{"version":3,"file":"9977.bundle.2adb0e3fbbd7756e9471.js","mappings":"gIAEA,MAAMA,EAAmB,mBAwBzB,SAASC,EAAWC,EAAYC,GAC5B,GAAKC,EAAA,GAAMC,aAAaH,GAGxB,OAAIE,EAAA,GAAMC,aAAaH,GAAYC,GACxBC,EAAA,GAAMC,aAAaH,GAAYC,GAAUG,YADpD,CAGJ,CACA,SAASC,EAAWC,EAAiBN,EAAYO,EAASN,GACtD,IAAKC,EAAA,GAAMC,aAAaH,GACpB,OAAO,KAEXE,EAAA,GAAMC,aAAaH,GAAYC,GAAY,CACvCO,SAAS,EACTJ,OAAQG,GAEZD,EAAgBG,YAAYF,EAChC,CACA,SAASG,EAAeV,EAAYC,GAC3BC,EAAA,GAAMC,aAAaH,IAGpBE,EAAA,GAAMC,aAAaH,GAAYC,KAC/BC,EAAA,GAAMC,aAAaH,GAAYC,GAAUO,SAAU,EAE3D,CACA,SAASG,EAAeL,EAAiBN,GAChCE,EAAA,GAAMC,aAAaH,IAGxBY,OAAOC,KAAKX,EAAA,GAAMC,aAAaH,IAAac,SAASb,IACjD,MAAMc,EAAab,EAAA,GAAMC,aAAaH,GAAYC,IAC7Cc,EAAWP,SAAWO,EAAWX,SAClCE,EAAgBU,YAAYD,EAAWX,eAChCF,EAAA,GAAMC,aAAaH,GAAYC,GAC1C,GAER,CACA,QA7DA,SAA6BgB,GACzB,MAAMC,GAAiB,IAAAC,mBAAkBF,IACnC,WAAEG,EAAU,kBAAEC,GAAsBH,EACpClB,EAAa,GAAGoB,KAAcC,IAC9Bf,EAaV,SAAsBW,GAClB,MAAMK,EAAkB,IAAIxB,IACtByB,EAAqBN,EAAQO,cAAcF,GAC3CG,EAAWF,GAAoBC,cAAc,uBACnD,OAAOC,CACX,CAlB4BC,CAAaT,GAIrC,OAHAL,OAAOC,KAAKX,EAAA,GAAMC,aAAaH,IAAac,SAASb,IACjDC,EAAA,GAAMC,aAAaH,GAAYC,GAAUO,SAAU,CAAK,IAErD,CACHF,gBAAiBA,EACjBqB,sBAAuBzB,EAAA,GAAMC,aAC7BJ,WAAYA,EAAW6B,KAAKC,KAAM7B,GAClCK,WAAYA,EAAWuB,KAAKC,KAAMvB,EAAiBN,GACnDU,eAAgBA,EAAekB,KAAKC,KAAM7B,GAC1CW,eAAgBA,EAAeiB,KAAKC,KAAMvB,EAAiBN,GAEnE,ECbA,QALA,SAAciB,EAASa,GACnB,MAAMC,EAAmB,EAAoBd,GAC7Ca,EAAGC,GACHA,EAAiBpB,gBACrB,C,wECoCA,QAtCA,SAAoBoB,EAAkBC,EAAeC,EAAWC,EAAQC,EAAQC,EAAU,CAAC,EAAGC,EAAS,IACnG,MAAM,MAAEC,EAAK,KAAEC,EAAI,MAAEC,EAAK,UAAEC,EAAS,SAAEC,EAAQ,YAAEC,EAAW,cAAEC,GAAmBhC,OAAOiC,OAAO,CAC3FP,MAAO,iBACPC,KAAM,cACNC,MAAO,IACPE,cAAUI,EACVL,eAAWK,EACXF,cAAe,EACfD,YAAa,GACdP,GACGW,EAAcN,GAAaD,EAE3BQ,GAAc,OAAShB,EAAe,SAAUC,GAChDgB,EAAwBlB,EAAiBhC,WAAWiD,GACpDE,EAAa,CACfC,GAAI,GAAGjB,EAAO,KACdkB,GAAI,GAAGlB,EAAO,KACdmB,EAAG,GAAGlB,IACNmB,OAAQhB,EACRC,OACA,eAAgBQ,EAChB,mBAAoBL,EACpB,eAAgBC,EAChB,iBAAkBC,GAEtB,GAAIK,GACA,OAAyBC,EAAYD,GACrClB,EAAiBrB,eAAesC,OAE/B,CACD,MAAMO,EAAmBC,SAASC,gBAnBxB,6BAmB+C,UAC1C,KAAXpB,GACAkB,EAAiBG,aAAa,UAAWrB,IAE7C,OAAwBa,EAAYK,GACpCxB,EAAiB1B,WAAWkD,EAAkBP,EAClD,CACJ,C,kDClCA,QALA,SAAqBjB,EAAkBC,EAAe2B,EAAgBC,EAAcxB,EAAU,CAAC,GAC3FwB,EAAa9C,SAAQ,CAAC+C,EAAQC,MAC1B,OAAW/B,EAAkBC,EAAe2B,EAAgBE,EAAQzB,EAAS0B,EAAE,GAEvF,C,uECoBA,QAvBA,SAAkB/B,EAAkBC,EAAe+B,EAASC,EAAwBC,EAAUC,EAAa9B,EAAU,CAAC,GAClH,MAAM+B,EAAQH,EAAuBI,OAAS,GACxC,EAAAC,EAAA,GAAiBL,EAAwBC,GACzCA,EACAK,EASV,SAA4BJ,GACxB,MAAQK,EAAGC,EAAMC,EAAGC,EAAG,OAAEC,EAAM,MAAEnC,GAAU0B,EACrCU,EAAYpC,EAAQ,EACpBqC,EAAaF,EAAS,EAK5B,MAAO,CAJW,CAACH,EAAOI,EAAWF,GAClB,CAACF,EAAME,EAAMG,GACX,CAACL,EAAOI,EAAWF,EAAMC,GAC1B,CAACH,EAAOhC,EAAOkC,EAAMG,GAE7C,CAlB8BC,CAAmBZ,GACvCa,GAAM,EAAAV,EAAA,GAAiBC,EAAmBH,GAC1Ca,EAAgBpE,OAAOiC,OAAO,CAChCP,MAAO,mBACPG,UAAW,IACXC,SAAU,OACXN,IACH,EAAA6C,EAAA,GAASlD,EAAkBC,EAAe,QAAQ+B,IAAWI,EAAOY,EAAKC,EAC7E,ECAA,QAZA,SAA2BjD,EAAkBC,EAAekD,EAAYC,EAAWC,EAAiBpB,EAAwBqB,EAASjD,EAAU,CAAC,GAC5I,MAAM4C,EAAgBpE,OAAOiC,OAAO,CAChCyC,aAAc,IACdC,UAAW,CACPhB,GAAG,EACHE,GAAG,IAERrC,GACGoD,GAAoB,EAAAC,EAAA,GAAY1D,EAAkBC,EAAekD,EAAYC,EAAWC,EAAiBJ,GAE/G,OADA,EAASjD,EAAkBC,EAAekD,EAAYlB,EAAwBoB,EAAiBI,EAAmBR,GAC3GQ,CACX,C,2DCXe,SAASE,EAAS3D,EAAkBC,EAAe2D,EAAcxB,EAAOY,EAAK3C,EAAU,CAAC,EAAGC,EAAS,IAC/G,MAAMuD,EAAU,CAACzB,EAAM,GAAIA,EAAM,IAC3B0B,EAAW,CAACd,EAAI,GAAIZ,EAAM,IAC1B2B,EAAa,CAAC3B,EAAM,GAAIY,EAAI,IAC5BgB,EAAc,CAAChB,EAAI,GAAIA,EAAI,KACjC,OAAsBhD,EAAkBC,EAAe2D,EAAc,CAACC,EAASC,EAAUC,EAAYC,GAAc3D,EAASC,EAChI,C,mFCqNA,MAAM2D,EAAoB,IAzN1B,MACI,WAAAC,GACIpE,KAAKqE,OAAS,CACVC,OAAQ,CAAC,EACTC,cAAe,CAAC,EAChBC,eAAgB,CAAC,EAEzB,CACA,QAAAC,CAASC,EAAWC,GAChB,MAAM,WAAEpF,EAAU,eAAEqF,EAAc,KAAEC,EAAI,aAAEC,GAAiBJ,EACrDK,EAAgB/E,KAAKgF,SAASN,GACpC,IAAIO,EAaJ,GALIA,EAPC1F,GAAeqF,EAOA5E,KAAKkF,kCAAkC,IAChDH,KACAJ,GACJE,GATa,IACTE,KACAJ,IASNE,EACD,MAAM,IAAIM,MAAM,mCAEpB,GAAI5F,EAAY,CACPS,KAAKqE,OAAOG,eAAejF,KAC5BS,KAAKqE,OAAOG,eAAejF,GAAc,CACrC6F,6BAA6B,EAC7BC,gBAAiB,CAAC,IAG1B,MAAMA,EAAkBrF,KAAKqE,OAAOG,eAAejF,GAAY8F,gBAC/D,GAAIT,EAAgB,CACXS,EAAgBT,KACjBS,EAAgBT,GAAkB,CAAC,GAElCS,EAAgBT,GAAgBC,KACjCQ,EAAgBT,GAAgBC,GAAQ,CAAC,GAE7C,MAAMS,EAAYD,EAAgBT,GAAgBC,QAC7B5D,IAAjB6D,GACKQ,EAAUC,aACXD,EAAUC,WAAa,CAAC,GAE5BD,EAAUC,WAAWT,GAAgBG,GAGrCK,EAAUE,YAAcP,CAEhC,KACK,CACD,MAAMQ,EAAwB,uBACzBJ,EAAgBI,KACjBJ,EAAgBI,GAAyB,CAAC,GAEzCJ,EAAgBI,GAAuBZ,KACxCQ,EAAgBI,GAAuBZ,GAAQ,CAAC,GAEpDQ,EAAgBI,GAAuBZ,GAAMW,YACzCP,CACR,CACJ,MACK,GAAIL,EAAgB,CAChB5E,KAAKqE,OAAOE,cAAcK,KAC3B5E,KAAKqE,OAAOE,cAAcK,GAAkB,CAAC,GAE5C5E,KAAKqE,OAAOE,cAAcK,GAAgBC,KAC3C7E,KAAKqE,OAAOE,cAAcK,GAAgBC,GAAQ,CAAC,GAEvD,MAAMa,EAAY1F,KAAKqE,OAAOE,cAAcK,GAAgBC,QACvC5D,IAAjB6D,GACKY,EAAUH,aACXG,EAAUH,WAAa,CAAC,GAE5BG,EAAUH,WAAWT,GAAgBG,GAGrCS,EAAUF,YAAcP,CAEhC,MAEIjF,KAAKqE,OAAOC,OAAOO,GAAQI,CAEnC,CACA,iCAAAC,CAAkCP,EAAQE,GACtC,MAAMc,EAAkB,IAAKhB,GAC7B,GAAIE,IAAS,8BAAkCe,SAAU,CACrD,MAAMC,EAAiBF,EACvBE,EAAeC,wBAA0BD,EAAeE,cACxDF,EAAeG,uBAAyBH,EAAeI,aACvDJ,EAAeK,qBAAuBL,EAAeM,WACrDN,EAAeO,oBAAsBP,EAAeQ,UACpDR,EAAeS,yBAA2BT,EAAeU,cAC7D,MACK,GAAI1B,IAAS,8BAAkC2B,QAAS,CACzD,MAAMC,EAAgBd,EACtBc,EAAcT,uBAAyBS,EAAcR,aACrDQ,EAAcH,yBAA2BG,EAAcF,eACvDE,EAAcC,sBAAwBD,EAAcE,YACpDF,EAAcX,wBAA0BW,EAAcV,cACtDU,EAAcP,qBAAuBO,EAAcN,WACnDM,EAAcL,oBAAsBK,EAAcJ,SACtD,CACA,OAAOV,CACX,CACA,QAAAX,CAASN,GACL,MAAM,WAAEnF,EAAU,eAAEqF,EAAc,KAAEC,EAAI,aAAEC,GAAiBJ,EAC3D,IAAIkC,EAAgB5G,KAAK6G,gBAAgBhC,GACrCO,GAA8B,EAoBlC,GAnBIpF,KAAKqE,OAAOC,OAAOO,KACnB+B,EAAgB,IACTA,KACA5G,KAAKqE,OAAOC,OAAOO,KAG1B7E,KAAKqE,OAAOE,cAAcK,KAAkBC,KAC5C+B,EAAgB,IACTA,KACA5G,KAAKqE,OAAOE,cAAcK,GAAgBC,GAAMW,kBAElCvE,IAAjB6D,GACA9E,KAAKqE,OAAOE,cAAcK,GAAgBC,GAAMU,aAAaT,KAC7D8B,EAAgB,IACTA,KACA5G,KAAKqE,OAAOE,cAAcK,GAAgBC,GAAMU,WAAWT,MAItEvF,GAAcS,KAAKqE,OAAOG,eAAejF,GAAa,CACtD6F,EACIpF,KAAKqE,OAAOG,eAAejF,GAAY6F,4BAC3C,MAAM0B,EAAsB,uBACxB9G,KAAKqE,OAAOG,eAAejF,GAAY8F,gBAAgByB,KAAuBjC,KAC9E+B,EAAgB,IACTA,KACA5G,KAAKqE,OAAOG,eAAejF,GAAY8F,gBAAgByB,GAAqBjC,GAAMW,cAGzFZ,GACA5E,KAAKqE,OAAOG,eAAejF,GAAY8F,gBAAgBT,KAAkBC,KACzE+B,EAAgB,IACTA,KACA5G,KAAKqE,OAAOG,eAAejF,GAAY8F,gBAAgBT,GAAgBC,GAAMW,kBAE/DvE,IAAjB6D,GACA9E,KAAKqE,OAAOG,eAAejF,GAAY8F,gBAAgBT,GAAgBC,GAAMU,aAAaT,KAC1F8B,EAAgB,IACTA,KACA5G,KAAKqE,OAAOG,eAAejF,GAAY8F,gBAAgBT,GAAgBC,GAAMU,WAAWT,KAI3G,CACA,OAAO8B,CACX,CACA,8BAAAG,CAA+BxH,GAC3B,OAAOS,KAAKqE,OAAOG,eAAejF,IAAa6F,2BACnD,CACA,8BAAA4B,CAA+BzH,EAAY6F,GAClCpF,KAAKqE,OAAOG,eAAejF,KAC5BS,KAAKqE,OAAOG,eAAejF,GAAc,CACrC6F,6BAA6B,EAC7BC,gBAAiB,CAAC,IAG1BrF,KAAKqE,OAAOG,eAAejF,GAAY6F,4BACnCA,CACR,CACA,eAAAyB,CAAgBhC,GACZ,OAAQA,GACJ,KAAK,8BAAkCe,SACnC,OAAO,SACX,KAAK,8BAAkCY,QACnC,OAAO,SACX,KAAK,8BAAkCS,QACnC,MAAO,CAAC,EACZ,QACI,MAAM,IAAI9B,MAAM,gCAAgCN,KAE5D,CACA,sBAAAqC,CAAuBtC,GACf5E,KAAKqE,OAAOE,cAAcK,WACnB5E,KAAKqE,OAAOE,cAAcK,EAEzC,CACA,0BAAAuC,GACInH,KAAKqE,OAAOE,cAAgB,CAAC,CACjC,CACA,kBAAA6C,CAAmB7H,GACXS,KAAKqE,OAAOG,eAAejF,WACpBS,KAAKqE,OAAOG,eAAejF,EAE1C,CACA,sBAAA8H,GACI,IAAK,MAAM9H,KAAcS,KAAKqE,OAAOG,eAAgB,CACjD,MACMY,EADgBpF,KAAKqE,OAAOG,eAAejF,GACC6F,4BAClDpF,KAAKqE,OAAOG,eAAejF,GAAc,CACrC6F,8BACAC,gBAAiB,CAAC,EAE1B,CACJ,CACA,kBAAAiC,GACItH,KAAKmH,6BACLnH,KAAKqH,wBACT,CACA,cAAAE,CAAe7C,GACX,MAAM,KAAEG,GAASH,EACX8C,EAAQxH,KAAKgF,SAASN,GACtB+C,EAAezH,KAAK6G,gBAAgBhC,GAC1C,OAAQ,EAAA6C,UAAA,UAAoBF,EAAOC,EACvC,E,wECxNG,SAASE,EAAgC/C,EAAgBgD,EAAqB9C,GACjF,MAAM+C,EAAc,CAChBjD,iBACAgD,sBACA9C,iBAEJ,QAAqBF,IACrB,IAAAkD,cAAa,EAAAC,YAAa,EAAAC,OAAOC,2BAA4BJ,EACjE,C,kDCVO,SAASK,EAAsB3I,GAElC,OADiC,KACD2I,sBAAsB3I,EAC1D,C,kDCHO,SAAS4I,EAAwC5I,EAAYmF,GAEhE,OADiC,KACDyD,wCAAwC5I,EAAYmF,EACxF,C,6DC2BA,QA7BA,UAAuC,eAAEE,EAAc,KAAEC,EAAI,KAAEuD,IAC3D,MAAMC,GAAe,OAAgBzD,GACrC,IAAKyD,EACD,MAAM,IAAIlD,MAAM,gBAAgBP,eAKpC,OAHIyD,EAAaC,mBAAmBzD,IAChC0D,QAAQC,KAAK,+BAA+B3D,qCAAwCD,sBAEhFC,GACJ,KAAK,IAA4Be,SAMjC,KAAK,IAA4BY,QAKjC,KAAK,IAA4BS,QACzBmB,IACAC,EAAaC,mBAAmBzD,GAAQuD,GAE5C,MACJ,QACI,MAAM,IAAIjD,MAAM,+BAA+BN,KAE3D,C,6DCbA,QAfA,SAAiCtF,EAAYC,GACpCA,IACDA,GAAoB,IAAAiJ,uBAAsBC,MAAMC,GAAOA,EAAGC,eAAeF,MAAMG,GAAOA,EAAGC,KAAOvJ,OAAcuJ,IAElH,MAAMC,EAAyB,KAAMC,WAAWC,QAAQC,GAAOA,EAAGC,cAAcC,MAAMP,GAAOA,EAAGrJ,oBAAsBA,KAChHqJ,EAAGtJ,YAAcsJ,EAAGtJ,aAAeA,OACzC,GAAKwJ,EAAuBxG,OAA5B,CAGA,GAAIwG,EAAuBxG,OAAS,EAChC,MAAM,IAAI4C,MAAM,qDAAqD3F,qBAAqCD,oFAG9G,OAAOwJ,EAAuB,EAL9B,CAMJ,C,wECbA,MAAMM,UAA8C,WACvCrJ,KAAKsJ,SAAW,uCAAyC,CAClE,WAAAlF,CAAYmF,GAORC,MANqB,EAAA9B,UAAA,UAAoB,CACrC+B,cAAe,CACXC,gBAAgB,EAChBC,mBAAmB,IAExBJ,GAEP,CACA,yBAAAK,GACI,OAAO,CACX,CACA,wBAAAC,CAAyBC,GACrB,MAAMC,EAAaD,EAAcC,YAC3B,YAAEC,GAAgBD,EAClBE,EAAeT,MAAMK,yBAAyBC,GACpD,GAAIE,EAAa,CACb,MAAM,eAAEpF,GAAmBmF,EAAW3B,KAAKC,cAC3C,IAAAV,iCAAgC/C,EACpC,CACA,OAAOqF,CACX,EAEJ,S,2SCHA,MAAM,sBAAEC,GAA0B,EAAAC,UAC5B,QAAEC,GAAY,EAAAC,UACdC,EAAqB,EAAIF,EAC/B,MAAMG,UAA8B,WACvBvK,KAAKsJ,SAAW,mBAAqB,CAC9C,WAAAlF,CAAYmF,EAAY,CAAC,EAAGiB,EAAmB,CAC3CC,0BAA2B,CAAC,QAAS,SACrChB,cAAe,CACXiB,gBAAgB,EAChBC,QAAQ,EACRC,2BAA2B,EAC3BC,+BAAgC,EAAAC,iBAAiBC,MACjDC,+BAAgC,CAC5BC,SAAS,EACT3K,OAAQ,GAEZqJ,mBAAmB,EACnBuB,sBAAuB,GACvBC,iCAAkC,EAClCC,eAAe,EACfC,mBAAoB,EACpBC,UAAW,CACPC,aAAa,EACbC,cAAc,EACdC,0BAA2B,GAC3BC,2BAA4B,IAEhCC,cAAe,CACXV,SAAS,EACTW,wBAAyB,MAE7BC,SAAU,CACNZ,SAAS,EACTa,QAAS,IAEbC,6BAA6B,EAC7BrC,gBAAgB,EAChBsC,aAAcC,EACdC,gBAAiB,EAAAC,wBAGrB3C,MAAMD,EAAWiB,GACjBxK,KAAKoM,WAAY,EACjBpM,KAAKqM,iBAAkB,EACvBrM,KAAKsM,eAAgB,EACrBtM,KAAKuM,iBAAoBC,IACrB,MAAM3E,EAAc2E,EAAIC,QAClB,QAAErN,GAAYyI,EACdkC,EAAa/J,KAAK0M,iBAAiBF,GACzCxM,KAAK2M,cAAc5C,EAAY3K,GAC/B,MAAMwN,GAAsB,IAAAC,gCAA+BzN,EAASY,KAAK8M,eAIzE,OAHA9M,KAAK+M,aAAaP,EAAKzC,EAAY6C,GACnCJ,EAAIQ,kBACJ,OAAsCJ,GAC/B7C,CAAU,EAErB/J,KAAKiN,uBAAyB,CAACT,EAAKzC,EAAY/H,KAC5C,MAAM6F,EAAc2E,EAAIC,QAClB,QAAErN,GAAYyI,EACd+E,GAAsB,IAAAC,gCAA+BzN,EAASY,KAAK8M,eACzE9M,KAAKkN,2BAA2BV,EAAKzC,EAAY6C,EAAqB5K,EAAO,EAEjFhC,KAAKmN,qBAAuB,CAACX,EAAKzC,KAC9B,MAAMlC,EAAc2E,EAAIC,QAClB,QAAErN,GAAYyI,EACd+E,GAAsB,IAAAC,gCAA+BzN,EAASY,KAAK8M,eACrE/C,EAAW3B,KAAKgF,QAAQC,OACxBrN,KAAKsN,0BAA0Bd,EAAKzC,EAAY6C,GAGhD5M,KAAKuN,wBAAwBf,EAAKzC,EAAY6C,GAElDJ,EAAIQ,gBAAgB,EAExBhN,KAAKwN,gBAAkB,CAACpO,EAAS2K,EAAY0D,EAAcC,KACvD,MAAMrO,GAAiB,IAAAC,mBAAkBF,IACnC,SAAEuO,GAAatO,GACb8K,SAAUyD,GAAW7D,EAAW3B,KAAKgF,QAC7C,IAAIS,EAAgBF,EAASG,cAAcF,EAAO,IAClD,IAAK,IAAI3L,EAAI,EAAGA,EAAI2L,EAAOrL,OAAQN,IAAK,CACpC,MAAM8L,EAAKF,EACLG,EAAKL,EAASG,cAAcF,EAAO3L,IAEzC,GADmBiI,EAAsBuD,EAAcM,EAAIC,EAAIN,GAE3D,OAAO,EAEXG,EAAgBG,CACpB,CACA,IAAKjE,EAAW3B,KAAKgF,QAAQC,OACzB,OAAO,EAEX,MAAMY,EAASN,EAASG,cAAcF,EAAO,IACvCM,EAAOP,EAASG,cAAcF,EAAOA,EAAOrL,OAAS,IAC3D,OAAO2H,EAAsBuD,EAAcQ,EAAQC,EAAMR,EAAU,EAEvE1N,KAAKmO,OAAU/O,IACX,MAAMgN,EAAYpM,KAAKoM,UACjBE,EAAgBtM,KAAKsM,cACrBD,EAAkBrM,KAAKqM,gBACzBD,EACApM,KAAKoO,cAAchP,GAEdkN,EACLtM,KAAKqO,sBAAsBjP,GAEtBiN,GACLrM,KAAKsO,wBAAwBlP,EACjC,EAEJY,KAAKuO,sBAAwB,CAACxE,EAAY4D,EAAUa,EAAiBnP,KACjE,MAAM,KAAE+I,GAAS2B,GACX,YAAE0E,GAAgBrG,GAChB+B,SAAUyD,EAAM,OAAEP,GAAWjF,EAAKgF,QACpCsB,EAAY3P,OAAOC,KAAKyP,GAC9B,IAAK,IAAIxM,EAAI,EAAGA,EAAIyM,EAAUnM,OAAQN,IAAK,CACvC,MAAM0M,EAAWD,EAAUzM,GACrB2M,EAAQ5O,KAAK6O,mBAAmBF,GACtC,IAAKC,EACD,SAEJ,MAAM,UAAEE,EAAS,SAAEC,GAAaH,EAC1BI,EAAoBpB,EAAOqB,KAAKC,GAAMvB,EAASG,cAAcoB,KAC7DC,EAAsB,CACxBC,aAAa,OAAoBzB,EAAUgB,GAC3CU,YAAarP,KAAKqP,YAAY1B,EAAUgB,EAAU5E,EAAWgF,SAASO,oBAEpEC,GAAe,OAAmBR,EAASS,SAAUzF,EAAWgF,SAASO,kBAAmBH,GAC5FM,GAAkB,QAAiCb,GAAO,KAC5D,MAAMzE,EAAW/B,EAAKgF,QAAQjD,SACxBuF,EAAYvF,EAAS5H,OACrBoN,EAAoB,IAAIC,MAAMF,GACpC,IAAK,IAAIzN,EAAI,EAAGA,EAAIyN,EAAWzN,IAC3B0N,EAAkB1N,GAAK0L,EAASG,cAAc3D,EAASlI,IAE3D,MAAQ4N,KAAMC,EAAYC,KAAMC,EAAYC,KAAMC,EAAYC,KAAMC,GAAgB,mBAAsBT,GACpGU,EAAiB1C,EAAS2C,cAAc,CAACJ,EAAYE,IACrDG,EAAiB,kCAA8BzB,EAAWuB,GAC1DG,EAAqB7C,EAAS2C,cAAc,CAC9CR,EACAE,IAGJ,MAAO,CAACO,EADmB,kCAA8BzB,EAAW0B,GACzB,IAE3CnD,EACArN,KAAKyQ,wBAAwB,CACzB9B,WACAhB,WACAqB,oBACApB,SACAkB,YACAC,WACAN,cACAc,eACAE,oBAIJzP,KAAK0Q,sBAAsB,CACvB3B,WACAC,oBACAL,WACAF,cACAc,eACAE,mBAGZ,CACA,MAAMzF,EAAcD,EAAWC,YAK/B,OAJAD,EAAWC,aAAc,EACrBA,IACA,IAAA2G,2BAA0B5G,EAAY1K,EAAesO,SAASvO,QAAS,EAAAwR,YAAYC,cAEhFpC,CAAW,EAEtBzO,KAAK8Q,aAAe,CAAC/G,EAAY4D,EAAUtO,EAAgBa,KACvD,MAAM,KAAEkI,GAAS2B,EACX4E,EAAW3O,KAAK+Q,YAAYpD,GAC5BqD,EAAiB,CACnBC,YAAajR,KAAKiR,YAClB3H,SAAUtJ,KAAK8M,cACfvN,WAAYF,EAAesO,SAAS7E,IAElCvI,EAAUP,KAAKkR,sBAAsBF,EAAgBjH,GAC3D,IAAKxJ,EAAQ4Q,WACT,OAEJ,MAAM7N,EAAYtD,KAAKyJ,cAAcuC,aAAa5D,EAAMuG,GACxD,IAAKrL,GAAkC,IAArBA,EAAUf,OACxB,OAEJ,MAAMyM,EAAoB5G,EAAKgF,QAAQjD,SAAS8E,KAAKC,GAAMvB,EAASG,cAAcoB,KAClF,IAAK9G,EAAKgJ,QAAQ5N,QAAQ6N,SAAU,CAChC,MAAMC,GAAsB,IAAAC,wBAAuBvC,GACnD5G,EAAKgJ,QAAQ5N,QAAQgO,cACjB7D,EAAS2C,cAAcgB,EAC/B,CACA,MAAM/N,EAAkBoK,EAASG,cAAc1F,EAAKgJ,QAAQ5N,QAAQgO,eAE9DnP,GAAc,IAAAoP,mBAAkBvR,EAAkB6J,EAAW5J,eAAiB,GADjE,IACiFmD,EAAWC,EAAiByL,EAAmB,CAAC,EAAGzO,IAC/ImC,EAAGC,EAAMC,EAAGC,EAAG,MAAElC,EAAK,OAAEmC,GAAWT,EAC3C+F,EAAKgJ,QAAQ5N,QAAQkO,iBAAmB,CACpC3N,QAAS4J,EAAS2C,cAAc,CAAC3N,EAAME,IACvCmB,SAAU2J,EAAS2C,cAAc,CAAC3N,EAAOhC,EAAOkC,IAChDoB,WAAY0J,EAAS2C,cAAc,CAAC3N,EAAME,EAAMC,IAChDoB,YAAayJ,EAAS2C,cAAc,CAAC3N,EAAOhC,EAAOkC,EAAMC,IAC5D,GAEL,OAAiB9C,OACjB,OAAuBA,OACvB,OAA8BA,OAC9B,OAA4BA,OAC5B,OAA+BA,OAC/B,OAAsBA,MACtBA,KAAK2R,gCAAiC,OAAS3R,KAAKuO,sBAAuB,IAAK,CAAEqD,UAAU,GAChG,CACA,uCAAAC,CAAwCzS,EAAS0S,GAC7C,IAAKA,IAAgBA,EAAYvP,OAC7B,OAEJ,MAAMlD,GAAiB,IAAAC,mBAAkBF,IACnC,SAAEuO,GAAatO,EACrB,IAAI0S,EACJ,GAAIpE,aAAoB,EAAAqE,eAAgB,CACpC,MAAMC,EAAStE,EAASuE,aAClB,yBAAEC,GAA6B,iDAA6CxE,EAAUsE,GAC5FF,EAAuB/R,KAAKoS,6BAA6BN,EAAaG,EAAQE,EAClF,MAEIJ,GAAuB,IAAAM,6BAA4B1E,EAAUmE,GAEjE,OAAOC,CACX,CACA,4BAAAK,CAA6BN,EAAaG,EAAQE,GAC9C,MAAM,gBAAEG,GAAoBL,EACtBM,EAAiCT,EAAY7I,QAAQuJ,IACvD,MAAMC,EAA4BD,EAAGzD,SAASuD,gBACxCI,EAAaC,KAAKC,IAAI,SAASN,EAAiBG,IAClDnI,EACJ,OAAOmI,GAA6BC,CAAU,IAElD,IAAKH,EAA+BhQ,OAChC,MAAO,GAEX,MAAMsQ,EAA+BV,EAA2B,GAC1D,WAAEW,GAAeb,EACjBc,EAAyB,GAC/B,IAAK,MAAMhJ,KAAcwI,EAAgC,CACrD,MACMS,EADOjJ,EAAW3B,KACLgF,QAAQjD,SAAS,GACpC,IAAKJ,EAAWkJ,UACZ,SAEJ,MAAMC,EAAM,cACZ,SAASA,EAAKJ,EAAYE,GAC1B,MAAMG,EAAM,SAASD,EAAKZ,GACtBK,KAAKC,IAAIO,GAAON,GAChBE,EAAuBK,KAAKrJ,EAEpC,CACA,OAAOgJ,CACX,CACA,yBAAAnJ,GACI,OAAO,CACX,CACA,gBAAA8C,CAAiBF,GACb,MAAM6G,EAAW7G,EAAIC,OAAO6G,cAAcC,MACpCC,EAAoBhK,MAAMkD,iBAAiBF,GAcjD,OAVmB,sBAAkBgH,EAAmB,CACpDpL,KAAM,CACFgF,QAAS,CACLjD,SAAU,CAAC,IAAIkJ,KAEnBI,MAAO,GACPhF,YAAa,CAAC,GAElB7C,wBAX6B7B,IAC7BA,EAAW3B,KAAKgJ,QAAQxD,OAAOrL,OAAS,CAAC,GAajD,CACA,kBAAAmR,CAAmBC,GACf,OAAOnK,MAAMkK,mBAAmBC,EACpC,CACA,wBAAA9J,CAAyBC,GACrB,MAAM,eAAEzK,EAAc,SAAEsP,EAAQ,iBAAEzO,GAAqB4J,EACjDC,EAAaD,EAAcC,WACjC,IAAI6J,GAAe,EACnB,MAAM,SAAEjG,EAAQ,gBAAEa,GAAoBnP,EAChC+M,EAAYpM,KAAKoM,UACjBE,EAAgBtM,KAAKsM,cACrBD,EAAkBrM,KAAKqM,gBAC7B,GAAMD,GAAaE,GAAiBD,EAS/B,CACD,MAAMwH,EAAsB7T,KAAK8T,WAAW/J,WAAW5J,cACvD,GAAI4J,EAAW5J,gBAAkB0T,EAC7B,GAAIzH,EACApM,KAAK+T,wBAAwB1U,EAAgBa,EAAkB6J,QAE9D,GAAIsC,EACLrM,KAAKgU,+BAA+B3U,EAAgBa,EAAkB6J,OAErE,KAAIuC,EAIL,MAAM,IAAInH,MAAM,WAAWnF,KAAK8M,4CAHhC9M,KAAKiU,6BAA6B5U,EAAgBa,EAAkB6J,EAIxE,MAGI/J,KAAKyJ,cAAcsC,6BACyB,IAA5ChC,EAAW3B,KAAKgF,QAAQjD,SAAS5H,OACjCvC,KAAKkU,6BAA6B7U,EAAgBa,EAAkB6J,GAGpE/J,KAAKmU,cAAc9U,EAAgBa,EAAkB6J,GAG7D6J,GAAe,CACnB,MAlCQ5T,KAAKyJ,cAAcsC,6BACyB,IAA5ChC,EAAW3B,KAAKgF,QAAQjD,SAAS5H,OACjCvC,KAAKkU,6BAA6B7U,EAAgBa,EAAkB6J,GAGpE/J,KAAKmU,cAAc9U,EAAgBa,EAAkB6J,GA8B7D,GAAK/J,KAAKyJ,cAAcC,eAKxB,OAFA1J,KAAKoU,wBAAwBrK,EAAY4E,EAAUhB,EAAUa,EAAiBnP,GAC9EW,KAAK8Q,aAAa/G,EAAY4D,EAAUtO,EAAgBa,GACjD0T,CACX,CACA,uBAAAQ,CAAwBrK,EAAY4E,EAAUhB,EAAUa,EAAiBnP,GACrE,MAAMwU,EAAsB7T,KAAK8T,YAAY/J,WAAW5J,cACxD,IAAI4J,EAAW5J,gBAAkB0T,GAC5B7T,KAAK8T,YAAYO,iBAGjBrU,KAAK8T,YAAYO,cAAe,CACjC,MAAM,KAAEjM,GAAS2B,EACZ3B,EAAKqG,YAAYE,IAAW2F,KAYxBvK,EAAWC,aAChBhK,KAAK2R,+BAA+B5H,EAAY4D,EAAUa,EAAiBnP,IAZ3E+I,EAAKqG,YAAYE,GAAY,CACzBa,SAAU,KACV+E,KAAM,KACNC,IAAK,KACLC,KAAM,KACNC,OAAQ,KACRC,SAAU,KACVL,KAAM,MAEVtU,KAAKuO,sBAAsBxE,EAAY4D,EAAUa,EAAiBnP,GAK1E,CACJ,CACA,uBAAAoR,EAAwB,SAAE9C,EAAQ,OAAEC,EAAM,UAAEkB,EAAS,SAAEC,EAAQ,YAAEN,EAAW,SAAEE,EAAQ,aAAEY,EAAY,kBAAEP,EAAiB,gBAAES,IACrH,MAAM,MAAEmF,EAAK,SAAED,EAAQ,KAAEL,GAAS7E,GAC5B,aAAEoF,GAAiBlH,EAASmH,eAC5BC,EAAc/F,EAAkB,GAChCgG,EAAqBrH,EAAS2C,cAAcyE,GAC5CE,EAActH,EAAS2C,cAAc,CACvCyE,EAAY,GAAK,EACjBA,EAAY,KAEVG,EAAcvH,EAAS2C,cAAc,CACvCyE,EAAY,GACZA,EAAY,GAAK,IAEfI,EAAW,cAAcH,EAAoBC,GAC7CG,EAAW,cAAcJ,EAAoBE,GAC7CG,EAAgB,kCAA8BvG,EAAWlB,EAAO,IACtEyH,EAAc,GAAK1C,KAAK2C,MAAMD,EAAc,IAC5CA,EAAc,GAAK1C,KAAK2C,MAAMD,EAAc,IAC5CA,EAAc,GAAK1C,KAAK2C,MAAMD,EAAc,IAC5C,IAAIE,EAAOF,EAAc,GACrBG,EAAOH,EAAc,GACrBI,EAAOJ,EAAc,GACrBK,EAAOL,EAAc,GACrBM,EAAON,EAAc,GACrBO,EAAOP,EAAc,GACzB,IAAK,IAAIQ,EAAI,EAAGA,EAAIjI,EAAOrL,OAAQsT,IAAK,CACpC,MAAMR,EAAgB,kCAA8BvG,EAAWlB,EAAOiI,IACtER,EAAc,GAAK1C,KAAK2C,MAAMD,EAAc,IAC5CA,EAAc,GAAK1C,KAAK2C,MAAMD,EAAc,IAC5CA,EAAc,GAAK1C,KAAK2C,MAAMD,EAAc,IAC5CE,EAAO5C,KAAKmD,IAAIP,EAAMF,EAAc,IACpCG,EAAO7C,KAAK6B,IAAIgB,EAAMH,EAAc,IACpCI,EAAO9C,KAAKmD,IAAIL,EAAMJ,EAAc,IACpCK,EAAO/C,KAAK6B,IAAIkB,EAAML,EAAc,IACpCM,EAAOhD,KAAKmD,IAAIH,EAAMN,EAAc,IACpCO,EAAOjD,KAAK6B,IAAIoB,EAAMP,EAAc,GACxC,CACA,MAAMU,EAAiB,kCAA8BjH,EAAWlB,EAAO,IACvEmI,EAAe,GAAKpD,KAAK2C,MAAMS,EAAe,IAC9CA,EAAe,GAAKpD,KAAK2C,MAAMS,EAAe,IAC9CA,EAAe,GAAKpD,KAAK2C,MAAMS,EAAe,IAC9C,IAAIxB,EAAO,EAAApK,SAAA,QAAiB6E,GAAqB4F,EAAQA,EACzDL,GAAQY,EAAWC,EACnB,MAAMY,EAAS,KAAQR,EAAOD,GACxBU,EAAS,KAAQP,EAAOD,GACxBS,EAAS,KAAQN,EAAOD,GAC9BJ,EAAO5C,KAAK2C,MAAMC,EAAOS,GACzBR,EAAO7C,KAAKwD,KAAKX,EAAOQ,GACxBP,EAAO9C,KAAK2C,MAAMG,EAAOQ,GACzBP,EAAO/C,KAAKwD,KAAKT,EAAOO,GACxBN,EAAOhD,KAAK2C,MAAMK,EAAOO,GACzBN,EAAOjD,KAAKwD,KAAKP,EAAOM,GACxB,MAAME,EAAY,CACd,CAACb,EAAMC,GACP,CAACC,EAAMC,GACP,CAACC,EAAMC,IAELS,EAAcvH,EAAUwH,aAAa,CAACd,EAAME,EAAME,IAClDW,EAAe5I,EAASG,cAAcuI,GAC5C,IAAIG,EAAS,EACTC,EAAgB,GAChBC,EAAsB,EAC1B,MAAMC,EAAgB9B,EAAa5V,QAAQe,KAAKyJ,cAAcyC,gBAAgB0K,cAAe,CACzF9H,YACA+H,WAAY,CAACC,EAAUC,KACnB,IAAIC,GAAS,EACb,MAAMhE,EAAQrF,EAASG,cAAcgJ,GAsBrC,OArBI9D,EAAM,IAAMwD,IACZE,EAAsB,EACtBF,EAASxD,EAAM,GACfyD,GAAgB,IAAAQ,wCAAuCjI,EAAmBgE,EAAO,CAACuD,EAAa,GAAIvD,EAAM,KACzGyD,EAAcS,MACH,SAAUC,EAAGC,GAChB,OAAOD,EAMZ,KANyBC,EAMzB,GALW,EACAD,EAIX,GAJsBC,EAItB,IAHgB,EACD,CACd,KAGJX,EAAclU,QAAUyQ,EAAM,GAAKyD,EAAc,GAAG,KACpDA,EAAcY,QACdX,KAEAA,EAAsB,GAAM,IAC5BM,GAAS,GAENA,CAAM,EAEjBZ,YACAkB,aAActX,KAAKyJ,cAAciB,iBAE/B6M,EAAQvX,KAAKyJ,cAAcyC,gBAAgBsL,gBACjD/I,EAAYE,GAAY,CACpBa,SAAUT,EAASS,SACnB+E,OACAkD,WAAW,OAAmBzI,EAAmB3B,QAAUuH,EAC3DH,KAAM8C,EAAM9C,MAAMiD,MAClBlD,IAAK+C,EAAM/C,KAAKkD,MAChBhD,OAAQ6C,EAAM7C,QAAQgD,MACtBC,WAAYJ,EAAMK,MAClBjB,cAAeA,EACfhC,WACApF,eACA+E,OAER,CACA,qBAAA5D,EAAsB,SAAE/B,EAAQ,SAAEI,EAAQ,kBAAEC,EAAiB,YAAEP,EAAW,aAAEc,EAAY,gBAAEE,IACtF,MAAM,MAAEmF,EAAK,KAAEN,GAAS7E,EACxBhB,EAAYE,GAAY,CACpBa,SAAUT,EAASS,SACnBjN,QAAQ,OAAmByM,GAAmB,GAAS4F,EACvDrF,eACA+E,OAER,EAEJ,SAASrI,EAAoB7D,EAAMuG,GAC/B,MAAMkJ,EAAoBzP,EAAKqG,YAAYE,IACrC,KAAE4F,EAAI,KAAEE,EAAI,OAAEC,EAAM,OAAEnS,EAAM,UAAEkV,EAAS,IAAEjD,EAAG,YAAEsD,EAAW,KAAExD,EAAI,SAAEK,EAAQ,aAAEpF,GAAkBsI,GAAqB,CAAC,EACnHvU,EAAY,GAClB,GAAIiR,EAAM,CACN,MAAMwD,EAAWD,EACX,8BACA,SAAS,wBAAoBvD,MAASI,IAC5CrR,EAAU8P,KAAK2E,EACnB,CAgBA,OAfItD,GACAnR,EAAU8P,KAAK,SAAS,wBAAoBqB,MAASlF,KAErDyI,OAAOC,SAASzD,IAChBlR,EAAU8P,KAAK,QAAQ,wBAAoBoB,MAAQjF,KAEnDmF,GACApR,EAAU8P,KAAK,YAAY,wBAAoBsB,MAAWnF,KAE1DkI,GACAnU,EAAU8P,KAAK,cAAc,wBAAoBqE,MAAcnD,KAE/D/R,GACAe,EAAU8P,KAAK,GAAG,wBAAoB7Q,MAAW+R,KAE9ChR,CACX,CACA,S,4PChgBA,MAAM,sBAAE4U,GAA0B,YAClC,MAAMC,UAAyB,YAClBnY,KAAKsJ,SAAW,cAAgB,CACzC,WAAAlF,CAAYmF,EAAY,CAAC,EAAGiB,EAAmB,CAC3CC,0BAA2B,CAAC,QAAS,SACrChB,cAAe,CACXiB,gBAAgB,EAChBC,QAAQ,EACRC,2BAA2B,EAC3BlB,gBAAgB,EAChBsC,aAAcC,EACdC,gBAAiB,EAAAC,wBAGrB3C,MAAMD,EAAWiB,GACjBxK,KAAKuM,iBAAoBC,IACrB,MAAM3E,EAAc2E,EAAIC,QAClB,cAAE6G,EAAa,QAAElU,GAAYyI,EAC7BwL,EAAWC,EAAcC,MACzBlU,GAAiB,IAAAC,mBAAkBF,IACnC,SAAEuO,GAAatO,EACrBW,KAAKoM,WAAY,EACjB,MAAMrC,EAAc/J,KAAgB,YAAEoY,4BAA4BzK,EAAU,CACxEvF,KAAM,CACFgJ,QAAS,CACLxD,OAAQ,CACJ,IAAIyF,GACJ,IAAIA,GACJ,IAAIA,GACJ,IAAIA,IAER7P,QAAS,CACL6N,UAAU,EACVG,cAAe,CAAC,EAAG,EAAG,GACtBE,iBAAkB,CACd3N,QAAS,CAAC,EAAG,EAAG,GAChBC,SAAU,CAAC,EAAG,EAAG,GACjBC,WAAY,CAAC,EAAG,EAAG,GACnBC,YAAa,CAAC,EAAG,EAAG,MAIhCuK,YAAa,CAAC,MAGtB,QAAc1E,EAAY3K,GAC1B,MAAMwN,GAAsB,IAAAC,gCAA+BzN,EAASY,KAAK8M,eAazE,OAZA9M,KAAKqY,SAAW,CACZtO,aACA6C,sBACA0L,YAAa,EACbjE,eAAe,EACfkE,eAAe,EACflH,UAAU,GAEdrR,KAAKwY,cAAcpZ,IACnB,IAAAqZ,mBAAkBrZ,GAClBoN,EAAIQ,kBACJ,OAAsCJ,GAC/B7C,CAAU,EAErB/J,KAAKwN,gBAAkB,CAACpO,EAAS2K,EAAY0D,EAAcC,KACvD,MAAMrO,GAAiB,IAAAC,mBAAkBF,IACnC,SAAEuO,GAAatO,GACf,KAAE+I,GAAS2B,GACX,OAAE6D,GAAWxF,EAAKgJ,QAClBsH,EAAe/K,EAASG,cAAcF,EAAO,IAC7C+K,EAAehL,EAASG,cAAcF,EAAO,IAC7CgL,EAAO5Y,KAAK6Y,8BAA8B,CAC5CH,EACAC,IAEE3F,EAAQ,CAACvF,EAAa,GAAIA,EAAa,KACvC,KAAE9K,EAAI,IAAEE,EAAG,MAAElC,EAAK,OAAEmC,GAAW8V,EAErC,OADwB,kBAA0B,CAACjW,EAAME,EAAKlC,EAAOmC,GAASkQ,IACvDtF,CAGX,EAEhB1N,KAAKmN,qBAAuB,CAACX,EAAKzC,KAC9B,MAAMlC,EAAc2E,EAAIC,QAClB,QAAErN,GAAYyI,EACpBkC,EAAW+O,aAAc,EACzB,MAAMlM,GAAsB,IAAAC,gCAA+BzN,EAASY,KAAK8M,eACzE9M,KAAKqY,SAAW,CACZtO,aACA6C,sBACAyH,eAAe,GAEnBrU,KAAK+Y,gBAAgB3Z,IACrB,IAAAqZ,mBAAkBrZ,GAClB,MAAMC,GAAiB,IAAAC,mBAAkBF,IACnC,gBAAEoP,GAAoBnP,GAC5B,OAAsCuN,GACtCJ,EAAIQ,gBAAgB,EAExBhN,KAAKiN,uBAAyB,CAACT,EAAKzC,EAAY/H,KAC5C,MAAM6F,EAAc2E,EAAIC,QAClB,QAAErN,GAAYyI,GACd,KAAEO,GAAS2B,EACjBA,EAAW+O,aAAc,EACzB,IACIR,EADAjE,GAAgB,EAEhBrS,EAAOwP,cACP6C,GAAgB,EAGhBiE,EAAclQ,EAAKgJ,QAAQxD,OAAOoL,WAAW9J,GAAMA,IAAMlN,IAE7D,MAAM4K,GAAsB,IAAAC,gCAA+BzN,EAASY,KAAK8M,eACzE9M,KAAKqY,SAAW,CACZtO,aACA6C,sBACA0L,cACAjE,iBAEJrU,KAAK+Y,gBAAgB3Z,IACrB,IAAAqZ,mBAAkBrZ,GAClB,MAAMC,GAAiB,IAAAC,mBAAkBF,IACnC,gBAAEoP,GAAoBnP,GAC5B,OAAsCuN,GACtCJ,EAAIQ,gBAAgB,EAExBhN,KAAKiZ,aAAgBzM,IACjB,MAAM3E,EAAc2E,EAAIC,QAClB,QAAErN,GAAYyI,GACd,WAAEkC,EAAU,oBAAE6C,EAAmB,cAAE2L,EAAa,SAAElH,GAAarR,KAAKqY,UACpE,KAAEjQ,GAAS2B,EACbwO,IAAkBlH,IAGtBjJ,EAAKgJ,QAAQ8H,kBAAoB,KACjClZ,KAAKmZ,kBAAkB/Z,GACvBY,KAAKoZ,gBAAgBha,IACrB,IAAAia,oBAAmBja,GACnBY,KAAKsZ,eACLtZ,KAAKqY,SAAW,KAChBrY,KAAKoM,WAAY,EACbpM,KAAKuZ,sBACLvZ,KAAKyJ,cAAcmB,4BACnB,QAAiBb,EAAW5J,gBAEhC,OAAsCyM,GAClC2L,IACA,IAAAiB,4BAA2BzP,GAC/B,EAEJ/J,KAAKyZ,cAAiBjN,IAClBxM,KAAKoM,WAAY,EACjB,MAAMvE,EAAc2E,EAAIC,QAClB,QAAErN,GAAYyI,GACd,WAAEkC,EAAU,oBAAE6C,EAAmB,YAAE0L,EAAW,cAAEjE,EAAa,cAAEkE,GAAmBvY,KAAKqY,SAC7FrY,KAAK0Z,WAAWta,EAAS2K,EAAY,CAAEwO,kBACvC,MAAM,KAAEnQ,GAAS2B,EACjB,GAAIsK,EAAe,CACf,MAAM,YAAEsF,GAAgB9R,EAClB+R,EAAgBD,EAAYpG,OAC5B,QAAE/P,GAAY4E,EAAKgJ,SACnB,cAAEI,GAAkBhO,EAC1BgO,EAAc,IAAMoI,EAAc,GAClCpI,EAAc,IAAMoI,EAAc,GAClCpI,EAAc,IAAMoI,EAAc,GAClCpW,EAAQ6N,UAAW,CACvB,MACK,QAAoBpQ,IAAhBqX,EAA2B,CAChC,MAAM,YAAEqB,GAAgB9R,EAClB+R,EAAgBD,EAAYpG,OAC5B,OAAE3F,GAAWxF,EAAKgJ,QACxBxD,EAAO3O,SAAS+T,IACZA,EAAM,IAAM4G,EAAc,GAC1B5G,EAAM,IAAM4G,EAAc,GAC1B5G,EAAM,IAAM4G,EAAc,EAAE,IAEhC7P,EAAWC,aAAc,CAC7B,KACK,CACD,MAAM,cAAEsJ,GAAkBzL,EACpBxI,GAAiB,IAAAC,mBAAkBF,IACnC,cAAE0O,EAAa,cAAEwC,GAAkBjR,EAAesO,SAClD0F,EAAWC,EAAcC,OACzB,OAAE3F,GAAWxF,EAAKgJ,QAExB,IAAIyI,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACJ,OATAxM,EAAO0K,GAAe,IAAIjF,GASlBiF,GACJ,KAAK,EACL,KAAK,EACDuB,EAAmB/L,EAAcF,EAAO,IACxCoM,EAAiBlM,EAAcF,EAAO,IACtCkM,EAAoB,CAACE,EAAe,GAAIH,EAAiB,IACzDE,EAAgB,CAACF,EAAiB,GAAIG,EAAe,IACrDE,EAAmB5J,EAAcwJ,GACjCK,EAAe7J,EAAcyJ,GAC7BnM,EAAO,GAAKsM,EACZtM,EAAO,GAAKuM,EACZ,MACJ,KAAK,EACL,KAAK,EACDL,EAAoBhM,EAAcF,EAAO,IACzCmM,EAAgBjM,EAAcF,EAAO,IACrCiM,EAAmB,CACfE,EAAc,GACdD,EAAkB,IAEtBE,EAAiB,CACbF,EAAkB,GAClBC,EAAc,IAElBE,EAAkB3J,EAAcuJ,GAChCO,EAAgB9J,EAAc0J,GAC9BpM,EAAO,GAAKqM,EACZrM,EAAO,GAAKwM,EAGpBrQ,EAAWC,aAAc,CAC7B,CACAhK,KAAKqY,SAAShH,UAAW,GACF,IAAA/R,mBAAkBF,IACzC,OAAsCwN,GAClC7C,EAAWC,cACX,IAAA2G,2BAA0B5G,EAAY3K,EAAS,EAAAwR,YAAYyJ,eAC/D,EAEJra,KAAKmO,OAAU/O,IACX,GAAIY,KAAKoM,UAAW,CAChBpM,KAAKoM,WAAY,EACjBpM,KAAKoZ,gBAAgBha,GACrBY,KAAKmZ,kBAAkB/Z,IACvB,IAAAia,oBAAmBja,GACnB,MAAM,WAAE2K,EAAU,oBAAE6C,EAAmB,cAAE2L,GAAkBvY,KAAKqY,UAC1D,KAAEjQ,GAAS2B,EAQjB,OAPAA,EAAW+O,aAAc,EACzB1Q,EAAKgJ,QAAQ8H,kBAAoB,MACjC,OAAsCtM,GAClC2L,IACA,IAAAiB,4BAA2BzP,GAE/B/J,KAAKqY,SAAW,KACTtO,EAAW5J,aACtB,GAEJH,KAAKwY,cAAiBpZ,IAClB,KAAMkb,uBAAwB,EAC9Blb,EAAQmb,iBAAiB,EAAAvS,OAAOwS,SAAUxa,KAAKiZ,cAC/C7Z,EAAQmb,iBAAiB,EAAAvS,OAAOyS,WAAYza,KAAKyZ,eACjDra,EAAQmb,iBAAiB,EAAAvS,OAAO0S,WAAY1a,KAAKyZ,eACjDra,EAAQmb,iBAAiB,EAAAvS,OAAO2S,YAAa3a,KAAKiZ,cAClD7Z,EAAQmb,iBAAiB,EAAAvS,OAAO4S,UAAW5a,KAAKiZ,cAChD7Z,EAAQmb,iBAAiB,EAAAvS,OAAO6S,WAAY7a,KAAKyZ,eACjDra,EAAQmb,iBAAiB,EAAAvS,OAAO8S,UAAW9a,KAAKiZ,aAAa,EAEjEjZ,KAAKoZ,gBAAmBha,IACpB,KAAMkb,uBAAwB,EAC9Blb,EAAQ2b,oBAAoB,EAAA/S,OAAOwS,SAAUxa,KAAKiZ,cAClD7Z,EAAQ2b,oBAAoB,EAAA/S,OAAOyS,WAAYza,KAAKyZ,eACpDra,EAAQ2b,oBAAoB,EAAA/S,OAAO0S,WAAY1a,KAAKyZ,eACpDra,EAAQ2b,oBAAoB,EAAA/S,OAAO2S,YAAa3a,KAAKiZ,cACrD7Z,EAAQ2b,oBAAoB,EAAA/S,OAAO4S,UAAW5a,KAAKiZ,cACnD7Z,EAAQ2b,oBAAoB,EAAA/S,OAAO6S,WAAY7a,KAAKyZ,eACpDra,EAAQ2b,oBAAoB,EAAA/S,OAAO8S,UAAW9a,KAAKiZ,aAAa,EAEpEjZ,KAAK+Y,gBAAmB3Z,IACpB,KAAMkb,uBAAwB,EAC9Blb,EAAQmb,iBAAiB,EAAAvS,OAAOwS,SAAUxa,KAAKiZ,cAC/C7Z,EAAQmb,iBAAiB,EAAAvS,OAAOyS,WAAYza,KAAKyZ,eACjDra,EAAQmb,iBAAiB,EAAAvS,OAAO2S,YAAa3a,KAAKiZ,cAClD7Z,EAAQmb,iBAAiB,EAAAvS,OAAO4S,UAAW5a,KAAKiZ,cAChD7Z,EAAQmb,iBAAiB,EAAAvS,OAAO6S,WAAY7a,KAAKyZ,eACjDra,EAAQmb,iBAAiB,EAAAvS,OAAO8S,UAAW9a,KAAKiZ,aAAa,EAEjEjZ,KAAKmZ,kBAAqB/Z,IACtB,KAAMkb,uBAAwB,EAC9Blb,EAAQ2b,oBAAoB,EAAA/S,OAAOwS,SAAUxa,KAAKiZ,cAClD7Z,EAAQ2b,oBAAoB,EAAA/S,OAAOyS,WAAYza,KAAKyZ,eACpDra,EAAQ2b,oBAAoB,EAAA/S,OAAO2S,YAAa3a,KAAKiZ,cACrD7Z,EAAQ2b,oBAAoB,EAAA/S,OAAO4S,UAAW5a,KAAKiZ,cACnD7Z,EAAQ2b,oBAAoB,EAAA/S,OAAO6S,WAAY7a,KAAKyZ,eACpDra,EAAQ2b,oBAAoB,EAAA/S,OAAO8S,UAAW9a,KAAKiZ,aAAa,EAEpEjZ,KAAKgb,iBAAmB,CAAC3b,EAAgBa,KACrC,IAAI0T,GAAe,EACnB,MAAM,SAAEjG,GAAatO,GACf,QAAED,GAAYuO,EACpB,IAAImE,GAAc,QAAe9R,KAAK8M,cAAe1N,GACrD,IAAK0S,GAAavP,OACd,OAAOqR,EAGX,GADA9B,EAAc9R,KAAK6R,wCAAwCzS,EAAS0S,IAC/DA,GAAavP,OACd,OAAOqR,EAEX,MAAMjF,EAAW3O,KAAK+Q,YAAYpD,GAC5Ba,EAAkBb,EAASsN,qBAC3BjK,EAAiB,CACnBC,YAAajR,KAAKiR,YAClB3H,SAAUtJ,KAAK8M,cACfvN,WAAYF,EAAesO,SAAS7E,IAExC,IAAK,IAAI7G,EAAI,EAAGA,EAAI6P,EAAYvP,OAAQN,IAAK,CACzC,MAAM8H,EAAa+H,EAAY7P,IACzB,cAAE9B,EAAa,KAAEiI,GAAS2B,GAC1B,OAAE6D,EAAM,kBAAEsL,GAAsB9Q,EAAKgJ,QACrCpC,EAAoBpB,EAAOqB,KAAKC,GAAMvB,EAASG,cAAcoB,KACnE8B,EAAe7Q,cAAgBA,EAC/B,MAAM,MAAEM,EAAK,UAAEG,EAAS,SAAEC,GAAab,KAAK0T,mBAAmB,CAC3D3J,aACAiH,oBAEE,gBAAEsB,EAAe,OAAE4I,GAAWvN,EAASuE,YAC7C,GAAK9J,EAAKqG,YAAYE,IACqB,MAAvCvG,EAAKqG,YAAYE,GAAUgG,UAW1B,GAAI5K,EAAWC,cAChBhK,KAAK2R,+BAA+B5H,EAAYuI,EAAiB4I,EAAQ1M,EAAiBnP,GACtFsO,aAAoB,EAAAqE,gBAAgB,CACpC,MAAM,kBAAE1C,GAAsBvF,EAAWgF,SACzC,IAAK,MAAMJ,KAAYvG,EAAKqG,YACxB,GAAIE,EAASwM,WAAW,WAAY,CACd3M,EAAgB4M,oBACC1S,MAAMG,IACrC,MAAMwS,EAAqB,yBAAqB/L,GAC1CgM,EAAczS,EAAGyS,YAAYD,GAC7BE,EAAkB,yBAAqB1S,EAAG2S,qBAChD,OAAOF,GAAeC,IAAoBF,CAAkB,YAGrDjT,EAAKqG,YAAYE,EAEhC,CAER,OA5BAvG,EAAKqG,YAAYE,GAAY,CACzBa,SAAU,KACV+E,KAAM,KACNC,IAAK,KACLC,KAAM,KACNC,OAAQ,KACRC,SAAU,MAEd3U,KAAKuO,sBAAsBxE,EAAYuI,EAAiB4I,EAAQ1M,EAAiBnP,GAsBrF,IAAKsO,EAASsN,qBAEV,OADA1S,QAAQC,KAAK,uCACNoL,EAEX,IAAI6H,EACJ,KAAK,IAAAC,qBAAoBvb,GACrB,SAOJ,IALK,IAAAwb,oBAAmBxb,IACnBH,KAAKqY,UACgB,OAAtBa,IACAuC,EAA2B,CAACzM,EAAkBkK,KAE9CuC,EAA0B,CAC1B,MAAM3Z,EAAiB,KACvB,IAAA8Z,aAAe1b,EAAkBC,EAAe2B,EAAgB2Z,EAA0B,CACtFhb,SAER,CACA,MAAMD,EAAS,GAAGL,SACZ2D,EAAe,KACrB,2BAAY5D,EAAkBC,EAAe2D,EAAckL,EAAmB,CAC1EvO,QACAI,WACAD,aACDJ,GACHoT,GAAe,EACf,MAAMrT,EAAUP,KAAKkR,sBAAsBF,EAAgBjH,GAC3D,IAAKxJ,EAAQ4Q,WAAY,CACrB/I,EAAKgJ,QAAQ5N,QAAU,CACnB6N,UAAU,EACVG,cAAe,CAAC,EAAG,EAAG,GACtBE,iBAAkB,CACd3N,QAAS,CAAC,EAAG,EAAG,GAChBC,SAAU,CAAC,EAAG,EAAG,GACjBC,WAAY,CAAC,EAAG,EAAG,GACnBC,YAAa,CAAC,EAAG,EAAG,KAG5B,QACJ,CACA,MAAMZ,EAAYtD,KAAKyJ,cAAcuC,aAAa5D,EAAMuG,GACxD,IAAKrL,GAAkC,IAArBA,EAAUf,OACxB,SAEJ,IAAK6F,EAAKgJ,QAAQ5N,QAAQ6N,SAAU,CAChC,MAAMC,GAAsB,IAAAC,wBAAuBvC,GACnD5G,EAAKgJ,QAAQ5N,QAAQgO,cACjB7D,EAAS2C,cAAcgB,EAC/B,CACA,MAAM/N,EAAkBoK,EAASG,cAAc1F,EAAKgJ,QAAQ5N,QAAQgO,eAC9DnO,EAAa,IACbhB,GAAc,IAAAoP,mBAAqBvR,EAAkBC,EAAekD,EAAYC,EAAWC,EAAiByL,EAAmB,CAAC,EAAGzO,IACjImC,EAAGC,EAAMC,EAAGC,EAAG,MAAElC,EAAK,OAAEmC,GAAWT,EAC3C+F,EAAKgJ,QAAQ5N,QAAQkO,iBAAmB,CACpC3N,QAAS4J,EAAS2C,cAAc,CAAC3N,EAAME,IACvCmB,SAAU2J,EAAS2C,cAAc,CAAC3N,EAAOhC,EAAOkC,IAChDoB,WAAY0J,EAAS2C,cAAc,CAAC3N,EAAME,EAAMC,IAChDoB,YAAayJ,EAAS2C,cAAc,CAAC3N,EAAOhC,EAAOkC,EAAMC,IAEjE,CACA,OAAO8Q,CAAY,EAEvB5T,KAAK6Y,8BAAiCjL,IAClC,MAAOiO,EAAQC,GAAUlO,EACzB,MAAO,CACHjL,KAAMgQ,KAAKmD,IAAI+F,EAAO,GAAIC,EAAO,IACjCjZ,IAAK8P,KAAKmD,IAAI+F,EAAO,GAAIC,EAAO,IAChCnb,MAAOgS,KAAKC,IAAIiJ,EAAO,GAAKC,EAAO,IACnChZ,OAAQ6P,KAAKC,IAAIiJ,EAAO,GAAKC,EAAO,IACvC,EAEL9b,KAAKuO,sBAAwB,CAACxE,EAAYuI,EAAiB4I,EAAQ1M,EAAiBnP,KAChF,IAAKW,KAAKyJ,cAAcC,eACpB,OAEJ,MAAM,KAAEtB,GAAS2B,GACX,SAAE4D,GAAatO,GACf,QAAED,GAAYuO,EACdoO,EAAY3T,EAAKgJ,QAAQxD,OAAO,GAChCoO,EAAY5T,EAAKgJ,QAAQxD,OAAO,IAChC,YAAEa,GAAgBrG,EAClBsG,EAAY3P,OAAOC,KAAKyP,GAC9B,IAAK,IAAIxM,EAAI,EAAGA,EAAIyM,EAAUnM,OAAQN,IAAK,CACvC,MAAM0M,EAAWD,EAAUzM,GACrB2M,EAAQ5O,KAAK6O,mBAAmBF,GACtC,IAAKC,EACD,SAEJ,MAAM,WAAEqN,EAAU,UAAEnN,EAAS,SAAEC,EAAQ,aAAE8F,GAAiBjG,EACpDsN,EAAYhE,EAAsBpJ,EAAWiN,GACnDG,EAAU,GAAKvJ,KAAK2C,MAAM4G,EAAU,IACpCA,EAAU,GAAKvJ,KAAK2C,MAAM4G,EAAU,IACpCA,EAAU,GAAKvJ,KAAK2C,MAAM4G,EAAU,IACpC,MAAMC,EAAYjE,EAAsBpJ,EAAWkN,GAInD,GAHAG,EAAU,GAAKxJ,KAAK2C,MAAM6G,EAAU,IACpCA,EAAU,GAAKxJ,KAAK2C,MAAM6G,EAAU,IACpCA,EAAU,GAAKxJ,KAAK2C,MAAM6G,EAAU,IAChCnc,KAAKoc,gBAAgBF,EAAWC,EAAWF,GAAa,CACxDjc,KAAKuZ,sBAAuB,EAC5B,MAMMnD,EAAY,CACd,CAPSzD,KAAKmD,IAAIoG,EAAU,GAAIC,EAAU,IACjCxJ,KAAK6B,IAAI0H,EAAU,GAAIC,EAAU,KAO1C,CANSxJ,KAAKmD,IAAIoG,EAAU,GAAIC,EAAU,IACjCxJ,KAAK6B,IAAI0H,EAAU,GAAIC,EAAU,KAM1C,CALSxJ,KAAKmD,IAAIoG,EAAU,GAAIC,EAAU,IACjCxJ,KAAK6B,IAAI0H,EAAU,GAAIC,EAAU,OAMxC,WAAEE,EAAU,YAAEC,IAAgB,OAAkChK,EAAiB4I,EAAQa,EAAWC,GACpG5K,EAAU,CAAC8K,EAAWC,IACtB,MAAEvH,EAAK,SAAED,IAAa,QAAiC/F,EAAOwC,GAC9DmD,EAAO5B,KAAKC,IAAIyJ,EAAaC,IAAgB1H,EAAQA,GACrD2H,EAAoB,CACtBnN,aAAa,OAAoBzB,EAAUgB,GAC3CU,YAAarP,KAAKqP,YAAY1B,EAAUgB,EAAU5E,EAAWgF,SAASO,oBAEpEC,GAAe,OAAmBR,EAASS,SAAUzF,EAAWgF,SAASO,kBAAmBiN,GAC5F5F,EAAgB9B,EAAa5V,QAAQe,KAAKyJ,cAAcyC,gBAAgB0K,cAAe,CACzFR,YACAtH,YACAwI,aAActX,KAAKyJ,cAAciB,iBAE/B6M,EAAQvX,KAAKyJ,cAAcyC,gBAAgBsL,gBACjD/I,EAAYE,GAAY,CACpBa,SAAUT,EAASS,SACnB+E,OACAE,KAAM8C,EAAM9C,MAAMiD,MAClBhD,OAAQ6C,EAAM7C,QAAQgD,MACtBlD,IAAK+C,EAAM/C,KAAKkD,MAChBC,WAAYJ,EAAMK,MAClBjB,cAAeA,EACfhC,WACApF,eAER,MAEIvP,KAAKuZ,sBAAuB,EAC5B9K,EAAYE,GAAY,CACpBa,SAAUT,EAASS,SAG/B,CACA,MAAMxF,EAAcD,EAAWC,YAK/B,OAJAD,EAAWC,aAAc,EACrBA,IACA,IAAA2G,2BAA0B5G,EAAY3K,EAAS,EAAAwR,YAAYC,cAExDpC,CAAW,EAEtBzO,KAAKoc,gBAAkB,CAACI,EAAQC,EAAQR,IAC5B,kCAA8BO,EAAQP,IAC1C,kCAA8BQ,EAAQR,GAE9Cjc,KAAK2R,gCAAiC,OAAS3R,KAAKuO,sBAAuB,IAAK,CAAEqD,UAAU,GAChG,QACS5R,KAAK0c,QAAU,CAACnd,EAAYqO,EAAQrN,KACzC,MAAMlB,GAAiB,IAAAsd,+BAA8Bpd,GACrD,IAAKF,EACD,OAEJ,MAAM,oBAAEud,EAAmB,kBAAEtN,EAAiB,gBAAEgD,EAAe,SAAEuK,EAAQ,SAAElP,GAAc3N,KAAK8c,YAAY3E,EAAkB9Y,EAAgBuO,EAAQrN,GAC9IwJ,EAAa,CACf5J,cAAeI,GAASJ,eAAiB,qBACzCiI,KAAM,CACFgJ,QAAS,CACLxD,SACAsL,kBAAmB,MAEvBzF,MAAO,GACPhF,YAAa,CAAC,GAElBqK,aAAa,EACbiE,eAAe,EACf/S,aAAa,EACbgT,UAAU,EACV/J,WAAW,EACXlE,SAAU,CACNzF,SAAUuT,EAAS/P,cACnBwF,kBACAsK,sBACAtN,uBACG/O,KAGX,QAAcwJ,EAAY4D,EAASvO,UACnC,OAAsC,CAACuO,EAAS7E,IAAI,CACrD,EAEP,SAASmD,EAAoB7D,EAAMuG,GAC/B,MAAMkJ,EAAoBzP,EAAKqG,YAAYE,IACrC,KAAE4F,EAAI,KAAEE,EAAI,IAAED,EAAG,OAAEE,EAAM,SAAEC,EAAQ,aAAEpF,GAAiBsI,EAC5D,GAAIpD,QACA,OAEJ,MAAMnR,EAAY,GAKlB,OAJAA,EAAU8P,KAAK,SAAS,wBAAoBmB,MAASI,KACrDrR,EAAU8P,KAAK,SAAS,wBAAoBqB,MAASlF,KACrDjM,EAAU8P,KAAK,QAAQ,wBAAoBoB,MAAQjF,KACnDjM,EAAU8P,KAAK,YAAY,wBAAoBsB,MAAWnF,KACnDjM,CACX,CACA,S,iOC3iBe,MAAM2Z,UAAyB,YACjCjd,KAAKkd,YAAc,CACxBC,QAAS,KACT/d,QAAS,KACTge,WAAY,EACZC,MAAO,KACPC,WAAY,CAACC,IAAKA,KAClBC,QAAQ,EACT,CACH,WAAApZ,CAAYmF,EAAWiB,GACnBhB,MAAMD,EAAWiB,GACjBxK,KAAKyd,QAAU,IAAIC,IACnB1d,KAAK2d,gBAAkB,IAAID,IAC3B1d,KAAK4d,uBAAyB,CAC1B9Y,aAAc,KACd+Y,iBAAiB,EACjBC,iBAAiB,EACjBC,eAAgB,GAExB,CACA,mBAAAC,CAAoBxR,GAChB,MAAM,GAAE1D,EAAE,cAAEmV,GAAkBzR,EAAIC,OAClC,GAAsB,aAAlBwR,EAAJ,CAGA,GAAIje,KAAK2d,gBAAgBO,IAAIpV,GAAK,CAC9B9I,KAAKme,WAAa,KAClB,MAAMC,EAAWpe,KAAK2d,gBAAgBU,IAAIvV,GACpC1J,EAAUgf,GAAUhf,QACpBkf,EAAgBte,KAAKue,iBAAiBnf,GAC5Ckf,EAAcxZ,aAAesZ,GAAUtZ,aACnC1F,GACAY,KAAKwe,6BAA4B,IAAAlf,mBAAkBF,GAAUkf,EAAe,EAAAG,kBAAkBC,cAEtG,CACA1e,KAAK2e,aAAanB,QAAS,CAX3B,CAYJ,CACA,gBAAImB,GACA,OAAO1B,EAAiBC,WAC5B,CACA,UAAAxD,CAAW9U,EAAgBga,GACvB,MAAMC,EAAiBD,EAAyB9V,GAChD,GAAI9I,KAAK8e,MACL9e,KAAK8e,KAAKF,2BAA6BA,EACvC,OAAO5e,KAAK8e,KAEhB,IAAIA,EAAO9e,KAAKyd,QAAQY,IAAIQ,GAY5B,OAXKC,EAKGA,EAAKC,mBACLD,EAAO,qBAAgCla,EAAgBga,GACvD5e,KAAKyd,QAAQuB,IAAIH,EAAgBC,KANrCA,EAAO,qBAAgCla,EAAgBga,GACvD5e,KAAKyd,QAAQuB,IAAIH,EAAgBC,IAQrC9e,KAAK8e,KAAOA,EACLA,CACX,CACA,cAAAG,CAAe7f,GACX,MAAMC,GAAiB,IAAAC,mBAAkBF,IACnC,SAAEuO,GAAatO,EACf6f,GAAqB,OAAsBvR,EAAS7E,IAC1D,IAAKoW,EAAoB,CACrB,MAAMC,EAAQ,IAAIC,YAAY,EAAAC,MAAA,OAAaC,YAAa,CACpD7S,OAAQ,CACJ5H,KAAM,eACN0a,QAAS,qGAEbC,YAAY,IAGhB,OADA,EAAAzX,YAAY0X,cAAcN,GACnB,IACX,CACA,MAAM,eAAEva,GAAmBsa,EACrBQ,GAAiB,IAAAC,yBAAwB/a,IACzC,mBAAE0D,IAAuB,OAAgB1D,GAO/C,OANiB5E,KAAK4f,YAAY,CAC9BjS,WACArF,qBACAoX,iBACA9a,kBAGR,CACA,WAAAgb,EAAY,SAAEjS,EAAQ,mBAAErF,EAAkB,eAAEoX,EAAc,eAAE9a,IACxD,GAAI+I,aAAoB,EAAAkS,mBAAoB,CACxC,MAAM,SAAEC,GAAaxX,EAAmB,IAA4B1C,UAC9Dma,EAASpS,EAASqS,YAExB,GADwBrS,aAAoB,IACvB,CACjB,MAAMwR,EAAQ,IAAIC,YAAY,EAAAC,MAAA,OAAaC,YAAa,CACpD7S,OAAQ,CACJ5H,KAAM,eACN0a,QAAS,2DAEbC,YAAY,IAGhB,OADA,EAAAzX,YAAY0X,cAAcN,GACnB,IACX,CACA,MAAMc,EAAUF,EAAO9Q,KAAKiR,GAAe,EAAAC,MAAMC,UAAUF,EAAWG,gBAChEC,EAAqB,EAAAH,MAAMC,UAAUN,GACrCS,EAAgCN,EAAQvX,MAAM8X,GAAW,oBAAgBA,EAAOvE,WAAYqE,EAAmBrE,eAAc6D,UAAYG,EAAQ,IAAIH,SAC3J,MAAO,CACHA,WACAW,mBAAoBzgB,KAAKyJ,cAAciX,WAAWZ,UAC9CS,EACJb,iBAER,CACK,CACD,MAAMiB,GAAsB,QAAqChT,EAAS7E,GAAIlE,GAC9E,IAAK+b,EACD,OAEJ,MAAO,CACHC,QAASD,EACTjB,iBAER,CACJ,CACA,eAAAmB,CAAgBzhB,EAAS0hB,GACrB,MAAMzhB,GAAiB,IAAAC,mBAAkBF,IACnC,SAAEuO,GAAatO,EACf4S,EAAStE,EAASuE,aAClB,gBAAEI,EAAe,OAAE4I,GAAWjJ,EAC9BrF,EAAsB,CAACe,EAAS7E,KAChC,aAAEhE,EAAY,eAAEF,EAAc,aAAEmc,GAAiB/gB,KAAKghB,0BAA0BrT,IAAa,CAAC,EAYpG,MAAO,CACHsT,YAZgB,CAChBlS,SAAU,CACNuD,gBAAiB,IAAIA,GACrB4I,OAAQ,IAAIA,GACZ0B,oBAAqBjP,EAASuT,yBAC9B5R,kBAAmB,GACnBhG,SAAUtJ,KAAK8M,cACfiU,gBAEJ3Y,KAAM,CAAC,GAIP0Y,eACAhc,eACA6I,WACA/I,iBACAmc,eACAnU,sBAER,CACA,yBAAAoU,CAA0BrT,GACtB,MAAMpO,EAAaoO,EAAS7E,GACtBqY,GAAuB,OAAsB5hB,GACnD,IAAK4hB,EACD,OAEJ,MAAM,eAAEvc,GAAmBuc,EACrBrc,GAAe,OAAsBF,GAC3C,IAAKE,EACD,OAGJ,MAAO,CACHA,eACAF,iBACAmc,cAJiB,IAAAK,sBAAqB7hB,EAAYqF,EAAgBE,GAM1E,CACA,gBAAAyZ,CAAiBnf,GACb,MAAMiZ,EAAWrY,KAAKqhB,WAAarhB,KAAKif,eAAe7f,IACjD,aAAE0F,EAAY,eAAEF,EAAc,YAAEqc,GAAgBjhB,KAAKme,YAAcne,KAAK6gB,gBAAgBzhB,IACxF,KAAEgJ,EAAI,SAAE2G,EAAW,CAAC,GAAMkS,GAAe,CAAC,GAC1C,gBAAE3O,EAAe,OAAE4I,GAAWnM,EAC9BuS,EAActhB,KAAKyJ,cAAc0T,SAASoE,gBAAgBzc,IAC1D,SAAE6I,IAAa,IAAArO,mBAAkBF,GACjC2hB,GAAe,IAAAK,sBAAqBzT,EAAS7E,GAAIlE,EAAgBE,GACvE,IAAKwc,IAAgBP,EACjB,OAEJ,IAAIS,EAAe,KAAMC,EAAsB,KAC3CzhB,KAAKyJ,cAAc0T,QAAQlS,UAC3BuW,EAAeF,GAqJ3B,SAAsB9f,EAAGkgB,EAAGtK,EAAGD,EAAGwK,EAAS,IACvC,MAAO,CACHhP,KAAKiP,MAAMpgB,GAAK,IAAMA,GAAKmgB,GAC3BhP,KAAKiP,MAAMF,GAAK,IAAMA,GAAKC,GAC3BhP,KAAKiP,MAAMxK,GAAK,IAAMA,GAAKuK,GAC3BxK,EAER,CA5J0C0K,IAAgBd,GAC9CU,EAAsB,KAkB1B,MAhBsB,IACfpJ,EACHzK,OAAQxF,GAAMgJ,SAASxD,OACvB9I,eACAwN,kBACAwP,gBAAiB9hB,KAAK2e,aAAanB,OACnCvM,YAAajR,KAAKiR,YAClBrM,iBACAsW,SACA0C,uBAAwB5d,KAAK4d,uBAC7BmE,eAAgB/hB,KAAKyJ,cAAcsY,eACnCtY,cAAezJ,KAAKyJ,cACpB+X,eACAC,sBACA/H,WAAY1Z,KAAK0Z,WAAW3Z,KAAKC,MAGzC,CACA,UAAAgiB,CAAW5iB,EAAUY,KAAK2e,aAAavf,QAASmB,GAC5C,MAAM,aAAEoe,GAAiB3e,KACnBiiB,EAAe1hB,GAAS0hB,cACT,IAAjBA,EACAjiB,KAAKkiB,cAAc9iB,IAEG,IAAjB6iB,GACLjiB,KAAKmiB,cAAc/iB,GAEvB,MAAMC,GAAiB,IAAAC,mBAAkBF,GACnCgjB,EAAUpiB,KAAKwe,4BAA4Bnf,EAAgBW,KAAKue,iBAAiBnf,GAAU,EAAAqf,kBAAkB4D,YAEnH,OADA1D,EAAanB,QAAS,EACf4E,CACX,CACA,aAAAD,CAAc/iB,EAAUY,KAAK2e,aAAavf,SACtC,IAAKA,EACD,OAEJY,KAAKsZ,eACL,MAAMja,GAAiB,IAAAC,mBAAkBF,GACzCY,KAAKwe,4BAA4Bnf,EAAgBW,KAAKue,iBAAiBnf,GAAU,EAAAqf,kBAAkB6D,eACnGtiB,KAAK2e,aAAaxB,QAAU,KAC5Bnd,KAAK2e,aAAanB,QAAS,CAC/B,CACA,aAAA0E,CAAc9iB,EAAUY,KAAK2e,aAAavf,SACtC,IAAKA,EACD,OAEJ,MAAMkf,EAAgBte,KAAKue,iBAAiBnf,GACxCY,KAAK8e,MAAQ9e,KAAK8e,KAAKhW,IACvB9I,KAAK2d,gBAAgBqB,IAAIhf,KAAK8e,KAAKhW,GAAI,CACnC1J,UACA0F,aAAcwZ,EAAcxZ,eAGpC,MAAMzF,GAAiB,IAAAC,mBAAkBF,GACzCY,KAAKwe,4BAA4Bnf,EAAgBif,EAAe,EAAAG,kBAAkBC,eAClF1e,KAAKsZ,eACLtZ,KAAK2e,aAAaxB,QAAU,KAC5Bnd,KAAK2e,aAAanB,QAAS,CAC/B,CACA,iCAAO+E,CAA2B5U,EAAUpN,GACxC,MAAMiiB,EAAiBjiB,GAASiiB,iBAAkB,EAC5C1Q,GAAc,IAAA2Q,qBACdC,GAAkB,IAAArQ,6BAA4B1E,EAAUmE,GAC9D,IAAK4Q,GAAiBngB,OAClB,OAEJ,MAAMogB,EAAqBD,EAAgBzZ,QAAQc,GAAeA,EAAW3B,KAAKgF,SAASjD,UAAU5H,SACrG,IAAKogB,EAAmBpgB,OACpB,OAEJ,MAQM4a,EARgB,IAAIF,EAAiB,CAAC,EAAG,CAC3CxT,cAAe,CACXmZ,WAAY,CACRC,mBAAoB,EAAAC,kBAExBf,eAAgB,wBAGMC,WAAWrU,EAASvO,UAC5C,KAAE0f,EAAI,eAAEla,GAAmBuY,EAC3B4F,EAAgBjE,GAAMjK,aACtBmO,EAAqBD,EAAcE,oBAAsBF,GACzD,WAAE9G,GAAe8G,EACjBjU,EAAYnB,EACbuV,kBACAC,MAAMC,YACNC,eACL,IAAK,MAAMtZ,KAAc4Y,EAAoB,CACzC,MAAMvM,EAAY,CACd,CAACkN,KAAWA,KACZ,CAACA,KAAWA,KACZ,CAACA,KAAWA,OAEV,SAAEnZ,GAAaJ,EAAW3B,KAAKgF,QACrC,IAAK,MAAM4F,KAAS7I,EAAU,CACP2E,EAAUyU,aAAavQ,GAC/B/T,SAAQ,CAACukB,EAAGC,KACnBrN,EAAUqN,GAAK,GAAK9Q,KAAKmD,IAAIM,EAAUqN,GAAK,GAAID,GAChDpN,EAAUqN,GAAK,GAAK9Q,KAAK6B,IAAI4B,EAAUqN,GAAK,GAAID,EAAE,GAE1D,CACApN,EAAUnX,SAAQ,CAACykB,EAAOD,KACtBC,EAAM,GAAK/Q,KAAKiP,MAAMjP,KAAK6B,IAAI,EAAGkP,EAAM,KACxCA,EAAM,GAAK/Q,KAAKiP,MAAMjP,KAAKmD,IAAImG,EAAWwH,GAAO,EAAGC,EAAM,IAAI,IAElE,MAAMC,GAAc,OAAsB/e,GACpC0Y,EAAavT,EAAW3B,KAAKgJ,UAAU,IAAMjH,EAAS,GACtDyZ,EAAa9U,EAAUyU,aAAajG,GAAYrO,IAAI0D,KAAKiP,OACzDiC,EAAab,EAAmBc,cAAcF,IAAe,EACnE,IAAIG,GAAe,EACfC,GAAmB,EACvB,IAAK,MAAMC,KAAa9Z,EAAU,CAC9B,MAAM+Z,EAAYpV,EAAUyU,aAAaU,GAAWhV,IAAI0D,KAAKiP,OACvDuC,EAAYnB,EAAmBc,cAAcI,GAC/CC,IAAcN,EACdE,GAAe,EAEVI,GAAa,IAClBH,GAAmB,EAE3B,CACA,MACMlf,EADUif,GAAgBC,EAE1BH,EACe,IAAfA,EACIF,EACA,EACV,IAAK,IAAI1hB,EAAImU,EAAU,GAAG,GAAInU,GAAKmU,EAAU,GAAG,GAAInU,IAChD,IAAK,IAAI4T,EAAIO,EAAU,GAAG,GAAIP,GAAKO,EAAU,GAAG,GAAIP,IAChD,IAAK,IAAIuO,EAAIhO,EAAU,GAAG,GAAIgO,GAAKhO,EAAU,GAAG,GAAIgO,IAAK,CACrD,MAAMC,EAAavV,EAAUwH,aAAa,CAACrU,EAAG4T,EAAGuO,KAC7B,IAAAE,yBAAwBD,EAAYla,IAEpD4Y,EAAcwB,SAAStiB,EAAG4T,EAAGuO,EAAGtf,EAExC,CAGJ0d,IACA,IAAAgC,kBAAiBza,EAAW5J,cAEpC,CACA,MAAMskB,EAAS1B,EAAc2B,4BAC7B,IAAA/c,iCAAgC/C,EAAgB6f,EACpD,E,kDCzVG,SAASE,EAAiC5a,GAC7C,GAAIA,EAAW6a,oBACX,OAEJ,IAAK7a,EAAW3B,KAAKC,aACjB,MAAM,IAAIlD,MAAM,kFAEpB,MAAM,eAAEP,EAAc,aAAEE,GAAiBiF,EAAW3B,KAAKC,aACnDA,GAAe,OAAgBzD,GAChCyD,EAAaC,mBAAmB9B,UACjC6B,EAAaC,mBAAmB9B,QAAU,CAAEqe,kBAAmB,IAAInH,MAEvE,IAAI,kBAAEmH,GAAsBxc,EAAaC,mBAAmB9B,QACvDqe,IACDA,EAAoB,IAAInH,KAE5B,IAAIoH,EAAqBD,GAAmBxG,IAAIvZ,GAC3CggB,IACDA,EAAqB,IAAIC,IACzBF,EAAkB7F,IAAIla,EAAcggB,IAExCD,EAAkB7F,IAAIla,EAAcggB,EAAmBE,IAAIjb,EAAW5J,eAC1E,C,kDCyFA,QA/GA,SAAkB8kB,EAAMC,EAAM3kB,GAC1B,IAAI4kB,EAAUC,EAAUC,EAASrO,EAAQsO,EAASC,EAC9CC,EAAiB,EACjBC,GAAU,EACVC,GAAS,EACT9T,GAAW,EACf,MAAM+T,GAAUT,GAAiB,IAATA,GAAsD,mBAAjCU,OAAOC,sBACpD,GAAoB,mBAATZ,EACP,MAAM,IAAIa,UAAU,uBASxB,SAASC,EAAWC,GAChB,MAAMC,EAAOd,EACPe,EAAUd,EAIhB,OAHAD,EAAWC,OAAWnkB,EACtBukB,EAAiBQ,EACjBhP,EAASiO,EAAKkB,MAAMD,EAASD,GACtBjP,CACX,CACA,SAASoP,EAAWC,EAAanB,GAC7B,OAAIS,EACOC,OAAOC,sBAAsBQ,GAEjCC,WAAWD,EAAanB,EACnC,CAoBA,SAASqB,EAAaP,GAClB,MAAMQ,EAAoBR,EAAOT,EAEjC,YAAyBtkB,IAAjBskB,GACJiB,GAAqBtB,GACrBsB,EAAoB,GACnBd,GAJuBM,EAAOR,GAIGH,CAC1C,CACA,SAASoB,IACL,MAAMT,EAAOU,KAAKC,MAClB,GAAIJ,EAAaP,GACb,OAAOY,EAAaZ,GAExBV,EAAUc,EAAWK,EArBzB,SAAuBT,GACnB,MACMa,EAAsBb,EAAOR,EAC7BsB,EAAc5B,GAFMc,EAAOT,GAGjC,OAAOG,EACD/S,KAAKmD,IAAIgR,EAAazB,EAAUwB,GAChCC,CACV,CAcuCC,CAAcf,GACrD,CACA,SAASY,EAAaZ,GAElB,OADAV,OAAUrkB,EACN2Q,GAAYuT,EACLY,EAAWC,IAEtBb,EAAWC,OAAWnkB,EACf+V,EACX,CAcA,SAASgQ,KAAaf,GAClB,MAAMD,EAAOU,KAAKC,MACZM,EAAaV,EAAaP,GAIhC,GAHAb,EAAWc,EACXb,EAAWplB,KACXulB,EAAeS,EACXiB,EAAY,CACZ,QAAgBhmB,IAAZqkB,EACA,OAzDZ,SAAqBU,GAGjB,OAFAR,EAAiBQ,EACjBV,EAAUc,EAAWK,EAAcvB,GAC5BO,EAAUM,EAAWC,GAAQhP,CACxC,CAqDmBkQ,CAAY3B,GAEvB,GAAIG,EAEA,OADAJ,EAAUc,EAAWK,EAAcvB,GAC5Ba,EAAWR,EAE1B,CAIA,YAHgBtkB,IAAZqkB,IACAA,EAAUc,EAAWK,EAAcvB,IAEhClO,CACX,CAIA,OAnGAkO,EAAOlN,OAAOkN,IAAS,GACnB,OAAS3kB,KACTklB,EAAU0B,QAAQ5mB,EAAQklB,SAC1BC,EAAS,YAAanlB,EACtB8kB,EAAUK,EAAS/S,KAAK6B,IAAIwD,OAAOzX,EAAQ8kB,UAAY,EAAGH,GAAQG,EAClEzT,EAAW,aAAcrR,EAAU4mB,QAAQ5mB,EAAQqR,UAAYA,GA2FnEoV,EAAU7Y,OAjCV,gBACoBlN,IAAZqkB,GA3CR,SAAqBxc,GACjB,GAAI6c,EACA,OAAOC,OAAOwB,qBAAqBte,GAEvCue,aAAave,EACjB,CAuCQwe,CAAYhC,GAEhBE,EAAiB,EACjBL,EAAWI,EAAeH,EAAWE,OAAUrkB,CACnD,EA4BA+lB,EAAUO,MA3BV,WACI,YAAmBtmB,IAAZqkB,EAAwBtO,EAAS4P,EAAaF,KAAKC,MAC9D,EA0BAK,EAAUQ,QAzBV,WACI,YAAmBvmB,IAAZqkB,CACX,EAwBO0B,CACX,C,iBC/Ge,SAASzV,EAAuBkW,GAC3C,MAAMC,EAKV,SAA2BC,GACvB,MAAMC,EAAqB,CAACD,EAAa,GAAIA,EAAa,IAAIzQ,KAAK2Q,GAC7DC,EAAqB,CAACH,EAAa,GAAIA,EAAa,IAAIzQ,KAAK6Q,GAC7DC,EAAQJ,EAAmBA,EAAmBrlB,OAAS,GACvDM,EAAMilB,EAAmB,GACzBG,EAASH,EAAmBA,EAAmBvlB,OAAS,GAC9D,MAAO,CACHM,MACAolB,SACAD,SAEJ,SAASH,EAAU1Q,EAAGC,GAClB,OAAOD,EAAE,GAAKC,EAAE,IAAM,EAAI,CAC9B,CACA,SAAS2Q,EAAU5Q,EAAGC,GAClB,OAAOD,EAAE,GAAKC,EAAE,IAAM,EAAI,CAC9B,CACJ,CAtBoB8Q,CAAkBT,GAC5BU,GAAWT,EAAQ7kB,IAAI,GAAK6kB,EAAQO,OAAO,IAAM,EAEvD,MADsB,CAACP,EAAQM,MAAM,GAAIG,EAE7C,C,kECJe,SAASC,EAAyBre,GAC7C,MAAMse,GAAY,OAA0Bte,GAC5C,OAAOse,EAAU9lB,OAAS8lB,EAAU,QAAKpnB,CAC7C,C,mCCAA,QAJA,SAAkByW,GACd,MAAM7S,SAAc6S,EACpB,OAAiB,OAAVA,IAA4B,WAAT7S,GAA8B,aAATA,EACnD,C,kBCHe,SAASyjB,EAAcC,EAAQzR,GAC1C,MAAM,OAAEzW,EAAM,OAAEC,GAAWioB,EACrBC,EAAUD,EAAOC,SAAWloB,EAASA,EAC3C,OAASwW,EAAS,GAAKzW,EAAO,KAAOyW,EAAS,GAAKzW,EAAO,KACrDyW,EAAS,GAAKzW,EAAO,KAAOyW,EAAS,GAAKzW,EAAO,KACjDyW,EAAS,GAAKzW,EAAO,KAAOyW,EAAS,GAAKzW,EAAO,KAClDmoB,CACR,C,4ECLA,MAAM,QAAEC,GAAY,YAIdC,EAAW,CAHH,gBAAgB,EAAG,EAAG,GACtB,gBAAgB,EAAG,EAAG,GACtB,gBAAgB,EAAG,EAAG,IAEpC,SAASC,EAAuBC,GAC5B,MAAMC,EAAgB,cAAc,cAAeD,EAAoB,GAAIA,EAAoB,IACzFE,EAAgB,cAAc,cAAeF,EAAoB,GAAIA,EAAoB,IAO/F,MAJkB,IAFCG,EAAwBF,EAAeH,MACvCK,EAAwBD,EAAeJ,IACTM,OAAOC,GAAUR,EAAQQ,EAAO,IAC7ER,EAAQQ,EAAO,KACfR,EAAQQ,EAAO,MACfR,EAAQQ,EAAO,MAEvB,CACA,SAASF,EAAwBG,EAAKC,GAClC,OAAOA,EAAKla,KAAKma,GAAkC,IAAxB,WAAWF,EAAKE,GAAezW,KAAK0W,IACnE,C,6DCFA,QAhBA,SAAkBpE,EAAMC,EAAM3kB,GAC1B,IAAIklB,GAAU,EACV7T,GAAW,EACf,GAAoB,mBAATqT,EACP,MAAM,IAAIa,UAAU,uBAMxB,OAJI,OAASvlB,KACTklB,EAAU,YAAallB,EAAU4mB,QAAQ5mB,EAAQklB,SAAWA,EAC5D7T,EAAW,aAAcrR,EAAU4mB,QAAQ5mB,EAAQqR,UAAYA,IAE5D,OAASqT,EAAMC,EAAM,CACxBO,UACA7T,WACAyT,QAASH,GAEjB,C,kDChBA,SAASoE,EAAoB3b,EAAUgB,GACnC,GAAIhB,aAAoB,EAAAkS,mBAAoB,CACxC,MAAMC,EAAW,EAAApY,UAAA,YAAsBiH,GACjC6R,EAAS,EAAAL,MAAMC,UAAUN,GAC/B,QAASU,GAAQ+I,SAAWxqB,OAAOC,KAAKwhB,EAAO+I,SAAShnB,OAAS,CACrE,CACK,GAAIoL,aAAoB,EAAA6b,cAAe,CACxC,MAAM,SAAEC,GAAa9b,EAASmH,gBAAkB,CAAC,EACjD,QAAS2U,GAAUC,MACvB,CAEI,OAAO,CAEf,C","sources":["webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/getSvgDrawingHelper.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/draw.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawCircle.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawHandles.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawLink.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawLinkedTextBox.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawRect.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/SegmentationStyle.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/events/triggerSegmentationDataModified.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getActiveSegmentation.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getSegmentationRepresentationVisibility.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/internalAddRepresentationData.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/store/ToolGroupManager/getToolGroupForViewport.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/PlanarFreehandContourSegmentationTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/PlanarFreehandROITool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/RectangleROITool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/LabelmapBaseTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contourSegmentation/addContourSegmentationAnnotation.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/debounce.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/drawing/getTextBoxCoordsCanvas.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/getViewportForAnnotation.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/isObject.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/sphere/pointInSphere.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/rectangleROITool/isAxisAlignedRectangle.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/throttle.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/viewport/isViewportPreScaled.js"],"sourcesContent":["import { state } from '../store/state';\nimport { getEnabledElement } from '@cornerstonejs/core';\nconst VIEWPORT_ELEMENT = 'viewport-element';\nfunction getSvgDrawingHelper(element) {\n    const enabledElement = getEnabledElement(element);\n    const { viewportId, renderingEngineId } = enabledElement;\n    const canvasHash = `${viewportId}:${renderingEngineId}`;\n    const svgLayerElement = _getSvgLayer(element);\n    Object.keys(state.svgNodeCache[canvasHash]).forEach((cacheKey) => {\n        state.svgNodeCache[canvasHash][cacheKey].touched = false;\n    });\n    return {\n        svgLayerElement: svgLayerElement,\n        svgNodeCacheForCanvas: state.svgNodeCache,\n        getSvgNode: getSvgNode.bind(this, canvasHash),\n        appendNode: appendNode.bind(this, svgLayerElement, canvasHash),\n        setNodeTouched: setNodeTouched.bind(this, canvasHash),\n        clearUntouched: clearUntouched.bind(this, svgLayerElement, canvasHash),\n    };\n}\nfunction _getSvgLayer(element) {\n    const viewportElement = `.${VIEWPORT_ELEMENT}`;\n    const internalDivElement = element.querySelector(viewportElement);\n    const svgLayer = internalDivElement?.querySelector(':scope > .svg-layer');\n    return svgLayer;\n}\nfunction getSvgNode(canvasHash, cacheKey) {\n    if (!state.svgNodeCache[canvasHash]) {\n        return;\n    }\n    if (state.svgNodeCache[canvasHash][cacheKey]) {\n        return state.svgNodeCache[canvasHash][cacheKey].domRef;\n    }\n}\nfunction appendNode(svgLayerElement, canvasHash, svgNode, cacheKey) {\n    if (!state.svgNodeCache[canvasHash]) {\n        return null;\n    }\n    state.svgNodeCache[canvasHash][cacheKey] = {\n        touched: true,\n        domRef: svgNode,\n    };\n    svgLayerElement.appendChild(svgNode);\n}\nfunction setNodeTouched(canvasHash, cacheKey) {\n    if (!state.svgNodeCache[canvasHash]) {\n        return;\n    }\n    if (state.svgNodeCache[canvasHash][cacheKey]) {\n        state.svgNodeCache[canvasHash][cacheKey].touched = true;\n    }\n}\nfunction clearUntouched(svgLayerElement, canvasHash) {\n    if (!state.svgNodeCache[canvasHash]) {\n        return;\n    }\n    Object.keys(state.svgNodeCache[canvasHash]).forEach((cacheKey) => {\n        const cacheEntry = state.svgNodeCache[canvasHash][cacheKey];\n        if (!cacheEntry.touched && cacheEntry.domRef) {\n            svgLayerElement.removeChild(cacheEntry.domRef);\n            delete state.svgNodeCache[canvasHash][cacheKey];\n        }\n    });\n}\nexport default getSvgDrawingHelper;\n","import getSvgDrawingHelper from './getSvgDrawingHelper';\nfunction draw(element, fn) {\n    const svgDrawingHelper = getSvgDrawingHelper(element);\n    fn(svgDrawingHelper);\n    svgDrawingHelper.clearUntouched();\n}\nexport default draw;\n","import _getHash from './_getHash';\nimport setAttributesIfNecessary from './setAttributesIfNecessary';\nimport setNewAttributesIfValid from './setNewAttributesIfValid';\nfunction drawCircle(svgDrawingHelper, annotationUID, circleUID, center, radius, options = {}, dataId = '') {\n    const { color, fill, width, lineWidth, lineDash, fillOpacity, strokeOpacity, } = Object.assign({\n        color: 'rgb(0, 255, 0)',\n        fill: 'transparent',\n        width: '2',\n        lineDash: undefined,\n        lineWidth: undefined,\n        strokeOpacity: 1,\n        fillOpacity: 1,\n    }, options);\n    const strokeWidth = lineWidth || width;\n    const svgns = 'http://www.w3.org/2000/svg';\n    const svgNodeHash = _getHash(annotationUID, 'circle', circleUID);\n    const existingCircleElement = svgDrawingHelper.getSvgNode(svgNodeHash);\n    const attributes = {\n        cx: `${center[0]}`,\n        cy: `${center[1]}`,\n        r: `${radius}`,\n        stroke: color,\n        fill,\n        'stroke-width': strokeWidth,\n        'stroke-dasharray': lineDash,\n        'fill-opacity': fillOpacity,\n        'stroke-opacity': strokeOpacity,\n    };\n    if (existingCircleElement) {\n        setAttributesIfNecessary(attributes, existingCircleElement);\n        svgDrawingHelper.setNodeTouched(svgNodeHash);\n    }\n    else {\n        const newCircleElement = document.createElementNS(svgns, 'circle');\n        if (dataId !== '') {\n            newCircleElement.setAttribute('data-id', dataId);\n        }\n        setNewAttributesIfValid(attributes, newCircleElement);\n        svgDrawingHelper.appendNode(newCircleElement, svgNodeHash);\n    }\n}\nexport default drawCircle;\n","import drawHandle from './drawHandle';\nfunction drawHandles(svgDrawingHelper, annotationUID, handleGroupUID, handlePoints, options = {}) {\n    handlePoints.forEach((handle, i) => {\n        drawHandle(svgDrawingHelper, annotationUID, handleGroupUID, handle, options, i);\n    });\n}\nexport default drawHandles;\n","import drawLine from './drawLine';\nimport findClosestPoint from '../utilities/math/vec2/findClosestPoint';\nfunction drawLink(svgDrawingHelper, annotationUID, linkUID, annotationAnchorPoints, refPoint, boundingBox, options = {}) {\n    const start = annotationAnchorPoints.length > 0\n        ? findClosestPoint(annotationAnchorPoints, refPoint)\n        : refPoint;\n    const boundingBoxPoints = _boundingBoxPoints(boundingBox);\n    const end = findClosestPoint(boundingBoxPoints, start);\n    const mergedOptions = Object.assign({\n        color: 'rgb(255, 255, 0)',\n        lineWidth: '1',\n        lineDash: '2,3',\n    }, options);\n    drawLine(svgDrawingHelper, annotationUID, `link-${linkUID}`, start, end, mergedOptions);\n}\nfunction _boundingBoxPoints(boundingBox) {\n    const { x: left, y: top, height, width } = boundingBox;\n    const halfWidth = width / 2;\n    const halfHeight = height / 2;\n    const topMiddle = [left + halfWidth, top];\n    const leftMiddle = [left, top + halfHeight];\n    const bottomMiddle = [left + halfWidth, top + height];\n    const rightMiddle = [left + width, top + halfHeight];\n    return [topMiddle, leftMiddle, bottomMiddle, rightMiddle];\n}\nexport default drawLink;\n","import drawTextBox from './drawTextBox';\nimport drawLink from './drawLink';\nfunction drawLinkedTextBox(svgDrawingHelper, annotationUID, textBoxUID, textLines, textBoxPosition, annotationAnchorPoints, textBox, options = {}) {\n    const mergedOptions = Object.assign({\n        handleRadius: '6',\n        centering: {\n            x: false,\n            y: true,\n        },\n    }, options);\n    const canvasBoundingBox = drawTextBox(svgDrawingHelper, annotationUID, textBoxUID, textLines, textBoxPosition, mergedOptions);\n    drawLink(svgDrawingHelper, annotationUID, textBoxUID, annotationAnchorPoints, textBoxPosition, canvasBoundingBox, mergedOptions);\n    return canvasBoundingBox;\n}\nexport default drawLinkedTextBox;\n","import _getHash from './_getHash';\nimport drawRectByCoordinates from './drawRectByCoordinates';\nexport default function drawRect(svgDrawingHelper, annotationUID, rectangleUID, start, end, options = {}, dataId = '') {\n    const topLeft = [start[0], start[1]];\n    const topRight = [end[0], start[1]];\n    const bottomLeft = [start[0], end[1]];\n    const bottomRight = [end[0], end[1]];\n    drawRectByCoordinates(svgDrawingHelper, annotationUID, rectangleUID, [topLeft, topRight, bottomLeft, bottomRight], options, dataId);\n}\n","import getDefaultContourConfig from '../../tools/displayTools/Contour/contourConfig';\nimport getDefaultLabelmapConfig from '../../tools/displayTools/Labelmap/labelmapConfig';\nimport * as Enums from '../../enums';\nimport { utilities } from '@cornerstonejs/core';\nclass SegmentationStyle {\n    constructor() {\n        this.config = {\n            global: {},\n            segmentations: {},\n            viewportsStyle: {},\n        };\n    }\n    setStyle(specifier, styles) {\n        const { viewportId, segmentationId, type, segmentIndex } = specifier;\n        const currentStyles = this.getStyle(specifier);\n        let updatedStyles;\n        if (!viewportId && !segmentationId) {\n            updatedStyles = {\n                ...currentStyles,\n                ...styles,\n            };\n        }\n        else {\n            updatedStyles = this.copyActiveToInactiveIfNotProvided({\n                ...currentStyles,\n                ...styles,\n            }, type);\n        }\n        if (!type) {\n            throw new Error('Type is required to set a style');\n        }\n        if (viewportId) {\n            if (!this.config.viewportsStyle[viewportId]) {\n                this.config.viewportsStyle[viewportId] = {\n                    renderInactiveSegmentations: false,\n                    representations: {},\n                };\n            }\n            const representations = this.config.viewportsStyle[viewportId].representations;\n            if (segmentationId) {\n                if (!representations[segmentationId]) {\n                    representations[segmentationId] = {};\n                }\n                if (!representations[segmentationId][type]) {\n                    representations[segmentationId][type] = {};\n                }\n                const repConfig = representations[segmentationId][type];\n                if (segmentIndex !== undefined) {\n                    if (!repConfig.perSegment) {\n                        repConfig.perSegment = {};\n                    }\n                    repConfig.perSegment[segmentIndex] = updatedStyles;\n                }\n                else {\n                    repConfig.allSegments = updatedStyles;\n                }\n            }\n            else {\n                const ALL_SEGMENTATIONS_KEY = '__allSegmentations__';\n                if (!representations[ALL_SEGMENTATIONS_KEY]) {\n                    representations[ALL_SEGMENTATIONS_KEY] = {};\n                }\n                if (!representations[ALL_SEGMENTATIONS_KEY][type]) {\n                    representations[ALL_SEGMENTATIONS_KEY][type] = {};\n                }\n                representations[ALL_SEGMENTATIONS_KEY][type].allSegments =\n                    updatedStyles;\n            }\n        }\n        else if (segmentationId) {\n            if (!this.config.segmentations[segmentationId]) {\n                this.config.segmentations[segmentationId] = {};\n            }\n            if (!this.config.segmentations[segmentationId][type]) {\n                this.config.segmentations[segmentationId][type] = {};\n            }\n            const segConfig = this.config.segmentations[segmentationId][type];\n            if (segmentIndex !== undefined) {\n                if (!segConfig.perSegment) {\n                    segConfig.perSegment = {};\n                }\n                segConfig.perSegment[segmentIndex] = updatedStyles;\n            }\n            else {\n                segConfig.allSegments = updatedStyles;\n            }\n        }\n        else {\n            this.config.global[type] = updatedStyles;\n        }\n    }\n    copyActiveToInactiveIfNotProvided(styles, type) {\n        const processedStyles = { ...styles };\n        if (type === Enums.SegmentationRepresentations.Labelmap) {\n            const labelmapStyles = processedStyles;\n            labelmapStyles.renderOutlineInactive ??= labelmapStyles.renderOutline;\n            labelmapStyles.outlineWidthInactive ??= labelmapStyles.outlineWidth;\n            labelmapStyles.renderFillInactive ??= labelmapStyles.renderFill;\n            labelmapStyles.fillAlphaInactive ??= labelmapStyles.fillAlpha;\n            labelmapStyles.outlineOpacityInactive ??= labelmapStyles.outlineOpacity;\n        }\n        else if (type === Enums.SegmentationRepresentations.Contour) {\n            const contourStyles = processedStyles;\n            contourStyles.outlineWidthInactive ??= contourStyles.outlineWidth;\n            contourStyles.outlineOpacityInactive ??= contourStyles.outlineOpacity;\n            contourStyles.outlineDashInactive ??= contourStyles.outlineDash;\n            contourStyles.renderOutlineInactive ??= contourStyles.renderOutline;\n            contourStyles.renderFillInactive ??= contourStyles.renderFill;\n            contourStyles.fillAlphaInactive ??= contourStyles.fillAlpha;\n        }\n        return processedStyles;\n    }\n    getStyle(specifier) {\n        const { viewportId, segmentationId, type, segmentIndex } = specifier;\n        let combinedStyle = this.getDefaultStyle(type);\n        let renderInactiveSegmentations = false;\n        if (this.config.global[type]) {\n            combinedStyle = {\n                ...combinedStyle,\n                ...this.config.global[type],\n            };\n        }\n        if (this.config.segmentations[segmentationId]?.[type]) {\n            combinedStyle = {\n                ...combinedStyle,\n                ...this.config.segmentations[segmentationId][type].allSegments,\n            };\n            if (segmentIndex !== undefined &&\n                this.config.segmentations[segmentationId][type].perSegment?.[segmentIndex]) {\n                combinedStyle = {\n                    ...combinedStyle,\n                    ...this.config.segmentations[segmentationId][type].perSegment[segmentIndex],\n                };\n            }\n        }\n        if (viewportId && this.config.viewportsStyle[viewportId]) {\n            renderInactiveSegmentations =\n                this.config.viewportsStyle[viewportId].renderInactiveSegmentations;\n            const allSegmentationsKey = '__allSegmentations__';\n            if (this.config.viewportsStyle[viewportId].representations[allSegmentationsKey]?.[type]) {\n                combinedStyle = {\n                    ...combinedStyle,\n                    ...this.config.viewportsStyle[viewportId].representations[allSegmentationsKey][type].allSegments,\n                };\n            }\n            if (segmentationId &&\n                this.config.viewportsStyle[viewportId].representations[segmentationId]?.[type]) {\n                combinedStyle = {\n                    ...combinedStyle,\n                    ...this.config.viewportsStyle[viewportId].representations[segmentationId][type].allSegments,\n                };\n                if (segmentIndex !== undefined &&\n                    this.config.viewportsStyle[viewportId].representations[segmentationId][type].perSegment?.[segmentIndex]) {\n                    combinedStyle = {\n                        ...combinedStyle,\n                        ...this.config.viewportsStyle[viewportId].representations[segmentationId][type].perSegment[segmentIndex],\n                    };\n                }\n            }\n        }\n        return combinedStyle;\n    }\n    getRenderInactiveSegmentations(viewportId) {\n        return this.config.viewportsStyle[viewportId]?.renderInactiveSegmentations;\n    }\n    setRenderInactiveSegmentations(viewportId, renderInactiveSegmentations) {\n        if (!this.config.viewportsStyle[viewportId]) {\n            this.config.viewportsStyle[viewportId] = {\n                renderInactiveSegmentations: false,\n                representations: {},\n            };\n        }\n        this.config.viewportsStyle[viewportId].renderInactiveSegmentations =\n            renderInactiveSegmentations;\n    }\n    getDefaultStyle(type) {\n        switch (type) {\n            case Enums.SegmentationRepresentations.Labelmap:\n                return getDefaultLabelmapConfig();\n            case Enums.SegmentationRepresentations.Contour:\n                return getDefaultContourConfig();\n            case Enums.SegmentationRepresentations.Surface:\n                return {};\n            default:\n                throw new Error(`Unknown representation type: ${type}`);\n        }\n    }\n    clearSegmentationStyle(segmentationId) {\n        if (this.config.segmentations[segmentationId]) {\n            delete this.config.segmentations[segmentationId];\n        }\n    }\n    clearAllSegmentationStyles() {\n        this.config.segmentations = {};\n    }\n    clearViewportStyle(viewportId) {\n        if (this.config.viewportsStyle[viewportId]) {\n            delete this.config.viewportsStyle[viewportId];\n        }\n    }\n    clearAllViewportStyles() {\n        for (const viewportId in this.config.viewportsStyle) {\n            const viewportStyle = this.config.viewportsStyle[viewportId];\n            const renderInactiveSegmentations = viewportStyle.renderInactiveSegmentations;\n            this.config.viewportsStyle[viewportId] = {\n                renderInactiveSegmentations,\n                representations: {},\n            };\n        }\n    }\n    resetToGlobalStyle() {\n        this.clearAllSegmentationStyles();\n        this.clearAllViewportStyles();\n    }\n    hasCustomStyle(specifier) {\n        const { type } = specifier;\n        const style = this.getStyle(specifier);\n        const defaultStyle = this.getDefaultStyle(type);\n        return !utilities.deepEqual(style, defaultStyle);\n    }\n}\nconst segmentationStyle = new SegmentationStyle();\nexport { segmentationStyle };\n","import { triggerEvent, eventTarget } from '@cornerstonejs/core';\nimport { Events } from '../../../enums';\nimport { setSegmentationDirty } from '../../../utilities/segmentation/utilities';\nexport function triggerSegmentationDataModified(segmentationId, modifiedSlicesToUse, segmentIndex) {\n    const eventDetail = {\n        segmentationId,\n        modifiedSlicesToUse,\n        segmentIndex,\n    };\n    setSegmentationDirty(segmentationId);\n    triggerEvent(eventTarget, Events.SEGMENTATION_DATA_MODIFIED, eventDetail);\n}\n","import { defaultSegmentationStateManager } from './SegmentationStateManager';\nexport function getActiveSegmentation(viewportId) {\n    const segmentationStateManager = defaultSegmentationStateManager;\n    return segmentationStateManager.getActiveSegmentation(viewportId);\n}\n","import { defaultSegmentationStateManager } from './SegmentationStateManager';\nexport function getSegmentationRepresentationVisibility(viewportId, specifier) {\n    const segmentationStateManager = defaultSegmentationStateManager;\n    return segmentationStateManager.getSegmentationRepresentationVisibility(viewportId, specifier);\n}\n","import { getSegmentation } from './getSegmentation';\nimport SegmentationRepresentations from '../../enums/SegmentationRepresentations';\nfunction internalAddRepresentationData({ segmentationId, type, data, }) {\n    const segmentation = getSegmentation(segmentationId);\n    if (!segmentation) {\n        throw new Error(`Segmentation ${segmentationId} not found`);\n    }\n    if (segmentation.representationData[type]) {\n        console.warn(`Representation data of type ${type} already exists for segmentation ${segmentationId}, overwriting it.`);\n    }\n    switch (type) {\n        case SegmentationRepresentations.Labelmap:\n            if (data) {\n                segmentation.representationData[type] =\n                    data;\n            }\n            break;\n        case SegmentationRepresentations.Contour:\n            if (data) {\n                segmentation.representationData[type] = data;\n            }\n            break;\n        case SegmentationRepresentations.Surface:\n            if (data) {\n                segmentation.representationData[type] = data;\n            }\n            break;\n        default:\n            throw new Error(`Invalid representation type ${type}`);\n    }\n}\nexport default internalAddRepresentationData;\n","import { getRenderingEngines } from '@cornerstonejs/core';\nimport { state } from '../state';\nfunction getToolGroupForViewport(viewportId, renderingEngineId) {\n    if (!renderingEngineId) {\n        renderingEngineId = getRenderingEngines().find((re) => re.getViewports().find((vp) => vp.id === viewportId))?.id;\n    }\n    const toolGroupFilteredByIds = state.toolGroups.filter((tg) => tg.viewportsInfo.some((vp) => vp.renderingEngineId === renderingEngineId &&\n        (!vp.viewportId || vp.viewportId === viewportId)));\n    if (!toolGroupFilteredByIds.length) {\n        return;\n    }\n    if (toolGroupFilteredByIds.length > 1) {\n        throw new Error(`Multiple tool groups found for renderingEngineId: ${renderingEngineId} and viewportId: ${viewportId}. You should only\n      have one tool group per viewport in a renderingEngine.`);\n    }\n    return toolGroupFilteredByIds[0];\n}\nexport default getToolGroupForViewport;\n","import { utilities } from '@cornerstonejs/core';\nimport { triggerSegmentationDataModified } from '../../stateManagement/segmentation/triggerSegmentationEvents';\nimport PlanarFreehandROITool from './PlanarFreehandROITool';\nclass PlanarFreehandContourSegmentationTool extends PlanarFreehandROITool {\n    static { this.toolName = 'PlanarFreehandContourSegmentationTool'; }\n    constructor(toolProps) {\n        const initialProps = utilities.deepMerge({\n            configuration: {\n                calculateStats: false,\n                allowOpenContours: false,\n            },\n        }, toolProps);\n        super(initialProps);\n    }\n    isContourSegmentationTool() {\n        return true;\n    }\n    renderAnnotationInstance(renderContext) {\n        const annotation = renderContext.annotation;\n        const { invalidated } = annotation;\n        const renderResult = super.renderAnnotationInstance(renderContext);\n        if (invalidated) {\n            const { segmentationId } = annotation.data.segmentation;\n            triggerSegmentationDataModified(segmentationId);\n        }\n        return renderResult;\n    }\n}\nexport default PlanarFreehandContourSegmentationTool;\n","import { CONSTANTS, getEnabledElement, VolumeViewport, utilities as csUtils, } from '@cornerstonejs/core';\nimport { vec3 } from 'gl-matrix';\nimport { getCalibratedLengthUnitsAndScale } from '../../utilities/getCalibratedUnits';\nimport * as math from '../../utilities/math';\nimport { polyline } from '../../utilities/math';\nimport { filterAnnotationsForDisplay } from '../../utilities/planar';\nimport throttle from '../../utilities/throttle';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport registerDrawLoop from './planarFreehandROITool/drawLoop';\nimport registerEditLoopCommon from './planarFreehandROITool/editLoopCommon';\nimport registerClosedContourEditLoop from './planarFreehandROITool/closedContourEditLoop';\nimport registerOpenContourEditLoop from './planarFreehandROITool/openContourEditLoop';\nimport registerOpenContourEndEditLoop from './planarFreehandROITool/openContourEndEditLoop';\nimport registerRenderMethods from './planarFreehandROITool/renderMethods';\nimport { triggerAnnotationModified } from '../../stateManagement/annotation/helpers/state';\nimport { drawLinkedTextBox } from '../../drawingSvg';\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\nimport { getLineSegmentIntersectionsCoordinates } from '../../utilities/math/polyline';\nimport { isViewportPreScaled } from '../../utilities/viewport/isViewportPreScaled';\nimport { BasicStatsCalculator } from '../../utilities/math/basic';\nimport calculatePerimeter from '../../utilities/contours/calculatePerimeter';\nimport ContourSegmentationBaseTool from '../base/ContourSegmentationBaseTool';\nimport { KeyboardBindings, ChangeTypes } from '../../enums';\nimport { getPixelValueUnits } from '../../utilities/getPixelValueUnits';\nconst { pointCanProjectOnLine } = polyline;\nconst { EPSILON } = CONSTANTS;\nconst PARALLEL_THRESHOLD = 1 - EPSILON;\nclass PlanarFreehandROITool extends ContourSegmentationBaseTool {\n    static { this.toolName = 'PlanarFreehandROI'; }\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            storePointData: false,\n            shadow: true,\n            preventHandleOutsideImage: false,\n            contourHoleAdditionModifierKey: KeyboardBindings.Shift,\n            alwaysRenderOpenContourHandles: {\n                enabled: false,\n                radius: 2,\n            },\n            allowOpenContours: true,\n            closeContourProximity: 10,\n            checkCanvasEditFallbackProximity: 6,\n            makeClockWise: true,\n            subPixelResolution: 4,\n            smoothing: {\n                smoothOnAdd: false,\n                smoothOnEdit: false,\n                knotsRatioPercentageOnAdd: 40,\n                knotsRatioPercentageOnEdit: 40,\n            },\n            interpolation: {\n                enabled: false,\n                onInterpolationComplete: null,\n            },\n            decimate: {\n                enabled: false,\n                epsilon: 0.1,\n            },\n            displayOnePointAsCrosshairs: false,\n            calculateStats: true,\n            getTextLines: defaultGetTextLines,\n            statsCalculator: BasicStatsCalculator,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.isDrawing = false;\n        this.isEditingClosed = false;\n        this.isEditingOpen = false;\n        this.addNewAnnotation = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const annotation = this.createAnnotation(evt);\n            this.addAnnotation(annotation, element);\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.activateDraw(evt, annotation, viewportIdsToRender);\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            return annotation;\n        };\n        this.handleSelectedCallback = (evt, annotation, handle) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.activateOpenContourEndEdit(evt, annotation, viewportIdsToRender, handle);\n        };\n        this.toolSelectedCallback = (evt, annotation) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            if (annotation.data.contour.closed) {\n                this.activateClosedContourEdit(evt, annotation, viewportIdsToRender);\n            }\n            else {\n                this.activateOpenContourEdit(evt, annotation, viewportIdsToRender);\n            }\n            evt.preventDefault();\n        };\n        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const { polyline: points } = annotation.data.contour;\n            let previousPoint = viewport.worldToCanvas(points[0]);\n            for (let i = 1; i < points.length; i++) {\n                const p1 = previousPoint;\n                const p2 = viewport.worldToCanvas(points[i]);\n                const canProject = pointCanProjectOnLine(canvasCoords, p1, p2, proximity);\n                if (canProject) {\n                    return true;\n                }\n                previousPoint = p2;\n            }\n            if (!annotation.data.contour.closed) {\n                return false;\n            }\n            const pStart = viewport.worldToCanvas(points[0]);\n            const pEnd = viewport.worldToCanvas(points[points.length - 1]);\n            return pointCanProjectOnLine(canvasCoords, pStart, pEnd, proximity);\n        };\n        this.cancel = (element) => {\n            const isDrawing = this.isDrawing;\n            const isEditingOpen = this.isEditingOpen;\n            const isEditingClosed = this.isEditingClosed;\n            if (isDrawing) {\n                this.cancelDrawing(element);\n            }\n            else if (isEditingOpen) {\n                this.cancelOpenContourEdit(element);\n            }\n            else if (isEditingClosed) {\n                this.cancelClosedContourEdit(element);\n            }\n        };\n        this._calculateCachedStats = (annotation, viewport, renderingEngine, enabledElement) => {\n            const { data } = annotation;\n            const { cachedStats } = data;\n            const { polyline: points, closed } = data.contour;\n            const targetIds = Object.keys(cachedStats);\n            for (let i = 0; i < targetIds.length; i++) {\n                const targetId = targetIds[i];\n                const image = this.getTargetImageData(targetId);\n                if (!image) {\n                    continue;\n                }\n                const { imageData, metadata } = image;\n                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n                const modalityUnitOptions = {\n                    isPreScaled: isViewportPreScaled(viewport, targetId),\n                    isSuvScaled: this.isSuvScaled(viewport, targetId, annotation.metadata.referencedImageId),\n                };\n                const modalityUnit = getPixelValueUnits(metadata.Modality, annotation.metadata.referencedImageId, modalityUnitOptions);\n                const calibratedScale = getCalibratedLengthUnitsAndScale(image, () => {\n                    const polyline = data.contour.polyline;\n                    const numPoints = polyline.length;\n                    const projectedPolyline = new Array(numPoints);\n                    for (let i = 0; i < numPoints; i++) {\n                        projectedPolyline[i] = viewport.worldToCanvas(polyline[i]);\n                    }\n                    const { maxX: canvasMaxX, maxY: canvasMaxY, minX: canvasMinX, minY: canvasMinY, } = math.polyline.getAABB(projectedPolyline);\n                    const topLeftBBWorld = viewport.canvasToWorld([canvasMinX, canvasMinY]);\n                    const topLeftBBIndex = csUtils.transformWorldToIndex(imageData, topLeftBBWorld);\n                    const bottomRightBBWorld = viewport.canvasToWorld([\n                        canvasMaxX,\n                        canvasMaxY,\n                    ]);\n                    const bottomRightBBIndex = csUtils.transformWorldToIndex(imageData, bottomRightBBWorld);\n                    return [topLeftBBIndex, bottomRightBBIndex];\n                });\n                if (closed) {\n                    this.updateClosedCachedStats({\n                        targetId,\n                        viewport,\n                        canvasCoordinates,\n                        points,\n                        imageData,\n                        metadata,\n                        cachedStats,\n                        modalityUnit,\n                        calibratedScale,\n                    });\n                }\n                else {\n                    this.updateOpenCachedStats({\n                        metadata,\n                        canvasCoordinates,\n                        targetId,\n                        cachedStats,\n                        modalityUnit,\n                        calibratedScale,\n                    });\n                }\n            }\n            const invalidated = annotation.invalidated;\n            annotation.invalidated = false;\n            if (invalidated) {\n                triggerAnnotationModified(annotation, enabledElement.viewport.element, ChangeTypes.StatsUpdated);\n            }\n            return cachedStats;\n        };\n        this._renderStats = (annotation, viewport, enabledElement, svgDrawingHelper) => {\n            const { data } = annotation;\n            const targetId = this.getTargetId(viewport);\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n            if (!options.visibility) {\n                return;\n            }\n            const textLines = this.configuration.getTextLines(data, targetId);\n            if (!textLines || textLines.length === 0) {\n                return;\n            }\n            const canvasCoordinates = data.contour.polyline.map((p) => viewport.worldToCanvas(p));\n            if (!data.handles.textBox.hasMoved) {\n                const canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCoordinates);\n                data.handles.textBox.worldPosition =\n                    viewport.canvasToWorld(canvasTextBoxCoords);\n            }\n            const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);\n            const textBoxUID = '1';\n            const boundingBox = drawLinkedTextBox(svgDrawingHelper, annotation.annotationUID ?? '', textBoxUID, textLines, textBoxPosition, canvasCoordinates, {}, options);\n            const { x: left, y: top, width, height } = boundingBox;\n            data.handles.textBox.worldBoundingBox = {\n                topLeft: viewport.canvasToWorld([left, top]),\n                topRight: viewport.canvasToWorld([left + width, top]),\n                bottomLeft: viewport.canvasToWorld([left, top + height]),\n                bottomRight: viewport.canvasToWorld([left + width, top + height]),\n            };\n        };\n        registerDrawLoop(this);\n        registerEditLoopCommon(this);\n        registerClosedContourEditLoop(this);\n        registerOpenContourEditLoop(this);\n        registerOpenContourEndEditLoop(this);\n        registerRenderMethods(this);\n        this._throttledCalculateCachedStats = throttle(this._calculateCachedStats, 100, { trailing: true });\n    }\n    filterInteractableAnnotationsForElement(element, annotations) {\n        if (!annotations || !annotations.length) {\n            return;\n        }\n        const enabledElement = getEnabledElement(element);\n        const { viewport } = enabledElement;\n        let annotationsToDisplay;\n        if (viewport instanceof VolumeViewport) {\n            const camera = viewport.getCamera();\n            const { spacingInNormalDirection } = csUtils.getTargetVolumeAndSpacingInNormalDir(viewport, camera);\n            annotationsToDisplay = this.filterAnnotationsWithinSlice(annotations, camera, spacingInNormalDirection);\n        }\n        else {\n            annotationsToDisplay = filterAnnotationsForDisplay(viewport, annotations);\n        }\n        return annotationsToDisplay;\n    }\n    filterAnnotationsWithinSlice(annotations, camera, spacingInNormalDirection) {\n        const { viewPlaneNormal } = camera;\n        const annotationsWithParallelNormals = annotations.filter((td) => {\n            const annotationViewPlaneNormal = td.metadata.viewPlaneNormal;\n            const isParallel = Math.abs(vec3.dot(viewPlaneNormal, annotationViewPlaneNormal)) >\n                PARALLEL_THRESHOLD;\n            return annotationViewPlaneNormal && isParallel;\n        });\n        if (!annotationsWithParallelNormals.length) {\n            return [];\n        }\n        const halfSpacingInNormalDirection = spacingInNormalDirection / 2;\n        const { focalPoint } = camera;\n        const annotationsWithinSlice = [];\n        for (const annotation of annotationsWithParallelNormals) {\n            const data = annotation.data;\n            const point = data.contour.polyline[0];\n            if (!annotation.isVisible) {\n                continue;\n            }\n            const dir = vec3.create();\n            vec3.sub(dir, focalPoint, point);\n            const dot = vec3.dot(dir, viewPlaneNormal);\n            if (Math.abs(dot) < halfSpacingInNormalDirection) {\n                annotationsWithinSlice.push(annotation);\n            }\n        }\n        return annotationsWithinSlice;\n    }\n    isContourSegmentationTool() {\n        return false;\n    }\n    createAnnotation(evt) {\n        const worldPos = evt.detail.currentPoints.world;\n        const contourAnnotation = super.createAnnotation(evt);\n        const onInterpolationComplete = (annotation) => {\n            annotation.data.handles.points.length = 0;\n        };\n        const annotation = csUtils.deepMerge(contourAnnotation, {\n            data: {\n                contour: {\n                    polyline: [[...worldPos]],\n                },\n                label: '',\n                cachedStats: {},\n            },\n            onInterpolationComplete,\n        });\n        return annotation;\n    }\n    getAnnotationStyle(context) {\n        return super.getAnnotationStyle(context);\n    }\n    renderAnnotationInstance(renderContext) {\n        const { enabledElement, targetId, svgDrawingHelper } = renderContext;\n        const annotation = renderContext.annotation;\n        let renderStatus = false;\n        const { viewport, renderingEngine } = enabledElement;\n        const isDrawing = this.isDrawing;\n        const isEditingOpen = this.isEditingOpen;\n        const isEditingClosed = this.isEditingClosed;\n        if (!(isDrawing || isEditingOpen || isEditingClosed)) {\n            if (this.configuration.displayOnePointAsCrosshairs &&\n                annotation.data.contour.polyline.length === 1) {\n                this.renderPointContourWithMarker(enabledElement, svgDrawingHelper, annotation);\n            }\n            else {\n                this.renderContour(enabledElement, svgDrawingHelper, annotation);\n            }\n        }\n        else {\n            const activeAnnotationUID = this.commonData.annotation.annotationUID;\n            if (annotation.annotationUID === activeAnnotationUID) {\n                if (isDrawing) {\n                    this.renderContourBeingDrawn(enabledElement, svgDrawingHelper, annotation);\n                }\n                else if (isEditingClosed) {\n                    this.renderClosedContourBeingEdited(enabledElement, svgDrawingHelper, annotation);\n                }\n                else if (isEditingOpen) {\n                    this.renderOpenContourBeingEdited(enabledElement, svgDrawingHelper, annotation);\n                }\n                else {\n                    throw new Error(`Unknown ${this.getToolName()} annotation rendering state`);\n                }\n            }\n            else {\n                if (this.configuration.displayOnePointAsCrosshairs &&\n                    annotation.data.contour.polyline.length === 1) {\n                    this.renderPointContourWithMarker(enabledElement, svgDrawingHelper, annotation);\n                }\n                else {\n                    this.renderContour(enabledElement, svgDrawingHelper, annotation);\n                }\n            }\n            renderStatus = true;\n        }\n        if (!this.configuration.calculateStats) {\n            return;\n        }\n        this._calculateStatsIfActive(annotation, targetId, viewport, renderingEngine, enabledElement);\n        this._renderStats(annotation, viewport, enabledElement, svgDrawingHelper);\n        return renderStatus;\n    }\n    _calculateStatsIfActive(annotation, targetId, viewport, renderingEngine, enabledElement) {\n        const activeAnnotationUID = this.commonData?.annotation.annotationUID;\n        if (annotation.annotationUID === activeAnnotationUID &&\n            !this.commonData?.movingTextBox) {\n            return;\n        }\n        if (!this.commonData?.movingTextBox) {\n            const { data } = annotation;\n            if (!data.cachedStats[targetId]?.unit) {\n                data.cachedStats[targetId] = {\n                    Modality: null,\n                    area: null,\n                    max: null,\n                    mean: null,\n                    stdDev: null,\n                    areaUnit: null,\n                    unit: null,\n                };\n                this._calculateCachedStats(annotation, viewport, renderingEngine, enabledElement);\n            }\n            else if (annotation.invalidated) {\n                this._throttledCalculateCachedStats(annotation, viewport, renderingEngine, enabledElement);\n            }\n        }\n    }\n    updateClosedCachedStats({ viewport, points, imageData, metadata, cachedStats, targetId, modalityUnit, canvasCoordinates, calibratedScale, }) {\n        const { scale, areaUnit, unit } = calibratedScale;\n        const { voxelManager } = viewport.getImageData();\n        const canvasPoint = canvasCoordinates[0];\n        const originalWorldPoint = viewport.canvasToWorld(canvasPoint);\n        const deltaXPoint = viewport.canvasToWorld([\n            canvasPoint[0] + 1,\n            canvasPoint[1],\n        ]);\n        const deltaYPoint = viewport.canvasToWorld([\n            canvasPoint[0],\n            canvasPoint[1] + 1,\n        ]);\n        const deltaInX = vec3.distance(originalWorldPoint, deltaXPoint);\n        const deltaInY = vec3.distance(originalWorldPoint, deltaYPoint);\n        const worldPosIndex = csUtils.transformWorldToIndex(imageData, points[0]);\n        worldPosIndex[0] = Math.floor(worldPosIndex[0]);\n        worldPosIndex[1] = Math.floor(worldPosIndex[1]);\n        worldPosIndex[2] = Math.floor(worldPosIndex[2]);\n        let iMin = worldPosIndex[0];\n        let iMax = worldPosIndex[0];\n        let jMin = worldPosIndex[1];\n        let jMax = worldPosIndex[1];\n        let kMin = worldPosIndex[2];\n        let kMax = worldPosIndex[2];\n        for (let j = 1; j < points.length; j++) {\n            const worldPosIndex = csUtils.transformWorldToIndex(imageData, points[j]);\n            worldPosIndex[0] = Math.floor(worldPosIndex[0]);\n            worldPosIndex[1] = Math.floor(worldPosIndex[1]);\n            worldPosIndex[2] = Math.floor(worldPosIndex[2]);\n            iMin = Math.min(iMin, worldPosIndex[0]);\n            iMax = Math.max(iMax, worldPosIndex[0]);\n            jMin = Math.min(jMin, worldPosIndex[1]);\n            jMax = Math.max(jMax, worldPosIndex[1]);\n            kMin = Math.min(kMin, worldPosIndex[2]);\n            kMax = Math.max(kMax, worldPosIndex[2]);\n        }\n        const worldPosIndex2 = csUtils.transformWorldToIndex(imageData, points[1]);\n        worldPosIndex2[0] = Math.floor(worldPosIndex2[0]);\n        worldPosIndex2[1] = Math.floor(worldPosIndex2[1]);\n        worldPosIndex2[2] = Math.floor(worldPosIndex2[2]);\n        let area = polyline.getArea(canvasCoordinates) / scale / scale;\n        area *= deltaInX * deltaInY;\n        const iDelta = 0.01 * (iMax - iMin);\n        const jDelta = 0.01 * (jMax - jMin);\n        const kDelta = 0.01 * (kMax - kMin);\n        iMin = Math.floor(iMin - iDelta);\n        iMax = Math.ceil(iMax + iDelta);\n        jMin = Math.floor(jMin - jDelta);\n        jMax = Math.ceil(jMax + jDelta);\n        kMin = Math.floor(kMin - kDelta);\n        kMax = Math.ceil(kMax + kDelta);\n        const boundsIJK = [\n            [iMin, iMax],\n            [jMin, jMax],\n            [kMin, kMax],\n        ];\n        const worldPosEnd = imageData.indexToWorld([iMax, jMax, kMax]);\n        const canvasPosEnd = viewport.worldToCanvas(worldPosEnd);\n        let curRow = 0;\n        let intersections = [];\n        let intersectionCounter = 0;\n        const pointsInShape = voxelManager.forEach(this.configuration.statsCalculator.statsCallback, {\n            imageData,\n            isInObject: (pointLPS, _pointIJK) => {\n                let result = true;\n                const point = viewport.worldToCanvas(pointLPS);\n                if (point[1] != curRow) {\n                    intersectionCounter = 0;\n                    curRow = point[1];\n                    intersections = getLineSegmentIntersectionsCoordinates(canvasCoordinates, point, [canvasPosEnd[0], point[1]]);\n                    intersections.sort((function (index) {\n                        return function (a, b) {\n                            return a[index] === b[index]\n                                ? 0\n                                : a[index] < b[index]\n                                    ? -1\n                                    : 1;\n                        };\n                    })(0));\n                }\n                if (intersections.length && point[0] > intersections[0][0]) {\n                    intersections.shift();\n                    intersectionCounter++;\n                }\n                if (intersectionCounter % 2 === 0) {\n                    result = false;\n                }\n                return result;\n            },\n            boundsIJK,\n            returnPoints: this.configuration.storePointData,\n        });\n        const stats = this.configuration.statsCalculator.getStatistics();\n        cachedStats[targetId] = {\n            Modality: metadata.Modality,\n            area,\n            perimeter: calculatePerimeter(canvasCoordinates, closed) / scale,\n            mean: stats.mean?.value,\n            max: stats.max?.value,\n            stdDev: stats.stdDev?.value,\n            statsArray: stats.array,\n            pointsInShape: pointsInShape,\n            areaUnit,\n            modalityUnit,\n            unit,\n        };\n    }\n    updateOpenCachedStats({ targetId, metadata, canvasCoordinates, cachedStats, modalityUnit, calibratedScale, }) {\n        const { scale, unit } = calibratedScale;\n        cachedStats[targetId] = {\n            Modality: metadata.Modality,\n            length: calculatePerimeter(canvasCoordinates, false) / scale,\n            modalityUnit,\n            unit,\n        };\n    }\n}\nfunction defaultGetTextLines(data, targetId) {\n    const cachedVolumeStats = data.cachedStats[targetId];\n    const { area, mean, stdDev, length, perimeter, max, isEmptyArea, unit, areaUnit, modalityUnit, } = cachedVolumeStats || {};\n    const textLines = [];\n    if (area) {\n        const areaLine = isEmptyArea\n            ? `Area: Oblique not supported`\n            : `Area: ${csUtils.roundNumber(area)} ${areaUnit}`;\n        textLines.push(areaLine);\n    }\n    if (mean) {\n        textLines.push(`Mean: ${csUtils.roundNumber(mean)} ${modalityUnit}`);\n    }\n    if (Number.isFinite(max)) {\n        textLines.push(`Max: ${csUtils.roundNumber(max)} ${modalityUnit}`);\n    }\n    if (stdDev) {\n        textLines.push(`Std Dev: ${csUtils.roundNumber(stdDev)} ${modalityUnit}`);\n    }\n    if (perimeter) {\n        textLines.push(`Perimeter: ${csUtils.roundNumber(perimeter)} ${unit}`);\n    }\n    if (length) {\n        textLines.push(`${csUtils.roundNumber(length)} ${unit}`);\n    }\n    return textLines;\n}\nexport default PlanarFreehandROITool;\n","import { AnnotationTool } from '../base';\nimport { getEnabledElement, VolumeViewport, utilities as csUtils, getEnabledElementByViewportId, } from '@cornerstonejs/core';\nimport { getCalibratedLengthUnitsAndScale } from '../../utilities/getCalibratedUnits';\nimport throttle from '../../utilities/throttle';\nimport { addAnnotation, getAnnotations, removeAnnotation, } from '../../stateManagement';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport { triggerAnnotationCompleted, triggerAnnotationModified, } from '../../stateManagement/annotation/helpers/state';\nimport { drawHandles as drawHandlesSvg, drawLinkedTextBox as drawLinkedTextBoxSvg, drawRectByCoordinates as drawRectSvg, } from '../../drawingSvg';\nimport { state } from '../../store/state';\nimport { ChangeTypes, Events } from '../../enums';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport * as rectangle from '../../utilities/math/rectangle';\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\nimport getWorldWidthAndHeightFromCorners from '../../utilities/planar/getWorldWidthAndHeightFromCorners';\nimport { resetElementCursor, hideElementCursor, } from '../../cursors/elementCursor';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { getPixelValueUnits } from '../../utilities/getPixelValueUnits';\nimport { isViewportPreScaled } from '../../utilities/viewport/isViewportPreScaled';\nimport { BasicStatsCalculator } from '../../utilities/math/basic';\nconst { transformWorldToIndex } = csUtils;\nclass RectangleROITool extends AnnotationTool {\n    static { this.toolName = 'RectangleROI'; }\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            storePointData: false,\n            shadow: true,\n            preventHandleOutsideImage: false,\n            calculateStats: true,\n            getTextLines: defaultGetTextLines,\n            statsCalculator: BasicStatsCalculator,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.addNewAnnotation = (evt) => {\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const worldPos = currentPoints.world;\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            this.isDrawing = true;\n            const annotation = (this.constructor).createAnnotationForViewport(viewport, {\n                data: {\n                    handles: {\n                        points: [\n                            [...worldPos],\n                            [...worldPos],\n                            [...worldPos],\n                            [...worldPos],\n                        ],\n                        textBox: {\n                            hasMoved: false,\n                            worldPosition: [0, 0, 0],\n                            worldBoundingBox: {\n                                topLeft: [0, 0, 0],\n                                topRight: [0, 0, 0],\n                                bottomLeft: [0, 0, 0],\n                                bottomRight: [0, 0, 0],\n                            },\n                        },\n                    },\n                    cachedStats: {},\n                },\n            });\n            addAnnotation(annotation, element);\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                handleIndex: 3,\n                movingTextBox: false,\n                newAnnotation: true,\n                hasMoved: false,\n            };\n            this._activateDraw(element);\n            hideElementCursor(element);\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            return annotation;\n        };\n        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const { data } = annotation;\n            const { points } = data.handles;\n            const canvasPoint1 = viewport.worldToCanvas(points[0]);\n            const canvasPoint2 = viewport.worldToCanvas(points[3]);\n            const rect = this._getRectangleImageCoordinates([\n                canvasPoint1,\n                canvasPoint2,\n            ]);\n            const point = [canvasCoords[0], canvasCoords[1]];\n            const { left, top, width, height } = rect;\n            const distanceToPoint = rectangle.distanceToPoint([left, top, width, height], point);\n            if (distanceToPoint <= proximity) {\n                return true;\n            }\n            return false;\n        };\n        this.toolSelectedCallback = (evt, annotation) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            annotation.highlighted = true;\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                movingTextBox: false,\n            };\n            this._activateModify(element);\n            hideElementCursor(element);\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            evt.preventDefault();\n        };\n        this.handleSelectedCallback = (evt, annotation, handle) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { data } = annotation;\n            annotation.highlighted = true;\n            let movingTextBox = false;\n            let handleIndex;\n            if (handle.worldPosition) {\n                movingTextBox = true;\n            }\n            else {\n                handleIndex = data.handles.points.findIndex((p) => p === handle);\n            }\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                handleIndex,\n                movingTextBox,\n            };\n            this._activateModify(element);\n            hideElementCursor(element);\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            evt.preventDefault();\n        };\n        this._endCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, newAnnotation, hasMoved } = this.editData;\n            const { data } = annotation;\n            if (newAnnotation && !hasMoved) {\n                return;\n            }\n            data.handles.activeHandleIndex = null;\n            this._deactivateModify(element);\n            this._deactivateDraw(element);\n            resetElementCursor(element);\n            this.doneEditMemo();\n            this.editData = null;\n            this.isDrawing = false;\n            if (this.isHandleOutsideImage &&\n                this.configuration.preventHandleOutsideImage) {\n                removeAnnotation(annotation.annotationUID);\n            }\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            if (newAnnotation) {\n                triggerAnnotationCompleted(annotation);\n            }\n        };\n        this._dragCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, handleIndex, movingTextBox, newAnnotation, } = this.editData;\n            this.createMemo(element, annotation, { newAnnotation });\n            const { data } = annotation;\n            if (movingTextBox) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const { textBox } = data.handles;\n                const { worldPosition } = textBox;\n                worldPosition[0] += worldPosDelta[0];\n                worldPosition[1] += worldPosDelta[1];\n                worldPosition[2] += worldPosDelta[2];\n                textBox.hasMoved = true;\n            }\n            else if (handleIndex === undefined) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const { points } = data.handles;\n                points.forEach((point) => {\n                    point[0] += worldPosDelta[0];\n                    point[1] += worldPosDelta[1];\n                    point[2] += worldPosDelta[2];\n                });\n                annotation.invalidated = true;\n            }\n            else {\n                const { currentPoints } = eventDetail;\n                const enabledElement = getEnabledElement(element);\n                const { worldToCanvas, canvasToWorld } = enabledElement.viewport;\n                const worldPos = currentPoints.world;\n                const { points } = data.handles;\n                points[handleIndex] = [...worldPos];\n                let bottomLeftCanvas;\n                let bottomRightCanvas;\n                let topLeftCanvas;\n                let topRightCanvas;\n                let bottomLeftWorld;\n                let bottomRightWorld;\n                let topLeftWorld;\n                let topRightWorld;\n                switch (handleIndex) {\n                    case 0:\n                    case 3:\n                        bottomLeftCanvas = worldToCanvas(points[0]);\n                        topRightCanvas = worldToCanvas(points[3]);\n                        bottomRightCanvas = [topRightCanvas[0], bottomLeftCanvas[1]];\n                        topLeftCanvas = [bottomLeftCanvas[0], topRightCanvas[1]];\n                        bottomRightWorld = canvasToWorld(bottomRightCanvas);\n                        topLeftWorld = canvasToWorld(topLeftCanvas);\n                        points[1] = bottomRightWorld;\n                        points[2] = topLeftWorld;\n                        break;\n                    case 1:\n                    case 2:\n                        bottomRightCanvas = worldToCanvas(points[1]);\n                        topLeftCanvas = worldToCanvas(points[2]);\n                        bottomLeftCanvas = [\n                            topLeftCanvas[0],\n                            bottomRightCanvas[1],\n                        ];\n                        topRightCanvas = [\n                            bottomRightCanvas[0],\n                            topLeftCanvas[1],\n                        ];\n                        bottomLeftWorld = canvasToWorld(bottomLeftCanvas);\n                        topRightWorld = canvasToWorld(topRightCanvas);\n                        points[0] = bottomLeftWorld;\n                        points[3] = topRightWorld;\n                        break;\n                }\n                annotation.invalidated = true;\n            }\n            this.editData.hasMoved = true;\n            const enabledElement = getEnabledElement(element);\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            if (annotation.invalidated) {\n                triggerAnnotationModified(annotation, element, ChangeTypes.HandlesUpdated);\n            }\n        };\n        this.cancel = (element) => {\n            if (this.isDrawing) {\n                this.isDrawing = false;\n                this._deactivateDraw(element);\n                this._deactivateModify(element);\n                resetElementCursor(element);\n                const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n                const { data } = annotation;\n                annotation.highlighted = false;\n                data.handles.activeHandleIndex = null;\n                triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n                if (newAnnotation) {\n                    triggerAnnotationCompleted(annotation);\n                }\n                this.editData = null;\n                return annotation.annotationUID;\n            }\n        };\n        this._activateDraw = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._deactivateDraw = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._activateModify = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._deactivateModify = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = false;\n            const { viewport } = enabledElement;\n            const { element } = viewport;\n            let annotations = getAnnotations(this.getToolName(), element);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            const targetId = this.getTargetId(viewport);\n            const renderingEngine = viewport.getRenderingEngine();\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            for (let i = 0; i < annotations.length; i++) {\n                const annotation = annotations[i];\n                const { annotationUID, data } = annotation;\n                const { points, activeHandleIndex } = data.handles;\n                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n                styleSpecifier.annotationUID = annotationUID;\n                const { color, lineWidth, lineDash } = this.getAnnotationStyle({\n                    annotation,\n                    styleSpecifier,\n                });\n                const { viewPlaneNormal, viewUp } = viewport.getCamera();\n                if (!data.cachedStats[targetId] ||\n                    data.cachedStats[targetId].areaUnit == null) {\n                    data.cachedStats[targetId] = {\n                        Modality: null,\n                        area: null,\n                        max: null,\n                        mean: null,\n                        stdDev: null,\n                        areaUnit: null,\n                    };\n                    this._calculateCachedStats(annotation, viewPlaneNormal, viewUp, renderingEngine, enabledElement);\n                }\n                else if (annotation.invalidated) {\n                    this._throttledCalculateCachedStats(annotation, viewPlaneNormal, viewUp, renderingEngine, enabledElement);\n                    if (viewport instanceof VolumeViewport) {\n                        const { referencedImageId } = annotation.metadata;\n                        for (const targetId in data.cachedStats) {\n                            if (targetId.startsWith('imageId')) {\n                                const viewports = renderingEngine.getStackViewports();\n                                const invalidatedStack = viewports.find((vp) => {\n                                    const referencedImageURI = csUtils.imageIdToURI(referencedImageId);\n                                    const hasImageURI = vp.hasImageURI(referencedImageURI);\n                                    const currentImageURI = csUtils.imageIdToURI(vp.getCurrentImageId());\n                                    return hasImageURI && currentImageURI !== referencedImageURI;\n                                });\n                                if (invalidatedStack) {\n                                    delete data.cachedStats[targetId];\n                                }\n                            }\n                        }\n                    }\n                }\n                if (!viewport.getRenderingEngine()) {\n                    console.warn('Rendering Engine has been destroyed');\n                    return renderStatus;\n                }\n                let activeHandleCanvasCoords;\n                if (!isAnnotationVisible(annotationUID)) {\n                    continue;\n                }\n                if (!isAnnotationLocked(annotationUID) &&\n                    !this.editData &&\n                    activeHandleIndex !== null) {\n                    activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n                }\n                if (activeHandleCanvasCoords) {\n                    const handleGroupUID = '0';\n                    drawHandlesSvg(svgDrawingHelper, annotationUID, handleGroupUID, activeHandleCanvasCoords, {\n                        color,\n                    });\n                }\n                const dataId = `${annotationUID}-rect`;\n                const rectangleUID = '0';\n                drawRectSvg(svgDrawingHelper, annotationUID, rectangleUID, canvasCoordinates, {\n                    color,\n                    lineDash,\n                    lineWidth,\n                }, dataId);\n                renderStatus = true;\n                const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n                if (!options.visibility) {\n                    data.handles.textBox = {\n                        hasMoved: false,\n                        worldPosition: [0, 0, 0],\n                        worldBoundingBox: {\n                            topLeft: [0, 0, 0],\n                            topRight: [0, 0, 0],\n                            bottomLeft: [0, 0, 0],\n                            bottomRight: [0, 0, 0],\n                        },\n                    };\n                    continue;\n                }\n                const textLines = this.configuration.getTextLines(data, targetId);\n                if (!textLines || textLines.length === 0) {\n                    continue;\n                }\n                if (!data.handles.textBox.hasMoved) {\n                    const canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCoordinates);\n                    data.handles.textBox.worldPosition =\n                        viewport.canvasToWorld(canvasTextBoxCoords);\n                }\n                const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);\n                const textBoxUID = '1';\n                const boundingBox = drawLinkedTextBoxSvg(svgDrawingHelper, annotationUID, textBoxUID, textLines, textBoxPosition, canvasCoordinates, {}, options);\n                const { x: left, y: top, width, height } = boundingBox;\n                data.handles.textBox.worldBoundingBox = {\n                    topLeft: viewport.canvasToWorld([left, top]),\n                    topRight: viewport.canvasToWorld([left + width, top]),\n                    bottomLeft: viewport.canvasToWorld([left, top + height]),\n                    bottomRight: viewport.canvasToWorld([left + width, top + height]),\n                };\n            }\n            return renderStatus;\n        };\n        this._getRectangleImageCoordinates = (points) => {\n            const [point0, point1] = points;\n            return {\n                left: Math.min(point0[0], point1[0]),\n                top: Math.min(point0[1], point1[1]),\n                width: Math.abs(point0[0] - point1[0]),\n                height: Math.abs(point0[1] - point1[1]),\n            };\n        };\n        this._calculateCachedStats = (annotation, viewPlaneNormal, viewUp, renderingEngine, enabledElement) => {\n            if (!this.configuration.calculateStats) {\n                return;\n            }\n            const { data } = annotation;\n            const { viewport } = enabledElement;\n            const { element } = viewport;\n            const worldPos1 = data.handles.points[0];\n            const worldPos2 = data.handles.points[3];\n            const { cachedStats } = data;\n            const targetIds = Object.keys(cachedStats);\n            for (let i = 0; i < targetIds.length; i++) {\n                const targetId = targetIds[i];\n                const image = this.getTargetImageData(targetId);\n                if (!image) {\n                    continue;\n                }\n                const { dimensions, imageData, metadata, voxelManager } = image;\n                const pos1Index = transformWorldToIndex(imageData, worldPos1);\n                pos1Index[0] = Math.floor(pos1Index[0]);\n                pos1Index[1] = Math.floor(pos1Index[1]);\n                pos1Index[2] = Math.floor(pos1Index[2]);\n                const pos2Index = transformWorldToIndex(imageData, worldPos2);\n                pos2Index[0] = Math.floor(pos2Index[0]);\n                pos2Index[1] = Math.floor(pos2Index[1]);\n                pos2Index[2] = Math.floor(pos2Index[2]);\n                if (this._isInsideVolume(pos1Index, pos2Index, dimensions)) {\n                    this.isHandleOutsideImage = false;\n                    const iMin = Math.min(pos1Index[0], pos2Index[0]);\n                    const iMax = Math.max(pos1Index[0], pos2Index[0]);\n                    const jMin = Math.min(pos1Index[1], pos2Index[1]);\n                    const jMax = Math.max(pos1Index[1], pos2Index[1]);\n                    const kMin = Math.min(pos1Index[2], pos2Index[2]);\n                    const kMax = Math.max(pos1Index[2], pos2Index[2]);\n                    const boundsIJK = [\n                        [iMin, iMax],\n                        [jMin, jMax],\n                        [kMin, kMax],\n                    ];\n                    const { worldWidth, worldHeight } = getWorldWidthAndHeightFromCorners(viewPlaneNormal, viewUp, worldPos1, worldPos2);\n                    const handles = [pos1Index, pos2Index];\n                    const { scale, areaUnit } = getCalibratedLengthUnitsAndScale(image, handles);\n                    const area = Math.abs(worldWidth * worldHeight) / (scale * scale);\n                    const pixelUnitsOptions = {\n                        isPreScaled: isViewportPreScaled(viewport, targetId),\n                        isSuvScaled: this.isSuvScaled(viewport, targetId, annotation.metadata.referencedImageId),\n                    };\n                    const modalityUnit = getPixelValueUnits(metadata.Modality, annotation.metadata.referencedImageId, pixelUnitsOptions);\n                    const pointsInShape = voxelManager.forEach(this.configuration.statsCalculator.statsCallback, {\n                        boundsIJK,\n                        imageData,\n                        returnPoints: this.configuration.storePointData,\n                    });\n                    const stats = this.configuration.statsCalculator.getStatistics();\n                    cachedStats[targetId] = {\n                        Modality: metadata.Modality,\n                        area,\n                        mean: stats.mean?.value,\n                        stdDev: stats.stdDev?.value,\n                        max: stats.max?.value,\n                        statsArray: stats.array,\n                        pointsInShape: pointsInShape,\n                        areaUnit,\n                        modalityUnit,\n                    };\n                }\n                else {\n                    this.isHandleOutsideImage = true;\n                    cachedStats[targetId] = {\n                        Modality: metadata.Modality,\n                    };\n                }\n            }\n            const invalidated = annotation.invalidated;\n            annotation.invalidated = false;\n            if (invalidated) {\n                triggerAnnotationModified(annotation, element, ChangeTypes.StatsUpdated);\n            }\n            return cachedStats;\n        };\n        this._isInsideVolume = (index1, index2, dimensions) => {\n            return (csUtils.indexWithinDimensions(index1, dimensions) &&\n                csUtils.indexWithinDimensions(index2, dimensions));\n        };\n        this._throttledCalculateCachedStats = throttle(this._calculateCachedStats, 100, { trailing: true });\n    }\n    static { this.hydrate = (viewportId, points, options) => {\n        const enabledElement = getEnabledElementByViewportId(viewportId);\n        if (!enabledElement) {\n            return;\n        }\n        const { FrameOfReferenceUID, referencedImageId, viewPlaneNormal, instance, viewport, } = this.hydrateBase(RectangleROITool, enabledElement, points, options);\n        const annotation = {\n            annotationUID: options?.annotationUID || csUtils.uuidv4(),\n            data: {\n                handles: {\n                    points,\n                    activeHandleIndex: null,\n                },\n                label: '',\n                cachedStats: {},\n            },\n            highlighted: false,\n            autoGenerated: false,\n            invalidated: false,\n            isLocked: false,\n            isVisible: true,\n            metadata: {\n                toolName: instance.getToolName(),\n                viewPlaneNormal,\n                FrameOfReferenceUID,\n                referencedImageId,\n                ...options,\n            },\n        };\n        addAnnotation(annotation, viewport.element);\n        triggerAnnotationRenderForViewportIds([viewport.id]);\n    }; }\n}\nfunction defaultGetTextLines(data, targetId) {\n    const cachedVolumeStats = data.cachedStats[targetId];\n    const { area, mean, max, stdDev, areaUnit, modalityUnit } = cachedVolumeStats;\n    if (mean === undefined || mean === null) {\n        return;\n    }\n    const textLines = [];\n    textLines.push(`Area: ${csUtils.roundNumber(area)} ${areaUnit}`);\n    textLines.push(`Mean: ${csUtils.roundNumber(mean)} ${modalityUnit}`);\n    textLines.push(`Max: ${csUtils.roundNumber(max)} ${modalityUnit}`);\n    textLines.push(`Std Dev: ${csUtils.roundNumber(stdDev)} ${modalityUnit}`);\n    return textLines;\n}\nexport default RectangleROITool;\n","import { getEnabledElement, cache, utilities as csUtils, Enums, eventTarget, BaseVolumeViewport, } from '@cornerstonejs/core';\nimport { BaseTool } from '../base';\nimport SegmentationRepresentations from '../../enums/SegmentationRepresentations';\nimport { getActiveSegmentation } from '../../stateManagement/segmentation/getActiveSegmentation';\nimport { getLockedSegmentIndices } from '../../stateManagement/segmentation/segmentLocking';\nimport { getSegmentation } from '../../stateManagement/segmentation/getSegmentation';\nimport { getClosestImageIdForStackViewport } from '../../utilities/annotationHydration';\nimport { getCurrentLabelmapImageIdForViewport } from '../../stateManagement/segmentation/getCurrentLabelmapImageIdForViewport';\nimport { getSegmentIndexColor } from '../../stateManagement/segmentation/config/segmentationColor';\nimport { getActiveSegmentIndex } from '../../stateManagement/segmentation/getActiveSegmentIndex';\nimport { StrategyCallbacks, Events } from '../../enums';\nimport * as LabelmapMemo from '../../utilities/segmentation/createLabelmapMemo';\nimport { getAllAnnotations, removeAnnotation, } from '../../stateManagement/annotation/annotationState';\nimport { filterAnnotationsForDisplay } from '../../utilities/planar';\nimport { isPointInsidePolyline3D } from '../../utilities/math/polyline';\nimport { triggerSegmentationDataModified } from '../../stateManagement/segmentation/triggerSegmentationEvents';\nimport { fillInsideCircle } from './strategies';\nexport default class LabelmapBaseTool extends BaseTool {\n    static { this.previewData = {\n        preview: null,\n        element: null,\n        timerStart: 0,\n        timer: null,\n        startPoint: [NaN, NaN],\n        isDrag: false,\n    }; }\n    constructor(toolProps, defaultToolProps) {\n        super(toolProps, defaultToolProps);\n        this.memoMap = new Map();\n        this.acceptedMemoIds = new Map();\n        this.centerSegmentIndexInfo = {\n            segmentIndex: null,\n            hasSegmentIndex: false,\n            hasPreviewIndex: false,\n            changedIndices: [],\n        };\n    }\n    _historyRedoHandler(evt) {\n        const { id, operationType } = evt.detail;\n        if (operationType !== 'labelmap') {\n            return;\n        }\n        if (this.acceptedMemoIds.has(id)) {\n            this._hoverData = null;\n            const memoData = this.acceptedMemoIds.get(id);\n            const element = memoData?.element;\n            const operationData = this.getOperationData(element);\n            operationData.segmentIndex = memoData?.segmentIndex;\n            if (element) {\n                this.applyActiveStrategyCallback(getEnabledElement(element), operationData, StrategyCallbacks.AcceptPreview);\n            }\n        }\n        this._previewData.isDrag = true;\n    }\n    get _previewData() {\n        return LabelmapBaseTool.previewData;\n    }\n    createMemo(segmentationId, segmentationVoxelManager) {\n        const voxelManagerId = segmentationVoxelManager.id;\n        if (this.memo &&\n            this.memo.segmentationVoxelManager === segmentationVoxelManager) {\n            return this.memo;\n        }\n        let memo = this.memoMap.get(voxelManagerId);\n        if (!memo) {\n            memo = LabelmapMemo.createLabelmapMemo(segmentationId, segmentationVoxelManager);\n            this.memoMap.set(voxelManagerId, memo);\n        }\n        else {\n            if (memo.redoVoxelManager) {\n                memo = LabelmapMemo.createLabelmapMemo(segmentationId, segmentationVoxelManager);\n                this.memoMap.set(voxelManagerId, memo);\n            }\n        }\n        this.memo = memo;\n        return memo;\n    }\n    createEditData(element) {\n        const enabledElement = getEnabledElement(element);\n        const { viewport } = enabledElement;\n        const activeSegmentation = getActiveSegmentation(viewport.id);\n        if (!activeSegmentation) {\n            const event = new CustomEvent(Enums.Events.ERROR_EVENT, {\n                detail: {\n                    type: 'Segmentation',\n                    message: 'No active segmentation detected, create a segmentation representation before using the brush tool',\n                },\n                cancelable: true,\n            });\n            eventTarget.dispatchEvent(event);\n            return null;\n        }\n        const { segmentationId } = activeSegmentation;\n        const segmentsLocked = getLockedSegmentIndices(segmentationId);\n        const { representationData } = getSegmentation(segmentationId);\n        const editData = this.getEditData({\n            viewport,\n            representationData,\n            segmentsLocked,\n            segmentationId,\n        });\n        return editData;\n    }\n    getEditData({ viewport, representationData, segmentsLocked, segmentationId, }) {\n        if (viewport instanceof BaseVolumeViewport) {\n            const { volumeId } = representationData[SegmentationRepresentations.Labelmap];\n            const actors = viewport.getActors();\n            const isStackViewport = viewport instanceof getClosestImageIdForStackViewport;\n            if (isStackViewport) {\n                const event = new CustomEvent(Enums.Events.ERROR_EVENT, {\n                    detail: {\n                        type: 'Segmentation',\n                        message: 'Cannot perform brush operation on the selected viewport',\n                    },\n                    cancelable: true,\n                });\n                eventTarget.dispatchEvent(event);\n                return null;\n            }\n            const volumes = actors.map((actorEntry) => cache.getVolume(actorEntry.referencedId));\n            const segmentationVolume = cache.getVolume(volumeId);\n            const referencedVolumeIdToThreshold = volumes.find((volume) => csUtils.isEqual(volume.dimensions, segmentationVolume.dimensions))?.volumeId || volumes[0]?.volumeId;\n            return {\n                volumeId,\n                referencedVolumeId: this.configuration.threshold?.volumeId ??\n                    referencedVolumeIdToThreshold,\n                segmentsLocked,\n            };\n        }\n        else {\n            const segmentationImageId = getCurrentLabelmapImageIdForViewport(viewport.id, segmentationId);\n            if (!segmentationImageId) {\n                return;\n            }\n            return {\n                imageId: segmentationImageId,\n                segmentsLocked,\n            };\n        }\n    }\n    createHoverData(element, centerCanvas) {\n        const enabledElement = getEnabledElement(element);\n        const { viewport } = enabledElement;\n        const camera = viewport.getCamera();\n        const { viewPlaneNormal, viewUp } = camera;\n        const viewportIdsToRender = [viewport.id];\n        const { segmentIndex, segmentationId, segmentColor } = this.getActiveSegmentationData(viewport) || {};\n        const brushCursor = {\n            metadata: {\n                viewPlaneNormal: [...viewPlaneNormal],\n                viewUp: [...viewUp],\n                FrameOfReferenceUID: viewport.getFrameOfReferenceUID(),\n                referencedImageId: '',\n                toolName: this.getToolName(),\n                segmentColor,\n            },\n            data: {},\n        };\n        return {\n            brushCursor,\n            centerCanvas,\n            segmentIndex,\n            viewport,\n            segmentationId,\n            segmentColor,\n            viewportIdsToRender,\n        };\n    }\n    getActiveSegmentationData(viewport) {\n        const viewportId = viewport.id;\n        const activeRepresentation = getActiveSegmentation(viewportId);\n        if (!activeRepresentation) {\n            return;\n        }\n        const { segmentationId } = activeRepresentation;\n        const segmentIndex = getActiveSegmentIndex(segmentationId);\n        if (!segmentIndex) {\n            return;\n        }\n        const segmentColor = getSegmentIndexColor(viewportId, segmentationId, segmentIndex);\n        return {\n            segmentIndex,\n            segmentationId,\n            segmentColor,\n        };\n    }\n    getOperationData(element) {\n        const editData = this._editData || this.createEditData(element);\n        const { segmentIndex, segmentationId, brushCursor } = this._hoverData || this.createHoverData(element);\n        const { data, metadata = {} } = brushCursor || {};\n        const { viewPlaneNormal, viewUp } = metadata;\n        const configColor = this.configuration.preview?.previewColors?.[segmentIndex];\n        const { viewport } = getEnabledElement(element);\n        const segmentColor = getSegmentIndexColor(viewport.id, segmentationId, segmentIndex);\n        if (!configColor && !segmentColor) {\n            return;\n        }\n        let previewColor = null, previewSegmentIndex = null;\n        if (this.configuration.preview.enabled) {\n            previewColor = configColor || lightenColor(...segmentColor);\n            previewSegmentIndex = 255;\n        }\n        const operationData = {\n            ...editData,\n            points: data?.handles?.points,\n            segmentIndex,\n            viewPlaneNormal,\n            previewOnHover: !this._previewData.isDrag,\n            toolGroupId: this.toolGroupId,\n            segmentationId,\n            viewUp,\n            centerSegmentIndexInfo: this.centerSegmentIndexInfo,\n            activeStrategy: this.configuration.activeStrategy,\n            configuration: this.configuration,\n            previewColor,\n            previewSegmentIndex,\n            createMemo: this.createMemo.bind(this),\n        };\n        return operationData;\n    }\n    addPreview(element = this._previewData.element, options) {\n        const { _previewData } = this;\n        const acceptReject = options?.acceptReject;\n        if (acceptReject === true) {\n            this.acceptPreview(element);\n        }\n        else if (acceptReject === false) {\n            this.rejectPreview(element);\n        }\n        const enabledElement = getEnabledElement(element);\n        const results = this.applyActiveStrategyCallback(enabledElement, this.getOperationData(element), StrategyCallbacks.AddPreview);\n        _previewData.isDrag = true;\n        return results;\n    }\n    rejectPreview(element = this._previewData.element) {\n        if (!element) {\n            return;\n        }\n        this.doneEditMemo();\n        const enabledElement = getEnabledElement(element);\n        this.applyActiveStrategyCallback(enabledElement, this.getOperationData(element), StrategyCallbacks.RejectPreview);\n        this._previewData.preview = null;\n        this._previewData.isDrag = false;\n    }\n    acceptPreview(element = this._previewData.element) {\n        if (!element) {\n            return;\n        }\n        const operationData = this.getOperationData(element);\n        if (this.memo && this.memo.id) {\n            this.acceptedMemoIds.set(this.memo.id, {\n                element,\n                segmentIndex: operationData.segmentIndex,\n            });\n        }\n        const enabledElement = getEnabledElement(element);\n        this.applyActiveStrategyCallback(enabledElement, operationData, StrategyCallbacks.AcceptPreview);\n        this.doneEditMemo();\n        this._previewData.preview = null;\n        this._previewData.isDrag = false;\n    }\n    static viewportContoursToLabelmap(viewport, options) {\n        const removeContours = options?.removeContours ?? true;\n        const annotations = getAllAnnotations();\n        const viewAnnotations = filterAnnotationsForDisplay(viewport, annotations);\n        if (!viewAnnotations?.length) {\n            return;\n        }\n        const contourAnnotations = viewAnnotations.filter((annotation) => annotation.data.contour?.polyline?.length);\n        if (!contourAnnotations.length) {\n            return;\n        }\n        const brushInstance = new LabelmapBaseTool({}, {\n            configuration: {\n                strategies: {\n                    FILL_INSIDE_CIRCLE: fillInsideCircle,\n                },\n                activeStrategy: 'FILL_INSIDE_CIRCLE',\n            },\n        });\n        const preview = brushInstance.addPreview(viewport.element);\n        const { memo, segmentationId } = preview;\n        const previewVoxels = memo?.voxelManager;\n        const segmentationVoxels = previewVoxels.sourceVoxelManager || previewVoxels;\n        const { dimensions } = previewVoxels;\n        const imageData = viewport\n            .getDefaultActor()\n            .actor.getMapper()\n            .getInputData();\n        for (const annotation of contourAnnotations) {\n            const boundsIJK = [\n                [Infinity, -Infinity],\n                [Infinity, -Infinity],\n                [Infinity, -Infinity],\n            ];\n            const { polyline } = annotation.data.contour;\n            for (const point of polyline) {\n                const indexPoint = imageData.worldToIndex(point);\n                indexPoint.forEach((v, idx) => {\n                    boundsIJK[idx][0] = Math.min(boundsIJK[idx][0], v);\n                    boundsIJK[idx][1] = Math.max(boundsIJK[idx][1], v);\n                });\n            }\n            boundsIJK.forEach((bound, idx) => {\n                bound[0] = Math.round(Math.max(0, bound[0]));\n                bound[1] = Math.round(Math.min(dimensions[idx] - 1, bound[1]));\n            });\n            const activeIndex = getActiveSegmentIndex(segmentationId);\n            const startPoint = annotation.data.handles?.[0] || polyline[0];\n            const startIndex = imageData.worldToIndex(startPoint).map(Math.round);\n            const startValue = segmentationVoxels.getAtIJKPoint(startIndex) || 0;\n            let hasZeroIndex = false;\n            let hasPositiveIndex = false;\n            for (const polyPoint of polyline) {\n                const polyIndex = imageData.worldToIndex(polyPoint).map(Math.round);\n                const polyValue = segmentationVoxels.getAtIJKPoint(polyIndex);\n                if (polyValue === startValue) {\n                    hasZeroIndex = true;\n                }\n                else if (polyValue >= 0) {\n                    hasPositiveIndex = true;\n                }\n            }\n            const hasBoth = hasZeroIndex && hasPositiveIndex;\n            const segmentIndex = hasBoth\n                ? startValue\n                : startValue === 0\n                    ? activeIndex\n                    : 0;\n            for (let i = boundsIJK[0][0]; i <= boundsIJK[0][1]; i++) {\n                for (let j = boundsIJK[1][0]; j <= boundsIJK[1][1]; j++) {\n                    for (let k = boundsIJK[2][0]; k <= boundsIJK[2][1]; k++) {\n                        const worldPoint = imageData.indexToWorld([i, j, k]);\n                        const isContained = isPointInsidePolyline3D(worldPoint, polyline);\n                        if (isContained) {\n                            previewVoxels.setAtIJK(i, j, k, segmentIndex);\n                        }\n                    }\n                }\n            }\n            if (removeContours) {\n                removeAnnotation(annotation.annotationUID);\n            }\n        }\n        const slices = previewVoxels.getArrayOfModifiedSlices();\n        triggerSegmentationDataModified(segmentationId, slices);\n    }\n}\nfunction lightenColor(r, g, b, a, factor = 0.4) {\n    return [\n        Math.round(r + (255 - r) * factor),\n        Math.round(g + (255 - g) * factor),\n        Math.round(b + (255 - b) * factor),\n        a,\n    ];\n}\n","import { getSegmentation } from '../../stateManagement/segmentation/getSegmentation';\nexport function addContourSegmentationAnnotation(annotation) {\n    if (annotation.parentAnnotationUID) {\n        return;\n    }\n    if (!annotation.data.segmentation) {\n        throw new Error('addContourSegmentationAnnotation: annotation does not have a segmentation data');\n    }\n    const { segmentationId, segmentIndex } = annotation.data.segmentation;\n    const segmentation = getSegmentation(segmentationId);\n    if (!segmentation.representationData.Contour) {\n        segmentation.representationData.Contour = { annotationUIDsMap: new Map() };\n    }\n    let { annotationUIDsMap } = segmentation.representationData.Contour;\n    if (!annotationUIDsMap) {\n        annotationUIDsMap = new Map();\n    }\n    let annotationsUIDsSet = annotationUIDsMap?.get(segmentIndex);\n    if (!annotationsUIDsSet) {\n        annotationsUIDsSet = new Set();\n        annotationUIDsMap.set(segmentIndex, annotationsUIDsSet);\n    }\n    annotationUIDsMap.set(segmentIndex, annotationsUIDsSet.add(annotation.annotationUID));\n}\n","import isObject from './isObject';\nfunction debounce(func, wait, options) {\n    let lastArgs, lastThis, maxWait, result, timerId, lastCallTime;\n    let lastInvokeTime = 0;\n    let leading = false;\n    let maxing = false;\n    let trailing = true;\n    const useRAF = !wait && wait !== 0 && typeof window.requestAnimationFrame === 'function';\n    if (typeof func !== 'function') {\n        throw new TypeError('Expected a function');\n    }\n    wait = Number(wait) || 0;\n    if (isObject(options)) {\n        leading = Boolean(options.leading);\n        maxing = 'maxWait' in options;\n        maxWait = maxing ? Math.max(Number(options.maxWait) || 0, wait) : maxWait;\n        trailing = 'trailing' in options ? Boolean(options.trailing) : trailing;\n    }\n    function invokeFunc(time) {\n        const args = lastArgs;\n        const thisArg = lastThis;\n        lastArgs = lastThis = undefined;\n        lastInvokeTime = time;\n        result = func.apply(thisArg, args);\n        return result;\n    }\n    function startTimer(pendingFunc, wait) {\n        if (useRAF) {\n            return window.requestAnimationFrame(pendingFunc);\n        }\n        return setTimeout(pendingFunc, wait);\n    }\n    function cancelTimer(id) {\n        if (useRAF) {\n            return window.cancelAnimationFrame(id);\n        }\n        clearTimeout(id);\n    }\n    function leadingEdge(time) {\n        lastInvokeTime = time;\n        timerId = startTimer(timerExpired, wait);\n        return leading ? invokeFunc(time) : result;\n    }\n    function remainingWait(time) {\n        const timeSinceLastCall = time - lastCallTime;\n        const timeSinceLastInvoke = time - lastInvokeTime;\n        const timeWaiting = wait - timeSinceLastCall;\n        return maxing\n            ? Math.min(timeWaiting, maxWait - timeSinceLastInvoke)\n            : timeWaiting;\n    }\n    function shouldInvoke(time) {\n        const timeSinceLastCall = time - lastCallTime;\n        const timeSinceLastInvoke = time - lastInvokeTime;\n        return (lastCallTime === undefined ||\n            timeSinceLastCall >= wait ||\n            timeSinceLastCall < 0 ||\n            (maxing && timeSinceLastInvoke >= maxWait));\n    }\n    function timerExpired() {\n        const time = Date.now();\n        if (shouldInvoke(time)) {\n            return trailingEdge(time);\n        }\n        timerId = startTimer(timerExpired, remainingWait(time));\n    }\n    function trailingEdge(time) {\n        timerId = undefined;\n        if (trailing && lastArgs) {\n            return invokeFunc(time);\n        }\n        lastArgs = lastThis = undefined;\n        return result;\n    }\n    function cancel() {\n        if (timerId !== undefined) {\n            cancelTimer(timerId);\n        }\n        lastInvokeTime = 0;\n        lastArgs = lastCallTime = lastThis = timerId = undefined;\n    }\n    function flush() {\n        return timerId === undefined ? result : trailingEdge(Date.now());\n    }\n    function pending() {\n        return timerId !== undefined;\n    }\n    function debounced(...args) {\n        const time = Date.now();\n        const isInvoking = shouldInvoke(time);\n        lastArgs = args;\n        lastThis = this;\n        lastCallTime = time;\n        if (isInvoking) {\n            if (timerId === undefined) {\n                return leadingEdge(lastCallTime);\n            }\n            if (maxing) {\n                timerId = startTimer(timerExpired, wait);\n                return invokeFunc(lastCallTime);\n            }\n        }\n        if (timerId === undefined) {\n            timerId = startTimer(timerExpired, wait);\n        }\n        return result;\n    }\n    debounced.cancel = cancel;\n    debounced.flush = flush;\n    debounced.pending = pending;\n    return debounced;\n}\nexport default debounce;\n","export default function getTextBoxCoordsCanvas(annotationCanvasPoints) {\n    const corners = _determineCorners(annotationCanvasPoints);\n    const centerY = (corners.top[1] + corners.bottom[1]) / 2;\n    const textBoxCanvas = [corners.right[0], centerY];\n    return textBoxCanvas;\n}\nfunction _determineCorners(canvasPoints) {\n    const handlesLeftToRight = [canvasPoints[0], canvasPoints[1]].sort(_compareX);\n    const handlesTopToBottom = [canvasPoints[0], canvasPoints[1]].sort(_compareY);\n    const right = handlesLeftToRight[handlesLeftToRight.length - 1];\n    const top = handlesTopToBottom[0];\n    const bottom = handlesTopToBottom[handlesTopToBottom.length - 1];\n    return {\n        top,\n        bottom,\n        right,\n    };\n    function _compareX(a, b) {\n        return a[0] < b[0] ? -1 : 1;\n    }\n    function _compareY(a, b) {\n        return a[1] < b[1] ? -1 : 1;\n    }\n}\n","import getViewportsForAnnotation from './getViewportsForAnnotation';\nexport default function getViewportForAnnotation(annotation) {\n    const viewports = getViewportsForAnnotation(annotation);\n    return viewports.length ? viewports[0] : undefined;\n}\n","function isObject(value) {\n    const type = typeof value;\n    return value !== null && (type === 'object' || type === 'function');\n}\nexport default isObject;\n","export default function pointInSphere(sphere, pointLPS) {\n    const { center, radius } = sphere;\n    const radius2 = sphere.radius2 || radius * radius;\n    return ((pointLPS[0] - center[0]) * (pointLPS[0] - center[0]) +\n        (pointLPS[1] - center[1]) * (pointLPS[1] - center[1]) +\n        (pointLPS[2] - center[2]) * (pointLPS[2] - center[2]) <=\n        radius2);\n}\n","import { vec3 } from 'gl-matrix';\nimport { utilities as csUtils } from '@cornerstonejs/core';\nconst { isEqual } = csUtils;\nconst iAxis = vec3.fromValues(1, 0, 0);\nconst jAxis = vec3.fromValues(0, 1, 0);\nconst kAxis = vec3.fromValues(0, 0, 1);\nconst axisList = [iAxis, jAxis, kAxis];\nfunction isAxisAlignedRectangle(rectangleCornersIJK) {\n    const rectangleVec1 = vec3.subtract(vec3.create(), rectangleCornersIJK[0], rectangleCornersIJK[1]);\n    const rectangleVec2 = vec3.subtract(vec3.create(), rectangleCornersIJK[0], rectangleCornersIJK[2]);\n    const anglesVec1 = calculateAnglesWithAxes(rectangleVec1, axisList);\n    const anglesVec2 = calculateAnglesWithAxes(rectangleVec2, axisList);\n    const isAligned = [...anglesVec1, ...anglesVec2].every((angle) => isEqual(angle, 0) ||\n        isEqual(angle, 90) ||\n        isEqual(angle, 180) ||\n        isEqual(angle, 270));\n    return isAligned;\n}\nfunction calculateAnglesWithAxes(vec, axes) {\n    return axes.map((axis) => (vec3.angle(vec, axis) * 180) / Math.PI);\n}\nexport { isAxisAlignedRectangle };\n","import debounce from './debounce';\nimport isObject from './isObject';\nfunction throttle(func, wait, options) {\n    let leading = true;\n    let trailing = true;\n    if (typeof func !== 'function') {\n        throw new TypeError('Expected a function');\n    }\n    if (isObject(options)) {\n        leading = 'leading' in options ? Boolean(options.leading) : leading;\n        trailing = 'trailing' in options ? Boolean(options.trailing) : trailing;\n    }\n    return debounce(func, wait, {\n        leading,\n        trailing,\n        maxWait: wait,\n    });\n}\nexport default throttle;\n","import { cache, StackViewport, BaseVolumeViewport, utilities, } from '@cornerstonejs/core';\nfunction isViewportPreScaled(viewport, targetId) {\n    if (viewport instanceof BaseVolumeViewport) {\n        const volumeId = utilities.getVolumeId(targetId);\n        const volume = cache.getVolume(volumeId);\n        return !!volume?.scaling && Object.keys(volume.scaling).length > 0;\n    }\n    else if (viewport instanceof StackViewport) {\n        const { preScale } = viewport.getImageData() || {};\n        return !!preScale?.scaled;\n    }\n    else {\n        return false;\n    }\n}\nexport { isViewportPreScaled };\n"],"names":["VIEWPORT_ELEMENT","getSvgNode","canvasHash","cacheKey","state","svgNodeCache","domRef","appendNode","svgLayerElement","svgNode","touched","appendChild","setNodeTouched","clearUntouched","Object","keys","forEach","cacheEntry","removeChild","element","enabledElement","getEnabledElement","viewportId","renderingEngineId","viewportElement","internalDivElement","querySelector","svgLayer","_getSvgLayer","svgNodeCacheForCanvas","bind","this","fn","svgDrawingHelper","annotationUID","circleUID","center","radius","options","dataId","color","fill","width","lineWidth","lineDash","fillOpacity","strokeOpacity","assign","undefined","strokeWidth","svgNodeHash","existingCircleElement","attributes","cx","cy","r","stroke","newCircleElement","document","createElementNS","setAttribute","handleGroupUID","handlePoints","handle","i","linkUID","annotationAnchorPoints","refPoint","boundingBox","start","length","findClosestPoint","boundingBoxPoints","x","left","y","top","height","halfWidth","halfHeight","_boundingBoxPoints","end","mergedOptions","drawLine","textBoxUID","textLines","textBoxPosition","textBox","handleRadius","centering","canvasBoundingBox","drawTextBox","drawRect","rectangleUID","topLeft","topRight","bottomLeft","bottomRight","segmentationStyle","constructor","config","global","segmentations","viewportsStyle","setStyle","specifier","styles","segmentationId","type","segmentIndex","currentStyles","getStyle","updatedStyles","copyActiveToInactiveIfNotProvided","Error","renderInactiveSegmentations","representations","repConfig","perSegment","allSegments","ALL_SEGMENTATIONS_KEY","segConfig","processedStyles","Labelmap","labelmapStyles","renderOutlineInactive","renderOutline","outlineWidthInactive","outlineWidth","renderFillInactive","renderFill","fillAlphaInactive","fillAlpha","outlineOpacityInactive","outlineOpacity","Contour","contourStyles","outlineDashInactive","outlineDash","combinedStyle","getDefaultStyle","allSegmentationsKey","getRenderInactiveSegmentations","setRenderInactiveSegmentations","Surface","clearSegmentationStyle","clearAllSegmentationStyles","clearViewportStyle","clearAllViewportStyles","resetToGlobalStyle","hasCustomStyle","style","defaultStyle","utilities","triggerSegmentationDataModified","modifiedSlicesToUse","eventDetail","triggerEvent","eventTarget","Events","SEGMENTATION_DATA_MODIFIED","getActiveSegmentation","getSegmentationRepresentationVisibility","data","segmentation","representationData","console","warn","getRenderingEngines","find","re","getViewports","vp","id","toolGroupFilteredByIds","toolGroups","filter","tg","viewportsInfo","some","PlanarFreehandContourSegmentationTool","toolName","toolProps","super","configuration","calculateStats","allowOpenContours","isContourSegmentationTool","renderAnnotationInstance","renderContext","annotation","invalidated","renderResult","pointCanProjectOnLine","polyline","EPSILON","CONSTANTS","PARALLEL_THRESHOLD","PlanarFreehandROITool","defaultToolProps","supportedInteractionTypes","storePointData","shadow","preventHandleOutsideImage","contourHoleAdditionModifierKey","KeyboardBindings","Shift","alwaysRenderOpenContourHandles","enabled","closeContourProximity","checkCanvasEditFallbackProximity","makeClockWise","subPixelResolution","smoothing","smoothOnAdd","smoothOnEdit","knotsRatioPercentageOnAdd","knotsRatioPercentageOnEdit","interpolation","onInterpolationComplete","decimate","epsilon","displayOnePointAsCrosshairs","getTextLines","defaultGetTextLines","statsCalculator","BasicStatsCalculator","isDrawing","isEditingClosed","isEditingOpen","addNewAnnotation","evt","detail","createAnnotation","addAnnotation","viewportIdsToRender","getViewportIdsWithToolToRender","getToolName","activateDraw","preventDefault","handleSelectedCallback","activateOpenContourEndEdit","toolSelectedCallback","contour","closed","activateClosedContourEdit","activateOpenContourEdit","isPointNearTool","canvasCoords","proximity","viewport","points","previousPoint","worldToCanvas","p1","p2","pStart","pEnd","cancel","cancelDrawing","cancelOpenContourEdit","cancelClosedContourEdit","_calculateCachedStats","renderingEngine","cachedStats","targetIds","targetId","image","getTargetImageData","imageData","metadata","canvasCoordinates","map","p","modalityUnitOptions","isPreScaled","isSuvScaled","referencedImageId","modalityUnit","Modality","calibratedScale","numPoints","projectedPolyline","Array","maxX","canvasMaxX","maxY","canvasMaxY","minX","canvasMinX","minY","canvasMinY","topLeftBBWorld","canvasToWorld","topLeftBBIndex","bottomRightBBWorld","updateClosedCachedStats","updateOpenCachedStats","triggerAnnotationModified","ChangeTypes","StatsUpdated","_renderStats","getTargetId","styleSpecifier","toolGroupId","getLinkedTextBoxStyle","visibility","handles","hasMoved","canvasTextBoxCoords","getTextBoxCoordsCanvas","worldPosition","drawLinkedTextBox","worldBoundingBox","_throttledCalculateCachedStats","trailing","filterInteractableAnnotationsForElement","annotations","annotationsToDisplay","VolumeViewport","camera","getCamera","spacingInNormalDirection","filterAnnotationsWithinSlice","filterAnnotationsForDisplay","viewPlaneNormal","annotationsWithParallelNormals","td","annotationViewPlaneNormal","isParallel","Math","abs","halfSpacingInNormalDirection","focalPoint","annotationsWithinSlice","point","isVisible","dir","dot","push","worldPos","currentPoints","world","contourAnnotation","label","getAnnotationStyle","context","renderStatus","activeAnnotationUID","commonData","renderContourBeingDrawn","renderClosedContourBeingEdited","renderOpenContourBeingEdited","renderPointContourWithMarker","renderContour","_calculateStatsIfActive","movingTextBox","unit","area","max","mean","stdDev","areaUnit","scale","voxelManager","getImageData","canvasPoint","originalWorldPoint","deltaXPoint","deltaYPoint","deltaInX","deltaInY","worldPosIndex","floor","iMin","iMax","jMin","jMax","kMin","kMax","j","min","worldPosIndex2","iDelta","jDelta","kDelta","ceil","boundsIJK","worldPosEnd","indexToWorld","canvasPosEnd","curRow","intersections","intersectionCounter","pointsInShape","statsCallback","isInObject","pointLPS","_pointIJK","result","getLineSegmentIntersectionsCoordinates","sort","a","b","shift","returnPoints","stats","getStatistics","perimeter","value","statsArray","array","cachedVolumeStats","isEmptyArea","areaLine","Number","isFinite","transformWorldToIndex","RectangleROITool","createAnnotationForViewport","editData","handleIndex","newAnnotation","_activateDraw","hideElementCursor","canvasPoint1","canvasPoint2","rect","_getRectangleImageCoordinates","highlighted","_activateModify","findIndex","_endCallback","activeHandleIndex","_deactivateModify","_deactivateDraw","resetElementCursor","doneEditMemo","isHandleOutsideImage","triggerAnnotationCompleted","_dragCallback","createMemo","deltaPoints","worldPosDelta","bottomLeftCanvas","bottomRightCanvas","topLeftCanvas","topRightCanvas","bottomLeftWorld","bottomRightWorld","topLeftWorld","topRightWorld","HandlesUpdated","isInteractingWithTool","addEventListener","MOUSE_UP","MOUSE_DRAG","MOUSE_MOVE","MOUSE_CLICK","TOUCH_END","TOUCH_DRAG","TOUCH_TAP","removeEventListener","renderAnnotation","getRenderingEngine","viewUp","startsWith","getStackViewports","referencedImageURI","hasImageURI","currentImageURI","getCurrentImageId","activeHandleCanvasCoords","isAnnotationVisible","isAnnotationLocked","drawHandles","point0","point1","worldPos1","worldPos2","dimensions","pos1Index","pos2Index","_isInsideVolume","worldWidth","worldHeight","pixelUnitsOptions","index1","index2","hydrate","getEnabledElementByViewportId","FrameOfReferenceUID","instance","hydrateBase","autoGenerated","isLocked","LabelmapBaseTool","previewData","preview","timerStart","timer","startPoint","NaN","isDrag","memoMap","Map","acceptedMemoIds","centerSegmentIndexInfo","hasSegmentIndex","hasPreviewIndex","changedIndices","_historyRedoHandler","operationType","has","_hoverData","memoData","get","operationData","getOperationData","applyActiveStrategyCallback","StrategyCallbacks","AcceptPreview","_previewData","segmentationVoxelManager","voxelManagerId","memo","redoVoxelManager","set","createEditData","activeSegmentation","event","CustomEvent","Enums","ERROR_EVENT","message","cancelable","dispatchEvent","segmentsLocked","getLockedSegmentIndices","getEditData","BaseVolumeViewport","volumeId","actors","getActors","volumes","actorEntry","cache","getVolume","referencedId","segmentationVolume","referencedVolumeIdToThreshold","volume","referencedVolumeId","threshold","segmentationImageId","imageId","createHoverData","centerCanvas","segmentColor","getActiveSegmentationData","brushCursor","getFrameOfReferenceUID","activeRepresentation","getSegmentIndexColor","_editData","configColor","previewColors","previewColor","previewSegmentIndex","g","factor","round","lightenColor","previewOnHover","activeStrategy","addPreview","acceptReject","acceptPreview","rejectPreview","results","AddPreview","RejectPreview","viewportContoursToLabelmap","removeContours","getAllAnnotations","viewAnnotations","contourAnnotations","strategies","FILL_INSIDE_CIRCLE","fillInsideCircle","previewVoxels","segmentationVoxels","sourceVoxelManager","getDefaultActor","actor","getMapper","getInputData","Infinity","worldToIndex","v","idx","bound","activeIndex","startIndex","startValue","getAtIJKPoint","hasZeroIndex","hasPositiveIndex","polyPoint","polyIndex","polyValue","k","worldPoint","isPointInsidePolyline3D","setAtIJK","removeAnnotation","slices","getArrayOfModifiedSlices","addContourSegmentationAnnotation","parentAnnotationUID","annotationUIDsMap","annotationsUIDsSet","Set","add","func","wait","lastArgs","lastThis","maxWait","timerId","lastCallTime","lastInvokeTime","leading","maxing","useRAF","window","requestAnimationFrame","TypeError","invokeFunc","time","args","thisArg","apply","startTimer","pendingFunc","setTimeout","shouldInvoke","timeSinceLastCall","timerExpired","Date","now","trailingEdge","timeSinceLastInvoke","timeWaiting","remainingWait","debounced","isInvoking","leadingEdge","Boolean","cancelAnimationFrame","clearTimeout","cancelTimer","flush","pending","annotationCanvasPoints","corners","canvasPoints","handlesLeftToRight","_compareX","handlesTopToBottom","_compareY","right","bottom","_determineCorners","centerY","getViewportForAnnotation","viewports","pointInSphere","sphere","radius2","isEqual","axisList","isAxisAlignedRectangle","rectangleCornersIJK","rectangleVec1","rectangleVec2","calculateAnglesWithAxes","every","angle","vec","axes","axis","PI","isViewportPreScaled","scaling","StackViewport","preScale","scaled"],"sourceRoot":""}