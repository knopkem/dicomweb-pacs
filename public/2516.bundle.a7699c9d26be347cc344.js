"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[2516,5830],{82516:(e,t,n)=>{n.r(t),n.d(t,{getDefaultWebWorker:()=>y,getPipelineWorkerUrl:()=>p,getPipelinesBaseUrl:()=>c,morphologicalContourInterpolation:()=>g,setDefaultWebWorker:()=>h,setPipelineWorkerUrl:()=>d,setPipelinesBaseUrl:()=>l,version:()=>a});const a="1.1.0";var r=n(5830);let i,s,o=`https://cdn.jsdelivr.net/npm/@itk-wasm/morphological-contour-interpolation@${a}/dist/pipelines`;function l(e){i=e}function c(){if(void 0!==i)return i;const e=(0,r.getPipelinesBaseUrl)();return void 0!==e?e:o}const u=null;function d(e){s=e}function p(){if(void 0!==s)return s;const e=(0,r.getPipelineWorkerUrl)();return void 0!==e?e:u}let f=null;async function m(){const e=p(),t="string"!=typeof e&&void 0!==e?.href?e.href:e;f=await(0,r.createWebWorker)(t)}function h(e){f=e}async function y(){if(null!==f)return f.terminated&&await m(),f;const e=(0,r.getDefaultWebWorker)();return null!==e?e:(await m(),f)}const g=async function(e,t={}){const n=[{type:r.InterfaceTypes.Image}],a=[{type:r.InterfaceTypes.Image,data:e}],i=[];if(i.push("0"),i.push("0"),i.push("--memory-io"),t.label&&i.push("--label",t.label.toString()),t.axis&&i.push("--axis",t.axis.toString()),t.noHeuristicAlignment&&t.noHeuristicAlignment&&i.push("--no-heuristic-alignment"),t.noUseDistanceTransform&&t.noUseDistanceTransform&&i.push("--no-use-distance-transform"),t.useCustomSlicePositions&&t.useCustomSlicePositions&&i.push("--use-custom-slice-positions"),t.noUseExtrapolation&&t.noUseExtrapolation&&i.push("--no-use-extrapolation"),t.useBallStructuringElement&&t.useBallStructuringElement&&i.push("--use-ball-structuring-element"),t.labeledSliceIndicesAxis&&i.push("--labeled-slice-indices-axis",t.labeledSliceIndicesAxis.toString()),t.labeledSliceIndicesLabel&&i.push("--labeled-slice-indices-label",t.labeledSliceIndicesLabel.toString()),t.labeledSliceIndices){if(t.labeledSliceIndices.length<1)throw new Error('"labeled-slice-indices" option must have a length > 1');i.push("--labeled-slice-indices"),await Promise.all(t.labeledSliceIndices.map((async e=>{i.push(e.toString())})))}let s=t?.webWorker;void 0===s&&(s=await y());const{webWorker:o,returnValue:l,stderr:u,outputs:d}=await(0,r.runPipeline)("morphological-contour-interpolation",i,n,a,{pipelineBaseUrl:c(),pipelineWorkerUrl:p(),webWorker:s,noCopy:t?.noCopy});if(0!==l&&""!==u)throw new Error(u);return{webWorker:o,outputImage:d[0]?.data}}},5830:(e,t,n)=>{n.r(t),n.d(t,{FloatTypes:()=>y.A,Image:()=>c,ImageType:()=>o,IntTypes:()=>i.A,InterfaceTypes:()=>T.A,Mesh:()=>A,MeshType:()=>k,PixelTypes:()=>s,PolyData:()=>I,PolyDataType:()=>b,WorkerPool:()=>w,bufferToTypedArray:()=>r.A,castImage:()=>g,copyImage:()=>u,createWebWorker:()=>S,getDefaultWebWorker:()=>q,getFileExtension:()=>m,getMatrixElement:()=>h,getPipelineWorkerUrl:()=>V,getPipelinesBaseUrl:()=>L,imageSharedBufferOrCopy:()=>p,meshToPolyData:()=>Y,polyDataToMesh:()=>Z,readDICOMTags:()=>H,readDICOMTagsArrayBuffer:()=>J,readImageArrayBuffer:()=>_,readImageBlob:()=>ee,readImageDICOMArrayBufferSeries:()=>X,readImageDICOMFileSeries:()=>K,readImageFile:()=>te,readImageFileSeries:()=>ne,readMeshArrayBuffer:()=>ae,readMeshFile:()=>re,runPipeline:()=>j,setDefaultWebWorker:()=>G,setPipelineWorkerUrl:()=>Q,setPipelinesBaseUrl:()=>M,stackImages:()=>f,version:()=>a});const a="1.0.0-b.165";var r=n(47911),i=n(44835);const s={Unknown:"Unknown",Scalar:"Scalar",RGB:"RGB",RGBA:"RGBA",Offset:"Offset",Vector:"Vector",Point:"Point",CovariantVector:"CovariantVector",SymmetricSecondRankTensor:"SymmetricSecondRankTensor",DiffusionTensor3D:"DiffusionTensor3D",Complex:"Complex",FixedArray:"FixedArray",Array:"Array",Matrix:"Matrix",VariableLengthVector:"VariableLengthVector",VariableSizeMatrix:"VariableSizeMatrix"};const o=class{dimension;componentType;pixelType;components;constructor(e=2,t=i.A.UInt8,n=s.Scalar,a=1){this.dimension=e,this.componentType=t,this.pixelType=n,this.components=a}};const l=function(e,t,n,a,r){e[a+n*t]=r};const c=class{imageType;name="image";origin;spacing;direction;size;metadata;data;constructor(e=new o){this.imageType=e;const t=e.dimension;this.origin=new Array(t),this.origin.fill(0),this.spacing=new Array(t),this.spacing.fill(1),this.direction=new Float64Array(t*t),this.direction.fill(0);for(let e=0;e<t;e++)l(this.direction,t,e,e,1);this.size=new Array(t),this.size.fill(0),this.metadata=new Map,this.data=null}};const u=function(e){const t=new c(e.imageType);if(t.name=e.name,t.origin=Array.from(e.origin),t.spacing=Array.from(e.spacing),t.direction=e.direction.slice(),t.size=Array.from(e.size),null!==e.data){const n=e.data.constructor;t.data=new n(e.data.length),null!=t.data&&t.data.set(e.data,0)}return t},d="function"==typeof globalThis.SharedArrayBuffer;const p=function(e){if(null===e.data)return e;if(d){if(e.data.buffer instanceof SharedArrayBuffer)return e;const t=new SharedArrayBuffer(e.data.buffer.byteLength),n=new(0,e.data.constructor)(t);return null!==n&&n.set(e.data,0),e.data=n,e}return u(e)};const f=function(e){if(e.length<1)throw Error("At least one images is required.");const t=e[0];if(null===t.data)throw Error("Image data is null.");const n=new c(t.imageType);n.origin=Array.from(t.origin),n.spacing=Array.from(t.spacing);const a=n.imageType.dimension;n.direction=t.direction.slice();const r=a-1;n.size=Array.from(t.size);const i=e.reduce(((e,t)=>e+t.size[r]),0);n.size[r]=i;const s=n.size.reduce(((e,t)=>e*t),1)*n.imageType.components,o=t.data.constructor;n.data=new o(s);let l=n.imageType.components;for(let e=0;e<n.size.length-1;e++)l*=n.size[e];let u=0;if(null==n.data)throw Error("Could not create result image data.");for(let t=0;t<e.length;t++)n.data.set(e[t].data,l*u),u+=e[t].size[r];return n};const m=function(e){let t=e.slice(2+(e.lastIndexOf(".")-1>>>0));if("gz"===t.toLowerCase()){const n=e.slice(0,-3).lastIndexOf(".");t=e.slice(2+(n-1>>>0))}else if("cbor"===t.toLowerCase()){const n=e.slice(0,-5).lastIndexOf(".");t=e.slice(2+(n-1>>>0))}else if("zst"===t.toLowerCase()){const n=e.slice(0,-10).lastIndexOf(".");t=e.slice(2+(n-1>>>0))}else if("zip"===t.toLowerCase()){const n=e.slice(0,-4).lastIndexOf(".");t=e.slice(2+(n-1>>>0))}return t};const h=function(e,t,n,a){return e[a+n*t]};var y=n(74112);const g=function(e,t){const n={...e.imageType};if(void 0!==t&&void 0!==t.pixelType&&(n.pixelType=t.pixelType,t.pixelType===s.Scalar&&1!==n.components))throw new Error("Cannot cast multi-component image to a scalar image");void 0!==t&&void 0!==t.componentType&&t.componentType!==e.imageType.componentType&&(n.componentType=t.componentType);const a=new c(n);if(a.name=e.name,a.origin=Array.from(e.origin),a.spacing=Array.from(e.spacing),a.direction=e.direction.slice(),a.size=Array.from(e.size),a.metadata=new Map(JSON.parse(JSON.stringify(Array.from(e.metadata)))),null!==e.data)if(void 0!==t&&void 0!==t.componentType&&t.componentType!==e.imageType.componentType)switch(e.imageType.componentType){case i.A.UInt8:case i.A.Int8:case i.A.UInt16:case i.A.Int16:case i.A.UInt32:case i.A.Int32:case y.A.Float32:case y.A.Float64:switch(a.imageType.componentType){case i.A.UInt8:a.data=new Uint8Array(e.data);break;case i.A.Int8:a.data=new Int8Array(e.data);break;case i.A.UInt16:a.data=new Uint16Array(e.data);break;case i.A.Int16:a.data=new Int16Array(e.data);break;case i.A.UInt32:a.data=new Uint32Array(e.data);break;case i.A.Int32:a.data=new Int32Array(e.data);break;case y.A.Float32:a.data=new Float32Array(e.data);break;case y.A.Float64:a.data=new Float64Array(e.data);break;case i.A.UInt64:a.data=new BigUint64Array(e.data.length);for(let t=0;t<a.data.length;t++)a.data[t]=BigInt.asIntN(64,BigInt(e.data[t]));break;case i.A.Int64:a.data=new BigInt64Array(e.data.length);for(let t=0;t<a.data.length;t++)a.data[t]=BigInt.asUintN(64,BigInt(e.data[t]))}break;case i.A.UInt64:case i.A.Int64:switch(a.imageType.componentType){case i.A.UInt8:a.data=new Uint8Array(e.data.length);for(let t=0;t<a.data.length;t++)a.data[t]=Number(e.data[t]);break;case i.A.Int8:a.data=new Int8Array(e.data.length);for(let t=0;t<a.data.length;t++)a.data[t]=Number(e.data[t]);break;case i.A.UInt16:a.data=new Uint16Array(e.data.length);for(let t=0;t<a.data.length;t++)a.data[t]=Number(e.data[t]);break;case i.A.Int16:a.data=new Int16Array(e.data.length);for(let t=0;t<a.data.length;t++)a.data[t]=Number(e.data[t]);break;case i.A.UInt32:a.data=new Uint32Array(e.data.length);for(let t=0;t<a.data.length;t++)a.data[t]=Number(e.data[t]);break;case i.A.Int32:a.data=new Int32Array(e.data.length);for(let t=0;t<a.data.length;t++)a.data[t]=Number(e.data[t]);break;case y.A.Float32:a.data=new Float32Array(e.data.length);for(let t=0;t<a.data.length;t++)a.data[t]=Number(e.data[t]);break;case y.A.Float64:a.data=new Float64Array(e.data.length);for(let t=0;t<a.data.length;t++)a.data[t]=Number(e.data[t]);break;case i.A.UInt64:a.data=new BigUint64Array(e.data);break;case i.A.Int64:a.data=new BigInt64Array(e.data)}}else{const t=e.data.constructor;a.data=new t(e.data.length),null!=a.data&&a.data.set(e.data,0)}return a};const w=class{fcn;workerQueue;runInfo;constructor(e,t){this.fcn=t,this.workerQueue=new Array(e),this.workerQueue.fill(null),this.runInfo=[]}runTasks(e,t=null){const n={taskQueue:[],results:[],addingTasks:!1,postponed:!1,runningWorkers:0,index:0,completedTasks:0,progressCallback:t,canceled:!1};return this.runInfo.push(n),n.index=this.runInfo.length-1,{promise:new Promise(((t,a)=>{n.resolve=t,n.reject=a,n.results=new Array(e.length),n.completedTasks=0,n.addingTasks=!0,e.forEach(((e,t)=>{this.addTask(n.index,t,e)})),n.addingTasks=!1})),runId:n.index}}terminateWorkers(){for(let e=0;e<this.workerQueue.length;e++){const t=this.workerQueue[e];null!=t&&t.terminate(),this.workerQueue[e]=null}}cancel(e){const t=this.runInfo[e];null!=t&&(t.canceled=!0)}addTask(e,t,n){const a=this.runInfo[e];if(!0===a?.canceled)return a.reject("Remaining tasks canceled"),void this.clearTask(a.index);if(this.workerQueue.length>0){const r=this.workerQueue.pop();a.runningWorkers++,n[n.length-1].webWorker=r,this.fcn(...n).then((({webWorker:n,...r})=>{if(this.workerQueue.push(n),null!==this.runInfo[e])if(a.runningWorkers--,a.results[t]=r,a.completedTasks++,null!=a.progressCallback&&a.progressCallback(a.completedTasks,a.results.length),a.taskQueue.length>0){const t=a.taskQueue.shift();this.addTask(e,t[0],t[1])}else if(!a.addingTasks&&0===a.runningWorkers){const e=a.results;a.resolve(e),this.clearTask(a.index)}})).catch((e=>{a.reject(e),this.clearTask(a.index)}))}else 0!==a.runningWorkers||a.postponed?a.taskQueue.push([t,n]):(a.postponed=!0,setTimeout((()=>{a.postponed=!1,this.addTask(a.index,t,n)}),50))}clearTask(e){this.runInfo[e].results=[],this.runInfo[e].taskQueue=[],this.runInfo[e].progressCallback=null,this.runInfo[e].canceled=null,this.runInfo[e].reject=()=>{},this.runInfo[e].resolve=()=>{}}};const k=class{dimension;pointComponentType;pointPixelComponentType;pointPixelType;pointPixelComponents;cellComponentType;cellPixelComponentType;cellPixelType;cellPixelComponents;constructor(e=2,t=y.A.Float32,n=y.A.Float32,a=s.Scalar,r=1,o=i.A.Int32,l=y.A.Float32,c=s.Scalar,u=1){this.dimension=e,this.pointComponentType=t,this.pointPixelComponentType=n,this.pointPixelType=a,this.pointPixelComponents=r,this.cellComponentType=o,this.cellPixelComponentType=l,this.cellPixelType=c,this.cellPixelComponents=u}};const A=class{mt;meshType;name="mesh";numberOfPoints;points;numberOfPointPixels;pointData;numberOfCells;cells;cellBufferSize;numberOfCellPixels;cellData;constructor(e=new k){this.mt=e,this.meshType=e,this.name="mesh",this.numberOfPoints=0,this.points=null,this.numberOfPointPixels=0,this.pointData=null,this.numberOfCells=0,this.cellBufferSize=0,this.cells=null,this.numberOfCellPixels=0,this.cellData=null}};const b=class{pointPixelComponentType;pointPixelType;pointPixelComponents;cellPixelComponentType;cellPixelType;cellPixelComponents;constructor(e=y.A.Float32,t=s.Scalar,n=1,a=y.A.Float32,r=s.Scalar,i=1){this.pointPixelComponentType=e,this.pointPixelType=t,this.pointPixelComponents=n,this.cellPixelComponentType=a,this.cellPixelType=r,this.cellPixelComponents=i}};const I=class{polyDataType;name="PolyData";numberOfPoints;points;verticesBufferSize;vertices;linesBufferSize;lines;polygonsBufferSize;polygons;triangleStripsBufferSize;triangleStrips;numberOfPointPixels;pointData;numberOfCellPixels;cellData;constructor(e=new b){this.polyDataType=e,this.polyDataType=e,this.name="PolyData",this.numberOfPoints=0,this.points=new Float32Array,this.verticesBufferSize=0,this.vertices=null,this.linesBufferSize=0,this.lines=null,this.polygonsBufferSize=0,this.polygons=null,this.triangleStripsBufferSize=0,this.triangleStrips=null,this.numberOfPointPixels=0,this.pointData=null,this.numberOfCellPixels=0,this.cellData=null}};var T=n(16881),x=n(99178),P=n(17739);const S=async function(e){const t=e;let a=null;if(null===t)a=new Worker(new URL(n.p+n.u(6376),n.b),{type:void 0});else if(t.startsWith("http")){const e=await P.Ay.get(t,{responseType:"blob"}),n=URL.createObjectURL(e.data);a=new Worker(n,{type:"module"})}else a=new Worker(t,{type:"module"});return a};function U(e){const t=x.LV(e),n=e;return n.terminated=!1,n.workerProxy=t,n.originalTerminate=n.terminate,n.terminate=()=>{n.terminated=!0,n.workerProxy[x.A2](),n.originalTerminate()},{workerProxy:t,worker:n}}const C=async function(e,t){let n;if(null!=e){const t=e;return void 0!==t.workerProxy?(n=t.workerProxy,{workerProxy:n,worker:t}):U(e)}return U(await S(t))};const B=async function(e,t){let n="unknown";n="string"!=typeof e?e.href:e.startsWith("http")?e:void 0!==t?`${t}/${e}`:e,n.endsWith(".js")&&(n=n.substring(0,n.length-3)),n.endsWith(".wasm")&&(n=n.substring(0,n.length-5));const a=`${n}.wasm`,r=(await P.Ay.get(a,{responseType:"arraybuffer"})).data,i=`${n}.js`;return(await import(i)).default({wasmBinary:r})};var W=n(8792),D=n(46619),v=n(27295),F=n(50295),O=n(3099);let z,E;function M(e){z=e}function L(){return z}function Q(e){E=e}function V(){return E}const N=new Map;function R(){let e=L();return void 0===e&&(e=new URL("/pipelines",document.location.origin).href),e}const j=async function(e,t,n,a,r){if(!await(async()=>WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,5,1,96,0,1,123,3,2,1,0,10,10,1,8,0,65,0,253,15,253,98,11])))()){const e="WebAssembly SIMD support is required -- please update your browser.";throw alert(e),new Error(e)}const i=r?.webWorker??null;if(!1===i){const i=await async function(e,t){let n=e,a=e;if("string"!=typeof e&&(n=new URL(e.href),a=n.href),N.has(a))return N.get(a);{const n=await B(e,t?.toString()??R());return N.set(a,n),n}}(e.toString(),r?.pipelineBaseUrl);return(0,W.A)(i,t,n,a)}let s=i;const o=r?.pipelineWorkerUrl??function(){let e=V();return void 0===e&&(e=null),e}(),l="string"!=typeof o&&void 0!==o?.href?o.href:o,{workerProxy:c,worker:u}=await C(s,l);s=u;const d=[];null!=a&&a.length>0&&a.forEach((function(e){if(e.type===T.A.BinaryStream){const t=e.data.data;d.push(t)}else if(e.type===T.A.BinaryFile){const t=e.data.data;d.push(t)}else if(e.type===T.A.Image){const t=e.data;null!==t.data&&d.push(...(0,v.A)(t))}else if(e.type===T.A.Mesh){const t=e.data;d.push(...(0,F.A)(t))}else if(e.type===T.A.PolyData){const t=e.data;d.push(...(0,O.A)(t))}}));const p=r?.pipelineBaseUrl??R(),f="string"!=typeof p&&void 0!==p?.href?p.href:p,m=null!=a?x.k0(a,(0,D.A)(d,r?.noCopy)):null,h=await c.runPipeline(e.toString(),f,t,n,m);return{returnValue:h.returnValue,stdout:h.stdout,stderr:h.stderr,outputs:h.outputs,webWorker:s}};let $=null;function G(e){$=e}function q(){return $}const H=async function(e,t,n=null){throw new Error("readDICOMTags is deprecated. Use readDicomTags from @itk-wasm/dicom instead.")};const J=async function(e,t,n=null){throw new Error("readDICOMTagsArrayBuffer is deprecated. Use readDicomTags from @itk-wasm/dicom instead.")},K=async(e,t)=>{throw new Error("readImageDICOMFileSeries is deprecated. Use readImageDicomFileSeries from @itk-wasm/dicom instead.")},X=async(e,t,n)=>{throw new Error("readImageDICOMArrayBufferSeries is deprecated. Use readImageDicomFileSeries from @itk-wasm/dicom instead.")};const Y=async function(e,t){throw new Error("This function has been migrated to the @itk-wasm/mesh-to-poly-data package.")};const Z=async function(e,t){throw new Error("This function has been migrated to the @itk-wasm/mesh-to-poly-data package.")};const _=async function(e,t,n,a){throw new Error("readImageArrayBuffer is deprecated. Use readImageFile from @itk-wasm/image-io instead.")};const ee=async function(e,t,n,a){throw new Error("readImageBlob is deprecated. Use readImageFile from @itk-wasm/image-io instead.")};const te=async function(e,t,n){throw new Error("readImageFile is deprecated. Use readImageFile from @itk-wasm/image-io instead.")};const ne=async function(e,t,n,a){throw new Error("readImageFileSeries is deprecated. Use readImageFileSeries from @itk-wasm/image-io instead.")};const ae=async function(e,t,n,a){throw new Error("readMeshArrayBuffer is deprecated. Use readMeshFile from @itk-wasm/mesh-io instead.")};const re=async function(e,t){throw new Error("readMeshFile is deprecated. Use readMeshFile from @itk-wasm/mesh-io instead.")}}}]);
//# sourceMappingURL=2516.bundle.a7699c9d26be347cc344.js.map