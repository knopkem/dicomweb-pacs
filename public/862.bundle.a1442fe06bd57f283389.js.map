{"version":3,"file":"862.bundle.a1442fe06bd57f283389.js","mappings":"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","sources":["webpack:///../../../extensions/measurement-tracking/src/viewports/TrackedCornerstoneViewport.tsx"],"sourcesContent":["import React, { useState, useEffect, useCallback } from 'react';\nimport PropTypes from 'prop-types';\n\nimport { Tooltip, Icon, ViewportActionArrows, useViewportGrid } from '@ohif/ui';\n\nimport { annotation } from '@cornerstonejs/tools';\nimport { useTrackedMeasurements } from './../getContextModule';\nimport { BaseVolumeViewport, Enums } from '@cornerstonejs/core';\nimport { useTranslation } from 'react-i18next';\n\nfunction TrackedCornerstoneViewport(props) {\n  const { displaySets, viewportId, servicesManager, extensionManager } = props;\n\n  const {\n    measurementService,\n    cornerstoneViewportService,\n    viewportGridService,\n    viewportActionCornersService,\n  } = servicesManager.services;\n\n  // Todo: handling more than one displaySet on the same viewport\n  const displaySet = displaySets[0];\n  const { t } = useTranslation('Common');\n\n  const [viewportGrid] = useViewportGrid();\n  const { activeViewportId } = viewportGrid;\n\n  const [trackedMeasurements, sendTrackedMeasurementsEvent] = useTrackedMeasurements();\n\n  const [isTracked, setIsTracked] = useState(false);\n  const [trackedMeasurementUID, setTrackedMeasurementUID] = useState(null);\n  const [viewportElem, setViewportElem] = useState(null);\n\n  const { trackedSeries } = trackedMeasurements.context;\n\n  const { SeriesInstanceUID } = displaySet;\n\n  const updateIsTracked = useCallback(() => {\n    const viewport = cornerstoneViewportService.getCornerstoneViewport(viewportId);\n\n    if (viewport instanceof BaseVolumeViewport) {\n      // A current image id will only exist for volume viewports that can have measurements tracked.\n      // Typically these are those volume viewports for the series of acquisition.\n      const currentImageId = viewport?.getCurrentImageId();\n\n      if (!currentImageId) {\n        if (isTracked) {\n          setIsTracked(false);\n        }\n        return;\n      }\n    }\n\n    if (trackedSeries.includes(SeriesInstanceUID) !== isTracked) {\n      setIsTracked(!isTracked);\n    }\n  }, [isTracked, trackedMeasurements, viewportId, SeriesInstanceUID]);\n\n  const onElementEnabled = useCallback(\n    evt => {\n      if (evt.detail.element !== viewportElem) {\n        // The VOLUME_VIEWPORT_NEW_VOLUME event allows updateIsTracked to reliably fetch the image id for a volume viewport.\n        evt.detail.element?.addEventListener(\n          Enums.Events.VOLUME_VIEWPORT_NEW_VOLUME,\n          updateIsTracked\n        );\n        setViewportElem(evt.detail.element);\n      }\n    },\n    [updateIsTracked, viewportElem]\n  );\n\n  const onElementDisabled = useCallback(() => {\n    viewportElem?.removeEventListener(Enums.Events.VOLUME_VIEWPORT_NEW_VOLUME, updateIsTracked);\n  }, [updateIsTracked, viewportElem]);\n\n  useEffect(updateIsTracked, [updateIsTracked]);\n\n  useEffect(() => {\n    const { unsubscribe } = cornerstoneViewportService.subscribe(\n      cornerstoneViewportService.EVENTS.VIEWPORT_DATA_CHANGED,\n      props => {\n        if (props.viewportId !== viewportId) {\n          return;\n        }\n\n        updateIsTracked();\n      }\n    );\n\n    return () => {\n      unsubscribe();\n    };\n  }, [updateIsTracked, viewportId]);\n\n  useEffect(() => {\n    if (isTracked) {\n      annotation.config.style.setViewportToolStyles(viewportId, {\n        global: {\n          lineDash: '',\n        },\n      });\n\n      cornerstoneViewportService.getRenderingEngine().renderViewport(viewportId);\n\n      return;\n    }\n\n    annotation.config.style.setViewportToolStyles(viewportId, {\n      global: {\n        lineDash: '4,4',\n      },\n    });\n\n    cornerstoneViewportService.getRenderingEngine().renderViewport(viewportId);\n\n    return () => {\n      annotation.config.style.setViewportToolStyles(viewportId, {});\n    };\n  }, [isTracked]);\n\n  /**\n   * The effect for listening to measurement service measurement added events\n   * and in turn firing an event to update the measurement tracking state machine.\n   * The TrackedCornerstoneViewport is the best place for this because when\n   * a measurement is added, at least one TrackedCornerstoneViewport will be in\n   * the DOM and thus can react to the events fired.\n   */\n  useEffect(() => {\n    const added = measurementService.EVENTS.MEASUREMENT_ADDED;\n    const addedRaw = measurementService.EVENTS.RAW_MEASUREMENT_ADDED;\n    const subscriptions = [];\n\n    [added, addedRaw].forEach(evt => {\n      subscriptions.push(\n        measurementService.subscribe(evt, ({ source, measurement }) => {\n          const { activeViewportId } = viewportGridService.getState();\n\n          // Each TrackedCornerstoneViewport receives the MeasurementService's events.\n          // Only send the tracked measurements event for the active viewport to avoid\n          // sending it more than once.\n          if (viewportId === activeViewportId) {\n            const {\n              referenceStudyUID: StudyInstanceUID,\n              referenceSeriesUID: SeriesInstanceUID,\n              uid: measurementId,\n            } = measurement;\n\n            sendTrackedMeasurementsEvent('SET_DIRTY', { SeriesInstanceUID });\n            sendTrackedMeasurementsEvent('TRACK_SERIES', {\n              viewportId,\n              StudyInstanceUID,\n              SeriesInstanceUID,\n              measurementId,\n            });\n          }\n        }).unsubscribe\n      );\n    });\n\n    return () => {\n      subscriptions.forEach(unsub => {\n        unsub();\n      });\n    };\n  }, [measurementService, sendTrackedMeasurementsEvent, viewportId, viewportGridService]);\n\n  const switchMeasurement = useCallback(\n    direction => {\n      const newTrackedMeasurementUID = _getNextMeasurementUID(\n        direction,\n        servicesManager,\n        trackedMeasurementUID,\n        trackedMeasurements\n      );\n\n      if (!newTrackedMeasurementUID) {\n        return;\n      }\n\n      setTrackedMeasurementUID(newTrackedMeasurementUID);\n\n      measurementService.jumpToMeasurement(viewportId, newTrackedMeasurementUID);\n    },\n    [measurementService, servicesManager, trackedMeasurementUID, trackedMeasurements, viewportId]\n  );\n\n  useEffect(() => {\n    const statusComponent = _getStatusComponent(isTracked, t);\n    const arrowsComponent = _getArrowsComponent(\n      isTracked,\n      switchMeasurement,\n      viewportId === activeViewportId\n    );\n\n    viewportActionCornersService.setComponents([\n      {\n        viewportId,\n        id: 'viewportStatusComponent',\n        component: statusComponent,\n        indexPriority: -100,\n        location: viewportActionCornersService.LOCATIONS.topLeft,\n      },\n      {\n        viewportId,\n        id: 'viewportActionArrowsComponent',\n        component: arrowsComponent,\n        indexPriority: 0,\n        location: viewportActionCornersService.LOCATIONS.topRight,\n      },\n    ]);\n  }, [activeViewportId, isTracked, switchMeasurement, viewportActionCornersService, viewportId]);\n\n  const getCornerstoneViewport = () => {\n    const { component: Component } = extensionManager.getModuleEntry(\n      '@ohif/extension-cornerstone.viewportModule.cornerstone'\n    );\n\n    return (\n      <Component\n        {...props}\n        onElementEnabled={evt => {\n          props.onElementEnabled?.(evt);\n          onElementEnabled(evt);\n        }}\n        onElementDisabled={onElementDisabled}\n      />\n    );\n  };\n\n  return (\n    <>\n      <div className=\"relative flex h-full w-full flex-row overflow-hidden\">\n        {getCornerstoneViewport()}\n      </div>\n    </>\n  );\n}\n\nTrackedCornerstoneViewport.propTypes = {\n  displaySets: PropTypes.arrayOf(PropTypes.object.isRequired).isRequired,\n  viewportId: PropTypes.string.isRequired,\n  dataSource: PropTypes.object,\n  children: PropTypes.node,\n  customProps: PropTypes.object,\n};\n\nTrackedCornerstoneViewport.defaultProps = {\n  customProps: {},\n};\n\nfunction _getNextMeasurementUID(\n  direction,\n  servicesManager,\n  trackedMeasurementId,\n  trackedMeasurements\n) {\n  const { measurementService, viewportGridService } = servicesManager.services;\n  const measurements = measurementService.getMeasurements();\n\n  const { activeViewportId, viewports } = viewportGridService.getState();\n  const { displaySetInstanceUIDs: activeViewportDisplaySetInstanceUIDs } =\n    viewports.get(activeViewportId);\n\n  const { trackedSeries } = trackedMeasurements.context;\n\n  // Get the potentially trackable measurements for the series of the\n  // active viewport.\n  // The measurements to jump between are the same\n  // regardless if this series is tracked or not.\n\n  const filteredMeasurements = measurements.filter(\n    m =>\n      trackedSeries.includes(m.referenceSeriesUID) &&\n      activeViewportDisplaySetInstanceUIDs.includes(m.displaySetInstanceUID)\n  );\n\n  if (!filteredMeasurements.length) {\n    // No measurements on this series.\n    return;\n  }\n\n  const measurementCount = filteredMeasurements.length;\n\n  const uids = filteredMeasurements.map(fm => fm.uid);\n  let measurementIndex = uids.findIndex(uid => uid === trackedMeasurementId);\n\n  if (measurementIndex === -1) {\n    // Not tracking a measurement, or previous measurement now deleted, revert to 0.\n    measurementIndex = 0;\n  } else {\n    measurementIndex += direction;\n    if (measurementIndex < 0) {\n      measurementIndex = measurementCount - 1;\n    } else if (measurementIndex === measurementCount) {\n      measurementIndex = 0;\n    }\n  }\n\n  const newTrackedMeasurementId = uids[measurementIndex];\n\n  return newTrackedMeasurementId;\n}\n\nconst _getArrowsComponent = (isTracked, switchMeasurement, isActiveViewport) => {\n  if (!isTracked) {\n    return null;\n  }\n\n  return (\n    <ViewportActionArrows\n      onArrowsClick={direction => switchMeasurement(direction)}\n      className={isActiveViewport ? 'visible' : 'invisible group-hover:visible'}\n    ></ViewportActionArrows>\n  );\n};\n\nfunction _getStatusComponent(isTracked, t) {\n  if (!isTracked) {\n    return null;\n  }\n\n  return (\n    <div className=\"relative\">\n      <Tooltip\n        position=\"bottom-left\"\n        content={\n          <div className=\"flex py-2\">\n            <div className=\"flex pt-1\">\n              <Icon\n                name=\"info-link\"\n                className=\"text-primary-main w-4\"\n              />\n            </div>\n            <div className=\"ml-4 flex\">\n              <span className=\"text-common-light text-base\">\n                {isTracked ? (\n                  <>{t('Series is tracked and can be viewed in the measurement panel')}</>\n                ) : (\n                  <>\n                    {t(\n                      'Measurements for untracked series will not be shown in the measurements panel'\n                    )}\n                  </>\n                )}\n              </span>\n            </div>\n          </div>\n        }\n      >\n        <Icon\n          name={'viewport-status-tracked'}\n          className=\"text-aqua-pale\"\n        />\n      </Tooltip>\n    </div>\n  );\n}\n\nexport default TrackedCornerstoneViewport;\n"],"names":["TrackedCornerstoneViewport","props","displaySets","viewportId","servicesManager","extensionManager","measurementService","cornerstoneViewportService","viewportGridService","viewportActionCornersService","services","displaySet","t","useTranslation","viewportGrid","useViewportGrid","activeViewportId","trackedMeasurements","sendTrackedMeasurementsEvent","useTrackedMeasurements","isTracked","setIsTracked","useState","trackedMeasurementUID","setTrackedMeasurementUID","viewportElem","setViewportElem","trackedSeries","context","SeriesInstanceUID","updateIsTracked","useCallback","viewport","getCornerstoneViewport","BaseVolumeViewport","currentImageId","getCurrentImageId","includes","onElementEnabled","evt","detail","element","addEventListener","Enums","VOLUME_VIEWPORT_NEW_VOLUME","onElementDisabled","removeEventListener","useEffect","unsubscribe","subscribe","EVENTS","VIEWPORT_DATA_CHANGED","annotation","setViewportToolStyles","global","lineDash","getRenderingEngine","renderViewport","added","MEASUREMENT_ADDED","addedRaw","RAW_MEASUREMENT_ADDED","subscriptions","forEach","push","source","measurement","getState","referenceStudyUID","StudyInstanceUID","referenceSeriesUID","uid","measurementId","unsub","switchMeasurement","direction","newTrackedMeasurementUID","trackedMeasurementId","measurements","getMeasurements","viewports","displaySetInstanceUIDs","activeViewportDisplaySetInstanceUIDs","get","filteredMeasurements","filter","m","displaySetInstanceUID","length","measurementCount","uids","map","fm","measurementIndex","findIndex","_getNextMeasurementUID","jumpToMeasurement","statusComponent","React","className","Tooltip","position","content","Icon","name","_getStatusComponent","arrowsComponent","_getArrowsComponent","setComponents","id","component","indexPriority","location","LOCATIONS","topLeft","topRight","Component","getModuleEntry","_extends","propTypes","PropTypes","isRequired","dataSource","children","customProps","defaultProps","isActiveViewport","ViewportActionArrows","onArrowsClick"],"sourceRoot":""}