{"version":3,"file":"473.bundle.12e70051b6d1ab699f25.js","mappings":"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","sources":["webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/base/AnnotationTool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/displayTools/Labelmap/labelmapConfig.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/annotationFrameRange.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/boundingBox/extend2DBoundingBoxInViewAxis.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/boundingBox/getBoundingBoxAroundShape.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/calibrateImageSpacing.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/cine/events.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/cine/state.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/cine/playClip.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/clip.js","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/contourSegmentation/addContourSegmentationAnnotation.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/contourSegmentation/areSameSegment.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/contourSegmentation/isContourSegmentationAnnotation.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/contourSegmentation/removeContourSegmentationAnnotation.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/contours/AnnotationToPointData.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/contours/areCoplanarContours.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/contours/calculatePerimeter.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/contours/contourFinder.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/contours/detectContourHoles.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/contours/findHandlePolylineIndex.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/contours/generateContourSetsFromLabelmap.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/contours/getContourHolesDataCanvas.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/contours/getContourHolesDataWorld.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/contours/getDeduplicatedVTKPolyDataPoints.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/contours/interpolation/acceptAutogeneratedInterpolations.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/contours/updateContourPolyline.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/debounce.js","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/drawing/getTextBoxCoordsCanvas.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/dynamicVolume/getDataInTime.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/dynamicVolume/generateImageFromTimeData.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/getAnnotationNearPoint.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/getCalibratedUnits.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/getSphereBoundsInfo.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/getViewportForAnnotation.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/isObject.js","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/aabb/intersectAABB.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/aabb/distanceToPointSquared.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/aabb/distanceToPoint.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/basic/Calculator.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/basic/BasicStatsCalculator.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/ellipse/pointInEllipse.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/ellipse/getCanvasEllipseCorners.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/line/distanceToPointSquaredInfo.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/line/distanceToPointSquared.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/line/distanceToPoint.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/line/intersectLine.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/line/isPointOnLineSegment.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/point/distanceToPoint.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/point/distanceToPointSquared.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/point/mirror.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/polyline/isClosed.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/polyline/containsPoint.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/polyline/containsPoints.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/polyline/getArea.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/polyline/getSignedArea.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/polyline/getWindingDirection.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/polyline/getNormal3.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/polyline/getNormal2.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/polyline/areLineSegmentsIntersecting.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/polyline/getLineSegmentIntersectionsIndexes.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/polyline/getLinesIntersection.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/polyline/combinePolyline.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/polyline/getFirstLineSegmentIntersectionIndexes.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/polyline/intersectPolyline.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/polyline/decimate.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/polyline/getLineSegmentIntersectionsCoordinates.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/polyline/getClosestLineSegmentIntersection.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/polyline/getSubPixelSpacingAndXYDirections.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/polyline/pointsAreWithinCloseContourProximity.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/polyline/addCanvasPointsToArray.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/polyline/pointCanProjectOnLine.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/polyline/projectTo2D.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/polyline/isPointInsidePolyline3D.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/rectangle/distanceToPoint.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/sphere/pointInSphere.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/vec2/liangBarksyClip.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/orientation/getOrientationStringLPS.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/orientation/invertOrientationStringLPS.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/planar/index.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/planarFreehandROITool/index.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/pointInShapeCallback.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/pointInSurroundingSphereCallback.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/pointToString.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/polyData/utils.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/rectangleROITool/getBoundsIJKFromRectangleAnnotations.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/rectangleROITool/isAxisAlignedRectangle.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/scroll.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/segmentation/InterpolationManager/InterpolationManager.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/segmentation/brushSizeForToolGroup.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/segmentation/brushThresholdForToolGroup.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/segmentation/isLineInSegment.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/segmentation/findLargestBidirectional.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/segmentation/contourAndFindLargestBidirectional.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/segmentation/createBidirectionalToolData.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/segmentation/createImageIdReferenceMap.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/segmentation/createLabelmapVolumeForViewport.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/segmentation/createMergedLabelmapForIndex.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/segmentation/floodFill.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/segmentation/getDefaultRepresentationConfig.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/segmentation/getHoveredContourSegmentationAnnotation.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/segmentation/getSegmentAtLabelmapBorder.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/segmentation/getSegmentAtWorldPoint.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/segmentation/invalidateBrushCursor.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/segmentation/isValidRepresentationConfig.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/segmentation/rectangleROIThresholdVolumeByRange.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/segmentation/segmentContourAction.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/segmentation/thresholdSegmentationByRange.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/segmentation/thresholdVolumeByRange.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/segmentation/utilities.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/stackPrefetch/stackPrefetch.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/stackPrefetch/stackContextPrefetch.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/throttle.js","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/touch/index.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/triggerAnnotationRenderForToolGroupIds.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/viewport/isViewportPreScaled.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/viewport/jumpToSlice.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/viewport/jumpToWorld.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/viewportFilters/filterViewportsWithFrameOfReferenceUID.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/viewportFilters/filterViewportsWithToolEnabled.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/viewportFilters/filterViewportsWithParallelNormals.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/viewportFilters/getViewportIdsWithToolToRender.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/voi/colorbar/Colorbar.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/voi/colorbar/ViewportColorbar.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/voi/colorbar/enums/ColorbarRangeTextPosition.ts","webpack:///../../../node_modules/@kitware/vtk.js/Filters/General/ImageMarchingSquares.js"],"sourcesContent":["import {\n  BaseVolumeViewport,\n  cache,\n  getEnabledElement,\n  metaData,\n  utilities as csUtils,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { vec2 } from 'gl-matrix';\n\nimport AnnotationDisplayTool from './AnnotationDisplayTool';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport {\n  Annotation,\n  Annotations,\n  EventTypes,\n  ToolHandle,\n  InteractionTypes,\n  ToolProps,\n  PublicToolProps,\n} from '../../types';\nimport { addAnnotation } from '../../stateManagement/annotation/annotationState';\nimport { StyleSpecifier } from '../../types/AnnotationStyle';\nimport { triggerAnnotationModified } from '../../stateManagement/annotation/helpers/state';\n\n/**\n * Abstract class for tools which create and display annotations on the\n * cornerstone3D canvas. In addition, it provides a base class for segmentation\n * tools that require drawing an annotation before running the segmentation strategy\n * for instance threshold segmentation based on an area and a threshold.\n * Annotation tools make use of drawing utilities to draw SVG elements on the viewport.\n *\n * To create a new annotation tool, derive from this class and implement the\n * abstract methods.\n */\nabstract class AnnotationTool extends AnnotationDisplayTool {\n  /**\n   * Creates a base annotation object, adding in any annotation base data provided\n   */\n  public static createAnnotation(...annotationBaseData): Annotation {\n    let annotation: Annotation = {\n      annotationUID: null as string,\n      highlighted: true,\n      invalidated: true,\n      metadata: {\n        toolName: this.toolName,\n      },\n      data: {\n        text: '',\n        handles: {\n          points: new Array<Types.Point3>(),\n          textBox: {\n            hasMoved: false,\n            worldPosition: <Types.Point3>[0, 0, 0],\n            worldBoundingBox: {\n              topLeft: <Types.Point3>[0, 0, 0],\n              topRight: <Types.Point3>[0, 0, 0],\n              bottomLeft: <Types.Point3>[0, 0, 0],\n              bottomRight: <Types.Point3>[0, 0, 0],\n            },\n          },\n        },\n        label: '',\n      },\n    } as unknown as Annotation;\n    for (const baseData of annotationBaseData) {\n      annotation = csUtils.deepMerge(annotation, baseData);\n    }\n    return annotation;\n  }\n\n  /**\n   * Creates a new annotation for the given viewport.  This just adds the\n   * viewport reference data to the metadata, and otherwise returns the\n   * static class createAnnotation data.\n   */\n  public static createAnnotationForViewport(viewport, ...annotationBaseData) {\n    return this.createAnnotation(\n      { metadata: viewport.getViewReference() },\n      ...annotationBaseData\n    );\n  }\n\n  /**\n   * Creates and adds an annotation of the given type, firing the annotation\n   * modified event on the new annotation.\n   * This implicitly uses the static class when you call it on the correct\n   * base class.  For example, you can call the KeyImageTool.createAnnotation\n   * method on KeyImageTool.toolName by calling KeyImageTool.createAndAddAnnotation\n   *\n   */\n  public static createAndAddAnnotation(viewport, ...annotationBaseData) {\n    const annotation = this.createAnnotationForViewport(\n      viewport,\n      ...annotationBaseData\n    );\n    addAnnotation(annotation, viewport.element);\n    triggerAnnotationModified(annotation, viewport.element);\n  }\n\n  static toolName;\n  // ===================================================================\n  // Abstract Methods - Must be implemented.\n  // ===================================================================\n\n  constructor(toolProps: PublicToolProps, defaultToolProps: ToolProps) {\n    super(toolProps, defaultToolProps);\n\n    if (toolProps.configuration?.getTextLines) {\n      this.configuration.getTextLines = toolProps.configuration.getTextLines;\n    }\n\n    if (toolProps.configuration?.statsCalculator) {\n      this.configuration.statsCalculator =\n        toolProps.configuration.statsCalculator;\n    }\n  }\n\n  /**\n   * @abstract addNewAnnotation Creates a new annotation based on the clicked mouse position\n   *\n   * @param evt - The normalized mouse event\n   * @param interactionType -  The interaction type used to add the annotation.\n   */\n  abstract addNewAnnotation(\n    evt: EventTypes.InteractionEventType,\n    interactionType: InteractionTypes\n  ): Annotation;\n\n  /**\n   * @abstract cancel Used to cancel the ongoing tool drawing and manipulation\n   *\n   */\n  abstract cancel(element: HTMLDivElement);\n\n  /**\n   * handleSelectedCallback Custom callback for when a handle is selected.\n   *\n   * @param evt - The normalized mouse event\n   * @param annotation - The annotation selected.\n   * @param handle - The selected handle (either Types.Point3 in space for annotations, or TextBoxHandle object for text boxes).\n   * @param interactionType - The interaction type the handle was selected with.\n   */\n  abstract handleSelectedCallback(\n    evt: EventTypes.InteractionEventType,\n    annotation: Annotation,\n    handle: ToolHandle,\n    interactionType: InteractionTypes\n  ): void;\n\n  /**\n   * Custom callback for when an annotation is selected\n   *\n   * @param evt - The normalized mouse event\n   * @param annotation - The `Annotation` to check.\n   * @param interactionType - The interaction type used to select the tool.\n   */\n  abstract toolSelectedCallback(\n    evt: EventTypes.InteractionEventType,\n    annotation: Annotation,\n    interactionType: InteractionTypes,\n    canvasCoords?: Types.Point2\n  ): void;\n\n  /**\n   * Returns true if the provided canvas coordinate tool is near the annotation\n   *\n   * @param element - The HTML element\n   * @param annotation - The annotation to check\n   * @param canvasCoords - The canvas coordinate to check\n   * @param proximity - The minimum proximity to consider the point near\n   * @param interactionType - The interaction type used to select the tool.\n   *\n   * @returns boolean if the point is near.\n   */\n  abstract isPointNearTool(\n    element: HTMLDivElement,\n    annotation: Annotation,\n    canvasCoords: Types.Point2,\n    proximity: number,\n    interactionType: string\n  ): boolean;\n\n  /**\n   * @virtual Event handler for Cornerstone MOUSE_MOVE event.\n   *\n   *\n   * @param evt - The normalized mouse event\n   * @param filteredAnnotations - The annotations to check for hover interactions\n   * @returns True if the annotation needs to be re-drawn by the annotationRenderingEngine.\n   */\n  public mouseMoveCallback = (\n    evt: EventTypes.MouseMoveEventType,\n    filteredAnnotations?: Annotations\n  ): boolean => {\n    if (!filteredAnnotations) {\n      return false;\n    }\n\n    const { element, currentPoints } = evt.detail;\n    const canvasCoords = currentPoints.canvas;\n    let annotationsNeedToBeRedrawn = false;\n\n    for (const annotation of filteredAnnotations) {\n      // Do not do anything if the annotation is locked or hidden.\n      if (\n        isAnnotationLocked(annotation) ||\n        !isAnnotationVisible(annotation.annotationUID)\n      ) {\n        continue;\n      }\n\n      const { data } = annotation;\n      const activateHandleIndex = data.handles\n        ? data.handles.activeHandleIndex\n        : undefined;\n\n      // Perform tool specific imagePointNearToolOrHandle to determine if the mouse\n      // is near the tool or its handles or its textBox.\n      const near = this._imagePointNearToolOrHandle(\n        element,\n        annotation,\n        canvasCoords,\n        6 // Todo: This should come from the state\n      );\n\n      const nearToolAndNotMarkedActive = near && !annotation.highlighted;\n      const notNearToolAndMarkedActive = !near && annotation.highlighted;\n      if (nearToolAndNotMarkedActive || notNearToolAndMarkedActive) {\n        annotation.highlighted = !annotation.highlighted;\n        annotationsNeedToBeRedrawn = true;\n      } else if (\n        data.handles &&\n        data.handles.activeHandleIndex !== activateHandleIndex\n      ) {\n        // Active handle index has changed, re-render.\n        annotationsNeedToBeRedrawn = true;\n      }\n    }\n\n    return annotationsNeedToBeRedrawn;\n  };\n\n  /**\n   * It checks if the mouse click is near TextBoxHandle or AnnotationHandle itself, and\n   * return either it. It prioritize TextBoxHandle over AnnotationHandle. If\n   * the mouse click is not near any of the handles, it does not return anything.\n   *\n   * @param element - The element that the tool is attached to.\n   * @param annotation - The annotation object associated with the annotation\n   * @param canvasCoords - The coordinates of the mouse click on canvas\n   * @param proximity - The distance from the mouse cursor to the point\n   * that is considered \"near\".\n   * @returns The handle that is closest to the cursor, or null if the cursor\n   * is not near any of the handles.\n   */\n  getHandleNearImagePoint(\n    element: HTMLDivElement,\n    annotation: Annotation,\n    canvasCoords: Types.Point2,\n    proximity: number\n  ): ToolHandle | undefined {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n\n    const { data } = annotation;\n    const { isCanvasAnnotation } = data;\n    const { points, textBox } = data.handles;\n\n    if (textBox) {\n      const { worldBoundingBox } = textBox;\n      if (worldBoundingBox) {\n        const canvasBoundingBox = {\n          topLeft: viewport.worldToCanvas(worldBoundingBox.topLeft),\n          topRight: viewport.worldToCanvas(worldBoundingBox.topRight),\n          bottomLeft: viewport.worldToCanvas(worldBoundingBox.bottomLeft),\n          bottomRight: viewport.worldToCanvas(worldBoundingBox.bottomRight),\n        };\n\n        if (\n          canvasCoords[0] >= canvasBoundingBox.topLeft[0] &&\n          canvasCoords[0] <= canvasBoundingBox.bottomRight[0] &&\n          canvasCoords[1] >= canvasBoundingBox.topLeft[1] &&\n          canvasCoords[1] <= canvasBoundingBox.bottomRight[1]\n        ) {\n          data.handles.activeHandleIndex = null;\n          return textBox as ToolHandle;\n        }\n      }\n    }\n\n    for (let i = 0; i < points?.length; i++) {\n      const point = points[i];\n      const annotationCanvasCoordinate = isCanvasAnnotation\n        ? point.slice(0, 2)\n        : viewport.worldToCanvas(point);\n\n      const near =\n        vec2.distance(\n          canvasCoords,\n          annotationCanvasCoordinate as Types.Point2\n        ) < proximity;\n\n      if (near === true) {\n        data.handles.activeHandleIndex = i;\n        return point;\n      }\n    }\n\n    data.handles.activeHandleIndex = null;\n  }\n\n  /**\n   * It returns the style for the text box\n   * @param styleSpecifier - An object containing the specifications such as viewportId,\n   * toolGroupId, toolName and annotationUID which are used to get the style if the level of specificity is\n   * met (hierarchy is checked from most specific to least specific which is\n   * annotationLevel -> viewportLevel -> toolGroupLevel -> default.\n   * @param annotation - The annotation for the tool that is\n   * currently active.\n   * @returns An object of the style settings for the text box.\n   */\n  public getLinkedTextBoxStyle(\n    specifications: StyleSpecifier,\n    annotation?: Annotation\n  ): Record<string, unknown> {\n    // Todo: this function can be used to set different styles for different toolMode\n    // for the textBox.\n\n    return {\n      visibility: this.getStyle(\n        'textBoxVisibility',\n        specifications,\n        annotation\n      ),\n      fontFamily: this.getStyle(\n        'textBoxFontFamily',\n        specifications,\n        annotation\n      ),\n      fontSize: this.getStyle('textBoxFontSize', specifications, annotation),\n      color: this.getStyle('textBoxColor', specifications, annotation),\n      shadow: this.getStyle('textBoxShadow', specifications, annotation),\n      background: this.getStyle(\n        'textBoxBackground',\n        specifications,\n        annotation\n      ),\n      lineWidth: this.getStyle(\n        'textBoxLinkLineWidth',\n        specifications,\n        annotation\n      ),\n      lineDash: this.getStyle(\n        'textBoxLinkLineDash',\n        specifications,\n        annotation\n      ),\n    };\n  }\n\n  /**\n   * Returns true if the viewport is scaled to SUV units\n   * @param viewport - The viewport\n   * @param targetId - The annotation targetId\n   * @param imageId - The annotation imageId\n   * @returns\n   */\n  isSuvScaled(\n    viewport: Types.IStackViewport | Types.IVolumeViewport,\n    targetId: string,\n    imageId?: string\n  ): boolean {\n    if (viewport instanceof BaseVolumeViewport) {\n      const volumeId = csUtils.getVolumeId(targetId);\n      const volume = cache.getVolume(volumeId);\n      return volume.scaling?.PT !== undefined;\n    }\n    const scalingModule: Types.ScalingParameters | undefined =\n      imageId && metaData.get('scalingModule', imageId);\n    return typeof scalingModule?.suvbw === 'number';\n  }\n\n  /**\n   * Get the style that will be applied to all annotations such as length, cobb\n   * angle, arrow annotate, etc. when rendered on a canvas or svg layer\n   */\n  protected getAnnotationStyle(context: {\n    annotation: Annotation;\n    styleSpecifier: StyleSpecifier;\n  }) {\n    const { annotation, styleSpecifier } = context;\n    const getStyle = (property) =>\n      this.getStyle(property, styleSpecifier, annotation);\n    const { annotationUID } = annotation;\n    const visibility = isAnnotationVisible(annotationUID);\n    const locked = isAnnotationLocked(annotation);\n\n    const lineWidth = getStyle('lineWidth') as number;\n    const lineDash = getStyle('lineDash') as string;\n    const color = getStyle('color') as string;\n    const shadow = getStyle('shadow') as boolean;\n    const textboxStyle = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n\n    return {\n      visibility,\n      locked,\n      color,\n      lineWidth,\n      lineDash,\n      lineOpacity: 1,\n      fillColor: color,\n      fillOpacity: 0,\n      shadow,\n      textbox: textboxStyle,\n    };\n  }\n\n  /**\n   * Returns true if the `canvasCoords` are near a handle or selectable part of the tool\n   *\n   * @param element - The HTML element\n   * @param annotation - The annotation to check\n   * @param canvasCoords - The canvas coordinates to check\n   * @param proximity - The proximity to consider\n   *\n   * @returns If the point is near.\n   */\n  private _imagePointNearToolOrHandle(\n    element: HTMLDivElement,\n    annotation: Annotation,\n    canvasCoords: Types.Point2,\n    proximity: number\n  ): boolean {\n    // Based on the tool instance type, check if the point is near the tool handles\n    const handleNearImagePoint = this.getHandleNearImagePoint(\n      element,\n      annotation,\n      canvasCoords,\n      proximity\n    );\n\n    if (handleNearImagePoint) {\n      return true;\n    }\n\n    // If the point is not near the handles, check if the point is near the tool\n    const toolNewImagePoint = this.isPointNearTool(\n      element,\n      annotation,\n      canvasCoords,\n      proximity,\n      'mouse'\n    );\n\n    if (toolNewImagePoint) {\n      return true;\n    }\n  }\n}\n\nAnnotationTool.toolName = 'AnnotationTool';\nexport default AnnotationTool;\n","import { LabelmapConfig } from '../../../types/LabelmapTypes';\n\nconst defaultLabelmapConfig: LabelmapConfig = {\n  renderOutline: true,\n  outlineWidthActive: 3,\n  outlineWidthInactive: 2,\n  activeSegmentOutlineWidthDelta: 0,\n  renderFill: true,\n  renderFillInactive: true,\n  fillAlpha: 0.7,\n  fillAlphaInactive: 0.65,\n  outlineOpacity: 1,\n  outlineOpacityInactive: 0.85,\n};\n\nfunction getDefaultLabelmapConfig(): LabelmapConfig {\n  return defaultLabelmapConfig;\n}\n\n// Checks if the labelmap config is valid, which means\n// if all the required fields are present and have the correct type\nfunction isValidLabelmapConfig(config): boolean {\n  return (\n    config &&\n    typeof config.renderOutline === 'boolean' &&\n    typeof config.outlineWidthActive === 'number' &&\n    typeof config.outlineWidthInactive === 'number' &&\n    typeof config.activeSegmentOutlineWidthDelta === 'number' &&\n    typeof config.renderFill === 'boolean' &&\n    typeof config.renderFillInactive === 'boolean' &&\n    typeof config.fillAlpha === 'number' &&\n    typeof config.fillAlphaInactive === 'number' &&\n    typeof config.outlineOpacity === 'number' &&\n    typeof config.outlineOpacityInactive === 'number'\n  );\n}\n\nexport default getDefaultLabelmapConfig;\nexport { isValidLabelmapConfig };\n","import { triggerEvent, eventTarget } from '@cornerstonejs/core';\nimport Events from '../enums/Events';\nimport { Annotation } from '../types';\n\nexport type FramesRange = [number, number] | number;\n\n/**\n * This class handles the annotation frame range values for multiframes.\n * Mostly used for the Video viewport, it allows references to\n * a range of frame values.\n */\nexport default class AnnotationFrameRange {\n  protected static frameRangeExtractor =\n    /(\\/frames\\/|[&?]frameNumber=)([^/&?]*)/i;\n\n  protected static imageIdToFrames(imageId: string): FramesRange {\n    const match = imageId.match(this.frameRangeExtractor);\n    if (!match || !match[2]) {\n      return null;\n    }\n    const range = match[2].split('-').map((it) => Number(it));\n    if (range.length === 1) {\n      return range[0];\n    }\n    return range as FramesRange;\n  }\n\n  public static framesToString(range) {\n    if (Array.isArray(range)) {\n      return `${range[0]}-${range[1]}`;\n    }\n    return String(range);\n  }\n\n  protected static framesToImageId(\n    imageId: string,\n    range: FramesRange | string\n  ): string {\n    const match = imageId.match(this.frameRangeExtractor);\n    if (!match || !match[2]) {\n      return null;\n    }\n    const newRangeString = this.framesToString(range);\n    return imageId.replace(\n      this.frameRangeExtractor,\n      `${match[1]}${newRangeString}`\n    );\n  }\n\n  /**\n   * Sets the range of frames to associate with the given annotation.\n   * The range can be a single frame number (1 based according to DICOM),\n   * or a range of values in the format `min-max` where min, max are inclusive\n   * Modifies the referencedImageID to specify the updated URL.\n   */\n  public static setFrameRange(\n    annotation: Annotation,\n    range: FramesRange | string,\n    eventBase?: { viewportId; renderingEngineId }\n  ) {\n    const { referencedImageId } = annotation.metadata;\n    annotation.metadata.referencedImageId = this.framesToImageId(\n      referencedImageId,\n      range\n    );\n    const eventDetail = {\n      ...eventBase,\n      annotation,\n    };\n    triggerEvent(eventTarget, Events.ANNOTATION_MODIFIED, eventDetail);\n  }\n\n  public static getFrameRange(\n    annotation: Annotation\n  ): number | [number, number] {\n    return this.imageIdToFrames(annotation.metadata.referencedImageId);\n  }\n}\n","import type { Types } from '@cornerstonejs/core';\n\n/**\n * Uses the current bounds of the 2D rectangle and extends it in the view axis by numSlices\n * It compares min and max of each IJK to find the view axis (for axial, zMin === zMax) and\n * then calculates the extended range. It will assume the slice is relative to the\n * current slice and will add the given slices to the current max of the boundingBox.\n * @param boundsIJK - [[iMin, iMax], [jMin, jMax], [kMin, kMax]]\n * @param slices - number of slices to project before and after\n * @returns extended bounds\n */\nfunction extend2DBoundingBoxInViewAxis(\n  boundsIJK: [Types.Point2, Types.Point2, Types.Point2],\n  numSlicesToProject: number\n): [Types.Point2, Types.Point2, Types.Point2] {\n  // find which index in boundsIJK has the same first and last value\n  const sliceNormalIndex = boundsIJK.findIndex(([min, max]) => min === max);\n\n  if (sliceNormalIndex === -1) {\n    throw new Error('3D bounding boxes not supported in an oblique plane');\n  }\n\n  // get the index and subtract slices from the min and add to the max\n  boundsIJK[sliceNormalIndex][0] -= numSlicesToProject;\n  boundsIJK[sliceNormalIndex][1] += numSlicesToProject;\n  return boundsIJK;\n}\n\nexport default extend2DBoundingBoxInViewAxis;\n","import type { Types } from '@cornerstonejs/core';\nimport { CONSTANTS } from '@cornerstonejs/core';\n\nconst { EPSILON } = CONSTANTS;\n\n/** Bounding box type */\ntype BoundingBox =\n  | [Types.Point2, Types.Point2, null]\n  | [Types.Point2, Types.Point2, Types.Point2];\n\nfunction calculateBoundingBox(\n  points,\n  dimensions,\n  isWorld = false\n): BoundingBox {\n  let xMin = Infinity;\n  let xMax = isWorld ? -Infinity : 0;\n  let yMin = Infinity;\n  let yMax = isWorld ? -Infinity : 0;\n  let zMin = Infinity;\n  let zMax = isWorld ? -Infinity : 0;\n\n  const is3D = points[0]?.length === 3;\n\n  // use for loop for performance\n  for (let i = 0; i < points.length; i++) {\n    const p = points[i];\n    xMin = Math.min(p[0], xMin);\n    xMax = Math.max(p[0], xMax);\n    yMin = Math.min(p[1], yMin);\n    yMax = Math.max(p[1], yMax);\n\n    if (is3D) {\n      zMin = Math.min(p[2] ?? zMin, zMin);\n      zMax = Math.max(p[2] ?? zMax, zMax);\n    }\n  }\n\n  if (dimensions) {\n    xMin = Math.max(isWorld ? dimensions[0] + EPSILON : 0, xMin);\n    xMax = Math.min(\n      isWorld ? dimensions[0] - EPSILON : dimensions[0] - 1,\n      xMax\n    );\n    yMin = Math.max(isWorld ? dimensions[1] + EPSILON : 0, yMin);\n    yMax = Math.min(\n      isWorld ? dimensions[1] - EPSILON : dimensions[1] - 1,\n      yMax\n    );\n\n    if (is3D && dimensions.length === 3) {\n      zMin = Math.max(isWorld ? dimensions[2] + EPSILON : 0, zMin);\n      zMax = Math.min(\n        isWorld ? dimensions[2] - EPSILON : dimensions[2] - 1,\n        zMax\n      );\n    }\n  } else if (!isWorld) {\n    // still need to bound to 0 and Infinity if no dimensions are provided for ijk\n    xMin = Math.max(0, xMin);\n    xMax = Math.min(Infinity, xMax);\n    yMin = Math.max(0, yMin);\n    yMax = Math.min(Infinity, yMax);\n\n    if (is3D) {\n      zMin = Math.max(0, zMin);\n      zMax = Math.min(Infinity, zMax);\n    }\n  }\n\n  return is3D\n    ? [\n        [xMin, xMax],\n        [yMin, yMax],\n        [zMin, zMax],\n      ]\n    : [[xMin, xMax], [yMin, yMax], null];\n}\n\n/**\n * With a given vertices (points) coordinates in 2D or 3D in IJK, it calculates the minimum and maximum\n * coordinate in each axis, and returns them. If clipBounds are provided it also\n * clip the min, max to the provided width, height and depth\n *\n * @param points - shape corner points coordinates either in IJK (image coordinate)\n * @param dimensions - bounds to clip the min, max\n * @returns [[xMin,xMax],[yMin,yMax], [zMin,zMax]]\n */\nexport function getBoundingBoxAroundShapeIJK(\n  points: Types.Point2[] | Types.Point3[],\n  dimensions?: Types.Point2 | Types.Point3\n): BoundingBox {\n  return calculateBoundingBox(points, dimensions, false);\n}\n\n/**\n * With a given vertices (points) coordinates in 2D or 3D in World Coordinates, it calculates the minimum and maximum\n * coordinate in each axis, and returns them. If clipBounds are provided it also\n * clip the min, max to the provided width, height and depth\n *\n * @param points - shape corner points coordinates either in IJK (image coordinate)\n * @param clipBounds - bounds to clip the min, max\n * @returns [[xMin,xMax],[yMin,yMax], [zMin,zMax]]\n */\nexport function getBoundingBoxAroundShapeWorld(\n  points: Types.Point2[] | Types.Point3[],\n  clipBounds?: Types.Point2 | Types.Point3\n): BoundingBox {\n  return calculateBoundingBox(points, clipBounds, true);\n}\n","import { utilities, Enums } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nconst { calibratedPixelSpacingMetadataProvider } = utilities;\n\n/**\n * It adds the provided spacing to the Cornerstone internal calibratedPixelSpacing\n * metadata provider, then it invalidates all the tools that have the imageId as\n * their reference imageIds. Finally, it triggers a re-render for invalidated annotations.\n * @param imageId - ImageId for the calibrated image\n * @param rowPixelSpacing - Spacing in row direction\n * @param calibrationOrScale - either the calibration object or a scale value\n */\nexport default function calibrateImageSpacing(\n  imageId: string,\n  renderingEngine: Types.IRenderingEngine,\n  calibrationOrScale: Types.IImageCalibration | number\n): void {\n  // Handle simple parameter version\n  if (typeof calibrationOrScale === 'number') {\n    calibrationOrScale = {\n      type: Enums.CalibrationTypes.USER,\n      scale: calibrationOrScale,\n    };\n  }\n  // 1. Add the calibratedPixelSpacing metadata to the metadata\n  calibratedPixelSpacingMetadataProvider.add(imageId, calibrationOrScale);\n\n  // 2. Update the actor for stackViewports\n  const viewports = renderingEngine.getStackViewports();\n\n  // 2.1 If imageId is already being used in a stackViewport -> update actor\n  viewports.forEach((viewport) => {\n    const imageIds = viewport.getImageIds();\n    if (imageIds.includes(imageId)) {\n      viewport.calibrateSpacing(imageId);\n    }\n  });\n\n  // 2.2 If imageId is cached but not being displayed in a viewport, stackViewport\n  // will handle using the calibratedPixelSpacing since it has been added\n  // to the provider\n}\n","/**\n * CINE Tool Events\n */\nenum Events {\n  CLIP_STOPPED = 'CORNERSTONE_CINE_TOOL_STOPPED',\n  CLIP_STARTED = 'CORNERSTONE_CINE_TOOL_STARTED',\n}\n\nexport default Events;\n","import { getEnabledElement } from '@cornerstonejs/core';\nimport { CINETypes } from '../../types';\n\nconst state: Record<string, CINETypes.ToolData> = {};\n\nfunction addToolState(element: HTMLDivElement, data: CINETypes.ToolData): void {\n  const enabledElement = getEnabledElement(element);\n  const { viewportId } = enabledElement;\n  state[viewportId] = data;\n}\n\nfunction getToolState(element: HTMLDivElement): CINETypes.ToolData | undefined {\n  const enabledElement = getEnabledElement(element);\n  const { viewportId } = enabledElement;\n  return state[viewportId];\n}\n\nfunction getToolStateByViewportId(\n  viewportId: string\n): CINETypes.ToolData | undefined {\n  return state[viewportId];\n}\n\nexport { addToolState, getToolState, getToolStateByViewportId };\n","import { glMatrix, vec3 } from 'gl-matrix';\nimport {\n  utilities as csUtils,\n  getEnabledElement,\n  StackViewport,\n  VolumeViewport,\n  cache,\n  BaseVolumeViewport,\n  Enums,\n} from '@cornerstonejs/core';\n\nimport { Types } from '@cornerstonejs/core';\nimport CINE_EVENTS from './events';\nimport { addToolState, getToolState, getToolStateByViewportId } from './state';\nimport { CINETypes } from '../../types';\nimport scroll from '../scroll';\n\nconst { ViewportStatus } = Enums;\nconst { triggerEvent } = csUtils;\n\nconst debounced = true;\nconst dynamicVolumesPlayingMap = new Map();\n\n/**\n * Starts playing a clip or adjusts the frame rate of an already playing clip.  framesPerSecond is\n * optional and defaults to 30 if not specified.  A negative framesPerSecond will play the clip in reverse.\n * The element must be a stack of images\n * @param element - HTML Element\n * @param framesPerSecond - Number of frames per second\n */\nfunction playClip(\n  element: HTMLDivElement,\n  playClipOptions: CINETypes.PlayClipOptions\n): void {\n  let playClipTimeouts;\n  let playClipIsTimeVarying;\n\n  if (element === undefined) {\n    throw new Error('playClip: element must not be undefined');\n  }\n\n  const enabledElement = getEnabledElement(element);\n\n  if (!enabledElement) {\n    throw new Error(\n      'playClip: element must be a valid Cornerstone enabled element'\n    );\n  }\n\n  if (!playClipOptions) {\n    playClipOptions = {};\n  }\n\n  // 4D Cine is enabled by default\n  playClipOptions.dynamicCineEnabled =\n    playClipOptions.dynamicCineEnabled ?? true;\n\n  const { viewport } = enabledElement;\n  const volume = _getVolumeFromViewport(viewport);\n  const playClipContext = _createCinePlayContext(viewport, playClipOptions);\n  let playClipData = getToolState(element);\n\n  const isDynamicCinePlaying =\n    playClipOptions.dynamicCineEnabled && volume?.isDynamicVolume();\n\n  // If user is trying to play CINE for a 4D volume it first needs\n  // to stop CINE that has may be playing for any other viewport.\n  if (isDynamicCinePlaying) {\n    _stopDynamicVolumeCine(element);\n  }\n\n  if (!playClipData) {\n    playClipData = {\n      intervalId: undefined,\n      framesPerSecond: 30,\n      lastFrameTimeStamp: undefined,\n      ignoreFrameTimeVector: false,\n      usingFrameTimeVector: false,\n      frameTimeVector: playClipOptions.frameTimeVector ?? undefined,\n      speed: playClipOptions.frameTimeVectorSpeedMultiplier ?? 1,\n      reverse: playClipOptions.reverse ?? false,\n      loop: playClipOptions.loop ?? true,\n    };\n    addToolState(element, playClipData);\n  } else {\n    // Make sure the specified clip is not running before any property update.\n    // If a 3D CINE was playing it passes isDynamicCinePlaying as FALSE to\n    // prevent stopping a 4D CINE in case it is playing on another viewport.\n    _stopClip(element, {\n      stopDynamicCine: !isDynamicCinePlaying,\n      viewportId: viewport.id,\n    });\n  }\n\n  playClipData.dynamicCineEnabled = playClipOptions.dynamicCineEnabled;\n\n  // If a framesPerSecond is specified and is valid, update the playClipData now\n  if (\n    playClipOptions.framesPerSecond < 0 ||\n    playClipOptions.framesPerSecond > 0\n  ) {\n    playClipData.framesPerSecond = Number(playClipOptions.framesPerSecond);\n    playClipData.reverse = playClipData.framesPerSecond < 0;\n    // If framesPerSecond is given, frameTimeVector will be ignored...\n    playClipData.ignoreFrameTimeVector = true;\n  }\n\n  // Determine if frame time vector should be used instead of a fixed frame rate...\n  if (\n    playClipData.ignoreFrameTimeVector !== true &&\n    playClipData.frameTimeVector &&\n    playClipData.frameTimeVector.length === playClipContext.numScrollSteps &&\n    playClipContext.frameTimeVectorEnabled\n  ) {\n    const { timeouts, isTimeVarying } = _getPlayClipTimeouts(\n      playClipData.frameTimeVector,\n      playClipData.speed\n    );\n\n    playClipTimeouts = timeouts;\n    playClipIsTimeVarying = isTimeVarying;\n  }\n\n  // This function encapsulates the frame rendering logic...\n  const playClipAction = () => {\n    const { numScrollSteps, currentStepIndex } = playClipContext;\n    let newStepIndex = currentStepIndex + (playClipData.reverse ? -1 : 1);\n    const newStepIndexOutOfRange =\n      newStepIndex < 0 || newStepIndex >= numScrollSteps;\n\n    if (!playClipData.loop && newStepIndexOutOfRange) {\n      // If a 3D CINE was playing it passes isDynamicCinePlaying as FALSE to\n      // prevent stopping a 4D CINE in case it is playing on another viewport.\n      _stopClip(element, {\n        stopDynamicCine: !isDynamicCinePlaying,\n        viewportId: viewport.id,\n      });\n\n      const eventDetail = { element };\n\n      triggerEvent(element, CINE_EVENTS.CLIP_STOPPED, eventDetail);\n      return;\n    }\n\n    // Loop around if newStepIndex is out of range\n    if (newStepIndex >= numScrollSteps) {\n      newStepIndex = 0;\n    } else if (newStepIndex < 0) {\n      newStepIndex = numScrollSteps - 1;\n    }\n\n    const delta = newStepIndex - currentStepIndex;\n\n    if (delta) {\n      playClipContext.scroll(delta);\n    }\n  };\n\n  if (isDynamicCinePlaying) {\n    dynamicVolumesPlayingMap.set(volume.volumeId, element);\n  }\n\n  // If playClipTimeouts array is available, not empty and its elements are NOT uniform ...\n  // ... (at least one timeout is different from the others), use alternate setTimeout implementation\n  if (\n    playClipTimeouts &&\n    playClipTimeouts.length > 0 &&\n    playClipIsTimeVarying\n  ) {\n    playClipData.usingFrameTimeVector = true;\n    playClipData.intervalId = window.setTimeout(\n      function playClipTimeoutHandler() {\n        playClipData.intervalId = window.setTimeout(\n          playClipTimeoutHandler,\n          playClipTimeouts[playClipContext.currentStepIndex]\n        );\n        playClipAction();\n      },\n      0\n    );\n  } else {\n    // ... otherwise user setInterval implementation which is much more efficient.\n    playClipData.usingFrameTimeVector = false;\n    playClipData.intervalId = window.setInterval(\n      playClipAction,\n      1000 / Math.abs(playClipData.framesPerSecond)\n    );\n  }\n\n  const eventDetail = {\n    element,\n  };\n\n  triggerEvent(element, CINE_EVENTS.CLIP_STARTED, eventDetail);\n}\n\n/**\n * Stops an already playing clip.\n * @param element - HTML Element\n */\nfunction stopClip(element: HTMLDivElement, options = {} as any): void {\n  _stopClip(element, {\n    stopDynamicCine: true,\n    ...options,\n  });\n}\n\nfunction _stopClip(\n  element: HTMLDivElement,\n  options = { stopDynamicCine: true, viewportId: undefined }\n) {\n  const { stopDynamicCine, viewportId } = options;\n  const enabledElement = getEnabledElement(element);\n\n  let toolState;\n  if (!enabledElement) {\n    if (viewportId) {\n      toolState = getToolStateByViewportId(viewportId);\n    } else {\n      return;\n    }\n  } else {\n    const { viewport } = enabledElement;\n    toolState = getToolState(viewport.element);\n  }\n\n  if (toolState) {\n    _stopClipWithData(toolState);\n  }\n\n  if (\n    stopDynamicCine &&\n    enabledElement?.viewport instanceof BaseVolumeViewport\n  ) {\n    _stopDynamicVolumeCine(element);\n  }\n}\n\n/**\n * [private] Stops any CINE playing for the dynamic volume loaded on this viewport\n * @param element - HTML Element\n */\nfunction _stopDynamicVolumeCine(element) {\n  const { viewport } = getEnabledElement(element);\n  const volume = _getVolumeFromViewport(viewport);\n\n  // If the current viewport has a 4D volume loaded it may be playing\n  // if it is also loaded on another viewport and user has started CINE\n  // for that one. This guarantees the other viewport will also be stopped.\n  if (volume?.isDynamicVolume()) {\n    const dynamicCineElement = dynamicVolumesPlayingMap.get(volume.volumeId);\n\n    dynamicVolumesPlayingMap.delete(volume.volumeId);\n\n    if (dynamicCineElement && dynamicCineElement !== element) {\n      stopClip(<HTMLDivElement>dynamicCineElement);\n    }\n  }\n}\n\n/**\n * [private] Turns a Frame Time Vector (0018,1065) array into a normalized array of timeouts. Each element\n * ... of the resulting array represents the amount of time each frame will remain on the screen.\n * @param vector - A Frame Time Vector (0018,1065) as specified in section C.7.6.5.1.2 of DICOM standard.\n * @param speed - A speed factor which will be applied to each element of the resulting array.\n * @returns An array with timeouts for each animation frame.\n */\nfunction _getPlayClipTimeouts(vector: number[], speed: number) {\n  let i;\n  let sample;\n  let delay;\n  let sum = 0;\n  const limit = vector.length;\n  const timeouts = [];\n\n  // Initialize time varying to false\n  let isTimeVarying = false;\n\n  if (typeof speed !== 'number' || speed <= 0) {\n    speed = 1;\n  }\n\n  // First element of a frame time vector must be discarded\n  for (i = 1; i < limit; i++) {\n    // eslint-disable-next-line no-bitwise\n    delay = (Number(vector[i]) / speed) | 0; // Integral part only\n    timeouts.push(delay);\n    if (i === 1) {\n      // Use first item as a sample for comparison\n      sample = delay;\n    } else if (delay !== sample) {\n      isTimeVarying = true;\n    }\n\n    sum += delay;\n  }\n\n  if (timeouts.length > 0) {\n    if (isTimeVarying) {\n      // If it's a time varying vector, make the last item an average...\n      // eslint-disable-next-line no-bitwise\n      delay = (sum / timeouts.length) | 0;\n    } else {\n      delay = timeouts[0];\n    }\n\n    timeouts.push(delay);\n  }\n\n  return { timeouts, isTimeVarying };\n}\n\n/**\n * [private] Performs the heavy lifting of stopping an ongoing animation.\n * @param element - HTML Element\n * @param playClipData - The data from playClip that needs to be stopped.\n */\nfunction _stopClipWithData(playClipData) {\n  const id = playClipData.intervalId;\n\n  if (typeof id !== 'undefined') {\n    playClipData.intervalId = undefined;\n    if (playClipData.usingFrameTimeVector) {\n      clearTimeout(id);\n    } else {\n      clearInterval(id);\n    }\n  }\n}\n\nfunction _getVolumesFromViewport(viewport): Types.IImageVolume[] {\n  return viewport\n    .getActors()\n    .map((actor) => cache.getVolume(actor.uid))\n    .filter((volume) => !!volume);\n}\n\nfunction _getVolumeFromViewport(viewport): Types.IImageVolume {\n  const volumes = _getVolumesFromViewport(viewport);\n  const dynamicVolume = volumes.find((volume) => volume.isDynamicVolume());\n\n  return dynamicVolume ?? volumes[0];\n}\n\nfunction _createStackViewportCinePlayContext(\n  viewport: StackViewport,\n  waitForRendered: number\n): CINETypes.CinePlayContext {\n  const imageIds = viewport.getImageIds();\n\n  return {\n    get numScrollSteps(): number {\n      return imageIds.length;\n    },\n    get currentStepIndex(): number {\n      return viewport.getTargetImageIdIndex();\n    },\n    get frameTimeVectorEnabled(): boolean {\n      // It is always in acquired orientation\n      return true;\n    },\n    waitForRenderedCount: 0,\n    scroll(delta: number): void {\n      if (\n        this.waitForRenderedCount <= waitForRendered &&\n        viewport.viewportStatus !== ViewportStatus.RENDERED\n      ) {\n        this.waitForRenderedCount++;\n        return;\n      }\n      this.waitForRenderedCount = 0;\n      scroll(viewport, { delta, debounceLoading: debounced });\n    },\n  };\n}\n\nfunction _createVolumeViewportCinePlayContext(\n  viewport: VolumeViewport,\n  volume: Types.IImageVolume\n): CINETypes.CinePlayContext {\n  const { volumeId } = volume;\n  const cachedScrollInfo = {\n    viewPlaneNormal: vec3.create(),\n    scrollInfo: null,\n  };\n\n  const getScrollInfo = () => {\n    const camera = viewport.getCamera();\n    const updateCache =\n      !cachedScrollInfo.scrollInfo ||\n      !vec3.equals(camera.viewPlaneNormal, cachedScrollInfo.viewPlaneNormal);\n\n    // Number of steps would change only after rotating the volume so it\n    // caches the result and recomputes only when necessary. Until it is\n    // rotated the current frame is updated locally\n    if (updateCache) {\n      const scrollInfo = csUtils.getVolumeViewportScrollInfo(\n        viewport,\n        volumeId\n      );\n\n      cachedScrollInfo.viewPlaneNormal = camera.viewPlaneNormal;\n      cachedScrollInfo.scrollInfo = scrollInfo;\n    }\n\n    return cachedScrollInfo.scrollInfo;\n  };\n\n  return {\n    get numScrollSteps(): number {\n      return getScrollInfo().numScrollSteps;\n    },\n    get currentStepIndex(): number {\n      return getScrollInfo().currentStepIndex;\n    },\n    get frameTimeVectorEnabled(): boolean {\n      const camera = viewport.getCamera();\n      const volumeViewPlaneNormal = volume.direction\n        .slice(6, 9)\n        .map((x) => -x) as Types.Point3;\n      const dot = vec3.dot(volumeViewPlaneNormal, camera.viewPlaneNormal);\n\n      // Check if the volume is in acquired orientation\n      // it may be flipped or rotated in plane\n      return glMatrix.equals(dot, 1);\n    },\n    scroll(delta: number): void {\n      getScrollInfo().currentStepIndex += delta;\n      scroll(viewport, { delta });\n    },\n  };\n}\n\nfunction _createDynamicVolumeViewportCinePlayContext(\n  volume: Types.IDynamicImageVolume\n): CINETypes.CinePlayContext {\n  return {\n    get numScrollSteps(): number {\n      return volume.numTimePoints;\n    },\n    get currentStepIndex(): number {\n      return volume.timePointIndex;\n    },\n    get frameTimeVectorEnabled(): boolean {\n      // Looping throught time does not uses frameTimeVector\n      return false;\n    },\n    scroll(delta: number): void {\n      // Updating this property (setter) makes it move to the desired time point\n      volume.timePointIndex += delta;\n    },\n  };\n}\n\nfunction _createCinePlayContext(\n  viewport,\n  playClipOptions: CINETypes.PlayClipOptions\n): CINETypes.CinePlayContext {\n  if (viewport instanceof StackViewport) {\n    return _createStackViewportCinePlayContext(\n      viewport,\n      playClipOptions.waitForRendered ?? 30\n    );\n  }\n\n  if (viewport instanceof VolumeViewport) {\n    const volume = _getVolumeFromViewport(viewport);\n\n    if (playClipOptions.dynamicCineEnabled && volume?.isDynamicVolume()) {\n      return _createDynamicVolumeViewportCinePlayContext(\n        <Types.IDynamicImageVolume>volume\n      );\n    }\n\n    return _createVolumeViewportCinePlayContext(viewport, volume);\n  }\n\n  throw new Error('Unknown viewport type');\n}\n\nexport { playClip, stopClip };\n","/**\n * Clips a value to an upper and lower bound.\n * @export @public @method\n * @name clip\n *\n * @param  {number} val  The value to clip.\n * @param  {number} low  The lower bound.\n * @param  {number} high The upper bound.\n * @returns {number}      The clipped value.\n */\nexport function clip(val, low, high) {\n  return Math.min(Math.max(low, val), high);\n}\n\n/**\n * Clips a value within a box.\n * @export @public @method\n * @name clipToBox\n *\n * @param  {Object} point The point to clip\n * @param  {Object} box   The bounding box to clip to.\n * @returns {Object}       The clipped point.\n */\nexport function clipToBox(point, box) {\n  // Clip an {x, y} point to a box of size {width, height}\n  point.x = clip(point.x, 0, box.width);\n  point.y = clip(point.y, 0, box.height);\n}\n\nexport default clip;\n","import { getSegmentation } from '../../stateManagement/segmentation/segmentationState';\nimport { ContourSegmentationAnnotation } from '../../types';\n\n/**\n * Adds a contour segmentation annotation to the specified segmentation.\n * @param annotation - The contour segmentation annotation to add.\n */\nexport function addContourSegmentationAnnotation(\n  annotation: ContourSegmentationAnnotation\n) {\n  if (annotation.parentAnnotationUID) {\n    // Don't add it for parent annotations - this happens during interpolation\n    return;\n  }\n  if (!annotation.data.segmentation) {\n    throw new Error(\n      'addContourSegmentationAnnotation: annotation does not have a segmentation data'\n    );\n  }\n\n  const { segmentationId, segmentIndex } = annotation.data.segmentation;\n  const segmentation = getSegmentation(segmentationId);\n\n  if (!segmentation.representationData.CONTOUR) {\n    segmentation.representationData.CONTOUR = { annotationUIDsMap: new Map() };\n  }\n\n  const { annotationUIDsMap } = segmentation.representationData.CONTOUR;\n\n  let annotationsUIDsSet = annotationUIDsMap.get(segmentIndex);\n\n  if (!annotationsUIDsSet) {\n    annotationsUIDsSet = new Set();\n    annotationUIDsMap.set(segmentIndex, annotationsUIDsSet);\n  }\n\n  annotationUIDsMap.set(\n    segmentIndex,\n    annotationsUIDsSet.add(annotation.annotationUID)\n  );\n}\n","import { ContourSegmentationAnnotation } from '../../types/ContourSegmentationAnnotation';\n\n/**\n * Check if two contour segmentations are from same segmentId,\n * segmentationRepresentationUID and segmentIndex.\n * @param firstAnnotation - First annotation\n * @param secondAnnotation - Second annotation\n * @returns True if they are from same segmentId, segmentationRepresentationUID\n * and segmentIndex or false otherwise.\n */\nexport default function areSameSegment(\n  firstAnnotation: ContourSegmentationAnnotation,\n  secondAnnotation: ContourSegmentationAnnotation\n) {\n  const { segmentation: firstSegmentation } = firstAnnotation.data;\n  const { segmentation: secondSegmentation } = secondAnnotation.data;\n\n  return (\n    firstSegmentation.segmentationId === secondSegmentation.segmentationId &&\n    firstSegmentation.segmentIndex === secondSegmentation.segmentIndex\n  );\n}\n","import { Annotation } from '../../types';\nimport { ContourSegmentationAnnotation } from '../../types/ContourSegmentationAnnotation';\n\nexport default function isContourSegmentationAnnotation(\n  annotation: Annotation\n): annotation is ContourSegmentationAnnotation {\n  return !!(<ContourSegmentationAnnotation>annotation).data?.segmentation;\n}\n","import { state } from '../../stateManagement/segmentation';\nimport { ContourSegmentationAnnotation } from '../../types';\n\n/**\n * Removes a contour segmentation annotation from the given annotation.\n * If the annotation does not have a segmentation data, this method returns\n * quietly.  This can occur for interpolated segmentations that have not yet\n * been converted to real segmentations or other in-process segmentations.\n * @param annotation - The contour segmentation annotation to remove.\n */\nexport function removeContourSegmentationAnnotation(\n  annotation: ContourSegmentationAnnotation\n) {\n  if (!annotation.data.segmentation) {\n    throw new Error(\n      'removeContourSegmentationAnnotation: annotation does not have a segmentation data'\n    );\n  }\n\n  const { segmentationId, segmentIndex } = annotation.data.segmentation;\n  const segmentation = state.getSegmentation(segmentationId);\n  const { annotationUIDsMap } = segmentation?.representationData.CONTOUR || {};\n  const annotationsUIDsSet = annotationUIDsMap?.get(segmentIndex);\n\n  if (!annotationsUIDsSet) {\n    return;\n  }\n\n  annotationsUIDsSet.delete(annotation.annotationUID);\n\n  // Delete segmentIndex Set if there is no more annotations\n  if (!annotationsUIDsSet.size) {\n    annotationUIDsMap.delete(segmentIndex);\n  }\n}\n","import RectangleROIStartEndThreshold from './RectangleROIStartEndThreshold';\n\nfunction validateAnnotation(annotation) {\n  if (!annotation?.data) {\n    throw new Error('Tool data is empty');\n  }\n\n  if (!annotation.metadata || annotation.metadata.referenceImageId) {\n    throw new Error('Tool data is not associated with any imageId');\n  }\n}\n\nclass AnnotationToPointData {\n  static TOOL_NAMES: Record<string, any> = {};\n\n  constructor() {\n    // empty\n  }\n\n  static convert(annotation, index, metadataProvider) {\n    validateAnnotation(annotation);\n\n    const { toolName } = annotation.metadata;\n    const toolClass = AnnotationToPointData.TOOL_NAMES[toolName];\n\n    if (!toolClass) {\n      throw new Error(\n        `Unknown tool type: ${toolName}, cannot convert to RTSSReport`\n      );\n    }\n\n    // Each toolData should become a list of contours, ContourSequence\n    // contains a list of contours with their pointData, their geometry\n    // type and their length.\n    const ContourSequence = toolClass.getContourSequence(\n      annotation,\n      metadataProvider\n    );\n\n    // Todo: random rgb color for now, options should be passed in\n    const color = [\n      Math.floor(Math.random() * 255),\n      Math.floor(Math.random() * 255),\n      Math.floor(Math.random() * 255),\n    ];\n\n    return {\n      ReferencedROINumber: index + 1,\n      ROIDisplayColor: color,\n      ContourSequence,\n    };\n  }\n\n  static register(toolClass) {\n    AnnotationToPointData.TOOL_NAMES[toolClass.toolName] = toolClass;\n  }\n}\n\nAnnotationToPointData.register(RectangleROIStartEndThreshold);\n\nexport default AnnotationToPointData;\n","import { glMatrix, vec3 } from 'gl-matrix';\nimport { ContourAnnotation } from '../../types/ContourAnnotation';\n\n/**\n * Check if two contour segmentation annotations are coplanar.\n *\n * A plane may be represented by a normal and a distance then to know if they\n * are coplanar we need to:\n *   - check if the normals of the two annotations are pointing to the same\n *   direction or to opposite directions (dot product equal to 1 or -1\n *   respectively)\n *   - Get one point from each polyline and project it onto the normal to get\n *   the distance from the origin (0, 0, 0).\n */\nexport default function areCoplanarContours(\n  firstAnnotation: ContourAnnotation,\n  secondAnnotation: ContourAnnotation\n) {\n  const { viewPlaneNormal: firstViewPlaneNormal } = firstAnnotation.metadata;\n  const { viewPlaneNormal: secondViewPlaneNormal } = secondAnnotation.metadata;\n  const dot = vec3.dot(firstViewPlaneNormal, secondViewPlaneNormal);\n  const parallelPlanes = glMatrix.equals(1, Math.abs(dot));\n\n  if (!parallelPlanes) {\n    return false;\n  }\n\n  const { polyline: firstPolyline } = firstAnnotation.data.contour;\n  const { polyline: secondPolyline } = secondAnnotation.data.contour;\n\n  // Choose one of the normals and calculate the distance of a point from each\n  // polyline along that normal. Both normal cannot be used with absolute dot\n  // product values because one of the view planes may be flipped or one of the\n  // points may be at the same distance but in the opposite direction\n  const firstDistance = vec3.dot(firstViewPlaneNormal, firstPolyline[0]);\n  const secondDistance = vec3.dot(firstViewPlaneNormal, secondPolyline[0]);\n\n  return glMatrix.equals(firstDistance, secondDistance);\n}\n","/**\n * Calculates the perimeter of a polyline.\n *\n * @param polyline - The polyline represented as an array of points.\n * @param closed - Indicates whether the polyline is closed or not.\n * @returns The perimeter of the polyline.\n */\nfunction calculatePerimeter(polyline: number[][], closed: boolean): number {\n  let perimeter = 0;\n\n  for (let i = 0; i < polyline.length - 1; i++) {\n    const point1 = polyline[i];\n    const point2 = polyline[i + 1];\n    perimeter += Math.sqrt(\n      Math.pow(point2[0] - point1[0], 2) + Math.pow(point2[1] - point1[1], 2)\n    );\n  }\n\n  if (closed) {\n    const firstPoint = polyline[0];\n    const lastPoint = polyline[polyline.length - 1];\n    perimeter += Math.sqrt(\n      Math.pow(lastPoint[0] - firstPoint[0], 2) +\n        Math.pow(lastPoint[1] - firstPoint[1], 2)\n    );\n  }\n\n  return perimeter;\n}\n\nexport default calculatePerimeter;\n","function findNextLink(line, lines, contourPoints) {\n  let index = -1;\n  lines.forEach((cell, i) => {\n    if (index >= 0) {\n      return;\n    }\n\n    if (cell.a == line.b) {\n      index = i;\n    }\n  });\n\n  if (index >= 0) {\n    const nextLine = lines[index];\n    lines.splice(index, 1);\n\n    contourPoints.push(nextLine.b);\n\n    if (contourPoints[0] == nextLine.b) {\n      return {\n        remainingLines: lines,\n        contourPoints,\n        type: 'CLOSED_PLANAR',\n        //type: 'CLOSEDPLANAR_XOR',\n      };\n    }\n\n    return findNextLink(nextLine, lines, contourPoints);\n  }\n\n  return {\n    remainingLines: lines,\n    contourPoints,\n    type: 'OPEN_PLANAR',\n  };\n}\n\n/**\n *\n * @param {*} lines\n */\nexport function findContours(lines) {\n  if (lines.length == 0) {\n    return [];\n  }\n\n  const contourPoints = [];\n\n  const firstCell = lines.shift();\n  contourPoints.push(firstCell.a);\n  contourPoints.push(firstCell.b);\n  const result = findNextLink(firstCell, lines, contourPoints);\n\n  if (result.remainingLines.length == 0) {\n    return [\n      {\n        type: result.type,\n        contourPoints: result.contourPoints,\n      },\n    ];\n  } else {\n    const extraContours = findContours(result.remainingLines);\n    extraContours.push({\n      type: result.type,\n      contourPoints: result.contourPoints,\n    });\n    return extraContours;\n  }\n}\n\nexport function findContoursFromReducedSet(lines) {\n  return findContours(lines);\n}\n\nexport default {\n  findContours,\n  findContoursFromReducedSet,\n};\n","/**\n * Functions for detecting and dealing with holes within contours.\n * Expected Contour format:\n * {\n *   type,\n *   contourPoints\n * }\n */\n\n/**\n * Checks if point is inside polygon defined by vertices array\n * Code from\n * https://stackoverflow.com/questions/22521982/check-if-point-is-inside-a-polygon\n * most original version based on:\n * https://wrf.ecse.rpi.edu/Research/Short_Notes/pnpoly.html/pnpoly.html\n * @param {*} point\n * @param {*} vertices\n * @returns\n */\nconst getIsPointInsidePolygon = (point, vertices) => {\n  // Todo: this is a duplicated logic we should merge it with the other one\n  // which is containsPoint in the utilities\n  const x = point[0];\n  const y = point[1];\n\n  let inside = false;\n  for (let i = 0, j = vertices.length - 1; i < vertices.length; j = i++) {\n    const xi = vertices[i][0],\n      yi = vertices[i][1];\n    const xj = vertices[j][0],\n      yj = vertices[j][1];\n\n    const intersect =\n      yi > y != yj > y && x < ((xj - xi) * (y - yi)) / (yj - yi) + xi;\n    if (intersect) {\n      inside = !inside;\n    }\n  }\n\n  return inside;\n};\n\n/**\n * Check if inner contour is completely surrounded by outer contour.\n * @param {*} outerContour\n * @param {*} innerContour\n * @returns\n */\nfunction checkEnclosed(outerContour, innerContour, points) {\n  const vertices = [];\n  outerContour.contourPoints.forEach((point) => {\n    vertices.push([points[point][0], points[point][1]]);\n  });\n\n  let pointsNotEnclosed = 0;\n  innerContour.contourPoints.forEach((point) => {\n    const result = getIsPointInsidePolygon(\n      [points[point][0], points[point][1]],\n      vertices\n    );\n    //console.log(result);\n\n    if (!result) {\n      pointsNotEnclosed++;\n    }\n  });\n\n  return pointsNotEnclosed === 0;\n}\n\n/**\n * Check if contours have holes, if so update contour accordingly\n * @param {*} polyData\n * @param {*} bypass\n */\nexport function processContourHoles(contours, points, useXOR = true) {\n  //console.log(points);\n\n  // Add non-closed planars to contour list\n  const retContours = contours.filter(\n    (contour) => contour.type !== 'CLOSED_PLANAR'\n  );\n\n  // Find closed planar contours\n  const closedContours = contours.filter(\n    (contour) => contour.type === 'CLOSED_PLANAR'\n  );\n\n  // Iterate through each contour in list check for contours that have holes\n  const contourWithHoles = [];\n  let contourWithoutHoles = [];\n  closedContours.forEach((contour, index) => {\n    const holes = [];\n\n    // Check if any other contour is a hole surrounded by current contour\n    closedContours.forEach((hContour, hIndex) => {\n      if (index != hIndex) {\n        // Check if inner loop contour is a hole of outer loop contour\n        if (checkEnclosed(contour, hContour, points)) {\n          holes.push(hIndex);\n        }\n      }\n    });\n\n    // Check if holes were found\n    if (holes.length > 0) {\n      // Note current contour and reference of its holes\n      contourWithHoles.push({\n        contour,\n        holes,\n      });\n    } else {\n      // Note contour index without holes\n      contourWithoutHoles.push(index);\n    }\n  });\n\n  if (useXOR) {\n    // XOR method\n    contourWithHoles.forEach((contourHoleSet) => {\n      // Modify contour with hole to type CLOSEDPLANAR_XOR\n      contourHoleSet.contour.type = 'CLOSEDPLANAR_XOR';\n      retContours.push(contourHoleSet.contour);\n\n      contourHoleSet.holes.forEach((holeIndex) => {\n        // Modify hole type to CLOSEDPLANAR_XOR\n        // and add to contour list to be returned\n        closedContours[holeIndex].type = 'CLOSEDPLANAR_XOR';\n        retContours.push(closedContours[holeIndex]);\n\n        // Remove hole from list of contours without holes\n        contourWithoutHoles = contourWithoutHoles.filter((contourIndex) => {\n          return contourIndex !== holeIndex;\n        });\n      });\n    });\n\n    // Add remaining contours to list (neither hole nor have holes)\n    contourWithoutHoles.forEach((contourIndex) => {\n      retContours.push(closedContours[contourIndex]);\n    });\n  } else {\n    // Keyhole method, not implemented\n  }\n\n  return retContours;\n}\n\nexport default { processContourHoles };\n","import { utilities as csUtils } from '@cornerstonejs/core';\nimport { vec3 } from 'gl-matrix';\n\nimport { ContourAnnotation } from '../../types/ToolSpecificAnnotationTypes';\n\nconst { isEqual } = csUtils;\n\n/**\n * Finds the index in the polyline of the specified handle.  If the handle\n * doesn't match a polyline point, then finds the closest polyline point.\n *\n * Assumes polyline is in the same orientation as the handles.\n *\n * @param annotation - to find the polyline and handles in\n * @param handleIndex - the index of hte handle to look for.\n *     Negative values are treated relative to the end of the handle index.\n * @returns Index in polyline of the closest handle\n *     * 0 for handleIndex 0\n *     * length for `handleIndex===handles length`\n */\nexport default function findHandlePolylineIndex(\n  annotation: ContourAnnotation,\n  handleIndex: number\n): number {\n  const { polyline } = annotation.data.contour;\n  const { points } = annotation.data.handles;\n  const { length } = points;\n  if (handleIndex === length) {\n    return polyline.length;\n  }\n  if (handleIndex < 0) {\n    handleIndex = (handleIndex + length) % length;\n  }\n  if (handleIndex === 0) {\n    return 0;\n  }\n  const handle = points[handleIndex];\n  const index = polyline.findIndex((point) => isEqual(handle, point));\n  if (index !== -1) {\n    return index;\n  }\n  // Need to find nearest\n  let closestDistance = Infinity;\n  return polyline.reduce((closestIndex, point, testIndex) => {\n    const distance = vec3.squaredDistance(point, handle);\n    if (distance < closestDistance) {\n      closestDistance = distance;\n      return testIndex;\n    }\n    return closestIndex;\n  }, -1);\n}\n","import { cache as cornerstoneCache } from '@cornerstonejs/core';\nimport vtkImageMarchingSquares from '@kitware/vtk.js/Filters/General/ImageMarchingSquares';\nimport vtkDataArray from '@kitware/vtk.js/Common/Core/DataArray';\nimport vtkImageData from '@kitware/vtk.js/Common/DataModel/ImageData';\n\nimport { getDeduplicatedVTKPolyDataPoints } from '../contours';\nimport { findContoursFromReducedSet } from './contourFinder';\nimport SegmentationRepresentations from '../../enums/SegmentationRepresentations';\n\nconst { Labelmap } = SegmentationRepresentations;\n\nfunction generateContourSetsFromLabelmap({ segmentations }) {\n  const { representationData, segments = [0, 1] } = segmentations;\n  const { volumeId: segVolumeId } = representationData[Labelmap];\n\n  // Get segmentation volume\n  const vol = cornerstoneCache.getVolume(segVolumeId);\n  if (!vol) {\n    console.warn(`No volume found for ${segVolumeId}`);\n    return;\n  }\n\n  const numSlices = vol.dimensions[2];\n\n  // NOTE: Workaround for marching squares not finding closed contours at\n  // boundary of image volume, clear pixels along x-y border of volume\n  const segData = vol.imageData.getPointData().getScalars().getData();\n  const pixelsPerSlice = vol.dimensions[0] * vol.dimensions[1];\n\n  for (let z = 0; z < numSlices; z++) {\n    for (let y = 0; y < vol.dimensions[1]; y++) {\n      const index = y * vol.dimensions[0] + z * pixelsPerSlice;\n      segData[index] = 0;\n      segData[index + vol.dimensions[0] - 1] = 0;\n    }\n  }\n\n  // end workaround\n  //\n  //\n  const ContourSets = [];\n\n  const { FrameOfReferenceUID } = vol.metadata;\n  // Iterate through all segments in current segmentation set\n  const numSegments = segments.length;\n  for (let segIndex = 0; segIndex < numSegments; segIndex++) {\n    const segment = segments[segIndex];\n\n    // Skip empty segments\n    if (!segment) {\n      continue;\n    }\n\n    const sliceContours = [];\n    const scalars = vtkDataArray.newInstance({\n      name: 'Scalars',\n      numberOfComponents: 1,\n      size: pixelsPerSlice * numSlices,\n      dataType: 'Uint8Array',\n    });\n    const { containedSegmentIndices } = segment;\n    for (let sliceIndex = 0; sliceIndex < numSlices; sliceIndex++) {\n      // Check if the slice is empty before running marching cube\n      if (\n        isSliceEmptyForSegment(sliceIndex, segData, pixelsPerSlice, segIndex)\n      ) {\n        continue;\n      }\n      const frameStart = sliceIndex * pixelsPerSlice;\n\n      try {\n        // Modify segData for this specific segment directly\n        for (let i = 0; i < pixelsPerSlice; i++) {\n          const value = segData[i + frameStart];\n          if (value === segIndex || containedSegmentIndices?.has(value)) {\n            (scalars as any).setValue(i + frameStart, 1);\n          } else {\n            (scalars as any).setValue(i, 0);\n          }\n        }\n\n        const mSquares = vtkImageMarchingSquares.newInstance({\n          slice: sliceIndex,\n        });\n\n        // filter out the scalar data so that only it has background and\n        // the current segment index\n        const imageDataCopy = vtkImageData.newInstance();\n\n        imageDataCopy.shallowCopy(vol.imageData);\n        imageDataCopy.getPointData().setScalars(scalars);\n\n        // Connect pipeline\n        mSquares.setInputData(imageDataCopy);\n        const cValues = [1];\n        mSquares.setContourValues(cValues);\n        mSquares.setMergePoints(false);\n\n        // Perform marching squares\n        const msOutput = mSquares.getOutputData();\n\n        // Clean up output from marching squares\n        const reducedSet = getDeduplicatedVTKPolyDataPoints(msOutput);\n        if (reducedSet.points?.length) {\n          const contours = findContoursFromReducedSet(reducedSet.lines);\n\n          sliceContours.push({\n            contours,\n            polyData: reducedSet,\n            FrameNumber: sliceIndex + 1,\n            sliceIndex,\n            FrameOfReferenceUID,\n          });\n        }\n      } catch (e) {\n        console.warn(sliceIndex);\n        console.warn(e);\n      }\n    }\n\n    const metadata = {\n      FrameOfReferenceUID,\n    };\n\n    const ContourSet = {\n      label: segment.label,\n      color: segment.color,\n      metadata,\n      sliceContours,\n    };\n\n    ContourSets.push(ContourSet);\n  }\n\n  return ContourSets;\n}\n\nfunction isSliceEmptyForSegment(sliceIndex, segData, pixelsPerSlice, segIndex) {\n  const startIdx = sliceIndex * pixelsPerSlice;\n  const endIdx = startIdx + pixelsPerSlice;\n\n  for (let i = startIdx; i < endIdx; i++) {\n    if (segData[i] === segIndex) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nexport { generateContourSetsFromLabelmap };\n","import type { Types } from '@cornerstonejs/core';\nimport type { Annotation } from '../../types';\nimport getContourHolesDataWorld from './getContourHolesDataWorld';\n\n/**\n * Get the polylines for the child annotations (holes)\n * @param annotation - Annotation\n * @param viewport - Viewport used to convert the points from world to canvas space\n * @returns An array that contains all child polylines\n */\nexport default function getContourHolesDataCanvas(\n  annotation: Annotation,\n  viewport: Types.IViewport\n): Types.Point2[][] {\n  const worldHoleContours = getContourHolesDataWorld(annotation);\n  const canvasHoleContours = [];\n\n  worldHoleContours.forEach((worldHoleContour) => {\n    const numPoints = worldHoleContour.length;\n\n    // Pre-allocated arrays are 3-4x faster than multiple \"push()\" calls\n    const canvasHoleContour: Types.Point2[] = new Array(numPoints);\n\n    // Using FOR loop instead of map() for better performance when processing large arrays\n    for (let i = 0; i < numPoints; i++) {\n      canvasHoleContour[i] = viewport.worldToCanvas(worldHoleContour[i]);\n    }\n\n    canvasHoleContours.push(canvasHoleContour);\n  });\n\n  return canvasHoleContours;\n}\n","import type { Types } from '@cornerstonejs/core';\nimport type { Annotation, ContourAnnotation } from '../../types';\nimport { getAnnotation } from '../../stateManagement';\n\n/**\n * Get child polylines data in world space for contour annotations that represent the holes\n * @param annotation - Annotation\n * @param viewport - Viewport used to convert the points from world to canvas space\n * @returns An array that contains all child polylines (holes) in world space\n */\nexport default function getContourHolesDataWorld(\n  annotation: Annotation\n): Types.Point3[][] {\n  const childAnnotationUIDs = annotation.childAnnotationUIDs ?? [];\n\n  return childAnnotationUIDs.map(\n    (uid) => (getAnnotation(uid) as ContourAnnotation).data.contour.polyline\n  );\n}\n","/**\n * Iterate through polyData from vtkjs and merge any points that are the same\n * then update merged point references within lines array\n * @param polyData - vtkPolyData\n * @param bypass - bypass the duplicate point removal\n * @returns the updated polyData\n */\nexport function getDeduplicatedVTKPolyDataPoints(polyData, bypass = false) {\n  const points = polyData.getPoints();\n  const lines = polyData.getLines();\n\n  // Todo: This is cloning which is not ideal, we should move to use the PointsArrayManager\n  // that will get merged soon\n  const pointsArray = new Array(points.getNumberOfPoints())\n    .fill(0)\n    .map((_, i) => points.getPoint(i).slice());\n\n  const linesArray = new Array(lines.getNumberOfCells()).fill(0).map((_, i) => {\n    const cell = lines.getCell(i * 3).slice();\n    return { a: cell[0], b: cell[1] };\n  });\n\n  if (bypass) {\n    return { points: pointsArray, lines: linesArray };\n  }\n\n  const newPoints = [];\n  for (const [i, pt] of pointsArray.entries()) {\n    // Todo: This is an n^2 algorithm - consider using a Map<string,Point3>.\n    // Generates a reasonable amount of garbage, but I think the performance\n    //  of that is better than doing repeated compares across the entire array.\n    const index = newPoints.findIndex(\n      (point) => point[0] === pt[0] && point[1] === pt[1] && point[2] === pt[2]\n    );\n\n    if (index >= 0) {\n      linesArray.map((line) => {\n        if (line.a === i) {\n          line.a = index;\n        }\n        if (line.b === i) {\n          line.b = index;\n        }\n        return line;\n      });\n    } else {\n      const newIndex = newPoints.length;\n      newPoints.push(pt);\n      linesArray.map((line) => {\n        if (line.a === i) {\n          line.a = newIndex;\n        }\n        if (line.b === i) {\n          line.b = newIndex;\n        }\n        return line;\n      });\n    }\n  }\n\n  const newLines = linesArray.filter((line) => line.a !== line.b);\n\n  return { points: newPoints, lines: newLines };\n}\n\nexport default { getDeduplicatedVTKPolyDataPoints };\n","import InterpolationManager from '../../segmentation/InterpolationManager/InterpolationManager';\nimport type { AcceptInterpolationSelector } from '../../../types/InterpolationTypes';\nimport type AnnotationGroupSelector from '../../../types/AnnotationGroupSelector';\n\n/**\n * Accepts interpolated annotations, marking them as autoGenerated false.\n *\n * @param annotationGroupSelector - viewport or FOR to select annotations on\n * @param selector - nested selection criteria\n */\nexport default function acceptAutogeneratedInterpolations(\n  annotationGroupSelector: AnnotationGroupSelector,\n  selector: AcceptInterpolationSelector\n) {\n  InterpolationManager.acceptAutoGenerated(annotationGroupSelector, selector);\n}\n","import { utilities as csUtils } from '@cornerstonejs/core';\nimport { Types } from '@cornerstonejs/core';\nimport type { ContourAnnotation } from '../../types';\nimport type { ContourWindingDirection } from '../../types/ContourAnnotation';\nimport * as math from '../math';\nimport {\n  getParentAnnotation,\n  invalidateAnnotation,\n} from '../../stateManagement';\n\n/**\n * Update the contour polyline data\n * @param annotation - Contour annotation\n * @param viewport - Viewport\n * @param polylineData - Polyline data (points, winding direction and closed)\n * @param transforms - Methods to convert points to/from canvas and world spaces\n * @param options - Options\n *   - decimate: allow to set some parameters to decimate the polyline reducing\n *   the amount of points stored which also affects how fast it will draw the\n *   annotation in a viewport, compute the winding direction, append/remove\n *   contours and create holes. A higher `epsilon` value results in a polyline\n *   with less points.\n */\nexport default function updateContourPolyline(\n  annotation: ContourAnnotation,\n  polylineData: {\n    points: Types.Point2[];\n    closed?: boolean;\n    targetWindingDirection?: ContourWindingDirection;\n  },\n  transforms: {\n    canvasToWorld: (point: Types.Point2) => Types.Point3;\n  },\n  options?: {\n    decimate?: {\n      enabled?: boolean;\n      epsilon?: number;\n    };\n  }\n) {\n  const { canvasToWorld } = transforms;\n  const { data } = annotation;\n  const { targetWindingDirection } = polylineData;\n  let { points: polyline } = polylineData;\n\n  // Decimate the polyline to reduce tha amount of points\n  if (options?.decimate?.enabled) {\n    polyline = math.polyline.decimate(\n      polylineData.points,\n      options?.decimate?.epsilon\n    );\n  }\n\n  let { closed } = polylineData;\n  const numPoints = polyline.length;\n  const polylineWorldPoints = new Array(numPoints);\n  const currentWindingDirection = math.polyline.getWindingDirection(polyline);\n  const parentAnnotation = getParentAnnotation(annotation) as ContourAnnotation;\n\n  if (closed === undefined) {\n    let currentClosedState = false;\n\n    // With two points it is just a line and do not make sense to consider it closed\n    if (polyline.length > 3) {\n      const lastToFirstDist = math.point.distanceToPointSquared(\n        polyline[0],\n        polyline[numPoints - 1]\n      );\n\n      currentClosedState = csUtils.isEqual(0, lastToFirstDist);\n    }\n\n    closed = currentClosedState;\n  }\n\n  // It must be in the opposite direction if it is a child annotation (hole)\n  let windingDirection = parentAnnotation\n    ? parentAnnotation.data.contour.windingDirection * -1\n    : targetWindingDirection;\n\n  if (windingDirection === undefined) {\n    windingDirection = currentWindingDirection;\n  } else if (windingDirection !== currentWindingDirection) {\n    polyline.reverse();\n  }\n\n  for (let i = 0; i < numPoints; i++) {\n    polylineWorldPoints[i] = canvasToWorld(polyline[i]);\n  }\n\n  data.contour.polyline = polylineWorldPoints;\n  data.contour.closed = closed;\n  data.contour.windingDirection = windingDirection;\n\n  invalidateAnnotation(annotation);\n}\n","import isObject from './isObject';\n\n/**\n * Creates a debounced function that delays invoking `func` until after `wait`\n * milliseconds have elapsed since the last time the debounced function was\n * invoked, or until the next browser frame is drawn. The debounced function\n * comes with a `cancel` method to cancel delayed `func` invocations and a\n * `flush` method to immediately invoke them. Provide `options` to indicate\n * whether `func` should be invoked on the leading and/or trailing edge of the\n * `wait` timeout. The `func` is invoked with the last arguments provided to the\n * debounced function. Subsequent calls to the debounced function return the\n * result of the last `func` invocation.\n *\n * **Note:** If `leading` and `trailing` options are `true`, `func` is\n * invoked on the trailing edge of the timeout only if the debounced function\n * is invoked more than once during the `wait` timeout.\n *\n * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n * until the next tick, similar to `setTimeout` with a timeout of `0`.\n *\n * If `wait` is omitted in an environment with `requestAnimationFrame`, `func`\n * invocation will be deferred until the next frame is drawn (typically about\n * 16ms).\n *\n * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n * for details over the differences between `debounce` and `throttle`.\n *\n * @param {Function} func The function to debounce.\n * @param {number} [wait=0]\n *  The number of milliseconds to delay; if omitted, `requestAnimationFrame` is\n *  used (if available).\n * @param {Object} [options={}] The options object.\n * @param {boolean} [options.leading=false]\n *  Specify invoking on the leading edge of the timeout.\n * @param {number} [options.maxWait]\n *  The maximum time `func` is allowed to be delayed before it's invoked.\n * @param {boolean} [options.trailing=true]\n *  Specify invoking on the trailing edge of the timeout.\n * @returns {Function} Returns the new debounced function.\n * @example\n *\n * // Avoid costly calculations while the window size is in flux.\n * jQuery(window).on('resize', debounce(calculateLayout, 150))\n *\n * // Invoke `sendMail` when clicked, debouncing subsequent calls.\n * jQuery(element).on('click', debounce(sendMail, 300, {\n *   'leading': true,\n *   'trailing': false\n * }))\n *\n * // Ensure `batchLog` is invoked once after 1 second of debounced calls.\n * const debounced = debounce(batchLog, 250, { 'maxWait': 1000 })\n * const source = new EventSource('/stream')\n * jQuery(source).on('message', debounced)\n *\n * // Cancel the trailing debounced invocation.\n * jQuery(window).on('popstate', debounced.cancel)\n *\n * // Check for pending invocations.\n * const status = debounced.pending() ? \"Pending...\" : \"Ready\"\n */\nfunction debounce(func, wait, options) {\n  let lastArgs, lastThis, maxWait, result, timerId, lastCallTime;\n\n  let lastInvokeTime = 0;\n  let leading = false;\n  let maxing = false;\n  let trailing = true;\n\n  // Bypass `requestAnimationFrame` by explicitly setting `wait=0`.\n  const useRAF =\n    !wait && wait !== 0 && typeof window.requestAnimationFrame === 'function';\n\n  if (typeof func !== 'function') {\n    throw new TypeError('Expected a function');\n  }\n  wait = Number(wait) || 0;\n  if (isObject(options)) {\n    leading = Boolean(options.leading);\n    maxing = 'maxWait' in options;\n    maxWait = maxing ? Math.max(Number(options.maxWait) || 0, wait) : maxWait;\n    trailing = 'trailing' in options ? Boolean(options.trailing) : trailing;\n  }\n\n  function invokeFunc(time) {\n    const args = lastArgs;\n    const thisArg = lastThis;\n\n    lastArgs = lastThis = undefined;\n    lastInvokeTime = time;\n    result = func.apply(thisArg, args);\n\n    return result;\n  }\n\n  function startTimer(pendingFunc, wait) {\n    if (useRAF) {\n      return window.requestAnimationFrame(pendingFunc);\n    }\n\n    return setTimeout(pendingFunc, wait);\n  }\n\n  function cancelTimer(id) {\n    if (useRAF) {\n      return window.cancelAnimationFrame(id);\n    }\n    clearTimeout(id);\n  }\n\n  function leadingEdge(time) {\n    // Reset any `maxWait` timer.\n    lastInvokeTime = time;\n    // Start the timer for the trailing edge.\n    timerId = startTimer(timerExpired, wait);\n\n    // Invoke the leading edge.\n    return leading ? invokeFunc(time) : result;\n  }\n\n  function remainingWait(time) {\n    const timeSinceLastCall = time - lastCallTime;\n    const timeSinceLastInvoke = time - lastInvokeTime;\n    const timeWaiting = wait - timeSinceLastCall;\n\n    return maxing\n      ? Math.min(timeWaiting, maxWait - timeSinceLastInvoke)\n      : timeWaiting;\n  }\n\n  function shouldInvoke(time) {\n    const timeSinceLastCall = time - lastCallTime;\n    const timeSinceLastInvoke = time - lastInvokeTime;\n\n    // Either this is the first call, activity has stopped and we're at the\n    // trailing edge, the system time has gone backwards and we're treating\n    // it as the trailing edge, or we've hit the `maxWait` limit.\n    return (\n      lastCallTime === undefined ||\n      timeSinceLastCall >= wait ||\n      timeSinceLastCall < 0 ||\n      (maxing && timeSinceLastInvoke >= maxWait)\n    );\n  }\n\n  function timerExpired() {\n    const time = Date.now();\n\n    if (shouldInvoke(time)) {\n      return trailingEdge(time);\n    }\n    // Restart the timer.\n    timerId = startTimer(timerExpired, remainingWait(time));\n  }\n\n  function trailingEdge(time) {\n    timerId = undefined;\n\n    // Only invoke if we have `lastArgs` which means `func` has been\n    // debounced at least once.\n    if (trailing && lastArgs) {\n      return invokeFunc(time);\n    }\n    lastArgs = lastThis = undefined;\n\n    return result;\n  }\n\n  function cancel() {\n    if (timerId !== undefined) {\n      cancelTimer(timerId);\n    }\n    lastInvokeTime = 0;\n    lastArgs = lastCallTime = lastThis = timerId = undefined;\n  }\n\n  function flush() {\n    return timerId === undefined ? result : trailingEdge(Date.now());\n  }\n\n  function pending() {\n    return timerId !== undefined;\n  }\n\n  function debounced(...args) {\n    const time = Date.now();\n    const isInvoking = shouldInvoke(time);\n\n    lastArgs = args;\n    lastThis = this; // eslint-disable-line consistent-this\n    lastCallTime = time;\n\n    if (isInvoking) {\n      if (timerId === undefined) {\n        return leadingEdge(lastCallTime);\n      }\n      if (maxing) {\n        // Handle invocations in a tight loop.\n        timerId = startTimer(timerExpired, wait);\n\n        return invokeFunc(lastCallTime);\n      }\n    }\n    if (timerId === undefined) {\n      timerId = startTimer(timerExpired, wait);\n    }\n\n    return result;\n  }\n  debounced.cancel = cancel;\n  debounced.flush = flush;\n  debounced.pending = pending;\n\n  return debounced;\n}\n\nexport default debounce;\n","import type { Types } from '@cornerstonejs/core';\n\n/**\n * Determine the coordinates that will place the textbox to the right of the\n * annotation.\n *\n * @param annotationCanvasPoints - The canvas points of the annotation's handles.\n * @returns - The coordinates for default placement of the textbox.\n */\nexport default function getTextBoxCoordsCanvas(\n  annotationCanvasPoints: Array<Types.Point2>\n): Types.Point2 {\n  const corners = _determineCorners(annotationCanvasPoints);\n  const centerY = (corners.top[1] + corners.bottom[1]) / 2;\n  const textBoxCanvas = <Types.Point2>[corners.right[0], centerY];\n\n  return textBoxCanvas;\n}\n\n/**\n * Determine the handles that have the min/max x and y values.\n *\n * @param canvasPoints - The canvas points of the annotation's handles.\n * @returns - The top, left, bottom, and right handles.\n */\nfunction _determineCorners(canvasPoints: Array<Types.Point2>) {\n  const handlesLeftToRight = [canvasPoints[0], canvasPoints[1]].sort(_compareX);\n  const handlesTopToBottom = [canvasPoints[0], canvasPoints[1]].sort(_compareY);\n  const right = handlesLeftToRight[handlesLeftToRight.length - 1];\n  const top = handlesTopToBottom[0];\n  const bottom = handlesTopToBottom[handlesTopToBottom.length - 1];\n\n  return {\n    top,\n    bottom,\n    right,\n  };\n\n  function _compareX(a, b) {\n    return a[0] < b[0] ? -1 : 1;\n  }\n  function _compareY(a, b) {\n    return a[1] < b[1] ? -1 : 1;\n  }\n}\n","import { utilities, cache, Types } from '@cornerstonejs/core';\nimport { getVoxelOverlap } from '../segmentation/utilities';\nimport pointInShapeCallback from '../pointInShapeCallback';\n\n/**\n * Gets the scalar data for a series of time points for either a single\n * coordinate or a segmentation mask, it will return the an array of scalar\n * data for a single coordinate or an array of arrays for a segmentation.\n *\n * @param dynamicVolume - 4D volume to compute time point data from\n * @param options - frameNumbers: which frames to use as timepoints, if left\n * blank, gets data timepoints over all frames\n * maskVolumeId: segmentationId to get timepoint data of\n * imageCoordinate: world coordinate to get timepoint data of\n * @returns\n */\nfunction getDataInTime(\n  dynamicVolume: Types.IDynamicImageVolume,\n  options: {\n    frameNumbers?;\n    maskVolumeId?;\n    imageCoordinate?;\n  }\n): number[] | number[][] {\n  let dataInTime;\n\n  // if frameNumbers is not provided, all frames are selected\n  const frames = options.frameNumbers || [\n    ...Array(dynamicVolume.numTimePoints).keys(),\n  ];\n\n  // You only need to provide either maskVolumeId OR imageCoordinate.\n  // Throws error if neither maskVolumeId or imageCoordinate is given,\n  // throws error if BOTH maskVolumeId and imageCoordinate is given\n  if (!options.maskVolumeId && !options.imageCoordinate) {\n    throw new Error(\n      'You should provide either maskVolumeId or imageCoordinate'\n    );\n  }\n\n  if (options.maskVolumeId && options.imageCoordinate) {\n    throw new Error('You can only use one of maskVolumeId or imageCoordinate');\n  }\n\n  if (options.maskVolumeId) {\n    const segmentationVolume = cache.getVolume(options.maskVolumeId);\n\n    const [dataInTime, ijkCoords] = _getTimePointDataMask(\n      frames,\n      dynamicVolume,\n      segmentationVolume\n    );\n\n    return [dataInTime, ijkCoords];\n  }\n\n  if (options.imageCoordinate) {\n    const dataInTime = _getTimePointDataCoordinate(\n      frames,\n      options.imageCoordinate,\n      dynamicVolume\n    );\n\n    return dataInTime;\n  }\n\n  return dataInTime;\n}\n\nfunction _getTimePointDataCoordinate(frames, coordinate, volume) {\n  const { dimensions, imageData } = volume;\n  const index = imageData.worldToIndex(coordinate);\n\n  index[0] = Math.floor(index[0]);\n  index[1] = Math.floor(index[1]);\n  index[2] = Math.floor(index[2]);\n\n  if (!utilities.indexWithinDimensions(index, dimensions)) {\n    throw new Error('outside bounds');\n  }\n\n  // calculate offset for index\n  const yMultiple = dimensions[0];\n  const zMultiple = dimensions[0] * dimensions[1];\n  const allScalarData = volume.getScalarDataArrays();\n  const value = [];\n\n  frames.forEach((frame) => {\n    const activeScalarData = allScalarData[frame];\n    const scalarIndex = index[2] * zMultiple + index[1] * yMultiple + index[0];\n    value.push(activeScalarData[scalarIndex]);\n  });\n\n  return value;\n}\n\nfunction _getTimePointDataMask(frames, dynamicVolume, segmentationVolume) {\n  const { imageData: maskImageData } = segmentationVolume;\n  const segScalarData = segmentationVolume.getScalarData();\n\n  const len = segScalarData.length;\n\n  // Pre-allocate memory for array\n  const nonZeroVoxelIndices = [];\n  nonZeroVoxelIndices.length = len;\n  const ijkCoords = [];\n\n  const dimensions = segmentationVolume.dimensions;\n\n  // Get the index of every non-zero voxel in mask\n  let actualLen = 0;\n  for (let i = 0, len = segScalarData.length; i < len; i++) {\n    if (segScalarData[i] !== 0) {\n      ijkCoords.push([\n        i % dimensions[0],\n        Math.floor((i / dimensions[0]) % dimensions[1]),\n        Math.floor(i / (dimensions[0] * dimensions[1])),\n      ]);\n      nonZeroVoxelIndices[actualLen++] = i;\n    }\n  }\n\n  // Trim the array to actual size\n  nonZeroVoxelIndices.length = actualLen;\n\n  const dynamicVolumeScalarDataArray = dynamicVolume.getScalarDataArrays();\n  const values = [];\n  const isSameVolume =\n    dynamicVolumeScalarDataArray[0].length === len &&\n    JSON.stringify(dynamicVolume.spacing) ===\n      JSON.stringify(segmentationVolume.spacing);\n\n  // if the segmentation mask is the same size as the dynamic volume (one frame)\n  // means we can just return the scalar data for the non-zero voxels\n  if (isSameVolume) {\n    for (let i = 0; i < nonZeroVoxelIndices.length; i++) {\n      const indexValues = [];\n      frames.forEach((frame) => {\n        const activeScalarData = dynamicVolumeScalarDataArray[frame];\n        indexValues.push(activeScalarData[nonZeroVoxelIndices[i]]);\n      });\n      values.push(indexValues);\n    }\n\n    return [values, ijkCoords];\n  }\n\n  // In case that the segmentation mask is not the same size as the dynamic volume (one frame)\n  // then we need to consider each voxel in the segmentation mask and check if it\n  // overlaps with the other volume, and if so we need to average the values of the\n  // overlapping voxels.\n  const callback = ({\n    pointLPS: segPointLPS,\n    value: segValue,\n    pointIJK: segPointIJK,\n  }) => {\n    // see if the value is non-zero\n    if (segValue === 0) {\n      // not interested\n      return;\n    }\n\n    // Then for each non-zero voxel in the segmentation mask, we should\n    // again perform the pointInShapeCallback to run the averaging callback\n    // function to get the average value of the overlapping voxels.\n    const overlapIJKMinMax = getVoxelOverlap(\n      dynamicVolume.imageData,\n      dynamicVolume.dimensions,\n      dynamicVolume.spacing,\n      segPointLPS\n    );\n\n    // count represents the number of voxels of the dynamic volume that represents\n    // one voxel of the segmentation mask\n    let count = 0;\n    const perFrameSum = new Map();\n\n    // Pre-initialize the Map\n    frames.forEach((frame) => perFrameSum.set(frame, 0));\n\n    const averageCallback = ({ index }) => {\n      for (let i = 0; i < frames.length; i++) {\n        const value = dynamicVolumeScalarDataArray[i][index];\n        const frame = frames[i];\n        perFrameSum.set(frame, perFrameSum.get(frame) + value);\n      }\n      count++;\n    };\n\n    pointInShapeCallback(\n      dynamicVolume.imageData,\n      () => true,\n      averageCallback,\n      overlapIJKMinMax\n    );\n\n    // average the values\n    const averageValues = [];\n    perFrameSum.forEach((sum) => {\n      averageValues.push(sum / count);\n    });\n\n    ijkCoords.push(segPointIJK);\n    values.push(averageValues);\n  };\n\n  // Since we have the non-zero voxel indices of the segmentation mask,\n  // we theoretically can use them, however, we kind of need to compute the\n  // pointLPS for each of the non-zero voxel indices, which is a bit of a pain.\n  // Todo: consider using the nonZeroVoxelIndices to compute the pointLPS\n  pointInShapeCallback(maskImageData, () => true, callback);\n\n  return [values, ijkCoords];\n}\n\nexport default getDataInTime;\n","import { Enums, Types } from '@cornerstonejs/core';\n\n/**\n * Gets the scalar data for a series of time frames from a 4D volume, returns an\n * array of scalar data after performing AVERAGE, SUM or SUBTRACT to be used to\n * create a 3D volume\n *\n * @param dynamicVolume4D - volume to compute time frame data from\n * @param operation - operation to perform on time frame data, operations include\n * SUM, AVERAGE, and SUBTRACT (can only be used with 2 time frames provided)\n * @param frameNumbers - an array of frame indices to perform the operation on, if\n * left empty, all frames will be used\n * @returns\n */\nfunction generateImageFromTimeData(\n  dynamicVolume: Types.IDynamicImageVolume,\n  operation: string,\n  frameNumbers?: number[]\n) {\n  // If no time frames provided, use all time frames\n  const frames = frameNumbers || [...Array(dynamicVolume.numTimePoints).keys()];\n  const numFrames = frames.length;\n\n  if (frames.length <= 1) {\n    throw new Error('Please provide two or more time points');\n  }\n\n  // Gets scalar data for all time frames\n  const typedArrays = dynamicVolume.getScalarDataArrays();\n\n  const arrayLength = typedArrays[0].length;\n  const finalArray = new Float32Array(arrayLength);\n\n  if (operation === Enums.DynamicOperatorType.SUM) {\n    for (let i = 0; i < numFrames; i++) {\n      const currentArray = typedArrays[frames[i]];\n      for (let j = 0; j < arrayLength; j++) {\n        finalArray[j] += currentArray[j];\n      }\n    }\n    return finalArray;\n  }\n\n  if (operation === Enums.DynamicOperatorType.SUBTRACT) {\n    if (frames.length > 2) {\n      throw new Error('Please provide only 2 time points for subtraction.');\n    }\n    for (let j = 0; j < arrayLength; j++) {\n      finalArray[j] += typedArrays[frames[0]][j] - typedArrays[frames[1]][j];\n    }\n    return finalArray;\n  }\n\n  if (operation === Enums.DynamicOperatorType.AVERAGE) {\n    for (let i = 0; i < numFrames; i++) {\n      const currentArray = typedArrays[frames[i]];\n      for (let j = 0; j < arrayLength; j++) {\n        finalArray[j] += currentArray[j];\n      }\n    }\n    for (let k = 0; k < arrayLength; k++) {\n      finalArray[k] = finalArray[k] / numFrames;\n    }\n    return finalArray;\n  }\n}\n\nexport default generateImageFromTimeData;\n","import { getEnabledElement } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { AnnotationTool, BaseTool } from '../tools';\nimport { Annotation } from '../types';\nimport { getAnnotations } from '../stateManagement/annotation/annotationState';\nimport * as ToolGroupManager from '../store/ToolGroupManager';\n\n/**\n * Get the annotation that is close to the provided canvas point, it will return\n * the first annotation that is found.\n *\n * @param element - The element to search for an annotation on.\n * @param canvasPoint - The canvasPoint on the page where the user clicked.\n * @param proximity - The distance from the canvasPoint to the annotation.\n * @returns The annotation for the element\n */\nfunction getAnnotationNearPoint(\n  element: HTMLDivElement,\n  canvasPoint: Types.Point2,\n  proximity = 5\n): Annotation | null {\n  // Todo: this function should return closest annotation, BUT, we are not using\n  // the function anywhere.\n  const enabledElement = getEnabledElement(element);\n  if (!enabledElement) {\n    throw new Error('getAnnotationNearPoint: enabledElement not found');\n  }\n\n  return getAnnotationNearPointOnEnabledElement(\n    enabledElement,\n    canvasPoint,\n    proximity\n  );\n}\n\n/**\n * \"Find the annotation near the point on the enabled element.\" it will return the\n * first annotation that is found.\n *\n * @param enabledElement - The element that is currently active.\n * @param point - The point to search near.\n * @param proximity - The distance from the point that the annotation must\n * be within.\n * @returns A Annotation object.\n */\nfunction getAnnotationNearPointOnEnabledElement(\n  enabledElement: Types.IEnabledElement,\n  point: Types.Point2,\n  proximity: number\n): Annotation | null {\n  // Todo: this function should return closest annotation, BUT, we are not using\n  // the function anywhere.\n  const { renderingEngineId, viewportId } = enabledElement;\n  const toolGroup = ToolGroupManager.getToolGroupForViewport(\n    viewportId,\n    renderingEngineId\n  );\n\n  if (!toolGroup) {\n    return null;\n  }\n\n  const { _toolInstances: tools } = toolGroup;\n  for (const name in tools) {\n    const found = findAnnotationNearPointByTool(\n      tools[name],\n      enabledElement,\n      point,\n      proximity\n    );\n    if (found) {\n      return found;\n    }\n  }\n\n  return null;\n}\n\n/**\n * For the provided toolClass, it will find the annotation that is near the point,\n * it will return the first annotation that is found.\n *\n * @param tool - AnnotationTool\n * @param enabledElement - The element that is currently active.\n * @param point - The point in the image where the user clicked.\n * @param proximity - The distance from the point that the tool must be\n * within to be considered \"near\" the point.\n * @returns The annotation object that is being returned is the annotation object that\n * is being used in the tool.\n */\nfunction findAnnotationNearPointByTool(\n  tool: AnnotationTool,\n  enabledElement: Types.IEnabledElement,\n  point: Types.Point2,\n  proximity: number\n): Annotation | null {\n  // Todo: this function does not return closest annotation. It just returns\n  // the first annotation that is found in the proximity. BUT, we are not using\n  // the function anywhere.\n  const { viewport } = enabledElement;\n\n  const annotations = getAnnotations(\n    (tool.constructor as typeof BaseTool).toolName,\n    viewport?.element\n  );\n  const currentId = viewport?.getCurrentImageId?.();\n  if (annotations?.length) {\n    const { element } = enabledElement.viewport;\n    for (const annotation of annotations) {\n      const referencedImageId = annotation.metadata?.referencedImageId;\n      if (\n        (currentId && referencedImageId && currentId !== referencedImageId) ||\n        !tool.isPointNearTool\n      ) {\n        continue;\n      }\n\n      if (\n        tool.isPointNearTool(element, annotation, point, proximity, '') ||\n        tool.getHandleNearImagePoint(element, annotation, point, proximity)\n      ) {\n        return annotation;\n      }\n    }\n  }\n  return null;\n}\n\nexport { getAnnotationNearPoint, getAnnotationNearPointOnEnabledElement };\n","import { Enums, utilities } from '@cornerstonejs/core';\n\nconst { CalibrationTypes } = Enums;\nconst PIXEL_UNITS = 'px';\n\nconst SUPPORTED_REGION_DATA_TYPES = [\n  1, // Tissue\n];\n\nconst SUPPORTED_LENGTH_VARIANT = [\n  '3,3', // x: cm  &  y:cm\n];\n\nconst SUPPORTED_PROBE_VARIANT = [\n  '4,3', // x: seconds  &  y : cm\n];\n\nconst UNIT_MAPPING = {\n  3: 'cm',\n  4: 'seconds',\n};\n\nconst EPS = 1e-3;\nconst SQUARE = '\\xb2';\n/**\n * Extracts the calibrated length units, area units, and the scale\n * for converting from internal spacing to image spacing.\n *\n * @param handles - to detect if spacing information is different between points\n * @param image - to extract the calibration from\n * @returns Object containing the units, area units, and scale\n */\nconst getCalibratedLengthUnitsAndScale = (image, handles) => {\n  const { calibration, hasPixelSpacing } = image;\n  let units = hasPixelSpacing ? 'mm' : PIXEL_UNITS;\n  let areaUnits = units + SQUARE;\n  let scale = 1;\n  let calibrationType = '';\n\n  if (\n    !calibration ||\n    (!calibration.type && !calibration.sequenceOfUltrasoundRegions)\n  ) {\n    return { units, areaUnits, scale };\n  }\n\n  if (calibration.type === CalibrationTypes.UNCALIBRATED) {\n    return { units: PIXEL_UNITS, areaUnits: PIXEL_UNITS + SQUARE, scale };\n  }\n\n  if (calibration.sequenceOfUltrasoundRegions) {\n    let imageIndex1, imageIndex2;\n    if (Array.isArray(handles) && handles.length === 2) {\n      [imageIndex1, imageIndex2] = handles;\n    } else if (typeof handles === 'function') {\n      const points = handles();\n      imageIndex1 = points[0];\n      imageIndex2 = points[1];\n    }\n\n    let regions = calibration.sequenceOfUltrasoundRegions.filter(\n      (region) =>\n        imageIndex1[0] >= region.regionLocationMinX0 &&\n        imageIndex1[0] <= region.regionLocationMaxX1 &&\n        imageIndex1[1] >= region.regionLocationMinY0 &&\n        imageIndex1[1] <= region.regionLocationMaxY1 &&\n        imageIndex2[0] >= region.regionLocationMinX0 &&\n        imageIndex2[0] <= region.regionLocationMaxX1 &&\n        imageIndex2[1] >= region.regionLocationMinY0 &&\n        imageIndex2[1] <= region.regionLocationMaxY1\n    );\n\n    // If we are not in a region at all we should show the underlying calibration\n    // which might be the mm spacing for the image\n    if (!regions?.length) {\n      return { units, areaUnits, scale };\n    }\n\n    // if we are in a region then it is the question of whether we support it\n    // or not. If we do not support it we should show px\n\n    regions = regions.filter(\n      (region) =>\n        SUPPORTED_REGION_DATA_TYPES.includes(region.regionDataType) &&\n        SUPPORTED_LENGTH_VARIANT.includes(\n          `${region.physicalUnitsXDirection},${region.physicalUnitsYDirection}`\n        )\n    );\n\n    if (!regions.length) {\n      return { units: PIXEL_UNITS, areaUnits: PIXEL_UNITS + SQUARE, scale };\n    }\n\n    // Todo: expand on this logic\n    const region = regions[0];\n\n    const physicalDeltaX = Math.abs(region.physicalDeltaX);\n    const physicalDeltaY = Math.abs(region.physicalDeltaY);\n\n    // if we are in a supported region then we should check if the\n    // physicalDeltaX and physicalDeltaY are the same. If they are not\n    // then we should show px again, but if they are the same then we should\n    // show the units\n    const isSamePhysicalDelta = utilities.isEqual(\n      physicalDeltaX,\n      physicalDeltaY,\n      EPS\n    );\n\n    if (isSamePhysicalDelta) {\n      // 1 to 1 aspect ratio, we use just one of them\n      scale = 1 / (physicalDeltaX * 10);\n      calibrationType = 'US Region';\n      units = 'mm';\n      areaUnits = 'mm' + SQUARE;\n    } else {\n      // here we are showing at the aspect ratio of the physical delta\n      // if they are not the same, then we should show px, but the correct solution\n      // is to grab each point separately and scale them individually\n      // Todo: implement this\n      return { units: PIXEL_UNITS, areaUnits: PIXEL_UNITS + SQUARE, scale };\n    }\n  } else if (calibration.scale) {\n    scale = calibration.scale;\n  }\n\n  // everything except REGION/Uncalibrated\n  const types = [\n    CalibrationTypes.ERMF,\n    CalibrationTypes.USER,\n    CalibrationTypes.ERROR,\n    CalibrationTypes.PROJECTION,\n  ];\n\n  if (types.includes(calibration?.type)) {\n    calibrationType = calibration.type;\n  }\n\n  return {\n    units: units + (calibrationType ? ` ${calibrationType}` : ''),\n    areaUnits: areaUnits + (calibrationType ? ` ${calibrationType}` : ''),\n    scale,\n  };\n};\n\nconst getCalibratedProbeUnitsAndValue = (image, handles) => {\n  const [imageIndex] = handles;\n  const { calibration } = image;\n  let units = ['raw'];\n  let values = [null];\n  let calibrationType = '';\n\n  if (\n    !calibration ||\n    (!calibration.type && !calibration.sequenceOfUltrasoundRegions)\n  ) {\n    return { units, values };\n    // Todo: add support for other scenarios\n  }\n\n  if (calibration.sequenceOfUltrasoundRegions) {\n    // for Probe tool\n    const supportedRegionsMetadata =\n      calibration.sequenceOfUltrasoundRegions.filter(\n        (region) =>\n          SUPPORTED_REGION_DATA_TYPES.includes(region.regionDataType) &&\n          SUPPORTED_PROBE_VARIANT.includes(\n            `${region.physicalUnitsXDirection},${region.physicalUnitsYDirection}`\n          )\n      );\n\n    if (!supportedRegionsMetadata?.length) {\n      return { units, values };\n    }\n\n    const region = supportedRegionsMetadata.find(\n      (region) =>\n        imageIndex[0] >= region.regionLocationMinX0 &&\n        imageIndex[0] <= region.regionLocationMaxX1 &&\n        imageIndex[1] >= region.regionLocationMinY0 &&\n        imageIndex[1] <= region.regionLocationMaxY1\n    );\n\n    if (!region) {\n      return { units, values };\n    }\n\n    // Todo: I think this is a ok assumption for now that if the referencePixelX0 and referencePixelY0\n    // are not defined, then we can assume 0 for them\n    const { referencePixelX0 = 0, referencePixelY0 = 0 } = region;\n    const { physicalDeltaX, physicalDeltaY } = region;\n\n    const yValue =\n      (imageIndex[1] - region.regionLocationMinY0 - referencePixelY0) *\n      physicalDeltaY;\n\n    const xValue =\n      (imageIndex[0] - region.regionLocationMinX0 - referencePixelX0) *\n      physicalDeltaX;\n\n    calibrationType = 'US Region';\n    values = [xValue, yValue];\n    units = [\n      UNIT_MAPPING[region.physicalUnitsXDirection],\n      UNIT_MAPPING[region.physicalUnitsYDirection],\n    ];\n  }\n\n  return {\n    units,\n    values,\n    calibrationType,\n  };\n};\n\n/** Gets the aspect ratio of the screen display relative to the image\n * display in order to square up measurement values.\n * That is, suppose the spacing on the image is 1, 0.5 (x,y spacing)\n * This is displayed at 1, 1 spacing on screen, then the\n * aspect value will be 1/0.5 = 2\n */\nconst getCalibratedAspect = (image) => image.calibration?.aspect || 1;\n\nexport {\n  getCalibratedLengthUnitsAndScale,\n  getCalibratedAspect,\n  getCalibratedProbeUnitsAndValue,\n};\n","import { utilities as csUtils } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport type { vtkImageData } from '@kitware/vtk.js/Common/DataModel/ImageData';\nimport { vec3 } from 'gl-matrix';\nimport { BoundsIJK } from '../types';\nimport { getBoundingBoxAroundShapeIJK } from './boundingBox';\n\nconst { transformWorldToIndex } = csUtils;\n\n/**\n * Given an imageData, and the great circle top and bottom points of a sphere,\n * this function will run the callback for each point of the imageData that is\n * within the sphere defined by the great circle points. If the viewport\n * is provided, region of interest will be an accurate approximation of the\n * sphere (using viewport camera), and the resulting performance will be\n * better.\n *\n * @privateRemarks great circle also known as orthodrome is the intersection of\n * the sphere and the plane that passes through the center of the sphere\n *\n * @param imageData - The volume imageData\n * @param circlePoints - bottom and top points of the great circle in world coordinates\n * @param callback - A callback function that will be called for each point in the shape.\n */\nfunction getSphereBoundsInfo(\n  circlePoints: [Types.Point3, Types.Point3],\n  imageData: vtkImageData,\n  viewport\n): {\n  boundsIJK: BoundsIJK;\n  centerWorld: Types.Point3;\n  radiusWorld: number;\n  topLeftWorld: Types.Point3;\n  bottomRightWorld: Types.Point3;\n} {\n  const [bottom, top] = circlePoints;\n\n  // Sphere center in world\n  const centerWorld = vec3.fromValues(\n    (bottom[0] + top[0]) / 2,\n    (bottom[1] + top[1]) / 2,\n    (bottom[2] + top[2]) / 2\n  );\n\n  // sphere radius in world\n  const radiusWorld = vec3.distance(bottom, top) / 2;\n\n  if (!viewport) {\n    throw new Error(\n      'viewport is required in order to calculate the sphere bounds'\n    );\n  }\n\n  const { boundsIJK, topLeftWorld, bottomRightWorld } =\n    _computeBoundsIJKWithCamera(\n      imageData,\n      viewport,\n      circlePoints,\n      centerWorld,\n      radiusWorld\n    );\n\n  return {\n    boundsIJK,\n    centerWorld: centerWorld as Types.Point3,\n    radiusWorld,\n    topLeftWorld: topLeftWorld as Types.Point3,\n    bottomRightWorld: bottomRightWorld as Types.Point3,\n  };\n}\n\nfunction _computeBoundsIJKWithCamera(\n  imageData,\n  viewport,\n  circlePoints,\n  centerWorld,\n  radiusWorld\n) {\n  const [bottom, top] = circlePoints;\n\n  const dimensions = imageData.getDimensions() as Types.Point3;\n\n  const camera = viewport.getCamera();\n\n  // Calculate viewRight from the camera, this will get used in order to\n  // calculate circles topLeft and bottomRight on different planes of intersection\n  // between sphere and viewPlane\n  const viewUp = vec3.fromValues(\n    camera.viewUp[0],\n    camera.viewUp[1],\n    camera.viewUp[2]\n  );\n  const viewPlaneNormal = vec3.fromValues(\n    camera.viewPlaneNormal[0],\n    camera.viewPlaneNormal[1],\n    camera.viewPlaneNormal[2]\n  );\n  const viewRight = vec3.create();\n\n  vec3.cross(viewRight, viewUp, viewPlaneNormal);\n\n  // we need to find the bounding box of the sphere in the image, e.g., the\n  // topLeftWorld and bottomRightWorld points of the bounding box.\n  // We go from the sphereCenter in the normal direction of amount radius, and\n  // we go left to find the topLeftWorld point of the bounding box. Next we go\n  // in the opposite direction and go right to find the bottomRightWorld point\n  // of the bounding box.\n  const topLeftWorld = vec3.create();\n  const bottomRightWorld = vec3.create();\n\n  vec3.scaleAndAdd(topLeftWorld, top, viewPlaneNormal, radiusWorld);\n  vec3.scaleAndAdd(bottomRightWorld, bottom, viewPlaneNormal, -radiusWorld);\n\n  // go in the direction of viewRight with the value of radius\n  vec3.scaleAndAdd(topLeftWorld, topLeftWorld, viewRight, -radiusWorld);\n  vec3.scaleAndAdd(bottomRightWorld, bottomRightWorld, viewRight, radiusWorld);\n\n  // In order to correctly come up with the boundsIJK, we need to consider\n  // all the points IJK to get the bounds, since the viewport might have\n  // rotate views and we cannot guarantee that the topLeft and bottomRight in the\n  // world, are the ones that will define the bounds in IJK\n  const topLeftIJK = transformWorldToIndex(\n    imageData,\n    topLeftWorld as Types.Point3\n  );\n  const bottomRightIJK = transformWorldToIndex(\n    imageData,\n    bottomRightWorld as Types.Point3\n  );\n\n  const pointsIJK = circlePoints.map((p) =>\n    transformWorldToIndex(imageData, p)\n  );\n\n  // get the bounding box of the sphere in the image\n  const boundsIJK = getBoundingBoxAroundShapeIJK(\n    [topLeftIJK, bottomRightIJK, ...pointsIJK],\n    dimensions\n  );\n\n  return { boundsIJK, topLeftWorld, bottomRightWorld };\n}\n\nexport { getSphereBoundsInfo };\n","import type { Annotation } from '../types';\nimport getViewportsForAnnotation from './getViewportsForAnnotation';\n\n/**\n * Finds a matching viewport in terms of the orientation of the annotation data\n * and the frame of reference.  This doesn't mean the annotation IS being displayed\n * in the viewport, just that it could be by navigating the slice, and/or pan/zoom,\n * without changing the orientation.\n *\n * @param annotation - to find a viewport that it could display in\n * @returns The viewport to display in\n */\nexport default function getViewportForAnnotation(annotation: Annotation) {\n  const viewports = getViewportsForAnnotation(annotation);\n\n  return viewports.length ? viewports[0] : undefined;\n}\n","/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @since 0.1.0\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * isObject({})\n * // => true\n *\n * isObject([1, 2, 3])\n * // => true\n *\n * isObject(Function)\n * // => true\n *\n * isObject(null)\n * // => false\n */\nfunction isObject(value) {\n  const type = typeof value;\n\n  return value !== null && (type === 'object' || type === 'function');\n}\n\nexport default isObject;\n","import { Types } from '@cornerstonejs/core';\n\n/**\n * Check if two axis-aligned bounding boxes intersect\n * @param aabb1 - First AABB\n * @param aabb2 - Second AABB\n * @returns True if they intersect or false otherwise\n */\nexport default function intersectAABB(\n  aabb1: Types.AABB2,\n  aabb2: Types.AABB2\n): boolean {\n  return (\n    aabb1.minX <= aabb2.maxX &&\n    aabb1.maxX >= aabb2.minX &&\n    aabb1.minY <= aabb2.maxY &&\n    aabb1.maxY >= aabb2.minY\n  );\n}\n","import { Types } from '@cornerstonejs/core';\n\n/**\n * Calculates the distance of a point to an AABB using 2D Box SDF (Signed Distance Field)\n *\n * The SDF of a Box\n * https://www.youtube.com/watch?v=62-pRVZuS5c\n *\n * @param aabb - Axis-aligned bound box\n * @param point - 2D point\n * @returns The closest distance between the 2D point and the AABB\n */\nexport default function distanceToPointSquared(\n  aabb: Types.AABB2,\n  point: Types.Point2\n): number {\n  const aabbWidth = aabb.maxX - aabb.minX;\n  const aabbHeight = aabb.maxY - aabb.minY;\n  const aabbSize = [aabbWidth, aabbHeight];\n  const aabbCenter: Types.Point2 = [\n    aabb.minX + aabbWidth / 2,\n    aabb.minY + aabbHeight / 2,\n  ];\n\n  // Translates the point as the center of the AABB is the new origin.\n  // THe point is also mirroed to the first quadrant to simplify the math.\n  const translatedPoint = [\n    Math.abs(point[0] - aabbCenter[0]),\n    Math.abs(point[1] - aabbCenter[1]),\n  ];\n\n  // Calculate the distance from the point to the vertical and horizontal AABB borders\n  const dx = translatedPoint[0] - aabbSize[0] * 0.5;\n  const dy = translatedPoint[1] - aabbSize[1] * 0.5;\n\n  // dx >  0 && dy >  0: diagonal line connecting the point to AABB's corner\n  // dx >  0 && dy <= 0: a line parallel to x-axis connecting the point to AABB's right side\n  // dx <= 0 && dy >  0: a line parallel to y-axis connecting the point to AABB's top side\n  // dx <= 0 && dy <= 0: the point is inside the AABB\n  if (dx > 0 && dy > 0) {\n    return dx * dx + dy * dy;\n  }\n\n  const dist = Math.max(dx, 0) + Math.max(dy, 0);\n\n  return dist * dist;\n}\n","import { Types } from '@cornerstonejs/core';\nimport distanceToPointSquared from './distanceToPointSquared';\n\n/**\n * Calculates the squared distance of a point to an AABB using\n * 2D Box SDF (Signed Distance Field)\n *\n * The SDF of a Box\n * https://www.youtube.com/watch?v=62-pRVZuS5c\n *\n * @param aabb - Axis-aligned bound box (minX, minY, maxX and maxY)\n * @param point - 2D point\n * @returns The squared distance between the 2D point and the AABB\n */\nexport default function distanceToPoint(\n  aabb: Types.AABB2,\n  point: Types.Point2\n): number {\n  return Math.sqrt(distanceToPointSquared(aabb, point));\n}\n","import { NamedStatistics } from '../../../types';\n\nabstract class Calculator {\n  static run: ({ value }) => void;\n  /**\n   * Gets the statistics as both an array of values, as well as the named values.\n   */\n  static getStatistics: () => NamedStatistics;\n}\n\nexport default Calculator;\n","import { NamedStatistics, Statistics } from '../../../types';\nimport Calculator from './Calculator';\n\nexport default class BasicStatsCalculator extends Calculator {\n  private static max = [-Infinity];\n  private static sum = [0];\n  private static sumSquares = [0];\n  private static squaredDiffSum = [0];\n  private static count = 0;\n\n  /**\n   * This callback is used when we verify if the point is in the annotion drawn so we can get every point\n   * in the shape to calculate the statistics\n   * @param value of the point in the shape of the annotation\n   */\n  static statsCallback = ({ value: newValue }): void => {\n    if (\n      Array.isArray(newValue) &&\n      newValue.length > 1 &&\n      this.max.length === 1\n    ) {\n      this.max.push(this.max[0], this.max[0]);\n      this.sum.push(this.sum[0], this.sum[0]);\n      this.sumSquares.push(this.sumSquares[0], this.sumSquares[0]);\n      this.squaredDiffSum.push(this.squaredDiffSum[0], this.squaredDiffSum[0]);\n    }\n\n    const newArray = Array.isArray(newValue) ? newValue : [newValue];\n    this.count += 1;\n\n    this.max.forEach(\n      (it, idx) => (this.max[idx] = Math.max(it, newArray[idx]))\n    );\n    this.sum.map((it, idx) => (this.sum[idx] += newArray[idx]));\n    this.sumSquares.map(\n      (it, idx) => (this.sumSquares[idx] += newArray[idx] ** 2)\n    );\n    this.squaredDiffSum.map(\n      (it, idx) =>\n        (this.squaredDiffSum[idx] += Math.pow(\n          newArray[idx] - this.sum[idx] / this.count,\n          2\n        ))\n    );\n  };\n\n  /**\n   * Basic function that calculates statictics for a given array of points.\n   * @returns An object that contains :\n   * max : The maximum value of the array\n   * mean : mean of the array\n   * stdDev : standard deviation of the array\n   * stdDevWithSumSquare : standard deviation of the array using sum\n   * array : An array of hte above values, in order.\n   */\n\n  static getStatistics = (): NamedStatistics => {\n    const mean = this.sum.map((sum) => sum / this.count);\n    const stdDev = this.squaredDiffSum.map((squaredDiffSum) =>\n      Math.sqrt(squaredDiffSum / this.count)\n    );\n    const stdDevWithSumSquare = this.sumSquares.map((it, idx) =>\n      Math.sqrt(this.sumSquares[idx] / this.count - mean[idx] ** 2)\n    );\n\n    const named: NamedStatistics = {\n      max: {\n        name: 'max',\n        label: 'Max Pixel',\n        value: singleArrayAsNumber(this.max),\n        unit: null,\n      },\n      mean: {\n        name: 'mean',\n        label: 'Mean Pixel',\n        value: singleArrayAsNumber(mean),\n        unit: null,\n      },\n      stdDev: {\n        name: 'stdDev',\n        label: 'Standard Deviation',\n        value: singleArrayAsNumber(stdDev),\n        unit: null,\n      },\n      stdDevWithSumSquare: {\n        name: 'stdDevWithSumSquare',\n        value: singleArrayAsNumber(stdDevWithSumSquare),\n        unit: null,\n      },\n      count: {\n        name: 'count',\n        label: 'Pixel Count',\n        value: this.count,\n        unit: null,\n      },\n      array: [],\n    };\n    named.array.push(\n      named.max,\n      named.mean,\n      named.stdDev,\n      named.stdDevWithSumSquare,\n      named.count\n    );\n\n    this.max = [-Infinity];\n    this.sum = [0];\n    this.sumSquares = [0];\n    this.squaredDiffSum = [0];\n    this.count = 0;\n\n    return named;\n  };\n}\n\nfunction singleArrayAsNumber(val: number[]) {\n  return val.length === 1 ? val[0] : val;\n}\n","import type { Types } from '@cornerstonejs/core';\ninterface Inverts {\n  invXRadiusSq?: number;\n  invYRadiusSq?: number;\n  invZRadiusSq?: number;\n  fast?: boolean;\n  /**\n   * If you call the pointInEllipse.precalculateInverts first, then you\n   * can call precalculated directly instead of having the extra time for\n   * the if conditions.\n   */\n  precalculated?: (pointLPS: Types.Point3) => boolean;\n}\n\n/**\n * Given an ellipse and a point, return true if the point is inside the ellipse\n * @param ellipse - The ellipse object to check against.\n * @param pointLPS - The point in LPS space to test.\n * @param inverts - An object to cache the inverted radius squared values, if you\n * are testing multiple points against the same ellipse then it is recommended to\n * pass in the same object to cache the values. However, there is a simpler way\n * to do this by passing in the fast flag as true, then on the first iteration\n * the values will be cached and on subsequent iterations the cached values will\n * be used.\n *\n * @returns A boolean value.\n */\nexport default function pointInEllipse(\n  ellipse,\n  pointLPS,\n  inverts: Inverts = {}\n) {\n  if (!inverts.precalculated) {\n    precalculatePointInEllipse(ellipse, inverts);\n  }\n  return inverts.precalculated(pointLPS);\n}\n\n/**\n * This will perform some precalculations to make things faster.\n * Ideally, use the 'precalculated' function inside inverts to call the\n * test function.  This minimizes re-reading of variables and only needs the\n * LPS passed each time.\n * That is:\n *\n * ```\n *    const inverts = precalculatePointInEllipse(ellipse);\n *    if( inverts.precalculated(pointLPS) ) ...\n * ```\n */\nconst precalculatePointInEllipse = (ellipse, inverts: Inverts = {}) => {\n  const { xRadius, yRadius, zRadius } = ellipse;\n\n  // This will run only once since we are caching the values in the same\n  // object that is passed in.\n  if (\n    inverts.invXRadiusSq === undefined ||\n    inverts.invYRadiusSq === undefined ||\n    inverts.invZRadiusSq === undefined\n  ) {\n    inverts.invXRadiusSq = xRadius !== 0 ? 1 / xRadius ** 2 : 0;\n    inverts.invYRadiusSq = yRadius !== 0 ? 1 / yRadius ** 2 : 0;\n    inverts.invZRadiusSq = zRadius !== 0 ? 1 / zRadius ** 2 : 0;\n  }\n\n  const { invXRadiusSq, invYRadiusSq, invZRadiusSq } = inverts;\n  const { center } = ellipse;\n  const [centerL, centerP, centerS] = center;\n\n  inverts.precalculated = (pointLPS) => {\n    // Calculate the sum of normalized squared distances\n    const dx = pointLPS[0] - centerL;\n    let inside = dx * dx * invXRadiusSq;\n    if (inside > 1) {\n      return false;\n    }\n\n    const dy = pointLPS[1] - centerP;\n    inside += dy * dy * invYRadiusSq;\n    if (inside > 1) {\n      return false;\n    }\n\n    const dz = pointLPS[2] - centerS;\n    inside += dz * dz * invZRadiusSq;\n\n    // Check if the point is inside the ellipse\n    return inside <= 1;\n  };\n\n  return inverts;\n};\n\nexport { precalculatePointInEllipse };\n","import type { Types } from '@cornerstonejs/core';\n\nexport type CanvasCoordinates = [\n  Types.Point2, // bottom\n  Types.Point2, // top\n  Types.Point2, // left\n  Types.Point2 // right\n];\n\n/**\n * It takes the canvas coordinates of the ellipse corners and returns the top left and bottom right\n * corners of it\n *\n * @param ellipseCanvasPoints - The coordinates of the ellipse in the canvas.\n * @returns An array of two points.\n */\nexport default function getCanvasEllipseCorners(\n  ellipseCanvasPoints: CanvasCoordinates\n): Array<Types.Point2> {\n  const [bottom, top, left, right] = ellipseCanvasPoints;\n\n  const topLeft = <Types.Point2>[left[0], top[1]];\n  const bottomRight = <Types.Point2>[right[0], bottom[1]];\n\n  return [topLeft, bottomRight];\n}\n","import type { Types } from '@cornerstonejs/core';\nimport * as math from '../';\n\n/**\n * Calculate the closest point and the squared distance between a reference point and a line segment.\n *\n * It projects the reference point onto the line segment but it shall be bounded by the\n * start/end points since this is a line segment and not a line which could be extended.\n *\n * @param lineStart - Start point of the line segment\n * @param lineEnd - End point of the line segment\n * @param point - Reference point\n * @returns Closest point and the squared distance between a `point` and a line\n *   segment defined by `lineStart` and `lineEnd` points\n */\nexport default function distanceToPointSquaredInfo(\n  lineStart: Types.Point2,\n  lineEnd: Types.Point2,\n  point: Types.Point2\n): {\n  point: Types.Point2;\n  distanceSquared: number;\n} {\n  let closestPoint: Types.Point2;\n  const distanceSquared = math.point.distanceToPointSquared(lineStart, lineEnd);\n\n  // Check if lineStart equal to the lineEnd which means the closest point\n  // is any of these two points\n  if (lineStart[0] === lineEnd[0] && lineStart[1] === lineEnd[1]) {\n    closestPoint = lineStart;\n  }\n\n  if (!closestPoint) {\n    const dotProduct =\n      ((point[0] - lineStart[0]) * (lineEnd[0] - lineStart[0]) +\n        (point[1] - lineStart[1]) * (lineEnd[1] - lineStart[1])) /\n      distanceSquared;\n\n    if (dotProduct < 0) {\n      closestPoint = lineStart;\n    } else if (dotProduct > 1) {\n      closestPoint = lineEnd;\n    } else {\n      closestPoint = [\n        lineStart[0] + dotProduct * (lineEnd[0] - lineStart[0]),\n        lineStart[1] + dotProduct * (lineEnd[1] - lineStart[1]),\n      ];\n    }\n  }\n\n  return {\n    point: [...closestPoint],\n    distanceSquared: math.point.distanceToPointSquared(point, closestPoint),\n  };\n}\n","import { Types } from '@cornerstonejs/core';\nimport distanceToPointSquaredInfo from './distanceToPointSquaredInfo';\n\n/**\n * Calculates the distance-squared of a point to a line segment\n *\n * @param lineStart - x,y coordinates of the start of the line\n * @param lineEnd - x,y coordinates of the end of the line\n * @param point - x,y of the point\n * @returns distance-squared\n */\nexport default function distanceToPointSquared(\n  lineStart: Types.Point2,\n  lineEnd: Types.Point2,\n  point: Types.Point2\n): number {\n  return distanceToPointSquaredInfo(lineStart, lineEnd, point).distanceSquared;\n}\n","import distanceToPointSquared from './distanceToPointSquared';\nimport type { Types } from '@cornerstonejs/core';\n\n/**\n * Calculates the distance of a point to a line\n *\n * @param lineStart - x,y coordinates of the start of the line\n * @param lineEnd - x,y coordinates of the end of the line\n * @param point - x,y of the point\n * @returns distance\n */\nexport default function distanceToPoint(\n  lineStart: Types.Point2,\n  lineEnd: Types.Point2,\n  point: Types.Point2\n): number {\n  if (lineStart.length !== 2 || lineEnd.length !== 2 || point.length !== 2) {\n    throw Error(\n      'lineStart, lineEnd, and point should have 2 elements of [x, y]'\n    );\n  }\n\n  return Math.sqrt(distanceToPointSquared(lineStart, lineEnd, point));\n}\n","import type { Types } from '@cornerstonejs/core';\n\n// Returns sign of number\nfunction sign(x: any) {\n  return typeof x === 'number'\n    ? x\n      ? x < 0\n        ? -1\n        : 1\n      : x === x\n      ? 0\n      : NaN\n    : NaN;\n}\n\n/**\n * Calculates the intersection point between two lines in the 2D plane\n *\n * @param line1Start - x,y coordinates of the start of the first line\n * @param line1End - x,y coordinates of the end of the first line\n * @param line2Start - x,y coordinates of the start of the second line\n * @param line2End - x,y coordinates of the end of the second line\n * @returns [x,y] - point x,y of the point\n */\n\nexport default function intersectLine(\n  line1Start: Types.Point2,\n  line1End: Types.Point2,\n  line2Start: Types.Point2,\n  line2End: Types.Point2\n): number[] {\n  const [x1, y1] = line1Start;\n  const [x2, y2] = line1End;\n  const [x3, y3] = line2Start;\n  const [x4, y4] = line2End;\n\n  // Compute a1, b1, c1, where line joining points 1 and 2 is \"a1 x  +  b1 y  +  c1  =  0\"\n  const a1 = y2 - y1;\n  const b1 = x1 - x2;\n  const c1 = x2 * y1 - x1 * y2;\n\n  // Compute r3 and r4\n  const r3 = a1 * x3 + b1 * y3 + c1;\n  const r4 = a1 * x4 + b1 * y4 + c1;\n\n  /* Check signs of r3 and r4.  If both point 3 and point 4 lie on\n   * same side of line 1, the line segments do not intersect.\n   */\n\n  if (r3 !== 0 && r4 !== 0 && sign(r3) === sign(r4)) {\n    return;\n  }\n\n  // Compute a2, b2, c2\n  const a2 = y4 - y3;\n  const b2 = x3 - x4;\n  const c2 = x4 * y3 - x3 * y4;\n\n  // Compute r1 and r2\n  const r1 = a2 * x1 + b2 * y1 + c2;\n  const r2 = a2 * x2 + b2 * y2 + c2;\n\n  /* Check signs of r1 and r2.  If both point 1 and point 2 lie\n   * on same side of second line segment, the line segments do\n   * not intersect.\n   */\n\n  if (r1 !== 0 && r2 !== 0 && sign(r1) === sign(r2)) {\n    return;\n  }\n\n  /* Line segments intersect: compute intersection point.\n   */\n\n  const denom = a1 * b2 - a2 * b1;\n  let num;\n\n  /* The denom/2 is to get rounding instead of truncating.  It\n   * is added or subtracted to the numerator, depending upon the\n   * sign of the numerator.\n   */\n\n  num = b1 * c2 - b2 * c1;\n  const x = num / denom;\n\n  num = a2 * c1 - a1 * c2;\n  const y = num / denom;\n\n  const intersectionPoint = [x, y];\n\n  return intersectionPoint;\n}\n","import type { Types } from '@cornerstonejs/core';\n\nconst ORIENTATION_TOLERANCE = 1e-2;\n\n/**\n * Test if a point is on a line segment\n * @param lineStart - Line segment start point\n * @param lineEnd - Line segment end point\n * @param point - Point to test\n * @returns True if the point lies on the line segment or false otherwise\n */\nexport default function isPointOnLineSegment(\n  lineStart: Types.Point2,\n  lineEnd: Types.Point2,\n  point: Types.Point2\n): boolean {\n  // The code below runs ~4x faster than calling `line.distanceToPointSquared()` (155 vs 598 ms)\n\n  // No Math.min/max call for better performance when testing thousands of points\n  const minX = lineStart[0] <= lineEnd[0] ? lineStart[0] : lineEnd[0];\n  const maxX = lineStart[0] >= lineEnd[0] ? lineStart[0] : lineEnd[0];\n  const minY = lineStart[1] <= lineEnd[1] ? lineStart[1] : lineEnd[1];\n  const maxY = lineStart[1] >= lineEnd[1] ? lineStart[1] : lineEnd[1];\n\n  // Checks if the point lies inside the AABB\n  const aabbContainsPoint =\n    point[0] >= minX - ORIENTATION_TOLERANCE &&\n    point[0] <= maxX + ORIENTATION_TOLERANCE &&\n    point[1] >= minY - ORIENTATION_TOLERANCE &&\n    point[1] <= maxY + ORIENTATION_TOLERANCE;\n\n  if (!aabbContainsPoint) {\n    return false;\n  }\n\n  // Now that we know the point is inside the AABB we check if it lies on the line segment\n  const orientation =\n    (lineEnd[1] - lineStart[1]) * (point[0] - lineEnd[0]) -\n    (lineEnd[0] - lineStart[0]) * (point[1] - lineEnd[1]);\n  const absOrientation = orientation >= 0 ? orientation : -orientation;\n\n  // The orientation must be zero for points that lies on the same line\n  return absOrientation <= ORIENTATION_TOLERANCE;\n}\n","import type { Types } from '@cornerstonejs/core';\nimport distanceToPointSquared from './distanceToPointSquared';\n\ntype Point = Types.Point2 | Types.Point3;\n\n/**\n * Calculates the distance of a point to another point\n *\n * @param p1 - x,y or x,y,z of the point\n * @param p2 - x,y or x,y,z of the point\n * @returns distance\n */\nexport default function distanceToPoint(p1: Point, p2: Point): number {\n  return Math.sqrt(distanceToPointSquared(p1, p2));\n}\n","import type { Types } from '@cornerstonejs/core';\n\ntype Point = Types.Point2 | Types.Point3;\n\n/**\n * Calculates the distance squared of a point to another point\n *\n * @param p1 - x,y or x,y,z of the point\n * @param p2 - x,y or x,y,z of the point\n * @returns distance\n */\nexport default function distanceToPointSquared(p1: Point, p2: Point): number {\n  if (p1.length !== p2.length) {\n    throw Error('Both points should have the same dimensionality');\n  }\n\n  const [x1, y1, z1 = 0] = p1;\n  const [x2, y2, z2 = 0] = p2;\n  const dx = x2 - x1;\n  const dy = y2 - y1;\n  const dz = z2 - z1;\n\n  // Time to square 10M numbers:\n  //   (n * n) = 161ms | (n ** 2) = 199ms | Math.pow(n, 2) = 29529ms\n  return dx * dx + dy * dy + dz * dz;\n}\n","import { Types } from '@cornerstonejs/core';\n\n/**\n * Get a mirrored point along the line created by two points where one of them\n * is the static (\"anchor\") point and the other one is the point to be mirroed.\n * @param mirrorPoint - 2D Point to be mirroed\n * @param staticPoint - Static 2D point\n * @returns Mirroed 2D point\n */\nexport default function mirror(\n  mirrorPoint: Types.Point2,\n  staticPoint: Types.Point2\n): Types.Point2 {\n  const [x1, y1] = mirrorPoint;\n  const [x2, y2] = staticPoint;\n\n  const newX = 2 * x2 - x1;\n  const newY = 2 * y2 - y1;\n\n  return [newX, newY];\n}\n","import { glMatrix } from 'gl-matrix';\nimport type { Types } from '@cornerstonejs/core';\nimport * as math from '..';\n\n/**\n * A polyline is considered closed if the start and end points are at the same position\n *\n * @param polyline - Polyline points (2D)\n * @returns True if the polyline is already closed or false otherwise\n */\nexport default function isClosed(polyline: Types.Point2[]): boolean {\n  if (polyline.length < 3) {\n    return false;\n  }\n\n  const numPolylinePoints = polyline.length;\n\n  const firstPoint = polyline[0];\n  const lastPoint = polyline[numPolylinePoints - 1];\n  const distFirstToLastPoints = math.point.distanceToPointSquared(\n    firstPoint,\n    lastPoint\n  );\n\n  return glMatrix.equals(0, distFirstToLastPoints);\n}\n","import type { Types } from '@cornerstonejs/core';\nimport isClosed from './isClosed';\n\n/**\n * Checks if a 2D point is inside the polyline.\n *\n * A point is inside a curve/polygon if the number of intersections between the horizontal\n * ray emanating from the given point and to the right and the line segments is odd.\n * https://www.eecs.umich.edu/courses/eecs380/HANDOUTS/PROJ2/InsidePoly.html\n *\n * Note that a point on the polyline is considered inside.\n *\n * @param polyline - Polyline points (2D)\n * @param point - 2D Point\n * @returns True if the point is inside the polyline or false otherwise\n */\nexport default function containsPoint(\n  polyline: Types.Point2[],\n  point: Types.Point2,\n  options: {\n    closed?: boolean;\n    holes?: Types.Point2[][];\n  } = {\n    closed: undefined,\n  }\n): boolean {\n  if (polyline.length < 3) {\n    return false;\n  }\n\n  const numPolylinePoints = polyline.length;\n  let numIntersections = 0;\n\n  const { closed, holes } = options;\n\n  if (holes?.length) {\n    for (const hole of holes) {\n      if (containsPoint(hole, point)) {\n        return false;\n      }\n    }\n  }\n\n  // Test intersection against [end, start] line segment if it should be closed\n  const shouldClose = !(closed === undefined ? isClosed(polyline) : closed);\n  const maxSegmentIndex = polyline.length - (shouldClose ? 1 : 2);\n\n  for (let i = 0; i <= maxSegmentIndex; i++) {\n    const p1 = polyline[i];\n\n    // Calculating the next point index without using % (mod) operator like in\n    // `(i + 1) % numPolylinePoints` to make it 20% faster\n    const p2Index = i === numPolylinePoints - 1 ? 0 : i + 1;\n    const p2 = polyline[p2Index];\n\n    // Calculating min/max without using Math.min/max to make it ~3% faster\n    const maxX = p1[0] >= p2[0] ? p1[0] : p2[0];\n    const maxY = p1[1] >= p2[1] ? p1[1] : p2[1];\n    const minY = p1[1] <= p2[1] ? p1[1] : p2[1];\n\n    const mayIntersectLineSegment =\n      point[0] <= maxX && point[1] >= minY && point[1] < maxY;\n\n    if (mayIntersectLineSegment) {\n      const isVerticalLine = p1[0] === p2[0];\n      let intersects = isVerticalLine;\n\n      if (!intersects) {\n        const xIntersection =\n          ((point[1] - p1[1]) * (p2[0] - p1[0])) / (p2[1] - p1[1]) + p1[0];\n\n        intersects = point[0] <= xIntersection;\n      }\n\n      numIntersections += intersects ? 1 : 0;\n    }\n  }\n\n  return !!(numIntersections % 2);\n}\n","import type { Types } from '@cornerstonejs/core';\nimport containsPoint from './containsPoint';\n\n/**\n * Checks if a polyline contains a set of points.\n *\n * @param polyline - Polyline points (2D)\n * @param points - 2D points to verify\n * @returns True if all points are inside the polyline or false otherwise\n */\nexport default function containsPoints(\n  polyline: Types.Point2[],\n  points: Types.Point2[]\n): boolean {\n  for (let i = 0, numPoint = points.length; i < numPoint; i++) {\n    if (!containsPoint(polyline, points[i])) {\n      return false;\n    }\n  }\n\n  return true;\n}\n","import type { Types } from '@cornerstonejs/core';\n\n/**\n * Calculates the area of an array of `Point2` points using the shoelace algorithm.\n *\n * The units of the area are in the same units as the points are in. E.g. if\n * the points are in canvas, then the result is in canvas pixels ^2; If they are\n * in mm, then the result is in mm^2; etc.\n */\nexport default function getArea(points: Types.Point2[]): number {\n  // Shoelace algorithm.\n  const n = points.length;\n  let area = 0.0;\n  let j = n - 1;\n\n  for (let i = 0; i < n; i++) {\n    area += (points[j][0] + points[i][0]) * (points[j][1] - points[i][1]);\n    j = i; // j is previous vertex to i\n  }\n\n  // Return absolute value of half the sum (half as summing up traingles).\n  return Math.abs(area / 2.0);\n}\n","import type { Types } from '@cornerstonejs/core';\n\n/**\n * Returns the area with signal of a 2D polyline\n * https://www.youtube.com/watch?v=GpsKrAipXm8&t=1900s\n *\n * This functions has a runtime very close to `getArea` and it is recommended to\n * be called only if you need the area signal (eg: calculate polygon normal). If\n * you do not need the area signal you should always call `getArea`.\n *\n *\n * @param polyline - Polyline points (2D)\n * @returns Area of the polyline (with signal)\n */\nexport default function getSignedArea(polyline: Types.Point2[]): number {\n  if (polyline.length < 3) {\n    return 0;\n  }\n\n  // Reference point can be any point on the same plane\n  const refPoint = polyline[0];\n  let area = 0;\n\n  // Takes three points (reference point and two other points from each line\n  // segment) and calculate the area with cross product. The magnitude of the\n  // vector returned by a cross product is equal to the area of the parallelogram\n  // that the vectors span which is two times the area of the triangle.\n  //\n  // Not calling vec3 mathods makes the function run much faster since polylines\n  // may have thousands of points when using freehand ROI tool and that would\n  // increase considerably the number of function calls.\n  for (let i = 0, len = polyline.length; i < len; i++) {\n    const p1 = polyline[i];\n    // Using ternary instead of % (mod) operator to make it faster\n    const p2Index = i === len - 1 ? 0 : i + 1;\n    const p2 = polyline[p2Index];\n    const aX = p1[0] - refPoint[0];\n    const aY = p1[1] - refPoint[1];\n    const bX = p2[0] - refPoint[0];\n    const bY = p2[1] - refPoint[1];\n\n    // Cross product between vectors \"a\" and \"b\" which returns (0, 0, crossProd)\n    // for 2D vectors.\n    area += aX * bY - aY * bX;\n  }\n\n  // Divide by two because cross product returns two times the area for each triangle\n  area *= 0.5;\n\n  return area;\n}\n","import type { Types } from '@cornerstonejs/core';\nimport getSignedArea from './getSignedArea';\n\n/**\n * Calculate the winding direction (CW or CCW) of a polyline\n * @param polyline - Polyline (2D)\n * @returns 1 for CW or -1 for CCW polylines\n */\nexport default function getWindingDirection(polyline: Types.Point2[]): number {\n  const signedArea = getSignedArea(polyline);\n\n  // Return 1 or -1 which is also possible to convert into ContourOrientation\n  return signedArea >= 0 ? 1 : -1;\n}\n","import { vec3 } from 'gl-matrix';\nimport { Types } from '@cornerstonejs/core';\n\nfunction _getAreaVector(polyline: Types.Point3[]): Types.Point3 {\n  const vecArea = vec3.create();\n\n  // Reference point can be any point on the same plane\n  const refPoint = polyline[0];\n\n  // Takes three points, reference point and two other points from each line\n  // segment, and calculate the area with cross product. The magnitude of the\n  // vector returned by a cross product is equal to the area of the parallelogram\n  // that the vectors span which is two times the area of the triangle.\n  //\n  // Not calling vec3 mathods makes the function run much faster since polylines\n  // may have thousands of points when using freehand ROI tool and that would\n  // increase considerably the number of function calls.\n  for (let i = 0, len = polyline.length; i < len; i++) {\n    const p1 = polyline[i];\n    // Using ternary instead of % (mod) operator to make it faster\n    const p2Index = i === len - 1 ? 0 : i + 1;\n    const p2 = polyline[p2Index];\n\n    const aX = p1[0] - refPoint[0];\n    const aY = p1[1] - refPoint[1];\n    const aZ = p1[2] - refPoint[2];\n    const bX = p2[0] - refPoint[0];\n    const bY = p2[1] - refPoint[1];\n    const bZ = p2[2] - refPoint[2];\n\n    // Cross product without calling vec3.cross() for better performance\n    vecArea[0] += aY * bZ - aZ * bY;\n    vecArea[1] += aZ * bX - aX * bZ;\n    vecArea[2] += aX * bY - aY * bX;\n  }\n\n  // Divide by two because cross product returns two times the area for each triangle\n  vec3.scale(vecArea, vecArea, 0.5);\n\n  // The magnitude of the vector is the area of the polyline\n  return <Types.Point3>vecArea;\n}\n\n/**\n * Calculate the normal of a 3D planar polyline\n * @param polyline - Planar polyline in 3D space\n * @returns Normal of the 3D planar polyline\n */\nexport default function getNormal3(polyline: Types.Point3[]): Types.Point3 {\n  const vecArea = _getAreaVector(polyline);\n\n  return vec3.normalize(vecArea, vecArea) as Types.Point3;\n}\n","import { Types } from '@cornerstonejs/core';\nimport getSignedArea from './getSignedArea';\n\n/**\n * Calculate the normal of a 2D polyline\n * https://www.youtube.com/watch?v=GpsKrAipXm8&t=1982s\n *\n * @param polyline - Planar polyline in 2D space\n * @returns Normal of the 2D planar polyline\n */\nexport default function getNormal2(polyline: Types.Point2[]): Types.Point3 {\n  const area = getSignedArea(polyline);\n\n  // The normal of a 2D polyline is (0, 0, 1) or (0, 0, -1) depending if it\n  // is CW or CCW polyline\n  return [0, 0, area / Math.abs(area)] as Types.Point3;\n}\n","import type { Types } from '@cornerstonejs/core';\n\n// ATTENTION: this is an internal function and it should not be added to \"polyline\"\n// namespace.\n//\n// TODO: there is a similar function in math.lineSegment.intersectLine but we\n// need to investigate why it is 6x slower than this one when thousands of\n// intersections are calculated. Also that one may return [NaN, NaN] for\n// collinear points.\n\n/**\n * Checks whether the line (`p1`,`q1`) intersects the line (`p2`,`q2`) via an\n * orientation algorithm.\n *\n * Credit and details: geeksforgeeks.org/check-if-two-given-line-segments-intersect/\n *\n * @param p1 - Start point of line segment 1\n * @param q1 - End point of line segment 1\n * @param p2 - Start point of line segment 2\n * @param q2 - End point of line segment 2\n * @returns True if the line segments intersect or false otherwise\n */\nexport default function areLineSegmentsIntersecting(\n  p1: Types.Point2,\n  q1: Types.Point2,\n  p2: Types.Point2,\n  q2: Types.Point2\n): boolean {\n  let result = false;\n\n  // Line 1 AABB\n  const line1MinX = p1[0] < q1[0] ? p1[0] : q1[0];\n  const line1MinY = p1[1] < q1[1] ? p1[1] : q1[1];\n  const line1MaxX = p1[0] > q1[0] ? p1[0] : q1[0];\n  const line1MaxY = p1[1] > q1[1] ? p1[1] : q1[1];\n\n  // Line 2 AABB\n  const line2MinX = p2[0] < q2[0] ? p2[0] : q2[0];\n  const line2MinY = p2[1] < q2[1] ? p2[1] : q2[1];\n  const line2MaxX = p2[0] > q2[0] ? p2[0] : q2[0];\n  const line2MaxY = p2[1] > q2[1] ? p2[1] : q2[1];\n\n  // If AABBs do not intersect it is impossible for the lines to intersect.\n  // Checking AABB before doing any math makes it run ~12% faster.\n  if (\n    line1MinX > line2MaxX ||\n    line1MaxX < line2MinX ||\n    line1MinY > line2MaxY ||\n    line1MaxY < line2MinY\n  ) {\n    return false;\n  }\n\n  const orient = [\n    orientation(p1, q1, p2),\n    orientation(p1, q1, q2),\n    orientation(p2, q2, p1),\n    orientation(p2, q2, q1),\n  ];\n\n  // General Case\n  if (orient[0] !== orient[1] && orient[2] !== orient[3]) {\n    return true;\n  }\n\n  // Special Cases\n  if (orient[0] === 0 && onSegment(p1, p2, q1)) {\n    // If p1, q1 and p2 are colinear and p2 lies on segment p1q1\n    result = true;\n  } else if (orient[1] === 0 && onSegment(p1, q2, q1)) {\n    // If p1, q1 and p2 are colinear and q2 lies on segment p1q1\n    result = true;\n  } else if (orient[2] === 0 && onSegment(p2, p1, q2)) {\n    // If p2, q2 and p1 are colinear and p1 lies on segment p2q2\n    result = true;\n  } else if (orient[3] === 0 && onSegment(p2, q1, q2)) {\n    // If p2, q2 and q1 are colinear and q1 lies on segment p2q2\n    result = true;\n  }\n\n  return result;\n}\n\n/**\n * Checks the orientation of 3 points, returns a 0, 1 or 2 based on\n * the orientation of the points.\n */\nfunction orientation(\n  p: Types.Point2,\n  q: Types.Point2,\n  r: Types.Point2\n): number {\n  // Take the cross product between vectors PQ and QR\n  const orientationValue =\n    (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1]);\n\n  if (orientationValue === 0) {\n    return 0; // Colinear\n  }\n\n  return orientationValue > 0 ? 1 : 2;\n}\n\n/**\n * Checks if point `q` lies on the segment (`p`,`r`).\n */\nfunction onSegment(p: Types.Point2, q: Types.Point2, r: Types.Point2): boolean {\n  if (\n    q[0] <= Math.max(p[0], r[0]) &&\n    q[0] >= Math.min(p[0], r[0]) &&\n    q[1] <= Math.max(p[1], r[1]) &&\n    q[1] >= Math.min(p[1], r[1])\n  ) {\n    return true;\n  }\n\n  return false;\n}\n","import type { Types } from '@cornerstonejs/core';\nimport areLineSegmentsIntersecting from './areLineSegmentsIntersecting';\n\n/**\n * Get all intersections between a polyline and a line segment.\n * @param polyline - Polyline points\n * @param p1 - Start point of line segment\n * @param q1 - End point of line segment\n * @param closed - Test the intersection against the line segment that connects\n * the last to the first point when set to true\n * @returns Start/end point indexes of all line segments that intersect (p1, q1)\n */\nexport default function getLineSegmentIntersectionsIndexes(\n  polyline: Types.Point2[],\n  p1: Types.Point2,\n  q1: Types.Point2,\n  closed = true\n): Types.Point2[] {\n  const intersections: Types.Point2[] = [];\n  const numPoints = polyline.length;\n  const maxI = numPoints - (closed ? 1 : 2);\n\n  for (let i = 0; i <= maxI; i++) {\n    const p2 = polyline[i];\n    // Do not use % operator for better performance\n    const j = i === numPoints - 1 ? 0 : i + 1;\n    const q2 = polyline[j];\n\n    if (areLineSegmentsIntersecting(p1, q1, p2, q2)) {\n      intersections.push([i, j]);\n    }\n  }\n\n  return intersections;\n}\n","import { Types } from '@cornerstonejs/core';\nimport * as mathLine from '../line';\n\n// ATTENTION: this is an internal function and it should not be added to \"polyline\" namespace\n\n// Tested with +1M random overlapping line segments and any tolerance below this\n// one may return invalid results.\nconst PARALLEL_LINES_TOLERANCE = 1e-2;\n\n/**\n * It returns the intersection between two lines (not line segments) or a midpoint\n * when the line segments overlap. This function calculates the intersection between\n * lines because it considers that getFirstLineSegmentIntersectionIndexes,\n * getLineSegmentIntersectionsCoordinates or getLineSegmentIntersectionsIndexes\n * has already been called first which guarantees.\n *\n * @param p1 - Line segment 1 start\n * @param q1 - Line segment 1 end\n * @param p2 - Line segment 2 start\n * @param q2 - Line segment 21 end\n * @returns The intersection between two lines or a midpoint when they overlap\n */\nexport default function getLinesIntersection(\n  p1: Types.Point2,\n  q1: Types.Point2,\n  p2: Types.Point2,\n  q2: Types.Point2\n) {\n  const diffQ1P1 = [q1[0] - p1[0], q1[1] - p1[1]];\n  const diffQ2P2 = [q2[0] - p2[0], q2[1] - p2[1]];\n  const denominator = diffQ2P2[1] * diffQ1P1[0] - diffQ2P2[0] * diffQ1P1[1];\n  const absDenominator = denominator >= 0 ? denominator : -denominator;\n\n  if (absDenominator < PARALLEL_LINES_TOLERANCE) {\n    // No Math.min/max calls for better performance.\n    const line1AABB = [\n      p1[0] < q1[0] ? p1[0] : q1[0], // 0: minX\n      p1[0] > q1[0] ? p1[0] : q1[0], // 1: maxX\n      p1[1] < q1[1] ? p1[1] : q1[1], // 2: minY\n      p1[1] > q1[1] ? p1[1] : q1[1], // 3: maxY\n    ];\n\n    // No Math.min/max calls for better performance.\n    const line2AABB = [\n      p2[0] < q2[0] ? p2[0] : q2[0], // 0: minX\n      p2[0] > q2[0] ? p2[0] : q2[0], // 1: maxX\n      p2[1] < q2[1] ? p2[1] : q2[1], // 2: minY\n      p2[1] > q2[1] ? p2[1] : q2[1], // 3: maxY\n    ];\n\n    const aabbIntersects =\n      line1AABB[0] <= line2AABB[1] && // minX1 <= maxX2\n      line1AABB[1] >= line2AABB[0] && // maxX1 >= minX2\n      line1AABB[2] <= line2AABB[3] && // minY1 <= maxY2\n      line1AABB[3] >= line2AABB[2]; // maxY1 >= minY2\n\n    if (!aabbIntersects) {\n      return;\n    }\n\n    // Three tests are enough to know if the lines overlap\n    const overlap =\n      mathLine.isPointOnLineSegment(p1, q1, p2) ||\n      mathLine.isPointOnLineSegment(p1, q1, q2) ||\n      mathLine.isPointOnLineSegment(p2, q2, p1);\n\n    if (!overlap) {\n      return;\n    }\n\n    // min/max seems to be inverted but that is correct because it is looking\n    // for the intersection range. No Math.min/max calls for better performance.\n    const minX = line1AABB[0] > line2AABB[0] ? line1AABB[0] : line2AABB[0];\n    const maxX = line1AABB[1] < line2AABB[1] ? line1AABB[1] : line2AABB[1];\n    const minY = line1AABB[2] > line2AABB[2] ? line1AABB[2] : line2AABB[2];\n    const maxY = line1AABB[3] < line2AABB[3] ? line1AABB[3] : line2AABB[3];\n    const midX = (minX + maxX) * 0.5;\n    const midY = (minY + maxY) * 0.5;\n\n    return [midX, midY];\n  }\n\n  let a = p1[1] - p2[1];\n  let b = p1[0] - p2[0];\n  const numerator1 = diffQ2P2[0] * a - diffQ2P2[1] * b;\n  const numerator2 = diffQ1P1[0] * a - diffQ1P1[1] * b;\n  a = numerator1 / denominator;\n  b = numerator2 / denominator;\n\n  const resultX = p1[0] + a * diffQ1P1[0];\n  const resultY = p1[1] + a * diffQ1P1[1];\n\n  return [resultX, resultY];\n}\n","import { Types } from '@cornerstonejs/core';\nimport * as mathPoint from '../point';\nimport getLineSegmentIntersectionsIndexes from './getLineSegmentIntersectionsIndexes';\nimport containsPoint from './containsPoint';\nimport getNormal2 from './getNormal2';\nimport { glMatrix, vec3 } from 'gl-matrix';\nimport getLinesIntersection from './getLinesIntersection';\n\nenum PolylinePointType {\n  Vertex,\n  Intersection,\n}\n\n// Position of the point related to the intersection region\nenum PolylinePointPosition {\n  Outside = -1,\n  Edge = 0,\n  Inside = 1,\n}\n\n// Direction from last point to the intersection point to know if it is entering\n// or exiting the intersection region\nenum PolylinePointDirection {\n  Exiting = -1,\n  Unknown = 0,\n  Entering = 1,\n}\n\ntype PolylinePoint = {\n  type: PolylinePointType;\n  coordinates: Types.Point2;\n  position?: PolylinePointPosition;\n  visited: boolean;\n  next: PolylinePoint;\n};\n\ntype PolylineIntersectionPoint = PolylinePoint & {\n  direction: PolylinePointDirection;\n  cloned?: boolean;\n};\n\n/**\n * Ensure all polyline point objects are pointing to the next object in case\n * it is still not point to anyone.\n * @param polylinePoints - Array that contains all polyline points (vertices and intersections)\n */\nfunction ensuresNextPointers(polylinePoints: PolylinePoint[]) {\n  // Make sure all nodes point to a valid node\n  for (let i = 0, len = polylinePoints.length; i < len; i++) {\n    const currentPoint = polylinePoints[i];\n\n    if (!currentPoint.next) {\n      currentPoint.next = polylinePoints[i === len - 1 ? 0 : i + 1];\n    }\n  }\n}\n\n/**\n * Creates one linked list per polyline that contains all vertices and intersections\n * found while walking along the edges.\n *\n * @param targetPolyline - Target polyline\n * @param sourcePolyline - Source polyline\n * @returns Two linked lists with all vertices and intersections.\n */\nfunction getSourceAndTargetPointsList(\n  targetPolyline: Types.Point2[],\n  sourcePolyline: Types.Point2[]\n) {\n  const targetPolylinePoints: PolylinePoint[] = [];\n  const sourcePolylinePoints: PolylinePoint[] = [];\n  const sourceIntersectionsCache = new Map<\n    number,\n    PolylineIntersectionPoint[]\n  >();\n\n  const isFirstPointInside = containsPoint(sourcePolyline, targetPolyline[0]);\n\n  let intersectionPointDirection = isFirstPointInside\n    ? PolylinePointDirection.Exiting\n    : PolylinePointDirection.Entering;\n\n  // Store all vertices and intersection for target contour\n  for (let i = 0, len = targetPolyline.length; i < len; i++) {\n    const p1 = targetPolyline[i];\n    const pointInside = containsPoint(sourcePolyline, p1);\n    const vertexPoint: PolylinePoint = {\n      type: PolylinePointType.Vertex,\n      coordinates: p1,\n      position: pointInside\n        ? PolylinePointPosition.Inside\n        : PolylinePointPosition.Outside,\n      visited: false,\n      next: null,\n    };\n\n    targetPolylinePoints.push(vertexPoint);\n\n    const q1 = targetPolyline[i === len - 1 ? 0 : i + 1];\n    const intersectionsInfo = getLineSegmentIntersectionsIndexes(\n      sourcePolyline,\n      p1,\n      q1\n    ).map((intersectedLineSegment) => {\n      const sourceLineSegmentId: number = intersectedLineSegment[0];\n      const p2 = sourcePolyline[intersectedLineSegment[0]];\n      const q2 = sourcePolyline[intersectedLineSegment[1]];\n\n      // lineSegment.intersectLine returns the midpoint of the four points\n      // when the lines are parallel or co-incident.  Otherwise it will return\n      // an extension of the line.\n      const intersectionCoordinate = getLinesIntersection(\n        p1,\n        q1,\n        p2,\n        q2\n      ) as Types.Point2;\n\n      const targetStartPointDistSquared = mathPoint.distanceToPointSquared(\n        p1,\n        intersectionCoordinate\n      );\n\n      return {\n        sourceLineSegmentId,\n        coordinate: intersectionCoordinate,\n        targetStartPointDistSquared,\n      };\n    });\n\n    intersectionsInfo.sort(\n      (left, right) =>\n        left.targetStartPointDistSquared - right.targetStartPointDistSquared\n    );\n\n    intersectionsInfo.forEach((intersectionInfo) => {\n      const { sourceLineSegmentId, coordinate: intersectionCoordinate } =\n        intersectionInfo;\n\n      // Intersection point to be added to the target polyline list\n      const targetEdgePoint: PolylineIntersectionPoint = {\n        type: PolylinePointType.Intersection,\n        coordinates: intersectionCoordinate,\n        position: PolylinePointPosition.Edge,\n        direction: intersectionPointDirection,\n        visited: false,\n        next: null,\n      };\n\n      // Intersection point to be added to the source polyline list.\n      // At this point there is no way to know if the point is entering or\n      // exiting the intersection region but that is not going to be used\n      // hence it is set to \"unknown\".\n      const sourceEdgePoint: PolylineIntersectionPoint = {\n        ...targetEdgePoint,\n        direction: PolylinePointDirection.Unknown,\n        cloned: true,\n      };\n\n      if (intersectionPointDirection === PolylinePointDirection.Entering) {\n        targetEdgePoint.next = sourceEdgePoint;\n      } else {\n        sourceEdgePoint.next = targetEdgePoint;\n      }\n\n      let sourceIntersectionPoints =\n        sourceIntersectionsCache.get(sourceLineSegmentId);\n\n      if (!sourceIntersectionPoints) {\n        sourceIntersectionPoints = [];\n        sourceIntersectionsCache.set(\n          sourceLineSegmentId,\n          sourceIntersectionPoints\n        );\n      }\n\n      targetPolylinePoints.push(targetEdgePoint);\n      sourceIntersectionPoints.push(sourceEdgePoint);\n\n      // Switches from \"exiting\" to \"entering\" and vice-versa\n      intersectionPointDirection *= -1;\n    });\n  }\n\n  // Store all vertices and intersections for source contour\n  for (let i = 0, len = sourcePolyline.length; i < len; i++) {\n    const lineSegmentId: number = i;\n    const p1 = sourcePolyline[i];\n    const vertexPoint: PolylinePoint = {\n      type: PolylinePointType.Vertex,\n      coordinates: p1,\n      visited: false,\n      next: null,\n    };\n\n    sourcePolylinePoints.push(vertexPoint);\n\n    const sourceIntersectionPoints =\n      sourceIntersectionsCache.get(lineSegmentId);\n\n    if (!sourceIntersectionPoints?.length) {\n      continue;\n    }\n\n    // Calculate the distance between each intersection point to the start point\n    // of the line segment, sort them by distance and return a sorted array that\n    // contains all intersection points.\n    sourceIntersectionPoints\n      .map((intersectionPoint) => ({\n        intersectionPoint,\n        lineSegStartDistSquared: mathPoint.distanceToPointSquared(\n          p1,\n          intersectionPoint.coordinates\n        ),\n      }))\n      .sort(\n        (left, right) =>\n          left.lineSegStartDistSquared - right.lineSegStartDistSquared\n      )\n      .map(({ intersectionPoint }) => intersectionPoint)\n      .forEach((intersectionPoint) =>\n        sourcePolylinePoints.push(intersectionPoint)\n      );\n  }\n\n  ensuresNextPointers(targetPolylinePoints);\n  ensuresNextPointers(sourcePolylinePoints);\n\n  return { targetPolylinePoints, sourcePolylinePoints };\n}\n\n/**\n * Get the next unvisited polyline points that is outside the intersection region.\n * @param polylinePoints - All polyline points (vertices and intersections)\n * @returns Any unvisited point that is outside the intersection region if it\n * exists or `undefined` otherwise\n */\nfunction getUnvisitedOutsidePoint(polylinePoints: PolylinePoint[]) {\n  for (let i = 0, len = polylinePoints.length; i < len; i++) {\n    const point = polylinePoints[i];\n\n    if (!point.visited && point.position === PolylinePointPosition.Outside) {\n      return point;\n    }\n  }\n}\n\n/**\n * Merge two planar polylines (2D)\n */\nfunction mergePolylines(\n  targetPolyline: Types.Point2[],\n  sourcePolyline: Types.Point2[]\n) {\n  const targetNormal = getNormal2(targetPolyline);\n  const sourceNormal = getNormal2(sourcePolyline);\n  const dotNormals = vec3.dot(sourceNormal, targetNormal);\n\n  // Both polylines need to be CW or CCW to be merged and one of them needs to\n  // be reversed if theirs orientation are not the same\n  if (!glMatrix.equals(1, dotNormals)) {\n    sourcePolyline = sourcePolyline.slice().reverse();\n  }\n\n  const { targetPolylinePoints } = getSourceAndTargetPointsList(\n    targetPolyline,\n    sourcePolyline\n  );\n  const startPoint: PolylinePoint =\n    getUnvisitedOutsidePoint(targetPolylinePoints);\n\n  // Source polyline contains target polyline\n  if (!startPoint) {\n    return targetPolyline.slice();\n  }\n\n  const mergedPolyline = [startPoint.coordinates];\n  let currentPoint = startPoint.next;\n\n  while (currentPoint !== startPoint) {\n    if (\n      currentPoint.type === PolylinePointType.Intersection &&\n      (<PolylineIntersectionPoint>currentPoint).cloned\n    ) {\n      currentPoint = currentPoint.next;\n      continue;\n    }\n\n    mergedPolyline.push(currentPoint.coordinates);\n    currentPoint = currentPoint.next;\n  }\n\n  return mergedPolyline;\n}\n\n/**\n * Subtract two planar polylines (2D)\n */\nfunction subtractPolylines(\n  targetPolyline: Types.Point2[],\n  sourcePolyline: Types.Point2[]\n): Types.Point2[][] {\n  const targetNormal = getNormal2(targetPolyline);\n  const sourceNormal = getNormal2(sourcePolyline);\n  const dotNormals = vec3.dot(sourceNormal, targetNormal);\n\n  // The polylines need to have different orientation (CW+CCW or CCW+CW) to be\n  // subtracted and one of them needs to be reversed if theirs orientation are\n  // the same\n  if (!glMatrix.equals(-1, dotNormals)) {\n    sourcePolyline = sourcePolyline.slice().reverse();\n  }\n\n  const { targetPolylinePoints } = getSourceAndTargetPointsList(\n    targetPolyline,\n    sourcePolyline\n  );\n  let startPoint: PolylinePoint = null;\n  const subtractedPolylines = [];\n\n  while ((startPoint = getUnvisitedOutsidePoint(targetPolylinePoints))) {\n    const subtractedPolyline = [startPoint.coordinates];\n    let currentPoint = startPoint.next;\n\n    startPoint.visited = true;\n\n    while (currentPoint !== startPoint) {\n      currentPoint.visited = true;\n\n      if (\n        currentPoint.type === PolylinePointType.Intersection &&\n        (<PolylineIntersectionPoint>currentPoint).cloned\n      ) {\n        currentPoint = currentPoint.next;\n        continue;\n      }\n\n      subtractedPolyline.push(currentPoint.coordinates);\n      currentPoint = currentPoint.next;\n    }\n\n    subtractedPolylines.push(subtractedPolyline);\n  }\n\n  return subtractedPolylines;\n}\n\nexport { mergePolylines, subtractPolylines };\n","import type { Types } from '@cornerstonejs/core';\nimport areLineSegmentsIntersecting from './areLineSegmentsIntersecting';\n\n/**\n * Checks whether the line (`p1`,`q1`) intersects any of the other lines in the\n * `points`, and returns the first value.\n *\n * @param points - Polyline points\n * @param p1 - First point of the line segment that is being tested\n * @param q1 - Second point of the line segment that is being tested\n * @param closed - Test the intersection with the line segment that connects\n *   the last and first points of the polyline\n * @returns Indexes of the line segment points from the polyline that intersects [p1, q1]\n */\nexport default function getFirstLineSegmentIntersectionIndexes(\n  points: Types.Point2[],\n  p1: Types.Point2,\n  q1: Types.Point2,\n  closed = true\n): Types.Point2 | undefined {\n  let initialI;\n  let j;\n\n  if (closed) {\n    j = points.length - 1;\n    initialI = 0;\n  } else {\n    j = 0;\n    initialI = 1;\n  }\n\n  for (let i = initialI; i < points.length; i++) {\n    const p2 = points[j];\n    const q2 = points[i];\n\n    if (areLineSegmentsIntersecting(p1, q1, p2, q2)) {\n      return [j, i];\n    }\n\n    j = i;\n  }\n}\n","import { Types } from '@cornerstonejs/core';\nimport getFirstLineSegmentIntersectionIndexes from './getFirstLineSegmentIntersectionIndexes';\n\n/**\n * Check if two polylines intersect comparing line segment by line segment.\n * @param sourcePolyline - Source polyline\n * @param targetPolyline - Target polyline\n * @returns True if the polylines intersect or false otherwise\n */\nexport default function intersectPolyline(\n  sourcePolyline: Types.Point2[],\n  targetPolyline: Types.Point2[]\n): boolean {\n  // Naive way to detect intersection between polylines in O(n^2).\n  // TODO: Implement Bentley Ottmann sweep line algorithm or maybe some\n  // algorithm that uses r-tree may make it run faster\n  for (let i = 0, sourceLen = sourcePolyline.length; i < sourceLen; i++) {\n    const sourceP1 = sourcePolyline[i];\n    const sourceP2Index = i === sourceLen - 1 ? 0 : i + 1;\n    const sourceP2 = sourcePolyline[sourceP2Index];\n\n    const intersectionPointIndexes = getFirstLineSegmentIntersectionIndexes(\n      targetPolyline,\n      sourceP1,\n      sourceP2\n    );\n\n    if (intersectionPointIndexes?.length === 2) {\n      return true;\n    }\n  }\n\n  return false;\n}\n","import type { Types } from '@cornerstonejs/core';\nimport * as mathLine from '../line';\n\nconst DEFAULT_EPSILON = 0.1;\n\n/**\n * RamerDouglasPeucker algorithm implementation to decimate a polyline\n * to a similar polyline with fewer points\n *\n * https://en.wikipedia.org/wiki/Ramer%E2%80%93Douglas%E2%80%93Peucker_algorithm\n * https://rosettacode.org/wiki/Ramer-Douglas-Peucker_line_simplification\n * https://karthaus.nl/rdp/\n *\n * @param polyline - Polyline to decimate\n * @param epsilon - A maximum given distance 'epsilon' to decide if a point\n * should or shouldn't be added the decimated polyline version. In each\n * iteration the polyline is split into two polylines and the distance of each\n * point from those new polylines are checked against the line that connects\n * the first and last points.\n * @returns Decimated polyline\n */\nexport default function decimate(\n  polyline: Types.Point2[],\n  epsilon = DEFAULT_EPSILON\n) {\n  const numPoints = polyline.length;\n\n  // The polyline must have at least a start and end points\n  if (numPoints < 3) {\n    return polyline;\n  }\n\n  const epsilonSquared = epsilon * epsilon;\n  const partitionQueue = [[0, numPoints - 1]];\n\n  // Used a boolean array to set each point that will be in the decimated polyline\n  // because pre-allocated arrays are 3-4x faster than thousands of push() calls\n  // to add all points to a new array.\n  const polylinePointFlags = new Array(numPoints).fill(false);\n\n  // Start and end points are always added to the decimated polyline\n  let numDecimatedPoints = 2;\n\n  // Add start and end points to the decimated polyline\n  polylinePointFlags[0] = true;\n  polylinePointFlags[numPoints - 1] = true;\n\n  // Iterative approach using a queue instead of recursion to reduce the number\n  // of function calls (performance)\n  while (partitionQueue.length) {\n    const [startIndex, endIndex] = partitionQueue.pop();\n\n    // Return if there is no point between the start and end points\n    if (endIndex - startIndex === 1) {\n      continue;\n    }\n\n    const startPoint = polyline[startIndex];\n    const endPoint = polyline[endIndex];\n    let maxDistSquared = -Infinity;\n    let maxDistIndex = -1;\n\n    // Search for the furthest point\n    for (let i = startIndex + 1; i < endIndex; i++) {\n      const currentPoint = polyline[i];\n      const distSquared = mathLine.distanceToPointSquared(\n        startPoint,\n        endPoint,\n        currentPoint\n      );\n\n      if (distSquared > maxDistSquared) {\n        maxDistSquared = distSquared;\n        maxDistIndex = i;\n      }\n    }\n\n    // Do not add any of the points because the fursthest one is very close to\n    // the line based on the epsilon value\n    if (maxDistSquared < epsilonSquared) {\n      continue;\n    }\n\n    // Update the flag for the furthest point because it will be added to the\n    // decimated polyline\n    polylinePointFlags[maxDistIndex] = true;\n    numDecimatedPoints++;\n\n    // Partition the points into two parts using maxDistIndex as the pivot point\n    // and process both sides\n    partitionQueue.push([maxDistIndex, endIndex]);\n    partitionQueue.push([startIndex, maxDistIndex]);\n  }\n\n  // A pre-allocated array is 3-4x faster then multiple push() calls\n  const decimatedPolyline: Types.Point2[] = new Array(numDecimatedPoints);\n\n  for (let srcIndex = 0, dstIndex = 0; srcIndex < numPoints; srcIndex++) {\n    if (polylinePointFlags[srcIndex]) {\n      decimatedPolyline[dstIndex++] = polyline[srcIndex];\n    }\n  }\n\n  return decimatedPolyline;\n}\n","import type { Types } from '@cornerstonejs/core';\nimport getLineSegmentIntersectionsIndexes from './getLineSegmentIntersectionsIndexes';\nimport getLinesIntersection from './getLinesIntersection';\n\n/**\n * Returns all intersections points between a line segment and a polyline\n */\nexport default function getLineSegmentIntersectionsCoordinates(\n  points: Types.Point2[],\n  p1: Types.Point2,\n  q1: Types.Point2,\n  closed = true\n): Types.Point2[] {\n  const result = [];\n  const polylineIndexes = getLineSegmentIntersectionsIndexes(\n    points,\n    p1,\n    q1,\n    closed\n  );\n\n  for (let i = 0; i < polylineIndexes.length; i++) {\n    const p2 = points[polylineIndexes[i][0]];\n    const q2 = points[polylineIndexes[i][1]];\n    const intersection = getLinesIntersection(p1, q1, p2, q2);\n    result.push(intersection);\n  }\n\n  return result;\n}\n","import { vec2 } from 'gl-matrix';\nimport type { Types } from '@cornerstonejs/core';\nimport areLineSegmentsIntersecting from './areLineSegmentsIntersecting';\n\n/**\n * Checks whether the line (`p1`,`q1`) intersects any of the other lines in the\n * `points`, and returns the closest value.\n * @param points - Polyline points\n * @param p1 - Start point of the line segment\n * @param q1 - End point of the line segment\n * @param closed - Test the intersection against the line that connects the first to the last when closed\n * @returns The closest line segment from polyline that intersects the line segment [p1, q1]\n */\nexport default function getClosestLineSegmentIntersection(\n  points: Types.Point2[],\n  p1: Types.Point2,\n  q1: Types.Point2,\n  closed = true\n): { segment: Types.Point2; distance: number } | undefined {\n  let initialQ2Index;\n  let p2Index;\n\n  if (closed) {\n    p2Index = points.length - 1;\n    initialQ2Index = 0;\n  } else {\n    p2Index = 0;\n    initialQ2Index = 1;\n  }\n\n  const intersections = [];\n\n  for (let q2Index = initialQ2Index; q2Index < points.length; q2Index++) {\n    const p2 = points[p2Index];\n    const q2 = points[q2Index];\n\n    if (areLineSegmentsIntersecting(p1, q1, p2, q2)) {\n      intersections.push([p2Index, q2Index]);\n    }\n\n    p2Index = q2Index;\n  }\n\n  if (intersections.length === 0) {\n    return;\n  }\n\n  // Find intersection closest to the start point\n  const distances = [];\n\n  intersections.forEach((intersection) => {\n    const intersectionPoints = [\n      points[intersection[0]],\n      points[intersection[1]],\n    ];\n\n    const midpoint = [\n      (intersectionPoints[0][0] + intersectionPoints[1][0]) / 2,\n      (intersectionPoints[0][1] + intersectionPoints[1][1]) / 2,\n    ];\n\n    distances.push(vec2.distance(<vec2>midpoint, p1));\n  });\n\n  const minDistance = Math.min(...distances);\n  const indexOfMinDistance = distances.indexOf(minDistance);\n\n  return {\n    segment: intersections[indexOfMinDistance],\n    distance: minDistance,\n  };\n}\n","import { StackViewport } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\nimport { vec3 } from 'gl-matrix';\n\nconst EPSILON = 1e-3;\n\n/**\n * Gets the desired spacing for points in the polyline for the\n * `PlanarFreehandROITool` in the x and y canvas directions, as well as\n * returning these canvas directions in world space.\n *\n * @param viewport - The Cornerstone3D `StackViewport` or `VolumeViewport`.\n * @param subPixelResolution - The number to divide the image pixel spacing by\n * to get the sub pixel spacing. E.g. `10` will return spacings 10x smaller than\n * the native image spacing.\n * @returns The spacings of the X and Y directions, and the 3D directions of the\n * x and y directions.\n */\nconst getSubPixelSpacingAndXYDirections = (\n  viewport: Types.IStackViewport | Types.IVolumeViewport,\n  subPixelResolution: number\n): { spacing: Types.Point2; xDir: Types.Point3; yDir: Types.Point3 } => {\n  let spacing;\n  let xDir;\n  let yDir;\n\n  if (viewport instanceof StackViewport) {\n    // Check XY directions\n    const imageData = viewport.getImageData();\n\n    xDir = imageData.direction.slice(0, 3);\n    yDir = imageData.direction.slice(3, 6);\n\n    spacing = imageData.spacing;\n  } else {\n    // Check volume directions\n    const imageData = viewport.getImageData();\n    const { direction, spacing: volumeSpacing } = imageData;\n    const { viewPlaneNormal, viewUp } = viewport.getCamera();\n\n    // Calculate size of spacing vector in normal direction\n    const iVector = direction.slice(0, 3) as Types.Point3;\n    const jVector = direction.slice(3, 6) as Types.Point3;\n    const kVector = direction.slice(6, 9) as Types.Point3;\n\n    const viewRight = vec3.create(); // Get the X direction of the viewport\n\n    vec3.cross(viewRight, <vec3>viewUp, <vec3>viewPlaneNormal);\n\n    const absViewRightDotI = Math.abs(vec3.dot(viewRight, iVector));\n    const absViewRightDotJ = Math.abs(vec3.dot(viewRight, jVector));\n    const absViewRightDotK = Math.abs(vec3.dot(viewRight, kVector));\n\n    // Get X spacing\n    let xSpacing;\n    if (Math.abs(1 - absViewRightDotI) < EPSILON) {\n      xSpacing = volumeSpacing[0];\n      xDir = iVector;\n    } else if (Math.abs(1 - absViewRightDotJ) < EPSILON) {\n      xSpacing = volumeSpacing[1];\n      xDir = jVector;\n    } else if (Math.abs(1 - absViewRightDotK) < EPSILON) {\n      xSpacing = volumeSpacing[2];\n      xDir = kVector;\n    } else {\n      throw new Error('No support yet for oblique plane planar contours');\n    }\n\n    const absViewUpDotI = Math.abs(vec3.dot(viewUp, iVector));\n    const absViewUpDotJ = Math.abs(vec3.dot(viewUp, jVector));\n    const absViewUpDotK = Math.abs(vec3.dot(viewUp, kVector));\n\n    // Get Y spacing\n    let ySpacing;\n    if (Math.abs(1 - absViewUpDotI) < EPSILON) {\n      ySpacing = volumeSpacing[0];\n      yDir = iVector;\n    } else if (Math.abs(1 - absViewUpDotJ) < EPSILON) {\n      ySpacing = volumeSpacing[1];\n      yDir = jVector;\n    } else if (Math.abs(1 - absViewUpDotK) < EPSILON) {\n      ySpacing = volumeSpacing[2];\n      yDir = kVector;\n    } else {\n      throw new Error('No support yet for oblique plane planar contours');\n    }\n\n    spacing = [xSpacing, ySpacing];\n  }\n\n  const subPixelSpacing: Types.Point2 = [\n    spacing[0] / subPixelResolution,\n    spacing[1] / subPixelResolution,\n  ];\n\n  return { spacing: subPixelSpacing, xDir, yDir };\n};\n\nexport default getSubPixelSpacingAndXYDirections;\n","import { vec2 } from 'gl-matrix';\nimport type { Types } from '@cornerstonejs/core';\n\n/**\n * Returns true if points `p1` and `p2` are within `closeContourProximity`.\n */\nconst pointsAreWithinCloseContourProximity = (\n  p1: Types.Point2,\n  p2: Types.Point2,\n  closeContourProximity: number\n): boolean => {\n  return vec2.dist(p1, p2) < closeContourProximity;\n};\n\nexport default pointsAreWithinCloseContourProximity;\n","import { getEnabledElement } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\nimport { vec2, vec3 } from 'gl-matrix';\nimport { PlanarFreehandROICommonData } from './planarFreehandROIInternalTypes';\n\n/**\n * Adds one or more points to the array at a resolution defined by the underlying image.\n */\nconst addCanvasPointsToArray = (\n  element: HTMLDivElement,\n  canvasPoints: Types.Point2[],\n  newCanvasPoint: Types.Point2,\n  commonData: PlanarFreehandROICommonData\n): number => {\n  const { xDir, yDir, spacing } = commonData;\n  const enabledElement = getEnabledElement(element);\n  const { viewport } = enabledElement;\n\n  if (!canvasPoints.length) {\n    canvasPoints.push(newCanvasPoint);\n    console.log('>>>>> !canvasPoints. :: RETURN');\n    return 1;\n  }\n\n  const lastWorldPos = viewport.canvasToWorld(\n    canvasPoints[canvasPoints.length - 1]\n  );\n  const newWorldPos = viewport.canvasToWorld(newCanvasPoint);\n  const worldPosDiff = vec3.create();\n\n  vec3.subtract(worldPosDiff, newWorldPos, lastWorldPos);\n\n  const xDist = Math.abs(vec3.dot(worldPosDiff, xDir));\n  const yDist = Math.abs(vec3.dot(worldPosDiff, yDir));\n\n  const numPointsToAdd = Math.max(\n    Math.floor(xDist / spacing[0]),\n    Math.floor(yDist / spacing[0])\n  );\n\n  if (numPointsToAdd > 1) {\n    const lastCanvasPoint = canvasPoints[canvasPoints.length - 1];\n\n    const canvasDist = vec2.dist(lastCanvasPoint, newCanvasPoint);\n\n    const canvasDir = vec2.create();\n\n    vec2.subtract(canvasDir, newCanvasPoint, lastCanvasPoint);\n\n    vec2.set(canvasDir, canvasDir[0] / canvasDist, canvasDir[1] / canvasDist);\n\n    const distPerPoint = canvasDist / numPointsToAdd;\n\n    for (let i = 1; i <= numPointsToAdd; i++) {\n      canvasPoints.push([\n        lastCanvasPoint[0] + distPerPoint * canvasDir[0] * i,\n        lastCanvasPoint[1] + distPerPoint * canvasDir[1] * i,\n      ]);\n    }\n  } else {\n    canvasPoints.push(newCanvasPoint);\n  }\n\n  return numPointsToAdd;\n};\n\nexport default addCanvasPointsToArray;\n","import type { Types } from '@cornerstonejs/core';\nimport { vec2 } from 'gl-matrix';\n\n/**\n * Returns `true` if the point `p` can project onto point (`p1`, `p2`), and if\n * this projected point is less than `proximity` units away.\n */\nconst pointCanProjectOnLine = (\n  p: Types.Point2,\n  p1: Types.Point2,\n  p2: Types.Point2,\n  proximity: number\n): boolean => {\n  // Perfom checks in order of computational complexity.\n  const p1p = [p[0] - p1[0], p[1] - p1[1]];\n  const p1p2 = [p2[0] - p1[0], p2[1] - p1[1]];\n\n  const dot = p1p[0] * p1p2[0] + p1p[1] * p1p2[1];\n\n  // Dot product needs to be positive to be a candidate for projection onto line segment.\n  if (dot < 0) {\n    return false;\n  }\n\n  const p1p2Mag = Math.sqrt(p1p2[0] * p1p2[0] + p1p2[1] * p1p2[1]);\n\n  if (p1p2Mag === 0) {\n    return false;\n  }\n\n  const projectionVectorMag = dot / p1p2Mag;\n  const p1p2UnitVector = [p1p2[0] / p1p2Mag, p1p2[1] / p1p2Mag];\n  const projectionVector = [\n    p1p2UnitVector[0] * projectionVectorMag,\n    p1p2UnitVector[1] * projectionVectorMag,\n  ];\n  const projectionPoint = <Types.Point2>[\n    p1[0] + projectionVector[0],\n    p1[1] + projectionVector[1],\n  ];\n\n  const distance = vec2.distance(p, projectionPoint);\n\n  if (distance > proximity) {\n    // point is too far away.\n    return false;\n  }\n\n  // Check projects onto line segment.\n  if (vec2.distance(p1, projectionPoint) > vec2.distance(p1, p2)) {\n    return false;\n  }\n\n  return true;\n};\n\nexport default pointCanProjectOnLine;\n","import { utilities } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nconst epsilon = 1e-6;\n\n/**\n * Projects a polyline from 3D to 2D by reducing one dimension.\n *\n * @param polyline - The polyline to be projected.\n * @returns An object containing the shared dimension index and the projected polyline in 2D.\n * @throws Error if a shared dimension index cannot be found for the polyline.\n */\nexport function projectTo2D(polyline: Types.Point3[]) {\n  // We need to reduce one dimension to 2D, so basically\n  // we need to find the dimension index that is shared by all points\n  // Use the first three points, two is enough but three is more robust\n  let sharedDimensionIndex;\n\n  const testPoints = utilities.getRandomSampleFromArray(polyline, 50);\n\n  for (let i = 0; i < 3; i++) {\n    if (\n      testPoints.every(\n        (point, index, array) => Math.abs(point[i] - array[0][i]) < epsilon\n      )\n    ) {\n      sharedDimensionIndex = i;\n      break;\n    }\n  }\n\n  if (sharedDimensionIndex === undefined) {\n    throw new Error(\n      'Cannot find a shared dimension index for polyline, probably oblique plane'\n    );\n  }\n\n  // convert polyline list and point to 2D\n  const points2D = [] as Types.Point2[];\n\n  const firstDim = (sharedDimensionIndex + 1) % 3;\n  const secondDim = (sharedDimensionIndex + 2) % 3;\n\n  for (let i = 0; i < polyline.length; i++) {\n    points2D.push([polyline[i][firstDim], polyline[i][secondDim]]);\n  }\n\n  return {\n    sharedDimensionIndex,\n    projectedPolyline: points2D,\n  };\n}\n","import type { Types } from '@cornerstonejs/core';\nimport containsPoint from './containsPoint';\nimport { projectTo2D } from './projectTo2D';\n\n/**\n * Determines whether a 3D point is inside a polyline in 3D space.\n *\n * The algorithm works by reducing the polyline and point to 2D space, and then\n * using the 2D algorithm to determine whether the point is inside the polyline.\n *\n * @param point - The 3D point to test.\n * @param polyline - The polyline represented as an array of 3D points.\n * @param options.holesPolyline - An array of polylines representing each hole, so it\n * is an array of arrays of 3D points.\n * @returns A boolean indicating whether the point is inside the polyline.\n * @throws An error if a shared dimension index cannot be found for the polyline points.\n */\nexport function isPointInsidePolyline3D(\n  point: Types.Point3,\n  polyline: Types.Point3[],\n  options: { holes?: Types.Point3[][] } = {}\n) {\n  const { sharedDimensionIndex, projectedPolyline } = projectTo2D(polyline);\n\n  const { holes } = options;\n  const projectedHoles = [] as Types.Point2[][];\n\n  if (holes) {\n    for (let i = 0; i < holes.length; i++) {\n      const hole = holes[i];\n      const hole2D = [] as Types.Point2[];\n\n      for (let j = 0; j < hole.length; j++) {\n        hole2D.push([\n          hole[j][(sharedDimensionIndex + 1) % 3],\n          hole[j][(sharedDimensionIndex + 2) % 3],\n        ]);\n      }\n\n      projectedHoles.push(hole2D);\n    }\n  }\n\n  const point2D = [\n    point[(sharedDimensionIndex + 1) % 3],\n    point[(sharedDimensionIndex + 2) % 3],\n  ] as Types.Point2;\n\n  return containsPoint(projectedPolyline, point2D, { holes: projectedHoles });\n}\n","import type { Types } from '@cornerstonejs/core';\nimport * as lineSegment from '../line';\n\ntype rectLineSegments = {\n  top: Types.Point2[];\n  right: Types.Point2[];\n  bottom: Types.Point2[];\n  left: Types.Point2[];\n};\n\n/**\n * Given a rectangle left, top, width and height, return an object containing the\n * line segments that make up the rectangle's four sides\n * @param left - The x-coordinate of the left edge of the rectangle.\n * @param top - The y-coordinate of the top edge of the rectangle.\n * @param width - The width of the rectangle.\n * @param height - The height of the rectangle.\n * @returns An object with four keys, each of which contains an array of two\n * points.\n */\nfunction rectToLineSegments(\n  left: number,\n  top: number,\n  width: number,\n  height: number\n): rectLineSegments {\n  const topLineStart: Types.Point2 = [left, top];\n  const topLineEnd: Types.Point2 = [left + width, top];\n\n  const rightLineStart: Types.Point2 = [left + width, top];\n  const rightLineEnd: Types.Point2 = [left + width, top + height];\n\n  const bottomLineStart: Types.Point2 = [left + width, top + height];\n  const bottomLineEnd: Types.Point2 = [left, top + height];\n\n  const leftLineStart: Types.Point2 = [left, top + height];\n  const leftLineEnd: Types.Point2 = [left, top];\n\n  const lineSegments = {\n    top: [topLineStart, topLineEnd],\n    right: [rightLineStart, rightLineEnd],\n    bottom: [bottomLineStart, bottomLineEnd],\n    left: [leftLineStart, leftLineEnd],\n  };\n\n  return lineSegments;\n}\n\n/**\n * Calculates distance of the point to the rectangle. It calculates the minimum\n * distance between the point and each line segment of the rectangle.\n *\n * @param rect - coordinates of the rectangle [left, top, width, height]\n * @param point - [x,y] coordinates of a point\n * @returns\n */\nexport default function distanceToPoint(\n  rect: number[],\n  point: Types.Point2\n): number {\n  if (rect.length !== 4 || point.length !== 2) {\n    throw Error(\n      'rectangle:[left, top, width, height] or point: [x,y] not defined correctly'\n    );\n  }\n\n  const [left, top, width, height] = rect;\n\n  let minDistance = 655535;\n  const lineSegments = rectToLineSegments(left, top, width, height);\n\n  Object.keys(lineSegments).forEach((segment) => {\n    const [lineStart, lineEnd] = lineSegments[segment];\n    const distance = lineSegment.distanceToPoint(lineStart, lineEnd, point);\n\n    if (distance < minDistance) {\n      minDistance = distance;\n    }\n  });\n\n  return minDistance;\n}\n","import type { Types } from '@cornerstonejs/core';\nimport { vec3 } from 'gl-matrix';\n\ntype Sphere = {\n  center: Types.Point3 | vec3;\n  radius: number;\n  // Square of the radius\n  radius2?: number;\n};\n\n/**\n * Checks if a point is inside a sphere. Note: this is similar to the\n * `pointInEllipse` function, but since we don't need checks for the\n * ellipse's rotation in different views, we can use a simpler equation\n * which would be faster (no if statements).\n *\n * This is safe to call for point in circle as long as you don't call it with\n * anything off-plane - that is, a circle is a degenerate sphere that is\n * intersected with the primary plane.\n *\n * @param sphere - Sphere object with center and radius and radius squared\n *     as radius2 if you are calling this a huge number of times.\n * @param pointLPS - the point to check in world coordinates\n * @returns boolean\n */\nexport default function pointInSphere(sphere: Sphere, pointLPS: vec3): boolean {\n  const { center, radius } = sphere;\n  const radius2 = sphere.radius2 || radius * radius;\n\n  return (\n    (pointLPS[0] - center[0]) * (pointLPS[0] - center[0]) +\n      (pointLPS[1] - center[1]) * (pointLPS[1] - center[1]) +\n      (pointLPS[2] - center[2]) * (pointLPS[2] - center[2]) <=\n    radius2\n  );\n}\n","// Pulled from source: https://github.com/w8r/liang-barsky\n// MIT Licensed.\n\n/**\n * Fast, destructive implementation of Liang-Barsky line clipping algorithm.\n * It clips a 2D segment by a rectangle.\n * @author Alexander Milevski <info@w8r.name>\n * @license MIT\n */\n\nconst EPSILON = 1e-6;\nconst INSIDE = 1;\nconst OUTSIDE = 0;\n\nfunction clipT(num, denom, c) {\n  const [tE, tL] = c;\n  if (Math.abs(denom) < EPSILON) {\n    return num < 0;\n  }\n  const t = num / denom;\n\n  if (denom > 0) {\n    if (t > tL) {\n      return 0;\n    }\n    if (t > tE) {\n      c[0] = t;\n    }\n  } else {\n    if (t < tE) {\n      return 0;\n    }\n    if (t < tL) {\n      c[1] = t;\n    }\n  }\n  return 1;\n}\n\n/**\n * @param  {Point} a\n * @param  {Point} b\n * @param  {BoundingBox} box [xmin, ymin, xmax, ymax]\n * @param  {Point?} [da]\n * @param  {Point?} [db]\n * @return {number}\n */\nexport default function clip(a, b, box, da?, db?) {\n  const [x1, y1] = a;\n  const [x2, y2] = b;\n  const dx = x2 - x1;\n  const dy = y2 - y1;\n\n  if (da === undefined || db === undefined) {\n    da = a;\n    db = b;\n  } else {\n    da[0] = a[0];\n    da[1] = a[1];\n    db[0] = b[0];\n    db[1] = b[1];\n  }\n\n  if (\n    Math.abs(dx) < EPSILON &&\n    Math.abs(dy) < EPSILON &&\n    x1 >= box[0] &&\n    x1 <= box[2] &&\n    y1 >= box[1] &&\n    y1 <= box[3]\n  ) {\n    return INSIDE;\n  }\n\n  const c = [0, 1];\n  if (\n    clipT(box[0] - x1, dx, c) &&\n    clipT(x1 - box[2], -dx, c) &&\n    clipT(box[1] - y1, dy, c) &&\n    clipT(y1 - box[3], -dy, c)\n  ) {\n    const [tE, tL] = c;\n    if (tL < 1) {\n      db[0] = x1 + tL * dx;\n      db[1] = y1 + tL * dy;\n    }\n    if (tE > 0) {\n      da[0] += tE * dx;\n      da[1] += tE * dy;\n    }\n    return INSIDE;\n  }\n  return OUTSIDE;\n}\n","import { Types } from '@cornerstonejs/core';\n\n/**\n * Returns the orientation of the vector in the patient coordinate system.\n * @public\n *\n * @param vector - Input array\n * @returns The orientation in the patient coordinate system.\n */\nexport default function getOrientationStringLPS(vector: Types.Point3): string {\n  // Thanks to David Clunie\n  // https://sites.google.com/site/dicomnotes/\n\n  let orientation = '';\n  const orientationX = vector[0] < 0 ? 'R' : 'L';\n  const orientationY = vector[1] < 0 ? 'A' : 'P';\n  const orientationZ = vector[2] < 0 ? 'F' : 'H';\n\n  // Should probably make this a function vector3.abs\n  const abs = [Math.abs(vector[0]), Math.abs(vector[1]), Math.abs(vector[2])];\n\n  const MIN = 0.0001;\n\n  for (let i = 0; i < 3; i++) {\n    if (abs[0] > MIN && abs[0] > abs[1] && abs[0] > abs[2]) {\n      orientation += orientationX;\n      abs[0] = 0;\n    } else if (abs[1] > MIN && abs[1] > abs[0] && abs[1] > abs[2]) {\n      orientation += orientationY;\n      abs[1] = 0;\n    } else if (abs[2] > MIN && abs[2] > abs[0] && abs[2] > abs[1]) {\n      orientation += orientationZ;\n      abs[2] = 0;\n    } else if (abs[0] > MIN && abs[1] > MIN && abs[0] === abs[1]) {\n      orientation += orientationX + orientationY;\n      abs[0] = 0;\n      abs[1] = 0;\n    } else if (abs[0] > MIN && abs[2] > MIN && abs[0] === abs[2]) {\n      orientation += orientationX + orientationZ;\n      abs[0] = 0;\n      abs[2] = 0;\n    } else if (abs[1] > MIN && abs[2] > MIN && abs[1] === abs[2]) {\n      orientation += orientationY + orientationZ;\n      abs[1] = 0;\n      abs[2] = 0;\n    } else {\n      break;\n    }\n  }\n\n  return orientation;\n}\n","/**\n * Inverts an orientation string.\n * @public\n *\n * @param orientationString - The orientation.\n * @returns The inverted orientationString.\n */\nexport default function invertOrientationStringLPS(\n  orientationString: string\n): string {\n  let inverted = orientationString.replace('H', 'f');\n\n  inverted = inverted.replace('F', 'h');\n  inverted = inverted.replace('R', 'l');\n  inverted = inverted.replace('L', 'r');\n  inverted = inverted.replace('A', 'p');\n  inverted = inverted.replace('P', 'a');\n  inverted = inverted.toUpperCase();\n\n  return inverted;\n}\n","import filterAnnotationsWithinSlice from './filterAnnotationsWithinSlice';\nimport getWorldWidthAndHeightFromCorners from './getWorldWidthAndHeightFromCorners';\nimport filterAnnotationsForDisplay from './filterAnnotationsForDisplay';\nimport getPointInLineOfSightWithCriteria from './getPointInLineOfSightWithCriteria';\nimport { isPlaneIntersectingAABB } from './isPlaneIntersectingAABB';\n\nexport default {\n  filterAnnotationsWithinSlice,\n  getWorldWidthAndHeightFromCorners,\n  filterAnnotationsForDisplay,\n  getPointInLineOfSightWithCriteria,\n  isPlaneIntersectingAABB,\n};\n\nexport {\n  filterAnnotationsWithinSlice,\n  getWorldWidthAndHeightFromCorners,\n  filterAnnotationsForDisplay,\n  getPointInLineOfSightWithCriteria,\n  isPlaneIntersectingAABB,\n};\n","import smoothAnnotation from './smoothAnnotation';\n\nexport default {\n  smoothAnnotation,\n};\n\nexport { smoothAnnotation };\n","import { vec3 } from 'gl-matrix';\nimport type { Types } from '@cornerstonejs/core';\nimport type { vtkImageData } from '@kitware/vtk.js/Common/DataModel/ImageData';\nimport BoundsIJK from '../types/BoundsIJK';\n\nexport type PointInShape = {\n  value: number;\n  index: number;\n  pointIJK: vec3;\n  pointLPS: vec3 | number[];\n};\n\nexport type PointInShapeCallback = ({\n  value,\n  index,\n  pointIJK,\n  pointLPS,\n}: {\n  value: number;\n  index: number;\n  pointIJK: vec3;\n  pointLPS: vec3;\n}) => void;\n\nexport type ShapeFnCriteria = (pointLPS: vec3, pointIJK: vec3) => boolean;\n\n/**\n * For each point in the image (If boundsIJK is not provided, otherwise, for each\n * point in the provided bounding box), It runs the provided callback IF the point\n * passes the provided criteria to be inside the shape (which is defined by the\n * provided pointInShapeFn)\n *\n * @param imageData - The image data object.\n * @param dimensions - The dimensions of the image.\n * @param pointInShapeFn - A function that takes a point in LPS space and returns\n * true if the point is in the shape and false if it is not.\n * @param callback - A function that will be called for\n * every point in the shape.\n * @param boundsIJK - The bounds of the volume in IJK coordinates.\n */\nexport default function pointInShapeCallback(\n  imageData: vtkImageData | Types.CPUImageData,\n  pointInShapeFn: ShapeFnCriteria,\n  callback?: PointInShapeCallback,\n  boundsIJK?: BoundsIJK\n): Array<PointInShape> {\n  let iMin, iMax, jMin, jMax, kMin, kMax;\n\n  let scalarData;\n  const { numComps } = imageData as any;\n\n  // if getScalarData is a method on imageData\n  if ((imageData as Types.CPUImageData).getScalarData) {\n    scalarData = (imageData as Types.CPUImageData).getScalarData();\n  } else {\n    scalarData = (imageData as vtkImageData)\n      .getPointData()\n      .getScalars()\n      .getData();\n  }\n\n  const dimensions = imageData.getDimensions();\n\n  if (!boundsIJK) {\n    iMin = 0;\n    iMax = dimensions[0];\n    jMin = 0;\n    jMax = dimensions[1];\n    kMin = 0;\n    kMax = dimensions[2];\n  } else {\n    [[iMin, iMax], [jMin, jMax], [kMin, kMax]] = boundsIJK;\n  }\n\n  const start = vec3.fromValues(iMin, jMin, kMin);\n\n  const direction = imageData.getDirection();\n  const rowCosines = direction.slice(0, 3);\n  const columnCosines = direction.slice(3, 6);\n  const scanAxisNormal = direction.slice(6, 9);\n\n  const spacing = imageData.getSpacing();\n  const [rowSpacing, columnSpacing, scanAxisSpacing] = spacing;\n\n  // @ts-ignore will be fixed in vtk-master\n  const worldPosStart = imageData.indexToWorld(start);\n\n  const rowStep = vec3.fromValues(\n    rowCosines[0] * rowSpacing,\n    rowCosines[1] * rowSpacing,\n    rowCosines[2] * rowSpacing\n  );\n\n  const columnStep = vec3.fromValues(\n    columnCosines[0] * columnSpacing,\n    columnCosines[1] * columnSpacing,\n    columnCosines[2] * columnSpacing\n  );\n\n  const scanAxisStep = vec3.fromValues(\n    scanAxisNormal[0] * scanAxisSpacing,\n    scanAxisNormal[1] * scanAxisSpacing,\n    scanAxisNormal[2] * scanAxisSpacing\n  );\n\n  const xMultiple =\n    numComps ||\n    scalarData.length / dimensions[2] / dimensions[1] / dimensions[0];\n  const yMultiple = dimensions[0] * xMultiple;\n  const zMultiple = dimensions[1] * yMultiple;\n\n  const pointsInShape: Array<PointInShape> = [];\n\n  const currentPos = vec3.clone(worldPosStart);\n\n  for (let k = kMin; k <= kMax; k++) {\n    const startPosJ = vec3.clone(currentPos);\n\n    for (let j = jMin; j <= jMax; j++) {\n      const startPosI = vec3.clone(currentPos);\n\n      for (let i = iMin; i <= iMax; i++) {\n        const pointIJK: Types.Point3 = [i, j, k];\n\n        // The current world position (pointLPS) is now in currentPos\n        if (pointInShapeFn(currentPos as Types.Point3, pointIJK)) {\n          const index = k * zMultiple + j * yMultiple + i * xMultiple;\n          let value;\n          if (xMultiple > 2) {\n            value = [\n              scalarData[index],\n              scalarData[index + 1],\n              scalarData[index + 2],\n            ];\n          } else {\n            value = scalarData[index];\n          }\n\n          pointsInShape.push({\n            value,\n            index,\n            pointIJK,\n            pointLPS: currentPos.slice(),\n          });\n          if (callback) {\n            callback({ value, index, pointIJK, pointLPS: currentPos });\n          }\n        }\n\n        // Increment currentPos by rowStep for the next iteration\n        vec3.add(currentPos, currentPos, rowStep);\n      }\n\n      // Reset currentPos to the start of the next J line and increment by columnStep\n      vec3.copy(currentPos, startPosI);\n      vec3.add(currentPos, currentPos, columnStep);\n    }\n\n    // Reset currentPos to the start of the next K slice and increment by scanAxisStep\n    vec3.copy(currentPos, startPosJ);\n    vec3.add(currentPos, currentPos, scanAxisStep);\n  }\n\n  return pointsInShape;\n}\n","import { utilities as csUtils } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport type { vtkImageData } from '@kitware/vtk.js/Common/DataModel/ImageData';\nimport { vec3 } from 'gl-matrix';\nimport { pointInSphere } from './math/sphere';\nimport pointInShapeCallback, {\n  PointInShapeCallback,\n} from './pointInShapeCallback';\nimport { BoundsIJK } from '../types';\nimport { getBoundingBoxAroundShape } from './boundingBox';\n\nconst { transformWorldToIndex } = csUtils;\n\n/**\n * Given an imageData, and the great circle top and bottom points of a sphere,\n * this function will run the callback for each point of the imageData that is\n * within the sphere defined by the great circle points. If the viewport\n * is provided, region of interest will be an accurate approximation of the\n * sphere (using viewport camera), and the resulting performance will be\n * better.\n *\n * @privateRemarks great circle also known as orthodrome is the intersection of\n * the sphere and the plane that passes through the center of the sphere\n *\n * @param imageData - The volume imageData\n * @param circlePoints - bottom and top points of the great circle in world coordinates\n * @param callback - A callback function that will be called for each point in the shape.\n */\nexport default function pointInSurroundingSphereCallback(\n  imageData: vtkImageData,\n  circlePoints: [Types.Point3, Types.Point3],\n  callback: PointInShapeCallback,\n  viewport?: Types.IVolumeViewport\n): void {\n  // We can run the sphere equation to determine if a point is inside\n  // the sphere; however, since the imageData dimensions can be quite large, we\n  // can narrow down the search by estimating the bounds of the sphere in index\n  // space.\n  const { boundsIJK, centerWorld, radiusWorld } = _getBounds(\n    circlePoints,\n    imageData,\n    viewport\n  );\n\n  const sphereObj = {\n    center: centerWorld,\n    radius: radiusWorld,\n  };\n\n  pointInShapeCallback(\n    imageData,\n    (pointLPS) => pointInSphere(sphereObj, pointLPS),\n    callback,\n    boundsIJK\n  );\n}\n\nfunction _getBounds(\n  circlePoints: [Types.Point3, Types.Point3],\n  imageData: vtkImageData,\n  viewport\n): {\n  boundsIJK: BoundsIJK;\n  centerWorld: Types.Point3;\n  radiusWorld: number;\n} {\n  const [bottom, top] = circlePoints;\n\n  // Sphere center in world\n  const centerWorld = vec3.fromValues(\n    (bottom[0] + top[0]) / 2,\n    (bottom[1] + top[1]) / 2,\n    (bottom[2] + top[2]) / 2\n  );\n\n  // sphere radius in world\n  const radiusWorld = vec3.distance(bottom, top) / 2;\n\n  let boundsIJK;\n\n  if (!viewport) {\n    // If no viewport is provide (no camera), we can estimate the bounding box\n    // of the sphere in index space.\n    // This is done by calculating the maximum value for radius in the index\n    // space (since the radius is in world space, we need to convert it to index, and\n    // each dimensions can have a different scale factor). Therefore, by finding\n    // the minimum spacing value in the imageData, we can calculate the maximum\n    // radius in index space and use that to calculate the bounds of the sphere\n    // This will not be accurate, but it is a good first approximation.\n    // sphere center in index\n    const centerIJK = transformWorldToIndex(\n      imageData,\n      centerWorld as Types.Point3\n    );\n\n    const spacings = imageData.getSpacing();\n    const minSpacing = Math.min(...spacings);\n\n    const maxRadiusIJK = Math.ceil(radiusWorld / minSpacing);\n\n    boundsIJK = [\n      [centerIJK[0] - maxRadiusIJK, centerIJK[0] + maxRadiusIJK],\n      [centerIJK[1] - maxRadiusIJK, centerIJK[1] + maxRadiusIJK],\n      [centerIJK[2] - maxRadiusIJK, centerIJK[2] + maxRadiusIJK],\n    ];\n\n    return {\n      boundsIJK,\n      centerWorld: centerWorld as Types.Point3,\n      radiusWorld,\n    };\n  }\n\n  boundsIJK = _computeBoundsIJKWithCamera(\n    imageData,\n    viewport,\n    circlePoints,\n    centerWorld,\n    radiusWorld\n  );\n\n  return {\n    boundsIJK,\n    centerWorld: centerWorld as Types.Point3,\n    radiusWorld,\n  };\n}\n\nfunction _computeBoundsIJKWithCamera(\n  imageData,\n  viewport,\n  circlePoints,\n  centerWorld,\n  radiusWorld\n) {\n  const [bottom, top] = circlePoints;\n\n  const dimensions = imageData.getDimensions() as Types.Point3;\n  const camera = viewport.getCamera();\n\n  // Calculate viewRight from the camera, this will get used in order to\n  // calculate circles topLeft and bottomRight on different planes of intersection\n  // between sphere and viewPlane\n  const viewUp = vec3.fromValues(\n    camera.viewUp[0],\n    camera.viewUp[1],\n    camera.viewUp[2]\n  );\n  const viewPlaneNormal = vec3.fromValues(\n    camera.viewPlaneNormal[0],\n    camera.viewPlaneNormal[1],\n    camera.viewPlaneNormal[2]\n  );\n  const viewRight = vec3.create();\n\n  vec3.cross(viewRight, viewUp, viewPlaneNormal);\n\n  // we need to find the bounding box of the sphere in the image, e.g., the\n  // topLeftWorld and bottomRightWorld points of the bounding box.\n  // We go from the sphereCenter in the normal direction of amount radius, and\n  // we go left to find the topLeftWorld point of the bounding box. Next we go\n  // in the opposite direction and go right to find the bottomRightWorld point\n  // of the bounding box.\n  const topLeftWorld = vec3.create();\n  const bottomRightWorld = vec3.create();\n\n  vec3.scaleAndAdd(topLeftWorld, top, viewPlaneNormal, radiusWorld);\n  vec3.scaleAndAdd(bottomRightWorld, bottom, viewPlaneNormal, -radiusWorld);\n\n  // go in the direction of viewRight with the value of radius\n  vec3.scaleAndAdd(topLeftWorld, topLeftWorld, viewRight, -radiusWorld);\n  vec3.scaleAndAdd(bottomRightWorld, bottomRightWorld, viewRight, radiusWorld);\n\n  // convert the world coordinates to index coordinates\n\n  const sphereCornersIJK = [\n    <Types.Point3>transformWorldToIndex(imageData, <Types.Point3>topLeftWorld),\n    <Types.Point3>(\n      transformWorldToIndex(imageData, <Types.Point3>bottomRightWorld)\n    ),\n  ];\n\n  // get the bounding box of the sphere in the image\n  const boundsIJK = getBoundingBoxAroundShape(sphereCornersIJK, dimensions);\n\n  return boundsIJK;\n}\n","export function pointToString(point, decimals = 5) {\n  return (\n    parseFloat(point[0]).toFixed(decimals) +\n    ',' +\n    parseFloat(point[1]).toFixed(decimals) +\n    ',' +\n    parseFloat(point[2]).toFixed(decimals) +\n    ','\n  );\n}\n","import vtkPolyData from '@kitware/vtk.js/Common/DataModel/PolyData';\nimport type { Types } from '@cornerstonejs/core';\nimport { vec3 } from 'gl-matrix';\n\n/**\n * Gets a point from an array of numbers given its index\n * @param points - array of number, each point defined by three consecutive numbers\n * @param idx - index of the point to retrieve\n * @returns\n */\nexport function getPoint(points, idx): Types.Point3 {\n  const idx3 = idx * 3;\n  if (idx3 < points.length) {\n    return vec3.fromValues(\n      points[idx3],\n      points[idx3 + 1],\n      points[idx3 + 2]\n    ) as Types.Point3;\n  }\n}\n\n/**\n * Extract contour point sets from the outline of a poly data actor\n * @param polyData - vtk polyData\n * @returns\n */\nexport function getPolyDataPointIndexes(polyData: vtkPolyData) {\n  const linesData = polyData.getLines().getData();\n  let idx = 0;\n  const lineSegments = new Map<number, number[]>();\n\n  // Populate lineSegments map\n  while (idx < linesData.length) {\n    const segmentSize = linesData[idx++];\n    const segment = [];\n    for (let i = 0; i < segmentSize; i++) {\n      segment.push(linesData[idx + i]);\n    }\n    lineSegments.set(segment[0], segment);\n    idx += segmentSize;\n  }\n\n  const contours = [];\n\n  // Function to find an available starting point\n  const findStartingPoint = (map) => {\n    for (const [key, value] of map.entries()) {\n      if (value !== undefined) {\n        return key;\n      }\n    }\n    return -1;\n  };\n\n  // Build contours\n  let startPoint = findStartingPoint(lineSegments);\n  while (startPoint !== -1) {\n    const contour = [startPoint];\n    while (lineSegments.has(startPoint)) {\n      const nextPoint = lineSegments.get(startPoint)[1];\n      if (lineSegments.has(nextPoint)) {\n        contour.push(nextPoint);\n      }\n      lineSegments.delete(startPoint);\n      startPoint = nextPoint;\n    }\n    contours.push(contour);\n    startPoint = findStartingPoint(lineSegments);\n  }\n\n  return contours.length ? contours : undefined;\n}\n\n/**\n * Extract contour points from a poly data object\n * @param polyData - vtk polyData\n * @returns\n */\nexport function getPolyDataPoints(polyData: vtkPolyData) {\n  const contoursIndexes = getPolyDataPointIndexes(polyData);\n  if (!contoursIndexes) {\n    return;\n  }\n\n  const rawPointsData = polyData.getPoints().getData();\n  return contoursIndexes.map((contourIndexes) =>\n    contourIndexes.map((index) => getPoint(rawPointsData, index))\n  );\n}\n","import { utilities as csUtils } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\nimport { getBoundingBoxAroundShapeIJK } from '../boundingBox/getBoundingBoxAroundShape';\nimport extend2DBoundingBoxInViewAxis from '../boundingBox/extend2DBoundingBoxInViewAxis';\n\ntype Options = {\n  numSlicesToProject?: number;\n};\n\nfunction getBoundsIJKFromRectangleAnnotations(\n  annotations,\n  referenceVolume,\n  options = {} as Options\n) {\n  const AllBoundsIJK = [];\n  annotations.forEach((annotation) => {\n    const { data } = annotation;\n    const { points } = data.handles;\n\n    const { imageData, dimensions } = referenceVolume;\n\n    let pointsToUse = points;\n    // If the tool is a 2D tool but has projection points, use them\n    if (data.cachedStats?.projectionPoints) {\n      const { projectionPoints } = data.cachedStats;\n      pointsToUse = [].concat(...projectionPoints); // cannot use flat() because of typescript compiler right now\n    }\n\n    const rectangleCornersIJK = pointsToUse.map(\n      (world) => csUtils.transformWorldToIndex(imageData, world) as Types.Point3\n    );\n    let boundsIJK = getBoundingBoxAroundShapeIJK(\n      rectangleCornersIJK,\n      dimensions\n    );\n\n    // If the tool is 2D but it is configured to project to X amount of slices\n    // Don't project the slices if projectionPoints have been used to define the extents\n    if (options.numSlicesToProject && !data.cachedStats?.projectionPoints) {\n      boundsIJK = extend2DBoundingBoxInViewAxis(\n        boundsIJK,\n        options.numSlicesToProject\n      );\n    }\n\n    AllBoundsIJK.push(boundsIJK);\n  });\n\n  if (AllBoundsIJK.length === 1) {\n    return AllBoundsIJK[0];\n  }\n\n  // Get the intersection of all the bounding boxes\n  // This is the bounding box that contains all the ROIs\n  const boundsIJK = AllBoundsIJK.reduce(\n    (accumulator, currentValue) => {\n      return {\n        iMin: Math.min(accumulator.iMin, currentValue.iMin),\n        jMin: Math.min(accumulator.jMin, currentValue.jMin),\n        kMin: Math.min(accumulator.kMin, currentValue.kMin),\n        iMax: Math.max(accumulator.iMax, currentValue.iMax),\n        jMax: Math.max(accumulator.jMax, currentValue.jMax),\n        kMax: Math.max(accumulator.kMax, currentValue.kMax),\n      };\n    },\n    {\n      iMin: Infinity,\n      jMin: Infinity,\n      kMin: Infinity,\n      iMax: -Infinity,\n      jMax: -Infinity,\n      kMax: -Infinity,\n    }\n  );\n\n  return boundsIJK;\n}\n\nexport default getBoundsIJKFromRectangleAnnotations;\n","import { vec3 } from 'gl-matrix';\nimport { utilities as csUtils } from '@cornerstonejs/core';\n\nconst { isEqual } = csUtils;\n\nconst iAxis = vec3.fromValues(1, 0, 0);\nconst jAxis = vec3.fromValues(0, 1, 0);\nconst kAxis = vec3.fromValues(0, 0, 1);\n\nconst axisList = [iAxis, jAxis, kAxis];\n\n/**\n * Determines whether a given rectangle in a 3D space (defined by its corner\n * points in IJK coordinates) is aligned with the IJK axes.\n * @param rectangleCornersIJK - The corner points of the rectangle in IJK coordinates\n * @returns True if the rectangle is aligned with the IJK axes, false otherwise\n */\nfunction isAxisAlignedRectangle(rectangleCornersIJK) {\n  const rectangleVec1 = vec3.subtract(\n    vec3.create(),\n    rectangleCornersIJK[0],\n    rectangleCornersIJK[1]\n  );\n\n  const rectangleVec2 = vec3.subtract(\n    vec3.create(),\n    rectangleCornersIJK[0],\n    rectangleCornersIJK[2]\n  );\n\n  // Calculate the angles with IJK axes for both vectors\n  const anglesVec1 = calculateAnglesWithAxes(rectangleVec1, axisList);\n  const anglesVec2 = calculateAnglesWithAxes(rectangleVec2, axisList);\n\n  // Check if all angles are aligned (0, 90, 180, or 270 degrees)\n  // we could do csUtils.isEqual(angle % 90, 0) but this is more explicit for reading\n  const isAligned = [...anglesVec1, ...anglesVec2].every(\n    (angle) =>\n      isEqual(angle, 0) ||\n      isEqual(angle, 90) ||\n      isEqual(angle, 180) ||\n      isEqual(angle, 270)\n  );\n\n  return isAligned;\n}\n\n// Function to calculate angle with IJK axes\nfunction calculateAnglesWithAxes(vec, axes) {\n  return axes.map((axis) => (vec3.angle(vec, axis) * 180) / Math.PI);\n}\n\nexport { isAxisAlignedRectangle };\n","import {\n  StackViewport,\n  Types,\n  VolumeViewport,\n  eventTarget,\n  EVENTS,\n  utilities as csUtils,\n  getEnabledElement,\n  VideoViewport,\n} from '@cornerstonejs/core';\nimport { ScrollOptions, EventTypes } from '../types';\n\n/**\n * It scrolls one slice in the Stack or Volume Viewport, it uses the options provided\n * to determine the slice to scroll to. For Stack Viewport, it scrolls in the 1 or -1\n * direction, for Volume Viewport, it uses the camera and focal point to determine the\n * slice to scroll to based on the spacings.\n * @param viewport - The viewport in which to scroll\n * @param options - Options to use for scrolling, including direction, invert, and volumeId\n * @returns\n */\nexport default function scroll(\n  viewport: Types.IViewport,\n  options: ScrollOptions\n): void {\n  // check if viewport is disabled then throw error\n  const enabledElement = getEnabledElement(viewport.element);\n\n  if (!enabledElement) {\n    throw new Error('Scroll::Viewport is not enabled (it might be disabled)');\n  }\n\n  if (\n    viewport instanceof StackViewport &&\n    viewport.getImageIds().length === 0\n  ) {\n    throw new Error('Scroll::Stack Viewport has no images');\n  }\n\n  const { type: viewportType } = viewport;\n  const { volumeId, delta, scrollSlabs } = options;\n\n  if (viewport instanceof StackViewport) {\n    viewport.scroll(delta, options.debounceLoading, options.loop);\n  } else if (viewport instanceof VolumeViewport) {\n    scrollVolume(viewport, volumeId, delta, scrollSlabs);\n  } else if (viewport instanceof VideoViewport) {\n    viewport.scroll(delta);\n  } else {\n    throw new Error(`Not implemented for Viewport Type: ${viewportType}`);\n  }\n}\n\nexport function scrollVolume(\n  viewport: VolumeViewport,\n  volumeId: string,\n  delta: number,\n  scrollSlabs = false\n) {\n  const useSlabThickness = scrollSlabs;\n\n  const { numScrollSteps, currentStepIndex, sliceRangeInfo } =\n    csUtils.getVolumeViewportScrollInfo(viewport, volumeId, useSlabThickness);\n\n  if (!sliceRangeInfo) {\n    return;\n  }\n\n  const { sliceRange, spacingInNormalDirection, camera } = sliceRangeInfo;\n  const { focalPoint, viewPlaneNormal, position } = camera;\n\n  const { newFocalPoint, newPosition } = csUtils.snapFocalPointToSlice(\n    focalPoint,\n    position,\n    sliceRange,\n    viewPlaneNormal,\n    spacingInNormalDirection,\n    delta\n  );\n\n  viewport.setCamera({\n    focalPoint: newFocalPoint,\n    position: newPosition,\n  });\n  viewport.render();\n\n  const desiredStepIndex = currentStepIndex + delta;\n\n  const VolumeScrollEventDetail: EventTypes.VolumeScrollOutOfBoundsEventDetail =\n    {\n      volumeId,\n      viewport,\n      delta,\n      desiredStepIndex,\n      currentStepIndex,\n      numScrollSteps,\n      currentImageId: viewport.getCurrentImageId(),\n    };\n\n  if (\n    (desiredStepIndex > numScrollSteps || desiredStepIndex < 0) &&\n    viewport.getCurrentImageId() // Check that we are in the plane of acquistion\n  ) {\n    // One common use case of this trigger might be to load the next\n    // volume in a time series or the next segment of a partially loaded volume.\n\n    csUtils.triggerEvent(\n      eventTarget,\n      EVENTS.VOLUME_SCROLL_OUT_OF_BOUNDS,\n      VolumeScrollEventDetail\n    );\n  } else {\n    csUtils.triggerEvent(\n      eventTarget,\n      EVENTS.VOLUME_VIEWPORT_SCROLL,\n      VolumeScrollEventDetail\n    );\n  }\n}\n","import { utilities as csUtils } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\nimport {\n  AnnotationCompletedEventType,\n  AnnotationModifiedEventType,\n  AnnotationRemovedEventType,\n} from '../../../types/EventTypes';\nimport { state as annotationState } from '../../../stateManagement/annotation';\nimport type AnnotationGroupSelector from '../../../types/AnnotationGroupSelector';\nimport getInterpolationDataCollection from '../../contours/interpolation/getInterpolationDataCollection';\nimport type {\n  InterpolationViewportData,\n  AcceptInterpolationSelector,\n} from '../../../types/InterpolationTypes';\nimport interpolate from '../../contours/interpolation/interpolate';\nimport deleteRelatedAnnotations from './deleteRelatedAnnotations';\nimport { InterpolationROIAnnotation } from '../../../types/ToolSpecificAnnotationTypes';\nimport ChangeTypes from '../../../enums/ChangeTypes';\nimport getViewportForAnnotation from '../../getViewportForAnnotation';\nimport { addContourSegmentationAnnotation } from '../../contourSegmentation/addContourSegmentationAnnotation';\n\nconst { uuidv4 } = csUtils;\n\nconst ChangeTypesForInterpolation = [\n  ChangeTypes.HandlesUpdated,\n  ChangeTypes.InterpolationUpdated,\n];\n\nexport default class InterpolationManager {\n  static toolNames = [];\n\n  static addTool(toolName: string) {\n    if (!this.toolNames.includes(toolName)) {\n      this.toolNames.push(toolName);\n    }\n  }\n\n  /**\n   * Accepts the autogenerated interpolations, marking them as non-autogenerated.\n   * Can provide a selector to choose which ones to accept.\n   *\n   * Rules for which items to select:\n   * 1. Only choose annotations having the same segment index and segmentationID\n   * 2. Exclude all contours having the same interpolation UID as any other contours\n   *    on the same slice.\n   * 3. Exclude autogenerated annotations\n   * 4. Exclude any reset interpolationUIDs (this is a manual operation to allow\n   *    creating a new interpolation)\n   * 5. Find the set of interpolationUID's remaining\n   *    a. If the set is of size 0, assign a new interpolationUID\n   *    b. If the set is of size 1, assign that interpolationUID\n   *    c. Otherwise (optional, otherwise do b for size>1 randomly),\n   *       for every remaining annotation, find the one whose center\n   *       point is closest to the center point of the new annotation.\n   *       Choose that interpolationUID\n   *\n   * To allow creating new interpolated groups, the idea is to just use a new\n   * segment index, then have an operation to update the segment index of an\n   * interpolation set.  That way the user can easily draw/see the difference,\n   * and then merge them as required.\n   * However, the base rules allow creating two contours on a single image to\n   * create a separate set.\n   */\n  static acceptAutoGenerated(\n    annotationGroupSelector: AnnotationGroupSelector,\n    selector: AcceptInterpolationSelector = {}\n  ) {\n    const { toolNames, segmentationId, segmentIndex, sliceIndex } = selector;\n    for (const toolName of toolNames || InterpolationManager.toolNames) {\n      const annotations = annotationState.getAnnotations(\n        toolName,\n        annotationGroupSelector\n      ) as InterpolationROIAnnotation[];\n      if (!annotations?.length) {\n        continue;\n      }\n      for (const annotation of annotations) {\n        const { interpolationUID, data, autoGenerated, metadata } = annotation;\n        if (interpolationUID) {\n          annotation.interpolationCompleted = true;\n        }\n        if (!autoGenerated) {\n          continue;\n        }\n        if (segmentIndex && segmentIndex !== data.segmentation.segmentIndex) {\n          continue;\n        }\n        if (\n          sliceIndex !== undefined &&\n          metadata &&\n          sliceIndex !== metadata.sliceIndex\n        ) {\n          continue;\n        }\n        if (\n          segmentationId &&\n          segmentationId !== data.segmentation.segmentationId\n        ) {\n          continue;\n        }\n        addContourSegmentationAnnotation(annotation);\n        annotation.autoGenerated = false;\n      }\n    }\n  }\n\n  /**\n   * When an annotation is completed, if the configuration includes interpolation,\n   * then find matching interpolations and interpolation between this segmentation\n   * and the other segmentations of the same type.\n   */\n  static handleAnnotationCompleted = (evt: AnnotationCompletedEventType) => {\n    const annotation = evt.detail.annotation as InterpolationROIAnnotation;\n    if (!annotation?.metadata) {\n      return;\n    }\n    const { toolName, originalToolName } = annotation.metadata;\n\n    if (\n      !this.toolNames.includes(toolName) &&\n      !this.toolNames.includes(originalToolName)\n    ) {\n      return;\n    }\n\n    const viewport = getViewportForAnnotation(annotation);\n    if (!viewport) {\n      console.warn('Unable to find viewport for', annotation);\n      return;\n    }\n    const sliceData: Types.ImageSliceData = getSliceData(viewport);\n    const viewportData: InterpolationViewportData = {\n      viewport,\n      sliceData,\n      annotation,\n      interpolationUID: annotation.interpolationUID,\n    };\n    const hasInterpolationUID = !!annotation.interpolationUID;\n    // If any update, triggered on an annotation, then it will be treated as non-autogenerated.\n    annotation.autoGenerated = false;\n    if (hasInterpolationUID) {\n      // This has already been configured with matching details, so just run\n      //  the interpolation again.\n      deleteRelatedAnnotations(viewportData);\n      interpolate(viewportData);\n      return;\n    }\n    const filterData = [\n      {\n        key: 'segmentIndex',\n        value: annotation.data.segmentation.segmentIndex,\n        parentKey: (annotation) => annotation.data.segmentation,\n      },\n      {\n        key: 'viewPlaneNormal',\n        value: annotation.metadata.viewPlaneNormal,\n        parentKey: (annotation) => annotation.metadata,\n      },\n      {\n        key: 'viewUp',\n        value: annotation.metadata.viewUp,\n        parentKey: (annotation) => annotation.metadata,\n      },\n    ];\n    let interpolationAnnotations = getInterpolationDataCollection(\n      viewportData,\n      filterData\n    );\n    // Skip other type of annotation interpolationUID's that are co-located\n    const { sliceIndex } = annotation.metadata;\n    const skipUIDs = new Set<string>();\n    interpolationAnnotations.forEach((interpolationAnnotation) => {\n      if (\n        interpolationAnnotation.interpolationCompleted ||\n        interpolationAnnotation.metadata.sliceIndex === sliceIndex\n      ) {\n        const { interpolationUID } = interpolationAnnotation;\n        skipUIDs.add(interpolationUID);\n      }\n    });\n    interpolationAnnotations = interpolationAnnotations.filter(\n      (interpolationAnnotation) =>\n        !skipUIDs.has(interpolationAnnotation.interpolationUID)\n    );\n\n    // Assign a new interpolationUID (this is checked above, so will be empty initially)\n    annotation.interpolationUID =\n      interpolationAnnotations[0]?.interpolationUID || uuidv4();\n    viewportData.interpolationUID = annotation.interpolationUID;\n    interpolate(viewportData);\n  };\n\n  /**\n   * This method gets called when an annotation changes.  It will then trigger\n   * related already interpolated annotations to be updated with the modified data.\n   */\n  static handleAnnotationUpdate = (evt: AnnotationModifiedEventType) => {\n    const annotation = evt.detail.annotation as InterpolationROIAnnotation;\n    const { changeType = ChangeTypes.HandlesUpdated } = evt.detail;\n    if (!annotation?.metadata) {\n      return;\n    }\n    const { toolName, originalToolName } = annotation.metadata;\n\n    if (\n      (!this.toolNames.includes(toolName) &&\n        !this.toolNames.includes(originalToolName)) ||\n      !ChangeTypesForInterpolation.includes(changeType)\n    ) {\n      return;\n    }\n    const viewport = getViewportForAnnotation(annotation);\n    if (!viewport) {\n      console.warn(\n        'Unable to find matching viewport for annotation interpolation',\n        annotation\n      );\n      return;\n    }\n    if (annotation.autoGenerated) {\n      // Dont fire the annotation changed events here, as that leads to recursion,\n      // although this is in fact completing the event, so trigger the segmentation add\n      addContourSegmentationAnnotation(annotation);\n      annotation.autoGenerated = false;\n    }\n\n    const sliceData: Types.ImageSliceData = getSliceData(viewport);\n    const viewportData: InterpolationViewportData = {\n      viewport,\n      sliceData,\n      annotation,\n      interpolationUID: annotation.interpolationUID,\n      isInterpolationUpdate: changeType === ChangeTypes.InterpolationUpdated,\n    };\n    interpolate(viewportData);\n  };\n\n  /**\n   * Delete interpolated annotations when their endpoints are deleted.\n   */\n  static handleAnnotationDelete = (evt: AnnotationRemovedEventType) => {\n    const annotation = evt.detail.annotation as InterpolationROIAnnotation;\n    if (!annotation?.metadata) {\n      return;\n    }\n    const { toolName } = annotation.metadata;\n\n    if (!this.toolNames.includes(toolName) || annotation.autoGenerated) {\n      return;\n    }\n    const viewport = getViewportForAnnotation(annotation);\n\n    if (!viewport) {\n      console.warn(\n        \"No viewport, can't delete interpolated results\",\n        annotation\n      );\n      return;\n    }\n\n    const sliceData: Types.ImageSliceData = getSliceData(viewport);\n    const viewportData: InterpolationViewportData = {\n      viewport,\n      sliceData,\n      annotation,\n      interpolationUID: annotation.interpolationUID,\n    };\n    // If any update, triggered on an annotation, then it will be treated as non-interpolated.\n    annotation.autoGenerated = false;\n    deleteRelatedAnnotations(viewportData);\n  };\n}\n\nfunction getSliceData(viewport): Types.ImageSliceData {\n  const sliceData: Types.ImageSliceData = {\n    numberOfSlices: viewport.getNumberOfSlices(),\n    imageIndex: viewport.getCurrentImageIdIndex(),\n  };\n  return sliceData;\n}\n","import { getToolGroup } from '../../store/ToolGroupManager';\nimport BrushTool from '../../tools/segmentation/BrushTool';\nimport triggerAnnotationRenderForViewportIds from '../triggerAnnotationRenderForViewportIds';\nimport { getRenderingEngine } from '@cornerstonejs/core';\nimport { getBrushToolInstances } from './utilities';\n\n/**\n * Sets the brush size for all brush-based tools in a given tool group.\n * @param toolGroupId - The ID of the tool group to set the brush size for.\n * @param brushSize - The new brush size to set.\n * @param toolName - The name of the specific tool to set the brush size for (optional)\n * If not provided, all brush-based tools in the tool group will be affected.\n */\nexport function setBrushSizeForToolGroup(\n  toolGroupId: string,\n  brushSize: number,\n  toolName?: string\n): void {\n  const toolGroup = getToolGroup(toolGroupId);\n\n  if (toolGroup === undefined) {\n    return;\n  }\n\n  const brushBasedToolInstances = getBrushToolInstances(toolGroupId, toolName);\n\n  brushBasedToolInstances.forEach((tool: BrushTool) => {\n    tool.configuration.brushSize = brushSize;\n\n    // Invalidate the brush being rendered so it can update.\n    tool.invalidateBrushCursor();\n  });\n\n  // Trigger an annotation render for any viewports on the toolgroup\n  const viewportsInfo = toolGroup.getViewportsInfo();\n\n  const viewportsInfoArray = Object.keys(viewportsInfo).map(\n    (key) => viewportsInfo[key]\n  );\n\n  if (!viewportsInfoArray.length) {\n    return;\n  }\n\n  const { renderingEngineId } = viewportsInfoArray[0];\n\n  // Use helper to get array of viewportIds, or we just end up doing this mapping\n  // ourselves here.\n  const viewportIds = toolGroup.getViewportIds();\n\n  const renderingEngine = getRenderingEngine(renderingEngineId);\n\n  triggerAnnotationRenderForViewportIds(renderingEngine, viewportIds);\n}\n\n/**\n * Gets the brush size for the first brush-based tool instance in a given tool group.\n * @param toolGroupId - The ID of the tool group to get the brush size for.\n * @param toolName - The name of the specific tool to get the brush size for (Optional)\n * If not provided, the first brush-based tool instance in the tool group will be used.\n * @returns The brush size of the selected tool instance, or undefined if no brush-based tool instance is found.\n */\nexport function getBrushSizeForToolGroup(\n  toolGroupId: string,\n  toolName?: string\n): void {\n  const toolGroup = getToolGroup(toolGroupId);\n\n  if (toolGroup === undefined) {\n    return;\n  }\n\n  const toolInstances = toolGroup._toolInstances;\n\n  if (!Object.keys(toolInstances).length) {\n    return;\n  }\n\n  const brushBasedToolInstances = getBrushToolInstances(toolGroupId, toolName);\n\n  // one is enough as they share the same brush size\n  const brushToolInstance = brushBasedToolInstances[0];\n\n  if (!brushToolInstance) {\n    return;\n  }\n\n  // TODO -> Assumes the brush sizes are the same and set via these helpers.\n  return brushToolInstance.configuration.brushSize;\n}\n","import type { Types } from '@cornerstonejs/core';\nimport { getToolGroup } from '../../store/ToolGroupManager';\nimport triggerAnnotationRenderForViewportIds from '../triggerAnnotationRenderForViewportIds';\nimport { getRenderingEngine } from '@cornerstonejs/core';\nimport { getBrushToolInstances } from './utilities';\n\nexport function setBrushThresholdForToolGroup(\n  toolGroupId: string,\n  threshold: Types.Point2,\n  otherArgs: Record<string, unknown> = { isDynamic: false }\n) {\n  const toolGroup = getToolGroup(toolGroupId);\n\n  if (toolGroup === undefined) {\n    return;\n  }\n\n  const brushBasedToolInstances = getBrushToolInstances(toolGroupId);\n  const configuration = {\n    ...otherArgs,\n    ...(threshold !== undefined && { threshold }),\n  };\n\n  brushBasedToolInstances.forEach((tool) => {\n    tool.configuration.strategySpecificConfiguration.THRESHOLD = {\n      ...tool.configuration.strategySpecificConfiguration.THRESHOLD,\n      ...configuration,\n    };\n  });\n\n  // Trigger an annotation render for any viewports on the toolgroup\n  const viewportsInfo = toolGroup.getViewportsInfo();\n\n  if (!viewportsInfo.length) {\n    return;\n  }\n\n  const { renderingEngineId } = viewportsInfo[0];\n\n  // Use helper to get array of viewportIds, or we just end up doing this mapping\n  // ourselves here.\n  const viewportIds = toolGroup.getViewportIds();\n\n  const renderingEngine = getRenderingEngine(renderingEngineId);\n\n  triggerAnnotationRenderForViewportIds(renderingEngine, viewportIds);\n}\n\nexport function getBrushThresholdForToolGroup(toolGroupId: string) {\n  const toolGroup = getToolGroup(toolGroupId);\n\n  if (toolGroup === undefined) {\n    return;\n  }\n\n  const toolInstances = toolGroup._toolInstances;\n\n  if (!Object.keys(toolInstances).length) {\n    return;\n  }\n\n  const brushBasedToolInstances = getBrushToolInstances(toolGroupId);\n  const brushToolInstance = brushBasedToolInstances[0];\n\n  if (!brushToolInstance) {\n    return;\n  }\n\n  // TODO -> Assumes the\n  return brushToolInstance.configuration.strategySpecificConfiguration.THRESHOLD\n    .threshold;\n}\n","import type { Types } from '@cornerstonejs/core';\nimport { cache } from '@cornerstonejs/core';\nimport { vec3 } from 'gl-matrix';\n\n/**\n * Determines if there is a point between point1 and point2 which is not\n * contained in the segmentation\n */\nexport default function isLineInSegment(\n  point1: Types.Point3,\n  point2: Types.Point3,\n  isInSegment\n) {\n  const ijk1 = isInSegment.toIJK(point1);\n  const ijk2 = isInSegment.toIJK(point2);\n  const testPoint = vec3.create();\n  const { testIJK } = isInSegment;\n  const delta = vec3.sub(vec3.create(), ijk1, ijk2);\n\n  // Test once for index value between the two points, so the max of the\n  // difference in IJK values\n  const testSize = Math.round(Math.max(...delta.map(Math.abs)));\n  if (testSize < 2) {\n    // No need to test when there are only two points\n    return true;\n  }\n  const unitDelta = vec3.scale(vec3.create(), delta, 1 / testSize);\n\n  for (let i = 1; i < testSize; i++) {\n    vec3.scaleAndAdd(testPoint, ijk2, unitDelta, i);\n    if (!testIJK(testPoint)) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Creates a function that tests to see if the provided line segment, specified\n * in LPS space (as endpoints) is contained in the segment\n */\nfunction createIsInSegment(\n  segVolumeId: string,\n  segmentIndex: number,\n  containedSegmentIndices?: Set<number>\n) {\n  // Get segmentation volume\n  const vol = cache.getVolume(segVolumeId);\n  if (!vol) {\n    console.warn(`No volume found for ${segVolumeId}`);\n    return;\n  }\n\n  const segData = vol.imageData.getPointData().getScalars().getData();\n  const width = vol.dimensions[0];\n  const pixelsPerSlice = width * vol.dimensions[1];\n\n  return {\n    /**\n     * Find the center point between point1 and point2, convert it to IJK space\n     * and test if the value at that location is in the segment\n     */\n    testCenter: (point1, point2) => {\n      const point = vec3.add(vec3.create(), point1, point2).map((it) => it / 2);\n      const ijk = vol.imageData.worldToIndex(point as vec3).map(Math.round);\n      const [i, j, k] = ijk;\n      const index = i + j * width + k * pixelsPerSlice;\n      const value = segData[index];\n      return value === segmentIndex || containedSegmentIndices?.has(value);\n    },\n\n    toIJK: (point) => vol.imageData.worldToIndex(point as vec3),\n\n    testIJK: (ijk) => {\n      const [i, j, k] = ijk;\n      const index =\n        Math.round(i) + Math.round(j) * width + Math.round(k) * pixelsPerSlice;\n      const value = segData[index];\n      return value === segmentIndex || containedSegmentIndices?.has(value);\n    },\n  };\n}\n\nexport { createIsInSegment, isLineInSegment };\n","import { vec3 } from 'gl-matrix';\n\nimport { createIsInSegment, isLineInSegment } from './isLineInSegment';\nimport type { BidirectionalData } from './createBidirectionalToolData';\n\nconst EPSILON = 1e-2;\n\n/**\n * Search in the contours for the given segment to find the largest bidirectional\n * that will fit entirely within the slice contours inside the contours object.\n * Assumptions/implementation details:\n *\n *   1. The major and minor bidirectional lines must not cross the contour\n *   2. The center point for both major and minor bidirectional lines must be\n *      within the segment, or the contained segment index.\n *   3. The major/minor axis must be orthogonal\n *\n * Note this does NOT test that the major/minor axis intersect.  Normally they will, but\n * it isn't a hard requirement.\n *\n * The way that islands within the contours are handled is to allow the island to be\n * coloured with something that is contained - that way both open and closed islands\n * can be handled correctly for finding the bidirectional  (an open island is a section\n * inside the segment that is open to the outside - this can happen at bone endpoints or when\n * one region flows into another)\n */\nexport default function findLargestBidirectional(\n  contours,\n  segVolumeId: string,\n  segment\n) {\n  const { sliceContours } = contours;\n  const { segmentIndex, containedSegmentIndices } = segment;\n  let maxBidirectional;\n  const isInSegment = createIsInSegment(\n    segVolumeId,\n    segmentIndex,\n    containedSegmentIndices\n  );\n  for (const sliceContour of sliceContours) {\n    const bidirectional = createBidirectionalForSlice(\n      sliceContour,\n      isInSegment,\n      maxBidirectional\n    );\n    if (!bidirectional) {\n      continue;\n    }\n    maxBidirectional = bidirectional;\n  }\n  if (maxBidirectional) {\n    Object.assign(maxBidirectional, segment);\n  }\n  return maxBidirectional;\n}\n\n/**\n * This function creates a bidirectional data object for the given slice and\n * slice contour, only when the major distance is larger than currentMax, or\n * equal to current max and the minor is larger than currentMax's minor.\n * It does this by looking at every pair of distances in sliceCountour to find\n * those larger than the currentMax, and then finds the minor distance for those\n * major distances.\n *\n */\nfunction createBidirectionalForSlice(\n  sliceContour,\n  isInSegment,\n  currentMax = { maxMajor: 0, maxMinor: 0 }\n) {\n  const { points } = sliceContour.polyData;\n  const { maxMinor: currentMaxMinor, maxMajor: currentMaxMajor } = currentMax;\n  let maxMajor = currentMaxMajor * currentMaxMajor;\n  let maxMinor = currentMaxMinor * currentMaxMinor;\n  let maxMajorPoints;\n  for (let index1 = 0; index1 < points.length; index1++) {\n    for (let index2 = index1 + 1; index2 < points.length; index2++) {\n      const point1 = points[index1];\n      const point2 = points[index2];\n      const distance2 = vec3.sqrDist(point1, point2);\n      if (distance2 < maxMajor) {\n        continue;\n      }\n      if (distance2 - EPSILON < maxMajor + EPSILON && maxMajorPoints) {\n        // Consider adding to the set of points rather than continuing here\n        // so that all minor axis can be tested\n        continue;\n      }\n      if (!isInSegment.testCenter(point1, point2)) {\n        // Center between the two points has to be in the segment, otherwise\n        // this is out of bounds.\n        continue;\n      }\n      if (!isLineInSegment(point1, point2, isInSegment)) {\n        // If the line intersects the segment boundary, then skip it\n        continue;\n      }\n      maxMajor = distance2 - EPSILON;\n      maxMajorPoints = [index1, index2];\n      maxMinor = 0;\n    }\n  }\n  if (!maxMajorPoints) {\n    return;\n  }\n\n  maxMajor = Math.sqrt(maxMajor + EPSILON);\n  const handle0 = points[maxMajorPoints[0]];\n  const handle1 = points[maxMajorPoints[1]];\n  const unitMajor = vec3.sub(vec3.create(), handle0, handle1);\n  vec3.scale(unitMajor, unitMajor, 1 / maxMajor);\n\n  let maxMinorPoints;\n\n  for (let index1 = 0; index1 < points.length; index1++) {\n    for (let index2 = index1 + 1; index2 < points.length; index2++) {\n      const point1 = points[index1];\n      const point2 = points[index2];\n      const distance2 = vec3.sqrDist(point1, point2);\n      if (distance2 <= maxMinor) {\n        continue;\n      }\n      const delta = vec3.sub(vec3.create(), point1, point2);\n\n      const dot = Math.abs(vec3.dot(delta, unitMajor)) / Math.sqrt(distance2);\n      if (dot > EPSILON) {\n        continue;\n      }\n\n      if (!isInSegment.testCenter(point1, point2)) {\n        // Center between the two points has to be in the segment, otherwise\n        // this is out of bounds.\n        continue;\n      }\n      if (!isLineInSegment(point1, point2, isInSegment)) {\n        continue;\n      }\n      maxMinor = distance2;\n      maxMinorPoints = [index1, index2];\n    }\n  }\n\n  if (!maxMinorPoints) {\n    // Didn't find a larger minor distance\n    return;\n  }\n  maxMinor = Math.sqrt(maxMinor);\n  const handle2 = points[maxMinorPoints[0]];\n  const handle3 = points[maxMinorPoints[1]];\n\n  const bidirectional = {\n    majorAxis: [handle0, handle1],\n    minorAxis: [handle2, handle3],\n    maxMajor,\n    maxMinor,\n    ...sliceContour,\n  } as BidirectionalData;\n  return bidirectional;\n}\n","import { generateContourSetsFromLabelmap } from '../contours';\nimport SegmentationRepresentations from '../../enums/SegmentationRepresentations';\nimport findLargestBidirectional from './findLargestBidirectional';\n\nconst { Labelmap } = SegmentationRepresentations;\n\n/**\n * Generates a contour object over the segment, and then uses the contouring to\n * find the largest bidirectional object that can be applied within the acquisition\n * plane that is within the segment index, or the contained segment indices.\n *\n * @param segmentation.segments - a list of segments to apply the contour to.\n * @param segmentation.segments.containedSegmentIndices - a set of segment indexes equivalent to the primary segment\n * @param segmentation.segments.label - the label for the segment\n * @param segmentation.segments.color - the color to use for the segment label\n */\nexport default function contourAndFindLargestBidirectional(segmentation) {\n  const contours = generateContourSetsFromLabelmap({\n    segmentations: segmentation,\n  });\n\n  if (!contours?.length || !contours[0].sliceContours.length) {\n    return;\n  }\n\n  const {\n    representationData,\n    segments = [\n      null,\n      { label: 'Unspecified', color: null, containedSegmentIndices: null },\n    ],\n  } = segmentation;\n  const { volumeId: segVolumeId } = representationData[Labelmap];\n\n  const segmentIndex = segments.findIndex((it) => !!it);\n  if (segmentIndex === -1) {\n    return;\n  }\n  segments[segmentIndex].segmentIndex = segmentIndex;\n  return findLargestBidirectional(\n    contours[0],\n    segVolumeId,\n    segments[segmentIndex]\n  );\n}\n","import type { Types } from '@cornerstonejs/core';\nimport type { Annotation } from '../../types/AnnotationTypes';\n\nexport type BidirectionalData = {\n  majorAxis: [Types.Point3, Types.Point3];\n  minorAxis: [Types.Point3, Types.Point3];\n  maxMajor: number;\n  maxMinor: number;\n  segmentIndex: number;\n  label?: string;\n  color?: string | number[];\n  referencedImageId: string;\n  sliceIndex: number;\n};\n\n/**\n * Creates data suitable for the BidirectionalTool from the basic bidirectional\n * data object.\n */\nexport default function createBidirectionalToolData(\n  bidirectionalData: BidirectionalData,\n  viewport\n): Annotation {\n  const { majorAxis, minorAxis, label = '', sliceIndex } = bidirectionalData;\n  const [major0, major1] = majorAxis;\n  const [minor0, minor1] = minorAxis;\n\n  const points = [major0, major1, minor0, minor1];\n  const bidirectionalToolData = {\n    highlighted: true,\n    invalidated: true,\n    metadata: {\n      toolName: 'Bidirectional',\n      // Get a view reference for the slice this applies to, not the currently\n      // displayed slice.  This will fill in the remaining data for that slice\n      ...viewport.getViewReference({ sliceIndex }),\n    },\n    data: {\n      handles: {\n        points,\n        textBox: {\n          hasMoved: false,\n          worldPosition: [0, 0, 0] as Types.Point3,\n          worldBoundingBox: {\n            topLeft: [0, 0, 0] as Types.Point3,\n            topRight: [0, 0, 0] as Types.Point3,\n            bottomLeft: [0, 0, 0] as Types.Point3,\n            bottomRight: [0, 0, 0] as Types.Point3,\n          },\n        },\n        activeHandleIndex: null,\n      },\n      label,\n      cachedStats: {},\n    },\n    isLocked: false,\n    isVisible: true,\n  };\n  return bidirectionalToolData;\n}\n","/**\n * Creates a map that associates each imageId with a set of segmentation imageIds.\n * Note that this function assumes that the imageIds and segmentationImageIds arrays\n * are the same length and same order.\n *\n * @param imageIdsArray - An array of imageIds.\n * @param segmentationImageIds - An array of segmentation imageIds.\n * @returns A map that maps each imageId to a set of segmentation imageIds.\n */\nfunction createImageIdReferenceMap(\n  imageIdsArray: string[],\n  segmentationImageIds: string[]\n): Map<string, string> {\n  const imageIdReferenceMap = new Map<string, string>(\n    imageIdsArray.map((imageId, index) => {\n      return [imageId, segmentationImageIds[index]];\n    })\n  );\n\n  return imageIdReferenceMap;\n}\n\nexport { createImageIdReferenceMap };\n","import cloneDeep from 'lodash.clonedeep';\nimport {\n  getEnabledElementByIds,\n  volumeLoader,\n  VolumeViewport,\n  utilities as csUtils,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\n/**\n * Create a new 3D segmentation volume from the default imageData presented in\n * the first actor of the viewport. It looks at the metadata of the imageData\n * to determine the volume dimensions and spacing if particular options are not provided.\n *\n * @param viewportId - The Id of the viewport from which to derive the volume from.\n * @param renderingEngineId - The Id of the rendering engine the viewport belongs to.\n * @param [segmentationId] - The Id to name the generated segmentation. Autogenerated if not given.\n * @param [options] - LabelmapOptions\n * @returns A promise that resolves to the Id of the new labelmap volume.\n */\nexport default async function createLabelmapVolumeForViewport(input: {\n  viewportId: string;\n  renderingEngineId: string;\n  segmentationId?: string;\n  options?: {\n    volumeId: string;\n    scalarData: Float32Array | Uint8Array | Uint16Array | Int16Array;\n    targetBuffer: {\n      type: 'Float32Array' | 'Uint8Array' | 'Uint16Array' | 'Int8Array';\n    };\n    metadata: Types.Metadata;\n    dimensions: Types.Point3;\n    spacing: Types.Point3;\n    origin: Types.Point3;\n    direction: Types.Mat3;\n  };\n}): Promise<string> {\n  const { viewportId, renderingEngineId, options } = input;\n  let { segmentationId } = input;\n  const enabledElement = getEnabledElementByIds(viewportId, renderingEngineId);\n\n  if (!enabledElement) {\n    throw new Error('element disabled');\n  }\n\n  const { viewport } = enabledElement;\n  if (!(viewport instanceof VolumeViewport)) {\n    throw new Error('Segmentation only supports VolumeViewport');\n  }\n\n  const { uid } = viewport.getDefaultActor();\n\n  if (segmentationId === undefined) {\n    // Name the segmentation volume with the viewport Id\n    segmentationId = `${uid}-based-segmentation-${\n      options?.volumeId ?? csUtils.uuidv4().slice(0, 8)\n    }`;\n  }\n\n  if (options) {\n    // create a new labelmap with its own properties\n    // This allows creation of a higher resolution labelmap vs reference volume\n    const properties = cloneDeep(options);\n    await volumeLoader.createLocalVolume(properties, segmentationId);\n  } else {\n    // create a labelmap from a reference volume\n    const { uid: volumeId } = viewport.getDefaultActor();\n    await volumeLoader.createAndCacheDerivedSegmentationVolume(volumeId, {\n      volumeId: segmentationId,\n    });\n  }\n\n  return segmentationId;\n}\n","import { Types } from '@cornerstonejs/core';\nimport { volumeLoader, utilities as csUtils } from '@cornerstonejs/core';\n\n/**\n * Given a list of labelmaps (with the possibility of overlapping regions), and\n * a segmentIndex it creates a new labelmap with the same dimensions as the input labelmaps,\n * but merges them into a single labelmap for the segmentIndex. It wipes out\n * all other segment Indices. This is useful for calculating statistics regarding\n * a specific segment when there are overlapping regions between labelmap (e.g. TMTV)\n *\n * @param labelmaps - Array of labelmaps\n * @param segmentIndex - The segment index to merge\n * @returns Merged labelmap\n */\nfunction createMergedLabelmapForIndex(\n  labelmaps: Array<Types.IImageVolume>,\n  segmentIndex = 1,\n  volumeId = 'mergedLabelmap'\n): Types.IImageVolume {\n  labelmaps.forEach(({ direction, dimensions, origin, spacing }) => {\n    if (\n      !csUtils.isEqual(dimensions, labelmaps[0].dimensions) ||\n      !csUtils.isEqual(direction, labelmaps[0].direction) ||\n      !csUtils.isEqual(spacing, labelmaps[0].spacing) ||\n      !csUtils.isEqual(origin, labelmaps[0].origin)\n    ) {\n      throw new Error('labelmaps must have the same size and shape');\n    }\n  });\n\n  const labelmap = labelmaps[0];\n\n  const arrayType = (labelmap.getScalarData() as any).constructor;\n  const outputData = new arrayType(labelmap.getScalarData().length);\n\n  labelmaps.forEach((labelmap) => {\n    const scalarData = labelmap.getScalarData();\n    for (let i = 0; i < scalarData.length; i++) {\n      if (scalarData[i] === segmentIndex) {\n        outputData[i] = segmentIndex;\n      }\n    }\n  });\n\n  const options = {\n    scalarData: outputData,\n    metadata: labelmap.metadata,\n    spacing: labelmap.spacing,\n    origin: labelmap.origin,\n    direction: labelmap.direction,\n    dimensions: labelmap.dimensions,\n  };\n\n  const preventCache = true;\n  // Todo: following should be async\n  const mergedVolume = volumeLoader.createLocalVolume(\n    options,\n    volumeId,\n    preventCache\n  );\n\n  return mergedVolume;\n}\n\nexport default createMergedLabelmapForIndex;\n","import type {\n  FloodFillResult,\n  FloodFillGetter,\n  FloodFillOptions,\n} from '../../types';\nimport { Types } from '@cornerstonejs/core';\n\n/**\n * floodFill.js - Taken from MIT OSS lib - https://github.com/tuzz/n-dimensional-flood-fill\n * Refactored to ES6.  Fixed the bounds/visits checks to use integer keys, restricting the\n * total search spacing to +/- 32k in each dimension, but resulting in about a hundred time\n * performance gain for larger regions since JavaScript does not have a hash map to allow the\n * map to work on keys.\n *\n * @param getter The getter to the elements of your data structure,\n *                          e.g. getter(x,y) for a 2D interprettation of your structure.\n * @param seed The seed for your fill. The dimensionality is infered\n *                        by the number of dimensions of the seed.\n * @param options.onFlood - An optional callback to execute when each pixel is flooded.\n *                             e.g. onFlood(x,y).\n * @param options.onBoundary - An optional callback to execute whenever a boundary is reached.\n *                                a boundary could be another segmentIndex, or the edge of your\n *                                data structure (i.e. when your getter returns undefined).\n * @param options.equals - An optional equality method for your datastructure.\n *                            Default is simply value1 = value2.\n * @param options.diagonals - Whether you allow flooding through diagonals. Defaults to false.\n *\n * @returns Flood fill results\n */\nfunction floodFill(\n  getter: FloodFillGetter,\n  seed: Types.Point2 | Types.Point3,\n  options: FloodFillOptions = {}\n): FloodFillResult {\n  const onFlood = options.onFlood;\n  const onBoundary = options.onBoundary;\n  const equals = options.equals;\n  const diagonals = options.diagonals || false;\n  const startNode = get(seed);\n  const permutations = prunedPermutations();\n  const stack = [];\n  const flooded = [];\n  const visits = new Set();\n  const bounds = new Map();\n\n  stack.push({ currentArgs: seed });\n\n  while (stack.length > 0) {\n    flood(stack.pop());\n  }\n\n  return {\n    flooded,\n    boundaries: boundaries(),\n  };\n\n  function flood(job) {\n    const getArgs = job.currentArgs;\n    const prevArgs = job.previousArgs;\n\n    if (visited(getArgs)) {\n      return;\n    }\n    markAsVisited(getArgs);\n\n    if (member(getArgs)) {\n      markAsFlooded(getArgs);\n      pushAdjacent(getArgs);\n    } else {\n      markAsBoundary(prevArgs);\n    }\n  }\n\n  /**\n   * Indicates if the key has been visited.\n   * @param key is a 2 or 3 element vector with values -32768...32767\n   */\n  function visited(key) {\n    const [x, y, z = 0] = key;\n    // Use an integer key value for checking visited, since JavaScript does not\n    // provide a generic hash key indexed hash map.\n    const iKey = x + 32768 + 65536 * (y + 32768 + 65536 * (z + 32768));\n    return visits.has(iKey);\n  }\n\n  function markAsVisited(key) {\n    const [x, y, z = 0] = key;\n    const iKey = x + 32768 + 65536 * (y + 32768 + 65536 * (z + 32768));\n    visits.add(iKey);\n  }\n\n  function member(getArgs) {\n    const node = get(getArgs);\n\n    return equals ? equals(node, startNode) : node === startNode;\n  }\n\n  function markAsFlooded(getArgs) {\n    flooded.push(getArgs);\n    if (onFlood) {\n      //@ts-ignore\n      onFlood(...getArgs);\n    }\n  }\n\n  function markAsBoundary(prevArgs) {\n    const [x, y, z = 0] = prevArgs;\n    // Use an integer key value for checking visited, since JavaScript does not\n    // provide a generic hash key indexed hash map.\n    const iKey = x + 32768 + 65536 * (y + 32768 + 65536 * (z + 32768));\n    bounds.set(iKey, prevArgs);\n    if (onBoundary) {\n      //@ts-ignore\n      onBoundary(...prevArgs);\n    }\n  }\n\n  function pushAdjacent(getArgs) {\n    for (let i = 0; i < permutations.length; i += 1) {\n      const perm = permutations[i];\n      const nextArgs = getArgs.slice(0);\n\n      for (let j = 0; j < getArgs.length; j += 1) {\n        nextArgs[j] += perm[j];\n      }\n\n      stack.push({\n        currentArgs: nextArgs,\n        previousArgs: getArgs,\n      });\n    }\n  }\n\n  function get(getArgs) {\n    //@ts-ignore\n    return getter(...getArgs);\n  }\n\n  // This is a significant performance hit - should be done as a wrapper\n  // only when needed.\n  // function safely(f, args) {\n  //   try {\n  //     return f(...args);\n  //   } catch (error) {\n  //     return;\n  //   }\n  // }\n\n  function prunedPermutations() {\n    const permutations = permute(seed.length);\n\n    return permutations.filter(function (perm) {\n      const count = countNonZeroes(perm);\n\n      return count !== 0 && (count === 1 || diagonals);\n    });\n  }\n\n  function permute(length) {\n    const perms = [];\n\n    const permutation = function (string) {\n      return string.split('').map(function (c) {\n        return parseInt(c, 10) - 1;\n      });\n    };\n\n    for (let i = 0; i < Math.pow(3, length); i += 1) {\n      const string = lpad(i.toString(3), '0', length);\n\n      perms.push(permutation(string));\n    }\n\n    return perms;\n  }\n\n  function boundaries() {\n    const array = Array.from(bounds.values());\n    array.reverse();\n    return array;\n  }\n}\n\nfunction defaultEquals(a, b) {\n  return a === b;\n}\n\nfunction countNonZeroes(array) {\n  let count = 0;\n\n  for (let i = 0; i < array.length; i += 1) {\n    if (array[i] !== 0) {\n      count += 1;\n    }\n  }\n\n  return count;\n}\n\nfunction lpad(string, character, length) {\n  const array = new Array(length + 1);\n  const pad = array.join(character);\n\n  return (pad + string).slice(-length);\n}\n\nexport default floodFill;\n","import getDefaultLabelmapConfig from '../../tools/displayTools/Labelmap/labelmapConfig';\nimport SegmentationRepresentation from '../../enums/SegmentationRepresentations';\nimport { Segmentation } from '../../types/SegmentationStateTypes';\n\n/**\n * It returns a configuration object for the given representation type.\n * @param representationType - The type of segmentation representation\n * @returns A representation configuration object.\n */\nexport default function getDefaultRepresentationConfig(\n  segmentation: Segmentation\n) {\n  const { type: representationType } = segmentation;\n  switch (representationType) {\n    case SegmentationRepresentation.Labelmap:\n      return getDefaultLabelmapConfig();\n    default:\n      throw new Error(`Unknown representation type: ${representationType}`);\n  }\n}\n","import { getAnnotation } from '../../stateManagement';\nimport { getSegmentation } from '../../stateManagement/segmentation/segmentationState';\n\n/**\n * Retrieves the index of the hovered contour segmentation annotation for a given segmentation ID.\n *\n * @param segmentationId - The ID of the segmentation.\n * @returns The index of the hovered contour segmentation annotation, or undefined if none is found.\n */\nexport function getHoveredContourSegmentationAnnotation(segmentationId) {\n  const segmentation = getSegmentation(segmentationId);\n  const { annotationUIDsMap } = segmentation.representationData.CONTOUR;\n\n  for (const [segmentIndex, annotationUIDs] of annotationUIDsMap.entries()) {\n    const highlightedAnnotationUID = Array.from(annotationUIDs).find(\n      (annotationUID) => getAnnotation(annotationUID).highlighted\n    );\n\n    if (highlightedAnnotationUID) {\n      return segmentIndex;\n    }\n  }\n\n  return undefined;\n}\n","import { cache, utilities } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\nimport {\n  getSegmentation,\n  getSegmentationIdRepresentations,\n} from '../../stateManagement/segmentation/segmentationState';\nimport {\n  LabelmapSegmentationDataStack,\n  LabelmapSegmentationDataVolume,\n} from '../../types/LabelmapTypes';\nimport { isVolumeSegmentation } from '../../tools/segmentation/strategies/utils/stackVolumeCheck';\n\ntype Options = {\n  viewport?: Types.IViewport;\n  searchRadius?: number;\n};\n\n/**\n * Retrieves the segment index at the border of a labelmap in a segmentation.\n *\n * @param segmentationId - The ID of the segmentation.\n * @param worldPoint - The world coordinates of the point.\n * @param options - Additional options.\n * @param options.viewport - The viewport to use.\n * @param options.searchRadius - The search radius to use.\n * @returns The segment index at the labelmap border, or undefined if not found.\n */\nexport function getSegmentAtLabelmapBorder(\n  segmentationId: string,\n  worldPoint: Types.Point3,\n  { viewport, searchRadius }: Options\n): number {\n  const segmentation = getSegmentation(segmentationId);\n\n  const labelmapData = segmentation.representationData.LABELMAP;\n\n  if (isVolumeSegmentation(labelmapData)) {\n    const { volumeId } = labelmapData as LabelmapSegmentationDataVolume;\n    const segmentationVolume = cache.getVolume(volumeId);\n\n    if (!segmentationVolume) {\n      return;\n    }\n\n    const imageData = segmentationVolume.imageData;\n\n    const segmentIndex = imageData.getScalarValueFromWorld(worldPoint);\n\n    const canvasPoint = viewport.worldToCanvas(worldPoint);\n\n    const onEdge = isSegmentOnEdgeCanvas(\n      canvasPoint as Types.Point2,\n      segmentIndex,\n      viewport,\n      imageData,\n      searchRadius\n    );\n\n    return onEdge ? segmentIndex : undefined;\n  }\n\n  // stack segmentation case\n  const { imageIdReferenceMap } = labelmapData as LabelmapSegmentationDataStack;\n\n  const currentImageId = (viewport as Types.IStackViewport).getCurrentImageId();\n\n  const segmentationImageId = imageIdReferenceMap.get(currentImageId);\n  const image = cache.getImage(segmentationImageId);\n\n  if (!image) {\n    return;\n  }\n\n  // find the first segmentationRepresentationUID for the segmentationId, since\n  // that is what we use as actorUID in the viewport\n\n  const segmentationRepresentations = getSegmentationIdRepresentations(\n    segmentation.segmentationId\n  );\n\n  const { segmentationRepresentationUID } = segmentationRepresentations[0];\n  const segmentationActor = viewport.getActor(segmentationRepresentationUID);\n  const imageData = segmentationActor?.actor.getMapper().getInputData();\n  const indexIJK = utilities.transformWorldToIndex(imageData, worldPoint);\n\n  const dimensions = imageData.getDimensions();\n  const voxelManager = (imageData.voxelManager ||\n    utilities.VoxelManager.createVolumeVoxelManager(\n      dimensions,\n      imageData.getPointData().getScalars().getData()\n    )) as utilities.VoxelManager<number>;\n\n  const segmentIndex = voxelManager.getAtIJKPoint(indexIJK as Types.Point3);\n\n  const onEdge = isSegmentOnEdgeIJK(\n    indexIJK as Types.Point3,\n    dimensions,\n    voxelManager,\n    segmentIndex\n  );\n\n  return onEdge ? segmentIndex : undefined;\n}\n\n/**\n * Checks if a segment is on the edge of a labelmap.\n * @param getNeighborIndex - A function that returns the neighbor index given the delta values.\n * @param segmentIndex - The index of the segment to check.\n * @param searchRadius - The radius within which to search for neighboring segments. Default is 1.\n * @returns A boolean indicating whether the segment is on the edge.\n */\nfunction isSegmentOnEdge(\n  getNeighborIndex: (\n    deltaI: number,\n    deltaJ: number,\n    deltaK: number\n  ) => number | undefined,\n  segmentIndex: number,\n  searchRadius = 1 // Default search radius\n): boolean {\n  const neighborRange = Array.from(\n    { length: 2 * searchRadius + 1 },\n    (_, i) => i - searchRadius\n  );\n\n  for (const deltaI of neighborRange) {\n    for (const deltaJ of neighborRange) {\n      for (const deltaK of neighborRange) {\n        if (deltaI === 0 && deltaJ === 0 && deltaK === 0) {\n          continue; // Skipping the central point\n        }\n\n        const neighborIndex = getNeighborIndex(deltaI, deltaJ, deltaK);\n\n        if (neighborIndex !== undefined && segmentIndex !== neighborIndex) {\n          return true; // On the edge\n        }\n      }\n    }\n  }\n\n  return false; // No edge neighbors found\n}\n\nfunction isSegmentOnEdgeIJK(\n  indexIJK: Types.Point3,\n  dimensions: Types.Point3,\n  voxelManager: any,\n  segmentIndex: number,\n  searchRadius?: number\n): boolean {\n  const getNeighborIndex = (deltaI: number, deltaJ: number, deltaK: number) => {\n    const neighborIJK = [\n      indexIJK[0] + deltaI,\n      indexIJK[1] + deltaJ,\n      indexIJK[2] + deltaK,\n    ];\n\n    return voxelManager.getAtIJK(...neighborIJK);\n  };\n\n  return isSegmentOnEdge(getNeighborIndex, segmentIndex, searchRadius);\n}\n\nfunction isSegmentOnEdgeCanvas(\n  canvasPoint: Types.Point2,\n  segmentIndex: number,\n  viewport: Types.IViewport,\n  imageData: any,\n  searchRadius?: number\n): boolean {\n  const getNeighborIndex = (deltaI: number, deltaJ: number) => {\n    const neighborCanvas = [canvasPoint[0] + deltaI, canvasPoint[1] + deltaJ];\n\n    const worldPoint = viewport.canvasToWorld(neighborCanvas as Types.Point2);\n    return imageData.getScalarValueFromWorld(worldPoint);\n  };\n\n  return isSegmentOnEdge(getNeighborIndex, segmentIndex, searchRadius);\n}\n","import { cache, utilities } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\nimport { SegmentationRepresentations } from '../../enums';\nimport {\n  getSegmentation,\n  getSegmentationIdRepresentations,\n} from '../../stateManagement/segmentation/segmentationState';\nimport {\n  LabelmapSegmentationDataStack,\n  LabelmapSegmentationDataVolume,\n} from '../../types/LabelmapTypes';\nimport { isVolumeSegmentation } from '../../tools/segmentation/strategies/utils/stackVolumeCheck';\nimport { ContourSegmentationAnnotation, Segmentation } from '../../types';\nimport { getAnnotation } from '../../stateManagement';\nimport { isPointInsidePolyline3D } from '../math/polyline';\n\ntype Options = {\n  representationType?: SegmentationRepresentations;\n  viewport?: Types.IViewport;\n};\n\n/**\n * Get the segment at the specified world point in the viewport.\n * @param segmentationId - The ID of the segmentation to get the segment for.\n * @param worldPoint - The world point to get the segment for.\n *\n * @returns The index of the segment at the world point, or undefined if not found.\n */\nexport function getSegmentAtWorldPoint(\n  segmentationId: string,\n  worldPoint: Types.Point3,\n  options = {} as Options\n): number {\n  const segmentation = getSegmentation(segmentationId);\n\n  const representationData = segmentation.representationData;\n\n  // if representationType is not provided, we will use the first representation\n  const desiredRepresentation =\n    options?.representationType ?? Object.keys(representationData)[0];\n\n  if (!desiredRepresentation) {\n    throw new Error(\n      `Segmentation ${segmentationId} does not have any representations`\n    );\n  }\n\n  switch (desiredRepresentation) {\n    case SegmentationRepresentations.Labelmap:\n      return getSegmentAtWorldForLabelmap(segmentation, worldPoint, options);\n    case SegmentationRepresentations.Contour:\n      return getSegmentAtWorldForContour(segmentation, worldPoint, options);\n    default:\n      return;\n  }\n}\n\n/**\n * Retrieves the segment index at a given world point for a labelmap.\n *\n * @param labelmapData - The labelmap segmentation data.\n * @param worldPoint - The world point to retrieve the segment at.\n *\n * @returns The segment index at the given world point, or undefined if not found.\n */\nexport function getSegmentAtWorldForLabelmap(\n  segmentation: Segmentation,\n  worldPoint: Types.Point3,\n  { viewport }: Options\n): number | undefined {\n  const labelmapData = segmentation.representationData.LABELMAP;\n\n  if (isVolumeSegmentation(labelmapData)) {\n    const { volumeId } = labelmapData as LabelmapSegmentationDataVolume;\n    const segmentationVolume = cache.getVolume(volumeId);\n\n    if (!segmentationVolume) {\n      return;\n    }\n\n    const segmentIndex =\n      segmentationVolume.imageData.getScalarValueFromWorld(worldPoint);\n\n    return segmentIndex;\n  }\n\n  // stack segmentation case\n  const { imageIdReferenceMap } = labelmapData as LabelmapSegmentationDataStack;\n\n  const currentImageId = (viewport as Types.IStackViewport).getCurrentImageId();\n\n  const segmentationImageId = imageIdReferenceMap.get(currentImageId);\n  const image = cache.getImage(segmentationImageId);\n\n  if (!image) {\n    return;\n  }\n\n  // find the first segmentationRepresentationUID for the segmentationId, since\n  // that is what we use as actorUID in the viewport\n\n  const segmentationRepresentations = getSegmentationIdRepresentations(\n    segmentation.segmentationId\n  );\n\n  const { segmentationRepresentationUID } = segmentationRepresentations[0];\n\n  const segmentationActor = viewport.getActor(segmentationRepresentationUID);\n  const imageData = segmentationActor?.actor.getMapper().getInputData();\n  const indexIJK = utilities.transformWorldToIndex(imageData, worldPoint);\n\n  const dimensions = imageData.getDimensions();\n  const voxelManager = (imageData.voxelManager ||\n    utilities.VoxelManager.createVolumeVoxelManager(\n      dimensions,\n      imageData.getPointData().getScalars().getData()\n    )) as utilities.VoxelManager<number>;\n\n  const segmentIndex = voxelManager.getAtIJKPoint(indexIJK as Types.Point3);\n\n  return segmentIndex;\n}\n\n/**\n * Retrieves the segment index at a given world point for contour segmentation.\n *\n * @param segmentation - The segmentation data.\n * @param worldPoint - The world point to check.\n * @param options - The options for segmentation.\n * @returns The segment index at the given world point, or undefined if not found.\n */\nexport function getSegmentAtWorldForContour(\n  segmentation: Segmentation,\n  worldPoint: Types.Point3,\n  { viewport }: Options\n): number {\n  const contourData = segmentation.representationData.CONTOUR;\n\n  const segmentIndices = Array.from(contourData.annotationUIDsMap.keys());\n  const { viewPlaneNormal } = viewport.getCamera();\n\n  for (const segmentIndex of segmentIndices) {\n    const annotationsSet = contourData.annotationUIDsMap.get(segmentIndex);\n\n    if (!annotationsSet) {\n      continue;\n    }\n\n    for (const annotationUID of annotationsSet) {\n      const annotation = getAnnotation(\n        annotationUID\n      ) as ContourSegmentationAnnotation;\n\n      if (!annotation) {\n        continue;\n      }\n\n      const { polyline } = annotation.data.contour;\n\n      if (\n        !utilities.isEqual(viewPlaneNormal, annotation.metadata.viewPlaneNormal)\n      ) {\n        continue;\n      }\n\n      // This function checks whether we are inside the contour. It does not\n      // check if we are exactly on the contour, which is highly unlikely given\n      // the canvas pixel resolution of 1 decimal place we have by design.\n      if (isPointInsidePolyline3D(worldPoint, polyline)) {\n        return Number(segmentIndex);\n      }\n    }\n  }\n}\n","import { getToolGroup } from '../../store/ToolGroupManager';\nimport BrushTool from '../../tools/segmentation/BrushTool';\nimport triggerAnnotationRenderForViewportIds from '../triggerAnnotationRenderForViewportIds';\nimport { getRenderingEngine } from '@cornerstonejs/core';\nimport { getBrushToolInstances } from './utilities';\n\n/**\n * Invalidates the brush cursor for a specific tool group.\n * This function triggers the update of the brush being rendered.\n * It also triggers an annotation render for any viewports on the tool group.\n *\n * @param toolGroupId - The ID of the tool group.\n */\nexport function invalidateBrushCursor(toolGroupId: string): void {\n  const toolGroup = getToolGroup(toolGroupId);\n\n  if (toolGroup === undefined) {\n    return;\n  }\n\n  const brushBasedToolInstances = getBrushToolInstances(toolGroupId);\n\n  brushBasedToolInstances.forEach((tool: BrushTool) => {\n    // Invalidate the brush being rendered so it can update.\n    tool.invalidateBrushCursor();\n  });\n\n  // Trigger an annotation render for any viewports on the toolgroup\n  const viewportsInfo = toolGroup.getViewportsInfo();\n\n  const viewportsInfoArray = Object.keys(viewportsInfo).map(\n    (key) => viewportsInfo[key]\n  );\n\n  if (!viewportsInfoArray.length) {\n    return;\n  }\n\n  const { renderingEngineId } = viewportsInfoArray[0];\n\n  // Use helper to get array of viewportIds, or we just end up doing this mapping\n  // ourselves here.\n  const viewportIds = toolGroup.getViewportIds();\n\n  const renderingEngine = getRenderingEngine(renderingEngineId);\n\n  triggerAnnotationRenderForViewportIds(renderingEngine, viewportIds);\n}\n","import { isValidLabelmapConfig } from '../../tools/displayTools/Labelmap/labelmapConfig';\nimport SegmentationRepresentation from '../../enums/SegmentationRepresentations';\nimport { RepresentationConfig } from '../../types/SegmentationStateTypes';\n\n/**\n * Given a representation type and a configuration, return true if the\n * configuration is valid for that representation type\n * @param representationType - The type of segmentation representation\n * @param config - RepresentationConfig\n * @returns A boolean value.\n */\nexport default function isValidRepresentationConfig(\n  representationType: string,\n  config: RepresentationConfig\n): boolean {\n  switch (representationType) {\n    case SegmentationRepresentation.Labelmap:\n      return isValidLabelmapConfig(config);\n    default:\n      throw new Error(`Unknown representation type: ${representationType}`);\n  }\n}\n","import type { Types } from '@cornerstonejs/core';\nimport { state } from '../../stateManagement/annotation';\nimport {\n  RectangleROIStartEndThresholdTool,\n  RectangleROIThresholdTool,\n} from '../../tools';\n\nimport thresholdVolumeByRange from './thresholdVolumeByRange';\nimport getBoundsIJKFromRectangleAnnotations from '../rectangleROITool/getBoundsIJKFromRectangleAnnotations';\nimport { ThresholdInformation } from './utilities';\n\nexport type ThresholdOptions = {\n  numSlicesToProject?: number; // number of slices to project before and after current slice\n  overwrite: boolean;\n  overlapType?: number; // type of the voxel overlap\n  segmentIndex?: number; // segment index to threshold\n};\n\nexport type AnnotationForThresholding = {\n  data: {\n    handles: {\n      points: Types.Point3[];\n    };\n    cachedStats?: {\n      projectionPoints?: Types.Point3[][];\n    };\n  };\n};\n\n/**\n * It uses the provided rectangleROI annotations (either RectangleROIThreshold, or\n * RectangleROIStartEndThreshold) to compute an ROI that is the intersection of\n * all the annotations. Then it uses the rectangleROIThreshold utility to threshold\n * the volume.\n * @param annotationUIDs - rectangleROI annotationsUIDs to use for ROI\n * @param segmentationVolume - the segmentation volume\n * @param thresholdVolumeInformation - object array containing the volume data and range threshold values\n * @param options - options for thresholding\n * @returns\n */\nfunction rectangleROIThresholdVolumeByRange(\n  annotationUIDs: string[],\n  segmentationVolume: Types.IImageVolume,\n  thresholdVolumeInformation: ThresholdInformation[],\n  options: ThresholdOptions\n): Types.IImageVolume {\n  const annotations = annotationUIDs.map((annotationUID) => {\n    return state.getAnnotation(annotationUID);\n  });\n\n  _validateAnnotations(annotations);\n\n  let boundsIJK;\n  for (let i = 0; i < thresholdVolumeInformation.length; i++) {\n    // make sure that the boundsIJK are generated by the correct volume\n    const volumeSize =\n      thresholdVolumeInformation[i].volume.getScalarData().length;\n    if (volumeSize === segmentationVolume.getScalarData().length || i === 0) {\n      boundsIJK = getBoundsIJKFromRectangleAnnotations(\n        annotations,\n        thresholdVolumeInformation[i].volume,\n        options\n      );\n    }\n  }\n\n  const outputSegmentationVolume = thresholdVolumeByRange(\n    segmentationVolume,\n    thresholdVolumeInformation,\n    { ...options, boundsIJK }\n  );\n\n  outputSegmentationVolume.modified();\n\n  return outputSegmentationVolume;\n}\n\nfunction _validateAnnotations(annotations) {\n  const validToolNames = [\n    RectangleROIThresholdTool.toolName,\n    RectangleROIStartEndThresholdTool.toolName,\n  ];\n\n  for (const annotation of annotations) {\n    const name = annotation.metadata.toolName;\n    if (!validToolNames.includes(name)) {\n      throw new Error(\n        'rectangleROIThresholdVolumeByRange only supports RectangleROIThreshold and RectangleROIStartEndThreshold annotations'\n      );\n    }\n  }\n}\n\nexport default rectangleROIThresholdVolumeByRange;\n","import { getEnabledElement, type Types } from '@cornerstonejs/core';\n\nimport type { Annotation } from '../../types/AnnotationTypes';\nimport * as segmentation from '../../stateManagement/segmentation';\nimport {\n  state as annotationState,\n  config as annotationConfig,\n} from '../../stateManagement/annotation';\nimport { jumpToSlice } from '../viewport';\nimport contourAndFindLargestBidirectional from './contourAndFindLargestBidirectional';\nimport createBidirectionalToolData from './createBidirectionalToolData';\nimport BidirectionalTool from '../../tools/annotation/BidirectionalTool';\n\nexport type Segment = {\n  segmentationId: string;\n  segmentIndex: number;\n  label: string;\n\n  style?: any;\n  containedSegmentIndices?: (number) => boolean;\n};\n\nexport type SegmentContourActionConfiguration = {\n  getSegment?: (\n    enabledElement: Types.IEnabledElement,\n    configuration: SegmentContourActionConfiguration\n  ) => Segment;\n\n  /**\n   * Optional map for data about each segment\n   */\n  segmentationId?: string;\n  segmentIndex?: number;\n  segmentData?: Map<number, Segment>;\n  toolGroupId?: string;\n};\n\nexport default function segmentContourAction(\n  element: HTMLDivElement,\n  configuration\n) {\n  const { data: configurationData } = configuration;\n  const enabledElement = getEnabledElement(element);\n  const segment = (configurationData.getSegment || defaultGetSegment)(\n    enabledElement,\n    configurationData\n  );\n  if (!segment) {\n    return;\n  }\n  const FrameOfReferenceUID = enabledElement.viewport.getFrameOfReferenceUID();\n  const segmentationsList = segmentation.state.getSegmentations();\n  const { segmentIndex, segmentationId } = segment;\n  const bidirectionals = annotationState.getAnnotations(\n    this.toolName || BidirectionalTool.toolName,\n    FrameOfReferenceUID\n  );\n  let hasExistingActiveSegment = false;\n  const existingLargestBidirectionals = bidirectionals.filter(\n    (existingBidirectionalItem) => {\n      const { segment } = existingBidirectionalItem.data;\n      if (!segment) {\n        return;\n      }\n      if (\n        segment.segmentationId === segmentationId &&\n        segment.segmentIndex === segmentIndex\n      ) {\n        hasExistingActiveSegment = true;\n        existingBidirectionalItem.data.segment = segment;\n      }\n      return !!segment;\n    }\n  );\n  if (!hasExistingActiveSegment) {\n    // Just create a dummy annotation object containing just enough information\n    // to create a real one.\n    existingLargestBidirectionals.push({\n      data: { segment },\n    } as unknown as Annotation);\n  }\n\n  let newBidirectional;\n  existingLargestBidirectionals.forEach((existingLargestBidirectional) => {\n    const segments = [];\n    const { segment: updateSegment } = existingLargestBidirectional.data;\n    const { segmentIndex, segmentationId } = updateSegment;\n    segments[segmentIndex] = updateSegment;\n    annotationState.removeAnnotation(\n      existingLargestBidirectional.annotationUID\n    );\n    const bidirectionalData = contourAndFindLargestBidirectional({\n      ...segmentationsList.find(\n        (segmentation) => segmentation.segmentationId === segmentationId\n      ),\n      segments,\n    });\n\n    if (!bidirectionalData) {\n      return;\n    }\n    const bidirectionalToolData = createBidirectionalToolData(\n      bidirectionalData,\n      enabledElement.viewport\n    );\n    bidirectionalToolData.annotationUID =\n      existingLargestBidirectional.annotationUID;\n    bidirectionalToolData.data.segment = updateSegment;\n\n    const annotationUID = annotationState.addAnnotation(\n      bidirectionalToolData,\n      FrameOfReferenceUID\n    );\n\n    if (\n      updateSegment.segmentIndex === segment.segmentIndex &&\n      updateSegment.segmentationId === segment.segmentationId\n    ) {\n      newBidirectional = bidirectionalData;\n      const { style } = segment;\n      if (style) {\n        annotationConfig.style.setAnnotationStyles(annotationUID, style);\n      }\n    }\n  });\n\n  if (newBidirectional) {\n    const { sliceIndex } = newBidirectional;\n    const imageIds = enabledElement.viewport.getImageIds();\n\n    // TODO - figure out why this is reversed\n    jumpToSlice(element, {\n      imageIndex: imageIds.length - 1 - sliceIndex,\n    });\n    enabledElement.viewport.render();\n  } else {\n    console.warn('No bidirectional found');\n  }\n\n  return newBidirectional;\n}\n\nexport function defaultGetSegment(\n  enabledElement: Types.IEnabledElement,\n  configuration: SegmentContourActionConfiguration\n): Segment {\n  const segmentationsList = segmentation.state.getSegmentations();\n  if (!segmentationsList.length) {\n    return;\n  }\n  const segmentationId =\n    configuration.segmentationId || segmentationsList[0].segmentationId;\n  const segmentIndex =\n    configuration.segmentIndex ??\n    segmentation.segmentIndex.getActiveSegmentIndex(segmentationId);\n  if (!segmentIndex) {\n    return;\n  }\n  const segmentData = configuration.segmentData?.get(segmentIndex);\n  return {\n    label: `Segment ${segmentIndex}`,\n    segmentIndex,\n    segmentationId,\n    ...segmentData,\n  };\n}\n","import { Types } from '@cornerstonejs/core';\nimport { pointInShapeCallback } from '../../utilities';\nimport { triggerSegmentationDataModified } from '../../stateManagement/segmentation/triggerSegmentationEvents';\nimport {\n  getVoxelOverlap,\n  processVolumes,\n  ThresholdInformation,\n} from './utilities';\n\n/**\n * It thresholds a segmentation volume based on a set of threshold values with\n * respect to a list of volumes and respective threshold ranges.\n * @param segmentationVolume - the segmentation volume to be modified\n * @param segmentationIndex - the index of the segmentation to modify\n * @param thresholdVolumeInformation - array of objects containing volume data\n * and a range (lower and upper values) to threshold\n * @param overlapType - indicates if the user requires all voxels pass\n * (overlapType = 1) or any voxel pass (overlapType = 0)\n * @returns\n */\nfunction thresholdSegmentationByRange(\n  segmentationVolume: Types.IImageVolume,\n  segmentationIndex: number,\n  thresholdVolumeInformation: ThresholdInformation[],\n  overlapType: number\n): Types.IImageVolume {\n  const scalarData = segmentationVolume.getScalarData();\n\n  // prepare a list of volume information objects for callback functions\n  const { baseVolumeIdx, volumeInfoList } = processVolumes(\n    segmentationVolume,\n    thresholdVolumeInformation\n  );\n\n  /**\n   * This function will test all overlaps between a voxel in base volume\n   * (the reference for segmentation volume creation) and voxels in other\n   * volumes.\n   * If the segmentation volume and the image volume are the same size,\n   * checks if the scalar data at each point is within the threshold values.\n   * If the segmentation volume and the image volume are different sizes,\n   * checks the voxel overlap\n   */\n  volumeInfoList.forEach((volumeInfo) => {\n    const { volumeSize } = volumeInfo;\n\n    if (volumeSize === scalarData.length) {\n      _handleSameSizeVolume(scalarData, segmentationIndex, volumeInfo);\n    } else {\n      _handleDifferentSizeVolume(\n        scalarData,\n        segmentationIndex,\n        volumeInfo,\n        volumeInfoList,\n        baseVolumeIdx,\n        overlapType\n      );\n    }\n  });\n\n  triggerSegmentationDataModified(segmentationVolume.volumeId);\n\n  return segmentationVolume;\n}\n\nfunction _handleDifferentSizeVolume(\n  scalarData: Types.PixelDataTypedArray,\n  segmentationIndex: number,\n  volumeInfo: any,\n  volumeInfoList: any,\n  baseVolumeIdx: number,\n  overlapType: number\n) {\n  const { imageData, lower, upper, dimensions } = volumeInfo;\n\n  let total, overlaps, range;\n\n  for (let i = 0; i < scalarData.length; i++) {\n    if (scalarData[i] === segmentationIndex) {\n      const overlapBounds = getVoxelOverlap(\n        imageData,\n        dimensions,\n        volumeInfoList[baseVolumeIdx].spacing,\n        volumeInfoList[baseVolumeIdx].imageData.getPoint(i)\n      );\n\n      const callbackOverlap = ({ value }) => {\n        total = total + 1;\n        if (value >= range.lower && value <= range.upper) {\n          overlaps = overlaps + 1;\n        }\n      };\n\n      total = 0;\n      overlaps = 0;\n      range = { lower, upper };\n      let overlapTest = false;\n\n      // check all voxel overlaps\n      pointInShapeCallback(\n        imageData,\n        () => true,\n        callbackOverlap,\n        overlapBounds\n      );\n\n      overlapTest = overlapType === 0 ? overlaps > 0 : overlaps === total;\n      scalarData[i] = overlapTest ? segmentationIndex : 0;\n    }\n  }\n  return { total, range, overlaps };\n}\n\nfunction _handleSameSizeVolume(\n  scalarData: Types.PixelDataTypedArray,\n  segmentationIndex: number,\n  volumeInfo: any\n) {\n  const { referenceValues, lower, upper } = volumeInfo;\n\n  for (let i = 0; i < scalarData.length; i++) {\n    if (scalarData[i] === segmentationIndex) {\n      const value = referenceValues[i];\n      scalarData[i] = value >= lower && value <= upper ? segmentationIndex : 0;\n    }\n  }\n}\n\nexport default thresholdSegmentationByRange;\n","import { Types } from '@cornerstonejs/core';\nimport { pointInShapeCallback } from '../../utilities';\nimport { triggerSegmentationDataModified } from '../../stateManagement/segmentation/triggerSegmentationEvents';\nimport { BoundsIJK } from '../../types';\nimport {\n  getVoxelOverlap,\n  processVolumes,\n  ThresholdInformation,\n} from './utilities';\n\nexport type ThresholdRangeOptions = {\n  overwrite: boolean;\n  boundsIJK: BoundsIJK;\n  overlapType?: number;\n  segmentIndex?: number;\n};\n\n/**\n * It thresholds a segmentation volume based on a set of threshold values with\n * respect to a list of volumes and respective threshold ranges.\n * @param segmentationVolume - the segmentation volume to be modified\n * @param thresholdVolumeInformation - array of objects containing volume data\n * and a range (lower and upper values) to threshold\n * @param options - the options for thresholding\n * As there is a chance the volumes might have different dimensions and spacing,\n * could be the case of no 1 to 1 mapping. So we need to work with the idea of\n * voxel overlaps (1 to many mappings). We consider all intersections valid, to\n * avoid the complexity to calculate a minimum voxel intersection percentage.\n * This function, given a voxel center and spacing, calculates the overlap of\n * the voxel with another volume and range check the voxels in the overlap.\n * Three situations can occur: all voxels pass the range check, some voxels pass\n * or none voxels pass. The overlapType parameter indicates if the user requires\n * all voxels pass (overlapType = 1) or any voxel pass (overlapType = 0)\n *\n * @returns segmented volume\n */\nfunction thresholdVolumeByRange(\n  segmentationVolume: Types.IImageVolume,\n  thresholdVolumeInformation: ThresholdInformation[],\n  options: ThresholdRangeOptions\n): Types.IImageVolume {\n  const { imageData: segmentationImageData } = segmentationVolume;\n  const scalarData = segmentationVolume.getScalarData();\n\n  const { overwrite, boundsIJK } = options;\n  const overlapType = options?.overlapType || 0;\n\n  // set the segmentation to all zeros\n  if (overwrite) {\n    for (let i = 0; i < scalarData.length; i++) {\n      scalarData[i] = 0;\n    }\n  }\n\n  const { baseVolumeIdx, volumeInfoList } = processVolumes(\n    segmentationVolume,\n    thresholdVolumeInformation\n  );\n\n  // global variables used in callbackOverlap function\n  let overlaps, total, range;\n\n  const testOverlapRange = (volumeInfo, voxelSpacing, voxelCenter) => {\n    /**\n     * This callback function will test all overlaps between a voxel in base\n     * volume (the reference for segmentation volume creation) and voxels in other\n     * volumes.\n     */\n    const callbackOverlap = ({ value }) => {\n      total = total + 1;\n      if (value >= range.lower && value <= range.upper) {\n        overlaps = overlaps + 1;\n      }\n    };\n\n    const { imageData, dimensions, lower, upper } = volumeInfo;\n\n    const overlapBounds = getVoxelOverlap(\n      imageData,\n      dimensions,\n      voxelSpacing,\n      voxelCenter\n    );\n\n    // reset global variables and setting the range check\n    total = 0;\n    overlaps = 0;\n    range = { lower, upper };\n\n    let overlapTest = false;\n\n    // check all voxel overlaps\n    pointInShapeCallback(imageData, () => true, callbackOverlap, overlapBounds);\n\n    if (overlapType === 0) {\n      overlapTest = overlaps > 0; // any voxel overlap is accepted\n    } else if (overlapType == 1) {\n      overlapTest = overlaps === total; // require all voxel overlaps\n    }\n    return overlapTest;\n  };\n\n  // range checks a voxel in a volume with same dimension as the segmentation\n  const testRange = (volumeInfo, pointIJK) => {\n    const { imageData, referenceValues, lower, upper } = volumeInfo;\n    const offset = imageData.computeOffsetIndex(pointIJK);\n\n    const value = referenceValues[offset];\n    if (value <= lower || value >= upper) {\n      return false;\n    } else {\n      return true;\n    }\n  };\n\n  /**\n   * This callback function will test all overlaps between a voxel in base\n   * volume (the reference for segmentation volume creation) and voxels in other\n   * volumes.\n   */\n  const callback = ({ index, pointIJK, pointLPS }) => {\n    let insert = volumeInfoList.length > 0;\n    for (let i = 0; i < volumeInfoList.length; i++) {\n      // if volume has the same size as segmentation volume, just range check\n      if (volumeInfoList[i].volumeSize === scalarData.length) {\n        insert = testRange(volumeInfoList[i], pointIJK);\n      } else {\n        // if not, need to calculate overlaps\n        insert = testOverlapRange(\n          volumeInfoList[i],\n          volumeInfoList[baseVolumeIdx].spacing,\n          pointLPS\n        );\n      }\n      if (!insert) {\n        break;\n      }\n    }\n\n    if (insert) {\n      scalarData[index] = options.segmentIndex || 1;\n    }\n  };\n\n  pointInShapeCallback(segmentationImageData, () => true, callback, boundsIJK);\n\n  triggerSegmentationDataModified(segmentationVolume.volumeId);\n\n  return segmentationVolume;\n}\n\nexport default thresholdVolumeByRange;\n","import { Types } from '@cornerstonejs/core';\nimport { utilities as csUtils } from '@cornerstonejs/core';\nimport { getToolGroup } from '../../store/ToolGroupManager';\nimport BrushTool from '../../tools/segmentation/BrushTool';\nimport { getBoundingBoxAroundShapeIJK } from '../boundingBox/getBoundingBoxAroundShape';\n\nexport type ThresholdInformation = {\n  volume: Types.IImageVolume;\n  lower: number;\n  upper: number;\n};\n\nexport function getBrushToolInstances(toolGroupId: string, toolName?: string) {\n  const toolGroup = getToolGroup(toolGroupId);\n\n  if (toolGroup === undefined) {\n    return;\n  }\n\n  const toolInstances = toolGroup._toolInstances;\n\n  if (!Object.keys(toolInstances).length) {\n    return;\n  }\n\n  if (toolName && toolInstances[toolName]) {\n    return [toolInstances[toolName]];\n  }\n\n  // For each tool that has BrushTool as base class, set the brush size.\n  const brushBasedToolInstances = Object.values(toolInstances).filter(\n    (toolInstance) => toolInstance instanceof BrushTool\n  ) as BrushTool[];\n\n  return brushBasedToolInstances;\n}\n\nconst equalsCheck = (a, b) => {\n  return JSON.stringify(a) === JSON.stringify(b);\n};\n\n/**\n * Given the center of a voxel in world coordinates, calculate the voxel\n * corners in world coords to calculate the voxel overlap in another volume\n */\nexport function getVoxelOverlap(\n  imageData,\n  dimensions,\n  voxelSpacing,\n  voxelCenter\n) {\n  const voxelCornersWorld = [];\n  for (let i = 0; i < 2; i++) {\n    for (let j = 0; j < 2; j++) {\n      for (let k = 0; k < 2; k++) {\n        const point = [...voxelCenter]; // Create a new point from voxelCenter\n        point[0] = point[0] + ((i * 2 - 1) * voxelSpacing[0]) / 2;\n        point[1] = point[1] + ((j * 2 - 1) * voxelSpacing[1]) / 2;\n        point[2] = point[2] + ((k * 2 - 1) * voxelSpacing[2]) / 2;\n        voxelCornersWorld.push(point);\n      }\n    }\n  }\n  const voxelCornersIJK = voxelCornersWorld.map(\n    (world) => csUtils.transformWorldToIndex(imageData, world) as Types.Point3\n  );\n  const overlapBounds = getBoundingBoxAroundShapeIJK(\n    voxelCornersIJK,\n    dimensions\n  );\n\n  return overlapBounds;\n}\n\n/**\n * Prepare a list of volume information objects for callback functions\n */\nexport function processVolumes(\n  segmentationVolume: Types.IImageVolume,\n  thresholdVolumeInformation: ThresholdInformation[]\n) {\n  const { spacing: segmentationSpacing } = segmentationVolume;\n  const scalarData = segmentationVolume.getScalarData();\n\n  // prepare a list of volume information objects for callback functions\n  const volumeInfoList = [];\n  let baseVolumeIdx = 0;\n  for (let i = 0; i < thresholdVolumeInformation.length; i++) {\n    const { imageData, spacing, dimensions } =\n      thresholdVolumeInformation[i].volume;\n\n    const volumeSize =\n      thresholdVolumeInformation[i].volume.getScalarData().length;\n    // discover the index of the volume the segmentation data is based on\n    if (\n      volumeSize === scalarData.length &&\n      equalsCheck(spacing, segmentationSpacing)\n    ) {\n      baseVolumeIdx = i;\n    }\n\n    // prepare information used in callback functions\n    const referenceValues = imageData.getPointData().getScalars().getData();\n    const lower = thresholdVolumeInformation[i].lower;\n    const upper = thresholdVolumeInformation[i].upper;\n\n    volumeInfoList.push({\n      imageData,\n      referenceValues,\n      lower,\n      upper,\n      spacing,\n      dimensions,\n      volumeSize,\n    });\n  }\n\n  return {\n    volumeInfoList,\n    baseVolumeIdx,\n  };\n}\n","import {\n  imageLoader,\n  Enums,\n  eventTarget,\n  imageLoadPoolManager,\n  cache,\n  getConfiguration as getCoreConfiguration,\n} from '@cornerstonejs/core';\nimport { addToolState, getToolState } from './state';\nimport {\n  getStackData,\n  requestType,\n  priority,\n  getPromiseRemovedHandler,\n  nearestIndex,\n  range,\n} from './stackPrefetchUtils';\n\nlet configuration = {\n  maxImagesToPrefetch: Infinity,\n  // Preserving the existing pool should be the default behaviour, as there might\n  // be a volume of the same series already being loaded in the pool, and we don't want\n  // to cancel it middle of the way when the other stack viewport mounts. Worst case scenario\n  // there will be a few extra images in the pool but by the time that their turn comes\n  // we will have already loaded the volume and it will get read from the CACHE,\n  // so who cares\n  preserveExistingPool: true,\n};\n\nlet resetPrefetchTimeout;\nconst resetPrefetchDelay = 10;\n\nfunction prefetch(element) {\n  // Get the stackPrefetch tool data\n  const stackPrefetchData = getToolState(element);\n\n  if (!stackPrefetchData) {\n    return;\n  }\n\n  const stackPrefetch = stackPrefetchData || {};\n  const stack = getStackData(element);\n\n  if (!stack?.imageIds?.length) {\n    console.warn('CornerstoneTools.stackPrefetch: No images in stack.');\n    return;\n  }\n\n  const { currentImageIdIndex } = stack;\n\n  // If all the requests are complete, disable the stackPrefetch tool\n  stackPrefetch.enabled &&= stackPrefetch.indicesToRequest?.length;\n\n  // Make sure the tool is still enabled\n  if (stackPrefetch.enabled === false) {\n    return;\n  }\n\n  // Remove an imageIdIndex from the list of indices to request\n  // This fires when the individual image loading deferred is resolved\n  function removeFromList(imageIdIndex) {\n    const index = stackPrefetch.indicesToRequest.indexOf(imageIdIndex);\n\n    if (index > -1) {\n      // Don't remove last element if imageIdIndex not found\n      stackPrefetch.indicesToRequest.splice(index, 1);\n    }\n  }\n\n  // Remove all already cached images from the\n  // IndicesToRequest array\n  stackPrefetchData.indicesToRequest.sort((a, b) => a - b);\n  const indicesToRequestCopy = stackPrefetch.indicesToRequest.slice();\n\n  indicesToRequestCopy.forEach(function (imageIdIndex) {\n    const imageId = stack.imageIds[imageIdIndex];\n\n    if (!imageId) {\n      return;\n    }\n\n    const distance = Math.abs(currentImageIdIndex - imageIdIndex);\n    // For nearby objects, ensure the last accessed time is updated\n    // by using getImageLoadObject.\n    // For more distant objects, just check if available, but dont\n    // change the access time.\n    // This allows throwing data that hasn't been accessed and is not\n    // nearby.\n    const imageCached =\n      distance < 6\n        ? cache.getImageLoadObject(imageId)\n        : cache.isLoaded(imageId);\n\n    if (imageCached) {\n      // Already in cache\n      removeFromList(imageIdIndex);\n    }\n  });\n\n  // Stop here if there are no images left to request\n  // After those in the cache have been removed\n  if (!stackPrefetch.indicesToRequest.length) {\n    return;\n  }\n\n  // Clear the requestPool of prefetch requests, if needed.\n  if (!configuration.preserveExistingPool) {\n    imageLoadPoolManager.clearRequestStack(requestType);\n  }\n\n  // Identify the nearest imageIdIndex to the currentImageIdIndex\n  const nearest = nearestIndex(\n    stackPrefetch.indicesToRequest,\n    stack.currentImageIdIndex\n  );\n\n  let imageId;\n  let nextImageIdIndex;\n  const preventCache = false;\n\n  function doneCallback(image) {\n    console.log('prefetch done: %s', image.imageId);\n    const imageIdIndex = stack.imageIds.indexOf(image.imageId);\n\n    removeFromList(imageIdIndex);\n  }\n\n  // Prefetch images around the current image (before and after)\n  let lowerIndex = nearest.low;\n  let higherIndex = nearest.high;\n  const imageIdsToPrefetch = [];\n\n  while (\n    lowerIndex >= 0 ||\n    higherIndex < stackPrefetch.indicesToRequest.length\n  ) {\n    const currentIndex = stack.currentImageIdIndex;\n    const shouldSkipLower =\n      currentIndex - stackPrefetch.indicesToRequest[lowerIndex] >\n      configuration.maxImagesToPrefetch;\n    const shouldSkipHigher =\n      stackPrefetch.indicesToRequest[higherIndex] - currentIndex >\n      configuration.maxImagesToPrefetch;\n\n    const shouldLoadLower = !shouldSkipLower && lowerIndex >= 0;\n    const shouldLoadHigher =\n      !shouldSkipHigher && higherIndex < stackPrefetch.indicesToRequest.length;\n\n    if (!shouldLoadHigher && !shouldLoadLower) {\n      break;\n    }\n\n    if (shouldLoadLower) {\n      nextImageIdIndex = stackPrefetch.indicesToRequest[lowerIndex--];\n      imageId = stack.imageIds[nextImageIdIndex];\n      imageIdsToPrefetch.push(imageId);\n    }\n\n    if (shouldLoadHigher) {\n      nextImageIdIndex = stackPrefetch.indicesToRequest[higherIndex++];\n      imageId = stack.imageIds[nextImageIdIndex];\n      imageIdsToPrefetch.push(imageId);\n    }\n  }\n\n  const requestFn = (imageId, options) =>\n    imageLoader.loadAndCacheImage(imageId, options);\n\n  const { useNorm16Texture, preferSizeOverAccuracy } =\n    getCoreConfiguration().rendering;\n\n  const useNativeDataType = useNorm16Texture || preferSizeOverAccuracy;\n\n  imageIdsToPrefetch.forEach((imageId) => {\n    // IMPORTANT: Request type should be passed if not the 'interaction'\n    // highest priority will be used for the request type in the imageRetrievalPool\n    const options = {\n      targetBuffer: {\n        type: useNativeDataType ? undefined : 'Float32Array',\n      },\n      preScale: {\n        enabled: true,\n      },\n      useNativeDataType,\n      requestType,\n    };\n\n    imageLoadPoolManager.addRequest(\n      requestFn.bind(null, imageId, options),\n      requestType,\n      // Additional details\n      {\n        imageId,\n      },\n      priority\n      // addToBeginning\n    );\n  });\n}\n\nfunction onImageUpdated(e) {\n  // Start prefetching again (after a delay)\n  // When the user has scrolled to a new image\n  clearTimeout(resetPrefetchTimeout);\n  resetPrefetchTimeout = setTimeout(function () {\n    const element = e.target;\n\n    // If playClip is enabled and the user loads a different series in the viewport\n    // An exception will be thrown because the element will not be enabled anymore\n    try {\n      prefetch(element);\n    } catch (error) {\n      return;\n    }\n  }, resetPrefetchDelay);\n}\n\nfunction enable(element) {\n  const stack = getStackData(element);\n\n  if (!stack || !stack.imageIds || stack.imageIds.length === 0) {\n    console.warn('CornerstoneTools.stackPrefetch: No images in stack.');\n    return;\n  }\n\n  // Use the currentImageIdIndex from the stack as the initialImageIdIndex\n  const stackPrefetchData = {\n    indicesToRequest: range(0, stack.imageIds.length - 1),\n    enabled: true,\n    direction: 1,\n  };\n\n  // Remove the currentImageIdIndex from the list to request\n  const indexOfCurrentImage = stackPrefetchData.indicesToRequest.indexOf(\n    stack.currentImageIdIndex\n  );\n\n  stackPrefetchData.indicesToRequest.splice(indexOfCurrentImage, 1);\n\n  addToolState(element, stackPrefetchData);\n\n  prefetch(element);\n\n  element.removeEventListener(Enums.Events.STACK_NEW_IMAGE, onImageUpdated);\n  element.addEventListener(Enums.Events.STACK_NEW_IMAGE, onImageUpdated);\n\n  const promiseRemovedHandler = getPromiseRemovedHandler(element);\n\n  eventTarget.removeEventListener(\n    Enums.Events.IMAGE_CACHE_IMAGE_REMOVED,\n    promiseRemovedHandler\n  );\n  eventTarget.addEventListener(\n    Enums.Events.IMAGE_CACHE_IMAGE_REMOVED,\n    promiseRemovedHandler\n  );\n}\n\nfunction disable(element) {\n  clearTimeout(resetPrefetchTimeout);\n  element.removeEventListener(Enums.Events.STACK_NEW_IMAGE, onImageUpdated);\n\n  const promiseRemovedHandler = getPromiseRemovedHandler(element);\n\n  eventTarget.removeEventListener(\n    Enums.Events.IMAGE_CACHE_IMAGE_REMOVED,\n    promiseRemovedHandler\n  );\n\n  const stackPrefetchData = getToolState(element);\n  // If there is actually something to disable, disable it\n\n  if (stackPrefetchData && stackPrefetchData.indicesToRequest.length) {\n    stackPrefetchData.enabled = false;\n\n    // Clear current prefetch requests from the requestPool\n    imageLoadPoolManager.clearRequestStack(requestType);\n  }\n}\n\nfunction getConfiguration() {\n  return configuration;\n}\n\nfunction setConfiguration(config) {\n  configuration = config;\n}\n\nconst stackPrefetch = { enable, disable, getConfiguration, setConfiguration };\n\nexport default stackPrefetch;\n","import {\n  imageLoader,\n  Enums,\n  eventTarget,\n  imageLoadPoolManager,\n  cache,\n  getConfiguration as getCoreConfiguration,\n} from '@cornerstonejs/core';\nimport { addToolState, getToolState } from './state';\nimport {\n  getStackData,\n  requestType,\n  priority,\n  clearFromImageIds,\n  getPromiseRemovedHandler,\n} from './stackPrefetchUtils';\nimport { roundNumber } from '../../utilities';\n\nlet configuration = {\n  maxImagesToPrefetch: Infinity,\n  // Fetch up to 2 image before and after\n  minBefore: 2,\n  maxAfter: 2,\n  // Increment the cache size by 10 images\n  directionExtraImages: 10,\n  preserveExistingPool: false,\n};\n\nlet resetPrefetchTimeout;\n// Starting the prefetch quickly isn't an issue as the main image is already being\n// loaded, so a 5 ms prefetch delay is fine\nconst resetPrefetchDelay = 5;\n\n/**\n * Call this to enable stack context sensitive prefetch.  Should be called\n * before stack data is set in order to start prefetch after load first image.\n * This will add a STACK_NEW_IMAGE to detect when a new image is displayed, and then\n * update the prefetch stack.  The context sensitive prefetch reacts to the\n * initial display, or significant moves, the already loaded images, the\n * cache size and the direction of navigation.  The behaviour is:\n *\n * 1. On navigating to a new image initially, or one that is at a different position:\n *  * Fetch the next/previous 2 images\n * 2. If the user is navigating forward/backward by less than 5 images, then\n *  * Prefetch additional images in the direction of navigation, up to 100\n * 3. If all the images in a given prefetch have completed, then:\n *  * Use the last prefetched image size as an image size for the stack\n *  * Fetch up to 1/4 of the cache size images near the current image\n *\n * This is designed to:\n *   * Get nearby images immediately so that they are available for navigation\n *     * Under the assumption that users might click and view an image, then\n *       navigate to next/previous image to see the exact image they want\n *   * Not interfere with loading other viewports if they are still loading\n *     * Load priority is prefetch, and minimal images are requested initially\n *   * Load an entire series if it will fit in memory\n *     * Allows navigating to other parts of the series and display images immediately\n *   * Have images available for CINE/navigation in one direction even when\n *     there is more image data than will fit in memory.\n *     * Up to 100 images in the direction of travel will be prefetched\n *\n * @param element - to prefetch on\n */\nconst enable = (element): void => {\n  const stack = getStackData(element);\n\n  if (!stack || !stack.imageIds || stack.imageIds.length === 0) {\n    console.warn('CornerstoneTools.stackPrefetch: No images in stack.');\n    return;\n  }\n\n  updateToolState(element);\n\n  prefetch(element);\n\n  element.removeEventListener(Enums.Events.STACK_NEW_IMAGE, onImageUpdated);\n  element.addEventListener(Enums.Events.STACK_NEW_IMAGE, onImageUpdated);\n\n  const promiseRemovedHandler = getPromiseRemovedHandler(element);\n\n  eventTarget.removeEventListener(\n    Enums.Events.IMAGE_CACHE_IMAGE_REMOVED,\n    promiseRemovedHandler\n  );\n  eventTarget.addEventListener(\n    Enums.Events.IMAGE_CACHE_IMAGE_REMOVED,\n    promiseRemovedHandler\n  );\n};\n\nfunction prefetch(element) {\n  const stack = getStackData(element);\n  if (!stack?.imageIds?.length) {\n    console.warn('CornerstoneTools.stackPrefetch: No images in stack.');\n    return;\n  }\n\n  // Get the stackPrefetch tool data\n  const stackPrefetchData = getToolState(element);\n\n  if (!stackPrefetchData) {\n    return;\n  }\n\n  const stackPrefetch = stackPrefetchData || {};\n\n  // If all the requests are complete, disable the stackPrefetch tool\n  stackPrefetch.enabled &&= stackPrefetch.indicesToRequest?.length;\n\n  // Make sure the tool is still enabled\n  if (stackPrefetch.enabled === false) {\n    return;\n  }\n\n  // Remove an imageIdIndex from the list of indices to request\n  // This fires when the individual image loading deferred is resolved\n  function removeFromList(imageIdIndex) {\n    const index = stackPrefetch.indicesToRequest.indexOf(imageIdIndex);\n\n    if (index > -1) {\n      // Don't remove last element if imageIdIndex not found\n      stackPrefetch.indicesToRequest.splice(index, 1);\n    }\n  }\n\n  // Remove all already cached images from the\n  // IndicesToRequest array.\n  const indicesToRequestCopy = stackPrefetch.indicesToRequest.slice();\n  const { currentImageIdIndex } = stack;\n\n  indicesToRequestCopy.forEach((imageIdIndex) => {\n    const imageId = stack.imageIds[imageIdIndex];\n\n    if (!imageId) {\n      return;\n    }\n\n    const distance = Math.abs(currentImageIdIndex - imageIdIndex);\n    // For nearby objects, ensure the last accessed time is updated\n    // by using getImageLoadObject.\n    // For more distant objects, just check if available, but dont\n    // change the access time.\n    // This allows throwing data that hasn't been accessed and is not\n    // nearby.\n    const imageCached =\n      distance < 6\n        ? cache.getImageLoadObject(imageId)\n        : cache.isLoaded(imageId);\n\n    if (imageCached) {\n      // Already in cache\n      removeFromList(imageIdIndex);\n    }\n  });\n\n  // Stop here if there are no images left to request\n  // After those in the cache have been removed\n  if (!stackPrefetch.indicesToRequest.length) {\n    return;\n  }\n\n  // Clear the requestPool of prefetch requests, if needed.\n  if (!configuration.preserveExistingPool) {\n    imageLoadPoolManager.filterRequests(clearFromImageIds(stack));\n  }\n\n  function doneCallback(imageId) {\n    const imageIdIndex = stack.imageIds.indexOf(imageId);\n\n    removeFromList(imageIdIndex);\n    const image = cache.getCachedImageBasedOnImageURI(imageId);\n    const { stats } = stackPrefetch;\n    const decodeTimeInMS = image?.image?.decodeTimeInMS || 0;\n    if (decodeTimeInMS) {\n      stats.imageIds.set(imageId, decodeTimeInMS);\n      stats.decodeTimeInMS += decodeTimeInMS;\n      const loadTimeInMS = image?.image?.loadTimeInMS || 0;\n      stats.loadTimeInMS += loadTimeInMS;\n    }\n\n    if (!stackPrefetch.indicesToRequest.length) {\n      if (image?.sizeInBytes) {\n        const { sizeInBytes } = image;\n        const usage = cache.getMaxCacheSize() / 4 / sizeInBytes;\n        if (!stackPrefetch.cacheFill) {\n          stats.initialTime = Date.now() - stats.start;\n          stats.initialSize = stats.imageIds.size;\n          updateToolState(element, usage);\n          prefetch(element);\n        } else if (stats.imageIds.size) {\n          stats.fillTime = Date.now() - stats.start;\n          const { size } = stats.imageIds;\n          stats.fillSize = size;\n          console.log(\n            'Done cache fill',\n            stats.fillTime,\n            'ms',\n            size,\n            'items',\n            'average total time',\n            roundNumber(stats.fillTime / size),\n            'ms',\n            'average load',\n            roundNumber(stats.loadTimeInMS / size),\n            'ms',\n            'average decode',\n            roundNumber(stats.decodeTimeInMS / size),\n            'ms'\n          );\n        }\n      }\n    }\n  }\n\n  const requestFn = (imageId, options) =>\n    imageLoader\n      .loadAndCacheImage(imageId, options)\n      .then(() => doneCallback(imageId));\n\n  const { useNorm16Texture, preferSizeOverAccuracy } =\n    getCoreConfiguration().rendering;\n\n  const useNativeDataType = useNorm16Texture || preferSizeOverAccuracy;\n\n  indicesToRequestCopy.forEach((imageIdIndex) => {\n    const imageId = stack.imageIds[imageIdIndex];\n    // IMPORTANT: Request type should be passed if not the 'interaction'\n    // highest priority will be used for the request type in the imageRetrievalPool\n    const options = {\n      targetBuffer: {\n        type: useNativeDataType ? undefined : 'Float32Array',\n      },\n      preScale: {\n        enabled: true,\n      },\n      useNativeDataType,\n      requestType,\n    };\n\n    imageLoadPoolManager.addRequest(\n      requestFn.bind(null, imageId, options),\n      requestType,\n      // Additional details\n      {\n        imageId,\n      },\n      priority\n      // addToBeginning\n    );\n  });\n}\n\nfunction onImageUpdated(e) {\n  // Start prefetching again (after a delay)\n  // When the user has scrolled to a new image\n  clearTimeout(resetPrefetchTimeout);\n  resetPrefetchTimeout = setTimeout(function () {\n    const element = e.target;\n\n    // If playClip is enabled and the user loads a different series in the viewport\n    // An exception will be thrown because the element will not be enabled anymore\n    try {\n      updateToolState(element);\n      prefetch(element);\n    } catch (error) {\n      return;\n    }\n  }, resetPrefetchDelay);\n}\n\n// Not a full signum, but good enough for direction.\nconst signum = (x) => (x < 0 ? -1 : 1);\n\nconst updateToolState = (element, usage?: number) => {\n  const stack = getStackData(element);\n  if (!stack || !stack.imageIds || stack.imageIds.length === 0) {\n    console.warn('CornerstoneTools.stackPrefetch: No images in stack.');\n    return;\n  }\n\n  const { currentImageIdIndex } = stack;\n  let { maxAfter = 2, minBefore = 2 } = configuration;\n  const { directionExtraImages = 10 } = configuration;\n  // Use the currentImageIdIndex from the stack as the initialImageIdIndex\n  const stackPrefetchData = getToolState(element) || {\n    indicesToRequest: [],\n    currentImageIdIndex,\n    stackCount: 0,\n    enabled: true,\n    direction: 1,\n    stats: {\n      start: Date.now(),\n      imageIds: new Map(),\n      decodeTimeInMS: 0,\n      loadTimeInMS: 0,\n      totalBytes: 0,\n    },\n  };\n  const delta = currentImageIdIndex - stackPrefetchData.currentImageIdIndex;\n  stackPrefetchData.direction = signum(delta);\n  stackPrefetchData.currentImageIdIndex = currentImageIdIndex;\n  stackPrefetchData.enabled = true;\n\n  if (stackPrefetchData.stackCount < 100) {\n    stackPrefetchData.stackCount += directionExtraImages;\n  }\n\n  if (Math.abs(delta) > maxAfter || !delta) {\n    // Not incrementing by 1, so stop increasing the data size\n    // TODO - consider reversing the CINE playback\n    stackPrefetchData.stackCount = 0;\n    if (usage) {\n      // The usage of the cache that this stack can use\n      const positionFraction = currentImageIdIndex / stack.imageIds.length;\n      minBefore = Math.ceil(usage * positionFraction);\n      maxAfter = Math.ceil(usage * (1 - positionFraction));\n      stackPrefetchData.cacheFill = true;\n    } else {\n      stackPrefetchData.cacheFill = false;\n    }\n  } else if (delta < 0) {\n    minBefore += stackPrefetchData.stackCount;\n    maxAfter = 0;\n  } else {\n    maxAfter += stackPrefetchData.stackCount;\n    minBefore = 0;\n  }\n\n  const minIndex = Math.max(0, currentImageIdIndex - minBefore);\n\n  const maxIndex = Math.min(\n    stack.imageIds.length - 1,\n    currentImageIdIndex + maxAfter\n  );\n\n  // Order these correctly initially\n  const indicesToRequest = [];\n  for (let i = currentImageIdIndex + 1; i <= maxIndex; i++) {\n    indicesToRequest.push(i);\n  }\n  for (let i = currentImageIdIndex - 1; i >= minIndex; i--) {\n    indicesToRequest.push(i);\n  }\n  stackPrefetchData.indicesToRequest = indicesToRequest;\n\n  addToolState(element, stackPrefetchData);\n};\n\nfunction disable(element) {\n  clearTimeout(resetPrefetchTimeout);\n  element.removeEventListener(Enums.Events.STACK_NEW_IMAGE, onImageUpdated);\n\n  const promiseRemovedHandler = getPromiseRemovedHandler(element);\n\n  eventTarget.removeEventListener(\n    Enums.Events.IMAGE_CACHE_IMAGE_REMOVED,\n    promiseRemovedHandler\n  );\n\n  const stackPrefetchData = getToolState(element);\n  // If there is actually something to disable, disable it\n\n  if (stackPrefetchData && stackPrefetchData.data.length) {\n    stackPrefetchData.enabled = false;\n    // Don't worry about clearing the requests - there aren't that many too be bothersome\n  }\n}\n\nfunction getConfiguration() {\n  return configuration;\n}\n\nfunction setConfiguration(config) {\n  configuration = config;\n}\n\nconst stackContextPrefetch = {\n  enable,\n  disable,\n  getConfiguration,\n  setConfiguration,\n};\n\nexport default stackContextPrefetch;\n","import debounce from './debounce';\nimport isObject from './isObject';\n\n/**\n * Creates a throttled function that only invokes `func` at most once per\n * every `wait` milliseconds (or once per browser frame). The throttled function\n * comes with a `cancel` method to cancel delayed `func` invocations and a\n * `flush` method to immediately invoke them. Provide `options` to indicate\n * whether `func` should be invoked on the leading and/or trailing edge of the\n * `wait` timeout. The `func` is invoked with the last arguments provided to the\n * throttled function. Subsequent calls to the throttled function return the\n * result of the last `func` invocation.\n *\n * **Note:** If `leading` and `trailing` options are `true`, `func` is\n * invoked on the trailing edge of the timeout only if the throttled function\n * is invoked more than once during the `wait` timeout.\n *\n * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n * until the next tick, similar to `setTimeout` with a timeout of `0`.\n *\n * If `wait` is omitted in an environment with `requestAnimationFrame`, `func`\n * invocation will be deferred until the next frame is drawn (typically about\n * 16ms).\n *\n * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n * for details over the differences between `throttle` and `debounce`.\n *\n * @param {Function} func The function to throttle.\n * @param {number} [wait=0]\n *  The number of milliseconds to throttle invocations to; if omitted,\n *  `requestAnimationFrame` is used (if available).\n * @param {Object} [options={}] The options object.\n * @param {boolean} [options.leading=true]\n *  Specify invoking on the leading edge of the timeout.\n * @param {boolean} [options.trailing=true]\n *  Specify invoking on the trailing edge of the timeout.\n * @returns {Function} Returns the new throttled function.\n * @example\n *\n * // Avoid excessively updating the position while scrolling.\n * jQuery(window).on('scroll', throttle(updatePosition, 100))\n *\n * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.\n * const throttled = throttle(renewToken, 300000, { 'trailing': false })\n * jQuery(element).on('click', throttled)\n *\n * // Cancel the trailing throttled invocation.\n * jQuery(window).on('popstate', throttled.cancel)\n */\nfunction throttle(func, wait, options) {\n  let leading = true;\n  let trailing = true;\n\n  if (typeof func !== 'function') {\n    throw new TypeError('Expected a function');\n  }\n  if (isObject(options)) {\n    leading = 'leading' in options ? Boolean(options.leading) : leading;\n    trailing = 'trailing' in options ? Boolean(options.trailing) : trailing;\n  }\n\n  return debounce(func, wait, {\n    leading,\n    trailing,\n    maxWait: wait,\n  });\n}\n\nexport default throttle;\n","import { IDistance, IPoints, ITouchPoints } from '../../types';\nimport { Types } from '@cornerstonejs/core';\n\n/**\n * Returns the difference between multiple `IPoints` instances.\n * @param currentPoints - The current points.\n * @param lastPoints - The last points, to be subtracted from the `currentPoints`.\n *\n * @returns The difference in IPoints format\n */\nfunction getDeltaPoints(\n  currentPoints: IPoints[],\n  lastPoints: IPoints[]\n): IPoints {\n  const curr = getMeanPoints(currentPoints);\n  const last = getMeanPoints(lastPoints);\n  return {\n    page: _subtractPoints2D(curr.page, last.page),\n    client: _subtractPoints2D(curr.client, last.client),\n    canvas: _subtractPoints2D(curr.canvas, last.canvas),\n    world: _subtractPoints3D(curr.world, last.world),\n  };\n}\n\n/**\n * Returns the distance between multiple `IPoints` instances.\n * @param currentPoints - The current points.\n * @param lastPoints - The last points, to be subtracted from the `currentPoints`.\n *\n * @returns The distance difference in IDistance format\n */\nfunction getDeltaDistance(\n  currentPoints: IPoints[],\n  lastPoints: IPoints[]\n): IDistance {\n  const curr = getMeanPoints(currentPoints);\n  const last = getMeanPoints(lastPoints);\n  return {\n    page: _getDistance2D(curr.page, last.page),\n    client: _getDistance2D(curr.client, last.client),\n    canvas: _getDistance2D(curr.canvas, last.canvas),\n    world: _getDistance3D(curr.world, last.world),\n  };\n}\n\nfunction getDeltaRotation(\n  currentPoints: ITouchPoints[],\n  lastPoints: ITouchPoints[]\n) {\n  // TODO\n}\n\n/**\n * Returns the distance difference between multiple `IPoints` instances.\n * @param currentPoints - The current points.\n * @param lastPoints -- The last points.\n *\n * @returns The difference in IPoints format\n */\nfunction getDeltaDistanceBetweenIPoints(\n  currentPoints: IPoints[],\n  lastPoints: IPoints[]\n): IDistance {\n  const currentDistance = _getMeanDistanceBetweenAllIPoints(currentPoints);\n  const lastDistance = _getMeanDistanceBetweenAllIPoints(lastPoints);\n  const deltaDistance = {\n    page: currentDistance.page - lastDistance.page,\n    client: currentDistance.client - lastDistance.client,\n    canvas: currentDistance.canvas - lastDistance.canvas,\n    world: currentDistance.world - lastDistance.world,\n  };\n  return deltaDistance;\n}\n\n/**\n * Copies a set of points.\n * @param points - The `IPoints` instance to copy.\n *\n * @returns A copy of the points.\n */\nfunction copyPointsList(points: ITouchPoints[]): ITouchPoints[] {\n  return JSON.parse(JSON.stringify(points));\n}\n\nfunction copyPoints(points: ITouchPoints): ITouchPoints {\n  return JSON.parse(JSON.stringify(points));\n}\n\nfunction getMeanPoints(points: IPoints[]): IPoints {\n  return points.reduce(\n    (prev, curr) => {\n      return {\n        page: [\n          prev.page[0] + curr.page[0] / points.length,\n          prev.page[1] + curr.page[1] / points.length,\n        ],\n        client: [\n          prev.client[0] + curr.client[0] / points.length,\n          prev.client[1] + curr.client[1] / points.length,\n        ],\n        canvas: [\n          prev.canvas[0] + curr.canvas[0] / points.length,\n          prev.canvas[1] + curr.canvas[1] / points.length,\n        ],\n        world: [\n          prev.world[0] + curr.world[0] / points.length,\n          prev.world[1] + curr.world[1] / points.length,\n          prev.world[2] + curr.world[2] / points.length,\n        ],\n      };\n    },\n    {\n      page: [0, 0],\n      client: [0, 0],\n      canvas: [0, 0],\n      world: [0, 0, 0],\n    }\n  );\n}\n\nfunction getMeanTouchPoints(points: ITouchPoints[]): ITouchPoints {\n  return points.reduce(\n    (prev, curr) => {\n      return {\n        page: [\n          prev.page[0] + curr.page[0] / points.length,\n          prev.page[1] + curr.page[1] / points.length,\n        ],\n        client: [\n          prev.client[0] + curr.client[0] / points.length,\n          prev.client[1] + curr.client[1] / points.length,\n        ],\n        canvas: [\n          prev.canvas[0] + curr.canvas[0] / points.length,\n          prev.canvas[1] + curr.canvas[1] / points.length,\n        ],\n        world: [\n          prev.world[0] + curr.world[0] / points.length,\n          prev.world[1] + curr.world[1] / points.length,\n          prev.world[2] + curr.world[2] / points.length,\n        ],\n        touch: {\n          identifier: null,\n          radiusX: prev.touch.radiusX + curr.touch.radiusX / points.length,\n          radiusY: prev.touch.radiusY + curr.touch.radiusY / points.length,\n          force: prev.touch.force + curr.touch.force / points.length,\n          rotationAngle:\n            prev.touch.rotationAngle + curr.touch.rotationAngle / points.length,\n        },\n      };\n    },\n    {\n      page: [0, 0],\n      client: [0, 0],\n      canvas: [0, 0],\n      world: [0, 0, 0],\n      touch: {\n        identifier: null,\n        radiusX: 0,\n        radiusY: 0,\n        force: 0,\n        rotationAngle: 0,\n      },\n    }\n  );\n}\n/**\n * _subtractPoints - Subtracts `point1` from `point0`.\n * @param point0 - The first point.\n * @param point1 - The second point to subtract from the first.\n *\n * @returns The difference.\n */\nfunction _subtractPoints2D(\n  point0: Types.Point2,\n  point1: Types.Point2\n): Types.Point2 {\n  return [point0[0] - point1[0], point0[1] - point1[1]];\n}\n\nfunction _subtractPoints3D(\n  point0: Types.Point3,\n  point1: Types.Point3\n): Types.Point3 {\n  return [point0[0] - point1[0], point0[1] - point1[1], point0[2] - point1[2]];\n}\n\nfunction _getMeanDistanceBetweenAllIPoints(points: IPoints[]): IDistance {\n  // get mean distance between all unordered pairs of points\n  const pairedDistance: IDistance[] = [];\n  for (let i = 0; i < points.length; i++) {\n    for (let j = 0; j < points.length; j++) {\n      if (i < j) {\n        pairedDistance.push({\n          page: _getDistance2D(points[i].page, points[j].page),\n          client: _getDistance2D(points[i].client, points[j].client),\n          canvas: _getDistance2D(points[i].canvas, points[j].canvas),\n          world: _getDistance3D(points[i].world, points[j].world),\n        });\n      }\n    }\n  }\n\n  // take the average distance\n  return pairedDistance.reduce(\n    (prev, curr) => {\n      return {\n        page: prev.page + curr.page / pairedDistance.length,\n        client: prev.client + curr.client / pairedDistance.length,\n        canvas: prev.canvas + curr.canvas / pairedDistance.length,\n        world: prev.world + curr.world / pairedDistance.length,\n      };\n    },\n    {\n      page: 0,\n      client: 0,\n      canvas: 0,\n      world: 0,\n    }\n  );\n}\n\nfunction _getDistance2D(point0: Types.Point2, point1: Types.Point2): number {\n  return Math.sqrt(\n    Math.pow(point0[0] - point1[0], 2) + Math.pow(point0[1] - point1[1], 2)\n  );\n}\n\nfunction _getDistance3D(point0: Types.Point3, point1: Types.Point3): number {\n  return Math.sqrt(\n    Math.pow(point0[0] - point1[0], 2) +\n      Math.pow(point0[1] - point1[1], 2) +\n      Math.pow(point0[2] - point1[2], 2)\n  );\n}\n\nexport {\n  getMeanPoints,\n  getMeanTouchPoints,\n  copyPoints,\n  copyPointsList,\n  getDeltaDistanceBetweenIPoints,\n  getDeltaPoints,\n  getDeltaDistance,\n  getDeltaRotation,\n};\n","import { getRenderingEngine, type Types } from '@cornerstonejs/core';\nimport triggerAnnotationRender from './triggerAnnotationRender';\nimport { getToolGroup } from '../store/ToolGroupManager';\n\n/**\n * Triggers annotation rendering for the specified tool group IDs.\n *\n * @param toolGroupIds - An array of tool group IDs.\n */\nexport function triggerAnnotationRenderForToolGroupIds(\n  toolGroupIds: string[]\n): void {\n  toolGroupIds.forEach((toolGroupId) => {\n    const toolGroup = getToolGroup(toolGroupId);\n\n    if (!toolGroup) {\n      console.warn(`ToolGroup not available for ${toolGroupId}`);\n      return;\n    }\n\n    const viewportsInfo = toolGroup.getViewportsInfo();\n\n    viewportsInfo.forEach((viewportInfo) => {\n      const { renderingEngineId, viewportId } = viewportInfo;\n\n      const renderingEngine = getRenderingEngine(renderingEngineId);\n      if (!renderingEngine) {\n        console.warn(`RenderingEngine not available for ${renderingEngineId}`);\n        return;\n      }\n\n      const viewport = renderingEngine.getViewport(viewportId);\n      triggerAnnotationRender(viewport.element);\n    });\n  });\n}\n\nexport default triggerAnnotationRenderForToolGroupIds;\n","import {\n  cache,\n  StackViewport,\n  Types,\n  BaseVolumeViewport,\n} from '@cornerstonejs/core';\n\nfunction isViewportPreScaled(\n  viewport: Types.IStackViewport | Types.IVolumeViewport,\n  targetId: string\n): boolean {\n  if (viewport instanceof BaseVolumeViewport) {\n    const targetIdTokens = targetId.split('volumeId:');\n    const volumeId =\n      targetIdTokens.length > 1\n        ? targetIdTokens[1].split('?')[0]\n        : targetIdTokens[0];\n    const volume = cache.getVolume(volumeId);\n    return !!volume?.scaling && Object.keys(volume.scaling).length > 0;\n  } else if (viewport instanceof StackViewport) {\n    const { preScale } = viewport.getImageData() || {};\n    return !!preScale?.scaled;\n  } else {\n    return false;\n  }\n}\n\nexport { isViewportPreScaled };\n","import {\n  getEnabledElement,\n  StackViewport,\n  VolumeViewport,\n  utilities as csUtils,\n  Types,\n} from '@cornerstonejs/core';\nimport JumpToSliceOptions from '../../types/JumpToSliceOptions';\nimport clip from '../clip';\nimport scroll from '../scroll';\n\n/**\n * It uses the imageIndex in the Options to scroll to the slice that is intended.\n * It works for both Stack and Volume viewports. In VolumeViewports, the imageIndex\n * should be given with respect to the index in the 3D image in the view direction\n * (i.e. the index of the slice in Axial, Sagittal, Coronal, or Oblique).\n *\n * @param element - the HTML Div element scrolling inside\n * @param options - the options used for jumping to a slice\n * @returns Promise that resolves to ImageIdIndex\n */\nasync function jumpToSlice(\n  element: HTMLDivElement,\n  options = {} as JumpToSliceOptions\n): Promise<void> {\n  const { imageIndex, debounceLoading, volumeId } = options;\n  const enabledElement = getEnabledElement(element);\n\n  if (!enabledElement) {\n    throw new Error('Element has been disabled');\n  }\n\n  const { viewport } = enabledElement;\n\n  const { imageIndex: currentImageIndex, numberOfSlices } = _getImageSliceData(\n    viewport,\n    debounceLoading\n  );\n\n  const imageIndexToJump = _getImageIndexToJump(numberOfSlices, imageIndex);\n  const delta = imageIndexToJump - currentImageIndex;\n\n  scroll(viewport, { delta, debounceLoading, volumeId });\n}\n\nfunction _getImageSliceData(\n  viewport: Types.IStackViewport | Types.IVolumeViewport,\n  debounceLoading?: boolean\n): Types.ImageSliceData {\n  if (viewport instanceof StackViewport) {\n    return {\n      numberOfSlices: viewport.getImageIds().length,\n      imageIndex: debounceLoading\n        ? viewport.getTargetImageIdIndex()\n        : viewport.getCurrentImageIdIndex(),\n    };\n  } else if (viewport instanceof VolumeViewport) {\n    return csUtils.getImageSliceDataForVolumeViewport(viewport);\n  } else {\n    throw new Error('Unsupported viewport type');\n  }\n}\n\nfunction _getImageIndexToJump(\n  numberOfSlices: number,\n  imageIndex: number\n): number {\n  const lastSliceIndex = numberOfSlices - 1;\n\n  return clip(imageIndex, 0, lastSliceIndex);\n}\n\nexport default jumpToSlice;\n","import { VolumeViewport } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { vec3 } from 'gl-matrix';\n\n// Todo: merge this utility functionality with Crosshair _jump\n/**\n * Uses the viewport's current camera to jump to a specific world coordinate\n * @param enabledElement - enabled element\n * @param jumpWorld - location in the world to jump to\n * @returns True if successful\n */\nexport default function jumpToWorld(\n  viewport: Types.IVolumeViewport,\n  jumpWorld: Types.Point3\n): true | undefined {\n  // if not instance of volumeViewport, return\n  if (!(viewport instanceof VolumeViewport)) {\n    return;\n  }\n\n  const { focalPoint } = viewport.getCamera();\n\n  const delta: Types.Point3 = [0, 0, 0];\n  vec3.sub(delta, jumpWorld, focalPoint);\n\n  _applyShift(viewport, delta);\n\n  return true;\n}\n\nfunction _applyShift(viewport, delta) {\n  const camera = viewport.getCamera();\n  const normal = camera.viewPlaneNormal;\n\n  const dotProd = vec3.dot(delta, normal);\n  const projectedDelta = vec3.fromValues(normal[0], normal[1], normal[2]);\n\n  vec3.scale(projectedDelta, projectedDelta, dotProd);\n\n  if (\n    Math.abs(projectedDelta[0]) > 1e-3 ||\n    Math.abs(projectedDelta[1]) > 1e-3 ||\n    Math.abs(projectedDelta[2]) > 1e-3\n  ) {\n    const newFocalPoint: Types.Point3 = [0, 0, 0];\n    const newPosition: Types.Point3 = [0, 0, 0];\n\n    vec3.add(newFocalPoint, camera.focalPoint, projectedDelta);\n    vec3.add(newPosition, camera.position, projectedDelta);\n\n    viewport.setCamera({\n      focalPoint: newFocalPoint,\n      position: newPosition,\n    });\n    viewport.render();\n  }\n}\n","import type { Types } from '@cornerstonejs/core';\n\n/**\n * Given an array of viewports, returns a list of viewports that are viewing a\n * world space with the given `FrameOfReferenceUID`.\n *\n * @param viewports - An array of viewports.\n * @param FrameOfReferenceUID - The UID defining a particular world space/Frame Of Reference.\n *\n * @returns A filtered array of viewports.\n */\nexport default function filterViewportsWithFrameOfReferenceUID(\n  viewports: Array<Types.IViewport>,\n  FrameOfReferenceUID: string\n): Array<Types.IStackViewport | Types.IVolumeViewport> {\n  const numViewports = viewports.length;\n  const viewportsWithFrameOfReferenceUID = [];\n\n  for (let vp = 0; vp < numViewports; vp++) {\n    const viewport = viewports[vp];\n\n    if (viewport.getFrameOfReferenceUID() === FrameOfReferenceUID) {\n      viewportsWithFrameOfReferenceUID.push(viewport);\n    }\n  }\n\n  return viewportsWithFrameOfReferenceUID;\n}\n","import type { Types } from '@cornerstonejs/core';\nimport type { IToolGroup } from '../../types';\nimport { ToolGroupManager } from '../../store';\nimport { ToolModes } from '../../enums';\n\nconst { Active, Passive, Enabled } = ToolModes;\n\n/**\n * Given an array of viewports, returns a list of viewports that have the the specified tool enabled.\n *\n * @param viewports - An array of viewports.\n * @param toolName - The name of the tool to filter on.\n *\n * @returns A filtered array of viewports.\n */\nexport default function filterViewportsWithToolEnabled(\n  viewports: Array<Types.IViewport>,\n  toolName: string\n): Array<Types.IStackViewport | Types.IVolumeViewport> {\n  const numViewports = viewports.length;\n\n  const viewportsWithToolEnabled = [];\n\n  for (let vp = 0; vp < numViewports; vp++) {\n    const viewport = viewports[vp];\n\n    const toolGroup = ToolGroupManager.getToolGroupForViewport(\n      viewport.id,\n      viewport.renderingEngineId\n    );\n\n    if (!toolGroup) {\n      continue;\n    }\n\n    const hasTool = _toolGroupHasActiveEnabledOrPassiveTool(\n      toolGroup,\n      toolName\n    );\n\n    if (hasTool) {\n      viewportsWithToolEnabled.push(viewport);\n    }\n  }\n\n  return viewportsWithToolEnabled;\n}\n\n/**\n * Given a toolGroup, return true if it contains the tool with the given `toolName` and it is\n * active, passive or enabled.\n *\n * @param toolGroup - The `toolGroup` to check.\n * @param toolName - The name of the tool.\n *\n * @returns True if the tool is enabled, passive or active in the `toolGroup`.\n */\nfunction _toolGroupHasActiveEnabledOrPassiveTool(\n  toolGroup: IToolGroup,\n  toolName: string\n) {\n  const { toolOptions } = toolGroup;\n  const tool = toolOptions[toolName];\n\n  if (!tool) {\n    return false;\n  }\n\n  const toolMode = tool.mode;\n\n  return toolMode === Active || toolMode === Passive || toolMode === Enabled;\n}\n","import { vec3 } from 'gl-matrix';\n\n/**\n * It filters the viewports that are looking in the same view as the camera\n * It basically checks if the viewPlaneNormal is parallel to the camera viewPlaneNormal\n * @param viewports - Array of viewports to filter\n * @param camera - Camera to compare against\n * @returns - Array of viewports with the same view\n */\nexport function filterViewportsWithParallelNormals(\n  viewports,\n  camera,\n  EPS = 0.999\n) {\n  return viewports.filter((viewport) => {\n    const vpCamera = viewport.getCamera();\n\n    const isParallel =\n      Math.abs(vec3.dot(vpCamera.viewPlaneNormal, camera.viewPlaneNormal)) >\n      EPS;\n\n    return isParallel;\n  });\n}\n\nexport default filterViewportsWithParallelNormals;\n","import { getEnabledElement } from '@cornerstonejs/core';\nimport filterViewportsWithFrameOfReferenceUID from './filterViewportsWithFrameOfReferenceUID';\nimport filterViewportsWithToolEnabled from './filterViewportsWithToolEnabled';\nimport filterViewportsWithParallelNormals from './filterViewportsWithParallelNormals';\n\n/**\n * Given a cornerstone3D enabled `element`, and a `toolName`, find all viewportIds\n * looking at the same Frame Of Reference that have the tool with the given `toolName`\n * active, passive or enabled.\n *\n * @param element - The target cornerstone3D enabled element.\n * @param toolName - The string toolName.\n * @param requireParallelNormals - If true, only return viewports that have parallel normals.\n *\n * @returns An array of viewportIds.\n */\nexport default function getViewportIdsWithToolToRender(\n  element: HTMLDivElement,\n  toolName: string,\n  requireParallelNormals = true\n): string[] {\n  const enabledElement = getEnabledElement(element);\n  const { renderingEngine, FrameOfReferenceUID } = enabledElement;\n\n  let viewports = renderingEngine.getViewports();\n\n  viewports = filterViewportsWithFrameOfReferenceUID(\n    viewports,\n    FrameOfReferenceUID\n  );\n  viewports = filterViewportsWithToolEnabled(viewports, toolName);\n\n  const viewport = renderingEngine.getViewport(enabledElement.viewportId);\n\n  if (requireParallelNormals) {\n    viewports = filterViewportsWithParallelNormals(\n      viewports,\n      viewport.getCamera()\n    );\n  }\n\n  const viewportIds = viewports.map((vp) => vp.id);\n\n  return viewportIds;\n}\n","import { IColorMapPreset } from '@kitware/vtk.js/Rendering/Core/ColorTransferFunction/ColorMaps';\nimport { vec2 } from 'gl-matrix';\nimport { utilities as csUtils, Types } from '@cornerstonejs/core';\nimport type { ColorbarProps, ColorbarVOIRange } from './types';\nimport { isRangeValid, areColorbarRangesEqual } from './common';\nimport { ColorbarRangeTextPosition } from './enums/ColorbarRangeTextPosition';\nimport { ColorbarCanvas } from './ColorbarCanvas';\nimport { ColorbarTicks } from './ColorbarTicks';\nimport isRangeTextPositionValid from './common/isRangeTextPositionValid';\nimport Widget from '../../../widgets/Widget';\n\nconst DEFAULTS = {\n  MULTIPLIER: 1,\n  RANGE_TEXT_POSITION: ColorbarRangeTextPosition.Right,\n  TICKS_BAR_SIZE: 50,\n};\n\ntype ColorbarPoints = {\n  page: Types.Point2;\n  client: Types.Point2;\n  local: Types.Point2;\n};\n\n/**\n * A base colorbar class that is not associated with any viewport. It is\n * possible to click and drag to change the VOI range, shows the ticks during\n * interaction and it can show full image range or VOI range.\n */\nclass Colorbar extends Widget {\n  private _colormaps: Map<string, IColorMapPreset>;\n  private _activeColormapName: string;\n  private _eventListenersManager: csUtils.eventListener.MultiTargetEventListenerManager;\n  private _canvas: ColorbarCanvas;\n  private _ticksBar: ColorbarTicks;\n  private _rangeTextPosition: ColorbarRangeTextPosition;\n\n  private _isMouseOver = false;\n  private _isInteracting = false;\n\n  constructor(props: ColorbarProps) {\n    super(props);\n\n    this._eventListenersManager =\n      new csUtils.eventListener.MultiTargetEventListenerManager();\n    this._colormaps = Colorbar.getColormapsMap(props);\n    this._activeColormapName = Colorbar.getInitialColormapName(props);\n    this._canvas = this._createCanvas(props);\n    this._ticksBar = this._createTicksBar(props);\n    this._rangeTextPosition =\n      props.ticks?.position ?? DEFAULTS.RANGE_TEXT_POSITION;\n\n    this._canvas.appendTo(this.rootElement);\n    this._ticksBar.appendTo(this.rootElement);\n\n    this._addRootElementEventListeners();\n  }\n\n  /**\n   * Returns the active LUT name\n   */\n  public get activeColormapName() {\n    return this._activeColormapName;\n  }\n\n  /**\n   * Set the current active LUT name and re-renders the color bar\n   */\n  public set activeColormapName(colormapName: string) {\n    if (colormapName === this._activeColormapName) {\n      return;\n    }\n\n    const colormap = this._colormaps.get(colormapName);\n\n    if (!colormap) {\n      console.warn(`Invalid colormap name (${colormapName})`);\n      return;\n    }\n\n    this._activeColormapName = colormapName;\n    this._canvas.colormap = colormap;\n  }\n\n  public get imageRange() {\n    return this._canvas.imageRange;\n  }\n\n  public set imageRange(imageRange: ColorbarVOIRange) {\n    this._canvas.imageRange = imageRange;\n    this._ticksBar.imageRange = imageRange;\n  }\n\n  public get voiRange() {\n    return this._canvas.voiRange;\n  }\n\n  public set voiRange(voiRange: ColorbarVOIRange) {\n    const { voiRange: currentVoiRange } = this._canvas;\n\n    if (\n      !isRangeValid(voiRange) ||\n      areColorbarRangesEqual(voiRange, currentVoiRange)\n    ) {\n      return;\n    }\n\n    this._canvas.voiRange = voiRange;\n    this._ticksBar.voiRange = voiRange;\n    this.onVoiChange(voiRange);\n  }\n\n  public get showFullImageRange() {\n    return this._canvas.showFullImageRange;\n  }\n\n  public set showFullImageRange(value: boolean) {\n    this._canvas.showFullImageRange = value;\n    this._ticksBar.showFullPixelValueRange = value;\n  }\n\n  public destroy() {\n    super.destroy();\n    this._eventListenersManager.reset();\n  }\n\n  protected createRootElement(): HTMLElement {\n    const rootElement = document.createElement('div');\n\n    Object.assign(rootElement.style, {\n      position: 'relative',\n      fontSize: '0',\n      width: '100%',\n      height: '100%',\n    });\n\n    return rootElement;\n  }\n\n  protected onContainerResize() {\n    super.onContainerResize();\n    this.updateTicksBar();\n    this._canvas.size = this.containerSize;\n  }\n\n  protected getVOIMultipliers(): [number, number] {\n    return [DEFAULTS.MULTIPLIER, DEFAULTS.MULTIPLIER];\n  }\n\n  protected onVoiChange(voiRange: ColorbarVOIRange) {\n    // no-op\n  }\n\n  protected showTicks() {\n    this.updateTicksBar();\n    this._ticksBar.visible = true;\n  }\n\n  protected hideTicks() {\n    if (this._isInteracting || this._isMouseOver) {\n      return;\n    }\n\n    this._ticksBar.visible = false;\n  }\n\n  private static getColormapsMap(props: ColorbarProps) {\n    const { colormaps } = props;\n\n    return colormaps.reduce(\n      (items, item) => items.set(item.Name, item),\n      new Map<string, IColorMapPreset>()\n    );\n  }\n\n  private static getInitialColormapName(props: ColorbarProps) {\n    const { activeColormapName, colormaps } = props;\n    const colormapExists =\n      !!activeColormapName &&\n      colormaps.some((cm) => cm.Name === activeColormapName);\n\n    return colormapExists ? activeColormapName : colormaps[0].Name;\n  }\n\n  private _createCanvas(props: ColorbarProps) {\n    const { imageRange, voiRange, showFullPixelValueRange } = props;\n    const colormap = this._colormaps.get(this._activeColormapName);\n\n    return new ColorbarCanvas({\n      colormap,\n      imageRange,\n      voiRange: voiRange,\n      showFullPixelValueRange,\n    });\n  }\n\n  public _createTicksBar(props: ColorbarProps): ColorbarTicks {\n    const ticksProps = props.ticks;\n\n    return new ColorbarTicks({\n      imageRange: props.imageRange,\n      voiRange: props.voiRange,\n      ticks: ticksProps,\n      showFullPixelValueRange: props.showFullPixelValueRange,\n    });\n  }\n\n  private _getPointsFromMouseEvent(evt: MouseEvent): ColorbarPoints {\n    const { rootElement: element } = this;\n    const clientPoint: Types.Point2 = [evt.clientX, evt.clientY];\n    const pagePoint: Types.Point2 = [evt.pageX, evt.pageY];\n    const rect = element.getBoundingClientRect();\n    const localPoints: Types.Point2 = [\n      pagePoint[0] - rect.left - window.pageXOffset,\n      pagePoint[1] - rect.top - window.pageYOffset,\n    ];\n\n    return { client: clientPoint, page: pagePoint, local: localPoints };\n  }\n\n  private updateTicksBar() {\n    const { width: containerWidth, height: containerHeight } =\n      this.containerSize;\n\n    // ResizeObserver have not triggered any event when this happen\n    if (containerWidth === 0 && containerHeight === 0) {\n      return;\n    }\n\n    const { _ticksBar: ticksBar, _rangeTextPosition: rangeTextPosition } = this;\n    const isHorizontal = containerWidth >= containerHeight;\n    const width = isHorizontal ? containerWidth : DEFAULTS.TICKS_BAR_SIZE;\n    const height = isHorizontal ? DEFAULTS.TICKS_BAR_SIZE : containerHeight;\n\n    if (\n      !isRangeTextPositionValid(\n        containerWidth,\n        containerHeight,\n        rangeTextPosition\n      )\n    ) {\n      throw new Error(\n        'Invalid rangeTextPosition value for the current colobar orientation'\n      );\n    }\n\n    let ticksBarTop;\n    let ticksBarLeft;\n\n    ticksBar.size = { width, height };\n\n    if (isHorizontal) {\n      ticksBarLeft = 0;\n      ticksBarTop =\n        rangeTextPosition === ColorbarRangeTextPosition.Top\n          ? -height\n          : containerHeight;\n    } else {\n      ticksBarTop = 0;\n      ticksBarLeft =\n        rangeTextPosition === ColorbarRangeTextPosition.Left\n          ? -width\n          : containerWidth;\n    }\n\n    ticksBar.top = ticksBarTop;\n    ticksBar.left = ticksBarLeft;\n  }\n\n  private _mouseOverCallback = (evt) => {\n    this._isMouseOver = true;\n    this.showTicks();\n    evt.stopPropagation();\n  };\n\n  private _mouseOutCallback = (evt) => {\n    this._isMouseOver = false;\n    this.hideTicks();\n    evt.stopPropagation();\n  };\n\n  private _mouseDownCallback = (evt: MouseEvent) => {\n    this._isInteracting = true;\n    this.showTicks();\n    this._addVOIEventListeners(evt);\n    evt.stopPropagation();\n  };\n\n  private _mouseDragCallback = (evt, initialState) => {\n    const multipliers = this.getVOIMultipliers();\n    const currentPoints = this._getPointsFromMouseEvent(evt);\n    const { points: startPoints, voiRange: startVOIRange } = initialState;\n    const canvasDelta = vec2.sub(\n      vec2.create(),\n      currentPoints.local,\n      startPoints.local\n    );\n\n    const wwDelta = canvasDelta[0] * multipliers[0];\n    const wcDelta = canvasDelta[1] * multipliers[1];\n\n    if (!wwDelta && !wcDelta) {\n      return;\n    }\n\n    const { lower: voiLower, upper: voiUpper } = startVOIRange;\n    let { windowWidth, windowCenter } = csUtils.windowLevel.toWindowLevel(\n      voiLower,\n      voiUpper\n    );\n\n    windowWidth = Math.max(windowWidth + wwDelta, 1);\n    windowCenter += wcDelta;\n\n    const newVoiRange = csUtils.windowLevel.toLowHighRange(\n      windowWidth,\n      windowCenter\n    );\n\n    this.voiRange = newVoiRange;\n    evt.stopPropagation();\n    evt.preventDefault();\n  };\n\n  private _mouseUpCallback = (evt) => {\n    this._isInteracting = false;\n    this.hideTicks();\n    this._removeVOIEventListeners();\n    evt.stopPropagation();\n  };\n\n  private _addRootElementEventListeners() {\n    const { _eventListenersManager: manager } = this;\n    const { rootElement: element } = this;\n\n    manager.addEventListener(element, 'mouseover', this._mouseOverCallback);\n    manager.addEventListener(element, 'mouseout', this._mouseOutCallback);\n    manager.addEventListener(\n      element,\n      'mousedown',\n      this._mouseDownCallback as EventListener\n    );\n  }\n\n  private _addVOIEventListeners(evt: MouseEvent) {\n    const { _eventListenersManager: manager } = this;\n    const points = this._getPointsFromMouseEvent(evt);\n    const voiRange = { ...this._canvas.voiRange };\n    const initialDragState = { points, voiRange };\n\n    this._removeVOIEventListeners();\n\n    manager.addEventListener(document, 'voi.mouseup', this._mouseUpCallback);\n    manager.addEventListener(document, 'voi.mousemove', (evt) =>\n      this._mouseDragCallback(evt, initialDragState)\n    );\n  }\n\n  private _removeVOIEventListeners() {\n    const { _eventListenersManager: manager } = this;\n\n    manager.removeEventListener(document, 'voi.mouseup');\n    manager.removeEventListener(document, 'voi.mousemove');\n  }\n}\n\nexport { Colorbar as default, Colorbar };\n","import {\n  eventTarget,\n  VolumeViewport,\n  StackViewport,\n  Types,\n  Enums,\n  utilities,\n  getEnabledElement,\n} from '@cornerstonejs/core';\nimport { Colorbar } from './Colorbar';\nimport type { ViewportColorbarProps, ColorbarVOIRange } from './types';\nimport { getVOIMultipliers } from '../../getVOIMultipliers';\n\nconst { Events } = Enums;\nconst defaultImageRange = { lower: -1000, upper: 1000 };\n/**\n * A colorbar associated with a viewport that updates automatically when the\n * viewport VOI changes or when the stack/volume are updated..\n */\nclass ViewportColorbar extends Colorbar {\n  private _element: HTMLDivElement;\n  private _volumeId: string;\n\n  private _hideTicksTime: number;\n  private _hideTicksTimeoutId: number;\n\n  constructor(props: ViewportColorbarProps) {\n    const { element, volumeId } = props;\n    const imageRange = ViewportColorbar._getImageRange(element, volumeId);\n    const voiRange = ViewportColorbar._getVOIRange(element, volumeId);\n\n    super({ ...props, imageRange, voiRange });\n\n    this._element = element;\n    this._volumeId = volumeId;\n\n    this._addCornerstoneEventListener();\n  }\n\n  public get element() {\n    return this._element;\n  }\n\n  public get enabledElement() {\n    return getEnabledElement(this._element);\n  }\n\n  protected getVOIMultipliers(): [number, number] {\n    const { viewport } = this.enabledElement;\n    return getVOIMultipliers(viewport, this._volumeId);\n  }\n\n  protected onVoiChange(voiRange: ColorbarVOIRange) {\n    super.onVoiChange(voiRange);\n\n    const { viewport } = this.enabledElement;\n\n    if (viewport instanceof StackViewport) {\n      viewport.setProperties({\n        voiRange: voiRange,\n      });\n      viewport.render();\n    } else if (viewport instanceof VolumeViewport) {\n      const { _volumeId: volumeId } = this;\n      const viewportsContainingVolumeUID = utilities.getViewportsWithVolumeId(\n        volumeId,\n        viewport.renderingEngineId\n      );\n\n      viewport.setProperties({ voiRange }, volumeId);\n      viewportsContainingVolumeUID.forEach((vp) => vp.render());\n    }\n  }\n\n  private static _getImageRange(element, volumeId?) {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n\n    const actor = volumeId\n      ? viewport.getActor(volumeId)\n      : viewport.getDefaultActor();\n\n    if (!actor) {\n      return defaultImageRange;\n    }\n\n    const imageData = actor.actor.getMapper().getInputData();\n    const imageRange = imageData.getPointData().getScalars().getRange();\n\n    return imageRange[0] === 0 && imageRange[1] === 0\n      ? defaultImageRange\n      : { lower: imageRange[0], upper: imageRange[1] };\n  }\n\n  private static _getVOIRange(element, volumeId) {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n\n    const volumeActor = volumeId\n      ? viewport.getActor(volumeId)\n      : viewport.getDefaultActor();\n\n    if (!volumeActor || !utilities.isImageActor(volumeActor)) {\n      return defaultImageRange;\n    }\n\n    const voiRange = (volumeActor.actor as Types.ImageActor)\n      .getProperty()\n      .getRGBTransferFunction(0)\n      .getRange();\n\n    return voiRange[0] === 0 && voiRange[1] === 0\n      ? defaultImageRange\n      : { lower: voiRange[0], upper: voiRange[1] };\n  }\n\n  private autoHideTicks = () => {\n    // Avoiding calling setTimeout multiple times when manipulating the VOI\n    // via WindowLevel tool for better performance\n    if (this._hideTicksTimeoutId) {\n      return;\n    }\n\n    const timeLeft = this._hideTicksTime - Date.now();\n\n    if (timeLeft <= 0) {\n      this.hideTicks();\n    } else {\n      this._hideTicksTimeoutId = window.setTimeout(() => {\n        // Recursive call until there is no more time left\n        this._hideTicksTimeoutId = 0;\n        this.autoHideTicks();\n      }, timeLeft);\n    }\n  };\n\n  private showAndAutoHideTicks(interval = 1000) {\n    this._hideTicksTime = Date.now() + interval;\n    this.showTicks();\n    this.autoHideTicks();\n  }\n\n  private _stackNewImageCallback = () => {\n    this.imageRange = ViewportColorbar._getImageRange(this._element);\n  };\n\n  private _imageVolumeModifiedCallback = (\n    evt: Types.EventTypes.ImageVolumeModifiedEvent\n  ) => {\n    const { volumeId } = evt.detail.imageVolume;\n\n    if (volumeId !== this._volumeId) {\n      return;\n    }\n\n    const { _element: element } = this;\n    this.imageRange = ViewportColorbar._getImageRange(element, volumeId);\n  };\n\n  private _viewportVOIModifiedCallback = (\n    evt: Types.EventTypes.VoiModifiedEvent\n  ) => {\n    const { viewportId, volumeId, range: voiRange, colormap } = evt.detail;\n    const { viewport } = this.enabledElement;\n    if (viewportId !== viewport.id || volumeId !== this._volumeId) {\n      return;\n    }\n\n    this.voiRange = voiRange;\n\n    if (colormap) {\n      this.activeColormapName = colormap.name;\n    }\n    this.showAndAutoHideTicks();\n  };\n\n  private _viewportColormapModifiedCallback = (\n    evt: Types.EventTypes.ColormapModifiedEvent\n  ) => {\n    const { viewportId, colormap, volumeId } = evt.detail;\n    const { viewport } = this.enabledElement;\n\n    if (viewportId !== viewport.id || volumeId !== this._volumeId) {\n      return;\n    }\n\n    this.activeColormapName = colormap.name;\n  };\n\n  private _addCornerstoneEventListener() {\n    const { _element: element } = this;\n\n    eventTarget.addEventListener(\n      Events.IMAGE_VOLUME_MODIFIED,\n      this._imageVolumeModifiedCallback\n    );\n\n    element.addEventListener(\n      Events.STACK_NEW_IMAGE,\n      this._stackNewImageCallback\n    );\n\n    element.addEventListener(\n      Events.VOI_MODIFIED,\n      this._viewportVOIModifiedCallback as EventListener\n    );\n\n    element.addEventListener(\n      Events.COLORMAP_MODIFIED,\n      this._viewportColormapModifiedCallback as EventListener\n    );\n  }\n}\n\nexport { ViewportColorbar as default, ViewportColorbar };\n","/**\n * Specify the position of the text/ticks.\n * Left/Right are the valid options for a vertical colorbars and Top/Bottom\n * for the horizontal ones.\n */\nexport enum ColorbarRangeTextPosition {\n  Top = 'top',\n  Left = 'left',\n  Bottom = 'bottom',\n  Right = 'right',\n}\n","import { m as macro } from '../../macros2.js';\nimport vtkPolyData from '../../Common/DataModel/PolyData.js';\nimport vtkEdgeLocator from '../../Common/DataModel/EdgeLocator.js';\nimport vtkCaseTable from './ImageMarchingSquares/caseTable.js';\n\nconst {\n  vtkErrorMacro,\n  vtkDebugMacro\n} = macro;\n\n// ----------------------------------------------------------------------------\n// vtkImageMarchingSquares methods\n// ----------------------------------------------------------------------------\n\nfunction vtkImageMarchingSquares(publicAPI, model) {\n  /**\n   * Get the X,Y kernels based on the set slicing mode.\n   * @returns {[number, number]}\n   */\n  function getKernels() {\n    let kernelX = 0; // default K slicing mode\n    let kernelY = 1;\n    if (model.slicingMode === 1) {\n      kernelX = 0;\n      kernelY = 2;\n    } else if (model.slicingMode === 0) {\n      kernelX = 1;\n      kernelY = 2;\n    }\n    return [kernelX, kernelY];\n  }\n\n  // Set our className\n  model.classHierarchy.push('vtkImageMarchingSquares');\n\n  /**\n   * Get the list of contour values.\n   * @returns {number[]}\n   */\n  publicAPI.getContourValues = () => model.contourValues;\n\n  /**\n   * Set the list contour values.\n   * @param {number[]} cValues\n   */\n  publicAPI.setContourValues = cValues => {\n    model.contourValues = cValues;\n    publicAPI.modified();\n  };\n  const ids = [];\n  const pixelScalars = [];\n  const pixelPts = [];\n  const edgeLocator = vtkEdgeLocator.newInstance();\n\n  /**\n   * Retrieve scalars and pixel coordinates.\n   * @param {Vector3} ijk origin of the pixel\n   * @param {Vector3} dims dimensions of the image\n   * @param {TypedArray} scalars list of scalar values\n   * @param {Vector3} increments IJK slice increments\n   * @param {number} kernelX index of the X element\n   * @param {number} kernelY index of the Y element\n   */\n  publicAPI.getPixelScalars = (ijk, dims, scalars, increments, kernelX, kernelY) => {\n    const [i, j, k] = ijk;\n\n    // First get the indices for the pixel\n    ids[0] = k * dims[1] * dims[0] + j * dims[0] + i; // i, j, k\n    ids[1] = ids[0] + increments[kernelX]; // i+1, j, k\n    ids[2] = ids[0] + increments[kernelY]; // i, j+1, k\n    ids[3] = ids[2] + increments[kernelX]; // i+1, j+1, k\n\n    // Now retrieve the scalars\n    for (let ii = 0; ii < 4; ++ii) {\n      pixelScalars[ii] = scalars[ids[ii]];\n    }\n  };\n\n  /**\n   * Retrieve pixel coordinates.\n   * @param {Vector3} ijk origin of the pixel\n   * @param {Vector3} origin origin of the image\n   * @param {Vector3} spacing spacing of the image\n   * @param {number} kernelX index of the X element\n   * @param {number} kernelY index of the Y element\n   */\n  publicAPI.getPixelPoints = (ijk, origin, spacing, kernelX, kernelY) => {\n    const i = ijk[kernelX];\n    const j = ijk[kernelY];\n\n    // (i,i+1),(j,j+1),(k,k+1) - i varies fastest; then j; then k\n    pixelPts[0] = origin[kernelX] + i * spacing[kernelX]; // 0\n    pixelPts[1] = origin[kernelY] + j * spacing[kernelY];\n    pixelPts[2] = pixelPts[0] + spacing[kernelX]; // 1\n    pixelPts[3] = pixelPts[1];\n    pixelPts[4] = pixelPts[0]; // 2\n    pixelPts[5] = pixelPts[1] + spacing[kernelY];\n    pixelPts[6] = pixelPts[2]; // 3\n    pixelPts[7] = pixelPts[5];\n  };\n\n  /**\n   * Produce points and lines for the polydata.\n   * @param {number[]} cVal list of contour values\n   * @param {Vector3} ijk origin of the pixel\n   * @param {Vector3} dims dimensions of the image\n   * @param {Vector3} origin origin of the image\n   * @param {Vector3} spacing sapcing of the image\n   * @param {TypedArray} scalars list of scalar values\n   * @param {number[]} points list of points\n   * @param {number[]} lines list of lines\n   * @param {Vector3} increments IJK slice increments\n   * @param {number} kernelX index of the X element\n   * @param {number} kernelY index of the Y element\n   */\n  publicAPI.produceLines = (cVal, ijk, dims, origin, spacing, scalars, points, lines, increments, kernelX, kernelY) => {\n    const k = ijk[model.slicingMode];\n    const CASE_MASK = [1, 2, 8, 4]; // case table is actually for quad\n    const xyz = [];\n    let pId;\n    publicAPI.getPixelScalars(ijk, dims, scalars, increments, kernelX, kernelY);\n    let index = 0;\n    for (let idx = 0; idx < 4; idx++) {\n      if (pixelScalars[idx] >= cVal) {\n        index |= CASE_MASK[idx]; // eslint-disable-line no-bitwise\n      }\n    }\n\n    const pixelLines = vtkCaseTable.getCase(index);\n    if (pixelLines[0] < 0) {\n      return; // don't get the pixel coordinates, nothing to do\n    }\n\n    publicAPI.getPixelPoints(ijk, origin, spacing, kernelX, kernelY);\n    const z = origin[model.slicingMode] + k * spacing[model.slicingMode];\n    for (let idx = 0; pixelLines[idx] >= 0; idx += 2) {\n      lines.push(2);\n      for (let eid = 0; eid < 2; eid++) {\n        const edgeVerts = vtkCaseTable.getEdge(pixelLines[idx + eid]);\n        pId = undefined;\n        if (model.mergePoints) {\n          pId = edgeLocator.isInsertedEdge(ids[edgeVerts[0]], ids[edgeVerts[1]])?.value;\n        }\n        if (pId === undefined) {\n          const t = (cVal - pixelScalars[edgeVerts[0]]) / (pixelScalars[edgeVerts[1]] - pixelScalars[edgeVerts[0]]);\n          const x0 = pixelPts.slice(edgeVerts[0] * 2, (edgeVerts[0] + 1) * 2);\n          const x1 = pixelPts.slice(edgeVerts[1] * 2, (edgeVerts[1] + 1) * 2);\n          xyz[kernelX] = x0[0] + t * (x1[0] - x0[0]);\n          xyz[kernelY] = x0[1] + t * (x1[1] - x0[1]);\n          xyz[model.slicingMode] = z;\n          pId = points.length / 3;\n          points.push(xyz[0], xyz[1], xyz[2]);\n          if (model.mergePoints) {\n            edgeLocator.insertEdge(ids[edgeVerts[0]], ids[edgeVerts[1]], pId);\n          }\n        }\n        lines.push(pId);\n      }\n    }\n  };\n  publicAPI.requestData = (inData, outData) => {\n    // implement requestData\n    const input = inData[0];\n    if (!input) {\n      vtkErrorMacro('Invalid or missing input');\n      return;\n    }\n    if (model.slicingMode == null || model.slicingMode < 0 || model.slicingMode > 2) {\n      vtkErrorMacro('Invalid or missing slicing mode');\n      return;\n    }\n    console.time('msquares');\n\n    // Retrieve output and volume data\n    const origin = input.getOrigin();\n    const spacing = input.getSpacing();\n    const dims = input.getDimensions();\n    const extent = input.getExtent();\n    const increments = input.computeIncrements(extent);\n    const scalars = input.getPointData().getScalars().getData();\n    const [kernelX, kernelY] = getKernels();\n\n    // Points - dynamic array\n    const points = [];\n\n    // Cells - dynamic array\n    const lines = [];\n\n    // Ensure slice is valid\n    let k = Math.round(model.slice);\n    if (k >= dims[model.slicingMode]) {\n      k = 0;\n    }\n\n    // Loop over all contour values, and then pixels, determine case and process\n    const ijk = [0, 0, 0];\n    ijk[model.slicingMode] = k;\n    for (let cv = 0; cv < model.contourValues.length; ++cv) {\n      for (let j = 0; j < dims[kernelY] - 1; ++j) {\n        ijk[kernelY] = j;\n        for (let i = 0; i < dims[kernelX] - 1; ++i) {\n          ijk[kernelX] = i;\n          publicAPI.produceLines(model.contourValues[cv], ijk, dims, origin, spacing, scalars, points, lines, increments, kernelX, kernelY);\n        }\n      }\n      edgeLocator.initialize();\n    }\n\n    // Update output\n    const polydata = vtkPolyData.newInstance();\n    polydata.getPoints().setData(new Float32Array(points), 3);\n    polydata.getLines().setData(new Uint32Array(lines));\n    outData[0] = polydata;\n    vtkDebugMacro('Produced output');\n    console.timeEnd('msquares');\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  contourValues: [],\n  slicingMode: 2,\n  slice: 0,\n  mergePoints: false\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Make this a VTK object\n  macro.obj(publicAPI, model);\n\n  // Also make it an algorithm with one input and one output\n  macro.algo(publicAPI, model, 1, 1);\n  macro.setGet(publicAPI, model, ['slicingMode', 'slice', 'mergePoints']);\n\n  // Object specific methods\n  macro.algo(publicAPI, model, 1, 1);\n  vtkImageMarchingSquares(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkImageMarchingSquares');\n\n// ----------------------------------------------------------------------------\n\nvar vtkImageMarchingSquares$1 = {\n  newInstance,\n  extend\n};\n\nexport { vtkImageMarchingSquares$1 as default, extend, newInstance };\n"],"names":["AnnotationTool","A","constructor","toolProps","defaultToolProps","super","mouseMoveCallback","evt","filteredAnnotations","element","currentPoints","detail","canvasCoords","canvas","annotationsNeedToBeRedrawn","annotation","isAnnotationLocked","isAnnotationVisible","annotationUID","data","activateHandleIndex","handles","activeHandleIndex","undefined","near","this","_imagePointNearToolOrHandle","nearToolAndNotMarkedActive","highlighted","notNearToolAndMarkedActive","configuration","getTextLines","statsCalculator","createAnnotation","annotationBaseData","invalidated","metadata","toolName","text","points","Array","textBox","hasMoved","worldPosition","worldBoundingBox","topLeft","topRight","bottomLeft","bottomRight","label","baseData","createAnnotationForViewport","viewport","getViewReference","createAndAddAnnotation","addAnnotation","getHandleNearImagePoint","proximity","enabledElement","getEnabledElement","isCanvasAnnotation","canvasBoundingBox","worldToCanvas","i","length","point","annotationCanvasCoordinate","slice","getLinkedTextBoxStyle","specifications","visibility","getStyle","fontFamily","fontSize","color","shadow","background","lineWidth","lineDash","isSuvScaled","targetId","imageId","BaseVolumeViewport","volumeId","volume","cache","getVolume","scaling","PT","scalingModule","metaData","suvbw","getAnnotationStyle","context","styleSpecifier","property","locked","lineOpacity","fillColor","fillOpacity","textbox","isPointNearTool","defaultLabelmapConfig","renderOutline","outlineWidthActive","outlineWidthInactive","activeSegmentOutlineWidthDelta","renderFill","renderFillInactive","fillAlpha","fillAlphaInactive","outlineOpacity","outlineOpacityInactive","isValidLabelmapConfig","config","AnnotationFrameRange","frameRangeExtractor","imageIdToFrames","match","range","split","map","it","Number","framesToString","isArray","String","framesToImageId","newRangeString","replace","setFrameRange","eventBase","referencedImageId","eventDetail","triggerEvent","eventTarget","ANNOTATION_MODIFIED","getFrameRange","boundsIJK","numSlicesToProject","sliceNormalIndex","findIndex","min","max","Error","EPSILON","CONSTANTS","calculateBoundingBox","dimensions","isWorld","xMin","Infinity","xMax","yMin","yMax","zMin","zMax","is3D","p","Math","getBoundingBoxAroundShapeIJK","getBoundingBoxAroundShapeWorld","clipBounds","calibratedPixelSpacingMetadataProvider","utilities","calibrateImageSpacing","renderingEngine","calibrationOrScale","type","Enums","USER","scale","add","getStackViewports","forEach","getImageIds","includes","calibrateSpacing","Events","state","addToolState","viewportId","getToolState","ViewportStatus","debounced","dynamicVolumesPlayingMap","Map","playClip","playClipOptions","playClipTimeouts","playClipIsTimeVarying","dynamicCineEnabled","_getVolumeFromViewport","playClipContext","StackViewport","waitForRendered","imageIds","numScrollSteps","currentStepIndex","getTargetImageIdIndex","frameTimeVectorEnabled","waitForRenderedCount","scroll","delta","viewportStatus","RENDERED","debounceLoading","_createStackViewportCinePlayContext","VolumeViewport","isDynamicVolume","numTimePoints","timePointIndex","_createDynamicVolumeViewportCinePlayContext","cachedScrollInfo","viewPlaneNormal","scrollInfo","getScrollInfo","camera","getCamera","volumeViewPlaneNormal","direction","x","dot","_createVolumeViewportCinePlayContext","_createCinePlayContext","playClipData","isDynamicCinePlaying","_stopDynamicVolumeCine","_stopClip","stopDynamicCine","id","intervalId","framesPerSecond","lastFrameTimeStamp","ignoreFrameTimeVector","usingFrameTimeVector","frameTimeVector","speed","frameTimeVectorSpeedMultiplier","reverse","loop","timeouts","isTimeVarying","vector","sample","delay","sum","limit","push","_getPlayClipTimeouts","playClipAction","newStepIndex","newStepIndexOutOfRange","CLIP_STOPPED","set","window","setTimeout","playClipTimeoutHandler","setInterval","abs","CLIP_STARTED","stopClip","options","toolState","getToolStateByViewportId","clearTimeout","clearInterval","_stopClipWithData","dynamicCineElement","get","delete","volumes","getActors","actor","uid","filter","_getVolumesFromViewport","find","clip","val","low","high","addContourSegmentationAnnotation","parentAnnotationUID","segmentation","segmentationId","segmentIndex","getSegmentation","representationData","CONTOUR","annotationUIDsMap","annotationsUIDsSet","Set","areSameSegment","firstAnnotation","secondAnnotation","firstSegmentation","secondSegmentation","isContourSegmentationAnnotation","removeContourSegmentationAnnotation","size","AnnotationToPointData","TOOL_NAMES","convert","index","metadataProvider","referenceImageId","validateAnnotation","toolClass","ContourSequence","getContourSequence","ReferencedROINumber","ROIDisplayColor","floor","random","register","areCoplanarContours","firstViewPlaneNormal","secondViewPlaneNormal","polyline","firstPolyline","contour","secondPolyline","firstDistance","secondDistance","closed","perimeter","point1","point2","sqrt","pow","firstPoint","lastPoint","findNextLink","line","lines","contourPoints","cell","a","b","nextLine","splice","remainingLines","findContours","firstCell","shift","result","extraContours","findContoursFromReducedSet","getIsPointInsidePolygon","vertices","y","inside","j","xi","yi","xj","yj","processContourHoles","contours","useXOR","retContours","closedContours","contourWithHoles","contourWithoutHoles","holes","hContour","hIndex","outerContour","innerContour","pointsNotEnclosed","checkEnclosed","contourHoleSet","holeIndex","contourIndex","isEqual","findHandlePolylineIndex","handleIndex","handle","closestDistance","reduce","closestIndex","testIndex","distance","Labelmap","generateContourSetsFromLabelmap","segmentations","segments","segVolumeId","vol","console","warn","numSlices","segData","imageData","getPointData","getScalars","getData","pixelsPerSlice","z","ContourSets","FrameOfReferenceUID","numSegments","segIndex","segment","sliceContours","scalars","name","numberOfComponents","dataType","containedSegmentIndices","sliceIndex","isSliceEmptyForSegment","frameStart","value","has","setValue","mSquares","imageDataCopy","shallowCopy","setScalars","setInputData","cValues","setContourValues","setMergePoints","msOutput","getOutputData","reducedSet","getDeduplicatedVTKPolyDataPoints","polyData","FrameNumber","e","ContourSet","startIdx","endIdx","getContourHolesDataCanvas","worldHoleContours","canvasHoleContours","worldHoleContour","numPoints","canvasHoleContour","getContourHolesDataWorld","childAnnotationUIDs","bypass","getPoints","getLines","pointsArray","getNumberOfPoints","fill","_","getPoint","linesArray","getNumberOfCells","getCell","newPoints","pt","entries","newIndex","acceptAutogeneratedInterpolations","annotationGroupSelector","selector","acceptAutoGenerated","updateContourPolyline","polylineData","transforms","canvasToWorld","targetWindingDirection","decimate","enabled","epsilon","polylineWorldPoints","currentWindingDirection","parentAnnotation","currentClosedState","lastToFirstDist","windingDirection","func","wait","lastArgs","lastThis","maxWait","timerId","lastCallTime","lastInvokeTime","leading","maxing","trailing","useRAF","requestAnimationFrame","TypeError","invokeFunc","time","args","thisArg","apply","startTimer","pendingFunc","shouldInvoke","timeSinceLastCall","timerExpired","Date","now","trailingEdge","timeSinceLastInvoke","timeWaiting","remainingWait","isInvoking","leadingEdge","Boolean","cancel","cancelAnimationFrame","cancelTimer","flush","pending","getTextBoxCoordsCanvas","annotationCanvasPoints","corners","canvasPoints","handlesLeftToRight","sort","_compareX","handlesTopToBottom","_compareY","right","top","bottom","_determineCorners","centerY","dynamicVolume","frames","frameNumbers","keys","maskVolumeId","imageCoordinate","segmentationVolume","dataInTime","ijkCoords","maskImageData","segScalarData","getScalarData","len","nonZeroVoxelIndices","actualLen","dynamicVolumeScalarDataArray","getScalarDataArrays","values","isSameVolume","JSON","stringify","spacing","indexValues","frame","activeScalarData","callback","pointLPS","segPointLPS","segValue","pointIJK","segPointIJK","overlapIJKMinMax","count","perFrameSum","averageCallback","pointInShapeCallback","averageValues","_getTimePointDataMask","coordinate","worldToIndex","yMultiple","zMultiple","allScalarData","scalarIndex","_getTimePointDataCoordinate","operation","numFrames","typedArrays","arrayLength","finalArray","Float32Array","SUM","currentArray","SUBTRACT","AVERAGE","k","getAnnotationNearPoint","canvasPoint","getAnnotationNearPointOnEnabledElement","renderingEngineId","toolGroup","_toolInstances","tools","found","findAnnotationNearPointByTool","tool","annotations","getAnnotations","currentId","getCurrentImageId","CalibrationTypes","PIXEL_UNITS","SUPPORTED_REGION_DATA_TYPES","SUPPORTED_LENGTH_VARIANT","SUPPORTED_PROBE_VARIANT","UNIT_MAPPING","SQUARE","getCalibratedLengthUnitsAndScale","image","calibration","hasPixelSpacing","units","areaUnits","calibrationType","sequenceOfUltrasoundRegions","UNCALIBRATED","imageIndex1","imageIndex2","regions","region","regionLocationMinX0","regionLocationMaxX1","regionLocationMinY0","regionLocationMaxY1","regionDataType","physicalUnitsXDirection","physicalUnitsYDirection","physicalDeltaX","physicalDeltaY","ERMF","ERROR","PROJECTION","getCalibratedProbeUnitsAndValue","imageIndex","supportedRegionsMetadata","referencePixelX0","referencePixelY0","yValue","getCalibratedAspect","aspect","transformWorldToIndex","getSphereBoundsInfo","circlePoints","centerWorld","radiusWorld","topLeftWorld","bottomRightWorld","getDimensions","viewUp","viewRight","topLeftIJK","bottomRightIJK","pointsIJK","_computeBoundsIJKWithCamera","getViewportForAnnotation","viewports","intersectAABB","aabb1","aabb2","minX","maxX","minY","maxY","distanceToPointSquared","aabb","aabbWidth","aabbHeight","aabbSize","aabbCenter","translatedPoint","dx","dy","dist","distanceToPoint","BasicStatsCalculator","sumSquares","squaredDiffSum","statsCallback","newValue","newArray","idx","getStatistics","mean","stdDev","stdDevWithSumSquare","named","singleArrayAsNumber","unit","array","pointInEllipse","ellipse","inverts","precalculated","precalculatePointInEllipse","xRadius","yRadius","zRadius","invXRadiusSq","invYRadiusSq","invZRadiusSq","center","centerL","centerP","centerS","dz","getCanvasEllipseCorners","ellipseCanvasPoints","left","distanceToPointSquaredInfo","lineStart","lineEnd","closestPoint","distanceSquared","math","dotProduct","sign","NaN","intersectLine","line1Start","line1End","line2Start","line2End","x1","y1","x2","y2","x3","y3","x4","y4","a1","b1","c1","r3","r4","a2","b2","c2","r1","r2","denom","num","ORIENTATION_TOLERANCE","isPointOnLineSegment","orientation","p1","p2","z1","z2","mirror","mirrorPoint","staticPoint","isClosed","numPolylinePoints","distFirstToLastPoints","containsPoint","numIntersections","hole","shouldClose","maxSegmentIndex","intersects","xIntersection","containsPoints","numPoint","getArea","n","area","getSignedArea","refPoint","aX","aY","bX","getWindingDirection","getNormal3","vecArea","aZ","bY","bZ","_getAreaVector","getNormal2","areLineSegmentsIntersecting","q1","q2","line1MinX","line1MinY","line1MaxX","line1MaxY","line2MinX","line2MinY","line2MaxX","line2MaxY","orient","onSegment","q","r","orientationValue","getLineSegmentIntersectionsIndexes","intersections","maxI","PARALLEL_LINES_TOLERANCE","getLinesIntersection","diffQ1P1","diffQ2P2","denominator","line1AABB","line2AABB","numerator2","PolylinePointType","PolylinePointPosition","PolylinePointDirection","ensuresNextPointers","polylinePoints","currentPoint","next","getSourceAndTargetPointsList","targetPolyline","sourcePolyline","targetPolylinePoints","sourcePolylinePoints","sourceIntersectionsCache","intersectionPointDirection","Exiting","Entering","pointInside","vertexPoint","Vertex","coordinates","position","Inside","Outside","visited","intersectionsInfo","intersectedLineSegment","sourceLineSegmentId","intersectionCoordinate","targetStartPointDistSquared","intersectionInfo","targetEdgePoint","Intersection","Edge","sourceEdgePoint","Unknown","cloned","sourceIntersectionPoints","lineSegmentId","intersectionPoint","lineSegStartDistSquared","getUnvisitedOutsidePoint","mergePolylines","targetNormal","sourceNormal","dotNormals","startPoint","mergedPolyline","subtractPolylines","subtractedPolylines","subtractedPolyline","getFirstLineSegmentIntersectionIndexes","initialI","intersectPolyline","sourceLen","intersectionPointIndexes","DEFAULT_EPSILON","epsilonSquared","partitionQueue","polylinePointFlags","numDecimatedPoints","startIndex","endIndex","pop","endPoint","maxDistSquared","maxDistIndex","distSquared","decimatedPolyline","srcIndex","dstIndex","getLineSegmentIntersectionsCoordinates","polylineIndexes","intersection","getClosestLineSegmentIntersection","initialQ2Index","p2Index","q2Index","distances","intersectionPoints","midpoint","minDistance","indexOf","subPixelResolution","xDir","yDir","getImageData","volumeSpacing","iVector","jVector","kVector","absViewRightDotI","absViewRightDotJ","absViewRightDotK","xSpacing","absViewUpDotI","absViewUpDotJ","absViewUpDotK","ySpacing","closeContourProximity","newCanvasPoint","commonData","log","lastWorldPos","newWorldPos","worldPosDiff","xDist","yDist","numPointsToAdd","lastCanvasPoint","canvasDist","canvasDir","distPerPoint","p1p","p1p2","p1p2Mag","projectionVectorMag","p1p2UnitVector","projectionVector","projectionPoint","projectTo2D","sharedDimensionIndex","testPoints","every","points2D","firstDim","secondDim","projectedPolyline","isPointInsidePolyline3D","projectedHoles","hole2D","rect","width","height","lineSegments","rectToLineSegments","Object","pointInSphere","sphere","radius","radius2","INSIDE","OUTSIDE","clipT","c","tE","tL","t","box","da","db","getOrientationStringLPS","orientationX","orientationY","orientationZ","MIN","invertOrientationStringLPS","orientationString","inverted","toUpperCase","filterAnnotationsWithinSlice","getWorldWidthAndHeightFromCorners","filterAnnotationsForDisplay","getPointInLineOfSightWithCriteria","isPlaneIntersectingAABB","smoothAnnotation","pointInShapeFn","iMin","iMax","jMin","jMax","kMin","kMax","scalarData","numComps","start","getDirection","rowCosines","columnCosines","scanAxisNormal","getSpacing","rowSpacing","columnSpacing","scanAxisSpacing","worldPosStart","indexToWorld","rowStep","columnStep","scanAxisStep","xMultiple","pointsInShape","currentPos","startPosJ","startPosI","pointInSurroundingSphereCallback","centerIJK","spacings","minSpacing","maxRadiusIJK","ceil","sphereCornersIJK","getBoundingBoxAroundShape","_getBounds","sphereObj","pointToString","decimals","parseFloat","toFixed","idx3","getPolyDataPointIndexes","linesData","segmentSize","findStartingPoint","key","nextPoint","getPolyDataPoints","contoursIndexes","rawPointsData","contourIndexes","referenceVolume","AllBoundsIJK","pointsToUse","cachedStats","projectionPoints","concat","rectangleCornersIJK","world","g","accumulator","currentValue","axisList","isAxisAlignedRectangle","rectangleVec1","rectangleVec2","calculateAnglesWithAxes","angle","vec","axes","axis","PI","viewportType","scrollSlabs","useSlabThickness","sliceRangeInfo","sliceRange","spacingInNormalDirection","focalPoint","newFocalPoint","newPosition","setCamera","render","desiredStepIndex","VolumeScrollEventDetail","currentImageId","EVENTS","VOLUME_SCROLL_OUT_OF_BOUNDS","VOLUME_VIEWPORT_SCROLL","scrollVolume","VideoViewport","uuidv4","ChangeTypesForInterpolation","HandlesUpdated","InterpolationUpdated","InterpolationManager","toolNames","addTool","interpolationUID","autoGenerated","interpolationCompleted","handleAnnotationCompleted","originalToolName","viewportData","sliceData","getSliceData","hasInterpolationUID","filterData","parentKey","interpolationAnnotations","skipUIDs","interpolationAnnotation","handleAnnotationUpdate","changeType","isInterpolationUpdate","handleAnnotationDelete","numberOfSlices","getNumberOfSlices","getCurrentImageIdIndex","setBrushSizeForToolGroup","toolGroupId","brushSize","getToolGroup","invalidateBrushCursor","viewportsInfo","getViewportsInfo","viewportsInfoArray","viewportIds","getViewportIds","getRenderingEngine","getBrushSizeForToolGroup","toolInstances","brushToolInstance","setBrushThresholdForToolGroup","threshold","otherArgs","isDynamic","brushBasedToolInstances","strategySpecificConfiguration","THRESHOLD","getBrushThresholdForToolGroup","isLineInSegment","isInSegment","ijk1","toIJK","ijk2","testPoint","testIJK","testSize","round","unitDelta","findLargestBidirectional","maxBidirectional","testCenter","ijk","createIsInSegment","sliceContour","bidirectional","createBidirectionalForSlice","assign","currentMax","maxMajor","maxMinor","currentMaxMinor","currentMaxMajor","maxMajorPoints","index1","index2","distance2","handle0","handle1","unitMajor","maxMinorPoints","majorAxis","minorAxis","SegmentationRepresentations","contourAndFindLargestBidirectional","createBidirectionalToolData","bidirectionalData","major0","major1","minor0","minor1","isLocked","isVisible","createImageIdReferenceMap","imageIdsArray","segmentationImageIds","async","createLabelmapVolumeForViewport","input","getEnabledElementByIds","getDefaultActor","properties","volumeLoader","labelmaps","origin","labelmap","outputData","arrayType","lpad","string","character","join","getter","seed","onFlood","onBoundary","equals","diagonals","startNode","permutations","perms","permutation","parseInt","toString","permute","perm","countNonZeroes","prunedPermutations","stack","flooded","visits","bounds","currentArgs","flood","boundaries","from","job","getArgs","prevArgs","previousArgs","iKey","markAsVisited","node","member","markAsFlooded","nextArgs","pushAdjacent","markAsBoundary","getDefaultRepresentationConfig","representationType","getHoveredContourSegmentationAnnotation","annotationUIDs","getSegmentAtLabelmapBorder","worldPoint","searchRadius","labelmapData","LABELMAP","getScalarValueFromWorld","onEdge","getNeighborIndex","deltaI","deltaJ","neighborCanvas","isSegmentOnEdge","isSegmentOnEdgeCanvas","imageIdReferenceMap","segmentationImageId","getImage","segmentationRepresentations","getSegmentationIdRepresentations","segmentationRepresentationUID","segmentationActor","getActor","getMapper","getInputData","indexIJK","voxelManager","createVolumeVoxelManager","getAtIJKPoint","deltaK","neighborIJK","getAtIJK","isSegmentOnEdgeIJK","neighborRange","neighborIndex","getSegmentAtWorldPoint","desiredRepresentation","getSegmentAtWorldForLabelmap","Contour","contourData","segmentIndices","annotationsSet","getSegmentAtWorldForContour","isValidRepresentationConfig","thresholdVolumeInformation","validToolNames","_validateAnnotations","outputSegmentationVolume","modified","segmentContourAction","configurationData","getSegment","defaultGetSegment","getFrameOfReferenceUID","segmentationsList","bidirectionals","hasExistingActiveSegment","existingLargestBidirectionals","existingBidirectionalItem","newBidirectional","existingLargestBidirectional","updateSegment","bidirectionalToolData","style","setAnnotationStyles","jumpToSlice","segmentData","segmentationIndex","overlapType","baseVolumeIdx","volumeInfoList","volumeInfo","volumeSize","referenceValues","lower","upper","_handleSameSizeVolume","total","overlaps","overlapBounds","callbackOverlap","overlapTest","_handleDifferentSizeVolume","triggerSegmentationDataModified","segmentationImageData","overwrite","testOverlapRange","voxelSpacing","voxelCenter","testRange","computeOffsetIndex","insert","getBrushToolInstances","toolInstance","equalsCheck","getVoxelOverlap","voxelCornersWorld","voxelCornersIJK","processVolumes","segmentationSpacing","resetPrefetchTimeout","maxImagesToPrefetch","preserveExistingPool","resetPrefetchDelay","prefetch","stackPrefetchData","stackPrefetch","currentImageIdIndex","indicesToRequest","removeFromList","imageIdIndex","getImageLoadObject","isLoaded","imageLoadPoolManager","clearRequestStack","nearest","nextImageIdIndex","lowerIndex","higherIndex","imageIdsToPrefetch","currentIndex","shouldLoadLower","shouldLoadHigher","requestFn","imageLoader","useNorm16Texture","preferSizeOverAccuracy","rendering","useNativeDataType","targetBuffer","preScale","requestType","addRequest","bind","onImageUpdated","target","error","enable","indexOfCurrentImage","removeEventListener","STACK_NEW_IMAGE","addEventListener","promiseRemovedHandler","IMAGE_CACHE_IMAGE_REMOVED","disable","getConfiguration","setConfiguration","minBefore","maxAfter","directionExtraImages","indicesToRequestCopy","filterRequests","then","getCachedImageBasedOnImageURI","stats","decodeTimeInMS","loadTimeInMS","sizeInBytes","usage","getMaxCacheSize","cacheFill","fillTime","fillSize","roundNumber","initialTime","initialSize","updateToolState","doneCallback","stackCount","totalBytes","positionFraction","minIndex","maxIndex","getDeltaPoints","lastPoints","curr","getMeanPoints","last","page","_subtractPoints2D","client","point0","getDeltaDistance","_getDistance2D","_getDistance3D","getDeltaRotation","getDeltaDistanceBetweenIPoints","currentDistance","_getMeanDistanceBetweenAllIPoints","lastDistance","copyPointsList","parse","copyPoints","prev","getMeanTouchPoints","touch","identifier","radiusX","radiusY","force","rotationAngle","pairedDistance","toolGroupIds","viewportInfo","getViewport","isViewportPreScaled","targetIdTokens","scaled","currentImageIndex","_getImageSliceData","lastSliceIndex","_getImageIndexToJump","jumpToWorld","jumpWorld","normal","dotProd","projectedDelta","_applyShift","filterViewportsWithFrameOfReferenceUID","numViewports","viewportsWithFrameOfReferenceUID","vp","Active","Passive","Enabled","ToolModes","filterViewportsWithToolEnabled","viewportsWithToolEnabled","_toolGroupHasActiveEnabledOrPassiveTool","toolOptions","toolMode","mode","EPS","vpCamera","getViewportIdsWithToolToRender","requireParallelNormals","getViewports","DEFAULTS","MULTIPLIER","RANGE_TEXT_POSITION","Right","TICKS_BAR_SIZE","Colorbar","props","_isMouseOver","_isInteracting","_mouseOverCallback","showTicks","stopPropagation","_mouseOutCallback","hideTicks","_mouseDownCallback","_addVOIEventListeners","_mouseDragCallback","initialState","multipliers","getVOIMultipliers","_getPointsFromMouseEvent","startPoints","voiRange","startVOIRange","canvasDelta","local","wwDelta","wcDelta","voiLower","voiUpper","windowWidth","windowCenter","newVoiRange","preventDefault","_mouseUpCallback","_removeVOIEventListeners","_eventListenersManager","_colormaps","getColormapsMap","_activeColormapName","getInitialColormapName","_canvas","_createCanvas","_ticksBar","_createTicksBar","_rangeTextPosition","ticks","appendTo","rootElement","_addRootElementEventListeners","activeColormapName","colormapName","colormap","imageRange","currentVoiRange","onVoiChange","showFullImageRange","showFullPixelValueRange","destroy","reset","createRootElement","document","createElement","onContainerResize","updateTicksBar","containerSize","visible","colormaps","items","item","Name","some","cm","ticksProps","clientPoint","clientX","clientY","pagePoint","pageX","pageY","getBoundingClientRect","pageXOffset","pageYOffset","containerWidth","containerHeight","ticksBar","rangeTextPosition","isHorizontal","ticksBarTop","ticksBarLeft","Top","Left","manager","initialDragState","defaultImageRange","ViewportColorbar","_getImageRange","_getVOIRange","autoHideTicks","_hideTicksTimeoutId","timeLeft","_hideTicksTime","_stackNewImageCallback","_element","_imageVolumeModifiedCallback","imageVolume","_volumeId","_viewportVOIModifiedCallback","showAndAutoHideTicks","_viewportColormapModifiedCallback","_addCornerstoneEventListener","setProperties","viewportsContainingVolumeUID","getRange","volumeActor","getProperty","getRGBTransferFunction","interval","IMAGE_VOLUME_MODIFIED","VOI_MODIFIED","COLORMAP_MODIFIED","ColorbarRangeTextPosition","vtkErrorMacro","vtkDebugMacro","m","vtkImageMarchingSquares","publicAPI","model","classHierarchy","getContourValues","contourValues","ids","pixelScalars","pixelPts","edgeLocator","newInstance","getPixelScalars","dims","increments","kernelX","kernelY","ii","getPixelPoints","produceLines","cVal","slicingMode","CASE_MASK","xyz","pId","pixelLines","getCase","eid","edgeVerts","getEdge","mergePoints","isInsertedEdge","x0","insertEdge","requestData","inData","outData","getOrigin","extent","getExtent","computeIncrements","getKernels","cv","initialize","polydata","setData","Uint32Array","timeEnd","DEFAULT_VALUES","extend","initialValues","arguments","obj","algo","setGet","vtkImageMarchingSquares$1"],"sourceRoot":""}