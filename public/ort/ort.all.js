/*! For license information please see ort.all.js.LICENSE.txt */
"use strict";var ort=(()=>{var __create=Object.create,__defProp=Object.defineProperty,__getOwnPropDesc=Object.getOwnPropertyDescriptor,__getOwnPropNames=Object.getOwnPropertyNames,__getProtoOf=Object.getPrototypeOf,__hasOwnProp=Object.prototype.hasOwnProperty,__esm=(t,e)=>function(){return t&&(e=(0,t[__getOwnPropNames(t)[0]])(t=0)),e},__commonJS=(t,e)=>function(){return e||(0,t[__getOwnPropNames(t)[0]])((e={exports:{}}).exports,e),e.exports},__export=(t,e)=>{for(var n in e)__defProp(t,n,{get:e[n],enumerable:!0})},__copyProps=(t,e,n,B)=>{if(e&&"object"==typeof e||"function"==typeof e)for(let s of __getOwnPropNames(e))__hasOwnProp.call(t,s)||s===n||__defProp(t,s,{get:()=>e[s],enumerable:!(B=__getOwnPropDesc(e,s))||B.enumerable});return t},__toESM=(t,e,n)=>(n=null!=t?__create(__getProtoOf(t)):{},__copyProps(!e&&t&&t.__esModule?n:__defProp(n,"default",{value:t,enumerable:!0}),t)),__toCommonJS=t=>__copyProps(__defProp({},"__esModule",{value:!0}),t),backends,backendsSortedByPriority,registerBackend,resolveBackend,init_backend_impl=__esm({"common/dist/esm/backend-impl.js"(){backends=new Map,backendsSortedByPriority=[],registerBackend=(t,e,n)=>{if(!e||"function"!=typeof e.init||"function"!=typeof e.createInferenceSessionHandler)throw new TypeError("not a valid backend");{const B=backends.get(t);if(void 0===B)backends.set(t,{backend:e,priority:n});else{if(B.priority>n)return;if(B.priority===n&&B.backend!==e)throw new Error(`cannot register backend "${t}" using priority ${n}`)}if(n>=0){const e=backendsSortedByPriority.indexOf(t);-1!==e&&backendsSortedByPriority.splice(e,1);for(let e=0;e<backendsSortedByPriority.length;e++)if(backends.get(backendsSortedByPriority[e]).priority<=n)return void backendsSortedByPriority.splice(e,0,t);backendsSortedByPriority.push(t)}}},resolveBackend=async t=>{const e=0===t.length?backendsSortedByPriority:t,n=[];for(const t of e){const e=backends.get(t);if(e){if(e.initialized)return e.backend;if(e.aborted)continue;const B=!!e.initPromise;try{return B||(e.initPromise=e.backend.init(t)),await e.initPromise,e.initialized=!0,e.backend}catch(s){B||n.push({name:t,err:s}),e.aborted=!0}finally{delete e.initPromise}}}throw new Error(`no available backend found. ERR: ${n.map((t=>`[${t.name}] ${t.err}`)).join(", ")}`)}}}),init_backend=__esm({"common/dist/esm/backend.js"(){init_backend_impl()}}),version,init_version=__esm({"common/dist/esm/version.js"(){version="1.17.1"}}),logLevelValue,env,init_env_impl=__esm({"common/dist/esm/env-impl.js"(){init_version(),logLevelValue="warning",env={wasm:{},webgl:{},webgpu:{},versions:{common:version},set logLevel(t){if(void 0!==t){if("string"!=typeof t||-1===["verbose","info","warning","error","fatal"].indexOf(t))throw new Error(`Unsupported logging level: ${t}`);logLevelValue=t}},get logLevel(){return logLevelValue}},Object.defineProperty(env,"logLevel",{enumerable:!0})}}),env2,init_env=__esm({"common/dist/esm/env.js"(){init_env_impl(),env2=env}}),tensorToDataURL,tensorToImageData,init_tensor_conversion_impl=__esm({"common/dist/esm/tensor-conversion-impl.js"(){tensorToDataURL=(t,e)=>{const n="undefined"!=typeof document?document.createElement("canvas"):new OffscreenCanvas(1,1);n.width=t.dims[3],n.height=t.dims[2];const B=n.getContext("2d");if(null!=B){let s,F;void 0!==e?.tensorLayout&&"NHWC"===e.tensorLayout?(s=t.dims[2],F=t.dims[3]):(s=t.dims[3],F=t.dims[2]);const Q=void 0!==e?.format?e.format:"RGB",U=e?.norm;let i,a;void 0===U||void 0===U.mean?i=[255,255,255,255]:"number"==typeof U.mean?i=[U.mean,U.mean,U.mean,U.mean]:(i=[U.mean[0],U.mean[1],U.mean[2],0],void 0!==U.mean[3]&&(i[3]=U.mean[3])),void 0===U||void 0===U.bias?a=[0,0,0,0]:"number"==typeof U.bias?a=[U.bias,U.bias,U.bias,U.bias]:(a=[U.bias[0],U.bias[1],U.bias[2],0],void 0!==U.bias[3]&&(a[3]=U.bias[3]));const l=F*s;let c=0,g=l,d=2*l,I=-1;"RGBA"===Q?(c=0,g=l,d=2*l,I=3*l):"RGB"===Q?(c=0,g=l,d=2*l):"RBG"===Q&&(c=0,d=l,g=2*l);for(let e=0;e<F;e++)for(let n=0;n<s;n++){const s=(t.data[c++]-a[0])*i[0],F=(t.data[g++]-a[1])*i[1],Q=(t.data[d++]-a[2])*i[2],U=-1===I?255:(t.data[I++]-a[3])*i[3];B.fillStyle="rgba("+s+","+F+","+Q+","+U+")",B.fillRect(n,e,1,1)}if("toDataURL"in n)return n.toDataURL();throw new Error("toDataURL is not supported")}throw new Error("Can not access image data")},tensorToImageData=(t,e)=>{const n="undefined"!=typeof document?document.createElement("canvas").getContext("2d"):new OffscreenCanvas(1,1).getContext("2d");let B;if(null==n)throw new Error("Can not access image data");{let s,F,Q;void 0!==e?.tensorLayout&&"NHWC"===e.tensorLayout?(s=t.dims[2],F=t.dims[1],Q=t.dims[3]):(s=t.dims[3],F=t.dims[2],Q=t.dims[1]);const U=void 0!==e&&void 0!==e.format?e.format:"RGB",i=e?.norm;let a,l;void 0===i||void 0===i.mean?a=[255,255,255,255]:"number"==typeof i.mean?a=[i.mean,i.mean,i.mean,i.mean]:(a=[i.mean[0],i.mean[1],i.mean[2],255],void 0!==i.mean[3]&&(a[3]=i.mean[3])),void 0===i||void 0===i.bias?l=[0,0,0,0]:"number"==typeof i.bias?l=[i.bias,i.bias,i.bias,i.bias]:(l=[i.bias[0],i.bias[1],i.bias[2],0],void 0!==i.bias[3]&&(l[3]=i.bias[3]));const c=F*s;if(void 0!==e&&(void 0!==e.format&&4===Q&&"RGBA"!==e.format||3===Q&&"RGB"!==e.format&&"BGR"!==e.format))throw new Error("Tensor format doesn't match input tensor dims");const g=4;let d=0,I=1,o=2,r=3,u=0,b=c,C=2*c,p=-1;"RGBA"===U?(u=0,b=c,C=2*c,p=3*c):"RGB"===U?(u=0,b=c,C=2*c):"RBG"===U&&(u=0,C=c,b=2*c),B=n.createImageData(s,F);for(let e=0;e<F*s;d+=g,I+=g,o+=g,r+=g,e++)B.data[d]=(t.data[u++]-l[0])*a[0],B.data[I]=(t.data[b++]-l[1])*a[1],B.data[o]=(t.data[C++]-l[2])*a[2],B.data[r]=-1===p?255:(t.data[p++]-l[3])*a[3]}return B}}}),bufferToTensor,tensorFromImage,tensorFromTexture,tensorFromGpuBuffer,tensorFromPinnedBuffer,init_tensor_factory_impl=__esm({"common/dist/esm/tensor-factory-impl.js"(){init_tensor_impl(),bufferToTensor=(t,e)=>{if(void 0===t)throw new Error("Image buffer must be defined");if(void 0===e.height||void 0===e.width)throw new Error("Image height and width must be defined");if("NHWC"===e.tensorLayout)throw new Error("NHWC Tensor layout is not supported yet");const{height:n,width:B}=e,s=e.norm??{mean:255,bias:0};let F,Q;F="number"==typeof s.mean?[s.mean,s.mean,s.mean,s.mean]:[s.mean[0],s.mean[1],s.mean[2],s.mean[3]??255],Q="number"==typeof s.bias?[s.bias,s.bias,s.bias,s.bias]:[s.bias[0],s.bias[1],s.bias[2],s.bias[3]??0];const U=void 0!==e.format?e.format:"RGBA",i=void 0!==e.tensorFormat&&void 0!==e.tensorFormat?e.tensorFormat:"RGB",a=n*B,l="RGBA"===i?new Float32Array(4*a):new Float32Array(3*a);let c=4,g=0,d=1,I=2,o=3,r=0,u=a,b=2*a,C=-1;"RGB"===U&&(c=3,g=0,d=1,I=2,o=-1),"RGBA"===i?C=3*a:"RBG"===i?(r=0,b=a,u=2*a):"BGR"===i&&(b=0,u=a,r=2*a);for(let e=0;e<a;e++,g+=c,I+=c,d+=c,o+=c)l[r++]=(t[g]+Q[0])/F[0],l[u++]=(t[d]+Q[1])/F[1],l[b++]=(t[I]+Q[2])/F[2],-1!==C&&-1!==o&&(l[C++]=(t[o]+Q[3])/F[3]);return new Tensor("float32",l,"RGBA"===i?[1,4,n,B]:[1,3,n,B])},tensorFromImage=async(t,e)=>{const n="undefined"!=typeof HTMLImageElement&&t instanceof HTMLImageElement,B="undefined"!=typeof ImageData&&t instanceof ImageData,s="undefined"!=typeof ImageBitmap&&t instanceof ImageBitmap,F="string"==typeof t;let Q,U=e??{};const i=()=>{if("undefined"!=typeof document)return document.createElement("canvas");if("undefined"!=typeof OffscreenCanvas)return new OffscreenCanvas(1,1);throw new Error("Canvas is not supported")},a=t=>t instanceof HTMLCanvasElement||t instanceof OffscreenCanvas?t.getContext("2d"):null;if(n){const n=i();n.width=t.width,n.height=t.height;const B=a(n);if(null==B)throw new Error("Can not access image data");{let n=t.height,s=t.width;if(void 0!==e&&void 0!==e.resizedHeight&&void 0!==e.resizedWidth&&(n=e.resizedHeight,s=e.resizedWidth),void 0!==e){if(U=e,void 0!==e.tensorFormat)throw new Error("Image input config format must be RGBA for HTMLImageElement");U.tensorFormat="RGBA",U.height=n,U.width=s}else U.tensorFormat="RGBA",U.height=n,U.width=s;B.drawImage(t,0,0),Q=B.getImageData(0,0,s,n).data}}else{if(!B){if(s){if(void 0===e)throw new Error("Please provide image config with format for Imagebitmap");const n=i();n.width=t.width,n.height=t.height;const B=a(n);if(null!=B){const e=t.height,n=t.width;return B.drawImage(t,0,0,n,e),Q=B.getImageData(0,0,n,e).data,U.height=e,U.width=n,bufferToTensor(Q,U)}throw new Error("Can not access image data")}if(F)return new Promise(((e,n)=>{const B=i(),s=a(B);if(!t||!s)return n();const F=new Image;F.crossOrigin="Anonymous",F.src=t,F.onload=()=>{B.width=F.width,B.height=F.height,s.drawImage(F,0,0,B.width,B.height);const t=s.getImageData(0,0,B.width,B.height);U.height=B.height,U.width=B.width,e(bufferToTensor(t.data,U))}}));throw new Error("Input data provided is not supported - aborted tensor creation")}{let n,B;if(void 0!==e&&void 0!==e.resizedWidth&&void 0!==e.resizedHeight?(n=e.resizedHeight,B=e.resizedWidth):(n=t.height,B=t.width),void 0!==e&&(U=e),U.format="RGBA",U.height=n,U.width=B,void 0!==e){const e=i();e.width=B,e.height=n;const s=a(e);if(null==s)throw new Error("Can not access image data");s.putImageData(t,0,0),Q=s.getImageData(0,0,B,n).data}else Q=t.data}}if(void 0!==Q)return bufferToTensor(Q,U);throw new Error("Input data provided is not supported - aborted tensor creation")},tensorFromTexture=(t,e)=>{const{width:n,height:B,download:s,dispose:F}=e;return new Tensor({location:"texture",type:"float32",texture:t,dims:[1,B,n,4],download:s,dispose:F})},tensorFromGpuBuffer=(t,e)=>{const{dataType:n,dims:B,download:s,dispose:F}=e;return new Tensor({location:"gpu-buffer",type:n??"float32",gpuBuffer:t,dims:B,download:s,dispose:F})},tensorFromPinnedBuffer=(t,e,n)=>new Tensor({location:"cpu-pinned",type:t,data:e,dims:n??[e.length]})}}),NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP,NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP,isBigIntChecked,checkBigInt,init_tensor_impl_type_mapping=__esm({"common/dist/esm/tensor-impl-type-mapping.js"(){NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP=new Map([["float32",Float32Array],["uint8",Uint8Array],["int8",Int8Array],["uint16",Uint16Array],["float16",Uint16Array],["int16",Int16Array],["int32",Int32Array],["bool",Uint8Array],["float64",Float64Array],["uint32",Uint32Array]]),NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP=new Map([[Float32Array,"float32"],[Uint8Array,"uint8"],[Int8Array,"int8"],[Uint16Array,"uint16"],[Int16Array,"int16"],[Int32Array,"int32"],[Float64Array,"float64"],[Uint32Array,"uint32"]]),isBigIntChecked=!1,checkBigInt=()=>{if(!isBigIntChecked){isBigIntChecked=!0;const t="undefined"!=typeof BigInt64Array&&"function"==typeof BigInt64Array.from,e="undefined"!=typeof BigUint64Array&&"function"==typeof BigUint64Array.from;t&&(NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.set("int64",BigInt64Array),NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.set(BigInt64Array,"int64")),e&&(NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.set("uint64",BigUint64Array),NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.set(BigUint64Array,"uint64"))}}}}),calculateSize,tensorReshape,init_tensor_utils_impl=__esm({"common/dist/esm/tensor-utils-impl.js"(){init_tensor_impl(),calculateSize=t=>{let e=1;for(let n=0;n<t.length;n++){const B=t[n];if("number"!=typeof B||!Number.isSafeInteger(B))throw new TypeError(`dims[${n}] must be an integer, got: ${B}`);if(B<0)throw new RangeError(`dims[${n}] must be a non-negative integer, got: ${B}`);e*=B}return e},tensorReshape=(t,e)=>{switch(t.location){case"cpu":return new Tensor(t.type,t.data,e);case"cpu-pinned":return new Tensor({location:"cpu-pinned",data:t.data,type:t.type,dims:e});case"texture":return new Tensor({location:"texture",texture:t.texture,type:t.type,dims:e});case"gpu-buffer":return new Tensor({location:"gpu-buffer",gpuBuffer:t.gpuBuffer,type:t.type,dims:e});default:throw new Error(`tensorReshape: tensor location ${t.location} is not supported`)}}}}),Tensor,init_tensor_impl=__esm({"common/dist/esm/tensor-impl.js"(){init_tensor_conversion_impl(),init_tensor_factory_impl(),init_tensor_impl_type_mapping(),init_tensor_utils_impl(),Tensor=class{constructor(t,e,n){let B,s;if(checkBigInt(),"object"==typeof t&&"location"in t)switch(this.dataLocation=t.location,B=t.type,s=t.dims,t.location){case"cpu-pinned":{const e=NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.get(B);if(!e)throw new TypeError(`unsupported type "${B}" to create tensor from pinned buffer`);if(!(t.data instanceof e))throw new TypeError(`buffer should be of type ${e.name}`);this.cpuData=t.data;break}case"texture":if("float32"!==B)throw new TypeError(`unsupported type "${B}" to create tensor from texture`);this.gpuTextureData=t.texture,this.downloader=t.download,this.disposer=t.dispose;break;case"gpu-buffer":if("float32"!==B&&"float16"!==B&&"int32"!==B&&"int64"!==B&&"uint32"!==B&&"bool"!==B)throw new TypeError(`unsupported type "${B}" to create tensor from gpu buffer`);this.gpuBufferData=t.gpuBuffer,this.downloader=t.download,this.disposer=t.dispose;break;default:throw new Error(`Tensor constructor: unsupported location '${this.dataLocation}'`)}else{let F,Q;if("string"==typeof t)if(B=t,Q=n,"string"===t){if(!Array.isArray(e))throw new TypeError("A string tensor's data must be a string array.");F=e}else{const n=NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.get(t);if(void 0===n)throw new TypeError(`Unsupported tensor type: ${t}.`);if(Array.isArray(e)){if("float16"===t)throw new TypeError("Creating a float16 tensor from number array is not supported. Please use Uint16Array as data.");F="uint64"===t||"int64"===t?n.from(e,BigInt):n.from(e)}else{if(!(e instanceof n))throw new TypeError(`A ${B} tensor's data must be type of ${n}`);F=e}}else if(Q=e,Array.isArray(t)){if(0===t.length)throw new TypeError("Tensor type cannot be inferred from an empty array.");const e=typeof t[0];if("string"===e)B="string",F=t;else{if("boolean"!==e)throw new TypeError(`Invalid element type of data array: ${e}.`);B="bool",F=Uint8Array.from(t)}}else{const e=NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.get(t.constructor);if(void 0===e)throw new TypeError(`Unsupported type for tensor data: ${t.constructor}.`);B=e,F=t}if(void 0===Q)Q=[F.length];else if(!Array.isArray(Q))throw new TypeError("A tensor's dims must be a number array");s=Q,this.cpuData=F,this.dataLocation="cpu"}const F=calculateSize(s);if(this.cpuData&&F!==this.cpuData.length)throw new Error(`Tensor's size(${F}) does not match data length(${this.cpuData.length}).`);this.type=B,this.dims=s,this.size=F}static async fromImage(t,e){return tensorFromImage(t,e)}static fromTexture(t,e){return tensorFromTexture(t,e)}static fromGpuBuffer(t,e){return tensorFromGpuBuffer(t,e)}static fromPinnedBuffer(t,e,n){return tensorFromPinnedBuffer(t,e,n)}toDataURL(t){return tensorToDataURL(this,t)}toImageData(t){return tensorToImageData(this,t)}get data(){if(this.ensureValid(),!this.cpuData)throw new Error("The data is not on CPU. Use `getData()` to download GPU data to CPU, or use `texture` or `gpuBuffer` property to access the GPU data directly.");return this.cpuData}get location(){return this.dataLocation}get texture(){if(this.ensureValid(),!this.gpuTextureData)throw new Error("The data is not stored as a WebGL texture.");return this.gpuTextureData}get gpuBuffer(){if(this.ensureValid(),!this.gpuBufferData)throw new Error("The data is not stored as a WebGPU buffer.");return this.gpuBufferData}async getData(t){switch(this.ensureValid(),this.dataLocation){case"cpu":case"cpu-pinned":return this.data;case"texture":case"gpu-buffer":if(!this.downloader)throw new Error("The current tensor is not created with a specified data downloader.");if(this.isDownloading)throw new Error("The current tensor is being downloaded.");try{this.isDownloading=!0;const e=await this.downloader();return this.downloader=void 0,this.dataLocation="cpu",this.cpuData=e,t&&this.disposer&&(this.disposer(),this.disposer=void 0),e}finally{this.isDownloading=!1}default:throw new Error(`cannot get data from location: ${this.dataLocation}`)}}dispose(){if(this.isDownloading)throw new Error("The current tensor is being downloaded.");this.disposer&&(this.disposer(),this.disposer=void 0),this.cpuData=void 0,this.gpuTextureData=void 0,this.gpuBufferData=void 0,this.downloader=void 0,this.isDownloading=void 0,this.dataLocation="none"}ensureValid(){if("none"===this.dataLocation)throw new Error("The tensor is disposed.")}reshape(t){if(this.ensureValid(),this.downloader||this.disposer)throw new Error("Cannot reshape a tensor that owns GPU resource.");return tensorReshape(this,t)}}}}),Tensor2,init_tensor=__esm({"common/dist/esm/tensor.js"(){init_tensor_impl(),Tensor2=Tensor}}),TRACE,TRACE_FUNC,TRACE_FUNC_BEGIN,TRACE_FUNC_END,init_trace=__esm({"common/dist/esm/trace.js"(){init_env_impl(),TRACE=(t,e)=>{env.wasm.trace&&console.timeStamp(`${t}::ORT::${e}`)},TRACE_FUNC=(t,e)=>{const n=(new Error).stack?.split(/\r\n|\r|\n/g)||[];let B=!1;for(let s=0;s<n.length;s++){if(B&&!n[s].includes("TRACE_FUNC")){let B=`FUNC_${t}::${n[s].trim().split(" ")[1]}`;return e&&(B+=`::${e}`),void TRACE("CPU",B)}n[s].includes("TRACE_FUNC")&&(B=!0)}},TRACE_FUNC_BEGIN=t=>{env.wasm.trace&&TRACE_FUNC("BEGIN",t)},TRACE_FUNC_END=t=>{env.wasm.trace&&TRACE_FUNC("END",t)}}}),InferenceSession,init_inference_session_impl=__esm({"common/dist/esm/inference-session-impl.js"(){init_backend_impl(),init_tensor(),init_trace(),InferenceSession=class t{constructor(t){this.handler=t}async run(t,e,n){TRACE_FUNC_BEGIN();const B={};let s={};if("object"!=typeof t||null===t||t instanceof Tensor2||Array.isArray(t))throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let F=!0;if("object"==typeof e){if(null===e)throw new TypeError("Unexpected argument[1]: cannot be null.");if(e instanceof Tensor2)throw new TypeError("'fetches' cannot be a Tensor");if(Array.isArray(e)){if(0===e.length)throw new TypeError("'fetches' cannot be an empty array.");F=!1;for(const t of e){if("string"!=typeof t)throw new TypeError("'fetches' must be a string array or an object.");if(-1===this.outputNames.indexOf(t))throw new RangeError(`'fetches' contains invalid output name: ${t}.`);B[t]=null}if("object"==typeof n&&null!==n)s=n;else if(void 0!==n)throw new TypeError("'options' must be an object.")}else{let t=!1;const Q=Object.getOwnPropertyNames(e);for(const n of this.outputNames)if(-1!==Q.indexOf(n)){const s=e[n];(null===s||s instanceof Tensor2)&&(t=!0,F=!1,B[n]=s)}if(t){if("object"==typeof n&&null!==n)s=n;else if(void 0!==n)throw new TypeError("'options' must be an object.")}else s=e}}else if(void 0!==e)throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(const e of this.inputNames)if(void 0===t[e])throw new Error(`input '${e}' is missing in 'feeds'.`);if(F)for(const t of this.outputNames)B[t]=null;const Q=await this.handler.run(t,B,s),U={};for(const t in Q)if(Object.hasOwnProperty.call(Q,t)){const e=Q[t];U[t]=e instanceof Tensor2?e:new Tensor2(e.type,e.data,e.dims)}return TRACE_FUNC_END(),U}async release(){return this.handler.dispose()}static async create(e,n,B,s){let F;TRACE_FUNC_BEGIN();let Q={};if("string"==typeof e){if(F=e,"object"==typeof n&&null!==n)Q=n;else if(void 0!==n)throw new TypeError("'options' must be an object.")}else if(e instanceof Uint8Array){if(F=e,"object"==typeof n&&null!==n)Q=n;else if(void 0!==n)throw new TypeError("'options' must be an object.")}else{if(!(e instanceof ArrayBuffer||"undefined"!=typeof SharedArrayBuffer&&e instanceof SharedArrayBuffer))throw new TypeError("Unexpected argument[0]: must be 'path' or 'buffer'.");{const t=e;let U=0,i=e.byteLength;if("object"==typeof n&&null!==n)Q=n;else if("number"==typeof n){if(U=n,!Number.isSafeInteger(U))throw new RangeError("'byteOffset' must be an integer.");if(U<0||U>=t.byteLength)throw new RangeError(`'byteOffset' is out of range [0, ${t.byteLength}).`);if(i=e.byteLength-U,"number"==typeof B){if(i=B,!Number.isSafeInteger(i))throw new RangeError("'byteLength' must be an integer.");if(i<=0||U+i>t.byteLength)throw new RangeError(`'byteLength' is out of range (0, ${t.byteLength-U}].`);if("object"==typeof s&&null!==s)Q=s;else if(void 0!==s)throw new TypeError("'options' must be an object.")}else if(void 0!==B)throw new TypeError("'byteLength' must be a number.")}else if(void 0!==n)throw new TypeError("'options' must be an object.");F=new Uint8Array(t,U,i)}}const U=(Q.executionProviders||[]).map((t=>"string"==typeof t?t:t.name)),i=await resolveBackend(U),a=await i.createInferenceSessionHandler(F,Q);return TRACE_FUNC_END(),new t(a)}startProfiling(){this.handler.startProfiling()}endProfiling(){this.handler.endProfiling()}get inputNames(){return this.handler.inputNames}get outputNames(){return this.handler.outputNames}}}}),InferenceSession2,init_inference_session=__esm({"common/dist/esm/inference-session.js"(){init_inference_session_impl(),InferenceSession2=InferenceSession}}),init_onnx_value=__esm({"common/dist/esm/onnx-value.js"(){}}),noBackendErrMsg,TrainingSession,init_training_session_impl=__esm({"common/dist/esm/training-session-impl.js"(){init_backend_impl(),init_tensor(),noBackendErrMsg="Training backend could not be resolved. Make sure you're using the correct configuration & WebAssembly files.",TrainingSession=class t{constructor(t,e,n){this.handler=t,this.hasOptimizerModel=e,this.hasEvalModel=n}get trainingInputNames(){return this.handler.inputNames}get trainingOutputNames(){return this.handler.outputNames}get evalInputNames(){if(this.hasEvalModel)return this.handler.evalInputNames;throw new Error("This training session has no evalModel loaded.")}get evalOutputNames(){if(this.hasEvalModel)return this.handler.evalOutputNames;throw new Error("This training session has no evalModel loaded.")}static async create(e,n){const B=e.evalModel||"",s=e.optimizerModel||"",F=n||{},Q=(F.executionProviders||[]).map((t=>"string"==typeof t?t:t.name)),U=await resolveBackend(Q);if(U.createTrainingSessionHandler){const n=await U.createTrainingSessionHandler(e.checkpointState,e.trainModel,B,s,F);return new t(n,!!e.optimizerModel,!!e.evalModel)}throw new Error(noBackendErrMsg)}typeNarrowingForRunStep(t,e,n,B,s){const F={};let Q={};if("object"!=typeof n||null===n||n instanceof Tensor2||Array.isArray(n))throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let U=!0;if("object"==typeof B){if(null===B)throw new TypeError("Unexpected argument[1]: cannot be null.");if(B instanceof Tensor2)throw new TypeError("'fetches' cannot be a Tensor");if(Array.isArray(B)){if(0===B.length)throw new TypeError("'fetches' cannot be an empty array.");U=!1;for(const t of B){if("string"!=typeof t)throw new TypeError("'fetches' must be a string array or an object.");if(-1===e.indexOf(t))throw new RangeError(`'fetches' contains invalid output name: ${t}.`);F[t]=null}if("object"==typeof s&&null!==s)Q=s;else if(void 0!==s)throw new TypeError("'options' must be an object.")}else{let t=!1;const n=Object.getOwnPropertyNames(B);for(const s of e)if(-1!==n.indexOf(s)){const e=B[s];(null===e||e instanceof Tensor2)&&(t=!0,U=!1,F[s]=e)}if(t){if("object"==typeof s&&null!==s)Q=s;else if(void 0!==s)throw new TypeError("'options' must be an object.")}else Q=B}}else if(void 0!==B)throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(const e of t)if(void 0===n[e])throw new Error(`input '${e}' is missing in 'feeds'.`);if(U)for(const t of e)F[t]=null;return[F,Q]}convertHandlerReturnTypeToMapOfTensors(t){const e={};for(const n in t)if(Object.hasOwnProperty.call(t,n)){const B=t[n];e[n]=B instanceof Tensor2?B:new Tensor2(B.type,B.data,B.dims)}return e}async lazyResetGrad(){await this.handler.lazyResetGrad()}async runTrainStep(t,e,n){const[B,s]=this.typeNarrowingForRunStep(this.trainingInputNames,this.trainingOutputNames,t,e,n),F=await this.handler.runTrainStep(t,B,s);return this.convertHandlerReturnTypeToMapOfTensors(F)}async runOptimizerStep(t){if(!this.hasOptimizerModel)throw new Error("This TrainingSession has no OptimizerModel loaded.");await this.handler.runOptimizerStep(t||{})}async runEvalStep(t,e,n){if(this.hasEvalModel){const[B,s]=this.typeNarrowingForRunStep(this.evalInputNames,this.evalOutputNames,t,e,n),F=await this.handler.runEvalStep(t,B,s);return this.convertHandlerReturnTypeToMapOfTensors(F)}throw new Error("This TrainingSession has no EvalModel loaded.")}async getParametersSize(t=!0){return this.handler.getParametersSize(t)}async loadParametersBuffer(t,e=!0){const n=await this.getParametersSize(e);if(t.length!==4*n)throw new Error("Size of the buffer passed into loadParametersBuffer must match the number of parameters in the model. Please use getParametersSize method to check.");return this.handler.loadParametersBuffer(t,e)}async getContiguousParameters(t=!0){return this.handler.getContiguousParameters(t)}async release(){return this.handler.dispose()}}}}),TrainingSession2,init_training_session=__esm({"common/dist/esm/training-session.js"(){init_training_session_impl(),TrainingSession2=TrainingSession}}),esm_exports={};__export(esm_exports,{InferenceSession:()=>InferenceSession2,TRACE:()=>TRACE,TRACE_FUNC_BEGIN:()=>TRACE_FUNC_BEGIN,TRACE_FUNC_END:()=>TRACE_FUNC_END,Tensor:()=>Tensor2,TrainingSession:()=>TrainingSession2,env:()=>env2,registerBackend:()=>registerBackend});var init_esm=__esm({"common/dist/esm/index.js"(){init_backend(),init_env(),init_inference_session(),init_tensor(),init_trace(),init_onnx_value(),init_training_session()}}),readFile,init_promises=__esm({"nodejs-ignore:node:fs/promises"(){readFile=void 0}}),NoOpLoggerProvider,ConsoleLoggerProvider,SEVERITY_VALUE,LOGGER_PROVIDER_MAP,LOGGER_DEFAULT_CONFIG,LOGGER_CONFIG_MAP,Logger,Event,EventRecord,Profiler,now;function log(t,e,n,B){if(void 0===e)return createCategorizedLogger(t);if(void 0===n)logInternal(t,e,1);else if("number"==typeof n&&void 0===B)logInternal(t,e,n);else if("string"==typeof n&&void 0===B)logInternal(t,n,1,e);else{if("string"!=typeof n||"number"!=typeof B)throw new TypeError("input is valid");logInternal(t,n,B,e)}}function createCategorizedLogger(t){return{verbose:log.verbose.bind(null,t),info:log.info.bind(null,t),warning:log.warning.bind(null,t),error:log.error.bind(null,t),fatal:log.fatal.bind(null,t)}}function logInternal(t,e,n,B){const s=LOGGER_CONFIG_MAP[B||""]||LOGGER_CONFIG_MAP[""];SEVERITY_VALUE[t]<SEVERITY_VALUE[s.minimalSeverity]||(s.logDateTime&&(e=`${(new Date).toISOString()}|${e}`),s.logSourceLocation,LOGGER_PROVIDER_MAP[s.provider].log(t,e,B))}var init_instrument=__esm({"web/lib/onnxjs/instrument.ts"(){NoOpLoggerProvider=class{log(t,e,n){}},ConsoleLoggerProvider=class{log(t,e,n){console.log(`${this.color(t)} ${n?"[35m"+n+"[0m ":""}${e}`)}color(t){switch(t){case"verbose":return"[34;40mv[0m";case"info":return"[32mi[0m";case"warning":return"[30;43mw[0m";case"error":return"[31;40me[0m";case"fatal":return"[101mf[0m";default:throw new Error(`unsupported severity: ${t}`)}}},SEVERITY_VALUE={verbose:1e3,info:2e3,warning:4e3,error:5e3,fatal:6e3},LOGGER_PROVIDER_MAP={none:new NoOpLoggerProvider,console:new ConsoleLoggerProvider},LOGGER_CONFIG_MAP={"":LOGGER_DEFAULT_CONFIG={provider:"console",minimalSeverity:"warning",logDateTime:!0,logSourceLocation:!1}},(t=>{function e(t){LOGGER_CONFIG_MAP={},n("",t||{})}function n(t,n){if("*"===t)e(n);else{const e=LOGGER_CONFIG_MAP[t]||LOGGER_DEFAULT_CONFIG;LOGGER_CONFIG_MAP[t]={provider:n.provider||e.provider,minimalSeverity:n.minimalSeverity||e.minimalSeverity,logDateTime:void 0===n.logDateTime?e.logDateTime:n.logDateTime,logSourceLocation:void 0===n.logSourceLocation?e.logSourceLocation:n.logSourceLocation}}}t.verbose=function(e,n){t("verbose",e,n)},t.info=function(e,n){t("info",e,n)},t.warning=function(e,n){t("warning",e,n)},t.error=function(e,n){t("error",e,n)},t.fatal=function(e,n){t("fatal",e,n)},t.reset=e,t.set=n,t.setWithEnv=function(t){const e={};t.logLevel&&(e.minimalSeverity=t.logLevel),n("",e)}})(log||(log={})),Logger=log,Event=class{constructor(t,e,n,B,s,F){this.category=t,this.name=e,this.startTime=n,this.endCallback=B,this.timer=s,this.ctx=F}async end(){return this.endCallback(this)}async checkTimer(){if(void 0===this.ctx||void 0===this.timer)throw new Error("No webgl timer found");return this.ctx.endTimer(),this.ctx.waitForQueryAndGetTime(this.timer)}},EventRecord=class{constructor(t,e,n,B){this.category=t,this.name=e,this.startTime=n,this.endTime=B}},Profiler=class{constructor(t,e,n){this._started=!1,this._flushPointer=0,this._started=!1,this._maxNumberEvents=void 0===t?1e4:t,this._flushBatchSize=void 0===e?10:e,this._flushIntervalInMilliseconds=void 0===n?5e3:n}static create(t){return void 0===t?new this:new this(t.maxNumberEvents,t.flushBatchSize,t.flushIntervalInMilliseconds)}start(){this._started=!0,this._timingEvents=[],this._flushTime=now(),this._flushPointer=0}stop(){for(this._started=!1;this._flushPointer<this._timingEvents.length;this._flushPointer++)this.logOneEvent(this._timingEvents[this._flushPointer])}event(t,e,n,B){const s=this._started?this.begin(t,e,B):void 0;let F=!1;const Q=n();if(Q&&"function"==typeof Q.then)return F=!0,new Promise(((t,e)=>{Q.then((async e=>{s&&await s.end(),t(e)}),(async t=>{s&&await s.end(),e(t)}))}));if(!F&&s){const t=s.end();if(t&&"function"==typeof t.then)return new Promise(((e,n)=>{t.then((()=>{e(Q)}),(t=>{n(t)}))}))}return Q}begin(t,e,n){if(!this._started)throw new Error("profiler is not started yet");if(void 0===n){const n=now();return this.flush(n),new Event(t,e,n,(t=>this.endSync(t)))}{const B=n.beginTimer();return new Event(t,e,0,(async t=>this.end(t)),B,n)}}async end(t){const e=await t.checkTimer();this._timingEvents.length<this._maxNumberEvents&&(this._timingEvents.push(new EventRecord(t.category,t.name,t.startTime,e)),this.flush(e))}endSync(t){const e=now();this._timingEvents.length<this._maxNumberEvents&&(this._timingEvents.push(new EventRecord(t.category,t.name,t.startTime,e)),this.flush(e))}logOneEvent(t){Logger.verbose(`Profiler.${t.category}`,`${(t.endTime-t.startTime).toFixed(2)}ms on event '${t.name}' at ${t.endTime.toFixed(2)}`)}flush(t){if(this._timingEvents.length-this._flushPointer>=this._flushBatchSize||t-this._flushTime>=this._flushIntervalInMilliseconds){for(const t=this._flushPointer;this._flushPointer<t+this._flushBatchSize&&this._flushPointer<this._timingEvents.length;this._flushPointer++)this.logOneEvent(this._timingEvents[this._flushPointer]);this._flushTime=now()}}get started(){return this._started}},now="undefined"!=typeof performance&&performance.now?()=>performance.now():Date.now}});function resolveOperator(t,e,n){for(const B of n){const n=B[0],s=B[1],F=B[2],Q=B[3],U=B[4];if(t.opType===n)for(const t of e)if((t.domain===s||"ai.onnx"===t.domain&&""===s)&&matchSelector(t.version,F))return{opImpl:Q,opInit:U}}throw new TypeError(`cannot resolve operator '${t.opType}' with opsets: ${e.map((t=>`${t.domain||"ai.onnx"} v${t.version}`)).join(", ")}`)}function matchSelector(t,e){if(e.endsWith("+")){const n=Number.parseInt(e.substring(0,e.length-1),10);return!isNaN(n)&&n<=t}if(2===e.split("-").length){const n=e.split("-"),B=Number.parseInt(n[0],10),s=Number.parseInt(n[1],10);return!isNaN(B)&&!isNaN(s)&&B<=t&&t<=s}return Number.parseInt(e,10)===t}var init_opset=__esm({"web/lib/onnxjs/opset.ts"(){}}),require_guid=__commonJS({"web/node_modules/guid-typescript/dist/guid.js"(t){t.__esModule=!0;var e=function(){function t(e){if(!e)throw new TypeError("Invalid argument; `value` has no value.");this.value=t.EMPTY,e&&t.isGuid(e)&&(this.value=e)}return t.isGuid=function(e){var n=e.toString();return e&&(e instanceof t||t.validator.test(n))},t.create=function(){return new t([t.gen(2),t.gen(1),t.gen(1),t.gen(1),t.gen(3)].join("-"))},t.createEmpty=function(){return new t("emptyguid")},t.parse=function(e){return new t(e)},t.raw=function(){return[t.gen(2),t.gen(1),t.gen(1),t.gen(1),t.gen(3)].join("-")},t.gen=function(t){for(var e="",n=0;n<t;n++)e+=(65536*(1+Math.random())|0).toString(16).substring(1);return e},t.prototype.equals=function(e){return t.isGuid(e)&&this.value===e.toString()},t.prototype.isEmpty=function(){return this.value===t.EMPTY},t.prototype.toString=function(){return this.value},t.prototype.toJSON=function(){return{value:this.value}},t.validator=new RegExp("^[a-z0-9]{8}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{12}$","i"),t.EMPTY="00000000-0000-0000-0000-000000000000",t}();t.Guid=e}}),wasm,INT_CACHE,UINT_CACHE,pow_dbl,TWO_PWR_16_DBL,TWO_PWR_24_DBL,TWO_PWR_32_DBL,TWO_PWR_64_DBL,TWO_PWR_63_DBL,TWO_PWR_24,ZERO,UZERO,ONE,UONE,NEG_ONE,MAX_VALUE,MAX_UNSIGNED_VALUE,MIN_VALUE,LongPrototype,long_default;function Long(t,e,n){this.low=0|t,this.high=0|e,this.unsigned=!!n}function isLong(t){return!0===(t&&t.__isLong__)}function ctz32(t){var e=Math.clz32(t&-t);return t?31-e:e}function fromInt(t,e){var n,B,s;return e?(s=0<=(t>>>=0)&&t<256)&&(B=UINT_CACHE[t])?B:(n=fromBits(t,0,!0),s&&(UINT_CACHE[t]=n),n):(s=-128<=(t|=0)&&t<128)&&(B=INT_CACHE[t])?B:(n=fromBits(t,t<0?-1:0,!1),s&&(INT_CACHE[t]=n),n)}function fromNumber(t,e){if(isNaN(t))return e?UZERO:ZERO;if(e){if(t<0)return UZERO;if(t>=TWO_PWR_64_DBL)return MAX_UNSIGNED_VALUE}else{if(t<=-TWO_PWR_63_DBL)return MIN_VALUE;if(t+1>=TWO_PWR_63_DBL)return MAX_VALUE}return t<0?fromNumber(-t,e).neg():fromBits(t%TWO_PWR_32_DBL|0,t/TWO_PWR_32_DBL|0,e)}function fromBits(t,e,n){return new Long(t,e,n)}function fromString(t,e,n){if(0===t.length)throw Error("empty string");if("number"==typeof e?(n=e,e=!1):e=!!e,"NaN"===t||"Infinity"===t||"+Infinity"===t||"-Infinity"===t)return e?UZERO:ZERO;if((n=n||10)<2||36<n)throw RangeError("radix");var B;if((B=t.indexOf("-"))>0)throw Error("interior hyphen");if(0===B)return fromString(t.substring(1),e,n).neg();for(var s=fromNumber(pow_dbl(n,8)),F=ZERO,Q=0;Q<t.length;Q+=8){var U=Math.min(8,t.length-Q),i=parseInt(t.substring(Q,Q+U),n);if(U<8){var a=fromNumber(pow_dbl(n,U));F=F.mul(a).add(fromNumber(i))}else F=(F=F.mul(s)).add(fromNumber(i))}return F.unsigned=e,F}function fromValue(t,e){return"number"==typeof t?fromNumber(t,e):"string"==typeof t?fromString(t,e):fromBits(t.low,t.high,"boolean"==typeof e?e:t.unsigned)}var init_long=__esm({"web/node_modules/long/index.js"(){wasm=null;try{wasm=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch(t){}Long.prototype.__isLong__,Object.defineProperty(Long.prototype,"__isLong__",{value:!0}),Long.isLong=isLong,INT_CACHE={},UINT_CACHE={},Long.fromInt=fromInt,Long.fromNumber=fromNumber,Long.fromBits=fromBits,pow_dbl=Math.pow,Long.fromString=fromString,Long.fromValue=fromValue,TWO_PWR_63_DBL=(TWO_PWR_64_DBL=(TWO_PWR_32_DBL=(TWO_PWR_16_DBL=65536)*TWO_PWR_16_DBL)*TWO_PWR_32_DBL)/2,TWO_PWR_24=fromInt(TWO_PWR_24_DBL=1<<24),ZERO=fromInt(0),Long.ZERO=ZERO,UZERO=fromInt(0,!0),Long.UZERO=UZERO,ONE=fromInt(1),Long.ONE=ONE,UONE=fromInt(1,!0),Long.UONE=UONE,NEG_ONE=fromInt(-1),Long.NEG_ONE=NEG_ONE,MAX_VALUE=fromBits(-1,2147483647,!1),Long.MAX_VALUE=MAX_VALUE,MAX_UNSIGNED_VALUE=fromBits(-1,-1,!0),Long.MAX_UNSIGNED_VALUE=MAX_UNSIGNED_VALUE,MIN_VALUE=fromBits(0,-2147483648,!1),Long.MIN_VALUE=MIN_VALUE,(LongPrototype=Long.prototype).toInt=function(){return this.unsigned?this.low>>>0:this.low},LongPrototype.toNumber=function(){return this.unsigned?(this.high>>>0)*TWO_PWR_32_DBL+(this.low>>>0):this.high*TWO_PWR_32_DBL+(this.low>>>0)},LongPrototype.toString=function(t){if((t=t||10)<2||36<t)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative()){if(this.eq(MIN_VALUE)){var e=fromNumber(t),n=this.div(e),B=n.mul(e).sub(this);return n.toString(t)+B.toInt().toString(t)}return"-"+this.neg().toString(t)}for(var s=fromNumber(pow_dbl(t,6),this.unsigned),F=this,Q="";;){var U=F.div(s),i=(F.sub(U.mul(s)).toInt()>>>0).toString(t);if((F=U).isZero())return i+Q;for(;i.length<6;)i="0"+i;Q=""+i+Q}},LongPrototype.getHighBits=function(){return this.high},LongPrototype.getHighBitsUnsigned=function(){return this.high>>>0},LongPrototype.getLowBits=function(){return this.low},LongPrototype.getLowBitsUnsigned=function(){return this.low>>>0},LongPrototype.getNumBitsAbs=function(){if(this.isNegative())return this.eq(MIN_VALUE)?64:this.neg().getNumBitsAbs();for(var t=0!=this.high?this.high:this.low,e=31;e>0&&!(t&1<<e);e--);return 0!=this.high?e+33:e+1},LongPrototype.isZero=function(){return 0===this.high&&0===this.low},LongPrototype.eqz=LongPrototype.isZero,LongPrototype.isNegative=function(){return!this.unsigned&&this.high<0},LongPrototype.isPositive=function(){return this.unsigned||this.high>=0},LongPrototype.isOdd=function(){return!(1&~this.low)},LongPrototype.isEven=function(){return!(1&this.low)},LongPrototype.equals=function(t){return isLong(t)||(t=fromValue(t)),(this.unsigned===t.unsigned||this.high>>>31!=1||t.high>>>31!=1)&&(this.high===t.high&&this.low===t.low)},LongPrototype.eq=LongPrototype.equals,LongPrototype.notEquals=function(t){return!this.eq(t)},LongPrototype.neq=LongPrototype.notEquals,LongPrototype.ne=LongPrototype.notEquals,LongPrototype.lessThan=function(t){return this.comp(t)<0},LongPrototype.lt=LongPrototype.lessThan,LongPrototype.lessThanOrEqual=function(t){return this.comp(t)<=0},LongPrototype.lte=LongPrototype.lessThanOrEqual,LongPrototype.le=LongPrototype.lessThanOrEqual,LongPrototype.greaterThan=function(t){return this.comp(t)>0},LongPrototype.gt=LongPrototype.greaterThan,LongPrototype.greaterThanOrEqual=function(t){return this.comp(t)>=0},LongPrototype.gte=LongPrototype.greaterThanOrEqual,LongPrototype.ge=LongPrototype.greaterThanOrEqual,LongPrototype.compare=function(t){if(isLong(t)||(t=fromValue(t)),this.eq(t))return 0;var e=this.isNegative(),n=t.isNegative();return e&&!n?-1:!e&&n?1:this.unsigned?t.high>>>0>this.high>>>0||t.high===this.high&&t.low>>>0>this.low>>>0?-1:1:this.sub(t).isNegative()?-1:1},LongPrototype.comp=LongPrototype.compare,LongPrototype.negate=function(){return!this.unsigned&&this.eq(MIN_VALUE)?MIN_VALUE:this.not().add(ONE)},LongPrototype.neg=LongPrototype.negate,LongPrototype.add=function(t){isLong(t)||(t=fromValue(t));var e=this.high>>>16,n=65535&this.high,B=this.low>>>16,s=65535&this.low,F=t.high>>>16,Q=65535&t.high,U=t.low>>>16,i=0,a=0,l=0,c=0;return l+=(c+=s+(65535&t.low))>>>16,a+=(l+=B+U)>>>16,i+=(a+=n+Q)>>>16,i+=e+F,fromBits((l&=65535)<<16|(c&=65535),(i&=65535)<<16|(a&=65535),this.unsigned)},LongPrototype.subtract=function(t){return isLong(t)||(t=fromValue(t)),this.add(t.neg())},LongPrototype.sub=LongPrototype.subtract,LongPrototype.multiply=function(t){if(this.isZero())return this;if(isLong(t)||(t=fromValue(t)),wasm)return fromBits(wasm.mul(this.low,this.high,t.low,t.high),wasm.get_high(),this.unsigned);if(t.isZero())return this.unsigned?UZERO:ZERO;if(this.eq(MIN_VALUE))return t.isOdd()?MIN_VALUE:ZERO;if(t.eq(MIN_VALUE))return this.isOdd()?MIN_VALUE:ZERO;if(this.isNegative())return t.isNegative()?this.neg().mul(t.neg()):this.neg().mul(t).neg();if(t.isNegative())return this.mul(t.neg()).neg();if(this.lt(TWO_PWR_24)&&t.lt(TWO_PWR_24))return fromNumber(this.toNumber()*t.toNumber(),this.unsigned);var e=this.high>>>16,n=65535&this.high,B=this.low>>>16,s=65535&this.low,F=t.high>>>16,Q=65535&t.high,U=t.low>>>16,i=65535&t.low,a=0,l=0,c=0,g=0;return c+=(g+=s*i)>>>16,l+=(c+=B*i)>>>16,c&=65535,l+=(c+=s*U)>>>16,a+=(l+=n*i)>>>16,l&=65535,a+=(l+=B*U)>>>16,l&=65535,a+=(l+=s*Q)>>>16,a+=e*i+n*U+B*Q+s*F,fromBits((c&=65535)<<16|(g&=65535),(a&=65535)<<16|(l&=65535),this.unsigned)},LongPrototype.mul=LongPrototype.multiply,LongPrototype.divide=function(t){if(isLong(t)||(t=fromValue(t)),t.isZero())throw Error("division by zero");var e,n,B;if(wasm)return this.unsigned||-2147483648!==this.high||-1!==t.low||-1!==t.high?fromBits((this.unsigned?wasm.div_u:wasm.div_s)(this.low,this.high,t.low,t.high),wasm.get_high(),this.unsigned):this;if(this.isZero())return this.unsigned?UZERO:ZERO;if(this.unsigned){if(t.unsigned||(t=t.toUnsigned()),t.gt(this))return UZERO;if(t.gt(this.shru(1)))return UONE;B=UZERO}else{if(this.eq(MIN_VALUE))return t.eq(ONE)||t.eq(NEG_ONE)?MIN_VALUE:t.eq(MIN_VALUE)?ONE:(e=this.shr(1).div(t).shl(1)).eq(ZERO)?t.isNegative()?ONE:NEG_ONE:(n=this.sub(t.mul(e)),B=e.add(n.div(t)));if(t.eq(MIN_VALUE))return this.unsigned?UZERO:ZERO;if(this.isNegative())return t.isNegative()?this.neg().div(t.neg()):this.neg().div(t).neg();if(t.isNegative())return this.div(t.neg()).neg();B=ZERO}for(n=this;n.gte(t);){e=Math.max(1,Math.floor(n.toNumber()/t.toNumber()));for(var s=Math.ceil(Math.log(e)/Math.LN2),F=s<=48?1:pow_dbl(2,s-48),Q=fromNumber(e),U=Q.mul(t);U.isNegative()||U.gt(n);)U=(Q=fromNumber(e-=F,this.unsigned)).mul(t);Q.isZero()&&(Q=ONE),B=B.add(Q),n=n.sub(U)}return B},LongPrototype.div=LongPrototype.divide,LongPrototype.modulo=function(t){return isLong(t)||(t=fromValue(t)),wasm?fromBits((this.unsigned?wasm.rem_u:wasm.rem_s)(this.low,this.high,t.low,t.high),wasm.get_high(),this.unsigned):this.sub(this.div(t).mul(t))},LongPrototype.mod=LongPrototype.modulo,LongPrototype.rem=LongPrototype.modulo,LongPrototype.not=function(){return fromBits(~this.low,~this.high,this.unsigned)},LongPrototype.countLeadingZeros=function(){return this.high?Math.clz32(this.high):Math.clz32(this.low)+32},LongPrototype.clz=LongPrototype.countLeadingZeros,LongPrototype.countTrailingZeros=function(){return this.low?ctz32(this.low):ctz32(this.high)+32},LongPrototype.ctz=LongPrototype.countTrailingZeros,LongPrototype.and=function(t){return isLong(t)||(t=fromValue(t)),fromBits(this.low&t.low,this.high&t.high,this.unsigned)},LongPrototype.or=function(t){return isLong(t)||(t=fromValue(t)),fromBits(this.low|t.low,this.high|t.high,this.unsigned)},LongPrototype.xor=function(t){return isLong(t)||(t=fromValue(t)),fromBits(this.low^t.low,this.high^t.high,this.unsigned)},LongPrototype.shiftLeft=function(t){return isLong(t)&&(t=t.toInt()),0==(t&=63)?this:t<32?fromBits(this.low<<t,this.high<<t|this.low>>>32-t,this.unsigned):fromBits(0,this.low<<t-32,this.unsigned)},LongPrototype.shl=LongPrototype.shiftLeft,LongPrototype.shiftRight=function(t){return isLong(t)&&(t=t.toInt()),0==(t&=63)?this:t<32?fromBits(this.low>>>t|this.high<<32-t,this.high>>t,this.unsigned):fromBits(this.high>>t-32,this.high>=0?0:-1,this.unsigned)},LongPrototype.shr=LongPrototype.shiftRight,LongPrototype.shiftRightUnsigned=function(t){return isLong(t)&&(t=t.toInt()),0==(t&=63)?this:t<32?fromBits(this.low>>>t|this.high<<32-t,this.high>>>t,this.unsigned):fromBits(32===t?this.high:this.high>>>t-32,0,this.unsigned)},LongPrototype.shru=LongPrototype.shiftRightUnsigned,LongPrototype.shr_u=LongPrototype.shiftRightUnsigned,LongPrototype.rotateLeft=function(t){var e;return isLong(t)&&(t=t.toInt()),0==(t&=63)?this:32===t?fromBits(this.high,this.low,this.unsigned):t<32?(e=32-t,fromBits(this.low<<t|this.high>>>e,this.high<<t|this.low>>>e,this.unsigned)):(e=32-(t-=32),fromBits(this.high<<t|this.low>>>e,this.low<<t|this.high>>>e,this.unsigned))},LongPrototype.rotl=LongPrototype.rotateLeft,LongPrototype.rotateRight=function(t){var e;return isLong(t)&&(t=t.toInt()),0==(t&=63)?this:32===t?fromBits(this.high,this.low,this.unsigned):t<32?(e=32-t,fromBits(this.high<<e|this.low>>>t,this.low<<e|this.high>>>t,this.unsigned)):(e=32-(t-=32),fromBits(this.low<<e|this.high>>>t,this.high<<e|this.low>>>t,this.unsigned))},LongPrototype.rotr=LongPrototype.rotateRight,LongPrototype.toSigned=function(){return this.unsigned?fromBits(this.low,this.high,!1):this},LongPrototype.toUnsigned=function(){return this.unsigned?this:fromBits(this.low,this.high,!0)},LongPrototype.toBytes=function(t){return t?this.toBytesLE():this.toBytesBE()},LongPrototype.toBytesLE=function(){var t=this.high,e=this.low;return[255&e,e>>>8&255,e>>>16&255,e>>>24,255&t,t>>>8&255,t>>>16&255,t>>>24]},LongPrototype.toBytesBE=function(){var t=this.high,e=this.low;return[t>>>24,t>>>16&255,t>>>8&255,255&t,e>>>24,e>>>16&255,e>>>8&255,255&e]},Long.fromBytes=function(t,e,n){return n?Long.fromBytesLE(t,e):Long.fromBytesBE(t,e)},Long.fromBytesLE=function(t,e){return new Long(t[0]|t[1]<<8|t[2]<<16|t[3]<<24,t[4]|t[5]<<8|t[6]<<16|t[7]<<24,e)},Long.fromBytesBE=function(t,e){return new Long(t[4]<<24|t[5]<<16|t[6]<<8|t[7],t[0]<<24|t[1]<<16|t[2]<<8|t[3],e)},long_default=Long}}),flatbuffers,init_flatbuffers=__esm({"web/node_modules/flatbuffers/js/flatbuffers.mjs"(){flatbuffers={},flatbuffers.Table,flatbuffers.SIZEOF_SHORT=2,flatbuffers.SIZEOF_INT=4,flatbuffers.FILE_IDENTIFIER_LENGTH=4,flatbuffers.SIZE_PREFIX_LENGTH=4,flatbuffers.Encoding={UTF8_BYTES:1,UTF16_STRING:2},flatbuffers.int32=new Int32Array(2),flatbuffers.float32=new Float32Array(flatbuffers.int32.buffer),flatbuffers.float64=new Float64Array(flatbuffers.int32.buffer),flatbuffers.isLittleEndian=1===new Uint16Array(new Uint8Array([1,0]).buffer)[0],flatbuffers.Long=function(t,e){this.low=0|t,this.high=0|e},flatbuffers.Long.create=function(t,e){return 0==t&&0==e?flatbuffers.Long.ZERO:new flatbuffers.Long(t,e)},flatbuffers.Long.prototype.toFloat64=function(){return(this.low>>>0)+4294967296*this.high},flatbuffers.Long.prototype.equals=function(t){return this.low==t.low&&this.high==t.high},flatbuffers.Long.ZERO=new flatbuffers.Long(0,0),flatbuffers.Builder=function(t){if(t)e=t;else var e=1024;this.bb=flatbuffers.ByteBuffer.allocate(e),this.space=e,this.minalign=1,this.vtable=null,this.vtable_in_use=0,this.isNested=!1,this.object_start=0,this.vtables=[],this.vector_num_elems=0,this.force_defaults=!1},flatbuffers.Builder.prototype.clear=function(){this.bb.clear(),this.space=this.bb.capacity(),this.minalign=1,this.vtable=null,this.vtable_in_use=0,this.isNested=!1,this.object_start=0,this.vtables=[],this.vector_num_elems=0,this.force_defaults=!1},flatbuffers.Builder.prototype.forceDefaults=function(t){this.force_defaults=t},flatbuffers.Builder.prototype.dataBuffer=function(){return this.bb},flatbuffers.Builder.prototype.asUint8Array=function(){return this.bb.bytes().subarray(this.bb.position(),this.bb.position()+this.offset())},flatbuffers.Builder.prototype.prep=function(t,e){t>this.minalign&&(this.minalign=t);for(var n=1+~(this.bb.capacity()-this.space+e)&t-1;this.space<n+t+e;){var B=this.bb.capacity();this.bb=flatbuffers.Builder.growByteBuffer(this.bb),this.space+=this.bb.capacity()-B}this.pad(n)},flatbuffers.Builder.prototype.pad=function(t){for(var e=0;e<t;e++)this.bb.writeInt8(--this.space,0)},flatbuffers.Builder.prototype.writeInt8=function(t){this.bb.writeInt8(this.space-=1,t)},flatbuffers.Builder.prototype.writeInt16=function(t){this.bb.writeInt16(this.space-=2,t)},flatbuffers.Builder.prototype.writeInt32=function(t){this.bb.writeInt32(this.space-=4,t)},flatbuffers.Builder.prototype.writeInt64=function(t){this.bb.writeInt64(this.space-=8,t)},flatbuffers.Builder.prototype.writeFloat32=function(t){this.bb.writeFloat32(this.space-=4,t)},flatbuffers.Builder.prototype.writeFloat64=function(t){this.bb.writeFloat64(this.space-=8,t)},flatbuffers.Builder.prototype.addInt8=function(t){this.prep(1,0),this.writeInt8(t)},flatbuffers.Builder.prototype.addInt16=function(t){this.prep(2,0),this.writeInt16(t)},flatbuffers.Builder.prototype.addInt32=function(t){this.prep(4,0),this.writeInt32(t)},flatbuffers.Builder.prototype.addInt64=function(t){this.prep(8,0),this.writeInt64(t)},flatbuffers.Builder.prototype.addFloat32=function(t){this.prep(4,0),this.writeFloat32(t)},flatbuffers.Builder.prototype.addFloat64=function(t){this.prep(8,0),this.writeFloat64(t)},flatbuffers.Builder.prototype.addFieldInt8=function(t,e,n){(this.force_defaults||e!=n)&&(this.addInt8(e),this.slot(t))},flatbuffers.Builder.prototype.addFieldInt16=function(t,e,n){(this.force_defaults||e!=n)&&(this.addInt16(e),this.slot(t))},flatbuffers.Builder.prototype.addFieldInt32=function(t,e,n){(this.force_defaults||e!=n)&&(this.addInt32(e),this.slot(t))},flatbuffers.Builder.prototype.addFieldInt64=function(t,e,n){!this.force_defaults&&e.equals(n)||(this.addInt64(e),this.slot(t))},flatbuffers.Builder.prototype.addFieldFloat32=function(t,e,n){(this.force_defaults||e!=n)&&(this.addFloat32(e),this.slot(t))},flatbuffers.Builder.prototype.addFieldFloat64=function(t,e,n){(this.force_defaults||e!=n)&&(this.addFloat64(e),this.slot(t))},flatbuffers.Builder.prototype.addFieldOffset=function(t,e,n){(this.force_defaults||e!=n)&&(this.addOffset(e),this.slot(t))},flatbuffers.Builder.prototype.addFieldStruct=function(t,e,n){e!=n&&(this.nested(e),this.slot(t))},flatbuffers.Builder.prototype.nested=function(t){if(t!=this.offset())throw new Error("FlatBuffers: struct must be serialized inline.")},flatbuffers.Builder.prototype.notNested=function(){if(this.isNested)throw new Error("FlatBuffers: object serialization must not be nested.")},flatbuffers.Builder.prototype.slot=function(t){this.vtable[t]=this.offset()},flatbuffers.Builder.prototype.offset=function(){return this.bb.capacity()-this.space},flatbuffers.Builder.growByteBuffer=function(t){var e=t.capacity();if(3221225472&e)throw new Error("FlatBuffers: cannot grow buffer beyond 2 gigabytes.");var n=e<<1,B=flatbuffers.ByteBuffer.allocate(n);return B.setPosition(n-e),B.bytes().set(t.bytes(),n-e),B},flatbuffers.Builder.prototype.addOffset=function(t){this.prep(flatbuffers.SIZEOF_INT,0),this.writeInt32(this.offset()-t+flatbuffers.SIZEOF_INT)},flatbuffers.Builder.prototype.startObject=function(t){this.notNested(),null==this.vtable&&(this.vtable=[]),this.vtable_in_use=t;for(var e=0;e<t;e++)this.vtable[e]=0;this.isNested=!0,this.object_start=this.offset()},flatbuffers.Builder.prototype.endObject=function(){if(null==this.vtable||!this.isNested)throw new Error("FlatBuffers: endObject called without startObject");this.addInt32(0);for(var t=this.offset(),e=this.vtable_in_use-1;e>=0&&0==this.vtable[e];e--);for(var n=e+1;e>=0;e--)this.addInt16(0!=this.vtable[e]?t-this.vtable[e]:0);this.addInt16(t-this.object_start);var B=(n+2)*flatbuffers.SIZEOF_SHORT;this.addInt16(B);var s=0,F=this.space;t:for(e=0;e<this.vtables.length;e++){var Q=this.bb.capacity()-this.vtables[e];if(B==this.bb.readInt16(Q)){for(var U=flatbuffers.SIZEOF_SHORT;U<B;U+=flatbuffers.SIZEOF_SHORT)if(this.bb.readInt16(F+U)!=this.bb.readInt16(Q+U))continue t;s=this.vtables[e];break}}return s?(this.space=this.bb.capacity()-t,this.bb.writeInt32(this.space,s-t)):(this.vtables.push(this.offset()),this.bb.writeInt32(this.bb.capacity()-t,this.offset()-t)),this.isNested=!1,t},flatbuffers.Builder.prototype.finish=function(t,e,n){var B=n?flatbuffers.SIZE_PREFIX_LENGTH:0;if(e){var s=e;if(this.prep(this.minalign,flatbuffers.SIZEOF_INT+flatbuffers.FILE_IDENTIFIER_LENGTH+B),s.length!=flatbuffers.FILE_IDENTIFIER_LENGTH)throw new Error("FlatBuffers: file identifier must be length "+flatbuffers.FILE_IDENTIFIER_LENGTH);for(var F=flatbuffers.FILE_IDENTIFIER_LENGTH-1;F>=0;F--)this.writeInt8(s.charCodeAt(F))}this.prep(this.minalign,flatbuffers.SIZEOF_INT+B),this.addOffset(t),B&&this.addInt32(this.bb.capacity()-this.space),this.bb.setPosition(this.space)},flatbuffers.Builder.prototype.finishSizePrefixed=function(t,e){this.finish(t,e,!0)},flatbuffers.Builder.prototype.requiredField=function(t,e){var n=this.bb.capacity()-t,B=n-this.bb.readInt32(n);if(!(0!=this.bb.readInt16(B+e)))throw new Error("FlatBuffers: field "+e+" must be set")},flatbuffers.Builder.prototype.startVector=function(t,e,n){this.notNested(),this.vector_num_elems=e,this.prep(flatbuffers.SIZEOF_INT,t*e),this.prep(n,t*e)},flatbuffers.Builder.prototype.endVector=function(){return this.writeInt32(this.vector_num_elems),this.offset()},flatbuffers.Builder.prototype.createString=function(t){if(t instanceof Uint8Array)var e=t;else{e=[];for(var n=0;n<t.length;){var B,s=t.charCodeAt(n++);if(s<55296||s>=56320)B=s;else B=(s<<10)+t.charCodeAt(n++)+-56613888;B<128?e.push(B):(B<2048?e.push(B>>6&31|192):(B<65536?e.push(B>>12&15|224):e.push(B>>18&7|240,B>>12&63|128),e.push(B>>6&63|128)),e.push(63&B|128))}}this.addInt8(0),this.startVector(1,e.length,1),this.bb.setPosition(this.space-=e.length);n=0;for(var F=this.space,Q=this.bb.bytes();n<e.length;n++)Q[F++]=e[n];return this.endVector()},flatbuffers.Builder.prototype.createLong=function(t,e){return flatbuffers.Long.create(t,e)},flatbuffers.ByteBuffer=function(t){this.bytes_=t,this.position_=0},flatbuffers.ByteBuffer.allocate=function(t){return new flatbuffers.ByteBuffer(new Uint8Array(t))},flatbuffers.ByteBuffer.prototype.clear=function(){this.position_=0},flatbuffers.ByteBuffer.prototype.bytes=function(){return this.bytes_},flatbuffers.ByteBuffer.prototype.position=function(){return this.position_},flatbuffers.ByteBuffer.prototype.setPosition=function(t){this.position_=t},flatbuffers.ByteBuffer.prototype.capacity=function(){return this.bytes_.length},flatbuffers.ByteBuffer.prototype.readInt8=function(t){return this.readUint8(t)<<24>>24},flatbuffers.ByteBuffer.prototype.readUint8=function(t){return this.bytes_[t]},flatbuffers.ByteBuffer.prototype.readInt16=function(t){return this.readUint16(t)<<16>>16},flatbuffers.ByteBuffer.prototype.readUint16=function(t){return this.bytes_[t]|this.bytes_[t+1]<<8},flatbuffers.ByteBuffer.prototype.readInt32=function(t){return this.bytes_[t]|this.bytes_[t+1]<<8|this.bytes_[t+2]<<16|this.bytes_[t+3]<<24},flatbuffers.ByteBuffer.prototype.readUint32=function(t){return this.readInt32(t)>>>0},flatbuffers.ByteBuffer.prototype.readInt64=function(t){return new flatbuffers.Long(this.readInt32(t),this.readInt32(t+4))},flatbuffers.ByteBuffer.prototype.readUint64=function(t){return new flatbuffers.Long(this.readUint32(t),this.readUint32(t+4))},flatbuffers.ByteBuffer.prototype.readFloat32=function(t){return flatbuffers.int32[0]=this.readInt32(t),flatbuffers.float32[0]},flatbuffers.ByteBuffer.prototype.readFloat64=function(t){return flatbuffers.int32[flatbuffers.isLittleEndian?0:1]=this.readInt32(t),flatbuffers.int32[flatbuffers.isLittleEndian?1:0]=this.readInt32(t+4),flatbuffers.float64[0]},flatbuffers.ByteBuffer.prototype.writeInt8=function(t,e){this.bytes_[t]=e},flatbuffers.ByteBuffer.prototype.writeUint8=function(t,e){this.bytes_[t]=e},flatbuffers.ByteBuffer.prototype.writeInt16=function(t,e){this.bytes_[t]=e,this.bytes_[t+1]=e>>8},flatbuffers.ByteBuffer.prototype.writeUint16=function(t,e){this.bytes_[t]=e,this.bytes_[t+1]=e>>8},flatbuffers.ByteBuffer.prototype.writeInt32=function(t,e){this.bytes_[t]=e,this.bytes_[t+1]=e>>8,this.bytes_[t+2]=e>>16,this.bytes_[t+3]=e>>24},flatbuffers.ByteBuffer.prototype.writeUint32=function(t,e){this.bytes_[t]=e,this.bytes_[t+1]=e>>8,this.bytes_[t+2]=e>>16,this.bytes_[t+3]=e>>24},flatbuffers.ByteBuffer.prototype.writeInt64=function(t,e){this.writeInt32(t,e.low),this.writeInt32(t+4,e.high)},flatbuffers.ByteBuffer.prototype.writeUint64=function(t,e){this.writeUint32(t,e.low),this.writeUint32(t+4,e.high)},flatbuffers.ByteBuffer.prototype.writeFloat32=function(t,e){flatbuffers.float32[0]=e,this.writeInt32(t,flatbuffers.int32[0])},flatbuffers.ByteBuffer.prototype.writeFloat64=function(t,e){flatbuffers.float64[0]=e,this.writeInt32(t,flatbuffers.int32[flatbuffers.isLittleEndian?0:1]),this.writeInt32(t+4,flatbuffers.int32[flatbuffers.isLittleEndian?1:0])},flatbuffers.ByteBuffer.prototype.getBufferIdentifier=function(){if(this.bytes_.length<this.position_+flatbuffers.SIZEOF_INT+flatbuffers.FILE_IDENTIFIER_LENGTH)throw new Error("FlatBuffers: ByteBuffer is too short to contain an identifier.");for(var t="",e=0;e<flatbuffers.FILE_IDENTIFIER_LENGTH;e++)t+=String.fromCharCode(this.readInt8(this.position_+flatbuffers.SIZEOF_INT+e));return t},flatbuffers.ByteBuffer.prototype.__offset=function(t,e){var n=t-this.readInt32(t);return e<this.readInt16(n)?this.readInt16(n+e):0},flatbuffers.ByteBuffer.prototype.__union=function(t,e){return t.bb_pos=e+this.readInt32(e),t.bb=this,t},flatbuffers.ByteBuffer.prototype.__string=function(t,e){t+=this.readInt32(t);var n=this.readInt32(t),B="",s=0;if(t+=flatbuffers.SIZEOF_INT,e===flatbuffers.Encoding.UTF8_BYTES)return this.bytes_.subarray(t,t+n);for(;s<n;){var F,Q=this.readUint8(t+s++);if(Q<192)F=Q;else{var U=this.readUint8(t+s++);if(Q<224)F=(31&Q)<<6|63&U;else{var i=this.readUint8(t+s++);if(Q<240)F=(15&Q)<<12|(63&U)<<6|63&i;else F=(7&Q)<<18|(63&U)<<12|(63&i)<<6|63&this.readUint8(t+s++)}}F<65536?B+=String.fromCharCode(F):(F-=65536,B+=String.fromCharCode(55296+(F>>10),56320+(1023&F)))}return B},flatbuffers.ByteBuffer.prototype.__indirect=function(t){return t+this.readInt32(t)},flatbuffers.ByteBuffer.prototype.__vector=function(t){return t+this.readInt32(t)+flatbuffers.SIZEOF_INT},flatbuffers.ByteBuffer.prototype.__vector_len=function(t){return this.readInt32(t+this.readInt32(t))},flatbuffers.ByteBuffer.prototype.__has_identifier=function(t){if(t.length!=flatbuffers.FILE_IDENTIFIER_LENGTH)throw new Error("FlatBuffers: file identifier must be length "+flatbuffers.FILE_IDENTIFIER_LENGTH);for(var e=0;e<flatbuffers.FILE_IDENTIFIER_LENGTH;e++)if(t.charCodeAt(e)!=this.readInt8(this.position_+flatbuffers.SIZEOF_INT+e))return!1;return!0},flatbuffers.ByteBuffer.prototype.createLong=function(t,e){return flatbuffers.Long.create(t,e)}}}),onnxruntime,init_ort_generated=__esm({"web/lib/onnxjs/ort-schema/flatbuffers/ort-generated.ts"(){init_flatbuffers(),(t=>{let e;(t=>{let e;(t=>{let e;var n;(n=e=t.AttributeType||(t.AttributeType={}))[n.UNDEFINED=0]="UNDEFINED",n[n.FLOAT=1]="FLOAT",n[n.INT=2]="INT",n[n.STRING=3]="STRING",n[n.TENSOR=4]="TENSOR",n[n.GRAPH=5]="GRAPH",n[n.FLOATS=6]="FLOATS",n[n.INTS=7]="INTS",n[n.STRINGS=8]="STRINGS",n[n.TENSORS=9]="TENSORS",n[n.GRAPHS=10]="GRAPHS",n[n.SPARSE_TENSOR=11]="SPARSE_TENSOR",n[n.SPARSE_TENSORS=12]="SPARSE_TENSORS"})(e=t.fbs||(t.fbs={}))})(e=t.experimental||(t.experimental={}))})(onnxruntime||(onnxruntime={})),(t=>{let e;(t=>{let e;(t=>{let e;var n;(n=e=t.DimensionValueType||(t.DimensionValueType={}))[n.UNKNOWN=0]="UNKNOWN",n[n.VALUE=1]="VALUE",n[n.PARAM=2]="PARAM"})(e=t.fbs||(t.fbs={}))})(e=t.experimental||(t.experimental={}))})(onnxruntime||(onnxruntime={})),(t=>{let e;(t=>{let e;(t=>{let e;var n;(n=e=t.TensorDataType||(t.TensorDataType={}))[n.UNDEFINED=0]="UNDEFINED",n[n.FLOAT=1]="FLOAT",n[n.UINT8=2]="UINT8",n[n.INT8=3]="INT8",n[n.UINT16=4]="UINT16",n[n.INT16=5]="INT16",n[n.INT32=6]="INT32",n[n.INT64=7]="INT64",n[n.STRING=8]="STRING",n[n.BOOL=9]="BOOL",n[n.FLOAT16=10]="FLOAT16",n[n.DOUBLE=11]="DOUBLE",n[n.UINT32=12]="UINT32",n[n.UINT64=13]="UINT64",n[n.COMPLEX64=14]="COMPLEX64",n[n.COMPLEX128=15]="COMPLEX128",n[n.BFLOAT16=16]="BFLOAT16",n[n.FLOAT8E4M3FN=17]="FLOAT8E4M3FN",n[n.FLOAT8E4M3FNUZ=18]="FLOAT8E4M3FNUZ",n[n.FLOAT8E5M2=19]="FLOAT8E5M2",n[n.FLOAT8E5M2FNUZ=20]="FLOAT8E5M2FNUZ"})(e=t.fbs||(t.fbs={}))})(e=t.experimental||(t.experimental={}))})(onnxruntime||(onnxruntime={})),(t=>{let e;(t=>{let e;(t=>{let e;var n;(n=e=t.NodeType||(t.NodeType={}))[n.Primitive=0]="Primitive",n[n.Fused=1]="Fused"})(e=t.fbs||(t.fbs={}))})(e=t.experimental||(t.experimental={}))})(onnxruntime||(onnxruntime={})),(t=>{let e;(t=>{let e;(t=>{let e;var n;(n=e=t.TypeInfoValue||(t.TypeInfoValue={}))[n.NONE=0]="NONE",n[n.tensor_type=1]="tensor_type",n[n.sequence_type=2]="sequence_type",n[n.map_type=3]="map_type"})(e=t.fbs||(t.fbs={}))})(e=t.experimental||(t.experimental={}))})(onnxruntime||(onnxruntime={})),(t=>{let e;(e=>{let n;(e=>{class n{constructor(){this.bb=null,this.bb_pos=0}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsShape(t,e){return(e||new n).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsShape(t,e){return t.setPosition(t.position()+flatbuffers.SIZE_PREFIX_LENGTH),(e||new n).__init(t.readInt32(t.position())+t.position(),t)}dim(e,n){let B=this.bb.__offset(this.bb_pos,4);return B?(n||new t.experimental.fbs.Dimension).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+B)+4*e),this.bb):null}dimLength(){let t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__vector_len(this.bb_pos+t):0}static startShape(t){t.startObject(1)}static addDim(t,e){t.addFieldOffset(0,e,0)}static createDimVector(t,e){t.startVector(4,e.length,4);for(let n=e.length-1;n>=0;n--)t.addOffset(e[n]);return t.endVector()}static startDimVector(t,e){t.startVector(4,e,4)}static endShape(t){return t.endObject()}static createShape(t,e){return n.startShape(t),n.addDim(t,e),n.endShape(t)}}e.Shape=n})(n=e.fbs||(e.fbs={}))})(e=t.experimental||(t.experimental={}))})(onnxruntime||(onnxruntime={})),(t=>{let e;(e=>{let n;(e=>{class n{constructor(){this.bb=null,this.bb_pos=0}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsDimension(t,e){return(e||new n).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsDimension(t,e){return t.setPosition(t.position()+flatbuffers.SIZE_PREFIX_LENGTH),(e||new n).__init(t.readInt32(t.position())+t.position(),t)}value(e){let n=this.bb.__offset(this.bb_pos,4);return n?(e||new t.experimental.fbs.DimensionValue).__init(this.bb.__indirect(this.bb_pos+n),this.bb):null}denotation(t){let e=this.bb.__offset(this.bb_pos,6);return e?this.bb.__string(this.bb_pos+e,t):null}static startDimension(t){t.startObject(2)}static addValue(t,e){t.addFieldOffset(0,e,0)}static addDenotation(t,e){t.addFieldOffset(1,e,0)}static endDimension(t){return t.endObject()}static createDimension(t,e,B){return n.startDimension(t),n.addValue(t,e),n.addDenotation(t,B),n.endDimension(t)}}e.Dimension=n})(n=e.fbs||(e.fbs={}))})(e=t.experimental||(t.experimental={}))})(onnxruntime||(onnxruntime={})),(t=>{let e;(t=>{let e;(t=>{class e{constructor(){this.bb=null,this.bb_pos=0}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsDimensionValue(t,n){return(n||new e).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsDimensionValue(t,n){return t.setPosition(t.position()+flatbuffers.SIZE_PREFIX_LENGTH),(n||new e).__init(t.readInt32(t.position())+t.position(),t)}dimType(){let t=this.bb.__offset(this.bb_pos,4);return t?this.bb.readInt8(this.bb_pos+t):0}dimValue(){let t=this.bb.__offset(this.bb_pos,6);return t?this.bb.readInt64(this.bb_pos+t):this.bb.createLong(0,0)}dimParam(t){let e=this.bb.__offset(this.bb_pos,8);return e?this.bb.__string(this.bb_pos+e,t):null}static startDimensionValue(t){t.startObject(3)}static addDimType(t,e){t.addFieldInt8(0,e,0)}static addDimValue(t,e){t.addFieldInt64(1,e,t.createLong(0,0))}static addDimParam(t,e){t.addFieldOffset(2,e,0)}static endDimensionValue(t){return t.endObject()}static createDimensionValue(t,n,B,s){return e.startDimensionValue(t),e.addDimType(t,n),e.addDimValue(t,B),e.addDimParam(t,s),e.endDimensionValue(t)}}t.DimensionValue=e})(e=t.fbs||(t.fbs={}))})(e=t.experimental||(t.experimental={}))})(onnxruntime||(onnxruntime={})),(t=>{let e;(e=>{let n;(e=>{class n{constructor(){this.bb=null,this.bb_pos=0}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsTensorTypeAndShape(t,e){return(e||new n).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsTensorTypeAndShape(t,e){return t.setPosition(t.position()+flatbuffers.SIZE_PREFIX_LENGTH),(e||new n).__init(t.readInt32(t.position())+t.position(),t)}elemType(){let t=this.bb.__offset(this.bb_pos,4);return t?this.bb.readInt32(this.bb_pos+t):0}shape(e){let n=this.bb.__offset(this.bb_pos,6);return n?(e||new t.experimental.fbs.Shape).__init(this.bb.__indirect(this.bb_pos+n),this.bb):null}static startTensorTypeAndShape(t){t.startObject(2)}static addElemType(t,e){t.addFieldInt32(0,e,0)}static addShape(t,e){t.addFieldOffset(1,e,0)}static endTensorTypeAndShape(t){return t.endObject()}static createTensorTypeAndShape(t,e,B){return n.startTensorTypeAndShape(t),n.addElemType(t,e),n.addShape(t,B),n.endTensorTypeAndShape(t)}}e.TensorTypeAndShape=n})(n=e.fbs||(e.fbs={}))})(e=t.experimental||(t.experimental={}))})(onnxruntime||(onnxruntime={})),(t=>{let e;(e=>{let n;(e=>{class n{constructor(){this.bb=null,this.bb_pos=0}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsMapType(t,e){return(e||new n).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsMapType(t,e){return t.setPosition(t.position()+flatbuffers.SIZE_PREFIX_LENGTH),(e||new n).__init(t.readInt32(t.position())+t.position(),t)}keyType(){let t=this.bb.__offset(this.bb_pos,4);return t?this.bb.readInt32(this.bb_pos+t):0}valueType(e){let n=this.bb.__offset(this.bb_pos,6);return n?(e||new t.experimental.fbs.TypeInfo).__init(this.bb.__indirect(this.bb_pos+n),this.bb):null}static startMapType(t){t.startObject(2)}static addKeyType(t,e){t.addFieldInt32(0,e,0)}static addValueType(t,e){t.addFieldOffset(1,e,0)}static endMapType(t){return t.endObject()}static createMapType(t,e,B){return n.startMapType(t),n.addKeyType(t,e),n.addValueType(t,B),n.endMapType(t)}}e.MapType=n})(n=e.fbs||(e.fbs={}))})(e=t.experimental||(t.experimental={}))})(onnxruntime||(onnxruntime={})),(t=>{let e;(e=>{let n;(e=>{class n{constructor(){this.bb=null,this.bb_pos=0}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsSequenceType(t,e){return(e||new n).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsSequenceType(t,e){return t.setPosition(t.position()+flatbuffers.SIZE_PREFIX_LENGTH),(e||new n).__init(t.readInt32(t.position())+t.position(),t)}elemType(e){let n=this.bb.__offset(this.bb_pos,4);return n?(e||new t.experimental.fbs.TypeInfo).__init(this.bb.__indirect(this.bb_pos+n),this.bb):null}static startSequenceType(t){t.startObject(1)}static addElemType(t,e){t.addFieldOffset(0,e,0)}static endSequenceType(t){return t.endObject()}static createSequenceType(t,e){return n.startSequenceType(t),n.addElemType(t,e),n.endSequenceType(t)}}e.SequenceType=n})(n=e.fbs||(e.fbs={}))})(e=t.experimental||(t.experimental={}))})(onnxruntime||(onnxruntime={})),(t=>{let e;(t=>{let e;(e=t.fbs||(t.fbs={})).EdgeEnd=class{constructor(){this.bb=null,this.bb_pos=0}__init(t,e){return this.bb_pos=t,this.bb=e,this}nodeIndex(){return this.bb.readUint32(this.bb_pos)}srcArgIndex(){return this.bb.readInt32(this.bb_pos+4)}dstArgIndex(){return this.bb.readInt32(this.bb_pos+8)}static createEdgeEnd(t,e,n,B){return t.prep(4,12),t.writeInt32(B),t.writeInt32(n),t.writeInt32(e),t.offset()}}})(e=t.experimental||(t.experimental={}))})(onnxruntime||(onnxruntime={})),(t=>{let e;(e=>{let n;(e=>{class n{constructor(){this.bb=null,this.bb_pos=0}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsNodeEdge(t,e){return(e||new n).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsNodeEdge(t,e){return t.setPosition(t.position()+flatbuffers.SIZE_PREFIX_LENGTH),(e||new n).__init(t.readInt32(t.position())+t.position(),t)}nodeIndex(){let t=this.bb.__offset(this.bb_pos,4);return t?this.bb.readUint32(this.bb_pos+t):0}inputEdges(e,n){let B=this.bb.__offset(this.bb_pos,6);return B?(n||new t.experimental.fbs.EdgeEnd).__init(this.bb.__vector(this.bb_pos+B)+12*e,this.bb):null}inputEdgesLength(){let t=this.bb.__offset(this.bb_pos,6);return t?this.bb.__vector_len(this.bb_pos+t):0}outputEdges(e,n){let B=this.bb.__offset(this.bb_pos,8);return B?(n||new t.experimental.fbs.EdgeEnd).__init(this.bb.__vector(this.bb_pos+B)+12*e,this.bb):null}outputEdgesLength(){let t=this.bb.__offset(this.bb_pos,8);return t?this.bb.__vector_len(this.bb_pos+t):0}static startNodeEdge(t){t.startObject(3)}static addNodeIndex(t,e){t.addFieldInt32(0,e,0)}static addInputEdges(t,e){t.addFieldOffset(1,e,0)}static startInputEdgesVector(t,e){t.startVector(12,e,4)}static addOutputEdges(t,e){t.addFieldOffset(2,e,0)}static startOutputEdgesVector(t,e){t.startVector(12,e,4)}static endNodeEdge(t){return t.endObject()}static createNodeEdge(t,e,B,s){return n.startNodeEdge(t),n.addNodeIndex(t,e),n.addInputEdges(t,B),n.addOutputEdges(t,s),n.endNodeEdge(t)}}e.NodeEdge=n})(n=e.fbs||(e.fbs={}))})(e=t.experimental||(t.experimental={}))})(onnxruntime||(onnxruntime={})),(t=>{let e;(e=>{let n;(e=>{class n{constructor(){this.bb=null,this.bb_pos=0}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsNode(t,e){return(e||new n).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsNode(t,e){return t.setPosition(t.position()+flatbuffers.SIZE_PREFIX_LENGTH),(e||new n).__init(t.readInt32(t.position())+t.position(),t)}name(t){let e=this.bb.__offset(this.bb_pos,4);return e?this.bb.__string(this.bb_pos+e,t):null}docString(t){let e=this.bb.__offset(this.bb_pos,6);return e?this.bb.__string(this.bb_pos+e,t):null}domain(t){let e=this.bb.__offset(this.bb_pos,8);return e?this.bb.__string(this.bb_pos+e,t):null}sinceVersion(){let t=this.bb.__offset(this.bb_pos,10);return t?this.bb.readInt32(this.bb_pos+t):0}index(){let t=this.bb.__offset(this.bb_pos,12);return t?this.bb.readUint32(this.bb_pos+t):0}opType(t){let e=this.bb.__offset(this.bb_pos,14);return e?this.bb.__string(this.bb_pos+e,t):null}type(){let t=this.bb.__offset(this.bb_pos,16);return t?this.bb.readInt32(this.bb_pos+t):0}executionProviderType(t){let e=this.bb.__offset(this.bb_pos,18);return e?this.bb.__string(this.bb_pos+e,t):null}inputs(t,e){let n=this.bb.__offset(this.bb_pos,20);return n?this.bb.__string(this.bb.__vector(this.bb_pos+n)+4*t,e):null}inputsLength(){let t=this.bb.__offset(this.bb_pos,20);return t?this.bb.__vector_len(this.bb_pos+t):0}outputs(t,e){let n=this.bb.__offset(this.bb_pos,22);return n?this.bb.__string(this.bb.__vector(this.bb_pos+n)+4*t,e):null}outputsLength(){let t=this.bb.__offset(this.bb_pos,22);return t?this.bb.__vector_len(this.bb_pos+t):0}attributes(e,n){let B=this.bb.__offset(this.bb_pos,24);return B?(n||new t.experimental.fbs.Attribute).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+B)+4*e),this.bb):null}attributesLength(){let t=this.bb.__offset(this.bb_pos,24);return t?this.bb.__vector_len(this.bb_pos+t):0}inputArgCounts(t){let e=this.bb.__offset(this.bb_pos,26);return e?this.bb.readInt32(this.bb.__vector(this.bb_pos+e)+4*t):0}inputArgCountsLength(){let t=this.bb.__offset(this.bb_pos,26);return t?this.bb.__vector_len(this.bb_pos+t):0}inputArgCountsArray(){let t=this.bb.__offset(this.bb_pos,26);return t?new Int32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}implicitInputs(t,e){let n=this.bb.__offset(this.bb_pos,28);return n?this.bb.__string(this.bb.__vector(this.bb_pos+n)+4*t,e):null}implicitInputsLength(){let t=this.bb.__offset(this.bb_pos,28);return t?this.bb.__vector_len(this.bb_pos+t):0}static startNode(t){t.startObject(13)}static addName(t,e){t.addFieldOffset(0,e,0)}static addDocString(t,e){t.addFieldOffset(1,e,0)}static addDomain(t,e){t.addFieldOffset(2,e,0)}static addSinceVersion(t,e){t.addFieldInt32(3,e,0)}static addIndex(t,e){t.addFieldInt32(4,e,0)}static addOpType(t,e){t.addFieldOffset(5,e,0)}static addType(t,e){t.addFieldInt32(6,e,0)}static addExecutionProviderType(t,e){t.addFieldOffset(7,e,0)}static addInputs(t,e){t.addFieldOffset(8,e,0)}static createInputsVector(t,e){t.startVector(4,e.length,4);for(let n=e.length-1;n>=0;n--)t.addOffset(e[n]);return t.endVector()}static startInputsVector(t,e){t.startVector(4,e,4)}static addOutputs(t,e){t.addFieldOffset(9,e,0)}static createOutputsVector(t,e){t.startVector(4,e.length,4);for(let n=e.length-1;n>=0;n--)t.addOffset(e[n]);return t.endVector()}static startOutputsVector(t,e){t.startVector(4,e,4)}static addAttributes(t,e){t.addFieldOffset(10,e,0)}static createAttributesVector(t,e){t.startVector(4,e.length,4);for(let n=e.length-1;n>=0;n--)t.addOffset(e[n]);return t.endVector()}static startAttributesVector(t,e){t.startVector(4,e,4)}static addInputArgCounts(t,e){t.addFieldOffset(11,e,0)}static createInputArgCountsVector(t,e){t.startVector(4,e.length,4);for(let n=e.length-1;n>=0;n--)t.addInt32(e[n]);return t.endVector()}static startInputArgCountsVector(t,e){t.startVector(4,e,4)}static addImplicitInputs(t,e){t.addFieldOffset(12,e,0)}static createImplicitInputsVector(t,e){t.startVector(4,e.length,4);for(let n=e.length-1;n>=0;n--)t.addOffset(e[n]);return t.endVector()}static startImplicitInputsVector(t,e){t.startVector(4,e,4)}static endNode(t){return t.endObject()}static createNode(t,e,B,s,F,Q,U,i,a,l,c,g,d,I){return n.startNode(t),n.addName(t,e),n.addDocString(t,B),n.addDomain(t,s),n.addSinceVersion(t,F),n.addIndex(t,Q),n.addOpType(t,U),n.addType(t,i),n.addExecutionProviderType(t,a),n.addInputs(t,l),n.addOutputs(t,c),n.addAttributes(t,g),n.addInputArgCounts(t,d),n.addImplicitInputs(t,I),n.endNode(t)}}e.Node=n})(n=e.fbs||(e.fbs={}))})(e=t.experimental||(t.experimental={}))})(onnxruntime||(onnxruntime={})),(t=>{let e;(e=>{let n;(e=>{class n{constructor(){this.bb=null,this.bb_pos=0}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsValueInfo(t,e){return(e||new n).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsValueInfo(t,e){return t.setPosition(t.position()+flatbuffers.SIZE_PREFIX_LENGTH),(e||new n).__init(t.readInt32(t.position())+t.position(),t)}name(t){let e=this.bb.__offset(this.bb_pos,4);return e?this.bb.__string(this.bb_pos+e,t):null}docString(t){let e=this.bb.__offset(this.bb_pos,6);return e?this.bb.__string(this.bb_pos+e,t):null}type(e){let n=this.bb.__offset(this.bb_pos,8);return n?(e||new t.experimental.fbs.TypeInfo).__init(this.bb.__indirect(this.bb_pos+n),this.bb):null}static startValueInfo(t){t.startObject(3)}static addName(t,e){t.addFieldOffset(0,e,0)}static addDocString(t,e){t.addFieldOffset(1,e,0)}static addType(t,e){t.addFieldOffset(2,e,0)}static endValueInfo(t){return t.endObject()}static createValueInfo(t,e,B,s){return n.startValueInfo(t),n.addName(t,e),n.addDocString(t,B),n.addType(t,s),n.endValueInfo(t)}}e.ValueInfo=n})(n=e.fbs||(e.fbs={}))})(e=t.experimental||(t.experimental={}))})(onnxruntime||(onnxruntime={})),(t=>{let e;(t=>{let e;(t=>{class e{constructor(){this.bb=null,this.bb_pos=0}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsTypeInfo(t,n){return(n||new e).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsTypeInfo(t,n){return t.setPosition(t.position()+flatbuffers.SIZE_PREFIX_LENGTH),(n||new e).__init(t.readInt32(t.position())+t.position(),t)}denotation(t){let e=this.bb.__offset(this.bb_pos,4);return e?this.bb.__string(this.bb_pos+e,t):null}valueType(){let t=this.bb.__offset(this.bb_pos,6);return t?this.bb.readUint8(this.bb_pos+t):0}value(t){let e=this.bb.__offset(this.bb_pos,8);return e?this.bb.__union(t,this.bb_pos+e):null}static startTypeInfo(t){t.startObject(3)}static addDenotation(t,e){t.addFieldOffset(0,e,0)}static addValueType(t,e){t.addFieldInt8(1,e,0)}static addValue(t,e){t.addFieldOffset(2,e,0)}static endTypeInfo(t){return t.endObject()}static createTypeInfo(t,n,B,s){return e.startTypeInfo(t),e.addDenotation(t,n),e.addValueType(t,B),e.addValue(t,s),e.endTypeInfo(t)}}t.TypeInfo=e})(e=t.fbs||(t.fbs={}))})(e=t.experimental||(t.experimental={}))})(onnxruntime||(onnxruntime={})),(t=>{let e;(t=>{let e;(t=>{class e{constructor(){this.bb=null,this.bb_pos=0}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsOperatorSetId(t,n){return(n||new e).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsOperatorSetId(t,n){return t.setPosition(t.position()+flatbuffers.SIZE_PREFIX_LENGTH),(n||new e).__init(t.readInt32(t.position())+t.position(),t)}domain(t){let e=this.bb.__offset(this.bb_pos,4);return e?this.bb.__string(this.bb_pos+e,t):null}version(){let t=this.bb.__offset(this.bb_pos,6);return t?this.bb.readInt64(this.bb_pos+t):this.bb.createLong(0,0)}static startOperatorSetId(t){t.startObject(2)}static addDomain(t,e){t.addFieldOffset(0,e,0)}static addVersion(t,e){t.addFieldInt64(1,e,t.createLong(0,0))}static endOperatorSetId(t){return t.endObject()}static createOperatorSetId(t,n,B){return e.startOperatorSetId(t),e.addDomain(t,n),e.addVersion(t,B),e.endOperatorSetId(t)}}t.OperatorSetId=e})(e=t.fbs||(t.fbs={}))})(e=t.experimental||(t.experimental={}))})(onnxruntime||(onnxruntime={})),(t=>{let e;(t=>{let e;(t=>{class e{constructor(){this.bb=null,this.bb_pos=0}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsTensor(t,n){return(n||new e).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsTensor(t,n){return t.setPosition(t.position()+flatbuffers.SIZE_PREFIX_LENGTH),(n||new e).__init(t.readInt32(t.position())+t.position(),t)}name(t){let e=this.bb.__offset(this.bb_pos,4);return e?this.bb.__string(this.bb_pos+e,t):null}docString(t){let e=this.bb.__offset(this.bb_pos,6);return e?this.bb.__string(this.bb_pos+e,t):null}dims(t){let e=this.bb.__offset(this.bb_pos,8);return e?this.bb.readInt64(this.bb.__vector(this.bb_pos+e)+8*t):this.bb.createLong(0,0)}dimsLength(){let t=this.bb.__offset(this.bb_pos,8);return t?this.bb.__vector_len(this.bb_pos+t):0}dataType(){let t=this.bb.__offset(this.bb_pos,10);return t?this.bb.readInt32(this.bb_pos+t):0}rawData(t){let e=this.bb.__offset(this.bb_pos,12);return e?this.bb.readUint8(this.bb.__vector(this.bb_pos+e)+t):0}rawDataLength(){let t=this.bb.__offset(this.bb_pos,12);return t?this.bb.__vector_len(this.bb_pos+t):0}rawDataArray(){let t=this.bb.__offset(this.bb_pos,12);return t?new Uint8Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}stringData(t,e){let n=this.bb.__offset(this.bb_pos,14);return n?this.bb.__string(this.bb.__vector(this.bb_pos+n)+4*t,e):null}stringDataLength(){let t=this.bb.__offset(this.bb_pos,14);return t?this.bb.__vector_len(this.bb_pos+t):0}static startTensor(t){t.startObject(6)}static addName(t,e){t.addFieldOffset(0,e,0)}static addDocString(t,e){t.addFieldOffset(1,e,0)}static addDims(t,e){t.addFieldOffset(2,e,0)}static createDimsVector(t,e){t.startVector(8,e.length,8);for(let n=e.length-1;n>=0;n--)t.addInt64(e[n]);return t.endVector()}static startDimsVector(t,e){t.startVector(8,e,8)}static addDataType(t,e){t.addFieldInt32(3,e,0)}static addRawData(t,e){t.addFieldOffset(4,e,0)}static createRawDataVector(t,e){t.startVector(1,e.length,1);for(let n=e.length-1;n>=0;n--)t.addInt8(e[n]);return t.endVector()}static startRawDataVector(t,e){t.startVector(1,e,1)}static addStringData(t,e){t.addFieldOffset(5,e,0)}static createStringDataVector(t,e){t.startVector(4,e.length,4);for(let n=e.length-1;n>=0;n--)t.addOffset(e[n]);return t.endVector()}static startStringDataVector(t,e){t.startVector(4,e,4)}static endTensor(t){return t.endObject()}static createTensor(t,n,B,s,F,Q,U){return e.startTensor(t),e.addName(t,n),e.addDocString(t,B),e.addDims(t,s),e.addDataType(t,F),e.addRawData(t,Q),e.addStringData(t,U),e.endTensor(t)}}t.Tensor=e})(e=t.fbs||(t.fbs={}))})(e=t.experimental||(t.experimental={}))})(onnxruntime||(onnxruntime={})),(t=>{let e;(e=>{let n;(e=>{class n{constructor(){this.bb=null,this.bb_pos=0}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsSparseTensor(t,e){return(e||new n).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsSparseTensor(t,e){return t.setPosition(t.position()+flatbuffers.SIZE_PREFIX_LENGTH),(e||new n).__init(t.readInt32(t.position())+t.position(),t)}values(e){let n=this.bb.__offset(this.bb_pos,4);return n?(e||new t.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb_pos+n),this.bb):null}indices(e){let n=this.bb.__offset(this.bb_pos,6);return n?(e||new t.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb_pos+n),this.bb):null}dims(t){let e=this.bb.__offset(this.bb_pos,8);return e?this.bb.readInt64(this.bb.__vector(this.bb_pos+e)+8*t):this.bb.createLong(0,0)}dimsLength(){let t=this.bb.__offset(this.bb_pos,8);return t?this.bb.__vector_len(this.bb_pos+t):0}static startSparseTensor(t){t.startObject(3)}static addValues(t,e){t.addFieldOffset(0,e,0)}static addIndices(t,e){t.addFieldOffset(1,e,0)}static addDims(t,e){t.addFieldOffset(2,e,0)}static createDimsVector(t,e){t.startVector(8,e.length,8);for(let n=e.length-1;n>=0;n--)t.addInt64(e[n]);return t.endVector()}static startDimsVector(t,e){t.startVector(8,e,8)}static endSparseTensor(t){return t.endObject()}static createSparseTensor(t,e,B,s){return n.startSparseTensor(t),n.addValues(t,e),n.addIndices(t,B),n.addDims(t,s),n.endSparseTensor(t)}}e.SparseTensor=n})(n=e.fbs||(e.fbs={}))})(e=t.experimental||(t.experimental={}))})(onnxruntime||(onnxruntime={})),(t=>{let e;(e=>{let n;(e=>{class n{constructor(){this.bb=null,this.bb_pos=0}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsAttribute(t,e){return(e||new n).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsAttribute(t,e){return t.setPosition(t.position()+flatbuffers.SIZE_PREFIX_LENGTH),(e||new n).__init(t.readInt32(t.position())+t.position(),t)}name(t){let e=this.bb.__offset(this.bb_pos,4);return e?this.bb.__string(this.bb_pos+e,t):null}docString(t){let e=this.bb.__offset(this.bb_pos,6);return e?this.bb.__string(this.bb_pos+e,t):null}type(){let t=this.bb.__offset(this.bb_pos,8);return t?this.bb.readInt32(this.bb_pos+t):0}f(){let t=this.bb.__offset(this.bb_pos,10);return t?this.bb.readFloat32(this.bb_pos+t):0}i(){let t=this.bb.__offset(this.bb_pos,12);return t?this.bb.readInt64(this.bb_pos+t):this.bb.createLong(0,0)}s(t){let e=this.bb.__offset(this.bb_pos,14);return e?this.bb.__string(this.bb_pos+e,t):null}t(e){let n=this.bb.__offset(this.bb_pos,16);return n?(e||new t.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb_pos+n),this.bb):null}g(e){let n=this.bb.__offset(this.bb_pos,18);return n?(e||new t.experimental.fbs.Graph).__init(this.bb.__indirect(this.bb_pos+n),this.bb):null}floats(t){let e=this.bb.__offset(this.bb_pos,20);return e?this.bb.readFloat32(this.bb.__vector(this.bb_pos+e)+4*t):0}floatsLength(){let t=this.bb.__offset(this.bb_pos,20);return t?this.bb.__vector_len(this.bb_pos+t):0}floatsArray(){let t=this.bb.__offset(this.bb_pos,20);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}ints(t){let e=this.bb.__offset(this.bb_pos,22);return e?this.bb.readInt64(this.bb.__vector(this.bb_pos+e)+8*t):this.bb.createLong(0,0)}intsLength(){let t=this.bb.__offset(this.bb_pos,22);return t?this.bb.__vector_len(this.bb_pos+t):0}strings(t,e){let n=this.bb.__offset(this.bb_pos,24);return n?this.bb.__string(this.bb.__vector(this.bb_pos+n)+4*t,e):null}stringsLength(){let t=this.bb.__offset(this.bb_pos,24);return t?this.bb.__vector_len(this.bb_pos+t):0}tensors(e,n){let B=this.bb.__offset(this.bb_pos,26);return B?(n||new t.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+B)+4*e),this.bb):null}tensorsLength(){let t=this.bb.__offset(this.bb_pos,26);return t?this.bb.__vector_len(this.bb_pos+t):0}graphs(e,n){let B=this.bb.__offset(this.bb_pos,28);return B?(n||new t.experimental.fbs.Graph).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+B)+4*e),this.bb):null}graphsLength(){let t=this.bb.__offset(this.bb_pos,28);return t?this.bb.__vector_len(this.bb_pos+t):0}static startAttribute(t){t.startObject(13)}static addName(t,e){t.addFieldOffset(0,e,0)}static addDocString(t,e){t.addFieldOffset(1,e,0)}static addType(t,e){t.addFieldInt32(2,e,0)}static addF(t,e){t.addFieldFloat32(3,e,0)}static addI(t,e){t.addFieldInt64(4,e,t.createLong(0,0))}static addS(t,e){t.addFieldOffset(5,e,0)}static addT(t,e){t.addFieldOffset(6,e,0)}static addG(t,e){t.addFieldOffset(7,e,0)}static addFloats(t,e){t.addFieldOffset(8,e,0)}static createFloatsVector(t,e){t.startVector(4,e.length,4);for(let n=e.length-1;n>=0;n--)t.addFloat32(e[n]);return t.endVector()}static startFloatsVector(t,e){t.startVector(4,e,4)}static addInts(t,e){t.addFieldOffset(9,e,0)}static createIntsVector(t,e){t.startVector(8,e.length,8);for(let n=e.length-1;n>=0;n--)t.addInt64(e[n]);return t.endVector()}static startIntsVector(t,e){t.startVector(8,e,8)}static addStrings(t,e){t.addFieldOffset(10,e,0)}static createStringsVector(t,e){t.startVector(4,e.length,4);for(let n=e.length-1;n>=0;n--)t.addOffset(e[n]);return t.endVector()}static startStringsVector(t,e){t.startVector(4,e,4)}static addTensors(t,e){t.addFieldOffset(11,e,0)}static createTensorsVector(t,e){t.startVector(4,e.length,4);for(let n=e.length-1;n>=0;n--)t.addOffset(e[n]);return t.endVector()}static startTensorsVector(t,e){t.startVector(4,e,4)}static addGraphs(t,e){t.addFieldOffset(12,e,0)}static createGraphsVector(t,e){t.startVector(4,e.length,4);for(let n=e.length-1;n>=0;n--)t.addOffset(e[n]);return t.endVector()}static startGraphsVector(t,e){t.startVector(4,e,4)}static endAttribute(t){return t.endObject()}static createAttribute(t,e,B,s,F,Q,U,i,a,l,c,g,d,I){return n.startAttribute(t),n.addName(t,e),n.addDocString(t,B),n.addType(t,s),n.addF(t,F),n.addI(t,Q),n.addS(t,U),n.addT(t,i),n.addG(t,a),n.addFloats(t,l),n.addInts(t,c),n.addStrings(t,g),n.addTensors(t,d),n.addGraphs(t,I),n.endAttribute(t)}}e.Attribute=n})(n=e.fbs||(e.fbs={}))})(e=t.experimental||(t.experimental={}))})(onnxruntime||(onnxruntime={})),(t=>{let e;(e=>{let n;(e=>{class n{constructor(){this.bb=null,this.bb_pos=0}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsGraph(t,e){return(e||new n).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsGraph(t,e){return t.setPosition(t.position()+flatbuffers.SIZE_PREFIX_LENGTH),(e||new n).__init(t.readInt32(t.position())+t.position(),t)}initializers(e,n){let B=this.bb.__offset(this.bb_pos,4);return B?(n||new t.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+B)+4*e),this.bb):null}initializersLength(){let t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__vector_len(this.bb_pos+t):0}nodeArgs(e,n){let B=this.bb.__offset(this.bb_pos,6);return B?(n||new t.experimental.fbs.ValueInfo).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+B)+4*e),this.bb):null}nodeArgsLength(){let t=this.bb.__offset(this.bb_pos,6);return t?this.bb.__vector_len(this.bb_pos+t):0}nodes(e,n){let B=this.bb.__offset(this.bb_pos,8);return B?(n||new t.experimental.fbs.Node).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+B)+4*e),this.bb):null}nodesLength(){let t=this.bb.__offset(this.bb_pos,8);return t?this.bb.__vector_len(this.bb_pos+t):0}maxNodeIndex(){let t=this.bb.__offset(this.bb_pos,10);return t?this.bb.readUint32(this.bb_pos+t):0}nodeEdges(e,n){let B=this.bb.__offset(this.bb_pos,12);return B?(n||new t.experimental.fbs.NodeEdge).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+B)+4*e),this.bb):null}nodeEdgesLength(){let t=this.bb.__offset(this.bb_pos,12);return t?this.bb.__vector_len(this.bb_pos+t):0}inputs(t,e){let n=this.bb.__offset(this.bb_pos,14);return n?this.bb.__string(this.bb.__vector(this.bb_pos+n)+4*t,e):null}inputsLength(){let t=this.bb.__offset(this.bb_pos,14);return t?this.bb.__vector_len(this.bb_pos+t):0}outputs(t,e){let n=this.bb.__offset(this.bb_pos,16);return n?this.bb.__string(this.bb.__vector(this.bb_pos+n)+4*t,e):null}outputsLength(){let t=this.bb.__offset(this.bb_pos,16);return t?this.bb.__vector_len(this.bb_pos+t):0}sparseInitializers(e,n){let B=this.bb.__offset(this.bb_pos,18);return B?(n||new t.experimental.fbs.SparseTensor).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+B)+4*e),this.bb):null}sparseInitializersLength(){let t=this.bb.__offset(this.bb_pos,18);return t?this.bb.__vector_len(this.bb_pos+t):0}static startGraph(t){t.startObject(8)}static addInitializers(t,e){t.addFieldOffset(0,e,0)}static createInitializersVector(t,e){t.startVector(4,e.length,4);for(let n=e.length-1;n>=0;n--)t.addOffset(e[n]);return t.endVector()}static startInitializersVector(t,e){t.startVector(4,e,4)}static addNodeArgs(t,e){t.addFieldOffset(1,e,0)}static createNodeArgsVector(t,e){t.startVector(4,e.length,4);for(let n=e.length-1;n>=0;n--)t.addOffset(e[n]);return t.endVector()}static startNodeArgsVector(t,e){t.startVector(4,e,4)}static addNodes(t,e){t.addFieldOffset(2,e,0)}static createNodesVector(t,e){t.startVector(4,e.length,4);for(let n=e.length-1;n>=0;n--)t.addOffset(e[n]);return t.endVector()}static startNodesVector(t,e){t.startVector(4,e,4)}static addMaxNodeIndex(t,e){t.addFieldInt32(3,e,0)}static addNodeEdges(t,e){t.addFieldOffset(4,e,0)}static createNodeEdgesVector(t,e){t.startVector(4,e.length,4);for(let n=e.length-1;n>=0;n--)t.addOffset(e[n]);return t.endVector()}static startNodeEdgesVector(t,e){t.startVector(4,e,4)}static addInputs(t,e){t.addFieldOffset(5,e,0)}static createInputsVector(t,e){t.startVector(4,e.length,4);for(let n=e.length-1;n>=0;n--)t.addOffset(e[n]);return t.endVector()}static startInputsVector(t,e){t.startVector(4,e,4)}static addOutputs(t,e){t.addFieldOffset(6,e,0)}static createOutputsVector(t,e){t.startVector(4,e.length,4);for(let n=e.length-1;n>=0;n--)t.addOffset(e[n]);return t.endVector()}static startOutputsVector(t,e){t.startVector(4,e,4)}static addSparseInitializers(t,e){t.addFieldOffset(7,e,0)}static createSparseInitializersVector(t,e){t.startVector(4,e.length,4);for(let n=e.length-1;n>=0;n--)t.addOffset(e[n]);return t.endVector()}static startSparseInitializersVector(t,e){t.startVector(4,e,4)}static endGraph(t){return t.endObject()}static createGraph(t,e,B,s,F,Q,U,i,a){return n.startGraph(t),n.addInitializers(t,e),n.addNodeArgs(t,B),n.addNodes(t,s),n.addMaxNodeIndex(t,F),n.addNodeEdges(t,Q),n.addInputs(t,U),n.addOutputs(t,i),n.addSparseInitializers(t,a),n.endGraph(t)}}e.Graph=n})(n=e.fbs||(e.fbs={}))})(e=t.experimental||(t.experimental={}))})(onnxruntime||(onnxruntime={})),(t=>{let e;(e=>{let n;(e=>{class n{constructor(){this.bb=null,this.bb_pos=0}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsModel(t,e){return(e||new n).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsModel(t,e){return t.setPosition(t.position()+flatbuffers.SIZE_PREFIX_LENGTH),(e||new n).__init(t.readInt32(t.position())+t.position(),t)}irVersion(){let t=this.bb.__offset(this.bb_pos,4);return t?this.bb.readInt64(this.bb_pos+t):this.bb.createLong(0,0)}opsetImport(e,n){let B=this.bb.__offset(this.bb_pos,6);return B?(n||new t.experimental.fbs.OperatorSetId).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+B)+4*e),this.bb):null}opsetImportLength(){let t=this.bb.__offset(this.bb_pos,6);return t?this.bb.__vector_len(this.bb_pos+t):0}producerName(t){let e=this.bb.__offset(this.bb_pos,8);return e?this.bb.__string(this.bb_pos+e,t):null}producerVersion(t){let e=this.bb.__offset(this.bb_pos,10);return e?this.bb.__string(this.bb_pos+e,t):null}domain(t){let e=this.bb.__offset(this.bb_pos,12);return e?this.bb.__string(this.bb_pos+e,t):null}modelVersion(){let t=this.bb.__offset(this.bb_pos,14);return t?this.bb.readInt64(this.bb_pos+t):this.bb.createLong(0,0)}docString(t){let e=this.bb.__offset(this.bb_pos,16);return e?this.bb.__string(this.bb_pos+e,t):null}graph(e){let n=this.bb.__offset(this.bb_pos,18);return n?(e||new t.experimental.fbs.Graph).__init(this.bb.__indirect(this.bb_pos+n),this.bb):null}graphDocString(t){let e=this.bb.__offset(this.bb_pos,20);return e?this.bb.__string(this.bb_pos+e,t):null}static startModel(t){t.startObject(9)}static addIrVersion(t,e){t.addFieldInt64(0,e,t.createLong(0,0))}static addOpsetImport(t,e){t.addFieldOffset(1,e,0)}static createOpsetImportVector(t,e){t.startVector(4,e.length,4);for(let n=e.length-1;n>=0;n--)t.addOffset(e[n]);return t.endVector()}static startOpsetImportVector(t,e){t.startVector(4,e,4)}static addProducerName(t,e){t.addFieldOffset(2,e,0)}static addProducerVersion(t,e){t.addFieldOffset(3,e,0)}static addDomain(t,e){t.addFieldOffset(4,e,0)}static addModelVersion(t,e){t.addFieldInt64(5,e,t.createLong(0,0))}static addDocString(t,e){t.addFieldOffset(6,e,0)}static addGraph(t,e){t.addFieldOffset(7,e,0)}static addGraphDocString(t,e){t.addFieldOffset(8,e,0)}static endModel(t){return t.endObject()}static createModel(t,e,B,s,F,Q,U,i,a,l){return n.startModel(t),n.addIrVersion(t,e),n.addOpsetImport(t,B),n.addProducerName(t,s),n.addProducerVersion(t,F),n.addDomain(t,Q),n.addModelVersion(t,U),n.addDocString(t,i),n.addGraph(t,a),n.addGraphDocString(t,l),n.endModel(t)}}e.Model=n})(n=e.fbs||(e.fbs={}))})(e=t.experimental||(t.experimental={}))})(onnxruntime||(onnxruntime={})),(t=>{let e;(t=>{let e;(t=>{class e{constructor(){this.bb=null,this.bb_pos=0}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsKernelCreateInfos(t,n){return(n||new e).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsKernelCreateInfos(t,n){return t.setPosition(t.position()+flatbuffers.SIZE_PREFIX_LENGTH),(n||new e).__init(t.readInt32(t.position())+t.position(),t)}nodeIndices(t){let e=this.bb.__offset(this.bb_pos,4);return e?this.bb.readUint32(this.bb.__vector(this.bb_pos+e)+4*t):0}nodeIndicesLength(){let t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__vector_len(this.bb_pos+t):0}nodeIndicesArray(){let t=this.bb.__offset(this.bb_pos,4);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}kernelDefHashes(t){let e=this.bb.__offset(this.bb_pos,6);return e?this.bb.readUint64(this.bb.__vector(this.bb_pos+e)+8*t):this.bb.createLong(0,0)}kernelDefHashesLength(){let t=this.bb.__offset(this.bb_pos,6);return t?this.bb.__vector_len(this.bb_pos+t):0}static startKernelCreateInfos(t){t.startObject(2)}static addNodeIndices(t,e){t.addFieldOffset(0,e,0)}static createNodeIndicesVector(t,e){t.startVector(4,e.length,4);for(let n=e.length-1;n>=0;n--)t.addInt32(e[n]);return t.endVector()}static startNodeIndicesVector(t,e){t.startVector(4,e,4)}static addKernelDefHashes(t,e){t.addFieldOffset(1,e,0)}static createKernelDefHashesVector(t,e){t.startVector(8,e.length,8);for(let n=e.length-1;n>=0;n--)t.addInt64(e[n]);return t.endVector()}static startKernelDefHashesVector(t,e){t.startVector(8,e,8)}static endKernelCreateInfos(t){return t.endObject()}static createKernelCreateInfos(t,n,B){return e.startKernelCreateInfos(t),e.addNodeIndices(t,n),e.addKernelDefHashes(t,B),e.endKernelCreateInfos(t)}}t.KernelCreateInfos=e})(e=t.fbs||(t.fbs={}))})(e=t.experimental||(t.experimental={}))})(onnxruntime||(onnxruntime={})),(t=>{let e;(e=>{let n;(e=>{class n{constructor(){this.bb=null,this.bb_pos=0}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsSubGraphSessionState(t,e){return(e||new n).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsSubGraphSessionState(t,e){return t.setPosition(t.position()+flatbuffers.SIZE_PREFIX_LENGTH),(e||new n).__init(t.readInt32(t.position())+t.position(),t)}graphId(t){let e=this.bb.__offset(this.bb_pos,4);return e?this.bb.__string(this.bb_pos+e,t):null}sessionState(e){let n=this.bb.__offset(this.bb_pos,6);return n?(e||new t.experimental.fbs.SessionState).__init(this.bb.__indirect(this.bb_pos+n),this.bb):null}static startSubGraphSessionState(t){t.startObject(2)}static addGraphId(t,e){t.addFieldOffset(0,e,0)}static addSessionState(t,e){t.addFieldOffset(1,e,0)}static endSubGraphSessionState(t){let e=t.endObject();return t.requiredField(e,4),e}static createSubGraphSessionState(t,e,B){return n.startSubGraphSessionState(t),n.addGraphId(t,e),n.addSessionState(t,B),n.endSubGraphSessionState(t)}}e.SubGraphSessionState=n})(n=e.fbs||(e.fbs={}))})(e=t.experimental||(t.experimental={}))})(onnxruntime||(onnxruntime={})),(t=>{let e;(e=>{let n;(e=>{class n{constructor(){this.bb=null,this.bb_pos=0}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsSessionState(t,e){return(e||new n).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsSessionState(t,e){return t.setPosition(t.position()+flatbuffers.SIZE_PREFIX_LENGTH),(e||new n).__init(t.readInt32(t.position())+t.position(),t)}kernels(e){let n=this.bb.__offset(this.bb_pos,4);return n?(e||new t.experimental.fbs.KernelCreateInfos).__init(this.bb.__indirect(this.bb_pos+n),this.bb):null}subGraphSessionStates(e,n){let B=this.bb.__offset(this.bb_pos,6);return B?(n||new t.experimental.fbs.SubGraphSessionState).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+B)+4*e),this.bb):null}subGraphSessionStatesLength(){let t=this.bb.__offset(this.bb_pos,6);return t?this.bb.__vector_len(this.bb_pos+t):0}static startSessionState(t){t.startObject(2)}static addKernels(t,e){t.addFieldOffset(0,e,0)}static addSubGraphSessionStates(t,e){t.addFieldOffset(1,e,0)}static createSubGraphSessionStatesVector(t,e){t.startVector(4,e.length,4);for(let n=e.length-1;n>=0;n--)t.addOffset(e[n]);return t.endVector()}static startSubGraphSessionStatesVector(t,e){t.startVector(4,e,4)}static endSessionState(t){return t.endObject()}static createSessionState(t,e,B){return n.startSessionState(t),n.addKernels(t,e),n.addSubGraphSessionStates(t,B),n.endSessionState(t)}}e.SessionState=n})(n=e.fbs||(e.fbs={}))})(e=t.experimental||(t.experimental={}))})(onnxruntime||(onnxruntime={})),(t=>{let e;(e=>{let n;(e=>{class n{constructor(){this.bb=null,this.bb_pos=0}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsInferenceSession(t,e){return(e||new n).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsInferenceSession(t,e){return t.setPosition(t.position()+flatbuffers.SIZE_PREFIX_LENGTH),(e||new n).__init(t.readInt32(t.position())+t.position(),t)}static bufferHasIdentifier(t){return t.__has_identifier("ORTM")}ortVersion(t){let e=this.bb.__offset(this.bb_pos,4);return e?this.bb.__string(this.bb_pos+e,t):null}model(e){let n=this.bb.__offset(this.bb_pos,6);return n?(e||new t.experimental.fbs.Model).__init(this.bb.__indirect(this.bb_pos+n),this.bb):null}sessionState(e){let n=this.bb.__offset(this.bb_pos,8);return n?(e||new t.experimental.fbs.SessionState).__init(this.bb.__indirect(this.bb_pos+n),this.bb):null}static startInferenceSession(t){t.startObject(3)}static addOrtVersion(t,e){t.addFieldOffset(0,e,0)}static addModel(t,e){t.addFieldOffset(1,e,0)}static addSessionState(t,e){t.addFieldOffset(2,e,0)}static endInferenceSession(t){return t.endObject()}static finishInferenceSessionBuffer(t,e){t.finish(e,"ORTM")}static finishSizePrefixedInferenceSessionBuffer(t,e){t.finish(e,"ORTM",!0)}static createInferenceSession(t,e,B,s){return n.startInferenceSession(t),n.addOrtVersion(t,e),n.addModel(t,B),n.addSessionState(t,s),n.endInferenceSession(t)}}e.InferenceSession=n})(n=e.fbs||(e.fbs={}))})(e=t.experimental||(t.experimental={}))})(onnxruntime||(onnxruntime={}))}}),require_aspromise=__commonJS({"web/node_modules/@protobufjs/aspromise/index.js"(t,e){e.exports=function(t,e){var n=new Array(arguments.length-1),B=0,s=2,F=!0;for(;s<arguments.length;)n[B++]=arguments[s++];return new Promise((function(s,Q){n[B]=function(t){if(F)if(F=!1,t)Q(t);else{for(var e=new Array(arguments.length-1),n=0;n<e.length;)e[n++]=arguments[n];s.apply(null,e)}};try{t.apply(e||null,n)}catch(t){F&&(F=!1,Q(t))}}))}}}),require_base64=__commonJS({"web/node_modules/@protobufjs/base64/index.js"(t){var e=t;e.length=function(t){var e=t.length;if(!e)return 0;for(var n=0;--e%4>1&&"="===t.charAt(e);)++n;return Math.ceil(3*t.length)/4-n};var n,B=new Array(64),s=new Array(123);for(n=0;n<64;)s[B[n]=n<26?n+65:n<52?n+71:n<62?n-4:n-59|43]=n++;e.encode=function(t,e,n){for(var s,F=null,Q=[],U=0,i=0;e<n;){var a=t[e++];switch(i){case 0:Q[U++]=B[a>>2],s=(3&a)<<4,i=1;break;case 1:Q[U++]=B[s|a>>4],s=(15&a)<<2,i=2;break;case 2:Q[U++]=B[s|a>>6],Q[U++]=B[63&a],i=0}U>8191&&((F||(F=[])).push(String.fromCharCode.apply(String,Q)),U=0)}return i&&(Q[U++]=B[s],Q[U++]=61,1===i&&(Q[U++]=61)),F?(U&&F.push(String.fromCharCode.apply(String,Q.slice(0,U))),F.join("")):String.fromCharCode.apply(String,Q.slice(0,U))};var F="invalid encoding";e.decode=function(t,e,n){for(var B,Q=n,U=0,i=0;i<t.length;){var a=t.charCodeAt(i++);if(61===a&&U>1)break;if(void 0===(a=s[a]))throw Error(F);switch(U){case 0:B=a,U=1;break;case 1:e[n++]=B<<2|(48&a)>>4,B=a,U=2;break;case 2:e[n++]=(15&B)<<4|(60&a)>>2,B=a,U=3;break;case 3:e[n++]=(3&B)<<6|a,U=0}}if(1===U)throw Error(F);return n-Q},e.test=function(t){return/^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(t)}}}),require_eventemitter=__commonJS({"web/node_modules/@protobufjs/eventemitter/index.js"(t,e){function n(){this._listeners={}}e.exports=n,n.prototype.on=function(t,e,n){return(this._listeners[t]||(this._listeners[t]=[])).push({fn:e,ctx:n||this}),this},n.prototype.off=function(t,e){if(void 0===t)this._listeners={};else if(void 0===e)this._listeners[t]=[];else for(var n=this._listeners[t],B=0;B<n.length;)n[B].fn===e?n.splice(B,1):++B;return this},n.prototype.emit=function(t){var e=this._listeners[t];if(e){for(var n=[],B=1;B<arguments.length;)n.push(arguments[B++]);for(B=0;B<e.length;)e[B].fn.apply(e[B++].ctx,n)}return this}}}),require_float=__commonJS({"web/node_modules/@protobufjs/float/index.js"(t,e){function n(t){return"undefined"!=typeof Float32Array?function(){var e=new Float32Array([-0]),n=new Uint8Array(e.buffer),B=128===n[3];function s(t,B,s){e[0]=t,B[s]=n[0],B[s+1]=n[1],B[s+2]=n[2],B[s+3]=n[3]}function F(t,B,s){e[0]=t,B[s]=n[3],B[s+1]=n[2],B[s+2]=n[1],B[s+3]=n[0]}function Q(t,B){return n[0]=t[B],n[1]=t[B+1],n[2]=t[B+2],n[3]=t[B+3],e[0]}function U(t,B){return n[3]=t[B],n[2]=t[B+1],n[1]=t[B+2],n[0]=t[B+3],e[0]}t.writeFloatLE=B?s:F,t.writeFloatBE=B?F:s,t.readFloatLE=B?Q:U,t.readFloatBE=B?U:Q}():function(){function e(t,e,n,B){var s=e<0?1:0;if(s&&(e=-e),0===e)t(1/e>0?0:2147483648,n,B);else if(isNaN(e))t(2143289344,n,B);else if(e>34028234663852886e22)t((s<<31|2139095040)>>>0,n,B);else if(e<11754943508222875e-54)t((s<<31|Math.round(e/1401298464324817e-60))>>>0,n,B);else{var F=Math.floor(Math.log(e)/Math.LN2);t((s<<31|F+127<<23|8388607&Math.round(e*Math.pow(2,-F)*8388608))>>>0,n,B)}}function n(t,e,n){var B=t(e,n),s=2*(B>>31)+1,F=B>>>23&255,Q=8388607&B;return 255===F?Q?NaN:s*(1/0):0===F?1401298464324817e-60*s*Q:s*Math.pow(2,F-150)*(Q+8388608)}t.writeFloatLE=e.bind(null,B),t.writeFloatBE=e.bind(null,s),t.readFloatLE=n.bind(null,F),t.readFloatBE=n.bind(null,Q)}(),"undefined"!=typeof Float64Array?function(){var e=new Float64Array([-0]),n=new Uint8Array(e.buffer),B=128===n[7];function s(t,B,s){e[0]=t,B[s]=n[0],B[s+1]=n[1],B[s+2]=n[2],B[s+3]=n[3],B[s+4]=n[4],B[s+5]=n[5],B[s+6]=n[6],B[s+7]=n[7]}function F(t,B,s){e[0]=t,B[s]=n[7],B[s+1]=n[6],B[s+2]=n[5],B[s+3]=n[4],B[s+4]=n[3],B[s+5]=n[2],B[s+6]=n[1],B[s+7]=n[0]}function Q(t,B){return n[0]=t[B],n[1]=t[B+1],n[2]=t[B+2],n[3]=t[B+3],n[4]=t[B+4],n[5]=t[B+5],n[6]=t[B+6],n[7]=t[B+7],e[0]}function U(t,B){return n[7]=t[B],n[6]=t[B+1],n[5]=t[B+2],n[4]=t[B+3],n[3]=t[B+4],n[2]=t[B+5],n[1]=t[B+6],n[0]=t[B+7],e[0]}t.writeDoubleLE=B?s:F,t.writeDoubleBE=B?F:s,t.readDoubleLE=B?Q:U,t.readDoubleBE=B?U:Q}():function(){function e(t,e,n,B,s,F){var Q=B<0?1:0;if(Q&&(B=-B),0===B)t(0,s,F+e),t(1/B>0?0:2147483648,s,F+n);else if(isNaN(B))t(0,s,F+e),t(2146959360,s,F+n);else if(B>17976931348623157e292)t(0,s,F+e),t((Q<<31|2146435072)>>>0,s,F+n);else{var U;if(B<22250738585072014e-324)t((U=B/5e-324)>>>0,s,F+e),t((Q<<31|U/4294967296)>>>0,s,F+n);else{var i=Math.floor(Math.log(B)/Math.LN2);1024===i&&(i=1023),t(4503599627370496*(U=B*Math.pow(2,-i))>>>0,s,F+e),t((Q<<31|i+1023<<20|1048576*U&1048575)>>>0,s,F+n)}}}function n(t,e,n,B,s){var F=t(B,s+e),Q=t(B,s+n),U=2*(Q>>31)+1,i=Q>>>20&2047,a=4294967296*(1048575&Q)+F;return 2047===i?a?NaN:U*(1/0):0===i?5e-324*U*a:U*Math.pow(2,i-1075)*(a+4503599627370496)}t.writeDoubleLE=e.bind(null,B,0,4),t.writeDoubleBE=e.bind(null,s,4,0),t.readDoubleLE=n.bind(null,F,0,4),t.readDoubleBE=n.bind(null,Q,4,0)}(),t}function B(t,e,n){e[n]=255&t,e[n+1]=t>>>8&255,e[n+2]=t>>>16&255,e[n+3]=t>>>24}function s(t,e,n){e[n]=t>>>24,e[n+1]=t>>>16&255,e[n+2]=t>>>8&255,e[n+3]=255&t}function F(t,e){return(t[e]|t[e+1]<<8|t[e+2]<<16|t[e+3]<<24)>>>0}function Q(t,e){return(t[e]<<24|t[e+1]<<16|t[e+2]<<8|t[e+3])>>>0}e.exports=n(n)}}),require_inquire=__commonJS({"web/node_modules/@protobufjs/inquire/index.js"(exports,module){function inquire(moduleName){try{var mod=eval("quire".replace(/^/,"re"))(moduleName);if(mod&&(mod.length||Object.keys(mod).length))return mod}catch(t){}return null}module.exports=inquire}}),require_utf8=__commonJS({"web/node_modules/@protobufjs/utf8/index.js"(t){var e=t;e.length=function(t){for(var e=0,n=0,B=0;B<t.length;++B)(n=t.charCodeAt(B))<128?e+=1:n<2048?e+=2:55296==(64512&n)&&56320==(64512&t.charCodeAt(B+1))?(++B,e+=4):e+=3;return e},e.read=function(t,e,n){if(n-e<1)return"";for(var B,s=null,F=[],Q=0;e<n;)(B=t[e++])<128?F[Q++]=B:B>191&&B<224?F[Q++]=(31&B)<<6|63&t[e++]:B>239&&B<365?(B=((7&B)<<18|(63&t[e++])<<12|(63&t[e++])<<6|63&t[e++])-65536,F[Q++]=55296+(B>>10),F[Q++]=56320+(1023&B)):F[Q++]=(15&B)<<12|(63&t[e++])<<6|63&t[e++],Q>8191&&((s||(s=[])).push(String.fromCharCode.apply(String,F)),Q=0);return s?(Q&&s.push(String.fromCharCode.apply(String,F.slice(0,Q))),s.join("")):String.fromCharCode.apply(String,F.slice(0,Q))},e.write=function(t,e,n){for(var B,s,F=n,Q=0;Q<t.length;++Q)(B=t.charCodeAt(Q))<128?e[n++]=B:B<2048?(e[n++]=B>>6|192,e[n++]=63&B|128):55296==(64512&B)&&56320==(64512&(s=t.charCodeAt(Q+1)))?(B=65536+((1023&B)<<10)+(1023&s),++Q,e[n++]=B>>18|240,e[n++]=B>>12&63|128,e[n++]=B>>6&63|128,e[n++]=63&B|128):(e[n++]=B>>12|224,e[n++]=B>>6&63|128,e[n++]=63&B|128);return n-F}}}),require_pool=__commonJS({"web/node_modules/@protobufjs/pool/index.js"(t,e){e.exports=function(t,e,n){var B=n||8192,s=B>>>1,F=null,Q=B;return function(n){if(n<1||n>s)return t(n);Q+n>B&&(F=t(B),Q=0);var U=e.call(F,Q,Q+=n);return 7&Q&&(Q=1+(7|Q)),U}}}}),require_longbits=__commonJS({"web/node_modules/protobufjs/src/util/longbits.js"(t,e){e.exports=B;var n=require_minimal();function B(t,e){this.lo=t>>>0,this.hi=e>>>0}var s=B.zero=new B(0,0);s.toNumber=function(){return 0},s.zzEncode=s.zzDecode=function(){return this},s.length=function(){return 1};var F=B.zeroHash="\0\0\0\0\0\0\0\0";B.fromNumber=function(t){if(0===t)return s;var e=t<0;e&&(t=-t);var n=t>>>0,F=(t-n)/4294967296>>>0;return e&&(F=~F>>>0,n=~n>>>0,++n>4294967295&&(n=0,++F>4294967295&&(F=0))),new B(n,F)},B.from=function(t){if("number"==typeof t)return B.fromNumber(t);if(n.isString(t)){if(!n.Long)return B.fromNumber(parseInt(t,10));t=n.Long.fromString(t)}return t.low||t.high?new B(t.low>>>0,t.high>>>0):s},B.prototype.toNumber=function(t){if(!t&&this.hi>>>31){var e=1+~this.lo>>>0,n=~this.hi>>>0;return e||(n=n+1>>>0),-(e+4294967296*n)}return this.lo+4294967296*this.hi},B.prototype.toLong=function(t){return n.Long?new n.Long(0|this.lo,0|this.hi,Boolean(t)):{low:0|this.lo,high:0|this.hi,unsigned:Boolean(t)}};var Q=String.prototype.charCodeAt;B.fromHash=function(t){return t===F?s:new B((Q.call(t,0)|Q.call(t,1)<<8|Q.call(t,2)<<16|Q.call(t,3)<<24)>>>0,(Q.call(t,4)|Q.call(t,5)<<8|Q.call(t,6)<<16|Q.call(t,7)<<24)>>>0)},B.prototype.toHash=function(){return String.fromCharCode(255&this.lo,this.lo>>>8&255,this.lo>>>16&255,this.lo>>>24,255&this.hi,this.hi>>>8&255,this.hi>>>16&255,this.hi>>>24)},B.prototype.zzEncode=function(){var t=this.hi>>31;return this.hi=((this.hi<<1|this.lo>>>31)^t)>>>0,this.lo=(this.lo<<1^t)>>>0,this},B.prototype.zzDecode=function(){var t=-(1&this.lo);return this.lo=((this.lo>>>1|this.hi<<31)^t)>>>0,this.hi=(this.hi>>>1^t)>>>0,this},B.prototype.length=function(){var t=this.lo,e=(this.lo>>>28|this.hi<<4)>>>0,n=this.hi>>>24;return 0===n?0===e?t<16384?t<128?1:2:t<2097152?3:4:e<16384?e<128?5:6:e<2097152?7:8:n<128?9:10}}}),require_minimal=__commonJS({"web/node_modules/protobufjs/src/util/minimal.js"(t){var e=t;function n(t,e,n){for(var B=Object.keys(e),s=0;s<B.length;++s)void 0!==t[B[s]]&&n||(t[B[s]]=e[B[s]]);return t}function B(t){function e(t,B){if(!(this instanceof e))return new e(t,B);Object.defineProperty(this,"message",{get:function(){return t}}),Error.captureStackTrace?Error.captureStackTrace(this,e):Object.defineProperty(this,"stack",{value:(new Error).stack||""}),B&&n(this,B)}return e.prototype=Object.create(Error.prototype,{constructor:{value:e,writable:!0,enumerable:!1,configurable:!0},name:{get:function(){return t},set:void 0,enumerable:!1,configurable:!0},toString:{value:function(){return this.name+": "+this.message},writable:!0,enumerable:!1,configurable:!0}}),e}e.asPromise=require_aspromise(),e.base64=require_base64(),e.EventEmitter=require_eventemitter(),e.float=require_float(),e.inquire=require_inquire(),e.utf8=require_utf8(),e.pool=require_pool(),e.LongBits=require_longbits(),e.isNode=Boolean("undefined"!=typeof global&&global&&global.process&&global.process.versions&&global.process.versions.node),e.global=e.isNode&&global||"undefined"!=typeof window&&window||"undefined"!=typeof self&&self||t,e.emptyArray=Object.freeze?Object.freeze([]):[],e.emptyObject=Object.freeze?Object.freeze({}):{},e.isInteger=Number.isInteger||function(t){return"number"==typeof t&&isFinite(t)&&Math.floor(t)===t},e.isString=function(t){return"string"==typeof t||t instanceof String},e.isObject=function(t){return t&&"object"==typeof t},e.isset=e.isSet=function(t,e){var n=t[e];return!(null==n||!t.hasOwnProperty(e))&&("object"!=typeof n||(Array.isArray(n)?n.length:Object.keys(n).length)>0)},e.Buffer=function(){try{var t=e.inquire("buffer").Buffer;return t.prototype.utf8Write?t:null}catch(t){return null}}(),e._Buffer_from=null,e._Buffer_allocUnsafe=null,e.newBuffer=function(t){return"number"==typeof t?e.Buffer?e._Buffer_allocUnsafe(t):new e.Array(t):e.Buffer?e._Buffer_from(t):"undefined"==typeof Uint8Array?t:new Uint8Array(t)},e.Array="undefined"!=typeof Uint8Array?Uint8Array:Array,e.Long=e.global.dcodeIO&&e.global.dcodeIO.Long||e.global.Long||e.inquire("long"),e.key2Re=/^true|false|0|1$/,e.key32Re=/^-?(?:0|[1-9][0-9]*)$/,e.key64Re=/^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/,e.longToHash=function(t){return t?e.LongBits.from(t).toHash():e.LongBits.zeroHash},e.longFromHash=function(t,n){var B=e.LongBits.fromHash(t);return e.Long?e.Long.fromBits(B.lo,B.hi,n):B.toNumber(Boolean(n))},e.merge=n,e.lcFirst=function(t){return t.charAt(0).toLowerCase()+t.substring(1)},e.newError=B,e.ProtocolError=B("ProtocolError"),e.oneOfGetter=function(t){for(var e={},n=0;n<t.length;++n)e[t[n]]=1;return function(){for(var t=Object.keys(this),n=t.length-1;n>-1;--n)if(1===e[t[n]]&&void 0!==this[t[n]]&&null!==this[t[n]])return t[n]}},e.oneOfSetter=function(t){return function(e){for(var n=0;n<t.length;++n)t[n]!==e&&delete this[t[n]]}},e.toJSONOptions={longs:String,enums:String,bytes:String,json:!0},e._configure=function(){var t=e.Buffer;t?(e._Buffer_from=t.from!==Uint8Array.from&&t.from||function(e,n){return new t(e,n)},e._Buffer_allocUnsafe=t.allocUnsafe||function(e){return new t(e)}):e._Buffer_from=e._Buffer_allocUnsafe=null}}}),require_writer=__commonJS({"web/node_modules/protobufjs/src/writer.js"(t,e){e.exports=l;var n,B=require_minimal(),s=B.LongBits,F=B.base64,Q=B.utf8;function U(t,e,n){this.fn=t,this.len=e,this.next=void 0,this.val=n}function i(){}function a(t){this.head=t.head,this.tail=t.tail,this.len=t.len,this.next=t.states}function l(){this.len=0,this.head=new U(i,0,0),this.tail=this.head,this.states=null}var c=function(){return B.Buffer?function(){return(l.create=function(){return new n})()}:function(){return new l}};function g(t,e,n){e[n]=255&t}function d(t,e){this.len=t,this.next=void 0,this.val=e}function I(t,e,n){for(;t.hi;)e[n++]=127&t.lo|128,t.lo=(t.lo>>>7|t.hi<<25)>>>0,t.hi>>>=7;for(;t.lo>127;)e[n++]=127&t.lo|128,t.lo=t.lo>>>7;e[n++]=t.lo}function o(t,e,n){e[n]=255&t,e[n+1]=t>>>8&255,e[n+2]=t>>>16&255,e[n+3]=t>>>24}l.create=c(),l.alloc=function(t){return new B.Array(t)},B.Array!==Array&&(l.alloc=B.pool(l.alloc,B.Array.prototype.subarray)),l.prototype._push=function(t,e,n){return this.tail=this.tail.next=new U(t,e,n),this.len+=e,this},d.prototype=Object.create(U.prototype),d.prototype.fn=function(t,e,n){for(;t>127;)e[n++]=127&t|128,t>>>=7;e[n]=t},l.prototype.uint32=function(t){return this.len+=(this.tail=this.tail.next=new d((t>>>=0)<128?1:t<16384?2:t<2097152?3:t<268435456?4:5,t)).len,this},l.prototype.int32=function(t){return t<0?this._push(I,10,s.fromNumber(t)):this.uint32(t)},l.prototype.sint32=function(t){return this.uint32((t<<1^t>>31)>>>0)},l.prototype.uint64=function(t){var e=s.from(t);return this._push(I,e.length(),e)},l.prototype.int64=l.prototype.uint64,l.prototype.sint64=function(t){var e=s.from(t).zzEncode();return this._push(I,e.length(),e)},l.prototype.bool=function(t){return this._push(g,1,t?1:0)},l.prototype.fixed32=function(t){return this._push(o,4,t>>>0)},l.prototype.sfixed32=l.prototype.fixed32,l.prototype.fixed64=function(t){var e=s.from(t);return this._push(o,4,e.lo)._push(o,4,e.hi)},l.prototype.sfixed64=l.prototype.fixed64,l.prototype.float=function(t){return this._push(B.float.writeFloatLE,4,t)},l.prototype.double=function(t){return this._push(B.float.writeDoubleLE,8,t)};var r=B.Array.prototype.set?function(t,e,n){e.set(t,n)}:function(t,e,n){for(var B=0;B<t.length;++B)e[n+B]=t[B]};l.prototype.bytes=function(t){var e=t.length>>>0;if(!e)return this._push(g,1,0);if(B.isString(t)){var n=l.alloc(e=F.length(t));F.decode(t,n,0),t=n}return this.uint32(e)._push(r,e,t)},l.prototype.string=function(t){var e=Q.length(t);return e?this.uint32(e)._push(Q.write,e,t):this._push(g,1,0)},l.prototype.fork=function(){return this.states=new a(this),this.head=this.tail=new U(i,0,0),this.len=0,this},l.prototype.reset=function(){return this.states?(this.head=this.states.head,this.tail=this.states.tail,this.len=this.states.len,this.states=this.states.next):(this.head=this.tail=new U(i,0,0),this.len=0),this},l.prototype.ldelim=function(){var t=this.head,e=this.tail,n=this.len;return this.reset().uint32(n),n&&(this.tail.next=t.next,this.tail=e,this.len+=n),this},l.prototype.finish=function(){for(var t=this.head.next,e=this.constructor.alloc(this.len),n=0;t;)t.fn(t.val,e,n),n+=t.len,t=t.next;return e},l._configure=function(t){n=t,l.create=c(),n._configure()}}}),require_writer_buffer=__commonJS({"web/node_modules/protobufjs/src/writer_buffer.js"(t,e){e.exports=s;var n=require_writer();(s.prototype=Object.create(n.prototype)).constructor=s;var B=require_minimal();function s(){n.call(this)}function F(t,e,n){t.length<40?B.utf8.write(t,e,n):e.utf8Write?e.utf8Write(t,n):e.write(t,n)}s._configure=function(){s.alloc=B._Buffer_allocUnsafe,s.writeBytesBuffer=B.Buffer&&B.Buffer.prototype instanceof Uint8Array&&"set"===B.Buffer.prototype.set.name?function(t,e,n){e.set(t,n)}:function(t,e,n){if(t.copy)t.copy(e,n,0,t.length);else for(var B=0;B<t.length;)e[n++]=t[B++]}},s.prototype.bytes=function(t){B.isString(t)&&(t=B._Buffer_from(t,"base64"));var e=t.length>>>0;return this.uint32(e),e&&this._push(s.writeBytesBuffer,e,t),this},s.prototype.string=function(t){var e=B.Buffer.byteLength(t);return this.uint32(e),e&&this._push(F,e,t),this},s._configure()}}),require_reader=__commonJS({"web/node_modules/protobufjs/src/reader.js"(t,e){e.exports=U;var n,B=require_minimal(),s=B.LongBits,F=B.utf8;function Q(t,e){return RangeError("index out of range: "+t.pos+" + "+(e||1)+" > "+t.len)}function U(t){this.buf=t,this.pos=0,this.len=t.length}var i,a="undefined"!=typeof Uint8Array?function(t){if(t instanceof Uint8Array||Array.isArray(t))return new U(t);throw Error("illegal buffer")}:function(t){if(Array.isArray(t))return new U(t);throw Error("illegal buffer")},l=function(){return B.Buffer?function(t){return(U.create=function(t){return B.Buffer.isBuffer(t)?new n(t):a(t)})(t)}:a};function c(){var t=new s(0,0),e=0;if(!(this.len-this.pos>4)){for(;e<3;++e){if(this.pos>=this.len)throw Q(this);if(t.lo=(t.lo|(127&this.buf[this.pos])<<7*e)>>>0,this.buf[this.pos++]<128)return t}return t.lo=(t.lo|(127&this.buf[this.pos++])<<7*e)>>>0,t}for(;e<4;++e)if(t.lo=(t.lo|(127&this.buf[this.pos])<<7*e)>>>0,this.buf[this.pos++]<128)return t;if(t.lo=(t.lo|(127&this.buf[this.pos])<<28)>>>0,t.hi=(t.hi|(127&this.buf[this.pos])>>4)>>>0,this.buf[this.pos++]<128)return t;if(e=0,this.len-this.pos>4){for(;e<5;++e)if(t.hi=(t.hi|(127&this.buf[this.pos])<<7*e+3)>>>0,this.buf[this.pos++]<128)return t}else for(;e<5;++e){if(this.pos>=this.len)throw Q(this);if(t.hi=(t.hi|(127&this.buf[this.pos])<<7*e+3)>>>0,this.buf[this.pos++]<128)return t}throw Error("invalid varint encoding")}function g(t,e){return(t[e-4]|t[e-3]<<8|t[e-2]<<16|t[e-1]<<24)>>>0}function d(){if(this.pos+8>this.len)throw Q(this,8);return new s(g(this.buf,this.pos+=4),g(this.buf,this.pos+=4))}U.create=l(),U.prototype._slice=B.Array.prototype.subarray||B.Array.prototype.slice,U.prototype.uint32=(i=4294967295,function(){if(i=(127&this.buf[this.pos])>>>0,this.buf[this.pos++]<128)return i;if(i=(i|(127&this.buf[this.pos])<<7)>>>0,this.buf[this.pos++]<128)return i;if(i=(i|(127&this.buf[this.pos])<<14)>>>0,this.buf[this.pos++]<128)return i;if(i=(i|(127&this.buf[this.pos])<<21)>>>0,this.buf[this.pos++]<128)return i;if(i=(i|(15&this.buf[this.pos])<<28)>>>0,this.buf[this.pos++]<128)return i;if((this.pos+=5)>this.len)throw this.pos=this.len,Q(this,10);return i}),U.prototype.int32=function(){return 0|this.uint32()},U.prototype.sint32=function(){var t=this.uint32();return t>>>1^-(1&t)},U.prototype.bool=function(){return 0!==this.uint32()},U.prototype.fixed32=function(){if(this.pos+4>this.len)throw Q(this,4);return g(this.buf,this.pos+=4)},U.prototype.sfixed32=function(){if(this.pos+4>this.len)throw Q(this,4);return 0|g(this.buf,this.pos+=4)},U.prototype.float=function(){if(this.pos+4>this.len)throw Q(this,4);var t=B.float.readFloatLE(this.buf,this.pos);return this.pos+=4,t},U.prototype.double=function(){if(this.pos+8>this.len)throw Q(this,4);var t=B.float.readDoubleLE(this.buf,this.pos);return this.pos+=8,t},U.prototype.bytes=function(){var t=this.uint32(),e=this.pos,n=this.pos+t;if(n>this.len)throw Q(this,t);return this.pos+=t,Array.isArray(this.buf)?this.buf.slice(e,n):e===n?new this.buf.constructor(0):this._slice.call(this.buf,e,n)},U.prototype.string=function(){var t=this.bytes();return F.read(t,0,t.length)},U.prototype.skip=function(t){if("number"==typeof t){if(this.pos+t>this.len)throw Q(this,t);this.pos+=t}else do{if(this.pos>=this.len)throw Q(this)}while(128&this.buf[this.pos++]);return this},U.prototype.skipType=function(t){switch(t){case 0:this.skip();break;case 1:this.skip(8);break;case 2:this.skip(this.uint32());break;case 3:for(;4!=(t=7&this.uint32());)this.skipType(t);break;case 5:this.skip(4);break;default:throw Error("invalid wire type "+t+" at offset "+this.pos)}return this},U._configure=function(t){n=t,U.create=l(),n._configure();var e=B.Long?"toLong":"toNumber";B.merge(U.prototype,{int64:function(){return c.call(this)[e](!1)},uint64:function(){return c.call(this)[e](!0)},sint64:function(){return c.call(this).zzDecode()[e](!1)},fixed64:function(){return d.call(this)[e](!0)},sfixed64:function(){return d.call(this)[e](!1)}})}}}),require_reader_buffer=__commonJS({"web/node_modules/protobufjs/src/reader_buffer.js"(t,e){e.exports=s;var n=require_reader();(s.prototype=Object.create(n.prototype)).constructor=s;var B=require_minimal();function s(t){n.call(this,t)}s._configure=function(){B.Buffer&&(s.prototype._slice=B.Buffer.prototype.slice)},s.prototype.string=function(){var t=this.uint32();return this.buf.utf8Slice?this.buf.utf8Slice(this.pos,this.pos=Math.min(this.pos+t,this.len)):this.buf.toString("utf-8",this.pos,this.pos=Math.min(this.pos+t,this.len))},s._configure()}}),require_service=__commonJS({"web/node_modules/protobufjs/src/rpc/service.js"(t,e){e.exports=B;var n=require_minimal();function B(t,e,B){if("function"!=typeof t)throw TypeError("rpcImpl must be a function");n.EventEmitter.call(this),this.rpcImpl=t,this.requestDelimited=Boolean(e),this.responseDelimited=Boolean(B)}(B.prototype=Object.create(n.EventEmitter.prototype)).constructor=B,B.prototype.rpcCall=function t(e,B,s,F,Q){if(!F)throw TypeError("request must be specified");var U=this;if(!Q)return n.asPromise(t,U,e,B,s,F);if(U.rpcImpl)try{return U.rpcImpl(e,B[U.requestDelimited?"encodeDelimited":"encode"](F).finish(),(function(t,n){if(t)return U.emit("error",t,e),Q(t);if(null!==n){if(!(n instanceof s))try{n=s[U.responseDelimited?"decodeDelimited":"decode"](n)}catch(t){return U.emit("error",t,e),Q(t)}return U.emit("data",n,e),Q(null,n)}U.end(!0)}))}catch(t){return U.emit("error",t,e),void setTimeout((function(){Q(t)}),0)}else setTimeout((function(){Q(Error("already ended"))}),0)},B.prototype.end=function(t){return this.rpcImpl&&(t||this.rpcImpl(null,null,null),this.rpcImpl=null,this.emit("end").off()),this}}}),require_rpc=__commonJS({"web/node_modules/protobufjs/src/rpc.js"(t){t.Service=require_service()}}),require_roots=__commonJS({"web/node_modules/protobufjs/src/roots.js"(t,e){e.exports={}}}),require_index_minimal=__commonJS({"web/node_modules/protobufjs/src/index-minimal.js"(t){var e=t;function n(){e.util._configure(),e.Writer._configure(e.BufferWriter),e.Reader._configure(e.BufferReader)}e.build="minimal",e.Writer=require_writer(),e.BufferWriter=require_writer_buffer(),e.Reader=require_reader(),e.BufferReader=require_reader_buffer(),e.util=require_minimal(),e.rpc=require_rpc(),e.roots=require_roots(),e.configure=n,n()}}),require_minimal2=__commonJS({"web/node_modules/protobufjs/minimal.js"(t,e){e.exports=require_index_minimal()}}),require_onnx=__commonJS({"web/lib/onnxjs/ort-schema/protobuf/onnx.js"(t,e){var n,B,s,F=require_minimal2(),Q=F.Reader,U=F.Writer,i=F.util,a=F.roots.default||(F.roots.default={});a.onnx=((s={}).Version=(n={},(B=Object.create(n))[n[0]="_START_VERSION"]=0,B[n[1]="IR_VERSION_2017_10_10"]=1,B[n[2]="IR_VERSION_2017_10_30"]=2,B[n[3]="IR_VERSION_2017_11_3"]=3,B[n[4]="IR_VERSION_2019_1_22"]=4,B[n[5]="IR_VERSION_2019_3_18"]=5,B[n[6]="IR_VERSION_2019_9_19"]=6,B[n[7]="IR_VERSION_2020_5_8"]=7,B[n[8]="IR_VERSION_2021_7_30"]=8,B[n[9]="IR_VERSION"]=9,B),s.AttributeProto=function(){function t(t){if(this.floats=[],this.ints=[],this.strings=[],this.tensors=[],this.graphs=[],this.sparseTensors=[],this.typeProtos=[],t)for(var e=Object.keys(t),n=0;n<e.length;++n)null!=t[e[n]]&&(this[e[n]]=t[e[n]])}return t.prototype.name="",t.prototype.refAttrName="",t.prototype.docString="",t.prototype.type=0,t.prototype.f=0,t.prototype.i=i.Long?i.Long.fromBits(0,0,!1):0,t.prototype.s=i.newBuffer([]),t.prototype.t=null,t.prototype.g=null,t.prototype.sparseTensor=null,t.prototype.tp=null,t.prototype.floats=i.emptyArray,t.prototype.ints=i.emptyArray,t.prototype.strings=i.emptyArray,t.prototype.tensors=i.emptyArray,t.prototype.graphs=i.emptyArray,t.prototype.sparseTensors=i.emptyArray,t.prototype.typeProtos=i.emptyArray,t.create=function(e){return new t(e)},t.encode=function(t,e){if(e||(e=U.create()),null!=t.name&&Object.hasOwnProperty.call(t,"name")&&e.uint32(10).string(t.name),null!=t.f&&Object.hasOwnProperty.call(t,"f")&&e.uint32(21).float(t.f),null!=t.i&&Object.hasOwnProperty.call(t,"i")&&e.uint32(24).int64(t.i),null!=t.s&&Object.hasOwnProperty.call(t,"s")&&e.uint32(34).bytes(t.s),null!=t.t&&Object.hasOwnProperty.call(t,"t")&&a.onnx.TensorProto.encode(t.t,e.uint32(42).fork()).ldelim(),null!=t.g&&Object.hasOwnProperty.call(t,"g")&&a.onnx.GraphProto.encode(t.g,e.uint32(50).fork()).ldelim(),null!=t.floats&&t.floats.length){e.uint32(58).fork();for(var n=0;n<t.floats.length;++n)e.float(t.floats[n]);e.ldelim()}if(null!=t.ints&&t.ints.length){for(e.uint32(66).fork(),n=0;n<t.ints.length;++n)e.int64(t.ints[n]);e.ldelim()}if(null!=t.strings&&t.strings.length)for(n=0;n<t.strings.length;++n)e.uint32(74).bytes(t.strings[n]);if(null!=t.tensors&&t.tensors.length)for(n=0;n<t.tensors.length;++n)a.onnx.TensorProto.encode(t.tensors[n],e.uint32(82).fork()).ldelim();if(null!=t.graphs&&t.graphs.length)for(n=0;n<t.graphs.length;++n)a.onnx.GraphProto.encode(t.graphs[n],e.uint32(90).fork()).ldelim();if(null!=t.docString&&Object.hasOwnProperty.call(t,"docString")&&e.uint32(106).string(t.docString),null!=t.tp&&Object.hasOwnProperty.call(t,"tp")&&a.onnx.TypeProto.encode(t.tp,e.uint32(114).fork()).ldelim(),null!=t.typeProtos&&t.typeProtos.length)for(n=0;n<t.typeProtos.length;++n)a.onnx.TypeProto.encode(t.typeProtos[n],e.uint32(122).fork()).ldelim();if(null!=t.type&&Object.hasOwnProperty.call(t,"type")&&e.uint32(160).int32(t.type),null!=t.refAttrName&&Object.hasOwnProperty.call(t,"refAttrName")&&e.uint32(170).string(t.refAttrName),null!=t.sparseTensor&&Object.hasOwnProperty.call(t,"sparseTensor")&&a.onnx.SparseTensorProto.encode(t.sparseTensor,e.uint32(178).fork()).ldelim(),null!=t.sparseTensors&&t.sparseTensors.length)for(n=0;n<t.sparseTensors.length;++n)a.onnx.SparseTensorProto.encode(t.sparseTensors[n],e.uint32(186).fork()).ldelim();return e},t.encodeDelimited=function(t,e){return this.encode(t,e).ldelim()},t.decode=function(t,e){t instanceof Q||(t=Q.create(t));for(var n=void 0===e?t.len:t.pos+e,B=new a.onnx.AttributeProto;t.pos<n;){var s=t.uint32();switch(s>>>3){case 1:B.name=t.string();break;case 21:B.refAttrName=t.string();break;case 13:B.docString=t.string();break;case 20:B.type=t.int32();break;case 2:B.f=t.float();break;case 3:B.i=t.int64();break;case 4:B.s=t.bytes();break;case 5:B.t=a.onnx.TensorProto.decode(t,t.uint32());break;case 6:B.g=a.onnx.GraphProto.decode(t,t.uint32());break;case 22:B.sparseTensor=a.onnx.SparseTensorProto.decode(t,t.uint32());break;case 14:B.tp=a.onnx.TypeProto.decode(t,t.uint32());break;case 7:if(B.floats&&B.floats.length||(B.floats=[]),2==(7&s))for(var F=t.uint32()+t.pos;t.pos<F;)B.floats.push(t.float());else B.floats.push(t.float());break;case 8:if(B.ints&&B.ints.length||(B.ints=[]),2==(7&s))for(F=t.uint32()+t.pos;t.pos<F;)B.ints.push(t.int64());else B.ints.push(t.int64());break;case 9:B.strings&&B.strings.length||(B.strings=[]),B.strings.push(t.bytes());break;case 10:B.tensors&&B.tensors.length||(B.tensors=[]),B.tensors.push(a.onnx.TensorProto.decode(t,t.uint32()));break;case 11:B.graphs&&B.graphs.length||(B.graphs=[]),B.graphs.push(a.onnx.GraphProto.decode(t,t.uint32()));break;case 23:B.sparseTensors&&B.sparseTensors.length||(B.sparseTensors=[]),B.sparseTensors.push(a.onnx.SparseTensorProto.decode(t,t.uint32()));break;case 15:B.typeProtos&&B.typeProtos.length||(B.typeProtos=[]),B.typeProtos.push(a.onnx.TypeProto.decode(t,t.uint32()));break;default:t.skipType(7&s)}}return B},t.decodeDelimited=function(t){return t instanceof Q||(t=new Q(t)),this.decode(t,t.uint32())},t.verify=function(t){if("object"!=typeof t||null===t)return"object expected";if(null!=t.name&&t.hasOwnProperty("name")&&!i.isString(t.name))return"name: string expected";if(null!=t.refAttrName&&t.hasOwnProperty("refAttrName")&&!i.isString(t.refAttrName))return"refAttrName: string expected";if(null!=t.docString&&t.hasOwnProperty("docString")&&!i.isString(t.docString))return"docString: string expected";if(null!=t.type&&t.hasOwnProperty("type"))switch(t.type){default:return"type: enum value expected";case 0:case 1:case 2:case 3:case 4:case 5:case 11:case 13:case 6:case 7:case 8:case 9:case 10:case 12:case 14:}if(null!=t.f&&t.hasOwnProperty("f")&&"number"!=typeof t.f)return"f: number expected";if(null!=t.i&&t.hasOwnProperty("i")&&!(i.isInteger(t.i)||t.i&&i.isInteger(t.i.low)&&i.isInteger(t.i.high)))return"i: integer|Long expected";if(null!=t.s&&t.hasOwnProperty("s")&&!(t.s&&"number"==typeof t.s.length||i.isString(t.s)))return"s: buffer expected";if(null!=t.t&&t.hasOwnProperty("t")&&(n=a.onnx.TensorProto.verify(t.t)))return"t."+n;if(null!=t.g&&t.hasOwnProperty("g")&&(n=a.onnx.GraphProto.verify(t.g)))return"g."+n;if(null!=t.sparseTensor&&t.hasOwnProperty("sparseTensor")&&(n=a.onnx.SparseTensorProto.verify(t.sparseTensor)))return"sparseTensor."+n;if(null!=t.tp&&t.hasOwnProperty("tp")&&(n=a.onnx.TypeProto.verify(t.tp)))return"tp."+n;if(null!=t.floats&&t.hasOwnProperty("floats")){if(!Array.isArray(t.floats))return"floats: array expected";for(var e=0;e<t.floats.length;++e)if("number"!=typeof t.floats[e])return"floats: number[] expected"}if(null!=t.ints&&t.hasOwnProperty("ints")){if(!Array.isArray(t.ints))return"ints: array expected";for(e=0;e<t.ints.length;++e)if(!(i.isInteger(t.ints[e])||t.ints[e]&&i.isInteger(t.ints[e].low)&&i.isInteger(t.ints[e].high)))return"ints: integer|Long[] expected"}if(null!=t.strings&&t.hasOwnProperty("strings")){if(!Array.isArray(t.strings))return"strings: array expected";for(e=0;e<t.strings.length;++e)if(!(t.strings[e]&&"number"==typeof t.strings[e].length||i.isString(t.strings[e])))return"strings: buffer[] expected"}if(null!=t.tensors&&t.hasOwnProperty("tensors")){if(!Array.isArray(t.tensors))return"tensors: array expected";for(e=0;e<t.tensors.length;++e)if(n=a.onnx.TensorProto.verify(t.tensors[e]))return"tensors."+n}if(null!=t.graphs&&t.hasOwnProperty("graphs")){if(!Array.isArray(t.graphs))return"graphs: array expected";for(e=0;e<t.graphs.length;++e)if(n=a.onnx.GraphProto.verify(t.graphs[e]))return"graphs."+n}if(null!=t.sparseTensors&&t.hasOwnProperty("sparseTensors")){if(!Array.isArray(t.sparseTensors))return"sparseTensors: array expected";for(e=0;e<t.sparseTensors.length;++e)if(n=a.onnx.SparseTensorProto.verify(t.sparseTensors[e]))return"sparseTensors."+n}if(null!=t.typeProtos&&t.hasOwnProperty("typeProtos")){if(!Array.isArray(t.typeProtos))return"typeProtos: array expected";for(e=0;e<t.typeProtos.length;++e){var n;if(n=a.onnx.TypeProto.verify(t.typeProtos[e]))return"typeProtos."+n}}return null},t.fromObject=function(t){if(t instanceof a.onnx.AttributeProto)return t;var e=new a.onnx.AttributeProto;switch(null!=t.name&&(e.name=String(t.name)),null!=t.refAttrName&&(e.refAttrName=String(t.refAttrName)),null!=t.docString&&(e.docString=String(t.docString)),t.type){default:if("number"==typeof t.type){e.type=t.type;break}break;case"UNDEFINED":case 0:e.type=0;break;case"FLOAT":case 1:e.type=1;break;case"INT":case 2:e.type=2;break;case"STRING":case 3:e.type=3;break;case"TENSOR":case 4:e.type=4;break;case"GRAPH":case 5:e.type=5;break;case"SPARSE_TENSOR":case 11:e.type=11;break;case"TYPE_PROTO":case 13:e.type=13;break;case"FLOATS":case 6:e.type=6;break;case"INTS":case 7:e.type=7;break;case"STRINGS":case 8:e.type=8;break;case"TENSORS":case 9:e.type=9;break;case"GRAPHS":case 10:e.type=10;break;case"SPARSE_TENSORS":case 12:e.type=12;break;case"TYPE_PROTOS":case 14:e.type=14}if(null!=t.f&&(e.f=Number(t.f)),null!=t.i&&(i.Long?(e.i=i.Long.fromValue(t.i)).unsigned=!1:"string"==typeof t.i?e.i=parseInt(t.i,10):"number"==typeof t.i?e.i=t.i:"object"==typeof t.i&&(e.i=new i.LongBits(t.i.low>>>0,t.i.high>>>0).toNumber())),null!=t.s&&("string"==typeof t.s?i.base64.decode(t.s,e.s=i.newBuffer(i.base64.length(t.s)),0):t.s.length>=0&&(e.s=t.s)),null!=t.t){if("object"!=typeof t.t)throw TypeError(".onnx.AttributeProto.t: object expected");e.t=a.onnx.TensorProto.fromObject(t.t)}if(null!=t.g){if("object"!=typeof t.g)throw TypeError(".onnx.AttributeProto.g: object expected");e.g=a.onnx.GraphProto.fromObject(t.g)}if(null!=t.sparseTensor){if("object"!=typeof t.sparseTensor)throw TypeError(".onnx.AttributeProto.sparseTensor: object expected");e.sparseTensor=a.onnx.SparseTensorProto.fromObject(t.sparseTensor)}if(null!=t.tp){if("object"!=typeof t.tp)throw TypeError(".onnx.AttributeProto.tp: object expected");e.tp=a.onnx.TypeProto.fromObject(t.tp)}if(t.floats){if(!Array.isArray(t.floats))throw TypeError(".onnx.AttributeProto.floats: array expected");e.floats=[];for(var n=0;n<t.floats.length;++n)e.floats[n]=Number(t.floats[n])}if(t.ints){if(!Array.isArray(t.ints))throw TypeError(".onnx.AttributeProto.ints: array expected");for(e.ints=[],n=0;n<t.ints.length;++n)i.Long?(e.ints[n]=i.Long.fromValue(t.ints[n])).unsigned=!1:"string"==typeof t.ints[n]?e.ints[n]=parseInt(t.ints[n],10):"number"==typeof t.ints[n]?e.ints[n]=t.ints[n]:"object"==typeof t.ints[n]&&(e.ints[n]=new i.LongBits(t.ints[n].low>>>0,t.ints[n].high>>>0).toNumber())}if(t.strings){if(!Array.isArray(t.strings))throw TypeError(".onnx.AttributeProto.strings: array expected");for(e.strings=[],n=0;n<t.strings.length;++n)"string"==typeof t.strings[n]?i.base64.decode(t.strings[n],e.strings[n]=i.newBuffer(i.base64.length(t.strings[n])),0):t.strings[n].length>=0&&(e.strings[n]=t.strings[n])}if(t.tensors){if(!Array.isArray(t.tensors))throw TypeError(".onnx.AttributeProto.tensors: array expected");for(e.tensors=[],n=0;n<t.tensors.length;++n){if("object"!=typeof t.tensors[n])throw TypeError(".onnx.AttributeProto.tensors: object expected");e.tensors[n]=a.onnx.TensorProto.fromObject(t.tensors[n])}}if(t.graphs){if(!Array.isArray(t.graphs))throw TypeError(".onnx.AttributeProto.graphs: array expected");for(e.graphs=[],n=0;n<t.graphs.length;++n){if("object"!=typeof t.graphs[n])throw TypeError(".onnx.AttributeProto.graphs: object expected");e.graphs[n]=a.onnx.GraphProto.fromObject(t.graphs[n])}}if(t.sparseTensors){if(!Array.isArray(t.sparseTensors))throw TypeError(".onnx.AttributeProto.sparseTensors: array expected");for(e.sparseTensors=[],n=0;n<t.sparseTensors.length;++n){if("object"!=typeof t.sparseTensors[n])throw TypeError(".onnx.AttributeProto.sparseTensors: object expected");e.sparseTensors[n]=a.onnx.SparseTensorProto.fromObject(t.sparseTensors[n])}}if(t.typeProtos){if(!Array.isArray(t.typeProtos))throw TypeError(".onnx.AttributeProto.typeProtos: array expected");for(e.typeProtos=[],n=0;n<t.typeProtos.length;++n){if("object"!=typeof t.typeProtos[n])throw TypeError(".onnx.AttributeProto.typeProtos: object expected");e.typeProtos[n]=a.onnx.TypeProto.fromObject(t.typeProtos[n])}}return e},t.toObject=function(t,e){e||(e={});var n={};if((e.arrays||e.defaults)&&(n.floats=[],n.ints=[],n.strings=[],n.tensors=[],n.graphs=[],n.typeProtos=[],n.sparseTensors=[]),e.defaults){if(n.name="",n.f=0,i.Long){var B=new i.Long(0,0,!1);n.i=e.longs===String?B.toString():e.longs===Number?B.toNumber():B}else n.i=e.longs===String?"0":0;e.bytes===String?n.s="":(n.s=[],e.bytes!==Array&&(n.s=i.newBuffer(n.s))),n.t=null,n.g=null,n.docString="",n.tp=null,n.type=e.enums===String?"UNDEFINED":0,n.refAttrName="",n.sparseTensor=null}if(null!=t.name&&t.hasOwnProperty("name")&&(n.name=t.name),null!=t.f&&t.hasOwnProperty("f")&&(n.f=e.json&&!isFinite(t.f)?String(t.f):t.f),null!=t.i&&t.hasOwnProperty("i")&&("number"==typeof t.i?n.i=e.longs===String?String(t.i):t.i:n.i=e.longs===String?i.Long.prototype.toString.call(t.i):e.longs===Number?new i.LongBits(t.i.low>>>0,t.i.high>>>0).toNumber():t.i),null!=t.s&&t.hasOwnProperty("s")&&(n.s=e.bytes===String?i.base64.encode(t.s,0,t.s.length):e.bytes===Array?Array.prototype.slice.call(t.s):t.s),null!=t.t&&t.hasOwnProperty("t")&&(n.t=a.onnx.TensorProto.toObject(t.t,e)),null!=t.g&&t.hasOwnProperty("g")&&(n.g=a.onnx.GraphProto.toObject(t.g,e)),t.floats&&t.floats.length){n.floats=[];for(var s=0;s<t.floats.length;++s)n.floats[s]=e.json&&!isFinite(t.floats[s])?String(t.floats[s]):t.floats[s]}if(t.ints&&t.ints.length)for(n.ints=[],s=0;s<t.ints.length;++s)"number"==typeof t.ints[s]?n.ints[s]=e.longs===String?String(t.ints[s]):t.ints[s]:n.ints[s]=e.longs===String?i.Long.prototype.toString.call(t.ints[s]):e.longs===Number?new i.LongBits(t.ints[s].low>>>0,t.ints[s].high>>>0).toNumber():t.ints[s];if(t.strings&&t.strings.length)for(n.strings=[],s=0;s<t.strings.length;++s)n.strings[s]=e.bytes===String?i.base64.encode(t.strings[s],0,t.strings[s].length):e.bytes===Array?Array.prototype.slice.call(t.strings[s]):t.strings[s];if(t.tensors&&t.tensors.length)for(n.tensors=[],s=0;s<t.tensors.length;++s)n.tensors[s]=a.onnx.TensorProto.toObject(t.tensors[s],e);if(t.graphs&&t.graphs.length)for(n.graphs=[],s=0;s<t.graphs.length;++s)n.graphs[s]=a.onnx.GraphProto.toObject(t.graphs[s],e);if(null!=t.docString&&t.hasOwnProperty("docString")&&(n.docString=t.docString),null!=t.tp&&t.hasOwnProperty("tp")&&(n.tp=a.onnx.TypeProto.toObject(t.tp,e)),t.typeProtos&&t.typeProtos.length)for(n.typeProtos=[],s=0;s<t.typeProtos.length;++s)n.typeProtos[s]=a.onnx.TypeProto.toObject(t.typeProtos[s],e);if(null!=t.type&&t.hasOwnProperty("type")&&(n.type=e.enums===String?void 0===a.onnx.AttributeProto.AttributeType[t.type]?t.type:a.onnx.AttributeProto.AttributeType[t.type]:t.type),null!=t.refAttrName&&t.hasOwnProperty("refAttrName")&&(n.refAttrName=t.refAttrName),null!=t.sparseTensor&&t.hasOwnProperty("sparseTensor")&&(n.sparseTensor=a.onnx.SparseTensorProto.toObject(t.sparseTensor,e)),t.sparseTensors&&t.sparseTensors.length)for(n.sparseTensors=[],s=0;s<t.sparseTensors.length;++s)n.sparseTensors[s]=a.onnx.SparseTensorProto.toObject(t.sparseTensors[s],e);return n},t.prototype.toJSON=function(){return this.constructor.toObject(this,F.util.toJSONOptions)},t.getTypeUrl=function(t){return void 0===t&&(t="type.googleapis.com"),t+"/onnx.AttributeProto"},t.AttributeType=function(){var t={},e=Object.create(t);return e[t[0]="UNDEFINED"]=0,e[t[1]="FLOAT"]=1,e[t[2]="INT"]=2,e[t[3]="STRING"]=3,e[t[4]="TENSOR"]=4,e[t[5]="GRAPH"]=5,e[t[11]="SPARSE_TENSOR"]=11,e[t[13]="TYPE_PROTO"]=13,e[t[6]="FLOATS"]=6,e[t[7]="INTS"]=7,e[t[8]="STRINGS"]=8,e[t[9]="TENSORS"]=9,e[t[10]="GRAPHS"]=10,e[t[12]="SPARSE_TENSORS"]=12,e[t[14]="TYPE_PROTOS"]=14,e}(),t}(),s.ValueInfoProto=function(){function t(t){if(t)for(var e=Object.keys(t),n=0;n<e.length;++n)null!=t[e[n]]&&(this[e[n]]=t[e[n]])}return t.prototype.name="",t.prototype.type=null,t.prototype.docString="",t.create=function(e){return new t(e)},t.encode=function(t,e){return e||(e=U.create()),null!=t.name&&Object.hasOwnProperty.call(t,"name")&&e.uint32(10).string(t.name),null!=t.type&&Object.hasOwnProperty.call(t,"type")&&a.onnx.TypeProto.encode(t.type,e.uint32(18).fork()).ldelim(),null!=t.docString&&Object.hasOwnProperty.call(t,"docString")&&e.uint32(26).string(t.docString),e},t.encodeDelimited=function(t,e){return this.encode(t,e).ldelim()},t.decode=function(t,e){t instanceof Q||(t=Q.create(t));for(var n=void 0===e?t.len:t.pos+e,B=new a.onnx.ValueInfoProto;t.pos<n;){var s=t.uint32();switch(s>>>3){case 1:B.name=t.string();break;case 2:B.type=a.onnx.TypeProto.decode(t,t.uint32());break;case 3:B.docString=t.string();break;default:t.skipType(7&s)}}return B},t.decodeDelimited=function(t){return t instanceof Q||(t=new Q(t)),this.decode(t,t.uint32())},t.verify=function(t){if("object"!=typeof t||null===t)return"object expected";if(null!=t.name&&t.hasOwnProperty("name")&&!i.isString(t.name))return"name: string expected";if(null!=t.type&&t.hasOwnProperty("type")){var e=a.onnx.TypeProto.verify(t.type);if(e)return"type."+e}return null!=t.docString&&t.hasOwnProperty("docString")&&!i.isString(t.docString)?"docString: string expected":null},t.fromObject=function(t){if(t instanceof a.onnx.ValueInfoProto)return t;var e=new a.onnx.ValueInfoProto;if(null!=t.name&&(e.name=String(t.name)),null!=t.type){if("object"!=typeof t.type)throw TypeError(".onnx.ValueInfoProto.type: object expected");e.type=a.onnx.TypeProto.fromObject(t.type)}return null!=t.docString&&(e.docString=String(t.docString)),e},t.toObject=function(t,e){e||(e={});var n={};return e.defaults&&(n.name="",n.type=null,n.docString=""),null!=t.name&&t.hasOwnProperty("name")&&(n.name=t.name),null!=t.type&&t.hasOwnProperty("type")&&(n.type=a.onnx.TypeProto.toObject(t.type,e)),null!=t.docString&&t.hasOwnProperty("docString")&&(n.docString=t.docString),n},t.prototype.toJSON=function(){return this.constructor.toObject(this,F.util.toJSONOptions)},t.getTypeUrl=function(t){return void 0===t&&(t="type.googleapis.com"),t+"/onnx.ValueInfoProto"},t}(),s.NodeProto=function(){function t(t){if(this.input=[],this.output=[],this.attribute=[],t)for(var e=Object.keys(t),n=0;n<e.length;++n)null!=t[e[n]]&&(this[e[n]]=t[e[n]])}return t.prototype.input=i.emptyArray,t.prototype.output=i.emptyArray,t.prototype.name="",t.prototype.opType="",t.prototype.domain="",t.prototype.attribute=i.emptyArray,t.prototype.docString="",t.create=function(e){return new t(e)},t.encode=function(t,e){if(e||(e=U.create()),null!=t.input&&t.input.length)for(var n=0;n<t.input.length;++n)e.uint32(10).string(t.input[n]);if(null!=t.output&&t.output.length)for(n=0;n<t.output.length;++n)e.uint32(18).string(t.output[n]);if(null!=t.name&&Object.hasOwnProperty.call(t,"name")&&e.uint32(26).string(t.name),null!=t.opType&&Object.hasOwnProperty.call(t,"opType")&&e.uint32(34).string(t.opType),null!=t.attribute&&t.attribute.length)for(n=0;n<t.attribute.length;++n)a.onnx.AttributeProto.encode(t.attribute[n],e.uint32(42).fork()).ldelim();return null!=t.docString&&Object.hasOwnProperty.call(t,"docString")&&e.uint32(50).string(t.docString),null!=t.domain&&Object.hasOwnProperty.call(t,"domain")&&e.uint32(58).string(t.domain),e},t.encodeDelimited=function(t,e){return this.encode(t,e).ldelim()},t.decode=function(t,e){t instanceof Q||(t=Q.create(t));for(var n=void 0===e?t.len:t.pos+e,B=new a.onnx.NodeProto;t.pos<n;){var s=t.uint32();switch(s>>>3){case 1:B.input&&B.input.length||(B.input=[]),B.input.push(t.string());break;case 2:B.output&&B.output.length||(B.output=[]),B.output.push(t.string());break;case 3:B.name=t.string();break;case 4:B.opType=t.string();break;case 7:B.domain=t.string();break;case 5:B.attribute&&B.attribute.length||(B.attribute=[]),B.attribute.push(a.onnx.AttributeProto.decode(t,t.uint32()));break;case 6:B.docString=t.string();break;default:t.skipType(7&s)}}return B},t.decodeDelimited=function(t){return t instanceof Q||(t=new Q(t)),this.decode(t,t.uint32())},t.verify=function(t){if("object"!=typeof t||null===t)return"object expected";if(null!=t.input&&t.hasOwnProperty("input")){if(!Array.isArray(t.input))return"input: array expected";for(var e=0;e<t.input.length;++e)if(!i.isString(t.input[e]))return"input: string[] expected"}if(null!=t.output&&t.hasOwnProperty("output")){if(!Array.isArray(t.output))return"output: array expected";for(e=0;e<t.output.length;++e)if(!i.isString(t.output[e]))return"output: string[] expected"}if(null!=t.name&&t.hasOwnProperty("name")&&!i.isString(t.name))return"name: string expected";if(null!=t.opType&&t.hasOwnProperty("opType")&&!i.isString(t.opType))return"opType: string expected";if(null!=t.domain&&t.hasOwnProperty("domain")&&!i.isString(t.domain))return"domain: string expected";if(null!=t.attribute&&t.hasOwnProperty("attribute")){if(!Array.isArray(t.attribute))return"attribute: array expected";for(e=0;e<t.attribute.length;++e){var n=a.onnx.AttributeProto.verify(t.attribute[e]);if(n)return"attribute."+n}}return null!=t.docString&&t.hasOwnProperty("docString")&&!i.isString(t.docString)?"docString: string expected":null},t.fromObject=function(t){if(t instanceof a.onnx.NodeProto)return t;var e=new a.onnx.NodeProto;if(t.input){if(!Array.isArray(t.input))throw TypeError(".onnx.NodeProto.input: array expected");e.input=[];for(var n=0;n<t.input.length;++n)e.input[n]=String(t.input[n])}if(t.output){if(!Array.isArray(t.output))throw TypeError(".onnx.NodeProto.output: array expected");for(e.output=[],n=0;n<t.output.length;++n)e.output[n]=String(t.output[n])}if(null!=t.name&&(e.name=String(t.name)),null!=t.opType&&(e.opType=String(t.opType)),null!=t.domain&&(e.domain=String(t.domain)),t.attribute){if(!Array.isArray(t.attribute))throw TypeError(".onnx.NodeProto.attribute: array expected");for(e.attribute=[],n=0;n<t.attribute.length;++n){if("object"!=typeof t.attribute[n])throw TypeError(".onnx.NodeProto.attribute: object expected");e.attribute[n]=a.onnx.AttributeProto.fromObject(t.attribute[n])}}return null!=t.docString&&(e.docString=String(t.docString)),e},t.toObject=function(t,e){e||(e={});var n={};if((e.arrays||e.defaults)&&(n.input=[],n.output=[],n.attribute=[]),e.defaults&&(n.name="",n.opType="",n.docString="",n.domain=""),t.input&&t.input.length){n.input=[];for(var B=0;B<t.input.length;++B)n.input[B]=t.input[B]}if(t.output&&t.output.length)for(n.output=[],B=0;B<t.output.length;++B)n.output[B]=t.output[B];if(null!=t.name&&t.hasOwnProperty("name")&&(n.name=t.name),null!=t.opType&&t.hasOwnProperty("opType")&&(n.opType=t.opType),t.attribute&&t.attribute.length)for(n.attribute=[],B=0;B<t.attribute.length;++B)n.attribute[B]=a.onnx.AttributeProto.toObject(t.attribute[B],e);return null!=t.docString&&t.hasOwnProperty("docString")&&(n.docString=t.docString),null!=t.domain&&t.hasOwnProperty("domain")&&(n.domain=t.domain),n},t.prototype.toJSON=function(){return this.constructor.toObject(this,F.util.toJSONOptions)},t.getTypeUrl=function(t){return void 0===t&&(t="type.googleapis.com"),t+"/onnx.NodeProto"},t}(),s.TrainingInfoProto=function(){function t(t){if(this.initializationBinding=[],this.updateBinding=[],t)for(var e=Object.keys(t),n=0;n<e.length;++n)null!=t[e[n]]&&(this[e[n]]=t[e[n]])}return t.prototype.initialization=null,t.prototype.algorithm=null,t.prototype.initializationBinding=i.emptyArray,t.prototype.updateBinding=i.emptyArray,t.create=function(e){return new t(e)},t.encode=function(t,e){if(e||(e=U.create()),null!=t.initialization&&Object.hasOwnProperty.call(t,"initialization")&&a.onnx.GraphProto.encode(t.initialization,e.uint32(10).fork()).ldelim(),null!=t.algorithm&&Object.hasOwnProperty.call(t,"algorithm")&&a.onnx.GraphProto.encode(t.algorithm,e.uint32(18).fork()).ldelim(),null!=t.initializationBinding&&t.initializationBinding.length)for(var n=0;n<t.initializationBinding.length;++n)a.onnx.StringStringEntryProto.encode(t.initializationBinding[n],e.uint32(26).fork()).ldelim();if(null!=t.updateBinding&&t.updateBinding.length)for(n=0;n<t.updateBinding.length;++n)a.onnx.StringStringEntryProto.encode(t.updateBinding[n],e.uint32(34).fork()).ldelim();return e},t.encodeDelimited=function(t,e){return this.encode(t,e).ldelim()},t.decode=function(t,e){t instanceof Q||(t=Q.create(t));for(var n=void 0===e?t.len:t.pos+e,B=new a.onnx.TrainingInfoProto;t.pos<n;){var s=t.uint32();switch(s>>>3){case 1:B.initialization=a.onnx.GraphProto.decode(t,t.uint32());break;case 2:B.algorithm=a.onnx.GraphProto.decode(t,t.uint32());break;case 3:B.initializationBinding&&B.initializationBinding.length||(B.initializationBinding=[]),B.initializationBinding.push(a.onnx.StringStringEntryProto.decode(t,t.uint32()));break;case 4:B.updateBinding&&B.updateBinding.length||(B.updateBinding=[]),B.updateBinding.push(a.onnx.StringStringEntryProto.decode(t,t.uint32()));break;default:t.skipType(7&s)}}return B},t.decodeDelimited=function(t){return t instanceof Q||(t=new Q(t)),this.decode(t,t.uint32())},t.verify=function(t){if("object"!=typeof t||null===t)return"object expected";if(null!=t.initialization&&t.hasOwnProperty("initialization")&&(n=a.onnx.GraphProto.verify(t.initialization)))return"initialization."+n;if(null!=t.algorithm&&t.hasOwnProperty("algorithm")&&(n=a.onnx.GraphProto.verify(t.algorithm)))return"algorithm."+n;if(null!=t.initializationBinding&&t.hasOwnProperty("initializationBinding")){if(!Array.isArray(t.initializationBinding))return"initializationBinding: array expected";for(var e=0;e<t.initializationBinding.length;++e)if(n=a.onnx.StringStringEntryProto.verify(t.initializationBinding[e]))return"initializationBinding."+n}if(null!=t.updateBinding&&t.hasOwnProperty("updateBinding")){if(!Array.isArray(t.updateBinding))return"updateBinding: array expected";for(e=0;e<t.updateBinding.length;++e){var n;if(n=a.onnx.StringStringEntryProto.verify(t.updateBinding[e]))return"updateBinding."+n}}return null},t.fromObject=function(t){if(t instanceof a.onnx.TrainingInfoProto)return t;var e=new a.onnx.TrainingInfoProto;if(null!=t.initialization){if("object"!=typeof t.initialization)throw TypeError(".onnx.TrainingInfoProto.initialization: object expected");e.initialization=a.onnx.GraphProto.fromObject(t.initialization)}if(null!=t.algorithm){if("object"!=typeof t.algorithm)throw TypeError(".onnx.TrainingInfoProto.algorithm: object expected");e.algorithm=a.onnx.GraphProto.fromObject(t.algorithm)}if(t.initializationBinding){if(!Array.isArray(t.initializationBinding))throw TypeError(".onnx.TrainingInfoProto.initializationBinding: array expected");e.initializationBinding=[];for(var n=0;n<t.initializationBinding.length;++n){if("object"!=typeof t.initializationBinding[n])throw TypeError(".onnx.TrainingInfoProto.initializationBinding: object expected");e.initializationBinding[n]=a.onnx.StringStringEntryProto.fromObject(t.initializationBinding[n])}}if(t.updateBinding){if(!Array.isArray(t.updateBinding))throw TypeError(".onnx.TrainingInfoProto.updateBinding: array expected");for(e.updateBinding=[],n=0;n<t.updateBinding.length;++n){if("object"!=typeof t.updateBinding[n])throw TypeError(".onnx.TrainingInfoProto.updateBinding: object expected");e.updateBinding[n]=a.onnx.StringStringEntryProto.fromObject(t.updateBinding[n])}}return e},t.toObject=function(t,e){e||(e={});var n={};if((e.arrays||e.defaults)&&(n.initializationBinding=[],n.updateBinding=[]),e.defaults&&(n.initialization=null,n.algorithm=null),null!=t.initialization&&t.hasOwnProperty("initialization")&&(n.initialization=a.onnx.GraphProto.toObject(t.initialization,e)),null!=t.algorithm&&t.hasOwnProperty("algorithm")&&(n.algorithm=a.onnx.GraphProto.toObject(t.algorithm,e)),t.initializationBinding&&t.initializationBinding.length){n.initializationBinding=[];for(var B=0;B<t.initializationBinding.length;++B)n.initializationBinding[B]=a.onnx.StringStringEntryProto.toObject(t.initializationBinding[B],e)}if(t.updateBinding&&t.updateBinding.length)for(n.updateBinding=[],B=0;B<t.updateBinding.length;++B)n.updateBinding[B]=a.onnx.StringStringEntryProto.toObject(t.updateBinding[B],e);return n},t.prototype.toJSON=function(){return this.constructor.toObject(this,F.util.toJSONOptions)},t.getTypeUrl=function(t){return void 0===t&&(t="type.googleapis.com"),t+"/onnx.TrainingInfoProto"},t}(),s.ModelProto=function(){function t(t){if(this.opsetImport=[],this.metadataProps=[],this.trainingInfo=[],this.functions=[],t)for(var e=Object.keys(t),n=0;n<e.length;++n)null!=t[e[n]]&&(this[e[n]]=t[e[n]])}return t.prototype.irVersion=i.Long?i.Long.fromBits(0,0,!1):0,t.prototype.opsetImport=i.emptyArray,t.prototype.producerName="",t.prototype.producerVersion="",t.prototype.domain="",t.prototype.modelVersion=i.Long?i.Long.fromBits(0,0,!1):0,t.prototype.docString="",t.prototype.graph=null,t.prototype.metadataProps=i.emptyArray,t.prototype.trainingInfo=i.emptyArray,t.prototype.functions=i.emptyArray,t.create=function(e){return new t(e)},t.encode=function(t,e){if(e||(e=U.create()),null!=t.irVersion&&Object.hasOwnProperty.call(t,"irVersion")&&e.uint32(8).int64(t.irVersion),null!=t.producerName&&Object.hasOwnProperty.call(t,"producerName")&&e.uint32(18).string(t.producerName),null!=t.producerVersion&&Object.hasOwnProperty.call(t,"producerVersion")&&e.uint32(26).string(t.producerVersion),null!=t.domain&&Object.hasOwnProperty.call(t,"domain")&&e.uint32(34).string(t.domain),null!=t.modelVersion&&Object.hasOwnProperty.call(t,"modelVersion")&&e.uint32(40).int64(t.modelVersion),null!=t.docString&&Object.hasOwnProperty.call(t,"docString")&&e.uint32(50).string(t.docString),null!=t.graph&&Object.hasOwnProperty.call(t,"graph")&&a.onnx.GraphProto.encode(t.graph,e.uint32(58).fork()).ldelim(),null!=t.opsetImport&&t.opsetImport.length)for(var n=0;n<t.opsetImport.length;++n)a.onnx.OperatorSetIdProto.encode(t.opsetImport[n],e.uint32(66).fork()).ldelim();if(null!=t.metadataProps&&t.metadataProps.length)for(n=0;n<t.metadataProps.length;++n)a.onnx.StringStringEntryProto.encode(t.metadataProps[n],e.uint32(114).fork()).ldelim();if(null!=t.trainingInfo&&t.trainingInfo.length)for(n=0;n<t.trainingInfo.length;++n)a.onnx.TrainingInfoProto.encode(t.trainingInfo[n],e.uint32(162).fork()).ldelim();if(null!=t.functions&&t.functions.length)for(n=0;n<t.functions.length;++n)a.onnx.FunctionProto.encode(t.functions[n],e.uint32(202).fork()).ldelim();return e},t.encodeDelimited=function(t,e){return this.encode(t,e).ldelim()},t.decode=function(t,e){t instanceof Q||(t=Q.create(t));for(var n=void 0===e?t.len:t.pos+e,B=new a.onnx.ModelProto;t.pos<n;){var s=t.uint32();switch(s>>>3){case 1:B.irVersion=t.int64();break;case 8:B.opsetImport&&B.opsetImport.length||(B.opsetImport=[]),B.opsetImport.push(a.onnx.OperatorSetIdProto.decode(t,t.uint32()));break;case 2:B.producerName=t.string();break;case 3:B.producerVersion=t.string();break;case 4:B.domain=t.string();break;case 5:B.modelVersion=t.int64();break;case 6:B.docString=t.string();break;case 7:B.graph=a.onnx.GraphProto.decode(t,t.uint32());break;case 14:B.metadataProps&&B.metadataProps.length||(B.metadataProps=[]),B.metadataProps.push(a.onnx.StringStringEntryProto.decode(t,t.uint32()));break;case 20:B.trainingInfo&&B.trainingInfo.length||(B.trainingInfo=[]),B.trainingInfo.push(a.onnx.TrainingInfoProto.decode(t,t.uint32()));break;case 25:B.functions&&B.functions.length||(B.functions=[]),B.functions.push(a.onnx.FunctionProto.decode(t,t.uint32()));break;default:t.skipType(7&s)}}return B},t.decodeDelimited=function(t){return t instanceof Q||(t=new Q(t)),this.decode(t,t.uint32())},t.verify=function(t){if("object"!=typeof t||null===t)return"object expected";if(null!=t.irVersion&&t.hasOwnProperty("irVersion")&&!(i.isInteger(t.irVersion)||t.irVersion&&i.isInteger(t.irVersion.low)&&i.isInteger(t.irVersion.high)))return"irVersion: integer|Long expected";if(null!=t.opsetImport&&t.hasOwnProperty("opsetImport")){if(!Array.isArray(t.opsetImport))return"opsetImport: array expected";for(var e=0;e<t.opsetImport.length;++e)if(n=a.onnx.OperatorSetIdProto.verify(t.opsetImport[e]))return"opsetImport."+n}if(null!=t.producerName&&t.hasOwnProperty("producerName")&&!i.isString(t.producerName))return"producerName: string expected";if(null!=t.producerVersion&&t.hasOwnProperty("producerVersion")&&!i.isString(t.producerVersion))return"producerVersion: string expected";if(null!=t.domain&&t.hasOwnProperty("domain")&&!i.isString(t.domain))return"domain: string expected";if(null!=t.modelVersion&&t.hasOwnProperty("modelVersion")&&!(i.isInteger(t.modelVersion)||t.modelVersion&&i.isInteger(t.modelVersion.low)&&i.isInteger(t.modelVersion.high)))return"modelVersion: integer|Long expected";if(null!=t.docString&&t.hasOwnProperty("docString")&&!i.isString(t.docString))return"docString: string expected";if(null!=t.graph&&t.hasOwnProperty("graph")&&(n=a.onnx.GraphProto.verify(t.graph)))return"graph."+n;if(null!=t.metadataProps&&t.hasOwnProperty("metadataProps")){if(!Array.isArray(t.metadataProps))return"metadataProps: array expected";for(e=0;e<t.metadataProps.length;++e)if(n=a.onnx.StringStringEntryProto.verify(t.metadataProps[e]))return"metadataProps."+n}if(null!=t.trainingInfo&&t.hasOwnProperty("trainingInfo")){if(!Array.isArray(t.trainingInfo))return"trainingInfo: array expected";for(e=0;e<t.trainingInfo.length;++e)if(n=a.onnx.TrainingInfoProto.verify(t.trainingInfo[e]))return"trainingInfo."+n}if(null!=t.functions&&t.hasOwnProperty("functions")){if(!Array.isArray(t.functions))return"functions: array expected";for(e=0;e<t.functions.length;++e){var n;if(n=a.onnx.FunctionProto.verify(t.functions[e]))return"functions."+n}}return null},t.fromObject=function(t){if(t instanceof a.onnx.ModelProto)return t;var e=new a.onnx.ModelProto;if(null!=t.irVersion&&(i.Long?(e.irVersion=i.Long.fromValue(t.irVersion)).unsigned=!1:"string"==typeof t.irVersion?e.irVersion=parseInt(t.irVersion,10):"number"==typeof t.irVersion?e.irVersion=t.irVersion:"object"==typeof t.irVersion&&(e.irVersion=new i.LongBits(t.irVersion.low>>>0,t.irVersion.high>>>0).toNumber())),t.opsetImport){if(!Array.isArray(t.opsetImport))throw TypeError(".onnx.ModelProto.opsetImport: array expected");e.opsetImport=[];for(var n=0;n<t.opsetImport.length;++n){if("object"!=typeof t.opsetImport[n])throw TypeError(".onnx.ModelProto.opsetImport: object expected");e.opsetImport[n]=a.onnx.OperatorSetIdProto.fromObject(t.opsetImport[n])}}if(null!=t.producerName&&(e.producerName=String(t.producerName)),null!=t.producerVersion&&(e.producerVersion=String(t.producerVersion)),null!=t.domain&&(e.domain=String(t.domain)),null!=t.modelVersion&&(i.Long?(e.modelVersion=i.Long.fromValue(t.modelVersion)).unsigned=!1:"string"==typeof t.modelVersion?e.modelVersion=parseInt(t.modelVersion,10):"number"==typeof t.modelVersion?e.modelVersion=t.modelVersion:"object"==typeof t.modelVersion&&(e.modelVersion=new i.LongBits(t.modelVersion.low>>>0,t.modelVersion.high>>>0).toNumber())),null!=t.docString&&(e.docString=String(t.docString)),null!=t.graph){if("object"!=typeof t.graph)throw TypeError(".onnx.ModelProto.graph: object expected");e.graph=a.onnx.GraphProto.fromObject(t.graph)}if(t.metadataProps){if(!Array.isArray(t.metadataProps))throw TypeError(".onnx.ModelProto.metadataProps: array expected");for(e.metadataProps=[],n=0;n<t.metadataProps.length;++n){if("object"!=typeof t.metadataProps[n])throw TypeError(".onnx.ModelProto.metadataProps: object expected");e.metadataProps[n]=a.onnx.StringStringEntryProto.fromObject(t.metadataProps[n])}}if(t.trainingInfo){if(!Array.isArray(t.trainingInfo))throw TypeError(".onnx.ModelProto.trainingInfo: array expected");for(e.trainingInfo=[],n=0;n<t.trainingInfo.length;++n){if("object"!=typeof t.trainingInfo[n])throw TypeError(".onnx.ModelProto.trainingInfo: object expected");e.trainingInfo[n]=a.onnx.TrainingInfoProto.fromObject(t.trainingInfo[n])}}if(t.functions){if(!Array.isArray(t.functions))throw TypeError(".onnx.ModelProto.functions: array expected");for(e.functions=[],n=0;n<t.functions.length;++n){if("object"!=typeof t.functions[n])throw TypeError(".onnx.ModelProto.functions: object expected");e.functions[n]=a.onnx.FunctionProto.fromObject(t.functions[n])}}return e},t.toObject=function(t,e){e||(e={});var n={};if((e.arrays||e.defaults)&&(n.opsetImport=[],n.metadataProps=[],n.trainingInfo=[],n.functions=[]),e.defaults){if(i.Long){var B=new i.Long(0,0,!1);n.irVersion=e.longs===String?B.toString():e.longs===Number?B.toNumber():B}else n.irVersion=e.longs===String?"0":0;n.producerName="",n.producerVersion="",n.domain="",i.Long?(B=new i.Long(0,0,!1),n.modelVersion=e.longs===String?B.toString():e.longs===Number?B.toNumber():B):n.modelVersion=e.longs===String?"0":0,n.docString="",n.graph=null}if(null!=t.irVersion&&t.hasOwnProperty("irVersion")&&("number"==typeof t.irVersion?n.irVersion=e.longs===String?String(t.irVersion):t.irVersion:n.irVersion=e.longs===String?i.Long.prototype.toString.call(t.irVersion):e.longs===Number?new i.LongBits(t.irVersion.low>>>0,t.irVersion.high>>>0).toNumber():t.irVersion),null!=t.producerName&&t.hasOwnProperty("producerName")&&(n.producerName=t.producerName),null!=t.producerVersion&&t.hasOwnProperty("producerVersion")&&(n.producerVersion=t.producerVersion),null!=t.domain&&t.hasOwnProperty("domain")&&(n.domain=t.domain),null!=t.modelVersion&&t.hasOwnProperty("modelVersion")&&("number"==typeof t.modelVersion?n.modelVersion=e.longs===String?String(t.modelVersion):t.modelVersion:n.modelVersion=e.longs===String?i.Long.prototype.toString.call(t.modelVersion):e.longs===Number?new i.LongBits(t.modelVersion.low>>>0,t.modelVersion.high>>>0).toNumber():t.modelVersion),null!=t.docString&&t.hasOwnProperty("docString")&&(n.docString=t.docString),null!=t.graph&&t.hasOwnProperty("graph")&&(n.graph=a.onnx.GraphProto.toObject(t.graph,e)),t.opsetImport&&t.opsetImport.length){n.opsetImport=[];for(var s=0;s<t.opsetImport.length;++s)n.opsetImport[s]=a.onnx.OperatorSetIdProto.toObject(t.opsetImport[s],e)}if(t.metadataProps&&t.metadataProps.length)for(n.metadataProps=[],s=0;s<t.metadataProps.length;++s)n.metadataProps[s]=a.onnx.StringStringEntryProto.toObject(t.metadataProps[s],e);if(t.trainingInfo&&t.trainingInfo.length)for(n.trainingInfo=[],s=0;s<t.trainingInfo.length;++s)n.trainingInfo[s]=a.onnx.TrainingInfoProto.toObject(t.trainingInfo[s],e);if(t.functions&&t.functions.length)for(n.functions=[],s=0;s<t.functions.length;++s)n.functions[s]=a.onnx.FunctionProto.toObject(t.functions[s],e);return n},t.prototype.toJSON=function(){return this.constructor.toObject(this,F.util.toJSONOptions)},t.getTypeUrl=function(t){return void 0===t&&(t="type.googleapis.com"),t+"/onnx.ModelProto"},t}(),s.StringStringEntryProto=function(){function t(t){if(t)for(var e=Object.keys(t),n=0;n<e.length;++n)null!=t[e[n]]&&(this[e[n]]=t[e[n]])}return t.prototype.key="",t.prototype.value="",t.create=function(e){return new t(e)},t.encode=function(t,e){return e||(e=U.create()),null!=t.key&&Object.hasOwnProperty.call(t,"key")&&e.uint32(10).string(t.key),null!=t.value&&Object.hasOwnProperty.call(t,"value")&&e.uint32(18).string(t.value),e},t.encodeDelimited=function(t,e){return this.encode(t,e).ldelim()},t.decode=function(t,e){t instanceof Q||(t=Q.create(t));for(var n=void 0===e?t.len:t.pos+e,B=new a.onnx.StringStringEntryProto;t.pos<n;){var s=t.uint32();switch(s>>>3){case 1:B.key=t.string();break;case 2:B.value=t.string();break;default:t.skipType(7&s)}}return B},t.decodeDelimited=function(t){return t instanceof Q||(t=new Q(t)),this.decode(t,t.uint32())},t.verify=function(t){return"object"!=typeof t||null===t?"object expected":null!=t.key&&t.hasOwnProperty("key")&&!i.isString(t.key)?"key: string expected":null!=t.value&&t.hasOwnProperty("value")&&!i.isString(t.value)?"value: string expected":null},t.fromObject=function(t){if(t instanceof a.onnx.StringStringEntryProto)return t;var e=new a.onnx.StringStringEntryProto;return null!=t.key&&(e.key=String(t.key)),null!=t.value&&(e.value=String(t.value)),e},t.toObject=function(t,e){e||(e={});var n={};return e.defaults&&(n.key="",n.value=""),null!=t.key&&t.hasOwnProperty("key")&&(n.key=t.key),null!=t.value&&t.hasOwnProperty("value")&&(n.value=t.value),n},t.prototype.toJSON=function(){return this.constructor.toObject(this,F.util.toJSONOptions)},t.getTypeUrl=function(t){return void 0===t&&(t="type.googleapis.com"),t+"/onnx.StringStringEntryProto"},t}(),s.TensorAnnotation=function(){function t(t){if(this.quantParameterTensorNames=[],t)for(var e=Object.keys(t),n=0;n<e.length;++n)null!=t[e[n]]&&(this[e[n]]=t[e[n]])}return t.prototype.tensorName="",t.prototype.quantParameterTensorNames=i.emptyArray,t.create=function(e){return new t(e)},t.encode=function(t,e){if(e||(e=U.create()),null!=t.tensorName&&Object.hasOwnProperty.call(t,"tensorName")&&e.uint32(10).string(t.tensorName),null!=t.quantParameterTensorNames&&t.quantParameterTensorNames.length)for(var n=0;n<t.quantParameterTensorNames.length;++n)a.onnx.StringStringEntryProto.encode(t.quantParameterTensorNames[n],e.uint32(18).fork()).ldelim();return e},t.encodeDelimited=function(t,e){return this.encode(t,e).ldelim()},t.decode=function(t,e){t instanceof Q||(t=Q.create(t));for(var n=void 0===e?t.len:t.pos+e,B=new a.onnx.TensorAnnotation;t.pos<n;){var s=t.uint32();switch(s>>>3){case 1:B.tensorName=t.string();break;case 2:B.quantParameterTensorNames&&B.quantParameterTensorNames.length||(B.quantParameterTensorNames=[]),B.quantParameterTensorNames.push(a.onnx.StringStringEntryProto.decode(t,t.uint32()));break;default:t.skipType(7&s)}}return B},t.decodeDelimited=function(t){return t instanceof Q||(t=new Q(t)),this.decode(t,t.uint32())},t.verify=function(t){if("object"!=typeof t||null===t)return"object expected";if(null!=t.tensorName&&t.hasOwnProperty("tensorName")&&!i.isString(t.tensorName))return"tensorName: string expected";if(null!=t.quantParameterTensorNames&&t.hasOwnProperty("quantParameterTensorNames")){if(!Array.isArray(t.quantParameterTensorNames))return"quantParameterTensorNames: array expected";for(var e=0;e<t.quantParameterTensorNames.length;++e){var n=a.onnx.StringStringEntryProto.verify(t.quantParameterTensorNames[e]);if(n)return"quantParameterTensorNames."+n}}return null},t.fromObject=function(t){if(t instanceof a.onnx.TensorAnnotation)return t;var e=new a.onnx.TensorAnnotation;if(null!=t.tensorName&&(e.tensorName=String(t.tensorName)),t.quantParameterTensorNames){if(!Array.isArray(t.quantParameterTensorNames))throw TypeError(".onnx.TensorAnnotation.quantParameterTensorNames: array expected");e.quantParameterTensorNames=[];for(var n=0;n<t.quantParameterTensorNames.length;++n){if("object"!=typeof t.quantParameterTensorNames[n])throw TypeError(".onnx.TensorAnnotation.quantParameterTensorNames: object expected");e.quantParameterTensorNames[n]=a.onnx.StringStringEntryProto.fromObject(t.quantParameterTensorNames[n])}}return e},t.toObject=function(t,e){e||(e={});var n={};if((e.arrays||e.defaults)&&(n.quantParameterTensorNames=[]),e.defaults&&(n.tensorName=""),null!=t.tensorName&&t.hasOwnProperty("tensorName")&&(n.tensorName=t.tensorName),t.quantParameterTensorNames&&t.quantParameterTensorNames.length){n.quantParameterTensorNames=[];for(var B=0;B<t.quantParameterTensorNames.length;++B)n.quantParameterTensorNames[B]=a.onnx.StringStringEntryProto.toObject(t.quantParameterTensorNames[B],e)}return n},t.prototype.toJSON=function(){return this.constructor.toObject(this,F.util.toJSONOptions)},t.getTypeUrl=function(t){return void 0===t&&(t="type.googleapis.com"),t+"/onnx.TensorAnnotation"},t}(),s.GraphProto=function(){function t(t){if(this.node=[],this.initializer=[],this.sparseInitializer=[],this.input=[],this.output=[],this.valueInfo=[],this.quantizationAnnotation=[],t)for(var e=Object.keys(t),n=0;n<e.length;++n)null!=t[e[n]]&&(this[e[n]]=t[e[n]])}return t.prototype.node=i.emptyArray,t.prototype.name="",t.prototype.initializer=i.emptyArray,t.prototype.sparseInitializer=i.emptyArray,t.prototype.docString="",t.prototype.input=i.emptyArray,t.prototype.output=i.emptyArray,t.prototype.valueInfo=i.emptyArray,t.prototype.quantizationAnnotation=i.emptyArray,t.create=function(e){return new t(e)},t.encode=function(t,e){if(e||(e=U.create()),null!=t.node&&t.node.length)for(var n=0;n<t.node.length;++n)a.onnx.NodeProto.encode(t.node[n],e.uint32(10).fork()).ldelim();if(null!=t.name&&Object.hasOwnProperty.call(t,"name")&&e.uint32(18).string(t.name),null!=t.initializer&&t.initializer.length)for(n=0;n<t.initializer.length;++n)a.onnx.TensorProto.encode(t.initializer[n],e.uint32(42).fork()).ldelim();if(null!=t.docString&&Object.hasOwnProperty.call(t,"docString")&&e.uint32(82).string(t.docString),null!=t.input&&t.input.length)for(n=0;n<t.input.length;++n)a.onnx.ValueInfoProto.encode(t.input[n],e.uint32(90).fork()).ldelim();if(null!=t.output&&t.output.length)for(n=0;n<t.output.length;++n)a.onnx.ValueInfoProto.encode(t.output[n],e.uint32(98).fork()).ldelim();if(null!=t.valueInfo&&t.valueInfo.length)for(n=0;n<t.valueInfo.length;++n)a.onnx.ValueInfoProto.encode(t.valueInfo[n],e.uint32(106).fork()).ldelim();if(null!=t.quantizationAnnotation&&t.quantizationAnnotation.length)for(n=0;n<t.quantizationAnnotation.length;++n)a.onnx.TensorAnnotation.encode(t.quantizationAnnotation[n],e.uint32(114).fork()).ldelim();if(null!=t.sparseInitializer&&t.sparseInitializer.length)for(n=0;n<t.sparseInitializer.length;++n)a.onnx.SparseTensorProto.encode(t.sparseInitializer[n],e.uint32(122).fork()).ldelim();return e},t.encodeDelimited=function(t,e){return this.encode(t,e).ldelim()},t.decode=function(t,e){t instanceof Q||(t=Q.create(t));for(var n=void 0===e?t.len:t.pos+e,B=new a.onnx.GraphProto;t.pos<n;){var s=t.uint32();switch(s>>>3){case 1:B.node&&B.node.length||(B.node=[]),B.node.push(a.onnx.NodeProto.decode(t,t.uint32()));break;case 2:B.name=t.string();break;case 5:B.initializer&&B.initializer.length||(B.initializer=[]),B.initializer.push(a.onnx.TensorProto.decode(t,t.uint32()));break;case 15:B.sparseInitializer&&B.sparseInitializer.length||(B.sparseInitializer=[]),B.sparseInitializer.push(a.onnx.SparseTensorProto.decode(t,t.uint32()));break;case 10:B.docString=t.string();break;case 11:B.input&&B.input.length||(B.input=[]),B.input.push(a.onnx.ValueInfoProto.decode(t,t.uint32()));break;case 12:B.output&&B.output.length||(B.output=[]),B.output.push(a.onnx.ValueInfoProto.decode(t,t.uint32()));break;case 13:B.valueInfo&&B.valueInfo.length||(B.valueInfo=[]),B.valueInfo.push(a.onnx.ValueInfoProto.decode(t,t.uint32()));break;case 14:B.quantizationAnnotation&&B.quantizationAnnotation.length||(B.quantizationAnnotation=[]),B.quantizationAnnotation.push(a.onnx.TensorAnnotation.decode(t,t.uint32()));break;default:t.skipType(7&s)}}return B},t.decodeDelimited=function(t){return t instanceof Q||(t=new Q(t)),this.decode(t,t.uint32())},t.verify=function(t){if("object"!=typeof t||null===t)return"object expected";if(null!=t.node&&t.hasOwnProperty("node")){if(!Array.isArray(t.node))return"node: array expected";for(var e=0;e<t.node.length;++e)if(n=a.onnx.NodeProto.verify(t.node[e]))return"node."+n}if(null!=t.name&&t.hasOwnProperty("name")&&!i.isString(t.name))return"name: string expected";if(null!=t.initializer&&t.hasOwnProperty("initializer")){if(!Array.isArray(t.initializer))return"initializer: array expected";for(e=0;e<t.initializer.length;++e)if(n=a.onnx.TensorProto.verify(t.initializer[e]))return"initializer."+n}if(null!=t.sparseInitializer&&t.hasOwnProperty("sparseInitializer")){if(!Array.isArray(t.sparseInitializer))return"sparseInitializer: array expected";for(e=0;e<t.sparseInitializer.length;++e)if(n=a.onnx.SparseTensorProto.verify(t.sparseInitializer[e]))return"sparseInitializer."+n}if(null!=t.docString&&t.hasOwnProperty("docString")&&!i.isString(t.docString))return"docString: string expected";if(null!=t.input&&t.hasOwnProperty("input")){if(!Array.isArray(t.input))return"input: array expected";for(e=0;e<t.input.length;++e)if(n=a.onnx.ValueInfoProto.verify(t.input[e]))return"input."+n}if(null!=t.output&&t.hasOwnProperty("output")){if(!Array.isArray(t.output))return"output: array expected";for(e=0;e<t.output.length;++e)if(n=a.onnx.ValueInfoProto.verify(t.output[e]))return"output."+n}if(null!=t.valueInfo&&t.hasOwnProperty("valueInfo")){if(!Array.isArray(t.valueInfo))return"valueInfo: array expected";for(e=0;e<t.valueInfo.length;++e)if(n=a.onnx.ValueInfoProto.verify(t.valueInfo[e]))return"valueInfo."+n}if(null!=t.quantizationAnnotation&&t.hasOwnProperty("quantizationAnnotation")){if(!Array.isArray(t.quantizationAnnotation))return"quantizationAnnotation: array expected";for(e=0;e<t.quantizationAnnotation.length;++e){var n;if(n=a.onnx.TensorAnnotation.verify(t.quantizationAnnotation[e]))return"quantizationAnnotation."+n}}return null},t.fromObject=function(t){if(t instanceof a.onnx.GraphProto)return t;var e=new a.onnx.GraphProto;if(t.node){if(!Array.isArray(t.node))throw TypeError(".onnx.GraphProto.node: array expected");e.node=[];for(var n=0;n<t.node.length;++n){if("object"!=typeof t.node[n])throw TypeError(".onnx.GraphProto.node: object expected");e.node[n]=a.onnx.NodeProto.fromObject(t.node[n])}}if(null!=t.name&&(e.name=String(t.name)),t.initializer){if(!Array.isArray(t.initializer))throw TypeError(".onnx.GraphProto.initializer: array expected");for(e.initializer=[],n=0;n<t.initializer.length;++n){if("object"!=typeof t.initializer[n])throw TypeError(".onnx.GraphProto.initializer: object expected");e.initializer[n]=a.onnx.TensorProto.fromObject(t.initializer[n])}}if(t.sparseInitializer){if(!Array.isArray(t.sparseInitializer))throw TypeError(".onnx.GraphProto.sparseInitializer: array expected");for(e.sparseInitializer=[],n=0;n<t.sparseInitializer.length;++n){if("object"!=typeof t.sparseInitializer[n])throw TypeError(".onnx.GraphProto.sparseInitializer: object expected");e.sparseInitializer[n]=a.onnx.SparseTensorProto.fromObject(t.sparseInitializer[n])}}if(null!=t.docString&&(e.docString=String(t.docString)),t.input){if(!Array.isArray(t.input))throw TypeError(".onnx.GraphProto.input: array expected");for(e.input=[],n=0;n<t.input.length;++n){if("object"!=typeof t.input[n])throw TypeError(".onnx.GraphProto.input: object expected");e.input[n]=a.onnx.ValueInfoProto.fromObject(t.input[n])}}if(t.output){if(!Array.isArray(t.output))throw TypeError(".onnx.GraphProto.output: array expected");for(e.output=[],n=0;n<t.output.length;++n){if("object"!=typeof t.output[n])throw TypeError(".onnx.GraphProto.output: object expected");e.output[n]=a.onnx.ValueInfoProto.fromObject(t.output[n])}}if(t.valueInfo){if(!Array.isArray(t.valueInfo))throw TypeError(".onnx.GraphProto.valueInfo: array expected");for(e.valueInfo=[],n=0;n<t.valueInfo.length;++n){if("object"!=typeof t.valueInfo[n])throw TypeError(".onnx.GraphProto.valueInfo: object expected");e.valueInfo[n]=a.onnx.ValueInfoProto.fromObject(t.valueInfo[n])}}if(t.quantizationAnnotation){if(!Array.isArray(t.quantizationAnnotation))throw TypeError(".onnx.GraphProto.quantizationAnnotation: array expected");for(e.quantizationAnnotation=[],n=0;n<t.quantizationAnnotation.length;++n){if("object"!=typeof t.quantizationAnnotation[n])throw TypeError(".onnx.GraphProto.quantizationAnnotation: object expected");e.quantizationAnnotation[n]=a.onnx.TensorAnnotation.fromObject(t.quantizationAnnotation[n])}}return e},t.toObject=function(t,e){e||(e={});var n={};if((e.arrays||e.defaults)&&(n.node=[],n.initializer=[],n.input=[],n.output=[],n.valueInfo=[],n.quantizationAnnotation=[],n.sparseInitializer=[]),e.defaults&&(n.name="",n.docString=""),t.node&&t.node.length){n.node=[];for(var B=0;B<t.node.length;++B)n.node[B]=a.onnx.NodeProto.toObject(t.node[B],e)}if(null!=t.name&&t.hasOwnProperty("name")&&(n.name=t.name),t.initializer&&t.initializer.length)for(n.initializer=[],B=0;B<t.initializer.length;++B)n.initializer[B]=a.onnx.TensorProto.toObject(t.initializer[B],e);if(null!=t.docString&&t.hasOwnProperty("docString")&&(n.docString=t.docString),t.input&&t.input.length)for(n.input=[],B=0;B<t.input.length;++B)n.input[B]=a.onnx.ValueInfoProto.toObject(t.input[B],e);if(t.output&&t.output.length)for(n.output=[],B=0;B<t.output.length;++B)n.output[B]=a.onnx.ValueInfoProto.toObject(t.output[B],e);if(t.valueInfo&&t.valueInfo.length)for(n.valueInfo=[],B=0;B<t.valueInfo.length;++B)n.valueInfo[B]=a.onnx.ValueInfoProto.toObject(t.valueInfo[B],e);if(t.quantizationAnnotation&&t.quantizationAnnotation.length)for(n.quantizationAnnotation=[],B=0;B<t.quantizationAnnotation.length;++B)n.quantizationAnnotation[B]=a.onnx.TensorAnnotation.toObject(t.quantizationAnnotation[B],e);if(t.sparseInitializer&&t.sparseInitializer.length)for(n.sparseInitializer=[],B=0;B<t.sparseInitializer.length;++B)n.sparseInitializer[B]=a.onnx.SparseTensorProto.toObject(t.sparseInitializer[B],e);return n},t.prototype.toJSON=function(){return this.constructor.toObject(this,F.util.toJSONOptions)},t.getTypeUrl=function(t){return void 0===t&&(t="type.googleapis.com"),t+"/onnx.GraphProto"},t}(),s.TensorProto=function(){function t(t){if(this.dims=[],this.floatData=[],this.int32Data=[],this.stringData=[],this.int64Data=[],this.externalData=[],this.doubleData=[],this.uint64Data=[],t)for(var e=Object.keys(t),n=0;n<e.length;++n)null!=t[e[n]]&&(this[e[n]]=t[e[n]])}return t.prototype.dims=i.emptyArray,t.prototype.dataType=0,t.prototype.segment=null,t.prototype.floatData=i.emptyArray,t.prototype.int32Data=i.emptyArray,t.prototype.stringData=i.emptyArray,t.prototype.int64Data=i.emptyArray,t.prototype.name="",t.prototype.docString="",t.prototype.rawData=i.newBuffer([]),t.prototype.externalData=i.emptyArray,t.prototype.dataLocation=0,t.prototype.doubleData=i.emptyArray,t.prototype.uint64Data=i.emptyArray,t.create=function(e){return new t(e)},t.encode=function(t,e){if(e||(e=U.create()),null!=t.dims&&t.dims.length){e.uint32(10).fork();for(var n=0;n<t.dims.length;++n)e.int64(t.dims[n]);e.ldelim()}if(null!=t.dataType&&Object.hasOwnProperty.call(t,"dataType")&&e.uint32(16).int32(t.dataType),null!=t.segment&&Object.hasOwnProperty.call(t,"segment")&&a.onnx.TensorProto.Segment.encode(t.segment,e.uint32(26).fork()).ldelim(),null!=t.floatData&&t.floatData.length){for(e.uint32(34).fork(),n=0;n<t.floatData.length;++n)e.float(t.floatData[n]);e.ldelim()}if(null!=t.int32Data&&t.int32Data.length){for(e.uint32(42).fork(),n=0;n<t.int32Data.length;++n)e.int32(t.int32Data[n]);e.ldelim()}if(null!=t.stringData&&t.stringData.length)for(n=0;n<t.stringData.length;++n)e.uint32(50).bytes(t.stringData[n]);if(null!=t.int64Data&&t.int64Data.length){for(e.uint32(58).fork(),n=0;n<t.int64Data.length;++n)e.int64(t.int64Data[n]);e.ldelim()}if(null!=t.name&&Object.hasOwnProperty.call(t,"name")&&e.uint32(66).string(t.name),null!=t.rawData&&Object.hasOwnProperty.call(t,"rawData")&&e.uint32(74).bytes(t.rawData),null!=t.doubleData&&t.doubleData.length){for(e.uint32(82).fork(),n=0;n<t.doubleData.length;++n)e.double(t.doubleData[n]);e.ldelim()}if(null!=t.uint64Data&&t.uint64Data.length){for(e.uint32(90).fork(),n=0;n<t.uint64Data.length;++n)e.uint64(t.uint64Data[n]);e.ldelim()}if(null!=t.docString&&Object.hasOwnProperty.call(t,"docString")&&e.uint32(98).string(t.docString),null!=t.externalData&&t.externalData.length)for(n=0;n<t.externalData.length;++n)a.onnx.StringStringEntryProto.encode(t.externalData[n],e.uint32(106).fork()).ldelim();return null!=t.dataLocation&&Object.hasOwnProperty.call(t,"dataLocation")&&e.uint32(112).int32(t.dataLocation),e},t.encodeDelimited=function(t,e){return this.encode(t,e).ldelim()},t.decode=function(t,e){t instanceof Q||(t=Q.create(t));for(var n=void 0===e?t.len:t.pos+e,B=new a.onnx.TensorProto;t.pos<n;){var s=t.uint32();switch(s>>>3){case 1:if(B.dims&&B.dims.length||(B.dims=[]),2==(7&s))for(var F=t.uint32()+t.pos;t.pos<F;)B.dims.push(t.int64());else B.dims.push(t.int64());break;case 2:B.dataType=t.int32();break;case 3:B.segment=a.onnx.TensorProto.Segment.decode(t,t.uint32());break;case 4:if(B.floatData&&B.floatData.length||(B.floatData=[]),2==(7&s))for(F=t.uint32()+t.pos;t.pos<F;)B.floatData.push(t.float());else B.floatData.push(t.float());break;case 5:if(B.int32Data&&B.int32Data.length||(B.int32Data=[]),2==(7&s))for(F=t.uint32()+t.pos;t.pos<F;)B.int32Data.push(t.int32());else B.int32Data.push(t.int32());break;case 6:B.stringData&&B.stringData.length||(B.stringData=[]),B.stringData.push(t.bytes());break;case 7:if(B.int64Data&&B.int64Data.length||(B.int64Data=[]),2==(7&s))for(F=t.uint32()+t.pos;t.pos<F;)B.int64Data.push(t.int64());else B.int64Data.push(t.int64());break;case 8:B.name=t.string();break;case 12:B.docString=t.string();break;case 9:B.rawData=t.bytes();break;case 13:B.externalData&&B.externalData.length||(B.externalData=[]),B.externalData.push(a.onnx.StringStringEntryProto.decode(t,t.uint32()));break;case 14:B.dataLocation=t.int32();break;case 10:if(B.doubleData&&B.doubleData.length||(B.doubleData=[]),2==(7&s))for(F=t.uint32()+t.pos;t.pos<F;)B.doubleData.push(t.double());else B.doubleData.push(t.double());break;case 11:if(B.uint64Data&&B.uint64Data.length||(B.uint64Data=[]),2==(7&s))for(F=t.uint32()+t.pos;t.pos<F;)B.uint64Data.push(t.uint64());else B.uint64Data.push(t.uint64());break;default:t.skipType(7&s)}}return B},t.decodeDelimited=function(t){return t instanceof Q||(t=new Q(t)),this.decode(t,t.uint32())},t.verify=function(t){if("object"!=typeof t||null===t)return"object expected";if(null!=t.dims&&t.hasOwnProperty("dims")){if(!Array.isArray(t.dims))return"dims: array expected";for(var e=0;e<t.dims.length;++e)if(!(i.isInteger(t.dims[e])||t.dims[e]&&i.isInteger(t.dims[e].low)&&i.isInteger(t.dims[e].high)))return"dims: integer|Long[] expected"}if(null!=t.dataType&&t.hasOwnProperty("dataType")&&!i.isInteger(t.dataType))return"dataType: integer expected";if(null!=t.segment&&t.hasOwnProperty("segment")&&(n=a.onnx.TensorProto.Segment.verify(t.segment)))return"segment."+n;if(null!=t.floatData&&t.hasOwnProperty("floatData")){if(!Array.isArray(t.floatData))return"floatData: array expected";for(e=0;e<t.floatData.length;++e)if("number"!=typeof t.floatData[e])return"floatData: number[] expected"}if(null!=t.int32Data&&t.hasOwnProperty("int32Data")){if(!Array.isArray(t.int32Data))return"int32Data: array expected";for(e=0;e<t.int32Data.length;++e)if(!i.isInteger(t.int32Data[e]))return"int32Data: integer[] expected"}if(null!=t.stringData&&t.hasOwnProperty("stringData")){if(!Array.isArray(t.stringData))return"stringData: array expected";for(e=0;e<t.stringData.length;++e)if(!(t.stringData[e]&&"number"==typeof t.stringData[e].length||i.isString(t.stringData[e])))return"stringData: buffer[] expected"}if(null!=t.int64Data&&t.hasOwnProperty("int64Data")){if(!Array.isArray(t.int64Data))return"int64Data: array expected";for(e=0;e<t.int64Data.length;++e)if(!(i.isInteger(t.int64Data[e])||t.int64Data[e]&&i.isInteger(t.int64Data[e].low)&&i.isInteger(t.int64Data[e].high)))return"int64Data: integer|Long[] expected"}if(null!=t.name&&t.hasOwnProperty("name")&&!i.isString(t.name))return"name: string expected";if(null!=t.docString&&t.hasOwnProperty("docString")&&!i.isString(t.docString))return"docString: string expected";if(null!=t.rawData&&t.hasOwnProperty("rawData")&&!(t.rawData&&"number"==typeof t.rawData.length||i.isString(t.rawData)))return"rawData: buffer expected";if(null!=t.externalData&&t.hasOwnProperty("externalData")){if(!Array.isArray(t.externalData))return"externalData: array expected";for(e=0;e<t.externalData.length;++e){var n;if(n=a.onnx.StringStringEntryProto.verify(t.externalData[e]))return"externalData."+n}}if(null!=t.dataLocation&&t.hasOwnProperty("dataLocation"))switch(t.dataLocation){default:return"dataLocation: enum value expected";case 0:case 1:}if(null!=t.doubleData&&t.hasOwnProperty("doubleData")){if(!Array.isArray(t.doubleData))return"doubleData: array expected";for(e=0;e<t.doubleData.length;++e)if("number"!=typeof t.doubleData[e])return"doubleData: number[] expected"}if(null!=t.uint64Data&&t.hasOwnProperty("uint64Data")){if(!Array.isArray(t.uint64Data))return"uint64Data: array expected";for(e=0;e<t.uint64Data.length;++e)if(!(i.isInteger(t.uint64Data[e])||t.uint64Data[e]&&i.isInteger(t.uint64Data[e].low)&&i.isInteger(t.uint64Data[e].high)))return"uint64Data: integer|Long[] expected"}return null},t.fromObject=function(t){if(t instanceof a.onnx.TensorProto)return t;var e=new a.onnx.TensorProto;if(t.dims){if(!Array.isArray(t.dims))throw TypeError(".onnx.TensorProto.dims: array expected");e.dims=[];for(var n=0;n<t.dims.length;++n)i.Long?(e.dims[n]=i.Long.fromValue(t.dims[n])).unsigned=!1:"string"==typeof t.dims[n]?e.dims[n]=parseInt(t.dims[n],10):"number"==typeof t.dims[n]?e.dims[n]=t.dims[n]:"object"==typeof t.dims[n]&&(e.dims[n]=new i.LongBits(t.dims[n].low>>>0,t.dims[n].high>>>0).toNumber())}if(null!=t.dataType&&(e.dataType=0|t.dataType),null!=t.segment){if("object"!=typeof t.segment)throw TypeError(".onnx.TensorProto.segment: object expected");e.segment=a.onnx.TensorProto.Segment.fromObject(t.segment)}if(t.floatData){if(!Array.isArray(t.floatData))throw TypeError(".onnx.TensorProto.floatData: array expected");for(e.floatData=[],n=0;n<t.floatData.length;++n)e.floatData[n]=Number(t.floatData[n])}if(t.int32Data){if(!Array.isArray(t.int32Data))throw TypeError(".onnx.TensorProto.int32Data: array expected");for(e.int32Data=[],n=0;n<t.int32Data.length;++n)e.int32Data[n]=0|t.int32Data[n]}if(t.stringData){if(!Array.isArray(t.stringData))throw TypeError(".onnx.TensorProto.stringData: array expected");for(e.stringData=[],n=0;n<t.stringData.length;++n)"string"==typeof t.stringData[n]?i.base64.decode(t.stringData[n],e.stringData[n]=i.newBuffer(i.base64.length(t.stringData[n])),0):t.stringData[n].length>=0&&(e.stringData[n]=t.stringData[n])}if(t.int64Data){if(!Array.isArray(t.int64Data))throw TypeError(".onnx.TensorProto.int64Data: array expected");for(e.int64Data=[],n=0;n<t.int64Data.length;++n)i.Long?(e.int64Data[n]=i.Long.fromValue(t.int64Data[n])).unsigned=!1:"string"==typeof t.int64Data[n]?e.int64Data[n]=parseInt(t.int64Data[n],10):"number"==typeof t.int64Data[n]?e.int64Data[n]=t.int64Data[n]:"object"==typeof t.int64Data[n]&&(e.int64Data[n]=new i.LongBits(t.int64Data[n].low>>>0,t.int64Data[n].high>>>0).toNumber())}if(null!=t.name&&(e.name=String(t.name)),null!=t.docString&&(e.docString=String(t.docString)),null!=t.rawData&&("string"==typeof t.rawData?i.base64.decode(t.rawData,e.rawData=i.newBuffer(i.base64.length(t.rawData)),0):t.rawData.length>=0&&(e.rawData=t.rawData)),t.externalData){if(!Array.isArray(t.externalData))throw TypeError(".onnx.TensorProto.externalData: array expected");for(e.externalData=[],n=0;n<t.externalData.length;++n){if("object"!=typeof t.externalData[n])throw TypeError(".onnx.TensorProto.externalData: object expected");e.externalData[n]=a.onnx.StringStringEntryProto.fromObject(t.externalData[n])}}switch(t.dataLocation){default:if("number"==typeof t.dataLocation){e.dataLocation=t.dataLocation;break}break;case"DEFAULT":case 0:e.dataLocation=0;break;case"EXTERNAL":case 1:e.dataLocation=1}if(t.doubleData){if(!Array.isArray(t.doubleData))throw TypeError(".onnx.TensorProto.doubleData: array expected");for(e.doubleData=[],n=0;n<t.doubleData.length;++n)e.doubleData[n]=Number(t.doubleData[n])}if(t.uint64Data){if(!Array.isArray(t.uint64Data))throw TypeError(".onnx.TensorProto.uint64Data: array expected");for(e.uint64Data=[],n=0;n<t.uint64Data.length;++n)i.Long?(e.uint64Data[n]=i.Long.fromValue(t.uint64Data[n])).unsigned=!0:"string"==typeof t.uint64Data[n]?e.uint64Data[n]=parseInt(t.uint64Data[n],10):"number"==typeof t.uint64Data[n]?e.uint64Data[n]=t.uint64Data[n]:"object"==typeof t.uint64Data[n]&&(e.uint64Data[n]=new i.LongBits(t.uint64Data[n].low>>>0,t.uint64Data[n].high>>>0).toNumber(!0))}return e},t.toObject=function(t,e){e||(e={});var n={};if((e.arrays||e.defaults)&&(n.dims=[],n.floatData=[],n.int32Data=[],n.stringData=[],n.int64Data=[],n.doubleData=[],n.uint64Data=[],n.externalData=[]),e.defaults&&(n.dataType=0,n.segment=null,n.name="",e.bytes===String?n.rawData="":(n.rawData=[],e.bytes!==Array&&(n.rawData=i.newBuffer(n.rawData))),n.docString="",n.dataLocation=e.enums===String?"DEFAULT":0),t.dims&&t.dims.length){n.dims=[];for(var B=0;B<t.dims.length;++B)"number"==typeof t.dims[B]?n.dims[B]=e.longs===String?String(t.dims[B]):t.dims[B]:n.dims[B]=e.longs===String?i.Long.prototype.toString.call(t.dims[B]):e.longs===Number?new i.LongBits(t.dims[B].low>>>0,t.dims[B].high>>>0).toNumber():t.dims[B]}if(null!=t.dataType&&t.hasOwnProperty("dataType")&&(n.dataType=t.dataType),null!=t.segment&&t.hasOwnProperty("segment")&&(n.segment=a.onnx.TensorProto.Segment.toObject(t.segment,e)),t.floatData&&t.floatData.length)for(n.floatData=[],B=0;B<t.floatData.length;++B)n.floatData[B]=e.json&&!isFinite(t.floatData[B])?String(t.floatData[B]):t.floatData[B];if(t.int32Data&&t.int32Data.length)for(n.int32Data=[],B=0;B<t.int32Data.length;++B)n.int32Data[B]=t.int32Data[B];if(t.stringData&&t.stringData.length)for(n.stringData=[],B=0;B<t.stringData.length;++B)n.stringData[B]=e.bytes===String?i.base64.encode(t.stringData[B],0,t.stringData[B].length):e.bytes===Array?Array.prototype.slice.call(t.stringData[B]):t.stringData[B];if(t.int64Data&&t.int64Data.length)for(n.int64Data=[],B=0;B<t.int64Data.length;++B)"number"==typeof t.int64Data[B]?n.int64Data[B]=e.longs===String?String(t.int64Data[B]):t.int64Data[B]:n.int64Data[B]=e.longs===String?i.Long.prototype.toString.call(t.int64Data[B]):e.longs===Number?new i.LongBits(t.int64Data[B].low>>>0,t.int64Data[B].high>>>0).toNumber():t.int64Data[B];if(null!=t.name&&t.hasOwnProperty("name")&&(n.name=t.name),null!=t.rawData&&t.hasOwnProperty("rawData")&&(n.rawData=e.bytes===String?i.base64.encode(t.rawData,0,t.rawData.length):e.bytes===Array?Array.prototype.slice.call(t.rawData):t.rawData),t.doubleData&&t.doubleData.length)for(n.doubleData=[],B=0;B<t.doubleData.length;++B)n.doubleData[B]=e.json&&!isFinite(t.doubleData[B])?String(t.doubleData[B]):t.doubleData[B];if(t.uint64Data&&t.uint64Data.length)for(n.uint64Data=[],B=0;B<t.uint64Data.length;++B)"number"==typeof t.uint64Data[B]?n.uint64Data[B]=e.longs===String?String(t.uint64Data[B]):t.uint64Data[B]:n.uint64Data[B]=e.longs===String?i.Long.prototype.toString.call(t.uint64Data[B]):e.longs===Number?new i.LongBits(t.uint64Data[B].low>>>0,t.uint64Data[B].high>>>0).toNumber(!0):t.uint64Data[B];if(null!=t.docString&&t.hasOwnProperty("docString")&&(n.docString=t.docString),t.externalData&&t.externalData.length)for(n.externalData=[],B=0;B<t.externalData.length;++B)n.externalData[B]=a.onnx.StringStringEntryProto.toObject(t.externalData[B],e);return null!=t.dataLocation&&t.hasOwnProperty("dataLocation")&&(n.dataLocation=e.enums===String?void 0===a.onnx.TensorProto.DataLocation[t.dataLocation]?t.dataLocation:a.onnx.TensorProto.DataLocation[t.dataLocation]:t.dataLocation),n},t.prototype.toJSON=function(){return this.constructor.toObject(this,F.util.toJSONOptions)},t.getTypeUrl=function(t){return void 0===t&&(t="type.googleapis.com"),t+"/onnx.TensorProto"},t.DataType=function(){var t={},e=Object.create(t);return e[t[0]="UNDEFINED"]=0,e[t[1]="FLOAT"]=1,e[t[2]="UINT8"]=2,e[t[3]="INT8"]=3,e[t[4]="UINT16"]=4,e[t[5]="INT16"]=5,e[t[6]="INT32"]=6,e[t[7]="INT64"]=7,e[t[8]="STRING"]=8,e[t[9]="BOOL"]=9,e[t[10]="FLOAT16"]=10,e[t[11]="DOUBLE"]=11,e[t[12]="UINT32"]=12,e[t[13]="UINT64"]=13,e[t[14]="COMPLEX64"]=14,e[t[15]="COMPLEX128"]=15,e[t[16]="BFLOAT16"]=16,e[t[17]="FLOAT8E4M3FN"]=17,e[t[18]="FLOAT8E4M3FNUZ"]=18,e[t[19]="FLOAT8E5M2"]=19,e[t[20]="FLOAT8E5M2FNUZ"]=20,e}(),t.Segment=function(){function t(t){if(t)for(var e=Object.keys(t),n=0;n<e.length;++n)null!=t[e[n]]&&(this[e[n]]=t[e[n]])}return t.prototype.begin=i.Long?i.Long.fromBits(0,0,!1):0,t.prototype.end=i.Long?i.Long.fromBits(0,0,!1):0,t.create=function(e){return new t(e)},t.encode=function(t,e){return e||(e=U.create()),null!=t.begin&&Object.hasOwnProperty.call(t,"begin")&&e.uint32(8).int64(t.begin),null!=t.end&&Object.hasOwnProperty.call(t,"end")&&e.uint32(16).int64(t.end),e},t.encodeDelimited=function(t,e){return this.encode(t,e).ldelim()},t.decode=function(t,e){t instanceof Q||(t=Q.create(t));for(var n=void 0===e?t.len:t.pos+e,B=new a.onnx.TensorProto.Segment;t.pos<n;){var s=t.uint32();switch(s>>>3){case 1:B.begin=t.int64();break;case 2:B.end=t.int64();break;default:t.skipType(7&s)}}return B},t.decodeDelimited=function(t){return t instanceof Q||(t=new Q(t)),this.decode(t,t.uint32())},t.verify=function(t){return"object"!=typeof t||null===t?"object expected":null!=t.begin&&t.hasOwnProperty("begin")&&!(i.isInteger(t.begin)||t.begin&&i.isInteger(t.begin.low)&&i.isInteger(t.begin.high))?"begin: integer|Long expected":null!=t.end&&t.hasOwnProperty("end")&&!(i.isInteger(t.end)||t.end&&i.isInteger(t.end.low)&&i.isInteger(t.end.high))?"end: integer|Long expected":null},t.fromObject=function(t){if(t instanceof a.onnx.TensorProto.Segment)return t;var e=new a.onnx.TensorProto.Segment;return null!=t.begin&&(i.Long?(e.begin=i.Long.fromValue(t.begin)).unsigned=!1:"string"==typeof t.begin?e.begin=parseInt(t.begin,10):"number"==typeof t.begin?e.begin=t.begin:"object"==typeof t.begin&&(e.begin=new i.LongBits(t.begin.low>>>0,t.begin.high>>>0).toNumber())),null!=t.end&&(i.Long?(e.end=i.Long.fromValue(t.end)).unsigned=!1:"string"==typeof t.end?e.end=parseInt(t.end,10):"number"==typeof t.end?e.end=t.end:"object"==typeof t.end&&(e.end=new i.LongBits(t.end.low>>>0,t.end.high>>>0).toNumber())),e},t.toObject=function(t,e){e||(e={});var n={};if(e.defaults){if(i.Long){var B=new i.Long(0,0,!1);n.begin=e.longs===String?B.toString():e.longs===Number?B.toNumber():B}else n.begin=e.longs===String?"0":0;i.Long?(B=new i.Long(0,0,!1),n.end=e.longs===String?B.toString():e.longs===Number?B.toNumber():B):n.end=e.longs===String?"0":0}return null!=t.begin&&t.hasOwnProperty("begin")&&("number"==typeof t.begin?n.begin=e.longs===String?String(t.begin):t.begin:n.begin=e.longs===String?i.Long.prototype.toString.call(t.begin):e.longs===Number?new i.LongBits(t.begin.low>>>0,t.begin.high>>>0).toNumber():t.begin),null!=t.end&&t.hasOwnProperty("end")&&("number"==typeof t.end?n.end=e.longs===String?String(t.end):t.end:n.end=e.longs===String?i.Long.prototype.toString.call(t.end):e.longs===Number?new i.LongBits(t.end.low>>>0,t.end.high>>>0).toNumber():t.end),n},t.prototype.toJSON=function(){return this.constructor.toObject(this,F.util.toJSONOptions)},t.getTypeUrl=function(t){return void 0===t&&(t="type.googleapis.com"),t+"/onnx.TensorProto.Segment"},t}(),t.DataLocation=function(){var t={},e=Object.create(t);return e[t[0]="DEFAULT"]=0,e[t[1]="EXTERNAL"]=1,e}(),t}(),s.SparseTensorProto=function(){function t(t){if(this.dims=[],t)for(var e=Object.keys(t),n=0;n<e.length;++n)null!=t[e[n]]&&(this[e[n]]=t[e[n]])}return t.prototype.values=null,t.prototype.indices=null,t.prototype.dims=i.emptyArray,t.create=function(e){return new t(e)},t.encode=function(t,e){if(e||(e=U.create()),null!=t.values&&Object.hasOwnProperty.call(t,"values")&&a.onnx.TensorProto.encode(t.values,e.uint32(10).fork()).ldelim(),null!=t.indices&&Object.hasOwnProperty.call(t,"indices")&&a.onnx.TensorProto.encode(t.indices,e.uint32(18).fork()).ldelim(),null!=t.dims&&t.dims.length){e.uint32(26).fork();for(var n=0;n<t.dims.length;++n)e.int64(t.dims[n]);e.ldelim()}return e},t.encodeDelimited=function(t,e){return this.encode(t,e).ldelim()},t.decode=function(t,e){t instanceof Q||(t=Q.create(t));for(var n=void 0===e?t.len:t.pos+e,B=new a.onnx.SparseTensorProto;t.pos<n;){var s=t.uint32();switch(s>>>3){case 1:B.values=a.onnx.TensorProto.decode(t,t.uint32());break;case 2:B.indices=a.onnx.TensorProto.decode(t,t.uint32());break;case 3:if(B.dims&&B.dims.length||(B.dims=[]),2==(7&s))for(var F=t.uint32()+t.pos;t.pos<F;)B.dims.push(t.int64());else B.dims.push(t.int64());break;default:t.skipType(7&s)}}return B},t.decodeDelimited=function(t){return t instanceof Q||(t=new Q(t)),this.decode(t,t.uint32())},t.verify=function(t){if("object"!=typeof t||null===t)return"object expected";var e;if(null!=t.values&&t.hasOwnProperty("values")&&(e=a.onnx.TensorProto.verify(t.values)))return"values."+e;if(null!=t.indices&&t.hasOwnProperty("indices")&&(e=a.onnx.TensorProto.verify(t.indices)))return"indices."+e;if(null!=t.dims&&t.hasOwnProperty("dims")){if(!Array.isArray(t.dims))return"dims: array expected";for(var n=0;n<t.dims.length;++n)if(!(i.isInteger(t.dims[n])||t.dims[n]&&i.isInteger(t.dims[n].low)&&i.isInteger(t.dims[n].high)))return"dims: integer|Long[] expected"}return null},t.fromObject=function(t){if(t instanceof a.onnx.SparseTensorProto)return t;var e=new a.onnx.SparseTensorProto;if(null!=t.values){if("object"!=typeof t.values)throw TypeError(".onnx.SparseTensorProto.values: object expected");e.values=a.onnx.TensorProto.fromObject(t.values)}if(null!=t.indices){if("object"!=typeof t.indices)throw TypeError(".onnx.SparseTensorProto.indices: object expected");e.indices=a.onnx.TensorProto.fromObject(t.indices)}if(t.dims){if(!Array.isArray(t.dims))throw TypeError(".onnx.SparseTensorProto.dims: array expected");e.dims=[];for(var n=0;n<t.dims.length;++n)i.Long?(e.dims[n]=i.Long.fromValue(t.dims[n])).unsigned=!1:"string"==typeof t.dims[n]?e.dims[n]=parseInt(t.dims[n],10):"number"==typeof t.dims[n]?e.dims[n]=t.dims[n]:"object"==typeof t.dims[n]&&(e.dims[n]=new i.LongBits(t.dims[n].low>>>0,t.dims[n].high>>>0).toNumber())}return e},t.toObject=function(t,e){e||(e={});var n={};if((e.arrays||e.defaults)&&(n.dims=[]),e.defaults&&(n.values=null,n.indices=null),null!=t.values&&t.hasOwnProperty("values")&&(n.values=a.onnx.TensorProto.toObject(t.values,e)),null!=t.indices&&t.hasOwnProperty("indices")&&(n.indices=a.onnx.TensorProto.toObject(t.indices,e)),t.dims&&t.dims.length){n.dims=[];for(var B=0;B<t.dims.length;++B)"number"==typeof t.dims[B]?n.dims[B]=e.longs===String?String(t.dims[B]):t.dims[B]:n.dims[B]=e.longs===String?i.Long.prototype.toString.call(t.dims[B]):e.longs===Number?new i.LongBits(t.dims[B].low>>>0,t.dims[B].high>>>0).toNumber():t.dims[B]}return n},t.prototype.toJSON=function(){return this.constructor.toObject(this,F.util.toJSONOptions)},t.getTypeUrl=function(t){return void 0===t&&(t="type.googleapis.com"),t+"/onnx.SparseTensorProto"},t}(),s.TensorShapeProto=function(){function t(t){if(this.dim=[],t)for(var e=Object.keys(t),n=0;n<e.length;++n)null!=t[e[n]]&&(this[e[n]]=t[e[n]])}return t.prototype.dim=i.emptyArray,t.create=function(e){return new t(e)},t.encode=function(t,e){if(e||(e=U.create()),null!=t.dim&&t.dim.length)for(var n=0;n<t.dim.length;++n)a.onnx.TensorShapeProto.Dimension.encode(t.dim[n],e.uint32(10).fork()).ldelim();return e},t.encodeDelimited=function(t,e){return this.encode(t,e).ldelim()},t.decode=function(t,e){t instanceof Q||(t=Q.create(t));for(var n=void 0===e?t.len:t.pos+e,B=new a.onnx.TensorShapeProto;t.pos<n;){var s=t.uint32();s>>>3==1?(B.dim&&B.dim.length||(B.dim=[]),B.dim.push(a.onnx.TensorShapeProto.Dimension.decode(t,t.uint32()))):t.skipType(7&s)}return B},t.decodeDelimited=function(t){return t instanceof Q||(t=new Q(t)),this.decode(t,t.uint32())},t.verify=function(t){if("object"!=typeof t||null===t)return"object expected";if(null!=t.dim&&t.hasOwnProperty("dim")){if(!Array.isArray(t.dim))return"dim: array expected";for(var e=0;e<t.dim.length;++e){var n=a.onnx.TensorShapeProto.Dimension.verify(t.dim[e]);if(n)return"dim."+n}}return null},t.fromObject=function(t){if(t instanceof a.onnx.TensorShapeProto)return t;var e=new a.onnx.TensorShapeProto;if(t.dim){if(!Array.isArray(t.dim))throw TypeError(".onnx.TensorShapeProto.dim: array expected");e.dim=[];for(var n=0;n<t.dim.length;++n){if("object"!=typeof t.dim[n])throw TypeError(".onnx.TensorShapeProto.dim: object expected");e.dim[n]=a.onnx.TensorShapeProto.Dimension.fromObject(t.dim[n])}}return e},t.toObject=function(t,e){e||(e={});var n={};if((e.arrays||e.defaults)&&(n.dim=[]),t.dim&&t.dim.length){n.dim=[];for(var B=0;B<t.dim.length;++B)n.dim[B]=a.onnx.TensorShapeProto.Dimension.toObject(t.dim[B],e)}return n},t.prototype.toJSON=function(){return this.constructor.toObject(this,F.util.toJSONOptions)},t.getTypeUrl=function(t){return void 0===t&&(t="type.googleapis.com"),t+"/onnx.TensorShapeProto"},t.Dimension=function(){function t(t){if(t)for(var e=Object.keys(t),n=0;n<e.length;++n)null!=t[e[n]]&&(this[e[n]]=t[e[n]])}var e;return t.prototype.dimValue=null,t.prototype.dimParam=null,t.prototype.denotation="",Object.defineProperty(t.prototype,"value",{get:i.oneOfGetter(e=["dimValue","dimParam"]),set:i.oneOfSetter(e)}),t.create=function(e){return new t(e)},t.encode=function(t,e){return e||(e=U.create()),null!=t.dimValue&&Object.hasOwnProperty.call(t,"dimValue")&&e.uint32(8).int64(t.dimValue),null!=t.dimParam&&Object.hasOwnProperty.call(t,"dimParam")&&e.uint32(18).string(t.dimParam),null!=t.denotation&&Object.hasOwnProperty.call(t,"denotation")&&e.uint32(26).string(t.denotation),e},t.encodeDelimited=function(t,e){return this.encode(t,e).ldelim()},t.decode=function(t,e){t instanceof Q||(t=Q.create(t));for(var n=void 0===e?t.len:t.pos+e,B=new a.onnx.TensorShapeProto.Dimension;t.pos<n;){var s=t.uint32();switch(s>>>3){case 1:B.dimValue=t.int64();break;case 2:B.dimParam=t.string();break;case 3:B.denotation=t.string();break;default:t.skipType(7&s)}}return B},t.decodeDelimited=function(t){return t instanceof Q||(t=new Q(t)),this.decode(t,t.uint32())},t.verify=function(t){if("object"!=typeof t||null===t)return"object expected";var e={};if(null!=t.dimValue&&t.hasOwnProperty("dimValue")&&(e.value=1,!(i.isInteger(t.dimValue)||t.dimValue&&i.isInteger(t.dimValue.low)&&i.isInteger(t.dimValue.high))))return"dimValue: integer|Long expected";if(null!=t.dimParam&&t.hasOwnProperty("dimParam")){if(1===e.value)return"value: multiple values";if(e.value=1,!i.isString(t.dimParam))return"dimParam: string expected"}return null!=t.denotation&&t.hasOwnProperty("denotation")&&!i.isString(t.denotation)?"denotation: string expected":null},t.fromObject=function(t){if(t instanceof a.onnx.TensorShapeProto.Dimension)return t;var e=new a.onnx.TensorShapeProto.Dimension;return null!=t.dimValue&&(i.Long?(e.dimValue=i.Long.fromValue(t.dimValue)).unsigned=!1:"string"==typeof t.dimValue?e.dimValue=parseInt(t.dimValue,10):"number"==typeof t.dimValue?e.dimValue=t.dimValue:"object"==typeof t.dimValue&&(e.dimValue=new i.LongBits(t.dimValue.low>>>0,t.dimValue.high>>>0).toNumber())),null!=t.dimParam&&(e.dimParam=String(t.dimParam)),null!=t.denotation&&(e.denotation=String(t.denotation)),e},t.toObject=function(t,e){e||(e={});var n={};return e.defaults&&(n.denotation=""),null!=t.dimValue&&t.hasOwnProperty("dimValue")&&("number"==typeof t.dimValue?n.dimValue=e.longs===String?String(t.dimValue):t.dimValue:n.dimValue=e.longs===String?i.Long.prototype.toString.call(t.dimValue):e.longs===Number?new i.LongBits(t.dimValue.low>>>0,t.dimValue.high>>>0).toNumber():t.dimValue,e.oneofs&&(n.value="dimValue")),null!=t.dimParam&&t.hasOwnProperty("dimParam")&&(n.dimParam=t.dimParam,e.oneofs&&(n.value="dimParam")),null!=t.denotation&&t.hasOwnProperty("denotation")&&(n.denotation=t.denotation),n},t.prototype.toJSON=function(){return this.constructor.toObject(this,F.util.toJSONOptions)},t.getTypeUrl=function(t){return void 0===t&&(t="type.googleapis.com"),t+"/onnx.TensorShapeProto.Dimension"},t}(),t}(),s.TypeProto=function(){function t(t){if(t)for(var e=Object.keys(t),n=0;n<e.length;++n)null!=t[e[n]]&&(this[e[n]]=t[e[n]])}var e;return t.prototype.tensorType=null,t.prototype.sequenceType=null,t.prototype.mapType=null,t.prototype.optionalType=null,t.prototype.sparseTensorType=null,t.prototype.denotation="",Object.defineProperty(t.prototype,"value",{get:i.oneOfGetter(e=["tensorType","sequenceType","mapType","optionalType","sparseTensorType"]),set:i.oneOfSetter(e)}),t.create=function(e){return new t(e)},t.encode=function(t,e){return e||(e=U.create()),null!=t.tensorType&&Object.hasOwnProperty.call(t,"tensorType")&&a.onnx.TypeProto.Tensor.encode(t.tensorType,e.uint32(10).fork()).ldelim(),null!=t.sequenceType&&Object.hasOwnProperty.call(t,"sequenceType")&&a.onnx.TypeProto.Sequence.encode(t.sequenceType,e.uint32(34).fork()).ldelim(),null!=t.mapType&&Object.hasOwnProperty.call(t,"mapType")&&a.onnx.TypeProto.Map.encode(t.mapType,e.uint32(42).fork()).ldelim(),null!=t.denotation&&Object.hasOwnProperty.call(t,"denotation")&&e.uint32(50).string(t.denotation),null!=t.sparseTensorType&&Object.hasOwnProperty.call(t,"sparseTensorType")&&a.onnx.TypeProto.SparseTensor.encode(t.sparseTensorType,e.uint32(66).fork()).ldelim(),null!=t.optionalType&&Object.hasOwnProperty.call(t,"optionalType")&&a.onnx.TypeProto.Optional.encode(t.optionalType,e.uint32(74).fork()).ldelim(),e},t.encodeDelimited=function(t,e){return this.encode(t,e).ldelim()},t.decode=function(t,e){t instanceof Q||(t=Q.create(t));for(var n=void 0===e?t.len:t.pos+e,B=new a.onnx.TypeProto;t.pos<n;){var s=t.uint32();switch(s>>>3){case 1:B.tensorType=a.onnx.TypeProto.Tensor.decode(t,t.uint32());break;case 4:B.sequenceType=a.onnx.TypeProto.Sequence.decode(t,t.uint32());break;case 5:B.mapType=a.onnx.TypeProto.Map.decode(t,t.uint32());break;case 9:B.optionalType=a.onnx.TypeProto.Optional.decode(t,t.uint32());break;case 8:B.sparseTensorType=a.onnx.TypeProto.SparseTensor.decode(t,t.uint32());break;case 6:B.denotation=t.string();break;default:t.skipType(7&s)}}return B},t.decodeDelimited=function(t){return t instanceof Q||(t=new Q(t)),this.decode(t,t.uint32())},t.verify=function(t){if("object"!=typeof t||null===t)return"object expected";var e={};if(null!=t.tensorType&&t.hasOwnProperty("tensorType")&&(e.value=1,n=a.onnx.TypeProto.Tensor.verify(t.tensorType)))return"tensorType."+n;if(null!=t.sequenceType&&t.hasOwnProperty("sequenceType")){if(1===e.value)return"value: multiple values";if(e.value=1,n=a.onnx.TypeProto.Sequence.verify(t.sequenceType))return"sequenceType."+n}if(null!=t.mapType&&t.hasOwnProperty("mapType")){if(1===e.value)return"value: multiple values";if(e.value=1,n=a.onnx.TypeProto.Map.verify(t.mapType))return"mapType."+n}if(null!=t.optionalType&&t.hasOwnProperty("optionalType")){if(1===e.value)return"value: multiple values";if(e.value=1,n=a.onnx.TypeProto.Optional.verify(t.optionalType))return"optionalType."+n}if(null!=t.sparseTensorType&&t.hasOwnProperty("sparseTensorType")){if(1===e.value)return"value: multiple values";var n;if(e.value=1,n=a.onnx.TypeProto.SparseTensor.verify(t.sparseTensorType))return"sparseTensorType."+n}return null!=t.denotation&&t.hasOwnProperty("denotation")&&!i.isString(t.denotation)?"denotation: string expected":null},t.fromObject=function(t){if(t instanceof a.onnx.TypeProto)return t;var e=new a.onnx.TypeProto;if(null!=t.tensorType){if("object"!=typeof t.tensorType)throw TypeError(".onnx.TypeProto.tensorType: object expected");e.tensorType=a.onnx.TypeProto.Tensor.fromObject(t.tensorType)}if(null!=t.sequenceType){if("object"!=typeof t.sequenceType)throw TypeError(".onnx.TypeProto.sequenceType: object expected");e.sequenceType=a.onnx.TypeProto.Sequence.fromObject(t.sequenceType)}if(null!=t.mapType){if("object"!=typeof t.mapType)throw TypeError(".onnx.TypeProto.mapType: object expected");e.mapType=a.onnx.TypeProto.Map.fromObject(t.mapType)}if(null!=t.optionalType){if("object"!=typeof t.optionalType)throw TypeError(".onnx.TypeProto.optionalType: object expected");e.optionalType=a.onnx.TypeProto.Optional.fromObject(t.optionalType)}if(null!=t.sparseTensorType){if("object"!=typeof t.sparseTensorType)throw TypeError(".onnx.TypeProto.sparseTensorType: object expected");e.sparseTensorType=a.onnx.TypeProto.SparseTensor.fromObject(t.sparseTensorType)}return null!=t.denotation&&(e.denotation=String(t.denotation)),e},t.toObject=function(t,e){e||(e={});var n={};return e.defaults&&(n.denotation=""),null!=t.tensorType&&t.hasOwnProperty("tensorType")&&(n.tensorType=a.onnx.TypeProto.Tensor.toObject(t.tensorType,e),e.oneofs&&(n.value="tensorType")),null!=t.sequenceType&&t.hasOwnProperty("sequenceType")&&(n.sequenceType=a.onnx.TypeProto.Sequence.toObject(t.sequenceType,e),e.oneofs&&(n.value="sequenceType")),null!=t.mapType&&t.hasOwnProperty("mapType")&&(n.mapType=a.onnx.TypeProto.Map.toObject(t.mapType,e),e.oneofs&&(n.value="mapType")),null!=t.denotation&&t.hasOwnProperty("denotation")&&(n.denotation=t.denotation),null!=t.sparseTensorType&&t.hasOwnProperty("sparseTensorType")&&(n.sparseTensorType=a.onnx.TypeProto.SparseTensor.toObject(t.sparseTensorType,e),e.oneofs&&(n.value="sparseTensorType")),null!=t.optionalType&&t.hasOwnProperty("optionalType")&&(n.optionalType=a.onnx.TypeProto.Optional.toObject(t.optionalType,e),e.oneofs&&(n.value="optionalType")),n},t.prototype.toJSON=function(){return this.constructor.toObject(this,F.util.toJSONOptions)},t.getTypeUrl=function(t){return void 0===t&&(t="type.googleapis.com"),t+"/onnx.TypeProto"},t.Tensor=function(){function t(t){if(t)for(var e=Object.keys(t),n=0;n<e.length;++n)null!=t[e[n]]&&(this[e[n]]=t[e[n]])}return t.prototype.elemType=0,t.prototype.shape=null,t.create=function(e){return new t(e)},t.encode=function(t,e){return e||(e=U.create()),null!=t.elemType&&Object.hasOwnProperty.call(t,"elemType")&&e.uint32(8).int32(t.elemType),null!=t.shape&&Object.hasOwnProperty.call(t,"shape")&&a.onnx.TensorShapeProto.encode(t.shape,e.uint32(18).fork()).ldelim(),e},t.encodeDelimited=function(t,e){return this.encode(t,e).ldelim()},t.decode=function(t,e){t instanceof Q||(t=Q.create(t));for(var n=void 0===e?t.len:t.pos+e,B=new a.onnx.TypeProto.Tensor;t.pos<n;){var s=t.uint32();switch(s>>>3){case 1:B.elemType=t.int32();break;case 2:B.shape=a.onnx.TensorShapeProto.decode(t,t.uint32());break;default:t.skipType(7&s)}}return B},t.decodeDelimited=function(t){return t instanceof Q||(t=new Q(t)),this.decode(t,t.uint32())},t.verify=function(t){if("object"!=typeof t||null===t)return"object expected";if(null!=t.elemType&&t.hasOwnProperty("elemType")&&!i.isInteger(t.elemType))return"elemType: integer expected";if(null!=t.shape&&t.hasOwnProperty("shape")){var e=a.onnx.TensorShapeProto.verify(t.shape);if(e)return"shape."+e}return null},t.fromObject=function(t){if(t instanceof a.onnx.TypeProto.Tensor)return t;var e=new a.onnx.TypeProto.Tensor;if(null!=t.elemType&&(e.elemType=0|t.elemType),null!=t.shape){if("object"!=typeof t.shape)throw TypeError(".onnx.TypeProto.Tensor.shape: object expected");e.shape=a.onnx.TensorShapeProto.fromObject(t.shape)}return e},t.toObject=function(t,e){e||(e={});var n={};return e.defaults&&(n.elemType=0,n.shape=null),null!=t.elemType&&t.hasOwnProperty("elemType")&&(n.elemType=t.elemType),null!=t.shape&&t.hasOwnProperty("shape")&&(n.shape=a.onnx.TensorShapeProto.toObject(t.shape,e)),n},t.prototype.toJSON=function(){return this.constructor.toObject(this,F.util.toJSONOptions)},t.getTypeUrl=function(t){return void 0===t&&(t="type.googleapis.com"),t+"/onnx.TypeProto.Tensor"},t}(),t.Sequence=function(){function t(t){if(t)for(var e=Object.keys(t),n=0;n<e.length;++n)null!=t[e[n]]&&(this[e[n]]=t[e[n]])}return t.prototype.elemType=null,t.create=function(e){return new t(e)},t.encode=function(t,e){return e||(e=U.create()),null!=t.elemType&&Object.hasOwnProperty.call(t,"elemType")&&a.onnx.TypeProto.encode(t.elemType,e.uint32(10).fork()).ldelim(),e},t.encodeDelimited=function(t,e){return this.encode(t,e).ldelim()},t.decode=function(t,e){t instanceof Q||(t=Q.create(t));for(var n=void 0===e?t.len:t.pos+e,B=new a.onnx.TypeProto.Sequence;t.pos<n;){var s=t.uint32();s>>>3==1?B.elemType=a.onnx.TypeProto.decode(t,t.uint32()):t.skipType(7&s)}return B},t.decodeDelimited=function(t){return t instanceof Q||(t=new Q(t)),this.decode(t,t.uint32())},t.verify=function(t){if("object"!=typeof t||null===t)return"object expected";if(null!=t.elemType&&t.hasOwnProperty("elemType")){var e=a.onnx.TypeProto.verify(t.elemType);if(e)return"elemType."+e}return null},t.fromObject=function(t){if(t instanceof a.onnx.TypeProto.Sequence)return t;var e=new a.onnx.TypeProto.Sequence;if(null!=t.elemType){if("object"!=typeof t.elemType)throw TypeError(".onnx.TypeProto.Sequence.elemType: object expected");e.elemType=a.onnx.TypeProto.fromObject(t.elemType)}return e},t.toObject=function(t,e){e||(e={});var n={};return e.defaults&&(n.elemType=null),null!=t.elemType&&t.hasOwnProperty("elemType")&&(n.elemType=a.onnx.TypeProto.toObject(t.elemType,e)),n},t.prototype.toJSON=function(){return this.constructor.toObject(this,F.util.toJSONOptions)},t.getTypeUrl=function(t){return void 0===t&&(t="type.googleapis.com"),t+"/onnx.TypeProto.Sequence"},t}(),t.Map=function(){function t(t){if(t)for(var e=Object.keys(t),n=0;n<e.length;++n)null!=t[e[n]]&&(this[e[n]]=t[e[n]])}return t.prototype.keyType=0,t.prototype.valueType=null,t.create=function(e){return new t(e)},t.encode=function(t,e){return e||(e=U.create()),null!=t.keyType&&Object.hasOwnProperty.call(t,"keyType")&&e.uint32(8).int32(t.keyType),null!=t.valueType&&Object.hasOwnProperty.call(t,"valueType")&&a.onnx.TypeProto.encode(t.valueType,e.uint32(18).fork()).ldelim(),e},t.encodeDelimited=function(t,e){return this.encode(t,e).ldelim()},t.decode=function(t,e){t instanceof Q||(t=Q.create(t));for(var n=void 0===e?t.len:t.pos+e,B=new a.onnx.TypeProto.Map;t.pos<n;){var s=t.uint32();switch(s>>>3){case 1:B.keyType=t.int32();break;case 2:B.valueType=a.onnx.TypeProto.decode(t,t.uint32());break;default:t.skipType(7&s)}}return B},t.decodeDelimited=function(t){return t instanceof Q||(t=new Q(t)),this.decode(t,t.uint32())},t.verify=function(t){if("object"!=typeof t||null===t)return"object expected";if(null!=t.keyType&&t.hasOwnProperty("keyType")&&!i.isInteger(t.keyType))return"keyType: integer expected";if(null!=t.valueType&&t.hasOwnProperty("valueType")){var e=a.onnx.TypeProto.verify(t.valueType);if(e)return"valueType."+e}return null},t.fromObject=function(t){if(t instanceof a.onnx.TypeProto.Map)return t;var e=new a.onnx.TypeProto.Map;if(null!=t.keyType&&(e.keyType=0|t.keyType),null!=t.valueType){if("object"!=typeof t.valueType)throw TypeError(".onnx.TypeProto.Map.valueType: object expected");e.valueType=a.onnx.TypeProto.fromObject(t.valueType)}return e},t.toObject=function(t,e){e||(e={});var n={};return e.defaults&&(n.keyType=0,n.valueType=null),null!=t.keyType&&t.hasOwnProperty("keyType")&&(n.keyType=t.keyType),null!=t.valueType&&t.hasOwnProperty("valueType")&&(n.valueType=a.onnx.TypeProto.toObject(t.valueType,e)),n},t.prototype.toJSON=function(){return this.constructor.toObject(this,F.util.toJSONOptions)},t.getTypeUrl=function(t){return void 0===t&&(t="type.googleapis.com"),t+"/onnx.TypeProto.Map"},t}(),t.Optional=function(){function t(t){if(t)for(var e=Object.keys(t),n=0;n<e.length;++n)null!=t[e[n]]&&(this[e[n]]=t[e[n]])}return t.prototype.elemType=null,t.create=function(e){return new t(e)},t.encode=function(t,e){return e||(e=U.create()),null!=t.elemType&&Object.hasOwnProperty.call(t,"elemType")&&a.onnx.TypeProto.encode(t.elemType,e.uint32(10).fork()).ldelim(),e},t.encodeDelimited=function(t,e){return this.encode(t,e).ldelim()},t.decode=function(t,e){t instanceof Q||(t=Q.create(t));for(var n=void 0===e?t.len:t.pos+e,B=new a.onnx.TypeProto.Optional;t.pos<n;){var s=t.uint32();s>>>3==1?B.elemType=a.onnx.TypeProto.decode(t,t.uint32()):t.skipType(7&s)}return B},t.decodeDelimited=function(t){return t instanceof Q||(t=new Q(t)),this.decode(t,t.uint32())},t.verify=function(t){if("object"!=typeof t||null===t)return"object expected";if(null!=t.elemType&&t.hasOwnProperty("elemType")){var e=a.onnx.TypeProto.verify(t.elemType);if(e)return"elemType."+e}return null},t.fromObject=function(t){if(t instanceof a.onnx.TypeProto.Optional)return t;var e=new a.onnx.TypeProto.Optional;if(null!=t.elemType){if("object"!=typeof t.elemType)throw TypeError(".onnx.TypeProto.Optional.elemType: object expected");e.elemType=a.onnx.TypeProto.fromObject(t.elemType)}return e},t.toObject=function(t,e){e||(e={});var n={};return e.defaults&&(n.elemType=null),null!=t.elemType&&t.hasOwnProperty("elemType")&&(n.elemType=a.onnx.TypeProto.toObject(t.elemType,e)),n},t.prototype.toJSON=function(){return this.constructor.toObject(this,F.util.toJSONOptions)},t.getTypeUrl=function(t){return void 0===t&&(t="type.googleapis.com"),t+"/onnx.TypeProto.Optional"},t}(),t.SparseTensor=function(){function t(t){if(t)for(var e=Object.keys(t),n=0;n<e.length;++n)null!=t[e[n]]&&(this[e[n]]=t[e[n]])}return t.prototype.elemType=0,t.prototype.shape=null,t.create=function(e){return new t(e)},t.encode=function(t,e){return e||(e=U.create()),null!=t.elemType&&Object.hasOwnProperty.call(t,"elemType")&&e.uint32(8).int32(t.elemType),null!=t.shape&&Object.hasOwnProperty.call(t,"shape")&&a.onnx.TensorShapeProto.encode(t.shape,e.uint32(18).fork()).ldelim(),e},t.encodeDelimited=function(t,e){return this.encode(t,e).ldelim()},t.decode=function(t,e){t instanceof Q||(t=Q.create(t));for(var n=void 0===e?t.len:t.pos+e,B=new a.onnx.TypeProto.SparseTensor;t.pos<n;){var s=t.uint32();switch(s>>>3){case 1:B.elemType=t.int32();break;case 2:B.shape=a.onnx.TensorShapeProto.decode(t,t.uint32());break;default:t.skipType(7&s)}}return B},t.decodeDelimited=function(t){return t instanceof Q||(t=new Q(t)),this.decode(t,t.uint32())},t.verify=function(t){if("object"!=typeof t||null===t)return"object expected";if(null!=t.elemType&&t.hasOwnProperty("elemType")&&!i.isInteger(t.elemType))return"elemType: integer expected";if(null!=t.shape&&t.hasOwnProperty("shape")){var e=a.onnx.TensorShapeProto.verify(t.shape);if(e)return"shape."+e}return null},t.fromObject=function(t){if(t instanceof a.onnx.TypeProto.SparseTensor)return t;var e=new a.onnx.TypeProto.SparseTensor;if(null!=t.elemType&&(e.elemType=0|t.elemType),null!=t.shape){if("object"!=typeof t.shape)throw TypeError(".onnx.TypeProto.SparseTensor.shape: object expected");e.shape=a.onnx.TensorShapeProto.fromObject(t.shape)}return e},t.toObject=function(t,e){e||(e={});var n={};return e.defaults&&(n.elemType=0,n.shape=null),null!=t.elemType&&t.hasOwnProperty("elemType")&&(n.elemType=t.elemType),null!=t.shape&&t.hasOwnProperty("shape")&&(n.shape=a.onnx.TensorShapeProto.toObject(t.shape,e)),n},t.prototype.toJSON=function(){return this.constructor.toObject(this,F.util.toJSONOptions)},t.getTypeUrl=function(t){return void 0===t&&(t="type.googleapis.com"),t+"/onnx.TypeProto.SparseTensor"},t}(),t}(),s.OperatorSetIdProto=function(){function t(t){if(t)for(var e=Object.keys(t),n=0;n<e.length;++n)null!=t[e[n]]&&(this[e[n]]=t[e[n]])}return t.prototype.domain="",t.prototype.version=i.Long?i.Long.fromBits(0,0,!1):0,t.create=function(e){return new t(e)},t.encode=function(t,e){return e||(e=U.create()),null!=t.domain&&Object.hasOwnProperty.call(t,"domain")&&e.uint32(10).string(t.domain),null!=t.version&&Object.hasOwnProperty.call(t,"version")&&e.uint32(16).int64(t.version),e},t.encodeDelimited=function(t,e){return this.encode(t,e).ldelim()},t.decode=function(t,e){t instanceof Q||(t=Q.create(t));for(var n=void 0===e?t.len:t.pos+e,B=new a.onnx.OperatorSetIdProto;t.pos<n;){var s=t.uint32();switch(s>>>3){case 1:B.domain=t.string();break;case 2:B.version=t.int64();break;default:t.skipType(7&s)}}return B},t.decodeDelimited=function(t){return t instanceof Q||(t=new Q(t)),this.decode(t,t.uint32())},t.verify=function(t){return"object"!=typeof t||null===t?"object expected":null!=t.domain&&t.hasOwnProperty("domain")&&!i.isString(t.domain)?"domain: string expected":null!=t.version&&t.hasOwnProperty("version")&&!(i.isInteger(t.version)||t.version&&i.isInteger(t.version.low)&&i.isInteger(t.version.high))?"version: integer|Long expected":null},t.fromObject=function(t){if(t instanceof a.onnx.OperatorSetIdProto)return t;var e=new a.onnx.OperatorSetIdProto;return null!=t.domain&&(e.domain=String(t.domain)),null!=t.version&&(i.Long?(e.version=i.Long.fromValue(t.version)).unsigned=!1:"string"==typeof t.version?e.version=parseInt(t.version,10):"number"==typeof t.version?e.version=t.version:"object"==typeof t.version&&(e.version=new i.LongBits(t.version.low>>>0,t.version.high>>>0).toNumber())),e},t.toObject=function(t,e){e||(e={});var n={};if(e.defaults)if(n.domain="",i.Long){var B=new i.Long(0,0,!1);n.version=e.longs===String?B.toString():e.longs===Number?B.toNumber():B}else n.version=e.longs===String?"0":0;return null!=t.domain&&t.hasOwnProperty("domain")&&(n.domain=t.domain),null!=t.version&&t.hasOwnProperty("version")&&("number"==typeof t.version?n.version=e.longs===String?String(t.version):t.version:n.version=e.longs===String?i.Long.prototype.toString.call(t.version):e.longs===Number?new i.LongBits(t.version.low>>>0,t.version.high>>>0).toNumber():t.version),n},t.prototype.toJSON=function(){return this.constructor.toObject(this,F.util.toJSONOptions)},t.getTypeUrl=function(t){return void 0===t&&(t="type.googleapis.com"),t+"/onnx.OperatorSetIdProto"},t}(),s.OperatorStatus=function(){var t={},e=Object.create(t);return e[t[0]="EXPERIMENTAL"]=0,e[t[1]="STABLE"]=1,e}(),s.FunctionProto=function(){function t(t){if(this.input=[],this.output=[],this.attribute=[],this.attributeProto=[],this.node=[],this.opsetImport=[],t)for(var e=Object.keys(t),n=0;n<e.length;++n)null!=t[e[n]]&&(this[e[n]]=t[e[n]])}return t.prototype.name="",t.prototype.input=i.emptyArray,t.prototype.output=i.emptyArray,t.prototype.attribute=i.emptyArray,t.prototype.attributeProto=i.emptyArray,t.prototype.node=i.emptyArray,t.prototype.docString="",t.prototype.opsetImport=i.emptyArray,t.prototype.domain="",t.create=function(e){return new t(e)},t.encode=function(t,e){if(e||(e=U.create()),null!=t.name&&Object.hasOwnProperty.call(t,"name")&&e.uint32(10).string(t.name),null!=t.input&&t.input.length)for(var n=0;n<t.input.length;++n)e.uint32(34).string(t.input[n]);if(null!=t.output&&t.output.length)for(n=0;n<t.output.length;++n)e.uint32(42).string(t.output[n]);if(null!=t.attribute&&t.attribute.length)for(n=0;n<t.attribute.length;++n)e.uint32(50).string(t.attribute[n]);if(null!=t.node&&t.node.length)for(n=0;n<t.node.length;++n)a.onnx.NodeProto.encode(t.node[n],e.uint32(58).fork()).ldelim();if(null!=t.docString&&Object.hasOwnProperty.call(t,"docString")&&e.uint32(66).string(t.docString),null!=t.opsetImport&&t.opsetImport.length)for(n=0;n<t.opsetImport.length;++n)a.onnx.OperatorSetIdProto.encode(t.opsetImport[n],e.uint32(74).fork()).ldelim();if(null!=t.domain&&Object.hasOwnProperty.call(t,"domain")&&e.uint32(82).string(t.domain),null!=t.attributeProto&&t.attributeProto.length)for(n=0;n<t.attributeProto.length;++n)a.onnx.AttributeProto.encode(t.attributeProto[n],e.uint32(90).fork()).ldelim();return e},t.encodeDelimited=function(t,e){return this.encode(t,e).ldelim()},t.decode=function(t,e){t instanceof Q||(t=Q.create(t));for(var n=void 0===e?t.len:t.pos+e,B=new a.onnx.FunctionProto;t.pos<n;){var s=t.uint32();switch(s>>>3){case 1:B.name=t.string();break;case 4:B.input&&B.input.length||(B.input=[]),B.input.push(t.string());break;case 5:B.output&&B.output.length||(B.output=[]),B.output.push(t.string());break;case 6:B.attribute&&B.attribute.length||(B.attribute=[]),B.attribute.push(t.string());break;case 11:B.attributeProto&&B.attributeProto.length||(B.attributeProto=[]),B.attributeProto.push(a.onnx.AttributeProto.decode(t,t.uint32()));break;case 7:B.node&&B.node.length||(B.node=[]),B.node.push(a.onnx.NodeProto.decode(t,t.uint32()));break;case 8:B.docString=t.string();break;case 9:B.opsetImport&&B.opsetImport.length||(B.opsetImport=[]),B.opsetImport.push(a.onnx.OperatorSetIdProto.decode(t,t.uint32()));break;case 10:B.domain=t.string();break;default:t.skipType(7&s)}}return B},t.decodeDelimited=function(t){return t instanceof Q||(t=new Q(t)),this.decode(t,t.uint32())},t.verify=function(t){if("object"!=typeof t||null===t)return"object expected";if(null!=t.name&&t.hasOwnProperty("name")&&!i.isString(t.name))return"name: string expected";if(null!=t.input&&t.hasOwnProperty("input")){if(!Array.isArray(t.input))return"input: array expected";for(var e=0;e<t.input.length;++e)if(!i.isString(t.input[e]))return"input: string[] expected"}if(null!=t.output&&t.hasOwnProperty("output")){if(!Array.isArray(t.output))return"output: array expected";for(e=0;e<t.output.length;++e)if(!i.isString(t.output[e]))return"output: string[] expected"}if(null!=t.attribute&&t.hasOwnProperty("attribute")){if(!Array.isArray(t.attribute))return"attribute: array expected";for(e=0;e<t.attribute.length;++e)if(!i.isString(t.attribute[e]))return"attribute: string[] expected"}if(null!=t.attributeProto&&t.hasOwnProperty("attributeProto")){if(!Array.isArray(t.attributeProto))return"attributeProto: array expected";for(e=0;e<t.attributeProto.length;++e)if(n=a.onnx.AttributeProto.verify(t.attributeProto[e]))return"attributeProto."+n}if(null!=t.node&&t.hasOwnProperty("node")){if(!Array.isArray(t.node))return"node: array expected";for(e=0;e<t.node.length;++e)if(n=a.onnx.NodeProto.verify(t.node[e]))return"node."+n}if(null!=t.docString&&t.hasOwnProperty("docString")&&!i.isString(t.docString))return"docString: string expected";if(null!=t.opsetImport&&t.hasOwnProperty("opsetImport")){if(!Array.isArray(t.opsetImport))return"opsetImport: array expected";for(e=0;e<t.opsetImport.length;++e){var n;if(n=a.onnx.OperatorSetIdProto.verify(t.opsetImport[e]))return"opsetImport."+n}}return null!=t.domain&&t.hasOwnProperty("domain")&&!i.isString(t.domain)?"domain: string expected":null},t.fromObject=function(t){if(t instanceof a.onnx.FunctionProto)return t;var e=new a.onnx.FunctionProto;if(null!=t.name&&(e.name=String(t.name)),t.input){if(!Array.isArray(t.input))throw TypeError(".onnx.FunctionProto.input: array expected");e.input=[];for(var n=0;n<t.input.length;++n)e.input[n]=String(t.input[n])}if(t.output){if(!Array.isArray(t.output))throw TypeError(".onnx.FunctionProto.output: array expected");for(e.output=[],n=0;n<t.output.length;++n)e.output[n]=String(t.output[n])}if(t.attribute){if(!Array.isArray(t.attribute))throw TypeError(".onnx.FunctionProto.attribute: array expected");for(e.attribute=[],n=0;n<t.attribute.length;++n)e.attribute[n]=String(t.attribute[n])}if(t.attributeProto){if(!Array.isArray(t.attributeProto))throw TypeError(".onnx.FunctionProto.attributeProto: array expected");for(e.attributeProto=[],n=0;n<t.attributeProto.length;++n){if("object"!=typeof t.attributeProto[n])throw TypeError(".onnx.FunctionProto.attributeProto: object expected");e.attributeProto[n]=a.onnx.AttributeProto.fromObject(t.attributeProto[n])}}if(t.node){if(!Array.isArray(t.node))throw TypeError(".onnx.FunctionProto.node: array expected");for(e.node=[],n=0;n<t.node.length;++n){if("object"!=typeof t.node[n])throw TypeError(".onnx.FunctionProto.node: object expected");e.node[n]=a.onnx.NodeProto.fromObject(t.node[n])}}if(null!=t.docString&&(e.docString=String(t.docString)),t.opsetImport){if(!Array.isArray(t.opsetImport))throw TypeError(".onnx.FunctionProto.opsetImport: array expected");for(e.opsetImport=[],n=0;n<t.opsetImport.length;++n){if("object"!=typeof t.opsetImport[n])throw TypeError(".onnx.FunctionProto.opsetImport: object expected");e.opsetImport[n]=a.onnx.OperatorSetIdProto.fromObject(t.opsetImport[n])}}return null!=t.domain&&(e.domain=String(t.domain)),e},t.toObject=function(t,e){e||(e={});var n={};if((e.arrays||e.defaults)&&(n.input=[],n.output=[],n.attribute=[],n.node=[],n.opsetImport=[],n.attributeProto=[]),e.defaults&&(n.name="",n.docString="",n.domain=""),null!=t.name&&t.hasOwnProperty("name")&&(n.name=t.name),t.input&&t.input.length){n.input=[];for(var B=0;B<t.input.length;++B)n.input[B]=t.input[B]}if(t.output&&t.output.length)for(n.output=[],B=0;B<t.output.length;++B)n.output[B]=t.output[B];if(t.attribute&&t.attribute.length)for(n.attribute=[],B=0;B<t.attribute.length;++B)n.attribute[B]=t.attribute[B];if(t.node&&t.node.length)for(n.node=[],B=0;B<t.node.length;++B)n.node[B]=a.onnx.NodeProto.toObject(t.node[B],e);if(null!=t.docString&&t.hasOwnProperty("docString")&&(n.docString=t.docString),t.opsetImport&&t.opsetImport.length)for(n.opsetImport=[],B=0;B<t.opsetImport.length;++B)n.opsetImport[B]=a.onnx.OperatorSetIdProto.toObject(t.opsetImport[B],e);if(null!=t.domain&&t.hasOwnProperty("domain")&&(n.domain=t.domain),t.attributeProto&&t.attributeProto.length)for(n.attributeProto=[],B=0;B<t.attributeProto.length;++B)n.attributeProto[B]=a.onnx.AttributeProto.toObject(t.attributeProto[B],e);return n},t.prototype.toJSON=function(){return this.constructor.toObject(this,F.util.toJSONOptions)},t.getTypeUrl=function(t){return void 0===t&&(t="type.googleapis.com"),t+"/onnx.FunctionProto"},t}(),s),e.exports=a}}),import_onnx,ArrayUtil,MatMulUtil,BroadcastUtil,GemmUtil,ProtoUtil,LongUtil,ShapeUtil,SplitUtil,PoolConvUtil,MIN_CLIP,MAX_CLIP;function assert(t,e){if(!t)throw new Error("string"==typeof e?e:e())}function decodeUtf8String(t){return(new TextDecoder).decode(t)}var init_util=__esm({"web/lib/onnxjs/util.ts"(){init_flatbuffers(),init_long(),import_onnx=__toESM(require_onnx()),init_tensor2(),ArrayUtil=class{static arraysEqual(t,e){if(t.length!==e.length)return!1;for(let n=0;n<t.length;n++)if(t[n]!==e[n])return!1;return!0}},MatMulUtil=class{static preprocessInputShapes(t,e){return[1===t.length?[1,t[0]]:t,1===e.length?[e[0],1]:e]}static postprocessOutputShape(t,e,n){1===e&&t.splice(t.length-2,1),1===n&&t.pop()}static calcMatMulShape(t,e){return t[1]!==e[0]?void 0:[t[0],e[1]]}},BroadcastUtil=class t{static calcShape(t,e,n=!1){const B=t.length,s=e.length;if(0===B)return e;if(0===s)return t;const F=Math.max(t.length,e.length),Q=new Array(F);if(n){if(B<2||s<2)return;const n=MatMulUtil.calcMatMulShape([t[B-2],t[B-1]],[e[s-2],e[s-1]]);if(void 0===n)return;[Q[F-2],Q[F-1]]=n}for(let U=n?3:1;U<=F;U++){const n=B-U<0?1:t[B-U],i=s-U<0?1:e[s-U];if(n!==i&&n>1&&i>1)return;Q[F-U]=Math.max(n,i)}return Q}static index(e,n){const B=new Array(n.length);return t.fillIndex(e,n,B),B}static fillIndex(t,e,n){const B=t.length-e.length;for(let s=0;s<e.length;s++)n[s]=t[B+s]%e[s]}static calc(e,n,B,s,F){const Q=t.calcShape(e.dims,n.dims);if(Q){if(s&&!ShapeUtil.areEqual(Q,e.dims))return;const U=ShapeUtil.size(Q),i=s?e:new Tensor3(Q,F||e.type);if(0===Q.length)i.set([],B(e.get([]),n.get([])));else{const s=new Array(Q.length),F=new Array(e.dims.length),a=new Array(n.dims.length);let l,c=0,g=0,d=!1,I=!1;0===e.dims.length&&(c=e.get([]),d=!0),0===n.dims.length&&(g=n.get([]),I=!0);for(let o=0;o<U;o++){l=o;for(let t=Q.length-1;t>=0;t--)s[t]=l%Q[t],l=Math.floor(l/Q[t]);d||(t.fillIndex(s,e.dims,F),c=e.get(F)),I||(t.fillIndex(s,n.dims,a),g=n.get(a)),i.set(s,B(c,g))}}return i}}static isValidBroadcast(t,e){const n=t.length,B=e.length;if(n>B)return!1;for(let s=1;s<=n;s++)if(1!==t[n-s]&&t[n-s]!==e[B-s])return!1;return!0}static getBroadcastDims(t,e){const n=t.length,B=[];for(let s=0;s<n;s++){const F=n-1-s,Q=t[F]||1;(e[e.length-1-s]||1)>1&&1===Q&&B.unshift(F)}return B}},GemmUtil=class{static getShapeOfGemmResult(t,e,n,B,s){if(2!==t.length||2!==n.length)throw new Error("shape need to be of size 2");let F,Q,U;e?(F=t[1],Q=t[0]):(F=t[0],Q=t[1]);let i=-1;if(B?(U=n[0],i=1):(U=n[1],i=0),n[i]!==Q)throw new Error("dimension mismatch");if(F<=0||U<=0||Q<=0)throw new Error("invalid shape specified");if(s&&!BroadcastUtil.isValidBroadcast(s,[F,U]))throw new Error("gemm: invalid bias shape for broadcast");return[F,U,Q]}},ProtoUtil=class t{static tensorDataTypeFromProto(t){switch(t){case import_onnx.onnx.TensorProto.DataType.INT8:return"int8";case import_onnx.onnx.TensorProto.DataType.UINT8:return"uint8";case import_onnx.onnx.TensorProto.DataType.BOOL:return"bool";case import_onnx.onnx.TensorProto.DataType.INT16:return"int16";case import_onnx.onnx.TensorProto.DataType.UINT16:return"uint16";case import_onnx.onnx.TensorProto.DataType.INT32:return"int32";case import_onnx.onnx.TensorProto.DataType.UINT32:return"uint32";case import_onnx.onnx.TensorProto.DataType.FLOAT:return"float32";case import_onnx.onnx.TensorProto.DataType.DOUBLE:return"float64";case import_onnx.onnx.TensorProto.DataType.STRING:return"string";case import_onnx.onnx.TensorProto.DataType.INT64:return"int32";case import_onnx.onnx.TensorProto.DataType.UINT64:return"uint32";default:throw new Error(`unsupported data type: ${import_onnx.onnx.TensorProto.DataType[t]}`)}}static tensorDataTypeStringToEnum(t){switch(t){case"int8":return import_onnx.onnx.TensorProto.DataType.INT8;case"uint8":return import_onnx.onnx.TensorProto.DataType.UINT8;case"bool":return import_onnx.onnx.TensorProto.DataType.BOOL;case"int16":return import_onnx.onnx.TensorProto.DataType.INT16;case"uint16":return import_onnx.onnx.TensorProto.DataType.UINT16;case"int32":return import_onnx.onnx.TensorProto.DataType.INT32;case"uint32":return import_onnx.onnx.TensorProto.DataType.UINT32;case"float32":return import_onnx.onnx.TensorProto.DataType.FLOAT;case"float64":return import_onnx.onnx.TensorProto.DataType.DOUBLE;case"string":return import_onnx.onnx.TensorProto.DataType.STRING;case"int64":return import_onnx.onnx.TensorProto.DataType.INT64;case"uint64":return import_onnx.onnx.TensorProto.DataType.UINT64;default:throw new Error(`unsupported data type: ${t}`)}}static tensorDimsFromProto(t){return t.map((t=>long_default.isLong(t)?t.toNumber():t))}static tensorValueTypeFromProto(e){return{tensorType:t.tensorDataTypeFromProto(e.elemType),shape:{dims:t.tensorDimsFromProto(e.shape.dim.map((t=>t.dimValue)))}}}static tensorDimsFromORTFormat(t){const e=[];for(let n=0;n<t.dimsLength();n++)e.push(LongUtil.longToNumber(t.dims(n)));return e}static tensorAttributesFromORTFormat(t){const e=[];for(let n=0;n<t.attributesLength();n++)e.push(t.attributes(n));return e}},LongUtil=class{static longToNumber(t,e){return long_default.isLong(t)?t.toNumber():t instanceof flatbuffers.Long?long_default.fromValue({low:t.low,high:t.high,unsigned:e??!1}).toNumber():t}static isLong(t){return long_default.isLong(t)||t instanceof flatbuffers.Long}},ShapeUtil=class t{static size(e){return t.getSizeFromDimensionRange(e,0,e.length)}static sizeFromDimension(e,n){if(n<0||n>e.length)throw new Error(`invalid dimension of ${n} for sizeFromDimension as Tensor has ${e.length} dimensions.`);return t.getSizeFromDimensionRange(e,n,e.length)}static sizeToDimension(e,n){if(n<0||n>e.length)throw new Error(`invalid dimension of ${n} for sizeToDimension as Tensor has ${e.length} dimensions.`);return t.getSizeFromDimensionRange(e,0,n)}static getSizeFromDimensionRange(t,e,n){let B=1;for(let s=e;s<n;s++){if(t[s]<=0)throw new Error("cannot get valid size from specified dimension range. Most likely the range contains 0 or negative values in them.");B*=t[s]}return B}static computeStrides(t){const e=t.length;if(0===e)return[];if(1===e)return[1];const n=new Array(e);n[e-1]=1,n[e-2]=t[e-1];for(let B=e-3;B>=0;--B)n[B]=n[B+1]*t[B+1];return n}static transpose(t){return t.slice().reverse()}static indicesToOffset(t,e,n){void 0===n&&(n=t.length);let B=0;for(let s=0;s<n;++s)B+=e[s]*t[s];return B}static offsetToIndices(t,e){const n=e.length;if(0===n)return[];if(1===n)return[t*e[0]];const B=new Array(e.length);for(let n=0;n<B.length-1;++n)B[n]=Math.floor(t/e[n]),t-=B[n]*e[n];return B[B.length-1]=t,B}static normalizeAxis(t,e){if(t<-e&&t>=e)throw new Error("unsupported axis for this operation.");return t<0?t+e:t}static normalizeAxes(t,e){return t.map((t=>this.normalizeAxis(t,e)))}static incrementIndex(t,e,n){if(0===e.length||0===t.length)throw new Error("Index incrementing unsupported for scalar Tensor");if(void 0===n)n=e.length;else if(n<=0||n>e.length)throw new Error("Incorrect axis to increment on");for(let B=n-1;B>=0&&(t[B]++,!(t[B]<e[B]));--B)t[B]=0}static calculateReshapedDims(e,n){if(0===n.length){if(0===e.length||1===t.size(e))return[];throw new Error("cannot reshape to a scalar Tensor")}const B=n.length,s=new Array(B);let F=-1,Q=1;for(let t=0;t<B;t++){if(n[t]<-1)throw new Error("a dimension in shape hints cannot be less than -1");if(-1===n[t]){if(-1!==F)throw new Error("at most one dimension in shape hints can be -1");F=t}else{if(0===n[t]){if(t>=e.length)throw new Error("the dimension with value zero exceeds the dimension size of the input tensor");s[t]=e[t]}else s[t]=n[t];Q*=s[t]}}const U=t.size(e);if(-1!==F){if(U%Q!=0)throw new Error(`the input tensor cannot be reshaped to the requested shape. Input shape: [${e}] Output shape: [${n}]`);s[F]=U/Q}else if(Q!==U)throw new Error("reshapedDims and originalDims don't have matching sizes");return s}static sortBasedOnPerm(t,e){return e?e.map((e=>t[e])):t.slice().reverse()}static padShape(t,e){const n=t.length;return t.map(((t,B)=>t+e[B]+e[B+n]))}static areEqual(t,e){return t.length===e.length&&t.every(((t,n)=>t===e[n]))}static validateDimsAndCalcSize(t){if(t.length>6)throw new TypeError("Only rank 0 to 6 is supported for tensor shape.");let e=1;for(const n of t){if(!Number.isInteger(n))throw new TypeError(`Invalid shape: ${n} is not an integer`);if(n<0||n>2147483647)throw new TypeError(`Invalid shape: length ${n} is not allowed`);e*=n}return e}static flattenShape(t,e){e<0&&(e+=t.length);const n=t.reduce(((t,e)=>t*e),1),B=t.slice(e).reduce(((t,e)=>t*e),1);return[n/B,B]}static squeezeShape(e,n){const B=new Array;n=t.normalizeAxes(n,e.length);for(let t=0;t<e.length;t++){const s=n.indexOf(t)>=0;if(s&&1!==e[t])throw new Error("squeeze an axis of size different than 1");(0===n.length&&e[t]>1||n.length>0&&!s)&&B.push(e[t])}return B}static unsqueezeShape(e,n){const B=new Array(e.length+n.length);B.fill(0);for(let e=0;e<n.length;e++){const s=t.normalizeAxis(n[e],B.length);if(s>=B.length)throw new Error("'axes' has an out of range axis");if(0!==B[s])throw new Error("'axes' has a duplicate axis");B[s]=1}let s=0;for(let t=0;t<B.length;t++)0===B[t]&&(B[t]=e[s++]);if(s!==e.length)throw new Error("the unsqueezed dimension could not be established");return B}},SplitUtil=class t{static splitShape(e,n,B,s){if(0===B.length){if(!s)throw new Error("need to know number of outputs when the 'split' attribute is not specified");t.determineSplit(e[n],s,B)}const F=[],Q=[0];for(let t=0;t<B.length;++t){0!==t&&Q.push(Q[t-1]+B[t-1]);const s=e.slice();s[n]=B[t],F.push(s)}return[F,Q]}static determineSplit(t,e,n){if(t%e!=0)throw new Error("cannot split tensor to equal sized parts");for(let B=0;B<e;++B)n.push(t/e)}},PoolConvUtil=class t{static adjustPoolAttributes(t,e,n,B,s,F){if(!t&&n.length!==e.length-2)throw new Error("length of specified kernel shapes should be 2 less than length of input dimensions");if(t)for(let t=0;t<e.length-2;t++)t>=n.length?n.push(e[t+2]):n[t]=e[t+2];for(let t=0;t<n.length;t++)if(t<B.length){if(B[t]<0)throw new Error("strides should be greater than or equal to 1")}else B.push(1);for(let t=0;t<n.length;t++)if(t<s.length){if(s[t]<0)throw new Error("dilations should be greater than or equal to 1")}else s.push(1);for(let t=0;t<2*n.length;t++)if(t<F.length){if(F[t]<0)throw new Error("pad should be greater than or equal to 1")}else F.push(0);for(let t=0;t<n.length;t++){if(n[t]<=0)throw new Error("kernel shapes need to be greater than 0");if(F[t]>=n[t]||F[t+n.length]>=n[t])throw new Error("pads should be smaller than kernel")}}static adjustPadsBasedOnAutoPad(e,n,B,s,F,Q){if(Q){if(F.length!==2*(e.length-2))throw new Error("length of pads should be twice the length of data dimensions");if(n.length!==e.length-2)throw new Error("length of strides should be the length of data dimensions");if(s.length!==e.length-2)throw new Error("length of kernel shapes should be the length of data dimensions");for(let U=0;U<e.length-2;U++)t.adjustPadAndReturnShape(e[U+2],n[U],B[U],s[U],F,U,U+e.length-2,Q)}}static computePoolOutputShape(e,n,B,s,F,Q,U){if(n.length<=0)throw new Error("input shape must be of size greater than 0");const i=[n[0],n[1]];return t.computeShapeHelper(e,n,i,B,s,F,Q,U),i}static computeConvOutputShape(e,n,B,s,F,Q,U){if(e.length<=0||n.length<=0)throw new Error("invalid input tensor dims or invalid filter tensor dims");const i=[e[0],n[0]];return t.computeShapeHelper(!1,e,i,B,s,F,Q,U),i}static computeShapeHelper(e,n,B,s,F,Q,U,i){if(e)for(let t=0;t<n.length-2;t++)B.push(1);else for(let e=0;e<n.length-2;e++)B.push(t.adjustPadAndReturnShape(n[e+2],s[e],F[e],Q[e],U,e,e+n.length-2,i))}static adjustPadAndReturnShape(t,e,n,B,s,F,Q,U){const i=n*(B-1)+1;if(!U||"NOTSET"===U)return Math.floor((t+s[F]+s[Q]-i)/e+1);switch(U){case"VALID":return s[F]=0,s[Q]=0,Math.floor((t-i)/e+1);case"SAME_LOWER":case"SAME_UPPER":if(1!==n)throw new Error("Dilation not supported for SAME_UPPER or SAME_LOWER");{const n=((t+e-1)/e-1)*e+B-t;return s[F]="SAME_LOWER"===U?Math.floor((n+1)/2):Math.floor(n/2),s[Q]=n-s[F],Math.floor((t+n-B)/e+1)}default:throw new Error("Unsupported AutoPad type")}}},MIN_CLIP=-34028234663852886e22,MAX_CLIP=34028234663852886e22}}),import_guid_typescript,import_onnx2,ortFbs,Tensor3;function sizeof(t){switch(t){case"bool":case"int8":case"uint8":return 1;case"int16":case"uint16":return 2;case"int32":case"uint32":case"float32":return 4;case"float64":return 8;default:throw new Error(`cannot calculate sizeof() on type ${t}`)}}function sizeofProto(t){switch(t){case import_onnx2.onnx.TensorProto.DataType.UINT8:case import_onnx2.onnx.TensorProto.DataType.INT8:case import_onnx2.onnx.TensorProto.DataType.BOOL:return 1;case import_onnx2.onnx.TensorProto.DataType.UINT16:case import_onnx2.onnx.TensorProto.DataType.INT16:return 2;case import_onnx2.onnx.TensorProto.DataType.FLOAT:case import_onnx2.onnx.TensorProto.DataType.INT32:case import_onnx2.onnx.TensorProto.DataType.UINT32:return 4;case import_onnx2.onnx.TensorProto.DataType.INT64:case import_onnx2.onnx.TensorProto.DataType.DOUBLE:case import_onnx2.onnx.TensorProto.DataType.UINT64:return 8;default:throw new Error(`cannot calculate sizeof() on type ${import_onnx2.onnx.TensorProto.DataType[t]}`)}}function createView(t,e){return new(dataviewConstructor(e))(t)}function dataviewConstructor(t){switch(t){case"bool":case"uint8":return Uint8Array;case"int8":return Int8Array;case"int16":return Int16Array;case"uint16":return Uint16Array;case"int32":return Int32Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"float32":return Float32Array;case"float64":return Float64Array;default:throw new Error("unspecified error")}}function longToNumber(t,e){if(e===import_onnx2.onnx.TensorProto.DataType.INT64||e===ortFbs.TensorDataType.INT64){if(t.greaterThanOrEqual(2147483648)||t.lessThan(-2147483648))throw new TypeError("int64 is not supported")}else{if(e!==import_onnx2.onnx.TensorProto.DataType.UINT32&&e!==ortFbs.TensorDataType.UINT32&&e!==import_onnx2.onnx.TensorProto.DataType.UINT64&&e!==ortFbs.TensorDataType.UINT64)throw new TypeError(`not a LONG type: ${import_onnx2.onnx.TensorProto.DataType[e]}`);if(t.greaterThanOrEqual(4294967296)||t.lessThan(0))throw new TypeError("uint64 is not supported")}return t.toNumber()}function readProto(t,e,n){switch(e){case import_onnx2.onnx.TensorProto.DataType.BOOL:case import_onnx2.onnx.TensorProto.DataType.UINT8:return t.getUint8(n);case import_onnx2.onnx.TensorProto.DataType.INT8:return t.getInt8(n);case import_onnx2.onnx.TensorProto.DataType.UINT16:return t.getUint16(n,!0);case import_onnx2.onnx.TensorProto.DataType.INT16:return t.getInt16(n,!0);case import_onnx2.onnx.TensorProto.DataType.FLOAT:return t.getFloat32(n,!0);case import_onnx2.onnx.TensorProto.DataType.INT32:return t.getInt32(n,!0);case import_onnx2.onnx.TensorProto.DataType.UINT32:return t.getUint32(n,!0);case import_onnx2.onnx.TensorProto.DataType.INT64:return longToNumber(long_default.fromBits(t.getUint32(n,!0),t.getUint32(n+4,!0),!1),e);case import_onnx2.onnx.TensorProto.DataType.DOUBLE:return t.getFloat64(n,!0);case import_onnx2.onnx.TensorProto.DataType.UINT64:return longToNumber(long_default.fromBits(t.getUint32(n,!0),t.getUint32(n+4,!0),!0),e);default:throw new Error(`cannot read from DataView for type ${import_onnx2.onnx.TensorProto.DataType[e]}`)}}var init_tensor2=__esm({"web/lib/onnxjs/tensor.ts"(){import_guid_typescript=__toESM(require_guid()),init_long(),init_ort_generated(),import_onnx2=__toESM(require_onnx()),init_util(),ortFbs=onnxruntime.experimental.fbs,Tensor3=class t{constructor(t,e,n,B,s,F=import_guid_typescript.Guid.create()){this.dims=t,this.type=e,this.dataProvider=n,this.asyncDataProvider=B,this.cache=s,this.dataId=F,this.size=ShapeUtil.validateDimsAndCalcSize(t);const Q=this.size,U=void 0===n&&void 0===B&&void 0===s;if(void 0!==s&&s.length!==Q)throw new RangeError("Input dims doesn't match data length.");if("string"===e){if(!(void 0===s||Array.isArray(s)&&s.every((t=>"string"==typeof t))))throw new TypeError("cache should be a string array");U&&(this.cache=new Array(Q))}else{if(void 0!==s){const t=dataviewConstructor(e);if(!(s instanceof t))throw new TypeError(`cache should be type ${t.name}`)}if(U){const t=new ArrayBuffer(Q*sizeof(e));this.cache=createView(t,e)}}}get data(){if(void 0===this.cache){const t=this.dataProvider(this.dataId);if(t.length!==this.size)throw new Error("Length of data provided by the Data Provider is inconsistent with the dims of this Tensor.");this.cache=t}return this.cache}get stringData(){if("string"!==this.type)throw new TypeError("data type is not string");return this.data}get integerData(){switch(this.type){case"uint8":case"int8":case"uint16":case"int16":case"int32":case"uint32":case"bool":return this.data;default:throw new TypeError("data type is not integer (uint8, int8, uint16, int16, int32, uint32, bool)")}}get floatData(){switch(this.type){case"float32":case"float64":return this.data;default:throw new TypeError("data type is not float (float32, float64)")}}get numberData(){if("string"!==this.type)return this.data;throw new TypeError("type cannot be non-number (string)")}get(t){return this.data[ShapeUtil.indicesToOffset(t,this.strides)]}set(t,e){this.data[ShapeUtil.indicesToOffset(t,this.strides)]=e}async getData(){return void 0===this.cache&&(this.cache=await this.asyncDataProvider(this.dataId)),this.cache}get strides(){return this._strides||(this._strides=ShapeUtil.computeStrides(this.dims)),this._strides}static fromProto(e){if(!e)throw new Error("cannot construct Value from an empty tensor");const n=ProtoUtil.tensorDataTypeFromProto(e.dataType),B=ProtoUtil.tensorDimsFromProto(e.dims),s=new t(B,n);if("string"===n)e.stringData.forEach(((t,e)=>{s.data[e]=decodeUtf8String(t)}));else if(e.rawData&&"number"==typeof e.rawData.byteLength&&e.rawData.byteLength>0){const t=s.data,n=new DataView(e.rawData.buffer,e.rawData.byteOffset,e.rawData.byteLength),B=sizeofProto(e.dataType),F=e.rawData.byteLength/B;if(e.rawData.byteLength%B!=0)throw new Error("invalid buffer length");if(t.length!==F)throw new Error("buffer length mismatch");for(let s=0;s<F;s++){const F=readProto(n,e.dataType,s*B);t[s]=F}}else{let t;switch(e.dataType){case import_onnx2.onnx.TensorProto.DataType.FLOAT:t=e.floatData;break;case import_onnx2.onnx.TensorProto.DataType.INT32:case import_onnx2.onnx.TensorProto.DataType.INT16:case import_onnx2.onnx.TensorProto.DataType.UINT16:case import_onnx2.onnx.TensorProto.DataType.INT8:case import_onnx2.onnx.TensorProto.DataType.UINT8:case import_onnx2.onnx.TensorProto.DataType.BOOL:t=e.int32Data;break;case import_onnx2.onnx.TensorProto.DataType.INT64:t=e.int64Data;break;case import_onnx2.onnx.TensorProto.DataType.DOUBLE:t=e.doubleData;break;case import_onnx2.onnx.TensorProto.DataType.UINT32:case import_onnx2.onnx.TensorProto.DataType.UINT64:t=e.uint64Data;break;default:throw new Error("unspecific error")}if(null==t)throw new Error("failed to populate data from a tensorproto value");const n=s.data;if(n.length!==t.length)throw new Error("array length mismatch");for(let B=0;B<t.length;B++){const s=t[B];long_default.isLong(s)?n[B]=longToNumber(s,e.dataType):n[B]=s}}return s}static fromData(e,n,B){return new t(n,B,void 0,void 0,e)}static fromOrtTensor(e){if(!e)throw new Error("cannot construct Value from an empty tensor");const n=ProtoUtil.tensorDimsFromORTFormat(e),B=ProtoUtil.tensorDataTypeFromProto(e.dataType()),s=new t(n,B);if("string"===B)for(let t=0;t<e.stringDataLength();t++)s.data[t]=e.stringData(t);else if(e.rawDataArray()&&"number"==typeof e.rawDataLength()&&e.rawDataLength()>0){const t=s.data,n=new DataView(e.rawDataArray().buffer,e.rawDataArray().byteOffset,e.rawDataLength()),B=sizeofProto(e.dataType()),F=e.rawDataLength()/B;if(e.rawDataLength()%B!=0)throw new Error("invalid buffer length");if(t.length!==F)throw new Error("buffer length mismatch");for(let s=0;s<F;s++){const F=readProto(n,e.dataType(),s*B);t[s]=F}}return s}}}}),GLSL_ES_2_0,GLSL_ES_3_0;function getGlsl(t){return 1===t?GLSL_ES_2_0:GLSL_ES_3_0}function getVertexShaderSource(t){const e=getGlsl(t);return`${e.version}\n      precision highp float;\n      ${e.attribute} vec3 position;\n      ${e.attribute} vec2 textureCoord;\n\n      ${e.varyingVertex} vec2 TexCoords;\n\n      void main()\n      {\n          gl_Position = vec4(position, 1.0);\n          TexCoords = textureCoord;\n      }`}function getFragShaderPreamble(t){const e=getGlsl(t);return`${e.version}\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    ${e.varyingFrag} vec2 TexCoords;\n    ${e.outputDeclaration}\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    // Custom vector types to handle higher dimenalities.\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    `}function getDefaultFragShaderMain(t,e){return`\n  void main() {\n    int indices[${e}];\n    toVec(TexCoords, indices);\n    vec4 result = vec4(process(indices));\n    ${getGlsl(t).output} = result;\n  }\n  `}var init_glsl_source=__esm({"web/lib/onnxjs/backends/webgl/glsl-source.ts"(){GLSL_ES_2_0={version:"",attribute:"attribute",varyingVertex:"varying",varyingFrag:"varying",texture2D:"texture2D",output:"gl_FragColor",outputDeclaration:""},GLSL_ES_3_0={version:"#version 300 es",attribute:"in",varyingVertex:"out",varyingFrag:"in",texture2D:"texture",output:"outputColor",outputDeclaration:"out vec4 outputColor;"}}}),init_types=__esm({"web/lib/onnxjs/backends/webgl/types.ts"(){}});async function repeatedTry(t,e=(t=>0),n){return new Promise(((B,s)=>{let F=0;const Q=()=>{if(t())return void B();F++;const U=e(F);null!=n&&F>=n?s():setTimeout(Q,U)};Q()}))}function generateShaderFuncNameFromInputSamplerName(t){return assert(void 0!==t&&0!==t.length,(()=>"empty string found for sampler name")),"get"+t.charAt(0).toUpperCase()+t.slice(1)}function generateShaderFuncNameFromInputSamplerNameAtOutCoords(t){return assert(void 0!==t&&0!==t.length,(()=>"empty string found for sampler name")),"get"+t.charAt(0).toUpperCase()+t.slice(1)+"AtOutCoords"}function squeezeInputShape(t,e){let n=JSON.parse(JSON.stringify(t));return n=e,n}function getSqueezedParams(t,e){return e.map((e=>t[e])).join(", ")}function getCoordsDataType(t){if(t<=1)return"int";if(2===t)return"ivec2";if(3===t)return"ivec3";if(4===t)return"ivec4";if(5===t)return"ivec5";if(6===t)return"ivec6";throw Error(`GPU for rank ${t} is not yet supported`)}function getGlChannels(t=6){return["x","y","z","w","u","v"].slice(0,t)}var init_utils=__esm({"web/lib/onnxjs/backends/webgl/utils.ts"(){init_util()}});function getVecChannels(t,e){return getGlChannels(e).map((e=>`${t}.${e}`))}function getChannels(t,e){return 1===e?[t]:getVecChannels(t,e)}function unpackFromChannel(){return"\n    float getChannel(vec4 frag, int dim) {\n      int modCoord = imod(dim, 2);\n      return modCoord == 0 ? frag.r : frag.g;\n    }\n\n    float getChannel(vec4 frag, vec2 innerDims) {\n      vec2 modCoord = mod(innerDims, 2.);\n      return modCoord.x == 0. ?\n        (modCoord.y == 0. ? frag.r : frag.g) :\n        (modCoord.y == 0. ? frag.b : frag.a);\n    }\n  "}var init_packing_utils=__esm({"web/lib/onnxjs/backends/webgl/ops/packing-utils.ts"(){init_utils()}}),packProgramMetadata,createPackProgramInfo,createPackProgramInfoLoader;function getOutOfBoundsCondition(t,e,n){if(0===t)return"false";if(1===t)return`rc > ${e[0]}`;let B="";for(let s=t-2;s<t;s++)B+=`${n[s]} >= ${e[s-t+2]}`,s<t-1&&(B+="||");return B}function getOutput(t,e){const n=t.length;if(0===n)return"getA(), 0, 0, 0";if(1===n)return`getA(rc),\n            rc + 1 >= ${t[0]} ? 0. : getA(rc + 1),\n            0, 0`;let B="";if(n>2)for(let t=0;t<n-2;++t)B+=`${e[t]},`;return`getA(${B}r, c),\n          rEdge ? 0. : getA(${B}rp1, c),\n          cEdge ? 0. : getA(${B}r, cp1),\n          rEdge || cEdge ? 0. : getA(${B}rp1, cp1)`}function getSetup(t,e,n,B){if(0===t||1===t)return"";return`\n    int r = ${e[t-2]};\n    int c = ${e[t-1]};\n    int rp1 = ${e[t-2]} + 1;\n    int cp1 = ${e[t-1]} + 1;\n    bool rEdge = rp1 >= ${B};\n    bool cEdge = cp1 >= ${n};\n    `}var init_pack=__esm({"web/lib/onnxjs/backends/webgl/ops/pack.ts"(){init_glsl_source(),init_types(),init_utils(),init_packing_utils(),packProgramMetadata={name:"pack",inputNames:["A"],inputTypes:[1]},createPackProgramInfo=(t,e)=>{const n=getGlsl(t.session.backend.glContext.version),B=e.dims,s=B.length,F=e.dims.length,Q=getCoordsDataType(F),U=getChannels("rc",F),i=getSetup(F,U,B[B.length-2],B[B.length-1]);let a;a=0===s?[1,1]:1===s?[B[0],1]:[B[F-1],B[F-2]];const l=getOutOfBoundsCondition(F,a,U),c=getOutput(B,U),g=`\n        void main() {\n          ${Q} rc = getOutputCoords();\n\n          if(${l}) {\n            ${n.output} = vec4(0);\n          } else {\n            ${i}\n\n            ${n.output} = vec4(${c});\n          }\n        }\n      `;return{...packProgramMetadata,hasMain:!0,output:{dims:e.dims,type:e.type,textureType:2},shaderSource:g}},createPackProgramInfoLoader=(t,e)=>({...packProgramMetadata,get:()=>createPackProgramInfo(t,e)})}}),createPackedReshape3DProgramMetadata,createPackedReshape3DProgramInfo,createPackedReshape3DProgramInfoLoader;function processDims3D(t){if(0===t.length)return[1,1,1];let e=1;for(let n=0;n<t.length-2;++n)e*=t[n];return[e,t.length>1?t[t.length-2]:1,t[t.length-1]]}function isReshapeCheap(t,e){let n=!1;return n=0===t.length||0===e.length||(t.length<2||e.length<2?t[t.length-1]===e[e.length-1]:t[t.length-1]===e[e.length-1]&&t[t.length-2]===e[e.length-2]),n}function getReshapedInputCoords(t){const e=ShapeUtil.computeStrides(t),n=["b","r","c"],B="index";return`\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      ${e.map(((t,s)=>`${`int ${n[s]} = ${B} / ${t}`}; ${s===e.length-1?`int ${n[s+1]} = ${B} - ${n[s]} * ${t}`:`index -= ${n[s]} * ${t}`};`)).join("")}\n      return ivec3(b, r, c);\n    }\n  `}function getFlattenedIndexFrom3D(t){const e=ShapeUtil.computeStrides(t);return`\n  int getFlattenedIndex(ivec3 coords) {\n    // reverse y, z order\n    return coords.x * ${e[0]} + coords.z * ${e[1]} + coords.y;\n  }\n`}var init_reshape_packed=__esm({"web/lib/onnxjs/backends/webgl/ops/reshape-packed.ts"(){init_util(),init_glsl_source(),init_types(),init_packing_utils(),createPackedReshape3DProgramMetadata=t=>({name:"Reshape (packed)",inputTypes:[2],inputNames:["A"],cacheHint:`${t}`}),createPackedReshape3DProgramInfo=(t,e,n,B)=>{const s=e.dims,F=B;let Q="";for(let t=0;t<4;t++){let e="";switch(t){case 0:e="outputCoords = rc;";break;case 1:e="outputCoords = ivec3(rc.x, rc.y+1, rc.z);";break;case 2:e="outputCoords = ivec3(rc.x, rc.y, rc.z+1);";break;case 3:e="outputCoords = ivec3(rc.x, rc.y+1, rc.z+1);";break;default:throw new Error}Q+=`\n        ${e}\n        ${t>0?"if(outputCoords.y < rows && outputCoords.z < cols){":""}\n          int flattenedIndex = getFlattenedIndex(outputCoords);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flattenedIndex);\n          vec2 innerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[${t}] = getChannel(getA(inputRC.x, inputRC.y, inputRC.z), innerDims);\n\n        ${t>0?"}":""}\n      `}const U=getGlsl(t.session.backend.glContext.version),i=`\n      ${getReshapedInputCoords(s)}\n      ${getFlattenedIndexFrom3D(F)}\n      ${unpackFromChannel()}\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.0);\n\n        ivec3 outputCoords;\n        int rows = ${F[2]};\n        int cols = ${F[1]};\n\n        ${Q}\n        ${U.output} = result;\n      }\n    `;return{...n,output:{dims:F,type:e.type,textureType:2},shaderSource:i,hasMain:!0}},createPackedReshape3DProgramInfoLoader=(t,e,n)=>{const B=createPackedReshape3DProgramMetadata(n);return{...B,get:()=>createPackedReshape3DProgramInfo(t,e,B,n)}}}}),encodeAsUint8,init_uint8_encode=__esm({"web/lib/onnxjs/backends/webgl/ops/uint8-encode.ts"(){init_glsl_source(),init_types(),encodeAsUint8=(t,e)=>{const n=e.shape,B=getGlsl(t.session.backend.glContext.version),s=`\n    const float FLOAT_MAX = 1.70141184e38;\n    const float FLOAT_MIN = 1.17549435e-38;\n\n    bool isNaN(float val) {\n      return (val < 1.0 || 0.0 < val || val == 0.0) ? false : true;\n    }\n\n    highp vec4 encodeAsUint8(highp float v) {\n      if (isNaN(v)) {\n        return vec4(255, 255, 255, 255);\n      }\n\n      highp float av = abs(v);\n\n      if(av < FLOAT_MIN) {\n        return vec4(0.0, 0.0, 0.0, 0.0);\n      } else if(v > FLOAT_MAX) {\n        return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n      } else if(v < -FLOAT_MAX) {\n        return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n      }\n\n      highp vec4 c = vec4(0,0,0,0);\n\n      highp float e = floor(log2(av));\n      highp float m = exp2(fract(log2(av))) - 1.0;\n\n      c[2] = floor(128.0 * m);\n      m -= c[2] / 128.0;\n      c[1] = floor(32768.0 * m);\n      m -= c[1] / 32768.0;\n      c[0] = floor(8388608.0 * m);\n\n      highp float ebias = e + 127.0;\n      c[3] = floor(ebias / 2.0);\n      ebias -= c[3] * 2.0;\n      c[2] += floor(ebias) * 128.0;\n\n      c[3] += 128.0 * step(0.0, -v);\n\n      return c / 255.0;\n    }\n\n    void main() {\n      float value = ${B.texture2D}(X,TexCoords).r;\n      ${B.output} = encodeAsUint8(value);\n    }`,F={name:"Uint8Encode",inputTypes:[0],inputNames:["X"],output:{dims:n,type:e.tensor.type,textureType:3},shaderSource:s,hasMain:!0};return t.executeProgram(F,[e.tensor])}}}),unpackProgramMetadata,createUnpackProgramInfo,createUnpackProgramInfoLoader;function getSourceCoords(t,e){if(1===t)return"rc";let n="";for(let B=0;B<t;B++)n+=e[B],B<t-1&&(n+=",");return n}var init_unpack=__esm({"web/lib/onnxjs/backends/webgl/ops/unpack.ts"(){init_glsl_source(),init_types(),init_utils(),init_packing_utils(),unpackProgramMetadata={name:"unpack",inputNames:["A"],inputTypes:[2]},createUnpackProgramInfo=(t,e)=>{const n=e.dims.length,B=getChannels("rc",n),s=B.slice(-2),F=getCoordsDataType(n),Q=unpackFromChannel(),U=0===e.dims.length?"":getSourceCoords(n,B),i=n<=1?"rc":`vec2(${s.join(",")})`,a=`\n    ${Q}\n    void main() {\n      ${F} rc = getOutputCoords();\n\n       // Sample the texture with the coords to get the rgba channel value.\n       vec4 packedInput = getA(${U});\n\n       ${getGlsl(t.session.backend.glContext.version).output} = vec4(getChannel(packedInput, ${i}), 0, 0, 0);\n     }\n   `;return{...unpackProgramMetadata,hasMain:!0,output:{dims:e.dims,type:e.type,textureType:0},shaderSource:a}},createUnpackProgramInfoLoader=(t,e)=>({...unpackProgramMetadata,get:()=>createUnpackProgramInfo(t,e)})}}),RedFloat32DataEncoder,RGBAFloatDataEncoder,Uint8DataEncoder,init_texture_data_encoder=__esm({"web/lib/onnxjs/backends/webgl/texture-data-encoder.ts"(){init_instrument(),RedFloat32DataEncoder=class{constructor(t,e=1){if(1===e)this.internalFormat=t.R32F,this.format=t.RED,this.textureType=t.FLOAT,this.channelSize=e;else{if(4!==e)throw new Error(`Invalid number of channels: ${e}`);this.internalFormat=t.RGBA32F,this.format=t.RGBA,this.textureType=t.FLOAT,this.channelSize=e}}encode(t,e){let n,B;return t.constructor!==Float32Array&&(Logger.warning("Encoder","data was not of type Float32; creating new Float32Array"),B=new Float32Array(t)),e*this.channelSize>t.length?(Logger.warning("Encoder","Source data too small. Allocating larger array"),B=t,n=this.allocate(e*this.channelSize),B.forEach(((t,e)=>n[e]=t))):(B=t,n=B),n}allocate(t){return new Float32Array(4*t)}decode(t,e){if(1===this.channelSize){return t.filter(((t,e)=>e%4==0)).subarray(0,e)}return t.subarray(0,e)}},RGBAFloatDataEncoder=class{constructor(t,e=1,n){if(1!==e&&4!==e)throw new Error(`Invalid number of channels: ${e}`);this.internalFormat=t.RGBA,this.format=t.RGBA,this.channelSize=e,this.textureType=n||t.FLOAT}encode(t,e){let n=t;return 1===this.channelSize&&(Logger.verbose("Encoder","Exploding into a larger array"),n=this.allocate(e),t.forEach(((t,e)=>n[4*e]=t))),n}allocate(t){return new Float32Array(4*t)}decode(t,e){if(1===this.channelSize){return t.filter(((t,e)=>e%4==0)).subarray(0,e)}return t.subarray(0,e)}},Uint8DataEncoder=class{constructor(t,e=1){if(this.channelSize=4,1===e)this.internalFormat=t.ALPHA,this.format=t.ALPHA,this.textureType=t.UNSIGNED_BYTE,this.channelSize=e;else{if(4!==e)throw new Error(`Invalid number of channels: ${e}`);this.internalFormat=t.RGBA,this.format=t.RGBA,this.textureType=t.UNSIGNED_BYTE,this.channelSize=e}}encode(t,e){return new Uint8Array(t.buffer,t.byteOffset,t.byteLength)}allocate(t){return new Uint8Array(t*this.channelSize)}decode(t,e){if(t instanceof Uint8Array)return t.subarray(0,e);throw new Error(`Invalid array type: ${t.constructor}`)}}}}),createTextureLayoutFromTextureType,calculateTextureWidthAndHeight,createTextureLayoutFromShape,init_texture_layout=__esm({"web/lib/onnxjs/backends/webgl/texture-layout.ts"(){init_util(),init_types(),createTextureLayoutFromTextureType=(t,e,n)=>{const B=0===n||1===n?1:4,s=2===n,F=1===n||2===n,Q=4===n?e.length-1:void 0,U=4===n?e.map(((t,n)=>n===e.length-1?4*t:t)):void 0;return createTextureLayoutFromShape(t,e,B,U,{isPacked:s,reverseWH:F,breakAxis:Q})},calculateTextureWidthAndHeight=(t,e,n)=>{const B=createTextureLayoutFromTextureType(t,e,n);return[B.width,B.height]},createTextureLayoutFromShape=(t,e,n=1,B,s)=>{const F=!(!s||!s.isPacked),[Q,U]=t.computeTextureWH(F&&B||e,s),i=e.length;let a=e.slice(0);if(0===i&&(a=[1]),1===n)B=e;else if(F){if(4!==n)throw new Error("a packed texture must be 4-channel");B=e,i>0&&(a[i-1]=Math.ceil(a[i-1]/2)),i>1&&(a[i-2]=Math.ceil(a[i-2]/2))}else if(!B)throw new Error("Unpacked shape is needed when using channels > 1");return{width:Q,height:U,channels:n,isPacked:F,shape:a,strides:ShapeUtil.computeStrides(a),unpackedShape:B,reversedWH:s&&s.reverseWH}}}}),getProgramInfoUniqueKey,WebGLInferenceHandler,init_inference_handler=__esm({"web/lib/onnxjs/backends/webgl/inference-handler.ts"(){init_instrument(),init_tensor2(),init_util(),init_pack(),init_reshape_packed(),init_uint8_encode(),init_unpack(),init_texture_data_encoder(),init_texture_layout(),init_types(),getProgramInfoUniqueKey=(t,e)=>{const n=e.map((t=>`${t.unpackedShape.join(",")};${t.width}x${t.height}`)).join("_");let B=t.name;return t.cacheHint&&(B+="["+t.cacheHint+"]"),B+=":"+n,B},WebGLInferenceHandler=class{constructor(t){this.session=t,this.packedTextureDataCache=new Map,this.unpackedTextureDataCache=new Map}calculateTextureWidthAndHeight(t,e){return calculateTextureWidthAndHeight(this.session.layoutStrategy,t,e)}executeProgram(t,e){if(e.length<t.inputNames.length)throw new Error(`Input size mustn't be less than ${t.inputNames.length}.`);if(t.inputNames.length!==t.inputTypes.length)throw new Error("input names size does not match input types");const n=[];for(let B=0;B<t.inputNames.length;++B)n[B]=this.getOrCreateTextureData(e[B],t.inputTypes[B]);const B=getProgramInfoUniqueKey(t,n);let s=this.session.programManager.getArtifact(B);const F=s?s.programInfo:"function"==typeof t.get?t.get():t,Q=createTextureLayoutFromTextureType(this.session.layoutStrategy,F.output.dims,F.output.textureType),U=this.createTextureData(Q,F.output.type);return s||(s=this.session.programManager.build(F,n,U),this.session.programManager.setArtifact(B,s)),this.runProgram(s,n,U),U}run(t,e){return this.executeProgram(t,e).tensor}runProgram(t,e,n){for(let n=0;n<e.length;++n)if(!!e[n].isPacked!=(2===t.programInfo.inputTypes[n]))throw new Error(`input[${n}] property packed inconsistent`);if(!!n.isPacked!=(2===t.programInfo.output.textureType))throw new Error("output property packed inconsistent");this.session.programManager.run(t,e,n)}getOrCreateTextureData(t,e){let n=this.getTextureData(t.dataId,2===e);if(!n&&(n=this.getTextureData(t.dataId,2!==e),n))return 2===e?this.pack(n):this.unpack(n);if(!n){const B=createTextureLayoutFromTextureType(this.session.layoutStrategy,t.dims,e);if(4===e){const n=1,B=4,s=t.dims;if(4===s.length){const F=[s[0],Math.ceil(s[1]*s[2]*s[3]/B)],Q=createTextureLayoutFromTextureType(this.session.layoutStrategy,F,e);let U=t.numberData;if(s[1]*s[2]*s[3]%B!=0){const e=s[0],F=s[1]*s[2]*s[3],Q=Math.ceil(F*n/B)*B;U=new Float32Array(e*Q);for(let B=0;B<e;++B){const e=B*F,s=B*Q+B%n*F;U.set(t.numberData.subarray(e,e+F),s)}}return this.createTextureData(Q,t.type,U,t,1)}}if(2===e){const e=createTextureLayoutFromShape(this.session.layoutStrategy,t.dims,1,[],{reverseWH:!0}),B=this.createTextureData(e,t.type,t.numberData,t,1);n=this.pack(B)}else n=this.createTextureData(B,t.type,t.numberData,t,1)}return n}createTextureDataFromLayoutBindTensor(t,e,n,B){return this.createTextureData(t,e,n,B,1)}createTextureData(t,e,n,B,s){Logger.verbose("InferenceHandler",`Creating TextureData: layout:[${JSON.stringify(t)}]`);const F=this.session.textureManager.createTextureFromLayout(e,t,n,s);return this.createTextureDataFromTexture(t,e,F,B)}reshapeUnpacked(t,e){const n=this.getOrCreateTextureData(t,0),B={channels:n.channels,height:n.height,width:n.width,shape:0!==e.length?e:[1],strides:ShapeUtil.computeStrides(e),unpackedShape:e};return this.createTextureDataFromTexture(B,t.type,n.texture).tensor}reshapePacked(t,e){const n=this.getOrCreateTextureData(t,2);if(isReshapeCheap(t.dims,e)){const B={channels:n.channels,height:n.height,width:n.width,shape:0!==e.length?e:[1],strides:ShapeUtil.computeStrides(e),unpackedShape:e,isPacked:!0};return this.createTextureDataFromTexture(B,t.type,n.texture).tensor}const B=processDims3D(t.dims),s=processDims3D(e),F=this.reshapePacked(t,B),Q=this.run(createPackedReshape3DProgramInfoLoader(this,F,s),[F]);return this.reshapePacked(Q,e)}cast(t,e){const n=this.getOrCreateTextureData(t,0);return this.createTextureDataFromTexture(n,e,n.texture).tensor}createTextureDataFromTexture(t,e,n,B,s){const F={...t,tensor:B||new Tensor3(t.unpackedShape,e,(t=>this.readTexture(F)),(async t=>this.readTextureAsync(F)),void 0,s),texture:n};return this.setTextureData(F.tensor.dataId,F,t.isPacked),F}getTextureData(t,e=!1){return this.session.isInitializer(t)?this.session.getTextureData(t,e):e?this.packedTextureDataCache.get(t):this.unpackedTextureDataCache.get(t)}setTextureData(t,e,n=!1){this.session.isInitializer(t)?this.session.setTextureData(t,e,n):(n?this.packedTextureDataCache:this.unpackedTextureDataCache).set(t,e)}isTextureLayoutCached(t,e=!1){return!!this.getTextureData(t.dataId,e)}dispose(){this.session.textureManager.clearActiveTextures(),this.packedTextureDataCache.forEach((t=>this.session.textureManager.releaseTexture(t))),this.packedTextureDataCache=new Map,this.unpackedTextureDataCache.forEach((t=>this.session.textureManager.releaseTexture(t))),this.unpackedTextureDataCache=new Map}readTexture(t){return t.isPacked?this.readTexture(this.unpack(t)):this.session.backend.glContext.isFloat32DownloadSupported?this.session.textureManager.readTexture(t,t.tensor.type,t.channels):this.session.textureManager.readUint8TextureAsFloat(encodeAsUint8(this,t))}async readTextureAsync(t){return t.isPacked?this.readTextureAsync(this.unpack(t)):this.session.backend.glContext.isFloat32DownloadSupported?this.session.textureManager.readTextureAsync(t,t.tensor.type,t.channels):this.session.textureManager.readUint8TextureAsFloat(encodeAsUint8(this,t))}pack(t){return this.executeProgram(createPackProgramInfoLoader(this,t.tensor),[t.tensor])}unpack(t){return this.executeProgram(createUnpackProgramInfoLoader(this,t.tensor),[t.tensor])}}}}),AttributeWithCacheKeyImpl,createAttributeWithCacheKey,init_attribute_with_cache_key=__esm({"web/lib/onnxjs/attribute-with-cache-key.ts"(){AttributeWithCacheKeyImpl=class{constructor(t){Object.assign(this,t)}get cacheKey(){return this.key||(this.key=Object.getOwnPropertyNames(this).sort().map((t=>`${this[t]}`)).join(";")),this.key}},createAttributeWithCacheKey=t=>new AttributeWithCacheKeyImpl(t)}}),batchNormalizationProgramMetadata,batchNormalization,parseBatchNormalizationAttributes,createBatchNormalizationProgramInfo,validateInputs,init_batch_normalization=__esm({"web/lib/onnxjs/backends/webgl/ops/batch-normalization.ts"(){init_attribute_with_cache_key(),init_glsl_source(),init_types(),batchNormalizationProgramMetadata={name:"BatchNormalization",inputNames:["A","Scale","B","Mean","Variance"],inputTypes:[0,0,0,0,0]},batchNormalization=(t,e,n)=>{validateInputs(e);return[t.run({...batchNormalizationProgramMetadata,cacheHint:n.cacheKey,get:()=>createBatchNormalizationProgramInfo(t,e,n)},e)]},parseBatchNormalizationAttributes=t=>{const e=t.attributes.getFloat("epsilon",1e-5),n=t.attributes.getFloat("momentum",.9),B=t.attributes.getInt("spatial",1);return createAttributeWithCacheKey({epsilon:e,momentum:n,spatial:B})},createBatchNormalizationProgramInfo=(t,e,n)=>{const B=getGlsl(t.session.backend.glContext.version),s=e[0].dims.length,[F,Q]=t.calculateTextureWidthAndHeight(e[1].dims,0),U=`\n  float process(int[${s}] indices) {\n    vec2 position = offsetToCoords(indices[1], ${F}, ${Q});\n    float scale = getColorAsFloat(${B.texture2D}(Scale, position));\n    float mean = getColorAsFloat(${B.texture2D}(Mean, position));\n    float variance = getColorAsFloat(${B.texture2D}(Variance, position));\n    float b = getColorAsFloat(${B.texture2D}(B, position));\n\n    return scale * ( (_A(indices) - mean) / sqrt(variance + float(${n.epsilon})) ) + b;\n  }`;return{...batchNormalizationProgramMetadata,output:{dims:e[0].dims,type:e[0].type,textureType:0},shaderSource:U}},validateInputs=t=>{if(!t||5!==t.length)throw new Error("BatchNormalization requires 5 inputs.");const e=t[0],n=t[1],B=t[2],s=t[3],F=t[4];if(e.dims.length<3||1!==n.dims.length||1!==B.dims.length||1!==s.dims.length||1!==F.dims.length)throw new Error("invalid input shape.");if(n.dims[0]!==e.dims[1]||B.dims[0]!==e.dims[1]||s.dims[0]!==e.dims[1]||F.dims[0]!==e.dims[1])throw new Error("invalid input shape.");if("float32"!==e.type&&"float64"!==e.type||"float32"!==n.type&&"float64"!==n.type||"float32"!==B.type&&"float64"!==B.type||"float32"!==s.type&&"float64"!==s.type||"float32"!==F.type&&"float64"!==F.type)throw new Error("invalid input tensor types.")}}}),GlslContext,GlslLib,GlslLibRoutine,GlslLibRoutineNode,TopologicalSortGlslRoutines,init_glsl_definitions=__esm({"web/lib/onnxjs/backends/webgl/glsl-definitions.ts"(){GlslContext=class{constructor(t,e,n,B){this.glContext=t,this.programInfo=e,this.inputTextureLayouts=n,this.outputTextureLayout=B}},GlslLib=class{constructor(t){this.context=t}},GlslLibRoutine=class{constructor(t,e){this.routineBody=t,this.dependencies=e}},GlslLibRoutineNode=class{constructor(t,e,n){this.name=t,this.dependencies=n||[],e&&(this.routineBody=e)}addDependency(t){t&&this.dependencies.push(t)}},TopologicalSortGlslRoutines=class{static returnOrderedNodes(t){if(!t||0===t.length)return[];if(1===t.length)return t;const e=new Set,n=new Set,B=new Array;return this.createOrderedNodes(t,e,n,B),B}static createOrderedNodes(t,e,n,B){for(let s=0;s<t.length;++s)this.dfsTraverse(t[s],e,n,B)}static dfsTraverse(t,e,n,B){if(!t||n.has(t.name))return;if(e.has(t.name))throw new Error("Cyclic dependency detected. Can't topologically sort routines needed for shader.");e.add(t.name);const s=t.dependencies;if(s&&s.length>0)for(let t=0;t<s.length;++t)this.dfsTraverse(s[t],e,n,B);B.push(t),n.add(t.name),e.delete(t.name)}}}}),createBinaryProgramInfoLoader,createBinaryProgramInfo,add2,and2,div,equal,greater,less,mul,or2,pow,pRelu,sub,xor2;function glslAdd(){const t="add_";return{body:`\n  float ${t}(float a, float b) {\n    return a + b;\n  }\n  vec4 ${t}(vec4 v1, vec4 v2) {\n    return v1 + v2;\n  }\n  `,name:t,type:0}}function glslDiv(){const t="div_";return{body:`\n  float ${t}(float a, float b) {\n    return a / b;\n  }\n  vec4 ${t}(vec4 v1, vec4 v2) {\n    return v1 / v2;\n  }\n  `,name:t,type:0}}function glslMul(){const t="mul_";return{body:`\n  float ${t}(float a, float b) {\n    return a * b;\n  }\n  vec4 ${t}(vec4 v1, vec4 v2) {\n    return v1 * v2;\n  }\n  `,name:t,type:0}}function glslSub(){const t="sub_";return{body:`\n  float ${t}(float a, float b) {\n    return a - b;\n  }\n  vec4 ${t}(vec4 v1, vec4 v2) {\n    return v1 - v2;\n  }\n  `,name:t,type:0}}function glslEqual(){const t="equal_";return{body:`\n  float ${t}(float a, float b) {\n    return float(a == b);\n  }\n  vec4 ${t}(vec4 v1, vec4 v2) {\n    return vec4(equal(v1, v2));\n  }\n  `,name:t,type:0}}function glslGreater(){const t="greater_";return{body:`\n  float ${t}(float a, float b) {\n    return float(a > b);\n  }\n  vec4 ${t}(vec4 v1, vec4 v2) {\n    return vec4( v1.r > v2.r ,\n      v1.g > v2.g,\n      v1.b > v2.b,\n      v1.a > v2.a );\n  }\n  `,name:t,type:0}}function glslLess(){const t="less_";return{body:`\n  float ${t}(float a, float b) {\n    return float(a < b);\n  }\n  vec4 ${t}(vec4 v1, vec4 v2) {\n    return vec4( v1.r < v2.r ,\n                v1.g < v2.g,\n                v1.b < v2.b,\n                v1.a < v2.a );\n  }\n  `,name:t,type:0}}function glslAnd(){const t="and_";return{body:`\n  float ${t}(float a, float b) {\n    return float( bool(a) && bool(b) );\n  }\n  vec4 ${t}(vec4 v1, vec4 v2) {\n    bvec4 b1 = bvec4(v1);\n    bvec4 b2 = bvec4(v2);\n    return vec4( b1.r && b2.r ,\n                b1.g && b2.g,\n                b1.b && b2.b,\n                b1.a && b2.a );\n  }\n  `,name:t,type:0}}function glslOr(){const t="or_";return{body:`\n  float ${t}(float a, float b) {\n    return float( bool(a) || bool(b) );\n  }\n  vec4 ${t}(vec4 v1, vec4 v2) {\n    bvec4 b1 = bvec4(v1);\n    bvec4 b2 = bvec4(v2);\n    return vec4( b1.r || b2.r ,\n                b1.g || b2.g,\n                b1.b || b2.b,\n                b1.a || b2.a );\n  }\n  `,name:t,type:0}}function glslXor(){const t="xor_";return{body:`\n  float ${t}(float a, float b) {\n    return float( bool(a) ^^ bool(b) );\n  }\n  vec4 ${t}(vec4 v1, vec4 v2) {\n    bvec4 b1 = bvec4(v1);\n    bvec4 b2 = bvec4(v2);\n    return vec4( b1.r ^^ b2.r ,\n                b1.g ^^ b2.g,\n                b1.b ^^ b2.b,\n                b1.a ^^ b2.a );\n  }\n  `,name:t,type:0}}function glslPow(){return glslBuiltinBinary("pow")}function glslPRelu(){const t="prelu_";return{body:`\n  float ${t}(float a, float b) {\n    return a < 0.0 ? a * b: a;\n  }\n  vec4 ${t}(vec4 v1, vec4 v2) {\n    return vec4(\n      v1.r < 0.0 ? v1.r * v2.r: v1.r,\n      v1.g < 0.0 ? v1.g * v2.g: v1.g,\n      v1.b < 0.0 ? v1.b * v2.b: v1.b,\n      v1.a < 0.0 ? v1.a * v2.a: v1.a\n      );\n  }\n  `,name:t,type:0}}function glslBuiltinBinary(t){const e=`${t}_`;return{body:`\n  float ${e}(float a, float b) {\n    return ${t}(a, b);\n  }\n  vec4 ${e}(vec4 v1, vec4 v2) {\n    return ${t}(v1, v2);\n  }\n  `,name:e,type:0}}var init_binary_op=__esm({"web/lib/onnxjs/backends/webgl/ops/binary-op.ts"(){init_util(),init_glsl_definitions(),init_glsl_source(),init_types(),createBinaryProgramInfoLoader=(t,e,n,B=e[0].type,s)=>{const F=t.session.pack?2:0;return{name:n.name,inputNames:["A","B"],inputTypes:[F,F],cacheHint:s,get:()=>createBinaryProgramInfo(t,e,n,B)}},createBinaryProgramInfo=(t,e,n,B=e[0].type)=>{const s=t.session.pack?2:0,F=!ShapeUtil.areEqual(e[0].dims,e[1].dims);let Q=e[0].dims;const U=t.session.pack;if(F){const F=BroadcastUtil.calcShape(e[0].dims,e[1].dims,!1);if(!F)throw new Error("Can't perform binary op on the given tensors");Q=F;const i=Q.length,a=0!==e[0].dims.length?e[0].dims.length:1,l=0!==e[1].dims.length?e[1].dims.length:1,c=0!==e[0].dims.length?"bcastIndices_A(indices, aindices);":"aindices[0] = 0;",g=0!==e[1].dims.length?"bcastIndices_B(indices, bindices);":"bindices[0] = 0;",d=getGlsl(t.session.backend.glContext.version),I=U?`\n      ${n.body}\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n        vec4 result = ${n.name}(a, b);\n        ${d.output} = result;\n      }`:`\n      ${n.body}\n      float process(int indices[${i}]) {\n        int aindices[${a}];\n        int bindices[${l}];\n        ${c}\n        ${g}\n        return ${n.name}(_A(aindices), _B(bindices));\n      }`;return{name:n.name,inputNames:["A","B"],inputTypes:[s,s],output:{dims:Q,type:B,textureType:s},shaderSource:I,hasMain:U}}const i=getGlsl(t.session.backend.glContext.version),a=`\n    ${n.body}\n    void main() {\n      vec4 v1 = ${i.texture2D}(A, TexCoords);\n      vec4 v2 = ${i.texture2D}(B, TexCoords);\n      vec4 result = ${n.name}(v1, v2);\n      ${i.output} = result;\n    }\n    `;return{name:n.name,inputNames:["A","B"],inputTypes:[s,s],output:{dims:e[0].dims,type:B,textureType:s},shaderSource:a,hasMain:!0}},add2=(t,e)=>[t.run(createBinaryProgramInfoLoader(t,e,glslAdd()),e)],and2=(t,e)=>[t.run(createBinaryProgramInfoLoader(t,e,glslAnd(),"bool"),e)],div=(t,e)=>[t.run(createBinaryProgramInfoLoader(t,e,glslDiv()),e)],equal=(t,e)=>[t.run(createBinaryProgramInfoLoader(t,e,glslEqual(),"bool"),e)],greater=(t,e)=>[t.run(createBinaryProgramInfoLoader(t,e,glslGreater(),"bool"),e)],less=(t,e)=>[t.run(createBinaryProgramInfoLoader(t,e,glslLess(),"bool"),e)],mul=(t,e)=>[t.run(createBinaryProgramInfoLoader(t,e,glslMul()),e)],or2=(t,e)=>[t.run(createBinaryProgramInfoLoader(t,e,glslOr(),"bool"),e)],pow=(t,e)=>[t.run(createBinaryProgramInfoLoader(t,e,glslPow()),e)],pRelu=(t,e)=>[t.run(createBinaryProgramInfoLoader(t,e,glslPRelu()),e)],sub=(t,e)=>[t.run(createBinaryProgramInfoLoader(t,e,glslSub()),e)],xor2=(t,e)=>[t.run(createBinaryProgramInfoLoader(t,e,glslXor(),"bool"),e)]}}),cast,parseCastAttributes,validateInputs2,init_cast=__esm({"web/lib/onnxjs/backends/webgl/ops/cast.ts"(){init_util(),cast=(t,e,n)=>(validateInputs2(e),[t.cast(e[0],n)]),parseCastAttributes=t=>ProtoUtil.tensorDataTypeFromProto(t.attributes.getInt("to")),validateInputs2=t=>{if(!t||1!==t.length)throw new Error("Cast requires 1 input.");if("string"===t[0].type)throw new Error("Invalid input type.")}}}),createPackedConcatProgramMetadata,createPackedConcatProgramInfo,createPackedConcatProgramInfoLoader,getShiftedChannelsSnippet,init_concat_packed=__esm({"web/lib/onnxjs/backends/webgl/ops/concat-packed.ts"(){init_glsl_source(),init_types(),init_utils(),init_packing_utils(),createPackedConcatProgramMetadata=(t,e)=>({name:"Concat (packed)",inputNames:Array.from({length:t},((t,e)=>`X${e}`)),inputTypes:Array(t).fill(2),cacheHint:e}),createPackedConcatProgramInfo=(t,e,n,B)=>{const s=n[0].dims.slice();if(B>=s.length||B<-1*s.length)throw new Error("axis specified for concat doesn't match input dimensionality");B<0&&(B=s.length+B);const F=s.slice(0);for(let t=1;t<n.length;t++){const e=n[t].dims.slice();for(let t=0;t<s.length;t++)if(t===B)F[B]+=e[t];else if(s[t]!==e[t])throw new Error("non concat dimensions must match")}const Q=F.length,U=getChannels("coords",Q),i=getCoordsDataType(Q),a=unpackFromChannel(),l=n.map((t=>t.dims)),c=getGlChannels(Q),g=new Array(l.length-1);g[0]=l[0][B];for(let t=1;t<g.length;t++)g[t]=g[t-1]+l[t][B];const d=c[B],I=c.slice(-2),o=c.join();let r=`if (${d} < ${g[0]}) {\n        return getChannel(\n            getX0(${o}), vec2(${I.join()}));\n        }`;for(let t=1;t<g.length;t++){const e=g[t-1];r+=`\n            if (${d} < ${g[t]}  && ${d} >= ${g[t-1]}) {\n              return getChannel(\n                getX${t}(${getShiftedChannelsSnippet(c,d,e)}),\n                vec2(${getShiftedChannelsSnippet(I,d,e)}));\n            }`}const u=g.length,b=g[g.length-1];r+=`\n            return getChannel(\n              getX${u}(${getShiftedChannelsSnippet(c,d,b)}),\n              vec2(${getShiftedChannelsSnippet(I,d,b)}));`;const C=getGlsl(t.session.backend.glContext.version),p=`\n          ${a}\n          float getValue(${c.map((t=>"int "+t))}) {\n            ${r}\n          }\n\n          void main() {\n            ${i} coords = getOutputCoords();\n            int lastDim = coords.${c[Q-1]};\n            coords.${c[Q-1]} = coords.${c[Q-2]};\n            coords.${c[Q-2]} = lastDim;\n\n            vec4 result = vec4(getValue(${U}), 0., 0., 0.);\n\n            ${U[Q-1]} = ${U[Q-1]} + 1;\n            if (${U[Q-1]} < ${F[Q-1]}) {\n              result.g = getValue(${U});\n            }\n\n            ${U[Q-2]} = ${U[Q-2]} + 1;\n            if (${U[Q-2]} < ${F[Q-2]}) {\n              result.a = getValue(${U});\n            }\n\n            ${U[Q-1]} = ${U[Q-1]} - 1;\n            if (${U[Q-2]} < ${F[Q-2]} &&\n                ${U[Q-1]} < ${F[Q-1]}) {\n              result.b = getValue(${U});\n            }\n            ${C.output} = result;\n          }\n        `;return{...e,output:{dims:F,type:n[0].type,textureType:2},shaderSource:p,hasMain:!0}},createPackedConcatProgramInfoLoader=(t,e,n)=>{const B=createPackedConcatProgramMetadata(e.length,n.cacheKey);return{...B,get:()=>createPackedConcatProgramInfo(t,B,e,n.axis)}},getShiftedChannelsSnippet=(t,e,n)=>{const B=t.indexOf(e);return t.map(((t,e)=>e===B?`${t} - ${n}`:t)).join()}}}),concat,createUnpackedConcatProgramMetadata,createUnpackedConcatProgramInfo,createUnpackedConcatProgramInfoLoader,getTextureIndexWhereDataResidesLinearSearch,getTextureIndexWhereDataResidesBinarySearch,getFetchDataFromCorrectTextureMethod,getGetSizeInConcatAxisValueFromIndexMethod,parseConcatAttributes,validateInputs3,init_concat=__esm({"web/lib/onnxjs/backends/webgl/ops/concat.ts"(){init_attribute_with_cache_key(),init_types(),init_concat_packed(),concat=(t,e,n)=>{if(validateInputs3(e),t.session.pack&&e[0].dims.length>1){return[t.run(createPackedConcatProgramInfoLoader(t,e,n),e)]}return[t.run(createUnpackedConcatProgramInfoLoader(t,e,n),e)]},createUnpackedConcatProgramMetadata=(t,e)=>({name:"Concat",inputNames:Array.from({length:t},((t,e)=>`X${e}`)),inputTypes:Array(t).fill(0),cacheHint:e}),createUnpackedConcatProgramInfo=(t,e,n,B)=>{const s=n[0].dims.slice();if(B>=s.length||B<-1*s.length)throw new Error("axis specified for concat doesn't match input dimensionality");B<0&&(B=s.length+B);const F=s.slice(0);for(let t=1;t<n.length;t++){const e=n[t].dims.slice();for(let t=0;t<s.length;t++)if(t===B)F[B]+=e[t];else if(s[t]!==e[t])throw new Error("non concat dimensions must match")}const Q=F.length,U=new Array(n.length);let i=0;for(let t=0;t<U.length;++t)i+=n[t].dims[B],U[t]=i;let a="";a=n.length<5?getTextureIndexWhereDataResidesLinearSearch(U):getTextureIndexWhereDataResidesBinarySearch(U);const l=`\n        ${getFetchDataFromCorrectTextureMethod(n.length,Q)}\n        ${getGetSizeInConcatAxisValueFromIndexMethod(U)}\n        ${a}\n        float process(int indices[${Q}]) {\n          int textureIndex = getTextureWhereDataResides (indices[${B}]);\n\n          if(textureIndex != 0) {\n            indices[${B}] = indices[${B}] - int(getSizeInConcatAxisValueFromIndex(textureIndex-int(1)));\n          }\n\n          return fetchDataFromCorrectTexture(textureIndex, indices);\n        }`;return{...e,output:{dims:F,type:n[0].type,textureType:0},shaderSource:l}},createUnpackedConcatProgramInfoLoader=(t,e,n)=>{const B=createUnpackedConcatProgramMetadata(e.length,n.cacheKey);return{...B,get:()=>createUnpackedConcatProgramInfo(t,B,e,n.axis)}},getTextureIndexWhereDataResidesLinearSearch=t=>`int getTextureWhereDataResides(int index) {\n      ${t.map(((t,e)=>`if(index<${t}) {return ${e};}\n`)).join("")}\n    }`,getTextureIndexWhereDataResidesBinarySearch=t=>getTextureIndexWhereDataResidesLinearSearch(t),getFetchDataFromCorrectTextureMethod=(t,e)=>{const n=[`float fetchDataFromCorrectTexture(int textureIndex, int indices[${e}]) {`];for(let e=0;e<t;++e)0===e?n.push(`\tif (textureIndex == ${e}) { return _X${e}(indices); }`):e===t-1?n.push(`\telse { return _X${e}(indices); }`):n.push(`\telse if (textureIndex == ${e}) { return _X${e}(indices); }`);return n.push("\t}"),n.join("\n")},getGetSizeInConcatAxisValueFromIndexMethod=t=>{const e=["int getSizeInConcatAxisValueFromIndex(int index) {"];for(let n=0;n<t.length;++n)0===n?e.push(`\tif (index == ${n}) { return ${t[n]}; }`):n===t.length-1?e.push(`\telse { return ${t[n]}; }`):e.push(`\telse if (index == ${n}) { return ${t[n]}; }`);return e.push("\t}"),e.join("\n")},parseConcatAttributes=t=>createAttributeWithCacheKey({axis:t.attributes.getInt("axis")}),validateInputs3=t=>{if(!t||t.length<1)throw new Error("too few inputs");const e=t[0].type,n=t[0].dims.length;if("string"===e)throw new Error("string tensor is not supported yet");for(const B of t){if(B.type!==e)throw new Error("input tensors should be one type");if(B.dims.length!==n)throw new Error("input tensors should have the same shape")}}}}),createElementwiseProgramInfo,createElementwiseProgramInfoLoader,abs,acos,asin,atan,clip,parseClipAttributes,clipV11,generateClipAttributesFromInputs,ceil,cos,elu,parseEluAttributes,exp,floor,identity,leakyRelu,parseLeakyReluAttributes,log2,neg,not2,relu,sigmoid,sin,sqrt,tan,tanh;function glslAbs(){return glslBuiltinUnary("abs")}function glslAcos(){return glslBuiltinUnary("acos")}function glslAsin(){return glslBuiltinUnary("asin")}function glslAtan(){return glslBuiltinUnary("atan")}function glslCeil(){return glslBuiltinUnary("ceil")}function glslCos(){return glslBuiltinUnary("cos")}function glslElu(t){const e="elu";return{body:`\n  const float alpha = float(${t});\n\n  float ${e}_(float a) {\n    return a >= 0.0 ? a: (exp(a) - 1.0) * alpha;\n  }\n  vec4 ${e}_(vec4 v) {\n    return vec4(${e}_(v.x), ${e}_(v.y), ${e}_(v.z), ${e}_(v.w));\n  }\n  `,name:e,type:0}}function glslExp(){return glslBuiltinUnary("exp")}function glslFloor(){return glslBuiltinUnary("floor")}function glslClip(t,e){const n="clip";return{body:`\n  const float min = float(${t});\n  const float max = float(${e});\n\n  float ${n}_(float a) {\n    return clamp(a, min, max);\n  }\n  vec4 ${n}_(vec4 v) {\n    return clamp(v, min, max);\n  }\n  `,name:n,type:0}}function glslIdentity(){const t="indentity";return{body:`\n  float ${t}_(float a) {\n    return a;\n  }\n  vec4 ${t}_(vec4 v) {\n    return v;\n  }\n  `,name:t,type:0}}function glslLeakyRelu(t){const e="leakyRelu";return{body:`\n  const float alpha = float(${t});\n\n  float ${e}_(float a) {\n    return a < 0.0 ? a * alpha : a;\n  }\n  vec4 ${e}_(vec4 v) {\n    return vec4(${e}_(v.x), ${e}_(v.y), ${e}_(v.z), ${e}_(v.w));\n  }\n  `,name:e,type:0}}function glslLog(){return glslBuiltinUnary("log")}function glslNeg(){const t="neg";return{body:`\n  float ${t}_(float a) {\n    return -a;\n  }\n  vec4 ${t}_(vec4 v) {\n    return -v;\n  }\n  `,name:t,type:0}}function glslNot(){const t="not";return{body:`\n  float ${t}_(float a) {\n    return float( ! bool(a) );\n  }\n  bool ${t}_(bool a) {\n    return !a;\n  }\n  vec4 ${t}_(vec4 v) {\n    return vec4(!bool(v.x), !bool(v.y), !bool(v.z), !bool(v.w));\n  }\n  bvec4 ${t}_(bvec4 v) {\n    return bvec4(!v.x, !v.y, !v.z, !v.w);\n  }\n  `,name:t,type:0}}function glslSin(){return glslBuiltinUnary("sin")}function glslRelu(){const t="relu";return{body:`\n  float ${t}_(float a) {\n    return max( a, 0.0 );\n  }\n  vec4 ${t}_(vec4 v) {\n    return max( v, 0.0 );\n  }\n  `,name:t,type:0}}function glslSigmoid(){const t="sigmoid";return{body:`\n  float ${t}_(float a) {\n    return 1.0 / (1.0 + exp(-a));\n  }\n  vec4 ${t}_(vec4 v) {\n    return 1.0 / (1.0 + exp(-v));\n  }\n  `,name:t,type:0}}function glslSqrt(){return glslBuiltinUnary("sqrt")}function glslTan(){return glslBuiltinUnary("tan")}function glslTanh(){const t="tanh";return{body:`\n  float ${t}_(float a) {\n    a = clamp(a, -10., 10.);\n    a = exp(2.*a);\n    return (a - 1.) / (a + 1.);\n  }\n  vec4 ${t}_(vec4 v) {\n    v = clamp(v, -10., 10.);\n    v = exp(2.*v);\n    return (v - 1.) / (v + 1.);\n  }\n  `,name:t,type:0}}function glslBuiltinUnary(t){return{body:`\n  float ${t}_(float a) {\n    return ${t}(a);\n  }\n  vec4 ${t}_(vec4 v) {\n    return ${t}(v);\n  }\n  `,name:t,type:0}}var init_unary_op=__esm({"web/lib/onnxjs/backends/webgl/ops/unary-op.ts"(){init_attribute_with_cache_key(),init_util(),init_glsl_definitions(),init_glsl_source(),init_types(),createElementwiseProgramInfo=(t,e,n,B)=>{const s=t.session.pack?2:0,F=getGlsl(t.session.backend.glContext.version);return{...e,output:{dims:n.dims,type:n.type,textureType:s},shaderSource:`\n     ${B.body}\n     void main() {\n       vec4 v = ${F.texture2D}(A, TexCoords);\n       v = ${B.name}_(v);\n       ${F.output} = v;\n     }\n     `,hasMain:!0}},createElementwiseProgramInfoLoader=(t,e,n,B)=>{const s=t.session.pack?2:0,F={name:n.name,inputTypes:[s],inputNames:["A"],cacheHint:B};return{...F,get:()=>createElementwiseProgramInfo(t,F,e,n)}},abs=(t,e)=>[t.run(createElementwiseProgramInfoLoader(t,e[0],glslAbs()),e)],acos=(t,e)=>[t.run(createElementwiseProgramInfoLoader(t,e[0],glslAcos()),e)],asin=(t,e)=>[t.run(createElementwiseProgramInfoLoader(t,e[0],glslAsin()),e)],atan=(t,e)=>[t.run(createElementwiseProgramInfoLoader(t,e[0],glslAtan()),e)],clip=(t,e,n)=>[t.run(createElementwiseProgramInfoLoader(t,e[0],glslClip(n.min,n.max),n.cacheKey),e)],parseClipAttributes=t=>createAttributeWithCacheKey({min:t.attributes.getFloat("min",MIN_CLIP),max:t.attributes.getFloat("max",MAX_CLIP)}),clipV11=(t,e)=>{const n=generateClipAttributesFromInputs(t,e);return clip(t,[e[0]],n)},generateClipAttributesFromInputs=(t,e)=>{if(e.length>=3&&(!t.session.isInitializer(e[1].dataId)||!t.session.isInitializer(e[2].dataId)))throw new Error("dynamic clip attributes are not allowed");const n=e.length>=3?e[1].numberData[0]:MIN_CLIP,B=e.length>=3?e[2].numberData[0]:MAX_CLIP;return createAttributeWithCacheKey({min:n,max:B})},ceil=(t,e)=>[t.run(createElementwiseProgramInfoLoader(t,e[0],glslCeil()),e)],cos=(t,e)=>[t.run(createElementwiseProgramInfoLoader(t,e[0],glslCos()),e)],elu=(t,e,n)=>[t.run(createElementwiseProgramInfoLoader(t,e[0],glslElu(n.alpha),n.cacheKey),e)],parseEluAttributes=t=>createAttributeWithCacheKey({alpha:t.attributes.getFloat("alpha",1)}),exp=(t,e)=>[t.run(createElementwiseProgramInfoLoader(t,e[0],glslExp()),e)],floor=(t,e)=>[t.run(createElementwiseProgramInfoLoader(t,e[0],glslFloor()),e)],identity=(t,e)=>[t.run(createElementwiseProgramInfoLoader(t,e[0],glslIdentity()),e)],leakyRelu=(t,e,n)=>[t.run(createElementwiseProgramInfoLoader(t,e[0],glslLeakyRelu(n.alpha),n.cacheKey),e)],parseLeakyReluAttributes=t=>createAttributeWithCacheKey({alpha:t.attributes.getFloat("alpha",.01)}),log2=(t,e)=>[t.run(createElementwiseProgramInfoLoader(t,e[0],glslLog()),e)],neg=(t,e)=>[t.run(createElementwiseProgramInfoLoader(t,e[0],glslNeg()),e)],not2=(t,e)=>[t.run(createElementwiseProgramInfoLoader(t,e[0],glslNot()),e)],relu=(t,e)=>[t.run(createElementwiseProgramInfoLoader(t,e[0],glslRelu()),e)],sigmoid=(t,e)=>[t.run(createElementwiseProgramInfoLoader(t,e[0],glslSigmoid()),e)],sin=(t,e)=>[t.run(createElementwiseProgramInfoLoader(t,e[0],glslSin()),e)],sqrt=(t,e)=>[t.run(createElementwiseProgramInfoLoader(t,e[0],glslSqrt()),e)],tan=(t,e)=>[t.run(createElementwiseProgramInfoLoader(t,e[0],glslTan()),e)],tanh=(t,e)=>[t.run(createElementwiseProgramInfoLoader(t,e[0],glslTanh()),e)]}}),parseInternalActivationAttributes;function getActivationSnippet(t){let e;switch(t.activation){case"Relu":e=glslRelu();break;case"Sigmoid":e=glslSigmoid();break;case"Clip":e=glslClip(t.clipMin,t.clipMax);break;default:return{activationFunction:"",applyActivation:""}}const n=e.name;return{activationFunction:e.body,applyActivation:`value = ${n}_(value);`}}var init_fuse_utils=__esm({"web/lib/onnxjs/backends/webgl/ops/fuse-utils.ts"(){init_util(),init_unary_op(),parseInternalActivationAttributes=t=>{const e=t.getString("activation","");if("Clip"===e){const[n,B]=t.getFloats("activation_params",[MIN_CLIP,MAX_CLIP]);return{activation:e,clipMax:B,clipMin:n,activationCacheKey:`${e}:${n},${B}`}}return{activation:e,activationCacheKey:e}}}}),createUnpackedGroupedConvProgramMetadata,createUnpackedGroupedConvProgramInfo,createUnpackedGroupedConvProgramInfoLoader,init_conv_grouped=__esm({"web/lib/onnxjs/backends/webgl/ops/conv-grouped.ts"(){init_instrument(),init_glsl_source(),init_types(),init_conv(),init_fuse_utils(),createUnpackedGroupedConvProgramMetadata=(t,e)=>({name:"GroupedConv",inputNames:t?["X","W","Bias"]:["X","W"],inputTypes:t?[0,0,0]:[0,0],cacheHint:e}),createUnpackedGroupedConvProgramInfo=(t,e,n,B)=>{const s=e.length>2?"value += getBias(output_channel);":"",F=e[0].dims.slice(),Q=e[1].dims.slice(),U=Q[0]/B.group;Logger.verbose("GroupedConv",`autpPad:${B.autoPad}, dilations:${B.dilations}, group:${B.group}, kernelShape:${B.kernelShape}, pads:${B.pads}, strides:${B.strides}`);const i=calculateOutputShape(F,Q,B.dilations,B.pads,B.strides),a=getGlsl(t.session.backend.glContext.version),{activationFunction:l,applyActivation:c}=getActivationSnippet(B),g=`\n  const ivec2 strides = ivec2(${B.strides[0]}, ${B.strides[1]});\n  const ivec2 pads = ivec2(${B.pads[0]}, ${B.pads[1]});\n  ${l}\n  void main() {\n    ivec4 coords = getOutputCoords();\n    int batch = coords.x;\n    int output_channel = coords.y;\n    ivec2 xRCCorner = coords.zw * strides - pads;\n    int group_id = output_channel / ${U};\n\n    float value = 0.0;\n    for (int wInChannel = 0; wInChannel < ${Q[1]}; wInChannel++) {\n      int input_channel = group_id * ${Q[1]} + wInChannel;\n      for (int wHeight = 0; wHeight < ${Q[2]}; wHeight++) {\n        int xHeight = xRCCorner.x + wHeight * ${B.dilations[0]};\n\n        if (xHeight < 0 || xHeight >= ${F[2]}) {\n          continue;\n        }\n\n        for (int wWidth = 0; wWidth < ${Q[3]}; wWidth++) {\n          int xWidth = xRCCorner.y + wWidth * ${B.dilations[1]};\n          if (xWidth < 0 || xWidth >= ${F[3]}) {\n            continue;\n          }\n\n          float xVal = getX(batch, input_channel, xWidth, xHeight);\n          float wVal = getW(output_channel, wInChannel, wWidth, wHeight);\n          value += xVal*wVal;\n        }\n      }\n    }\n    ${s}\n    ${c}\n    ${a.output} = vec4(value, .0, .0, .0);\n  }\n`;return{...n,output:{dims:i,type:e[0].type,textureType:0},shaderSource:g,hasMain:!0}},createUnpackedGroupedConvProgramInfoLoader=(t,e,n)=>{const B=createUnpackedGroupedConvProgramMetadata(e.length>2,n.cacheKey);return{...B,get:()=>createUnpackedGroupedConvProgramInfo(t,e,B,n)}}}}),createPackedIm2ColProgramMetadata,createPackedIm2ColProgramInfo,createPackedIm2ColProgramInfoLoader,init_im2col_pack=__esm({"web/lib/onnxjs/backends/webgl/ops/im2col-pack.ts"(){init_glsl_source(),init_types(),init_packing_utils(),createPackedIm2ColProgramMetadata=t=>({name:"Im2Col (packed)",inputNames:["A"],inputTypes:[2],cacheHint:t}),createPackedIm2ColProgramInfo=(t,e,n,B,s,F)=>{const Q=n.dims,U=B.dims,i=s.length,a=[U[1]*U[2]*U[3],s[2]*s[3]],l=U[2]*U[3],c=unpackFromChannel(),g=getGlsl(t.session.backend.glContext.version);let d="";for(let t=0;t<=1;t++)for(let e=0;e<=1;e++)d+=`\n            blockIndex = rc.x + ${e};\n            pos = rc.y + ${t};\n\n            if(blockIndex < ${a[1]} && pos < ${a[0]}) {\n              offsetY = int(blockIndex / (${s[i-1]})) * ${F.strides[0]} -\n                ${F.pads[0]};\n              d0 = offsetY + ${F.dilations[0]} * (imod(pos, ${l}) / ${U[2]});\n\n              if(d0 < ${Q[2]} && d0 >= 0) {\n                offsetX = imod(blockIndex, ${s[i-1]}) * ${F.strides[1]} -\n                  ${F.pads[1]};\n                d1 = offsetX + ${F.dilations[1]} * imod(imod(pos, ${l}), ${U[2]});\n\n                if(d1 < ${Q[3]} && d1 >= 0) {\n\n                  ch = int(float(pos)/ ${l}.);\n                    innerDims = vec2(d0, d1);\n                    result[${2*t+e}] = getChannel(\n                      getA(0, ch, int(innerDims.x),\n                      int(innerDims.y)), innerDims);\n                }\n              }\n            }\n\n          `;const I=`\n      ${c}\n\n      void main() {\n        ivec2 rc = getOutputCoords();\n          vec4 result = vec4(0.0);\n          int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n          vec2 innerDims;\n          ${d}\n          ${g.output} = result;\n      }\n            `;return{...e,output:{dims:a,type:n.type,textureType:2},shaderSource:I,hasMain:!0}},createPackedIm2ColProgramInfoLoader=(t,e,n,B,s)=>{const F=createPackedIm2ColProgramMetadata(s.cacheKey);return{...F,get:()=>createPackedIm2ColProgramInfo(t,F,e,n,B,s)}}}}),matMul,parseMatMulAttributes,createMatmulProgramMetadata,validateInputs4;function createMatmulProgramInfo(t,e,n){const B=e[0].dims,s=e[1].dims,F=BroadcastUtil.calcShape(B,s,!0);if(!F)throw new Error("Can't use matmul on the given tensors");const Q=getCoordsDataType(F.length),U=getGlChannels(),{activationFunction:i,applyActivation:a}=getActivationSnippet(n),l=e.length>2,c=l?"value += getBiasForMatmul();":"",g=l?`${getBiasForMatmul(Q,U,e[2].dims,F,!1)}`:"",d=F.length,I=B.length,o=s.length,r=`\n    ${i}\n    ${g}\n    float process(int indices[${d}]) {\n        int a[${I}];\n        int b[${o}];\n        bcastMatmulIndices_A(indices, a);\n        bcastMatmulIndices_B(indices, b);\n\n        float value;\n        for (int k=0; k<${B[B.length-1]}; ++k) {\n            a[${I-1}] = k;\n            b[${o-2}] = k;\n            value += _A(a) * _B(b);\n        }\n        ${c}\n        ${a}\n        return value;\n    }`;return{...t,output:{dims:F,type:e[0].type,textureType:0},shaderSource:r}}function createMatmulProgramInfoLoader(t,e){const n=createMatmulProgramMetadata(t.length>2,e.activationCacheKey);return{...n,get:()=>createMatmulProgramInfo(n,t,e)}}function getBiasForMatmul(t,e,n,B,s){let F="";const Q=n.length,U=B.length,i=U-Q;F=U<2&&Q>0?"coords":n.map(((t,n)=>`coords.${e[n+i]}`)).join(", ");const a=BroadcastUtil.getBroadcastDims(n,B).map((t=>`coords.${e[t+i]} = 0;`)).join("\n");let l="vec4(outputValue.xx, outputValue.yy)";1===ShapeUtil.size(n)&&(l="vec4(outputValue.x)");return s?`\nvec4 getBiasForMatmul() {\n  ${t} coords = getOutputCoords();\n  ${a}\n  vec4 outputValue = getBias(${F});\n  return ${l};\n}`:`\nfloat getBiasForMatmul() {\n  ${t} coords = getOutputCoords();\n  ${a}\n  return getBias(coords.x);\n}`}var init_matmul=__esm({"web/lib/onnxjs/backends/webgl/ops/matmul.ts"(){init_util(),init_types(),init_utils(),init_fuse_utils(),init_matmul_pack(),matMul=(t,e,n)=>(validateInputs4(e),t.session.pack?[t.run(createPackedMatmulProgramInfoLoader(t,e,n),e)]:[t.run(createMatmulProgramInfoLoader(e,n),e)]),parseMatMulAttributes=t=>parseInternalActivationAttributes(t.attributes),createMatmulProgramMetadata=(t,e)=>({name:"MatMul",inputNames:t?["A","B","Bias"]:["A","B"],inputTypes:t?[0,0,0]:[0,0],cacheHint:e}),validateInputs4=t=>{if(!t||2!==t.length)throw new Error("MatMul requires 2 inputs.");if(t[0].dims[t[0].dims.length-1]!==t[1].dims[t[1].dims.length-2])throw new Error("shared dimension does not match.");if("float32"!==t[0].type&&"float64"!==t[0].type||"float32"!==t[1].type&&"float64"!==t[1].type)throw new Error("inputs should be float type");if(t[0].type!==t[1].type)throw new Error("inputs types should match")}}}),createPackedMatmulProgramMetadata,createPackedMatmulProgramInfo,createPackedMatmulProgramInfoLoader;function getBcastSamplerForMatmul(t,e,n,B){let s=[],F=[];const Q=n[0].dims,U=n[1].dims,i=Q.length,a=U.length,l=B.length,c=l-i,g=l-a;s=Q.map(((t,n)=>`coords.${e[n+c]}`)),s[i-1]="i*2",s.join(", "),F=U.map(((t,n)=>`coords.${e[n+g]}`)),F[a-2]="i*2",F.join(", ");const d=BroadcastUtil.getBroadcastDims(Q,B),I=BroadcastUtil.getBroadcastDims(U,B),o=d.map((t=>`coords.${e[t+c]} = 0;`)).join("\n"),r=I.map((t=>`coords.${e[t+g]} = 0;`)).join("\n"),u=`int lastDim = coords.${e[l-1]};\n  coords.${e[l-1]} = coords.${e[l-2]};\n  coords.${e[l-2]} = lastDim;`;return`\nvec4 getAAtOutCoordsMatmul(int i) {\n  ${t} coords = getOutputCoords();\n  ${u}\n  ${o}\n  vec4 outputValue = getA(${s});\n  return outputValue;\n}\n\nvec4 getBAtOutCoordsMatmul(int i) {\n  ${t} coords = getOutputCoords();\n  ${u}\n  ${r}\n  vec4 outputValue = getB(${F});\n  return outputValue;\n}`}function getA(t,e){let n="";for(let B=0;B<e-2;B++)n+=`rc.${t[B]}, `;return n+=`rc.${t[e-2]}, i*2`,n}function getB(t,e){let n="";for(let B=0;B<e-2;B++)n+=`rc.${t[B]}, `;return n+=`i*2, rc.${t[e-1]}`,n}var init_matmul_pack=__esm({"web/lib/onnxjs/backends/webgl/ops/matmul-pack.ts"(){init_util(),init_glsl_source(),init_types(),init_utils(),init_fuse_utils(),init_matmul(),createPackedMatmulProgramMetadata=(t,e)=>({name:"MatMul (packed)",inputNames:t?["A","B","Bias"]:["A","B"],inputTypes:t?[2,2,2]:[2,2],cacheHint:e}),createPackedMatmulProgramInfo=(t,e,n,B)=>{const s=n.length>2,F=s?"value += getBiasForMatmul();":"",Q=n[0].dims,U=n[1].dims,i=BroadcastUtil.calcShape(Q,U,!0),a=!ShapeUtil.areEqual(n[0].dims,n[1].dims);if(!i)throw new Error("Can't use matmul on the given tensors");const l=Q[Q.length-1],c=Math.ceil(l/2),g=Q.length,d=U.length,I=getGlsl(t.session.backend.glContext.version),o=getCoordsDataType(i.length),r=i.length,u=getGlChannels(),{activationFunction:b,applyActivation:C}=getActivationSnippet(B),p=s?`${getBiasForMatmul(o,u,n[2].dims,i,!0)}`:"",m=a?`${getBcastSamplerForMatmul(o,u,n,i)}`:"",G=a?"getAAtOutCoordsMatmul(i)":`getA(${getA(u,g)})`,V=a?"getBAtOutCoordsMatmul(i)":`getB(${getB(u,d)})`,x=`\n            ${m}\n            ${p}\n            ${b}\n            void main() {\n              ${a?"":`${o} rc =\n          getOutputCoords(); int lastDim = rc.${u[r-1]}; rc.${u[r-1]} =\n          rc.${u[r-2]}; rc.${u[r-2]} = lastDim;\n      `}\n\n              vec4 value = vec4(0);\n              for (int i = 0; i < ${c}; i++) {\n                vec4 a = ${G};\n                vec4 b = ${V};\n\n                value += (a.rrbb * b.rgrg);\n                value += (a.ggaa * b.baba);\n              }\n              ${F}\n              ${C}\n              ${I.output} = value;\n            }`;return{...e,output:{dims:i,type:n[0].type,textureType:2},shaderSource:x,hasMain:!0}},createPackedMatmulProgramInfoLoader=(t,e,n)=>{const B=createPackedMatmulProgramMetadata(e.length>2,n.activationCacheKey);return{...B,get:()=>createPackedMatmulProgramInfo(t,B,e,n)}}}}),conv2DPacked,init_conv_pack=__esm({"web/lib/onnxjs/backends/webgl/ops/conv-pack.ts"(){init_conv(),init_im2col_pack(),init_matmul_pack(),conv2DPacked=(t,e,n)=>{const B=e[0].dims,s=e[1].dims,F=calculateOutputShape(B,s,n.dilations,n.pads,n.strides),Q=t.run(createPackedIm2ColProgramInfoLoader(t,e[0],e[1],F,n),[e[0]]),U=t.reshapePacked(e[1],[s[0],s[1]*s[2]*s[3]]),i=3===e.length?[U,Q,e[2]]:[U,Q],a=t.run(createPackedMatmulProgramInfoLoader(t,i,n),i);return t.reshapePacked(a,F)}}}),createIm2ColProgramMetadata,createIm2ColProgramInfo,createIm2ColProgramInfoLoader,calculateIm2ColDims,init_im2col=__esm({"web/lib/onnxjs/backends/webgl/ops/im2col.ts"(){init_types(),createIm2ColProgramMetadata=t=>({name:"Im2Col",inputNames:["X"],inputTypes:[0],cacheHint:t}),createIm2ColProgramInfo=(t,e,n,B,s,F)=>{const Q=n.dims,U=B.dims,i=s.length,a=calculateIm2ColDims(Q,U,s,4),l=`\n        const int XC = ${Q[1]};\n        const int XH = ${Q[2]};\n        const int XW = ${Q[3]};\n        const int KH = ${F.kernelShape[0]};\n        const int KW = ${F.kernelShape[1]};\n        const int dilationH = ${F.dilations[0]};\n        const int dilationW = ${F.dilations[1]};\n        const int strideH = ${F.strides[0]};\n        const int strideW = ${F.strides[1]};\n        const int padH = ${F.pads[0]};\n        const int padW = ${F.pads[1]};\n        const int KHKW = KH*KW;\n        const int XCKHKW = XC * KHKW;\n        const int outputChannels = 4;\n        vec4 process(int indices[${i}]) {\n          int b  = indices[0]; // batch size\n          int oh = indices[1] * strideH - padH; //output height\n          int ow = indices[2] * strideW - padW; //output width\n          int p = indices[3] * outputChannels; //patch\n          vec4 value = vec4(0.0);\n          for(int i=0; i < outputChannels; ++i) {\n            if(p < XCKHKW) {\n              int patchC = p / KHKW;\n              int patchH = (p - patchC*KHKW) / KW;\n              int patchW = (p - patchC*KHKW) - patchH * KW;\n              int xh2 = oh + patchH * dilationH;\n              int xw2 = ow + patchW * dilationW;\n              int x[${Q.length}];\n              x[0] = b;\n              x[1] = patchC;\n              x[2] = xh2;\n              x[3] = xw2;\n              if(xh2 >= 0 &&\n                  xh2 < XH &&\n                  xw2 >= 0 &&\n                  xw2 < XW) {\n                value[i] = _X(x);\n              }\n            }\n            ++p;\n          }\n          return value;\n        }\n        `;return{...e,output:{dims:a,type:n.type,textureType:4},shaderSource:l}},createIm2ColProgramInfoLoader=(t,e,n,B,s)=>{const F=createIm2ColProgramMetadata(s.cacheKey);return{...F,get:()=>createIm2ColProgramInfo(t,F,e,n,B,s)}},calculateIm2ColDims=(t,e,n,B=4)=>[n[0],n[2],n[3],Math.ceil(t[1]*e[2]*e[3]/B)]}}),createDotProductProgramMetadata,createDotProductProgramInfo,createDotProductProgramInfoLoader,init_dot_product=__esm({"web/lib/onnxjs/backends/webgl/ops/dot-product.ts"(){init_util(),init_glsl_source(),init_types(),init_fuse_utils(),init_im2col(),createDotProductProgramMetadata=(t,e)=>({name:"ConvDotProduct",inputNames:t?["Im2Col","K","B"]:["Im2Col","K"],inputTypes:t?[0,4,0]:[0,4],cacheKey:e.activationCacheKey}),createDotProductProgramInfo=(t,e,n,B,s)=>{const F=n[0].dims,Q=n[1].dims,U=[Q[0],Math.ceil(F[1]*Q[2]*Q[3]/4)],i=calculateIm2ColDims(F,Q,B),[a,l]=t.calculateTextureWidthAndHeight(U,4),c=ShapeUtil.computeStrides(i),[g,d]=t.calculateTextureWidthAndHeight(i,4),I=B.length,o=n.length<3?"0.0":"_B(b)",r=Math.ceil(F[1]*Q[2]*Q[3]/4),{activationFunction:u,applyActivation:b}=getActivationSnippet(s),C=getGlsl(t.session.backend.glContext.version),p=`\n${u}\nfloat process(int indices[${I}]) {\n  int b[1];\n  b[0] = indices[1];\n  int im2col[4];\n  im2col[0] = indices[0];\n  im2col[1] = indices[2];\n  im2col[2] = indices[3];\n  int im2colOffset = im2col[0] * ${c[0]} + im2col[1] * ${c[1]} + im2col[2] * ${c[2]};\n  int kernelOffset = indices[1] * ${U[1]};\n  float value = ${o};\n  for (int i = 0; i < ${r}; ++i) {\n    vec2 im2colCoords = offsetToCoords(im2colOffset, ${g}, ${d});\n    vec2 kernelCoords = offsetToCoords(kernelOffset, ${a}, ${l});\n    value += dot(${C.texture2D}(Im2Col, im2colCoords), ${C.texture2D}(K, kernelCoords));\n    ++im2colOffset;\n    ++kernelOffset;\n  }\n  ${b}\n  return value;\n}`;return{...e,output:{dims:B,type:n[0].type,textureType:0},shaderSource:p}},createDotProductProgramInfoLoader=(t,e,n,B)=>{const s=createDotProductProgramMetadata(e.length>2,B);return{...s,get:()=>createDotProductProgramInfo(t,s,e,n,B)}}}}),calculateOutputShape,conv,conv2d,conv2DUnpackedPointwise,conv2DUnpacked,getAdjustedConvAttributes,parseConvAttributes,validateInputs5,init_conv=__esm({"web/lib/onnxjs/backends/webgl/ops/conv.ts"(){init_attribute_with_cache_key(),init_util(),init_conv_grouped(),init_conv_pack(),init_dot_product(),init_fuse_utils(),init_im2col(),init_matmul(),calculateOutputShape=(t,e,n,B,s)=>{const F=t[0],Q=t.slice(2),U=Q.length,i=e[0],a=e.slice(2).map(((t,e)=>t+(t-1)*(n[e]-1))),l=Q.map(((t,e)=>t+B[e]+B[e+U])).map(((t,e)=>Math.floor((t-a[e]+s[e])/s[e])));return[F,i].concat(...l)},conv=(t,e,n)=>(validateInputs5(e,n),conv2d(t,e,n)),conv2d=(t,e,n)=>{const B=getAdjustedConvAttributes(n,e),s=t.session.pack,F=1===B.kernelShape[0]&&1===B.kernelShape[1];if(B.group>1){return[t.run(createUnpackedGroupedConvProgramInfoLoader(t,e,B),e)]}return F&&s?[conv2DUnpackedPointwise(t,e,B)]:s&&4===e[0].dims.length&&1===e[0].dims[0]&&!F?[conv2DPacked(t,e,B)]:[conv2DUnpacked(t,e,B)]},conv2DUnpackedPointwise=(t,e,n)=>{const B=e[0].dims,s=e[1].dims,F=calculateOutputShape(B,s,n.dilations,n.pads,n.strides),Q=t.reshapeUnpacked(e[0],[B[1],B[2]*B[3]]),U=t.reshapeUnpacked(e[1],[s[0],s[1]]),i=e.length>2?[U,Q,e[2]]:[U,Q],a=t.run(createMatmulProgramInfoLoader(i,n),i);return t.reshapeUnpacked(a,F)},conv2DUnpacked=(t,e,n)=>{const B=e[0].dims,s=e[1].dims,F=calculateOutputShape(B,s,n.dilations,n.pads,n.strides),Q=t.run(createIm2ColProgramInfoLoader(t,e[0],e[1],F,n),[e[0]]),U=3===e.length?[Q,e[1],e[2]]:[Q,e[1]];return t.run(createDotProductProgramInfoLoader(t,e,F,n),U)},getAdjustedConvAttributes=(t,e)=>{const n=t.kernelShape.slice();if(0===t.kernelShape.length)for(let t=2;t<e[1].dims.length;++t)n.push(e[1].dims[t]);const B=t.pads.slice();PoolConvUtil.adjustPadsBasedOnAutoPad(e[0].dims,t.strides,t.dilations,n,B,t.autoPad);const s=Object.assign({},t);return Object.assign(s,{kernelShape:n,pads:B,cacheKey:t.cacheKey}),s},parseConvAttributes=t=>{const e=t.attributes,n=parseInternalActivationAttributes(e),B=e.getString("auto_pad","NOTSET"),s=e.getInts("dilations",[1,1]),F=e.getInt("group",1),Q=e.getInts("kernel_shape",[]),U=e.getInts("pads",[0,0,0,0]),i=e.getInts("strides",[1,1]);return createAttributeWithCacheKey({autoPad:B,dilations:s,group:F,kernelShape:Q,pads:U,strides:i,...n})},validateInputs5=(t,e)=>{if(!t||2!==t.length&&3!==t.length)throw new Error("Conv requires 2 or 3 inputs");if(4!==t[0].dims.length||4!==t[1].dims.length)throw new Error("currently only support 2-dimensional conv");if(t[0].dims[1]!==t[1].dims[1]*e.group)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");if(3===t.length&&(1!==t[2].dims.length||t[1].dims[0]!==t[2].dims[0]))throw new Error("invalid bias");const n=t[0].dims.length-2;if(e.dilations.length!==n)throw new Error(`dilations should be ${n}D`);if(e.strides.length!==n)throw new Error(`strides should be ${n}D`);if(e.pads.length!==2*n)throw new Error(`pads should be ${2*n}D`);if(0!==e.kernelShape.length&&e.kernelShape.length!==t[1].dims.length-2)throw new Error("invalid kernel shape");if("float32"!==t[0].type||"float32"!==t[1].type)throw new Error("Conv input(X,W) should be float tensor");if(3===t.length&&"float32"!==t[2].type)throw new Error("Conv input(bias) should be float tensor")}}}),computeTotalPad,distributePadding,calculateOutputShapeAndPads,convTranspose,convTranspose2d,createConvTransposeProgramMetadata,createUnpackedConvTransposeProgramInfo,createUnpackedConvTransposeProgramInfoLoader,convTranspose2DUnpacked,getAdjustedConvTransposeAttributes,parseConvTransposeAttributes,validateInputs6,init_conv_transpose=__esm({"web/lib/onnxjs/backends/webgl/ops/conv-transpose.ts"(){init_attribute_with_cache_key(),init_glsl_source(),init_types(),init_fuse_utils(),computeTotalPad=(t,e,n,B,s,F)=>(t-1)*e+n+(B-1)*s+1-F,distributePadding=(t,e,n,B,s)=>{const F=Math.floor(t/2);"SAME_UPPER"===e?(n[B]=F,n[s]=t-F):"SAME_LOWER"===e&&(n[B]=t-F,n[s]=F)},calculateOutputShapeAndPads=(t,e,n,B,s,F,Q,U)=>{const i=t.length-2,a=0===U.length;for(let l=0;l<i;++l){const c=a?t[l+2]*F[l]:U[l],g=computeTotalPad(t[l+2],F[l],s[l],e[l],n[l],c);distributePadding(g,B,s,l,l+i),a&&U.push(F[l]*(t[l+2]-1)+Q[l]+(e[l]-1)*n[l]+1-s[l]-s[l+i])}},convTranspose=(t,e,n)=>(validateInputs6(e,n),convTranspose2d(t,e,n)),convTranspose2d=(t,e,n)=>{const B=getAdjustedConvTransposeAttributes(n,e);return[convTranspose2DUnpacked(t,e,B)]},createConvTransposeProgramMetadata=(t,e)=>({name:"ConvTranspose",inputNames:t?["X","W","B"]:["X","W"],inputTypes:t?[0,0,0]:[0,0],cacheHint:e}),createUnpackedConvTransposeProgramInfo=(t,e,n,B)=>{const s=e.length>2?"getB(output_channel)":"0.0",F=e[0].dims,Q=e[1].dims,U=Q[1],i=Q[0]/B.group,a=[e[0].dims[0],e[1].dims[1]*B.group,...B.outputShape],l=getGlsl(t.session.backend.glContext.version),{activationFunction:c,applyActivation:g}=getActivationSnippet(B),d=`\n  const ivec2 strides = ivec2(${B.strides[0]}, ${B.strides[1]});\n  const ivec2 pads = ivec2(${B.pads[0]}, ${B.pads[1]});\n  ${c}\n  void main() {\n    ivec4 coords = getOutputCoords();\n    int batch = coords.x;\n    int output_channel = coords.y;\n\n    ivec2 loc = coords.zw + pads;\n\n    int group_id = output_channel / ${U};\n    int wOutChannel = output_channel - group_id * ${U};\n\n    float value = ${s};\n    for (int inChannelOffset = 0; inChannelOffset < ${i}; inChannelOffset++) {\n      int input_channel = group_id * ${i} + inChannelOffset;\n      for (int wWOff = 0; wWOff < ${Q[2]}; wWOff++) {\n        for (int wHOff = 0; wHOff < ${Q[3]}; wHOff++) {\n          ivec2 wOff = ivec2(wWOff * ${B.dilations[0]}, wHOff * ${B.dilations[1]});\n          ivec2 wLoc = loc - wOff;\n          ivec2 wLocIn = wLoc / strides;\n          if (\n            wLocIn * strides == wLoc &&\n            wLocIn.x >= 0 && wLocIn.x < ${F[2]} &&\n            wLocIn.y >= 0 && wLocIn.y < ${F[3]}\n          ) {\n            float xVal = getX(batch, input_channel, wLocIn.y, wLocIn.x);\n            float wVal = getW(input_channel, wOutChannel, wHOff, wWOff);\n            value += xVal * wVal;\n          }\n        }\n      }\n    }\n    ${g}\n    ${l.output} = vec4(value, .0, .0, .0);\n  }\n`;return{...n,output:{dims:a,type:e[0].type,textureType:0},shaderSource:d,hasMain:!0}},createUnpackedConvTransposeProgramInfoLoader=(t,e,n)=>{const B=createConvTransposeProgramMetadata(e.length>2,n.cacheKey);return{...B,get:()=>createUnpackedConvTransposeProgramInfo(t,e,B,n)}},convTranspose2DUnpacked=(t,e,n)=>t.run(createUnpackedConvTransposeProgramInfoLoader(t,e,n),e),getAdjustedConvTransposeAttributes=(t,e)=>{const n=t.kernelShape.slice();if(0===t.kernelShape.length)for(let t=2;t<e[1].dims.length;++t)n.push(e[1].dims[t]);const B=t.pads.slice(),s=t.outputShape.slice(),F=e[0].dims;calculateOutputShapeAndPads(F,n,t.dilations,t.autoPad,B,t.strides,t.outputPadding,s);const Q=Object.assign({},t);return Object.assign(Q,{kernelShape:n,pads:B,outputShape:s,cacheKey:t.cacheKey}),Q},parseConvTransposeAttributes=t=>{const e=t.attributes,n=parseInternalActivationAttributes(e),B=e.getString("auto_pad","NOTSET"),s=e.getInts("dilations",[1,1]),F=e.getInt("group",1),Q=e.getInts("kernel_shape",[]),U=e.getInts("output_padding",[0,0]),i=e.getInts("output_shape",[]),a=e.getInts("pads",[0,0,0,0]),l=e.getInts("strides",[1,1]);return createAttributeWithCacheKey({autoPad:B,dilations:s,group:F,kernelShape:Q,outputPadding:U,outputShape:i,pads:a,strides:l,...n})},validateInputs6=(t,e)=>{if(!t||2!==t.length&&3!==t.length)throw new Error("Conv requires 2 or 3 inputs");if(4!==t[0].dims.length||4!==t[1].dims.length)throw new Error("currently only support 2-dimensional conv");if(t[0].dims[1]!==t[1].dims[0])throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");const n=t[1].dims[1]*e.group;if(3===t.length&&(1!==t[2].dims.length||t[2].dims[0]!==n))throw new Error("invalid bias");const B=t[0].dims.length-2;if(e.dilations.length!==B)throw new Error(`dilations should be ${B}D`);if(e.strides.length!==B)throw new Error(`strides should be ${B}D`);if(e.pads.length!==2*B)throw new Error(`pads should be ${2*B}D`);if(e.outputPadding.length!==B)throw new Error(`output_padding should be ${B}D`);if(0!==e.kernelShape.length&&e.kernelShape.length!==t[1].dims.length-2)throw new Error("invalid kernel shape");if(0!==e.outputShape.length&&e.outputShape.length!==t[0].dims.length-2)throw new Error("invalid output shape");if("float32"!==t[0].type||"float32"!==t[1].type)throw new Error("ConvTranspose input(X,W) should be float tensor");if(3===t.length&&"float32"!==t[2].type)throw new Error("ConvTranspose input(bias) should be float tensor")}}}),transposeProgramMetadata,transpose,parseTransposeAttributes,createTransposeProgramInfo,getAdjustedPerm,getOutputShape,getPermFunctionBody,validateInputs7,init_transpose=__esm({"web/lib/onnxjs/backends/webgl/ops/transpose.ts"(){init_attribute_with_cache_key(),init_util(),init_types(),transposeProgramMetadata={name:"Transpose",inputNames:["A"],inputTypes:[0]},transpose=(t,e,n)=>{validateInputs7(e);return[t.run({...transposeProgramMetadata,cacheHint:n.cacheKey,get:()=>createTransposeProgramInfo(t,e[0],n.perm)},e)]},parseTransposeAttributes=t=>createAttributeWithCacheKey({perm:t.attributes.getInts("perm",[])}),createTransposeProgramInfo=(t,e,n)=>{const B=e.dims;n=getAdjustedPerm(B,n);const s=getOutputShape(B,n),F=B.length,Q=`\n      ${getPermFunctionBody("perm",n,F)}\n      float process(int indices[${F}]) {\n        int a[${F}];\n        perm(a, indices);\n        return _A(a);\n      }`;return{...transposeProgramMetadata,output:{dims:s,type:e.type,textureType:0},shaderSource:Q}},getAdjustedPerm=(t,e)=>(e&&e.length!==t.length&&(e=[...t.keys()].reverse()),e),getOutputShape=(t,e)=>(e=getAdjustedPerm(t,e),ShapeUtil.sortBasedOnPerm(t,e)),getPermFunctionBody=(t,e,n)=>{const B=[];B.push(`void ${t}(out int a[${n}], int src[${n}]) {`);for(let t=0;t<n;++t)B.push(`\ta[${e[t]}]=src[${t}];`);return B.push("\t}"),B.join("\n")},validateInputs7=t=>{if(!t||1!==t.length)throw new Error("Transpose requires 1 input.");if("float32"!==t[0].type&&"float64"!==t[0].type)throw new Error("input should be float tensor")}}}),depthToSpace,parseDepthToSpaceAttributes,validateInputs8,init_depth_to_space=__esm({"web/lib/onnxjs/backends/webgl/ops/depth-to-space.ts"(){init_transpose(),depthToSpace=(t,e,n)=>{validateInputs8(e);const B=n.blocksize,s=B*B,F="DCR"===n.mode?[0,3,4,1,5,2]:[0,1,4,2,5,3],Q="DCR"===n.mode?[e[0].dims[0],B,B,e[0].dims[1]/s,e[0].dims[2],e[0].dims[3]]:[e[0].dims[0],e[0].dims[1]/s,B,B,e[0].dims[2],e[0].dims[3]],U=t.reshapeUnpacked(e[0],Q),i={perm:F,cacheKey:`${F}`},[a]=transpose(t,[U],i),l=[e[0].dims[0],e[0].dims[1]/s,e[0].dims[2]*B,e[0].dims[3]*B];return[t.reshapeUnpacked(a,l)]},parseDepthToSpaceAttributes=t=>{const e=t.attributes.getInt("blocksize");if(e<1)throw new Error(`blocksize must be >= 1, but got : ${e} for DepthToSpace`);const n=t.attributes.getString("mode","DCR");if("DCR"!==n&&"CRD"!==n)throw new Error(`unrecognized mode: ${n} for DepthToSpace`);return{mode:n,blocksize:e}},validateInputs8=t=>{if(1!==t.length)throw new Error(`DepthToSpace expect 1 inputs, but got ${t.length}`);if("string"===t[0].type||4!==t[0].dims.length)throw new TypeError("DepthToSpace input should be a 4-D numeric tensor")}}}),flatten,parseFlattenAttributes,validateInputs9,init_flatten=__esm({"web/lib/onnxjs/backends/webgl/ops/flatten.ts"(){init_util(),flatten=(t,e,n)=>{validateInputs9(e,n);const B=ShapeUtil.flattenShape(e[0].dims,n);return[t.reshapeUnpacked(e[0],B)]},parseFlattenAttributes=t=>t.attributes.getInt("axis",1),validateInputs9=(t,e)=>{if(!t||1!==t.length)throw new Error("Flatten requires 1 input.");const n=t[0].dims.length;if(0===n)throw new Error("scalar tensor is not supported.");if(e<-n||e>n)throw new Error("Invalid axis");if("string"===t[0].type)throw new Error("string tensor is not supported.")}}}),NUMBER_TYPES,init_operators=__esm({"web/lib/onnxjs/operators.ts"(){NUMBER_TYPES=["float32","float64","int32","int16","int8","uint16","uint32","uint8"]}}),gather,parseGatherAttributes,gatherProgramMetadata,createGatherProgramInfo,createGatherProgramInfoLoader,validateInputs10,init_gather=__esm({"web/lib/onnxjs/backends/webgl/ops/gather.ts"(){init_attribute_with_cache_key(),init_operators(),init_util(),init_types(),gather=(t,e,n)=>{validateInputs10(e,n.axis);return[t.run(createGatherProgramInfoLoader(t,e,n),e)]},parseGatherAttributes=t=>createAttributeWithCacheKey({axis:t.attributes.getInt("axis",0)}),gatherProgramMetadata={name:"Gather",inputNames:["A","B"],inputTypes:[0,0]},createGatherProgramInfo=(t,e,n,B)=>{const s=n[0].dims.slice(),F=n[1].dims.slice(),Q=new Array(s.length+F.length-1);B=ShapeUtil.normalizeAxis(B,s.length);const U=[];for(let t=0;t<Q.length;t++)t<B?(Q[t]=s[t],U.push(`inputIdx[${t}] = outputIdx[${t}];`)):t<B+F.length?(Q[t]=F[t-B],U.push(`indexDataIdx[${t-B}] = outputIdx[${t}];`)):(Q[t]=s[t-F.length+1],U.push(`inputIdx[${t-F.length+1}] = outputIdx[${t}];`));const i=`\n      float process(int outputIdx[${Q.length||1}]) {\n        int inputIdx[${s.length}];\n        int indexDataIdx[${F.length||1}];\n        indexDataIdx[0] = 0;\n        ${U.join("\n        ")}\n        int idx = int(_B(indexDataIdx));\n        inputIdx[${B}] = idx < 0 ? idx + ${s[B]} : idx;\n        return _A(inputIdx);\n      }`;return{...e,output:{dims:Q,type:n[0].type,textureType:0},shaderSource:i}},createGatherProgramInfoLoader=(t,e,n)=>{const B={...gatherProgramMetadata,cacheHint:n.cacheKey};return{...B,get:()=>createGatherProgramInfo(t,B,e,n.axis)}},validateInputs10=(t,e)=>{if(!t||2!==t.length)throw new Error("Gather requires 2 inputs.");const n=t[0].dims.length;if(n<1)throw new Error("Invalid input shape.");if(e<-n||e>n-1)throw new Error("Invalid axis.");if(-1===NUMBER_TYPES.indexOf(t[0].type))throw new Error("Invaid input type.");if("int32"!==t[1].type&&"int16"!==t[1].type)throw new Error("Invaid input type.")}}}),gemm,parseGemmAttributes,parseGemmAttributesV7,parseGemmAttributesV11,createGemmProgramInfoLoader,createGemmProgramInfo,validateInputs11,init_gemm=__esm({"web/lib/onnxjs/backends/webgl/ops/gemm.ts"(){init_attribute_with_cache_key(),init_util(),init_types(),gemm=(t,e,n)=>{validateInputs11(e,n);return[t.run(createGemmProgramInfoLoader(e,n),e)]},parseGemmAttributes=(t,e)=>{const n=0!==t.attributes.getInt("transA",0),B=0!==t.attributes.getInt("transB",0),s=t.attributes.getFloat("alpha",1),F=t.attributes.getFloat("beta",1);return createAttributeWithCacheKey({transA:n,transB:B,alpha:s,beta:F,isOptionalC:e})},parseGemmAttributesV7=t=>parseGemmAttributes(t,!1),parseGemmAttributesV11=t=>parseGemmAttributes(t,!0),createGemmProgramInfoLoader=(t,e)=>{const n={name:"Gemm",inputNames:3===t.length?["A","B","C"]:["A","B"],inputTypes:3===t.length?[0,0,0]:[0,0],key:e.cacheKey};return{...n,get:()=>createGemmProgramInfo(n,t,e)}},createGemmProgramInfo=(t,e,n)=>{const B=e[0].dims.slice(),s=e[1].dims.slice(),[F,Q]=GemmUtil.getShapeOfGemmResult(B,n.transA,s,n.transB,3===e.length?e[2].dims:void 0),U=[F,Q];if(!U)throw new Error("Can't use gemm on the given tensors");let i=B[B.length-1],a="";n.transA&&(i=B[0]),n.transA&&n.transB?a="value += _A_T(a) * _B_T(b);":n.transA&&!n.transB?a="value += _A_T(a) * _B(b);":!n.transA&&n.transB?a="value += _A(a) * _B_T(b);":n.transA||n.transB||(a="value += _A(a) * _B(b);");const l=U.length,c=`\n      float process(int indices[${l}]) {\n          int a[${l}];\n          int b[${l}];\n          ${3===e.length?`int c[${e[2].dims.length}];`:""}\n\n          copyVec(indices, a);\n          copyVec(indices, b);\n          ${3===e.length?"bcastIndices_C(indices, c);":""}\n\n          float value = 0.0;\n          for (int k=0; k<${i}; ++k) {\n              a[${l-1}] = k;\n              b[${l-2}] = k;\n              ${a}\n          }\n\n          value = value * alpha;\n          ${3===e.length?"value += beta * _C(c);":""}\n          return value;\n      }`;return{...t,output:{dims:U,type:e[0].type,textureType:0},variables:[{name:"alpha",type:"float",data:n.alpha},{name:"beta",type:"float",data:n.beta}],shaderSource:c}},validateInputs11=(t,e)=>{if(!t)throw new Error("Input is missing");if(e.isOptionalC&&(t.length<2||t.length>3))throw new Error("Invaid input shape.");if(!e.isOptionalC&&3!==t.length)throw new Error("Gemm requires 3 inputs");if(3===t.length&&1!==t[2].dims.length&&2!==t[2].dims.length)throw new Error("Invalid input shape of C");if("float32"!==t[0].type&&"float64"!==t[0].type||"float32"!==t[1].type&&"float64"!==t[1].type||3===t.length&&"float32"!==t[2].type&&"float64"!==t[2].type)throw new Error("Invalid input type.");if(t[0].type!==t[1].type||3===t.length&&t[0].type!==t[2].type)throw new Error("Input types are mismatched")}}}),imageScaler,parseImageScalerAttributes,imageScalerProgramMetadata,createImageScalerProgramInfo,createImageScalerProgramInfoLoader,createGetBiasMethod,validateInputs12,init_image_scaler=__esm({"web/lib/onnxjs/backends/webgl/ops/image-scaler.ts"(){init_attribute_with_cache_key(),init_types(),imageScaler=(t,e,n)=>{validateInputs12(e);return[t.run(createImageScalerProgramInfoLoader(t,e,n),e)]},parseImageScalerAttributes=t=>{const e=t.attributes.getFloat("scale"),n=t.attributes.getFloats("bias");return createAttributeWithCacheKey({scale:e,bias:n})},imageScalerProgramMetadata={name:"ImageScaler",inputNames:["X"],inputTypes:[0]},createImageScalerProgramInfo=(t,e,n,B)=>{const s=n[0].dims.slice(),F=s.length,Q=`\n      ${createGetBiasMethod(B.bias.length)}\n      float process(int indices[${F}]) {\n        return _X(indices) * scale + getBias(bias, indices[1]);\n      }`;return{...e,output:{dims:s,type:n[0].type,textureType:0},variables:[{name:"bias",type:"float",arrayLength:B.bias.length,data:B.bias},{name:"scale",type:"float",data:B.scale}],shaderSource:Q}},createImageScalerProgramInfoLoader=(t,e,n)=>{const B={...imageScalerProgramMetadata,cacheHint:n.cacheKey};return{...B,get:()=>createImageScalerProgramInfo(t,B,e,n)}},createGetBiasMethod=t=>{const e=[`float getBias(float bias[${t}], int channel) {`];for(let n=0;n<t;++n)0===n?e.push(`\tif (channel == ${n}) { return bias[${n}]; }`):n===t-1?e.push(`\telse { return bias[${n}]; }`):e.push(`\telse if (channel == ${n}) { return bias[${n}]; }`);return e.push("\t}"),e.join("\n")},validateInputs12=t=>{if(!t||1!==t.length)throw new Error("ImageScaler requires 1 input.");if(4!==t[0].dims.length)throw new Error("Invalid input shape.");if("float32"!==t[0].type&&"float64"!==t[0].type)throw new Error("Invalid input type.")}}}),instanceNormalization,parseInstanceNormalizationAttributes,meanAndVarianceProgramMetadata,createMeanAndVarianceProgramInfo,createMeanAndVarianceProgramInfoLoader,computeOutputProgramMetadata,createComputeOutputProgramInfo,createComputeOutputProgramInfoLoader,validateInputs13,init_instance_normalization=__esm({"web/lib/onnxjs/backends/webgl/ops/instance-normalization.ts"(){init_glsl_source(),init_types(),instanceNormalization=(t,e,n)=>{validateInputs13(e);const B=t.run(createMeanAndVarianceProgramInfoLoader(e[0]),e);return[t.run(createComputeOutputProgramInfoLoader(t,e[0],n,B.dims),[e[0],B,e[1],e[2]])]},parseInstanceNormalizationAttributes=t=>t.attributes.getFloat("epsilon",1e-5),meanAndVarianceProgramMetadata={name:"InstanceNormalization_MeanAndVariance",inputNames:["X"],inputTypes:[0]},createMeanAndVarianceProgramInfo=(t,e)=>{const n=e.dims.slice(),B=n[1],s=n[2]*n[3],F=[n[0],B],Q=`\n      vec4 process(int[2] indices) {\n        vec4 v = vec4(0.0);\n        int a[4];\n        a[0] = indices[0];\n        a[1] = indices[1];\n        float temp = 0.0;\n        for(int a2=0; a2<${n[2]}; a2++) {\n          a[2] = a2;\n          for(int a3=0; a3<${n[3]}; a3++) {\n            a[3] = a3;\n            float x = _X(a);\n            temp += x;\n          }\n        }\n        float mean = temp / float(${s});\n        temp = 0.0;\n        for(int a2=0; a2<${n[2]}; a2++) {\n          a[2] = a2;\n          for(int a3=0; a3<${n[3]}; a3++) {\n            a[3] = a3;\n            float x = _X(a);\n            temp += (x - mean) * (x - mean);\n          }\n        }\n        v.r = mean;\n        v.g = temp / float(${s});\n\n        return v;\n      }`;return{...t,output:{dims:F,type:e.type,textureType:4},shaderSource:Q}},createMeanAndVarianceProgramInfoLoader=t=>({...meanAndVarianceProgramMetadata,get:()=>createMeanAndVarianceProgramInfo(meanAndVarianceProgramMetadata,t)}),computeOutputProgramMetadata={name:"InstanceNormalization_ComputeOutput",inputNames:["X","MeanAndVariance","Scale","B"],inputTypes:[0,4,0,0]},createComputeOutputProgramInfo=(t,e,n,B,s)=>{const F=getGlsl(t.session.backend.glContext.version),[Q,U]=t.calculateTextureWidthAndHeight(s,4),[i,a]=[Q/4,U],l=`\n      vec4 get_MeanAndVariance(int[2] mv) {\n        int offset = indicesToOffset_MeanAndVariance(mv);\n        vec2 coords = offsetToCoords(offset, ${i}, ${a});\n        return ${F.texture2D}(MeanAndVariance, coords);\n      }\n\n      float process(int[4] indices) {\n        int mv[2];\n        mv[0] = indices[0];\n        mv[1] = indices[1];\n        vec4 mean_and_variance = get_MeanAndVariance(mv);\n        float mean = mean_and_variance.r;\n        float variance = mean_and_variance.g;\n\n        int sb[1];\n        sb[0] = indices[1];\n        float scale = _Scale(sb);\n        float b = _B(sb);\n\n        return scale * (_X(indices) - mean) / sqrt(variance + epsilon) + b;\n      }`;return{...e,output:{dims:n.dims,type:n.type,textureType:0},variables:[{name:"epsilon",type:"float",data:B}],shaderSource:l}},createComputeOutputProgramInfoLoader=(t,e,n,B)=>{const s={...computeOutputProgramMetadata,cacheHint:`${n}`};return{...s,get:()=>createComputeOutputProgramInfo(t,s,e,n,B)}},validateInputs13=t=>{if(!t||3!==t.length)throw new Error("InstanceNormalization requires 3 inputs.");const e=t[0],n=t[1],B=t[2];if(e.dims.length<3||1!==n.dims.length||1!==B.dims.length)throw new Error("Invalid input shape.");if(n.dims[0]!==e.dims[1]||B.dims[0]!==e.dims[1])throw new Error("Input shapes are mismatched.");if("float32"!==e.type&&"float64"!==e.type||"float32"!==n.type&&"float64"!==n.type||"float32"!==B.type&&"float64"!==B.type)throw new Error("Invalid input type.");if(4!==t[0].dims.length)throw new Error("Only support 4-D input shape.")}}}),lrn,parseLrnAttributes,lrnProgramMetadata,validateInputs14;function createLrnProgramInfo(t,e){const n=t[0].dims[1],B=t[0].dims.length,s=-Math.floor((e.size-1)/2),F=Math.ceil((e.size-1)/2),Q=`float(${e.alpha}) / float(${e.size})`,U=`\n    float process(int indices[${B}]) {\n        int c = indices[1];\n        float x = _X(indices);\n        float square_sum = 0.0;\n\n        for (int i = ${s}; i <= ${F}; i++) {\n          int idx = c + i;\n          if (c >= 0 && c < ${n}) {\n            indices[1] = idx;\n            float j = _X(indices);\n            square_sum += j * j;\n          }\n        }\n        return x / pow(${`float(${e.bias})`} + ${Q} * square_sum, ${`float(${e.beta})`});\n    }`;return{...lrnProgramMetadata,cacheHint:e.cacheKey,output:{dims:t[0].dims,type:t[0].type,textureType:0},shaderSource:U}}function createLrnProgramInfoLoader(t,e){return{...lrnProgramMetadata,cacheHint:e.cacheKey,get:()=>createLrnProgramInfo(t,e)}}var init_lrn=__esm({"web/lib/onnxjs/backends/webgl/ops/lrn.ts"(){init_attribute_with_cache_key(),init_types(),lrn=(t,e,n)=>(validateInputs14(e),[t.run(createLrnProgramInfoLoader(e,n),e)]),parseLrnAttributes=t=>{const e=t.attributes.getFloat("alpha",1e-4),n=t.attributes.getFloat("beta",.75),B=t.attributes.getFloat("bias",1),s=t.attributes.getInt("size");return createAttributeWithCacheKey({alpha:e,beta:n,bias:B,size:s})},lrnProgramMetadata={name:"LRN",inputNames:["X"],inputTypes:[0]},validateInputs14=t=>{if(!t||1!==t.length)throw new Error("LRN requires 1 input.");if(4!==t[0].dims.length)throw new Error('currently only support LRN for input with "NCHW" format');if("float32"!==t[0].type)throw new Error("input should be float type")}}}),padProgramMetadata,padV2,parsePadAttributesV2,padV11,parsePadAttributesV11,generatePadAttributesFromInputs,createPadProgramInfo,validateInputsV2,validateInputsV11,getPadFunction,getPadConstant,getPadReflect,getPadEdge,init_pad=__esm({"web/lib/onnxjs/backends/webgl/ops/pad.ts"(){init_attribute_with_cache_key(),init_util(),init_glsl_source(),init_types(),padProgramMetadata={name:"Pad",inputNames:["A"],inputTypes:[0]},padV2=(t,e,n)=>{validateInputsV2(e);return[t.run({...padProgramMetadata,cacheHint:n.cacheKey,get:()=>createPadProgramInfo(t,e[0],n)},e)]},parsePadAttributesV2=t=>{const e=t.attributes.getString("mode","constant"),n=t.attributes.getFloat("value",0),B=t.attributes.getInts("pads");return createAttributeWithCacheKey({mode:e,value:n,pads:B})},padV11=(t,e,n)=>{validateInputsV11(e);const B=generatePadAttributesFromInputs(t,e,n);return padV2(t,[e[0]],B)},parsePadAttributesV11=t=>t.attributes.getString("mode","constant"),generatePadAttributesFromInputs=(t,e,n)=>{if(!t.session.isInitializer(e[1].dataId)||e.length>=3&&!t.session.isInitializer(e[2].dataId))throw new Error("dynamic pad attributes are not allowed");const B=Array.from(e[1].integerData),s=e.length>=3?e[2].floatData[0]:0;return createAttributeWithCacheKey({mode:n,pads:B,value:s})},createPadProgramInfo=(t,e,n)=>{const B=ShapeUtil.padShape(e.dims.slice(),n.pads),s=B.length,F=`\n      ${getPadFunction(t,e,n)}\n      float process(int[${s}] indices) {\n          return padA(indices);\n      }`;return{name:"Pad",inputNames:["A"],inputTypes:[0],output:{dims:B,type:e.type,textureType:0},shaderSource:F}},validateInputsV2=t=>{if(!t||1!==t.length)throw new Error("Pad requires 1 input");if("float32"!==t[0].type&&"float64"!==t[0].type)throw new Error("Invalid input type.")},validateInputsV11=t=>{if(!t||2!==t.length&&3!==t.length)throw new Error("Pad requires 2 or 3 inputs");if("int32"!==t[1].type)throw new Error("Invalid input type.");if(t.length>=3&&"string"===t[2].type)throw new Error("Invalid input type.")},getPadFunction=(t,e,n)=>{const B=getGlsl(t.session.backend.glContext.version),[s,F]=t.calculateTextureWidthAndHeight(e.dims,0),Q=ShapeUtil.computeStrides(e.dims);switch(n.mode){case"constant":return getPadConstant(B,e.dims,Q,s,F,n.pads,n.value);case"reflect":return getPadReflect(B,e.dims,Q,s,F,n.pads);case"edge":return getPadEdge(B,e.dims,Q,s,F,n.pads);default:throw new Error("Invalid mode")}},getPadConstant=(t,e,n,B,s,F,Q)=>{const U=e.length;let i="";for(let t=U-1;t>=0;--t)i+=`\n        k = m[${t}] - ${F[t]};\n        if (k < 0)  return constant;\n        if (k >= ${e[t]}) return constant;\n        offset += k * ${n[t]};\n        `;return`\n      float padA(int m[${U}]) {\n        const float constant = float(${Q});\n        int offset = 0;\n        int k = 0;\n        ${i}\n        vec2 coords = offsetToCoords(offset, ${B}, ${s});\n        float value = getColorAsFloat(${t.texture2D}(A, coords));\n        return value;\n      }\n      `},getPadReflect=(t,e,n,B,s,F)=>{const Q=e.length;let U="";for(let t=Q-1;t>=0;--t)U+=`\n        k = m[${t}] - ${F[t]};\n        if (k < 0) { k = -k; }\n        {\n          const int _2n_1 = ${2*(e[t]-1)};\n          k = int( mod( float(k), float(_2n_1) ) ) ;\n          if(k >= ${e[t]}) { k = _2n_1 - k; }\n        }\n        offset += k * ${n[t]};\n        `;return`\n      float padA(int m[${Q}]) {\n        int offset = 0;\n        int k = 0;\n        ${U}\n        vec2 coords = offsetToCoords(offset, ${B}, ${s});\n        float value = getColorAsFloat(${t.texture2D}(A, coords));\n        return value;\n      }\n      `},getPadEdge=(t,e,n,B,s,F)=>{const Q=e.length;let U="";for(let t=Q-1;t>=0;--t)U+=`\n        k = m[${t}] - ${F[t]};\n        if (k < 0)  k = 0;\n        if (k >= ${e[t]}) k = ${e[t]-1};\n        offset += k * ${n[t]};\n      `;return`\n      float padA(int m[${Q}]) {\n        int offset = 0;\n        int k = 0;\n        ${U}\n        vec2 coords = offsetToCoords(offset, ${B}, ${s});\n        float value = getColorAsFloat(${t.texture2D}(A, coords));\n        return value;\n      }\n      `}}}),averagePool,parseAveragePoolAttributes,createAveragePoolProgramInfo,globalAveragePool,parseGlobalAveragePoolAttributes,maxPool,parseMaxPoolAttributes,createMaxPoolProgramInfo,getAdjustedPoolAttributesAndOutputShape,globalMaxPoolAttributes,globalMaxPoolMetadata,globalMaxPool,validateInputs15,generatePoolingCode,copyArray,offsetToIndices,init_pool=__esm({"web/lib/onnxjs/backends/webgl/ops/pool.ts"(){init_attribute_with_cache_key(),init_util(),init_types(),averagePool=(t,e,n)=>{validateInputs15(e);const B={name:"AveragePool",inputNames:["X"],inputTypes:[0],cacheHint:n.cacheKey};return[t.run({...B,get:()=>createAveragePoolProgramInfo(e,B,!1,n)},e)]},parseAveragePoolAttributes=t=>{const e=t.attributes.getString("auto_pad","NOTSET"),n=t.attributes.getInt("ceil_mode",0),B=0!==t.attributes.getInt("count_include_pad",0),s=t.attributes.getInts("kernel_shape"),F=t.attributes.getInts("strides",[]),Q=t.attributes.getInts("pads",[]);if(0!==n)throw new Error("using ceil() in shape computation is not yet supported for AveragePool");return createAttributeWithCacheKey({autoPad:e,ceilMode:n,countIncludePad:B,kernelShape:s,strides:F,pads:Q})},createAveragePoolProgramInfo=(t,e,n,B)=>{const[s,F]=getAdjustedPoolAttributesAndOutputShape(t,B,n),Q=ShapeUtil.size(s.kernelShape);let U="";s.countIncludePad?U+=`value /= float(${Q});`:U+=`value /= float(${Q} - pad);`;const i=`\n        ${generatePoolingCode(t[0].dims,s,"value += _X(x);",U,"0.0")}\n      `;return{...e,output:{dims:F,type:t[0].type,textureType:0},shaderSource:i}},globalAveragePool=(t,e,n)=>{validateInputs15(e);const B={name:"GlobalAveragePool",inputNames:["X"],inputTypes:[0],cacheHint:`${n.countIncludePad}`};return[t.run({...B,get:()=>createAveragePoolProgramInfo(e,B,!0,n)},e)]},parseGlobalAveragePoolAttributes=t=>{const e=0!==t.attributes.getInt("count_include_pad",0);return createAttributeWithCacheKey({autoPad:"",ceilMode:0,countIncludePad:e,kernelShape:[],strides:[],pads:[]})},maxPool=(t,e,n)=>{validateInputs15(e);const B={name:"MaxPool",inputNames:["X"],inputTypes:[0],cacheHint:n.cacheKey};return[t.run({...B,get:()=>createMaxPoolProgramInfo(e,B,!1,n)},e)]},parseMaxPoolAttributes=t=>{const e=t.attributes.getString("auto_pad","NOTSET"),n=t.attributes.getInt("ceil_mode",0),B=t.attributes.getInts("kernel_shape"),s=t.attributes.getInts("strides",[]),F=t.attributes.getInts("pads",[]),Q=t.attributes.getInt("storage_order",0),U=t.attributes.getInts("dilations",[]);if(0!==Q)throw new Error("column major storage order is not yet supported for MaxPool");if(0!==n)throw new Error("using ceil() in shape computation is not yet supported for MaxPool");return createAttributeWithCacheKey({autoPad:e,ceilMode:n,countIncludePad:!1,kernelShape:B,strides:s,pads:F,storageOrder:Q,dilations:U})},createMaxPoolProgramInfo=(t,e,n,B)=>{const[s,F]=getAdjustedPoolAttributesAndOutputShape(t,B,n),Q=`\n      ${generatePoolingCode(t[0].dims,s,"\n      value = max(_X(x), value);\n    ","","-1e5")}\n    `;return{...e,output:{dims:F,type:t[0].type,textureType:0},shaderSource:Q}},getAdjustedPoolAttributesAndOutputShape=(t,e,n)=>{const B=t[0].dims.slice(),s=Object.hasOwnProperty.call(e,"dilations"),F=e.kernelShape.slice(),Q=e.strides.slice(),U=s?e.dilations.slice():[],i=e.pads.slice();PoolConvUtil.adjustPoolAttributes(n,B,F,Q,U,i);const a=PoolConvUtil.computePoolOutputShape(n,B,Q,U,F,i,e.autoPad),l=Object.assign({},e);return s?Object.assign(l,{kernelShape:F,strides:Q,pads:i,dilations:U,cacheKey:e.cacheKey}):Object.assign(l,{kernelShape:F,strides:Q,pads:i,cacheKey:e.cacheKey}),[l,a]},globalMaxPoolAttributes={autoPad:"",ceilMode:0,countIncludePad:!1,kernelShape:[],strides:[],pads:[],storageOrder:0,dilations:[],cacheKey:""},globalMaxPoolMetadata={name:"GlobalMaxPool",inputNames:["X"],inputTypes:[0]},globalMaxPool=(t,e)=>{validateInputs15(e);return[t.run({...globalMaxPoolMetadata,get:()=>createMaxPoolProgramInfo(e,globalMaxPoolMetadata,!0,globalMaxPoolAttributes)},e)]},validateInputs15=t=>{if(!t||1!==t.length)throw new Error("Pool ops requires 1 input.");if("float32"!==t[0].type&&"float64"!==t[0].type)throw new Error("Invalid input type.")},generatePoolingCode=(t,e,n,B,s)=>{const F=t.length;if(e.kernelShape.length<=2){const Q=e.kernelShape[e.kernelShape.length-1],U=e.strides[e.strides.length-1],i=e.pads[e.pads.length/2-1],a=e.pads[e.pads.length-1],l=t[F-1];let c="",g="",d="";if(c=i+a!==0?`\n          for (int i = 0; i < ${Q}; i++) {\n            x[${F} - 1] = indices[${F} - 1] * ${U} - ${i} + i;\n            if (x[${F} - 1] < 0 || x[${F} - 1] >= ${l}) {\n              pad++;\n              continue;\n            }\n            ${n}\n          }`:`\n          for (int i = 0; i < ${Q}; i++) {\n            x[${F} - 1] = indices[${F} - 1] * ${U} - ${i} + i;\n            ${n}\n          }`,2===e.kernelShape.length){const n=e.kernelShape[e.kernelShape.length-2],B=e.strides[e.strides.length-2],s=e.pads[e.pads.length/2-2],U=e.pads[e.pads.length-2],i=t[F-2];g=s+U!==0?`\n            for (int j = 0; j < ${n}; j++) {\n              x[${F} - 2] = indices[${F} - 2] * ${B} - ${s} + j;\n              if (x[${F} - 2] < 0 || x[${F} - 2] >= ${i}) {\n                pad+= ${Q};\n                continue;\n              }\n          `:`\n            for (int j = 0; j < ${n}; j++) {\n              x[${F} - 2] = indices[${F} - 2] * ${B} - ${s} + j;\n            `,d="\n          }\n        "}return`\n        float process(int indices[${F}]) {\n          int x[${F}];\n          copyVec(indices, x);\n\n          float value = ${s};\n          int pad = 0;\n          ${g}\n          ${c}\n          ${d}\n          ${B}\n          return value;\n        }\n      `}{const Q=ShapeUtil.size(e.kernelShape),U=ShapeUtil.computeStrides(e.kernelShape),i=U.length,a=e.pads.length,l=offsetToIndices(i),c=copyArray(t,"inputDims"),g=copyArray(e.pads,"pads"),d=copyArray(U,"kernelStrides"),I=copyArray(e.strides,"strides");let o="";o=e.pads.reduce(((t,e)=>t+e))?`\n            if (x[j] >= inputDims[j] || x[j] < 0) {\n              pad++;\n              isPad = true;\n              break;\n            }\n          }\n          if (!isPad) {\n            ${n}\n          }`:`\n          }\n          ${n}\n        `;return`\n        ${l}\n        float process(int indices[${F}]) {\n          int x[${F}];\n          copyVec(indices, x);\n          int offset[${i}];\n          int pads[${a}];\n          int inputDims[${F}];\n          int kernelStrides[${i}];\n          int strides[${i}];\n          ${g}\n          ${c}\n          ${I}\n          ${d}\n\n          float value = ${s};\n          int pad = 0;\n          bool isPad = false;\n          for (int i = 0; i < ${Q}; i++) {\n            offsetToIndices(i, kernelStrides, offset);\n            isPad = false;\n            for (int j = ${F} - ${i}; j < ${F}; j++) {\n              x[j] = indices[j] * strides[j - ${F} + ${i}]\n                + offset[j - ${F} + ${i}] - pads[j - 2];\n              ${o}\n          }\n          ${B}\n\n          return value;\n        }\n      `}},copyArray=(t,e)=>{let n="";for(let B=0;B<t.length;B++)n+=`\n      ${e}[${B}] = ${t[B]};\n    `;return n},offsetToIndices=t=>`\n  void offsetToIndices(int offset, int[${t}] strides, out int[${t}] indices) {\n    if (${t} == 0) {\n      return;\n    }\n    for (int i = 0; i < ${t} - 1; ++i) {\n      indices[i] = offset / strides[i];\n      offset -= indices[i] * strides[i];\n    }\n    indices[${t} - 1] = offset;\n  }`}}),reduce,parseReduceAttributes,createReduceProgramInfo,validateInputs16,reduceSum,reduceMean,reduceMax,reduceMin,reduceProd,reduceLogSum,reduceLogSumSquare,init_reduce=__esm({"web/lib/onnxjs/backends/webgl/ops/reduce.ts"(){init_attribute_with_cache_key(),init_operators(),init_util(),init_types(),reduce=(t,e,n,B,s)=>{validateInputs16(e);const F={name:B,inputNames:["A"],inputTypes:[0]};return[t.run({...F,cacheHint:n.cacheKey,get:()=>createReduceProgramInfo(t,e,n,B,s,F)},e)]},parseReduceAttributes=t=>{const e=t.attributes.getInts("axes",[]),n=1===t.attributes.getInt("keepdims",1);return createAttributeWithCacheKey({axes:e,keepDims:n})},createReduceProgramInfo=(t,e,n,B,s,F)=>{const Q=[],U=e[0].dims.length||1,i=[],a=ShapeUtil.normalizeAxes(n.axes,e[0].dims.length),l=s(e,a);let c=l[1];for(let t=0;t<e[0].dims.length;t++)a.indexOf(t)>=0||0===a.length?(n.keepDims&&Q.push(1),c=`\n          for(int j${t} = 0; j${t} < ${e[0].dims[t]}; j${t}++) {\n            inputIdx[${t}] = j${t};\n            ${c}\n          }`):(i.push(`inputIdx[${t}] = outputIdx[${Q.length}];`),Q.push(e[0].dims[t]));const g=`\n      float process(int outputIdx[${Q.length||1}]) {\n        float value;                 // final result\n        int inputIdx[${U}];      // addressing input data\n        ${i.join("\n")}\n        ${l[0]}       // init ops for reduce max/min\n        ${c}\n        ${l[2]}       // final computation for reduce mean\n        return value;\n      }`;return{...F,output:{dims:Q,type:e[0].type,textureType:0},shaderSource:g}},validateInputs16=t=>{if(!t||1!==t.length)throw new Error("Reduce op requires 1 input.");if(-1===NUMBER_TYPES.indexOf(t[0].type))throw new Error("Invalid input type.")},reduceSum=(t,e,n)=>reduce(t,e,n,"ReduceSum",(()=>["value = 0.0;","value += _A(inputIdx);",""])),reduceMean=(t,e,n)=>reduce(t,e,n,"ReduceMean",((t,e)=>{let n=1;for(let B=0;B<t[0].dims.length;B++)(e.indexOf(B)>=0||0===e.length)&&(n*=t[0].dims[B]);return["value = 0.0;","value += _A(inputIdx);",`value /= ${n}.;`]})),reduceMax=(t,e,n)=>reduce(t,e,n,"ReduceMax",((t,e)=>{const n=[];for(let B=0;B<t[0].dims.length;B++)(e.indexOf(B)>=0||0===e.length)&&n.push(`inputIdx[${B}] = 0;`);return[`${n.join("\n")}\nvalue = _A(inputIdx);`,"value = max(value, _A(inputIdx));",""]})),reduceMin=(t,e,n)=>reduce(t,e,n,"ReduceMin",((t,e)=>{const n=[];for(let B=0;B<t[0].dims.length;B++)(e.indexOf(B)>=0||0===e.length)&&n.push(`inputIdx[${B}] = 0;`);return[`${n.join("\n")}\nvalue = _A(inputIdx);`,"value = min(value, _A(inputIdx));",""]})),reduceProd=(t,e,n)=>reduce(t,e,n,"ReduceProd",(()=>["value = 1.0;","value *= _A(inputIdx);",""])),reduceLogSum=(t,e,n)=>reduce(t,e,n,"ReduceLogSum",(()=>["value = 0.0;","value += _A(inputIdx);","value = log(value);"])),reduceLogSumSquare=(t,e,n)=>reduce(t,e,n,"ReduceLogSumSquare",(()=>["float t; value = 0.0;","t = _A(inputIdx); value += t * t;",""]))}}),reshape,init_reshape=__esm({"web/lib/onnxjs/backends/webgl/ops/reshape.ts"(){init_util(),reshape=(t,e)=>{const n=ShapeUtil.calculateReshapedDims(e[0].dims,e[1].integerData);return t.session.pack?[t.reshapePacked(e[0],n)]:[t.reshapeUnpacked(e[0],n)]}}}),upsampleProgramMetadata,upsample,parseUpsampleAttributesV7,parseUpsampleAttributesV9,parseUpsampleAttributes,createUpsampleProgramInfo,validateInputs17,scalesValidation,init_upsample=__esm({"web/lib/onnxjs/backends/webgl/ops/upsample.ts"(){init_attribute_with_cache_key(),init_glsl_source(),init_types(),upsampleProgramMetadata={name:"Upsample",inputNames:["X"],inputTypes:[0]},upsample=(t,e,n)=>{validateInputs17(e,n);return[t.run({...upsampleProgramMetadata,cacheHint:n.cacheKey,get:()=>createUpsampleProgramInfo(t,e,n)},e)]},parseUpsampleAttributesV7=t=>parseUpsampleAttributes(t,7),parseUpsampleAttributesV9=t=>parseUpsampleAttributes(t,9),parseUpsampleAttributes=(t,e)=>{const n=e>=10,B=t.attributes.getString("mode","nearest");if("nearest"!==B&&"linear"!==B&&(e<11||"cubic"!==B))throw new Error(`unrecognized mode: ${B}`);let s=[];e<9&&(s=t.attributes.getFloats("scales"),scalesValidation(s,B,n));const F=t.attributes.getFloat("extrapolation_value",0),Q=e>10?t.attributes.getString("coordinate_transformation_mode","half_pixel"):"asymmetric";if(-1===["asymmetric","pytorch_half_pixel","tf_half_pixel_for_nn","align_corners","tf_crop_and_resize","half_pixel"].indexOf(Q))throw new Error(`coordinate_transform_mode '${Q}' is not supported`);const U="tf_crop_and_resize"===Q,i=U,a="nearest"===B&&e>=11?t.attributes.getString("nearest_mode","round_prefer_floor"):"";if(-1===["round_prefer_floor","round_prefer_ceil","floor","ceil",""].indexOf(a))throw new Error(`nearest_mode '${a}' is not supported`);const l=t.attributes.getFloat("cubic_coeff_a",-.75),c=0!==t.attributes.getInt("exclude_outside",0);if(c&&"cubic"!==B)throw new Error("exclude_outside can be set to 1 only when mode is CUBIC.");const g=e<11||"nearest"===B&&"asymmetric"===Q&&"floor"===a;let d=0,I=0,o=0;return e>10?t.inputs.length>2?(d=1,I=2,o=3):(I=1,o=2):9===e&&(I=1),createAttributeWithCacheKey({opset:e,isResize:n,mode:B,scales:s,extrapolationValue:F,coordinateTransformMode:Q,useExtrapolation:i,needRoiInput:U,nearestMode:a,cubicCoefficientA:l,excludeOutside:c,useNearest2xOptimization:g,roiInputIdx:d,scalesInputIdx:I,sizesInputIdx:o})},createUpsampleProgramInfo=(t,e,n)=>{const B=getGlsl(t.session.backend.glContext.version),[s,F]=t.calculateTextureWidthAndHeight(e[0].dims,0),Q=e[0].dims.map(((t,e)=>Math.floor(t*n.scales[e]))),[U,i]=t.calculateTextureWidthAndHeight(Q,0),a=Q.length,l=new Array(a),c=new Array(a);let g=`\n      int output_pitches[${a}];\n      int input_pitches[${a}];\n      `;for(let t=a-1;t>=0;t--)l[t]=t===a-1?1:l[t+1]*Q[t+1],c[t]=t===a-1?1:c[t+1]*e[0].dims[t+1],g+=`\n        output_pitches[${t}] = ${l[t]};\n        input_pitches[${t}] = ${c[t]};\n        `;const d=`\n      float getInputFloat(int index) {\n        vec2 coords = offsetToCoords(index, ${s}, ${F});\n        float value = getColorAsFloat(${B.texture2D}(X, coords));\n        return value;\n      }\n      `,I="nearest"===n.mode?`\n    ${d}\n    float process(int indices[${a}]) {\n      int input_index = 0;\n      int output_index = coordsToOffset(TexCoords, ${U}, ${i});\n\n      ${g}\n\n      int d, m;\n      for (int dim = 0; dim < ${a}; ++dim) {\n        d = output_index / output_pitches[dim];\n        m = output_index - d * output_pitches[dim];\n        output_index = m;\n\n        if (scales[dim] != 1 && d > 0) {\n          int d2 = d / scales[dim];\n          m = d - d2 * scales[dim];\n          d = d2;\n        }\n        input_index += input_pitches[dim] * d;\n      }\n\n      return getInputFloat(input_index);\n    }`:4===a?`\n    ${d}\n    float process(int indices[4]) {\n      int input_index = 0;\n      int output_index = coordsToOffset(TexCoords, ${U}, ${i});\n\n      ${g}\n\n      int m;\n      int index_of_dim0, index_of_dim1, index_of_dim2, index_of_dim3;\n      index_of_dim0 = output_index / output_pitches[0];\n      m = output_index - index_of_dim0 * output_pitches[0];\n      index_of_dim1 = m / output_pitches[1];\n      m = m - index_of_dim1 * output_pitches[1];\n      index_of_dim2 = m / output_pitches[2];\n      m = m - index_of_dim2 * output_pitches[2];\n      index_of_dim3 = m;\n\n      int index_of_input_dim2, index_of_input_dim3, x_offset, y_offset;\n      index_of_input_dim2 = index_of_dim2 / scales[2];\n      y_offset = index_of_dim2 - index_of_input_dim2 * scales[2];\n      index_of_input_dim3 = index_of_dim3 / scales[3];\n      x_offset = index_of_dim3 - index_of_input_dim3 * scales[3];\n\n      input_index = index_of_dim0 * input_pitches[0] +\n            index_of_dim1 * input_pitches[1] +\n            index_of_input_dim2 * input_pitches[2] +\n            index_of_input_dim3;\n\n      float x00 = getInputFloat(input_index);\n      float x10, x01, x11;\n\n      bool end_of_dim2 = false;\n      if (index_of_input_dim2 == (${e[0].dims[2]} - 1)) {\n        // It's the end in dimension 2\n        x01 = x00;\n        end_of_dim2 = true;\n      } else {\n        x01 = getInputFloat(input_index + input_pitches[2]);\n      }\n\n      if (index_of_input_dim3 == (input_pitches[2] - 1)) {\n        // It's the end in dimension 3\n        x10 = x00;\n        x11 = x01;\n      }\n      else {\n        x10 = getInputFloat(input_index + 1);\n        x11 = end_of_dim2 ? x10 : getInputFloat(input_index + input_pitches[2] + 1);\n      }\n\n      float y0 = x00 + float(y_offset) * (x01 - x00) / float(scales[2]);\n      float y1 = x10 + float(y_offset) * (x11 - x10) / float(scales[2]);\n      return y0 + float(x_offset) * (y1 - y0) / float(scales[3]);\n    }`:`\n    ${d}\n    float process(int indices[2]) {\n      int input_index = 0;\n      int output_index = coordsToOffset(TexCoords, ${U}, ${i});\n\n      ${g}\n\n      int m;\n      int index_of_dim0, index_of_dim1;\n      index_of_dim0 = output_index / output_pitches[0];\n      m = output_index - index_of_dim0 * output_pitches[0];\n      index_of_dim1 = m;\n\n      int index_of_input_dim0, index_of_input_dim1, x_offset, y_offset;\n      index_of_input_dim0 = index_of_dim0 / scales[0];\n      y_offset = index_of_dim0 - index_of_input_dim0 * scales[0];\n      index_of_input_dim1 = index_of_dim1 / scales[1];\n      x_offset = index_of_dim1 - index_of_input_dim1 * scales[1];\n\n      input_index = index_of_input_dim0 * input_pitches[0] + index_of_input_dim1;\n\n      float x00 = getInputFloat(input_index);\n      float x10, x01, x11;\n\n      bool end_of_dim0 = false;\n      if (index_of_input_dim0 == (${e[0].dims[0]} - 1)) {\n        // It's the end in dimension 0\n        x01 = x00;\n        end_of_dim0 = true;\n      } else {\n        x01 = getInputFloat(input_index + input_pitches[0]);\n      }\n\n      if (index_of_input_dim1 == (input_pitches[0] - 1)) {\n        // It's the end in dimension 1\n        x10 = x00;\n        x11 = x01;\n      }\n      else {\n        x10 = getInputFloat(input_index + 1);\n        x11 = end_of_dim0 ? x10 : getInputFloat(input_index + input_pitches[0] + 1);\n      }\n\n      float y0 = x00 + float(y_offset) * (x01 - x00) / float(scales[0]);\n      float y1 = x10 + float(y_offset) * (x11 - x10) / float(scales[0]);\n      return y0 + float(x_offset) * (y1 - y0) / float(scales[1]);\n    }`;return{...upsampleProgramMetadata,output:{dims:Q,type:e[0].type,textureType:0},shaderSource:I,variables:[{name:"scales",type:"int",arrayLength:n.scales.length,data:n.scales.map((t=>Math.ceil(t)))}]}},validateInputs17=(t,e)=>{if(!t||e.opset<9&&1!==t.length||e.opset>=9&&e.opset<11&&2!==t.length||e.opset>=11&&t.length<2)throw new Error("invalid inputs.");if(e.scales.length>0&&t[0].dims.length!==e.scales.length)throw new Error("Invalid input shape.");if("string"===t[0].type)throw new Error("Invalid input tensor types.")},scalesValidation=(t,e,n)=>{if(n){for(const e of t)if(e<=0)throw new Error("Scale value should be greater than 0.")}else for(const e of t)if(e<1)throw new Error("Scale value should be greater than or equal to 1.");if(!("linear"!==e&&"cubic"!==e||2===t.length||4===t.length&&1===t[0]&&1===t[1]))throw new Error(`'Linear' mode and 'Cubic' mode only support 2-D inputs ('Bilinear', 'Bicubic')         or 4-D inputs with the corresponding outermost 2 scale values being 1         in the ${n?"Resize":"Upsample"} opeartor.`)}}}),resizeProgramMetadata,resize,parseResizeAttributesV10,parseResizeAttributesV11,createPackedResizeProgramInfo,prepareInputs,parseScalesData,parseScalesDataFromOutputSize,init_resize_packed=__esm({"web/lib/onnxjs/backends/webgl/ops/resize-packed.ts"(){init_glsl_source(),init_types(),init_utils(),init_packing_utils(),init_upsample(),resizeProgramMetadata={name:"Resize",inputNames:["A"],inputTypes:[2]},resize=(t,e,n)=>{validateInputs17(e,n);return[t.run({...resizeProgramMetadata,cacheHint:n.cacheKey,get:()=>createPackedResizeProgramInfo(t,e,n)},e)]},parseResizeAttributesV10=t=>parseUpsampleAttributes(t,10),parseResizeAttributesV11=t=>parseUpsampleAttributes(t,11),createPackedResizeProgramInfo=(t,e,n)=>{const B=getGlsl(t.session.backend.glContext.version),[s,F]=prepareInputs(e,n);if(s.every((t=>1===t))&&"tf_crop_and_resize"!==n.coordinateTransformMode)return{...resizeProgramMetadata,output:{dims:F,type:e[0].type,textureType:2},hasMain:!0,shaderSource:`void main() {\n                    vec4 v = ${B.texture2D}(X, TexCoords);\n                    ${B.output} = v;\n                }`};const Q=F.length;if(Q<2)throw new Error(`output dimension should be at least 2, but got ${Q}`);const U=F[Q-2],i=F[Q-1],a=e[0].dims;if(Q!==a.length)throw new Error(`output dimension should match input ${a.length}, but got ${Q}`);const l=a[Q-2],c=a[Q-1],g=s[Q-2],d=s[Q-1];let I="";if("linear"!==n.mode)throw new Error(`resize (packed) does not support mode: '${n.mode}'`);switch(n.coordinateTransformMode){case"asymmetric":I="\n                    vec4 getSourceFracIndex(ivec4 coords) {\n                        return vec4(coords) / scaleWHWH;\n                    }\n                ";break;case"half_pixel":I="\n                    vec4 getSourceFracIndex(ivec4 coords) {\n                        return (vec4(coords) + 0.5) / scaleWHWH - 0.5;\n                    }\n                ";break;case"pytorch_half_pixel":I=`\n                    vec4 getSourceFracIndex(ivec4 coords) {\n                        vec4 fcoords = vec4(coords);\n                        return vec4(\n                            ${i}.0 > 1.0 ? (fcoords.x + 0.5) / scaleWHWH.x - 0.5 : 0.0,\n                            ${U}.0 > 1.0 ? (fcoords.y + 0.5) / scaleWHWH.y - 0.5 : 0.0,\n                            ${i}.0 > 1.0 ? (fcoords.z + 0.5) / scaleWHWH.z - 0.5 : 0.0,\n                            ${U}.0 > 1.0 ? (fcoords.w + 0.5) / scaleWHWH.w - 0.5 : 0.0\n                          );\n                    }\n                `;break;case"align_corners":I=`\n                    vec4 getSourceFracIndex(ivec4 coords) {\n                        vec4 resized = vec4(${i}.0 - 1.0, ${U}.0 - 1.0, ${i}.0 - 1.0,\n                            ${U}.0 - 1.0);\n                        vec4 original = vec4(${c}.0 - 1.0, ${l}.0 - 1.0, ${c}.0 - 1.0,\n                            ${l}.0 - 1.0);\n                        vec4 new_scale = original / resized;\n                        return vec4(coords) * new_scale;\n                    }\n                `;break;default:throw new Error(`resize (packed) does not support coordinateTransformMode:                                 '${n.coordinateTransformMode}'`)}const o=getCoordsDataType(Q),r=`\n            const vec2 inputWH = vec2(${l}.0, ${c}.0);\n            const vec4 scaleWHWH = vec4(float(${g}), float(${d}), float(${g}), float(${d}));\n            ${unpackFromChannel()}\n            ${I}\n            float getAValue(int x10, int r, int c, int d) {\n                return getChannel(getA(x10, r, c, d), vec2(c, d));\n            }\n            void main() {\n                ${o} rc = getOutputCoords();\n\n                int batch = rc[0];\n                int depth = rc[1];\n\n                // retrieve the 4 coordinates that is used in the 4 packed output values.\n                ivec4 coords = ivec4(rc.wz, rc.w + 1, rc.z + 1);\n\n                // calculate the source index in fraction\n                vec4 sourceFrac = getSourceFracIndex(coords);\n\n                // get the lower and upper bound of the 4 values that will be packed into one texel.\n                ivec4 x00 = ivec4(max(sourceFrac.xy, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.xy)));\n                ivec4 x01 = ivec4(max(sourceFrac.xw, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.xw)));\n                ivec4 x10 = ivec4(max(sourceFrac.zy, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.zy)));\n                ivec4 x11 = ivec4(max(sourceFrac.zw, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.zw)));\n\n                bool hasNextRow = rc.w < ${U-1};\n                bool hasNextCol = rc.z < ${i-1};\n\n                // pack x00, x01, x10, x11's top-left corner into one vec4 structure\n                vec4 topLeft = vec4(\n                    getAValue(batch, depth, x00.x, x00.y),\n                    hasNextCol ? getAValue(batch, depth, x01.x, x01.y) : 0.0,\n                    hasNextRow ? getAValue(batch, depth, x10.x, x10.y) : 0.0,\n                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.x, x11.y) : 0.0);\n\n                // pack x00, x01, x10, x11's top-right corner into one vec4 structure\n                vec4 topRight = vec4(\n                    getAValue(batch, depth, x00.x, x00.w),\n                    hasNextCol ? getAValue(batch, depth, x01.x, x01.w) : 0.0,\n                    hasNextRow ? getAValue(batch, depth, x10.x, x10.w) : 0.0,\n                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.x, x11.w) : 0.0);\n\n                // pack x00, x01, x10, x11's bottom-left corner into one vec4 structure\n                vec4 bottomLeft = vec4(\n                    getAValue(batch, depth, x00.z, x00.y),\n                    hasNextCol ? getAValue(batch, depth, x01.z, x01.y) : 0.0,\n                    hasNextRow ? getAValue(batch, depth, x10.z, x10.y) : 0.0,\n                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.z, x11.y) : 0.0);\n\n                // pack x00, x01, x10, x11's bottom-right corner into one vec4 structure\n                vec4 bottomRight = vec4(\n                    getAValue(batch, depth, x00.z, x00.w),\n                    hasNextCol ? getAValue(batch, depth, x01.z, x01.w) : 0.0,\n                    hasNextRow ? getAValue(batch, depth, x10.z, x10.w) : 0.0,\n                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.z, x11.w) : 0.0);\n\n                // calculate the interpolation fraction on u and v direction\n                vec4 frac = vec4(sourceFrac) - floor(sourceFrac);\n                vec4 clampFrac = clamp(frac, vec4(0.0), vec4(1.0));\n\n                vec4 top = mix(topLeft, topRight, clampFrac.ywyw);\n                vec4 bottom = mix(bottomLeft, bottomRight, clampFrac.ywyw);\n                vec4 newValue = mix(top, bottom, clampFrac.xxzz);\n\n                ${B.output} = vec4(newValue);\n            }\n        `;return{...resizeProgramMetadata,output:{dims:F,type:e[0].type,textureType:2},hasMain:!0,shaderSource:r}},prepareInputs=(t,e)=>{const n=t[0].dims;let B,s=e.scales;if(0===s.length){const F=t[e.scalesInputIdx];if(F&&0!==F.size){if(t[e.sizesInputIdx])throw new Error("Only one of scales or sizes must be provided as input.");s=parseScalesData(F,e.mode,e.isResize)}else{const F=t[e.sizesInputIdx];if(!F||0===F.size)throw new Error("Either scales or sizes MUST be provided as input.");B=Array.from(F.integerData),s=parseScalesDataFromOutputSize(B,n,e.mode,e.isResize)}}else if(t[e.sizesInputIdx])throw new Error("Only one of scales or sizes must be provided as input.");const F=B||n.map(((t,e)=>Math.floor(t*s[e])));return[s,F]},parseScalesData=(t,e,n)=>{const B=Array.from(t.floatData);return scalesValidation(B,e,n),B},parseScalesDataFromOutputSize=(t,e,n,B)=>{const s=e.length,F=new Array(s);for(let n=0,B=s;n<B;n++)if(0===e[n]){if(0!==t[n])throw new Error("Input dim is zero but required output dim is non-zero.");F[n]=1}else F[n]=t[n]/e[n];return scalesValidation(F,n,B),F}}}),shape,validateInputs18,init_shape=__esm({"web/lib/onnxjs/backends/webgl/ops/shape.ts"(){init_tensor2(),shape=(t,e)=>(validateInputs18(e),[new Tensor3([e[0].dims.length],"int32",void 0,void 0,new Int32Array(e[0].dims))]),validateInputs18=t=>{if(!t||1!==t.length)throw new Error("Shape requires 1 input.")}}}),sliceProgramMetadata,slice,parseSliceAttributes,createSliceProgramInfo,validateInputs19,sliceV10,generateSliceAttributesFromInputs,validateInputsV10,init_slice=__esm({"web/lib/onnxjs/backends/webgl/ops/slice.ts"(){init_attribute_with_cache_key(),init_operators(),init_util(),init_types(),sliceProgramMetadata={name:"Slice",inputNames:["A"],inputTypes:[0]},slice=(t,e,n)=>{validateInputs19(e);return[t.run({...sliceProgramMetadata,cacheHint:n.cacheKey,get:()=>createSliceProgramInfo(t,e[0],n)},e)]},parseSliceAttributes=t=>{const e=t.attributes.getInts("starts"),n=t.attributes.getInts("ends"),B=t.attributes.getInts("axes",[]);return createAttributeWithCacheKey({starts:e,ends:n,axes:B})},createSliceProgramInfo=(t,e,n)=>{const B=0===n.axes.length?e.dims.slice(0).map(((t,e)=>e)):n.axes,s=ShapeUtil.normalizeAxes(B,e.dims.length),F=n.starts.map(((t,n)=>t>e.dims[s[n]]-1?e.dims[s[n]]:ShapeUtil.normalizeAxis(t,e.dims[s[n]]))),Q=n.ends.map(((t,n)=>t>e.dims[s[n]]-1?e.dims[s[n]]:ShapeUtil.normalizeAxis(t,e.dims[s[n]]))),U=e.dims.slice(),i=[];for(let t=0;t<s.length;t++)U[s[t]]=Q[t]-F[t],F[t]>0&&i.push(`outputIdx[${s[t]}] += ${F[t]};`);const a=`\n      float process(int outputIdx[${U.length}]) {\n        ${i.join("\n      ")}\n        return _A(outputIdx);\n      }`;return{...sliceProgramMetadata,output:{dims:U,type:e.type,textureType:0},shaderSource:a}},validateInputs19=t=>{if(!t||1!==t.length)throw new Error("Slice requires 1 input.");if(-1===NUMBER_TYPES.indexOf(t[0].type))throw new Error("Invalid input type.")},sliceV10=(t,e)=>{validateInputsV10(e);const n=generateSliceAttributesFromInputs(t,e);return[t.run({...sliceProgramMetadata,cacheHint:n.cacheKey,get:()=>createSliceProgramInfo(t,e[0],n)},[e[0]])]},generateSliceAttributesFromInputs=(t,e)=>{if(!t.session.isInitializer(e[1].dataId)||!t.session.isInitializer(e[2].dataId)||e.length>=4&&!t.session.isInitializer(e[3].dataId)||e.length>=5&&!t.session.isInitializer(e[4].dataId))throw new Error("dynamic slice attributes are not allowed");if(e.length>=5&&e[4].integerData.some((t=>1!==t)))throw new Error("currently non-1 steps is not supported for Slice");const n=Array.from(e[1].integerData),B=Array.from(e[2].integerData),s=e.length>=4?Array.from(e[3].integerData):[];return{starts:n,ends:B,axes:s,cacheKey:`${s};${n};${B}`}},validateInputsV10=t=>{if(!t||t.length<3||t.length>5)throw new Error("Invalid input number.");if("int32"!==t[1].type||1!==t[1].dims.length)throw new Error("Invalid input type.");if("int32"!==t[2].type||1!==t[2].dims.length)throw new Error("Invalid input type.");if(t.length>=4&&("int32"!==t[3].type||1!==t[3].dims.length))throw new Error("Invalid input type.");if(t.length>=5&&("int32"!==t[4].type||1!==t[4].dims.length))throw new Error("Invalid input type.")}}}),softmaxComputeMaxProgramMetadata,softmaxComputeScaleProgramMetadata,softmaxProgramMetadata,softmax,parseSoftmaxAttributes,parseSoftmaxAttributesV13,softmaxV13,computeSoftmax,createComputeMaxProgramInfo,createComputScaleProgramInfo,createSoftMaxProgramInfo,validateInputs20,init_softmax=__esm({"web/lib/onnxjs/backends/webgl/ops/softmax.ts"(){init_attribute_with_cache_key(),init_util(),init_glsl_source(),init_types(),init_transpose(),softmaxComputeMaxProgramMetadata={name:"SoftmaxComputeMax",inputNames:["A"],inputTypes:[0]},softmaxComputeScaleProgramMetadata={name:"SoftmaxComputeScale",inputNames:["A","Max"],inputTypes:[0,0]},softmaxProgramMetadata={name:"SoftMax",inputNames:["A","Max","Norm"],inputTypes:[0,0,0]},softmax=(t,e,n)=>{validateInputs20(e);const B=e[0].dims.slice(),s=ShapeUtil.normalizeAxis(n.axis,B.length),F=ShapeUtil.sizeToDimension(B,s),Q=ShapeUtil.sizeFromDimension(B,s);return computeSoftmax(t,e,n,F,Q)},parseSoftmaxAttributes=t=>createAttributeWithCacheKey({axis:t.attributes.getInt("axis",1)}),parseSoftmaxAttributesV13=t=>createAttributeWithCacheKey({axis:t.attributes.getInt("axis",-1)}),softmaxV13=(t,e,n)=>{validateInputs20(e);const B=e[0].dims.slice(),s=ShapeUtil.normalizeAxis(n.axis,B.length),F=B.length,Q=s!==F-1,U=[];let i,a=[],l=[];Q&&(a=Array.from({length:F}).map(((t,e)=>e)),a[s]=F-1,a[F-1]=s,a.map((t=>U.push(B[t]))),i=createAttributeWithCacheKey({perm:a}),l=transpose(t,e,i));const c=Q?ShapeUtil.sizeToDimension(U,F-1):ShapeUtil.sizeToDimension(B,F-1),g=Q?ShapeUtil.sizeFromDimension(U,F-1):ShapeUtil.sizeFromDimension(B,F-1),d=computeSoftmax(t,Q?l:e,n,c,g);if(Q){return transpose(t,d,i)}return d},computeSoftmax=(t,e,n,B,s)=>{const F=createComputeMaxProgramInfo(t,e[0],B,s,[B]),Q=t.run({...softmaxComputeMaxProgramMetadata,cacheHint:n.cacheKey,get:()=>F},e),U=createComputScaleProgramInfo(t,e[0],B,s,F.output.dims,[B]),i=t.run({...softmaxComputeScaleProgramMetadata,cacheHint:n.cacheKey,get:()=>U},[e[0],Q]),a=createSoftMaxProgramInfo(t,e[0],B,s,F.output.dims,U.output.dims);return[t.run({...softmaxProgramMetadata,cacheHint:n.cacheKey,get:()=>a},[e[0],Q,i])]},createComputeMaxProgramInfo=(t,e,n,B,s)=>{const[F,Q]=t.calculateTextureWidthAndHeight(e.dims,0),U=s.length;if(n<1||B<1)throw new Error("Logical row count N and feature count D must be greater than or equal to 1");if(1!==s.length)throw new Error("Dimensionality of the output should be 1");if(s[0]!==n)throw new Error("Shape of the output should be equal to logical row count");const i=getGlsl(t.session.backend.glContext.version),a=`\n      float process(int[${U}] indices) {\n        int logical_row_start_offset = indices[0] * ${B};\n\n        float max = getColorAsFloat(${i.texture2D}(A, offsetToCoords(logical_row_start_offset, ${F},\n        ${Q} )));\n        for(int i=1; i<${B}; ++i)\n        {\n          float current = getColorAsFloat(${i.texture2D}(A, offsetToCoords(logical_row_start_offset + i,\n            ${F}, ${Q})));\n          if(current > max)\n          max = current;\n        }\n\n        return max;\n      }`;return{...softmaxComputeMaxProgramMetadata,output:{dims:s,type:e.type,textureType:0},shaderSource:a}},createComputScaleProgramInfo=(t,e,n,B,s,F)=>{const[Q,U]=t.calculateTextureWidthAndHeight(e.dims,0),i=F.length;if(n<1||B<1)throw new Error("Logical row count N and feature count D must be greater than or equal to 1");if(1!==F.length)throw new Error("Dimensionality of the output should be 1");if(F[0]!==n)throw new Error("Shape of the output should be equal to logical row count");if(1!==s.length)throw new Error("Dimensionality of the intermediate results should be 1");if(s[0]!==n)throw new Error("Shape of the intermediate results should be equal to logical row count");const a=`\n      float process(int[${i}] indices) {\n        int logical_row_start_offset = indices[0] * ${B};\n\n        float norm_factor = 0.0;\n        float max = _Max(indices);\n        for(int i=0; i<${B}; ++i)\n        {\n          norm_factor += exp(getColorAsFloat(${getGlsl(t.session.backend.glContext.version).texture2D}(A, offsetToCoords(logical_row_start_offset + i,\n            ${Q}, ${U}))) - max);\n        }\n\n        return norm_factor;\n      }`;return{...softmaxComputeScaleProgramMetadata,output:{dims:F,type:e.type,textureType:0},shaderSource:a}},createSoftMaxProgramInfo=(t,e,n,B,s,F)=>{const[Q,U]=t.calculateTextureWidthAndHeight(e.dims,0),i=e.dims.length;if(n<1||B<1)throw new Error("Logical row count N and feature count D must be greater than or equal to 1");if(1!==s.length||1!==F.length)throw new Error("Dimensionality of the intermediate results should be 1");if(s[0]!==n||F[0]!==n)throw new Error("Shape of the intermediate results should be equal to logical row count");const a=`\n      float process(int[${i}] indices) {\n\n      // get offset of current logical tensor index from the 2-D texture coordinates (TexCoords)\n      int offset = coordsToOffset(TexCoords, ${Q}, ${U});\n\n      //determine the logical row for this index\n      int logical_row_index[1];\n      logical_row_index[0] = offset / ${B};\n\n      float norm_factor = _Norm(logical_row_index);\n\n      // avoid possible division by 0\n      // if norm_facor is 0, all elements are zero\n      // if so, return 0\n      if(norm_factor == 0.0)\n        return 0.0;\n\n      return exp(_A(indices) - _Max(logical_row_index)) / norm_factor;\n    }`;return{...softmaxProgramMetadata,output:{dims:e.dims,type:e.type,textureType:0},shaderSource:a}},validateInputs20=t=>{if(!t||1!==t.length)throw new Error("Softmax requires 1 input.");if("float32"!==t[0].type&&"float64"!==t[0].type)throw new Error("Invalid input type")}}}),splitProgramMetadata,split,parseSplitAttributes,getProgramCount,createSplitProgramInfo,validateInputs21,init_split=__esm({"web/lib/onnxjs/backends/webgl/ops/split.ts"(){init_attribute_with_cache_key(),init_util(),init_types(),splitProgramMetadata={name:"Split",inputNames:["A"],inputTypes:[0]},split=(t,e,n)=>{validateInputs21(e);const B=ShapeUtil.normalizeAxis(n.axis,e[0].dims.length),s=getProgramCount(t,e,B,n),F=[];for(let Q=0;Q<s;++Q)F.push(t.run({...splitProgramMetadata,cacheHint:`${n.cacheKey};${Q}`,get:()=>createSplitProgramInfo(t,e[0],n,B,Q)},e));return F},parseSplitAttributes=t=>{const e=t.attributes.getInt("axis",0),n=t.attributes.getInts("split",[]),B=t.outputs.length;return createAttributeWithCacheKey({axis:e,split:n,numOutputs:B})},getProgramCount=(t,e,n,B)=>{const[,s]=SplitUtil.splitShape(e[0].dims,n,B.split,B.numOutputs);return s.length},createSplitProgramInfo=(t,e,n,B,s)=>{const[F,Q]=SplitUtil.splitShape(e.dims,B,n.split,n.numOutputs),U=Q[s],i=F[s],a=`\n      float process(int indices[${i.length}]) {\n        indices[${B}] += ${U};\n        return _A(indices);\n      }\n    `;return{...splitProgramMetadata,cacheHint:`${n.cacheKey}:${s}`,output:{dims:i,type:e.type,textureType:0},shaderSource:a}},validateInputs21=t=>{if(!t||1!==t.length)throw new Error("Split requires one input.");if("int8"!==t[0].type&&"uint8"!==t[0].type&&"int16"!==t[0].type&&"uint16"!==t[0].type&&"int32"!==t[0].type&&"uint32"!==t[0].type&&"float32"!==t[0].type&&"float64"!==t[0].type&&"bool"!==t[0].type)throw new Error("Invalid input type.")}}}),squeeze,squeezeV13,parseSqueezeAttributes,validateInputs22,validateInputsV13,init_squeeze=__esm({"web/lib/onnxjs/backends/webgl/ops/squeeze.ts"(){init_util(),squeeze=(t,e,n)=>{validateInputs22(e);const B=ShapeUtil.squeezeShape(e[0].dims,n);return[t.reshapeUnpacked(e[0],B)]},squeezeV13=(t,e)=>(validateInputsV13(e),squeeze(t,[e[0]],Array.from(e[1].integerData))),parseSqueezeAttributes=t=>t.attributes.getInts("axes"),validateInputs22=t=>{if(!t||1!==t.length)throw new Error("Squeeze requires 1 input.");if("string"===t[0].type)throw new Error("invalid input tensor types.")},validateInputsV13=t=>{if(!t||2!==t.length)throw new Error("Squeeze requires 2 inputs.");if("int32"!==t[1].type)throw new Error("Invalid input type.")}}}),sum,createSumProgramInfo,validateInputs23,init_sum=__esm({"web/lib/onnxjs/backends/webgl/ops/sum.ts"(){init_glsl_source(),init_types(),sum=(t,e)=>{validateInputs23(e);const n={name:"Sum",inputNames:e.map(((t,e)=>`X${e}`)),inputTypes:new Array(e.length).fill(0)};return[t.run({...n,get:()=>createSumProgramInfo(t,e,n)},e)]},createSumProgramInfo=(t,e,n)=>{const B=getGlsl(t.session.backend.glContext.version),s=e[0].dims.slice(),F=`\n      void main() {\n        vec4 result = ${e.map(((t,e)=>`${B.texture2D}(X${e},TexCoords)`)).join(" + ")};\n        ${B.output} = result;\n      }\n    `;return{...n,output:{dims:s,type:e[0].type,textureType:0},hasMain:!0,shaderSource:F}},validateInputs23=t=>{if(!t||0===t.length)throw new Error("Sum requires inputs.");const e=t[0].dims.length;for(let n=1;n<t.length;n++){if(e!==t[n].dims.length)throw new Error("Input shapes are mismatched.");for(let B=0;B<e;B++)if(t[0].dims[B]!==t[n].dims[B])throw new Error("Input shapes are not matched.")}if("float32"!==t[0].type&&"float64"!==t[0].type)throw new Error("Invalid input type.");for(let e=1;e<t.length;e++)if(t[0].type!==t[e].type)throw new Error("Input types are not matched.")}}}),tile,createTileProgramInfo,validateInputs24,init_tile=__esm({"web/lib/onnxjs/backends/webgl/ops/tile.ts"(){init_operators(),init_types(),tile=(t,e)=>{validateInputs24(e);const n={name:"Tile",inputNames:["A"],inputTypes:[0]};return[t.run({...n,get:()=>createTileProgramInfo(t,e,n)},e)]},createTileProgramInfo=(t,e,n)=>{const B=e[0].dims.slice(),s=new Array(B.length),F=[];for(let t=0;t<B.length;t++)s[t]=B[t]*e[1].numberData[t],F.push(`inputIdx[${t}] = int(mod(float(outputIdx[${t}]), ${B[t]}.));`);const Q=s.length,U=`\n      float process(int outputIdx[${Q}]) {\n        int inputIdx[${Q}];\n        ${F.join("\n")}\n        return _A(inputIdx);\n      }\n    `;return{...n,output:{dims:s,type:e[0].type,textureType:0},shaderSource:U}},validateInputs24=t=>{if(!t||2!==t.length)throw new Error("Tile requires 2 input.");if(1!==t[1].dims.length)throw new Error("The second input shape must 1 dimension.");if(t[1].dims[0]!==t[0].dims.length)throw new Error("Invalid input shape.");if(-1===NUMBER_TYPES.indexOf(t[0].type))throw new Error("Invalid input type.");if("int32"!==t[1].type&&"int16"!==t[1].type)throw new Error("Invalid repeat type.")}}}),unsqueeze,unsqueezeV13,parseUnsqueezeAttributes,validateInputs25,validateInputsV132,init_unsqueeze=__esm({"web/lib/onnxjs/backends/webgl/ops/unsqueeze.ts"(){init_util(),unsqueeze=(t,e,n)=>{validateInputs25(e);const B=ShapeUtil.unsqueezeShape(e[0].dims,n);return[t.reshapeUnpacked(e[0],B)]},unsqueezeV13=(t,e)=>(validateInputsV132(e),unsqueeze(t,[e[0]],Array.from(e[1].integerData))),parseUnsqueezeAttributes=t=>t.attributes.getInts("axes"),validateInputs25=t=>{if(!t||1!==t.length)throw new Error("Unsqueeze requires 1 input.");if("string"===t[0].type)throw new Error("invalid input tensor types.")},validateInputsV132=t=>{if(!t||2!==t.length)throw new Error("Unsqueeze requires 2 inputs.");if("int32"!==t[1].type)throw new Error("Invalid input type.")}}}),WEBGL_OP_RESOLVE_RULES,init_op_resolve_rules=__esm({"web/lib/onnxjs/backends/webgl/op-resolve-rules.ts"(){init_batch_normalization(),init_binary_op(),init_cast(),init_concat(),init_conv(),init_conv_transpose(),init_depth_to_space(),init_flatten(),init_gather(),init_gemm(),init_image_scaler(),init_instance_normalization(),init_lrn(),init_matmul(),init_pad(),init_pool(),init_reduce(),init_reshape(),init_resize_packed(),init_shape(),init_slice(),init_softmax(),init_split(),init_squeeze(),init_sum(),init_tile(),init_transpose(),init_unary_op(),init_unsqueeze(),init_upsample(),WEBGL_OP_RESOLVE_RULES=[["Abs","","6+",abs],["Acos","","7+",acos],["Add","","7+",add2],["And","","7+",and2],["Asin","","7+",asin],["Atan","","7+",atan],["AveragePool","","7+",averagePool,parseAveragePoolAttributes],["BatchNormalization","","7+",batchNormalization,parseBatchNormalizationAttributes],["Cast","","6+",cast,parseCastAttributes],["Ceil","","6+",ceil],["Clip","","6-10",clip,parseClipAttributes],["Clip","","11+",clipV11],["Concat","","4+",concat,parseConcatAttributes],["Conv","","1+",conv,parseConvAttributes],["ConvTranspose","","1+",convTranspose,parseConvTransposeAttributes],["Cos","","7+",cos],["Div","","7+",div],["Dropout","","7+",identity],["DepthToSpace","","1+",depthToSpace,parseDepthToSpaceAttributes],["Equal","","7+",equal],["Elu","","6+",elu,parseEluAttributes],["Exp","","6+",exp],["Flatten","","1+",flatten,parseFlattenAttributes],["Floor","","6+",floor],["FusedConv","com.microsoft","1+",conv,parseConvAttributes],["Gather","","1+",gather,parseGatherAttributes],["Gemm","","7-10",gemm,parseGemmAttributesV7],["Gemm","","11+",gemm,parseGemmAttributesV11],["GlobalAveragePool","","1+",globalAveragePool,parseGlobalAveragePoolAttributes],["GlobalMaxPool","","1+",globalMaxPool],["Greater","","7+",greater],["Identity","","1+",identity],["ImageScaler","","1+",imageScaler,parseImageScalerAttributes],["InstanceNormalization","","6+",instanceNormalization,parseInstanceNormalizationAttributes],["LeakyRelu","","6+",leakyRelu,parseLeakyReluAttributes],["Less","","7+",less],["LRN","","1+",lrn,parseLrnAttributes],["Log","","6+",log2],["MatMul","","1+",matMul,parseMatMulAttributes],["MaxPool","","1+",maxPool,parseMaxPoolAttributes],["Mul","","7+",mul],["Neg","","6+",neg],["Not","","1+",not2],["Or","","7+",or2],["Pad","","2-10",padV2,parsePadAttributesV2],["Pad","","11+",padV11,parsePadAttributesV11],["Pow","","7+",pow],["PRelu","","7+",pRelu],["ReduceLogSum","","1+",reduceLogSum,parseReduceAttributes],["ReduceMax","","1+",reduceMax,parseReduceAttributes],["ReduceMean","","1+",reduceMean,parseReduceAttributes],["ReduceMin","","1+",reduceMin,parseReduceAttributes],["ReduceProd","","1+",reduceProd,parseReduceAttributes],["ReduceSum","","1-12",reduceSum,parseReduceAttributes],["ReduceSumSquare","","1+",reduceLogSumSquare,parseReduceAttributes],["Relu","","6+",relu],["Reshape","","5+",reshape],["Resize","","10",resize,parseResizeAttributesV10],["Resize","","11+",resize,parseResizeAttributesV11],["Shape","","1+",shape],["Sigmoid","","6+",sigmoid],["Sin","","7+",sin],["Slice","","10+",sliceV10],["Slice","","1-9",slice,parseSliceAttributes],["Softmax","","1-12",softmax,parseSoftmaxAttributes],["Softmax","","13+",softmaxV13,parseSoftmaxAttributesV13],["Split","","2-12",split,parseSplitAttributes],["Sqrt","","6+",sqrt],["Squeeze","","1-12",squeeze,parseSqueezeAttributes],["Squeeze","","13+",squeezeV13],["Sub","","7+",sub],["Sum","","6+",sum],["Tan","","7+",tan],["Tanh","","6+",tanh],["Tile","","6+",tile],["Transpose","","1+",transpose,parseTransposeAttributes],["Upsample","","7-8",upsample,parseUpsampleAttributesV7],["Upsample","","9",upsample,parseUpsampleAttributesV9],["Unsqueeze","","1-12",unsqueeze,parseUnsqueezeAttributes],["Unsqueeze","","13+",unsqueezeV13],["Xor","","7+",xor2]]}}),INLINE_FUNC_DEF_REGEX,FUNC_CALL_REGEX;function replaceInlines(t){const e={};let n;for(;null!==(n=INLINE_FUNC_DEF_REGEX.exec(t));){const t=n[3].split(",").map((t=>{const e=t.trim().split(" ");return e&&2===e.length?{type:e[0],name:e[1]}:null})).filter((t=>null!==t));e[n[2]]={params:t,body:n[4]}}for(const B in e){const s=FUNC_CALL_REGEX.replace("__FUNC__",B),F=new RegExp(s,"gm");for(;null!==(n=F.exec(t));){const s=n[1],F=n[2],Q=n[3].split(","),U=s?`${s} ${F};`:"";let i=e[B].body,a="";e[B].params.forEach(((t,e)=>{t&&(a+=`${t.type} ${t.name} = ${Q[e]};\n`)})),i=`${a}\n ${i}`,i=i.replace("return",`${F} = `);const l=`\n      ${U}\n      {\n        ${i}\n      }\n      `;t=t.replace(n[0],l)}}return t=t.replace(INLINE_FUNC_DEF_REGEX,"")}var init_glsl_function_inliner=__esm({"web/lib/onnxjs/backends/webgl/glsl-function-inliner.ts"(){INLINE_FUNC_DEF_REGEX=/@inline[\s\n\r]+(\w+)[\s\n\r]+([0-9a-zA-Z_]+)\s*\(([^)]*)\)\s*{(([^}]|[\n\r])*)}/gm,FUNC_CALL_REGEX="(\\w+)?\\s+([_0-9a-zA-Z]+)\\s+=\\s+__FUNC__\\((.*)\\)\\s*;"}}),PreferLogicalStrategy;function squeezeShape(t,e){const n=[],B=[],s=null!=e&&Array.isArray(e)&&0===e.length,F=null==e||s?null:parseAxisParam(e,t).sort();let Q=0;for(let e=0;e<t.length;++e){if(null!=F){if(F[Q]===e&&1!==t[e])throw new Error(`Can't squeeze axis ${e} since its dim '${t[e]}' is not 1`);(null==F[Q]||F[Q]>e)&&1===t[e]&&(n.push(t[e]),B.push(e)),F[Q]<=e&&Q++}1!==t[e]&&(n.push(t[e]),B.push(e))}return{newShape:n,keptDims:B}}function parseAxisParam(t,e){const n=e.length;return assert((t=null==t?e.map(((t,e)=>e)):[].concat(t)).every((t=>t>=-n&&t<n)),(()=>`All values in axis param must be in range [-${n}, ${n}) but got axis ${t}`)),assert(t.every(isInt),(()=>`All values in axis param must be integers but got axis ${t}`)),t.map((t=>t<0?n+t:t))}function isInt(t){return t%1==0}function sizeFromShape(t){if(0===t.length)return 1;let e=t[0];for(let n=1;n<t.length;n++)e*=t[n];return e}function sizeToSquarishShape(t){const e=Math.ceil(Math.sqrt(t));return[e,Math.ceil(t/e)]}var init_texture_layout_strategy=__esm({"web/lib/onnxjs/backends/webgl/texture-layout-strategy.ts"(){init_instrument(),init_util(),PreferLogicalStrategy=class{constructor(t){this.maxTextureSize=t}computeTextureWH(t,e){const n=this.computeTexture(t,e);return e&&e.isPacked&&(n[0]/=2,n[1]/=2),e&&e.reverseWH?[n[1],n[0]]:n}computeTexture(t,e){const n=e&&e.isPacked;if(0===t.length)return n?[2,2]:[1,1];let B=this.maxTextureSize;if(e&&void 0!==e.breakAxis){const n=e.breakAxis>=t.length?1:t.slice(e.breakAxis).reduce(((t,e)=>t*e)),s=e.breakAxis<=0?1:t.slice(0,e.breakAxis).reduce(((t,e)=>t*e));if(!(n>B||s>B))return[n,s];Logger.verbose("TextureLayout",`Given width/height preferences were unattainable: shape:${t}, breakAxis:${e.breakAxis}`)}let s=t.slice(0);if(n&&(B*=2,s=s.map(((t,e)=>e>=s.length-2?s[e]%2==0?s[e]:s[e]+1:s[e])),1===s.length&&(s=[2,s[0]])),2!==s.length){const t=squeezeShape(s);s=t.newShape}const F=sizeFromShape(s);return s.length<=1&&F<=B?[1,F]:2===s.length&&s[0]<=B&&s[1]<=B?s:3===s.length&&s[0]*s[1]<=B&&s[2]<=B?[s[0]*s[1],s[2]]:3===s.length&&s[0]<=B&&s[1]*s[2]<=B?[s[0],s[1]*s[2]]:4===s.length&&s[0]*s[1]*s[2]<=B&&s[3]<=B?[s[0]*s[1]*s[2],s[3]]:4===s.length&&s[0]<=B&&s[1]*s[2]*s[3]<=B?[s[0],s[1]*s[2]*s[3]]:n?sizeToSquarishShape(F/4).map((t=>2*t)):sizeToSquarishShape(F)}}}}),CoordsGlslLib,init_glsl_coordinate_lib=__esm({"web/lib/onnxjs/backends/webgl/glsl-coordinate-lib.ts"(){init_util(),init_glsl_definitions(),init_glsl_source(),init_texture_layout_strategy(),init_utils(),CoordsGlslLib=class extends GlslLib{constructor(t){super(t)}getFunctions(){return{...this.offsetToCoords(),...this.coordsToOffset(),...this.toVec(),...this.valueFrom(),...this.getCommonUtilFuncs(),...this.getInputsSamplingSnippets(),...this.getOutputSamplingSnippet()}}getCustomTypes(){return{}}offsetToCoords(){return{offsetToCoords:new GlslLibRoutine("\n      vec2 offsetToCoords(int offset, int width, int height) {\n        int t = offset / width;\n        int s = offset - t*width;\n        vec2 coords = (vec2(s,t) + vec2(0.5,0.5)) / vec2(width, height);\n        return coords;\n      }\n      ")}}coordsToOffset(){return{coordsToOffset:new GlslLibRoutine("\n      int coordsToOffset(vec2 coords, int width, int height) {\n        float s = coords.s * float(width);\n        float t = coords.t * float(height);\n        int offset = int(t) * width + int(s);\n        return offset;\n      }\n      ")}}getOutputSamplingSnippet(){const t=this.context.outputTextureLayout;return t.isPacked?this.getPackedOutputSamplingSnippet(t):this.getUnpackedOutputSamplingSnippet(t)}getPackedOutputSamplingSnippet(t){const e=t.unpackedShape,n=[t.width,t.height],B={},s="getOutputCoords";switch(e.length){case 0:B[s]=this.getOutputScalarCoords();break;case 1:B[s]=this.getOutputPacked1DCoords(e,n);break;case 2:B[s]=this.getOutputPacked2DCoords(e,n);break;case 3:B[s]=this.getOutputPacked3DCoords(e,n);break;default:B[s]=this.getOutputPackedNDCoords(e,n)}const F=`\n      void setOutput(vec4 val) {\n        ${getGlsl(this.context.glContext.version).output} = val;\n      }\n    `;return B.floatTextureSetRGBA=new GlslLibRoutine(F),B}getUnpackedOutputSamplingSnippet(t){const e=t.unpackedShape,n=[t.width,t.height],B={},s="getOutputCoords";switch(e.length){case 0:B[s]=this.getOutputScalarCoords();break;case 1:B[s]=this.getOutputUnpacked1DCoords(e,n);break;case 2:B[s]=this.getOutputUnpacked2DCoords(e,n);break;case 3:B[s]=this.getOutputUnpacked3DCoords(e,n);break;case 4:B[s]=this.getOutputUnpacked4DCoords(e,n);break;case 5:B[s]=this.getOutputUnpacked5DCoords(e,n);break;case 6:B[s]=this.getOutputUnpacked6DCoords(e,n);break;default:throw new Error(`Unsupported output dimensionality: ${e.length}`)}const F=`\n        void setOutput(float val) {\n          ${getGlsl(this.context.glContext.version).output} = vec4(val, 0, 0, 0);\n        }\n    `;return B.floatTextureSetR=new GlslLibRoutine(F),B}getOutputScalarCoords(){return new GlslLibRoutine("\n      int getOutputCoords() {\n        return 0;\n      }\n    ")}getOutputPacked1DCoords(t,e){const n=e;let B="";return 1===n[0]?(B=`\n          int getOutputCoords() {\n            return 2 * int(TexCoords.y * ${n[1]}.0);\n          }\n        `,new GlslLibRoutine(B)):1===n[1]?(B=`\n          int getOutputCoords() {\n            return 2 * int(TexCoords.x * ${n[0]}.0);\n          }\n        `,new GlslLibRoutine(B)):(B=`\n        int getOutputCoords() {\n          ivec2 resTexRC = ivec2(TexCoords.xy *\n                                 vec2(${n[0]}, ${n[1]}));\n          return 2 * (resTexRC.y * ${n[0]} + resTexRC.x);\n        }\n      `,new GlslLibRoutine(B))}getOutputPacked2DCoords(t,e){let n="";if(ArrayUtil.arraysEqual(t,e))return n=`\n        ivec2 getOutputCoords() {\n          return 2 * ivec2(TexCoords.xy * vec2(${e[0]}, ${e[1]}));\n        }\n      `,new GlslLibRoutine(n);const B=e,s=Math.ceil(t[1]/2);return n=`\n        ivec2 getOutputCoords() {\n          ivec2 resTexRC = ivec2(TexCoords.xy *\n                                vec2(${B[0]}, ${B[1]}));\n\n          int index = resTexRC.y * ${B[0]} + resTexRC.x;\n\n          // reverse r and c order for packed texture\n          int r = imod(index, ${s}) * 2;\n          int c = 2 * (index / ${s});\n\n          return ivec2(r, c);\n        }\n      `,new GlslLibRoutine(n)}getOutputPacked3DCoords(t,e){const n=[e[0],e[1]],B=Math.ceil(t[2]/2),s=B*Math.ceil(t[1]/2);return new GlslLibRoutine(`\n        ivec3 getOutputCoords() {\n          ivec2 resTexRC = ivec2(TexCoords.xy *\n                                vec2(${n[0]}, ${n[1]}));\n          int index = resTexRC.y * ${n[0]} + resTexRC.x;\n\n          int b = index / ${s};\n          index -= b * ${s};\n\n          // reverse r and c order for packed texture\n          int r = imod(index, ${B}) * 2;\n          int c = 2 * (index / ${B});\n\n          return ivec3(b, r, c);\n        }\n      `)}getOutputPackedNDCoords(t,e){const n=[e[0],e[1]],B=Math.ceil(t[t.length-1]/2),s=B*Math.ceil(t[t.length-2]/2);let F=s,Q="",U="b, r, c";for(let e=2;e<t.length-1;e++)F*=t[t.length-e-1],Q=`\n      int b${e} = index / ${F};\n      index -= b${e} * ${F};\n    `+Q,U=`b${e}, `+U;const i=`\n      ivec${t.length} getOutputCoords() {\n        ivec2 resTexRC = ivec2(TexCoords.xy *\n                              vec2(${n[0]}, ${n[1]}));\n        int index = resTexRC.y * ${n[0]} + resTexRC.x;\n\n        ${Q}\n\n        int b = index / ${s};\n        index -= b * ${s};\n\n        // reverse r and c order for packed texture\n        int r = imod(index, ${B}) * 2;\n        int c = 2 * (index / ${B});\n\n        return ivec${t.length}(${U});\n      }\n    `;return new GlslLibRoutine(i)}getOutputUnpacked1DCoords(t,e){const n=`\n        int getOutputCoords() {\n          ivec2 resTexRC = ivec2(TexCoords.xy *\n                                vec2(${e[0]}, ${e[1]}));\n          return resTexRC.y * ${e[0]} + resTexRC.x;\n        }\n      `;return new GlslLibRoutine(n)}getOutputUnpacked2DCoords(t,e){const n=`\n        ivec2 getOutputCoords() {\n          ivec2 resTexRC = ivec2(TexCoords.xy *\n                                vec2(${e[0]}, ${e[1]}));\n          int index = resTexRC.y * ${e[0]} + resTexRC.x;\n          int r = index / ${t[1]};\n          int c = index - r * ${t[1]};\n          return ivec2(r, c);\n        }\n      `;return new GlslLibRoutine(n)}getOutputUnpacked3DCoords(t,e){let n="";const B=t.length;let s=null;B<2&&(s=[]),s=new Array(B-1),s[B-2]=t[B-1];for(let e=B-3;e>=0;--e)s[e]=s[e+1]*t[e+1];const F=["r","c","d"],Q=s.map(((t,e)=>`${`int ${F[e]} = index / ${t}`}; ${e===s.length-1?`int ${F[e+1]} = index - ${F[e]} * ${t}`:`index -= ${F[e]} * ${t}`};`)).join("");return n=`\n        ivec3 getOutputCoords() {\n          ivec2 resTexRC = ivec2(TexCoords.xy *\n                                vec2(${e[0]}, ${e[1]}));\n          int index = resTexRC.y * ${e[0]} + resTexRC.x;\n          ${Q}\n          return ivec3(r, c, d);\n        }\n      `,new GlslLibRoutine(n)}getOutputUnpacked4DCoords(t,e){let n="";const B=t.length;let s=null;B<2&&(s=[]),s=new Array(B-1),s[B-2]=t[B-1];for(let e=B-3;e>=0;--e)s[e]=s[e+1]*t[e+1];const F=["r","c","d","d2"],Q=s.map(((t,e)=>`${`int ${F[e]} = index / ${t}`}; ${e===s.length-1?`int ${F[e+1]} = index - ${F[e]} * ${t}`:`index -= ${F[e]} * ${t}`};`)).join("");return n=`\n      ivec4 getOutputCoords() {\n          ivec2 resTexRC = ivec2(TexCoords.xy *\n                                vec2(${e[0]}, ${e[1]}));\n          int index = resTexRC.y * ${e[0]} + resTexRC.x;\n          ${Q}\n          return ivec4(r, c, d, d2);\n        }\n      `,new GlslLibRoutine(n)}getOutputUnpacked5DCoords(t,e){let n="";const B=t.length;let s=null;B<2&&(s=[]),s=new Array(B-1),s[B-2]=t[B-1];for(let e=B-3;e>=0;--e)s[e]=s[e+1]*t[e+1];const F=["r","c","d","d2","d3"],Q=s.map(((t,e)=>`${`int ${F[e]} = index / ${t}`}; ${e===s.length-1?`int ${F[e+1]} = index - ${F[e]} * ${t}`:`index -= ${F[e]} * ${t}`};`)).join("");return n=`\n      ivec5 getOutputCoords() {\n          ivec2 resTexRC = ivec2(TexCoords.xy *\n                                vec2(${e[0]}, ${e[1]}));\n          int index = resTexRC.y * ${e[0]} + resTexRC.x;\n          ${Q}\n          return ivec5(r, c, d, d2, d3);\n        }\n      `,new GlslLibRoutine(n)}getOutputUnpacked6DCoords(t,e){let n="";const B=t.length;let s=null;B<2&&(s=[]),s=new Array(B-1),s[B-2]=t[B-1];for(let e=B-3;e>=0;--e)s[e]=s[e+1]*t[e+1];const F=["r","c","d","d2","d3","d4"],Q=s.map(((t,e)=>`${`int ${F[e]} = index / ${t}`}; ${e===s.length-1?`int ${F[e+1]} = index - ${F[e]} * ${t}`:`index -= ${F[e]} * ${t}`};`)).join("");return n=`\n     ivec6 getOutputCoords() {\n         ivec2 resTexRC = ivec2(TexCoords.xy *\n                               vec2(${e[0]}, ${e[1]}));\n         int index = resTexRC.y * ${e[0]} + resTexRC.x;\n         ${Q}\n         return ivec6(r, c, d, d2, d3, d4);\n       }\n     `,new GlslLibRoutine(n)}getCommonUtilFuncs(){const t={};let e="uvFromFlat";t[e]=new GlslLibRoutine("\n    vec2 uvFromFlat(int texNumR, int texNumC, int index) {\n      int texC = index / texNumR;\n      int texR = index - texC * texNumR;\n      // TODO: swap texR, texC order in following function so row is corresponding to u and column is corresponding to\n      //       v.\n      return (vec2(texR, texC) + halfCR) / vec2(texNumR, texNumC);\n    }\n    "),e="packedUVfrom1D",t[e]=new GlslLibRoutine("\n      vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n        int texelIndex = index / 2;\n        int texR = texelIndex / texNumC;\n        int texC = texelIndex - texR * texNumC;\n        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n      }\n      "),e="packedUVfrom2D",t[e]=new GlslLibRoutine("\n      vec2 packedUVfrom2D(int texNumR, int texNumC, int texelsInLogicalRow, int row, int col) {\n        int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n        int texR = texelIndex / texNumC;\n        int texC = texelIndex - texR * texNumC;\n        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n      }\n      "),e="packedUVfrom3D",t[e]=new GlslLibRoutine("\n      vec2 packedUVfrom3D(int texNumR, int texNumC,\n          int texelsInBatch, int texelsInLogicalRow, int b,\n          int row, int col) {\n        int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n        int texR = index / texNumC;\n        int texC = index - texR * texNumC;\n        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n      }\n      "),e="sampleTexture";const n=getGlsl(this.context.glContext.version);return t[e]=new GlslLibRoutine(`\n        float sampleTexture(sampler2D textureSampler, vec2 uv) {\n            return ${n.texture2D}(textureSampler, uv).r;\n        }`),t}getInputsSamplingSnippets(){const t={},e=this.context.outputTextureLayout;return this.context.programInfo.inputNames.forEach(((n,B)=>{const s=this.context.inputTextureLayouts[B],F=generateShaderFuncNameFromInputSamplerName(n);s.isPacked?t[F]=this.getPackedSamplerFromInput(F,n,s):t[F]=this.getUnpackedSamplerFromInput(F,n,s);const Q=generateShaderFuncNameFromInputSamplerNameAtOutCoords(n);s.unpackedShape.length<=e.unpackedShape.length&&(s.isPacked?t[Q]=this.getPackedSamplerAtOutputCoords(Q,s,e,n):t[Q]=this.getUnpackedSamplerAtOutputCoords(Q,s,e,n))})),t}getPackedSamplerAtOutputCoords(t,e,n,B){const s=e.unpackedShape,F=n.unpackedShape,Q=generateShaderFuncNameFromInputSamplerName(B),U=s.length,i=F.length,a=BroadcastUtil.getBroadcastDims(s,F),l=getCoordsDataType(i),c=i-U;let g;const d=getGlChannels();g=0===U?"":i<2&&a.length>=1?"coords = 0;":a.map((t=>`coords.${d[t+c]} = 0;`)).join("\n");let I="";I=i<2&&U>0?"coords":s.map(((t,e)=>`coords.${d[e+c]}`)).join(", ");let o="return outputValue;";const r=1===ShapeUtil.size(s),u=1===ShapeUtil.size(F);if(1!==U||r||u){if(r&&!u)o=1===i?"\n          return vec4(outputValue.x, outputValue.x, 0., 0.);\n        ":"\n          return vec4(outputValue.x);\n        ";else if(a.length){const t=U-2,e=U-1;a.indexOf(t)>-1&&a.indexOf(e)>-1?o="return vec4(outputValue.x);":a.indexOf(t)>-1?o="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":a.indexOf(e)>-1&&(o="return vec4(outputValue.xx, outputValue.zz);")}}else o="\n        return vec4(outputValue.xy, outputValue.xy);\n      ";const b=`\n        int lastDim = coords.${d[i-1]};\n        coords.${d[i-1]} = coords.${d[i-2]};\n        coords.${d[i-2]} = lastDim;\n      `;return new GlslLibRoutine(`\n      vec4 ${t}() {\n        ${l} coords = getOutputCoords();\n        ${b}\n        ${g}\n        vec4 outputValue = ${Q}(${I});\n        ${o}\n      }\n    `,["coordinates.getOutputCoords"])}getUnpackedSamplerAtOutputCoords(t,e,n,B){const s=[n.width,n.height],F=[e.width,e.height],Q=e.unpackedShape.length,U=n.unpackedShape.length,i=e.unpackedShape,a=n.unpackedShape,l=generateShaderFuncNameFromInputSamplerName(B);if(Q===U&&ArrayUtil.arraysEqual(F,s)){return new GlslLibRoutine(`\n          float ${t}() {\n            return sampleTexture(${B}, TexCoords);\n          }\n        `,["coordinates.sampleTexture"])}const c=getCoordsDataType(U),g=BroadcastUtil.getBroadcastDims(i,a),d=U-Q;let I;const o=getGlChannels();I=0===Q?"":U<2&&g.length>=1?"coords = 0;":g.map((t=>`coords.${o[t+d]} = 0;`)).join("\n");let r="";r=U<2&&Q>0?"coords":e.unpackedShape.map(((t,e)=>`coords.${o[e+d]}`)).join(", ");return new GlslLibRoutine(`\n        float ${t}() {\n          ${c} coords = getOutputCoords();\n          ${I}\n          return ${l}(${r});\n        }\n      `,["coordinates.getOutputCoords"])}getPackedSamplerFromInput(t,e,n){switch(n.unpackedShape.length){case 0:return this.getPackedSamplerScalar(t,e);case 1:return this.getPackedSampler1D(t,e,n);case 2:return this.getPackedSampler2D(t,e,n);case 3:return this.getPackedSampler3D(t,e,n);default:return this.getPackedSamplerND(t,e,n)}}getUnpackedSamplerFromInput(t,e,n){const B=n.unpackedShape;switch(B.length){case 0:return this.getUnpackedSamplerScalar(t,e,n);case 1:return this.getUnpackedSampler1D(t,e,n);case 2:return this.getUnpackedSampler2D(t,e,n);case 3:return this.getUnpackedSampler3D(t,e,n);case 4:return this.getUnpackedSampler4D(t,e,n);case 5:return this.getUnpackedSampler5D(t,e,n);case 6:return this.getUnpackedSampler6D(t,e,n);default:throw new Error(`Unsupported dimension ${B.length}-D`)}}getPackedSamplerScalar(t,e){const n=`\n          vec4 ${t}() {\n            return ${getGlsl(this.context.glContext.version).texture2D}(${e}, halfCR);\n          }\n        `;return new GlslLibRoutine(n)}getPackedSampler1D(t,e,n){const B=[n.width,n.height],s=[B[1],B[0]],F=getGlsl(this.context.glContext.version),Q=`vec4 ${t}(int index) {\n      vec2 uv = packedUVfrom1D(\n      ${s[0]}, ${s[1]}, index);\n      return ${F.texture2D}(${e}, uv);\n    }`;return new GlslLibRoutine(Q,["coordinates.packedUVfrom1D"])}getPackedSampler2D(t,e,n){const B=n.unpackedShape,s=[n.width,n.height],F=getGlsl(this.context.glContext.version),Q=s[0],U=s[1];if(null!=s&&ArrayUtil.arraysEqual(B,s)){const n=`vec4 ${t}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${U}.0, ${Q}.0);\n        return ${F.texture2D}(${e}, uv);\n      }`;return new GlslLibRoutine(n)}const i=s,a=Math.ceil(B[1]/2),l=`vec4 ${t}(int row, int col) {\n      vec2 uv = packedUVfrom2D(${i[1]}, ${i[0]}, ${a}, row, col);\n      return ${F.texture2D}(${e}, uv);\n    }`;return new GlslLibRoutine(l,["coordinates.packedUVfrom2D"])}getPackedSampler3D(t,e,n){const B=n.unpackedShape,s=[n.width,n.height],F=[s[0],s[1]],Q=getGlsl(this.context.glContext.version);if(1===B[0]){const s=B.slice(1),F=[1,2],Q=squeezeInputShape(B,s),U=["b","row","col"],i=JSON.parse(JSON.stringify(n));i.unpackedShape=Q;const a=this.getPackedSamplerFromInput(t,e,i),l=`${a.routineBody}\n      vec4 ${t}(int b, int row, int col) {\n        return ${t}(${getSqueezedParams(U,F)});\n      } `;return new GlslLibRoutine(l,a.dependencies)}const U=F[0],i=F[1],a=Math.ceil(B[2]/2),l=`vec4 ${t}(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        ${i}, ${U}, ${a*Math.ceil(B[1]/2)}, ${a}, b, row, col);\n      return ${Q.texture2D}(${e}, uv);}`;return new GlslLibRoutine(l,["coordinates.packedUVfrom3D"])}getPackedSamplerND(t,e,n){const B=n.unpackedShape,s=B.length,F=[n.width,n.height],Q=getGlsl(this.context.glContext.version),U=[F[0],F[1]],i=U[1],a=U[0],l=Math.ceil(B[s-1]/2);let c=l*Math.ceil(B[s-2]/2),g="int b, int row, int col",d=`b * ${c} + (row / 2) * ${l} + (col / 2)`;for(let t=2;t<s-1;t++)g=`int b${t}, `+g,c*=B[s-t-1],d=`b${t} * ${c} + `+d;const I=`vec4 ${t}(${g}) {\n      int index = ${d};\n      int texR = index / ${a};\n      int texC = index - texR * ${a};\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${a}, ${i});\n      return ${Q.texture2D}(${e}, uv);\n    }`;return new GlslLibRoutine(I)}getUnpackedSamplerScalar(t,e,n){const[B,s]=[n.width,n.height];if(1===B&&1===s){return new GlslLibRoutine(`\n          float ${t}() {\n            return sampleTexture(${e}, halfCR);\n          }\n        `,["coordinates.sampleTexture"])}return new GlslLibRoutine(`\n        float ${t}() {\n          int offset_${e} = coordsToOffset(TexCoords, ${B}, ${s});\n          vec2 uv = uvFromFlat(${B}, ${s}, offset_${e});\n          return sampleTexture(${e}, uv);\n        }\n      `,["coordinates.uvFromFlat","coordinates.sampleTexture","coordinates.coordsToOffset"])}getUnpackedSampler1D(t,e,n){const B=n.width,s=n.height;if(1===s&&1===B){return new GlslLibRoutine(`\n        float ${t}(int index) {\n          return sampleTexture(${e}, halfCR);\n        }\n      `,["coordinates.sampleTexture"])}if(1===s){return new GlslLibRoutine(`\n          float ${t}(int index) {\n            vec2 uv = vec2((float(index) + 0.5) / ${B}.0, 0.5);\n            return sampleTexture(${e}, uv);\n          }\n        `,["coordinates.sampleTexture"])}if(1===B){return new GlslLibRoutine(`\n          float ${t}(int index) {\n            vec2 uv = vec2(0.5, (float(index) + 0.5) / ${s}.0);\n            return sampleTexture(${e}, uv);\n          }\n        `,["coordinates.sampleTexture"])}return new GlslLibRoutine(`\n        float ${t}(int index) {\n          vec2 uv = uvFromFlat(${B}, ${s}, index);\n          return sampleTexture(${e}, uv);\n        }\n      `,["coordinates.uvFromFlat","coordinates.sampleTexture"])}getUnpackedSampler2D(t,e,n){const B=n.unpackedShape,s=[n.height,n.width];if(null!=s&&ArrayUtil.arraysEqual(B,s)){return new GlslLibRoutine(`\n          float ${t}(int row, int col) {\n            vec2 uv = (vec2(row, col) + halfCR) / vec2(${s[1]}.0, ${s[0]}.0);\n            return sampleTexture(${e}, uv);\n          }\n        `,["coordinates.sampleTexture"])}const{newShape:F,keptDims:Q}=squeezeShape(B),U=F;if(U.length<B.length){const s=squeezeInputShape(B,U),F=JSON.parse(JSON.stringify(n));F.unpackedShape=s;const i=["col","row"],a=`\n          ${this.getUnpackedSamplerFromInput(t,e,F).routineBody}\n          float ${t}(int row, int col) {\n            return ${t}(${getSqueezedParams(i,Q)});\n          }\n        `;return new GlslLibRoutine(a,["coordinates.sampleTexture"])}const i=s[1],a=s[0];if(1===a){const n=`\n          float ${t}(int row, int col) {\n            int offset_${e} = coordsToOffset(TexCoords, ${i}, ${a});\n            float index = dot(vec3(row, col, offset_${e}), vec3(${B[1]}, 1, 1));\n            vec2 uv = vec2(0.5, (index + 0.5) / ${i}.0);\n            return sampleTexture(${e}, uv);\n          }\n        `;return new GlslLibRoutine(n,["coordinates.sampleTexture","coordinates.coordsToOffset"])}if(1===i){const n=`\n          float ${t}(int row, int col) {\n            int offset_${e} = coordsToOffset(TexCoords, ${i}, ${a});\n            float index = dot(vec3(row, col, offset_${e}), vec3(${B[1]}, 1, 1));\n            vec2 uv = vec2((index + 0.5) / ${a}.0, 0.5);\n            return sampleTexture(${e}, uv);\n          }\n        `;return new GlslLibRoutine(n,["coordinates.sampleTexture","coordinates.coordsToOffset"])}const l=`\n        float ${t}(int row, int col) {\n          int index = col * ${B[1]} + row;\n          vec2 uv = uvFromFlat(${i}, ${a}, index);\n          return sampleTexture(${e}, uv);\n        }\n      `;return new GlslLibRoutine(l,["coordinates.uvFromFlat","coordinates.sampleTexture","coordinates.coordsToOffset"])}getUnpackedSampler3D(t,e,n){const B=n.unpackedShape,s=B[1]*B[2],F=B[2],{newShape:Q,keptDims:U}=squeezeShape(B),i=Q;if(i.length<B.length){const s=squeezeInputShape(B,i),F=["batch","col","row"],Q=JSON.parse(JSON.stringify(n));Q.unpackedShape=s;const a=this.getUnpackedSamplerFromInput(t,e,Q),l=U.reverse(),c=`\n          ${a.routineBody}\n          float ${t}(int batch, int row, int col) {\n            return ${t}(${getSqueezedParams(F,l)});\n          }\n        `;return new GlslLibRoutine(c,a.dependencies)}const a=n.width,l=n.height;return new GlslLibRoutine(`\n          float ${t}(int depth, int row, int col) {\n            // Explicitly use integer operations as dot() only works on floats.\n            int index = depth * ${s} + col * ${F} + row;\n            vec2 uv = uvFromFlat(${a}, ${l}, index);\n            return sampleTexture(${e}, uv);\n          }\n      `,["coordinates.uvFromFlat","coordinates.sampleTexture","coordinates.coordsToOffset"])}getUnpackedSampler4D(t,e,n){const B=n.unpackedShape,s=B[3],F=B[2]*s,Q=B[1]*F,U=n.width,i=n.height;return new GlslLibRoutine(`\n        float ${t}(int row, int col, int depth, int depth2) {\n          int index = row * ${Q} + col * ${F} +\n              depth2 * ${s} + depth;\n          vec2 uv = uvFromFlat(${U}, ${i}, index);\n          return sampleTexture(${e}, uv);\n        }\n      `,["coordinates.uvFromFlat","coordinates.sampleTexture"])}getUnpackedSampler5D(t,e,n){const B=n.unpackedShape,s=B[4],F=B[3]*s,Q=B[2]*F,U=B[1]*Q,{newShape:i,keptDims:a}=squeezeShape(B);if(i.length<B.length){const s=squeezeInputShape(B,i),F=["row","col","depth","depth2","depth3"],Q=JSON.parse(JSON.stringify(n));Q.unpackedShape=s;const U=`\n          ${this.getUnpackedSamplerFromInput(t,e,Q).routineBody}\n          float ${t}(int row, int col, int depth, int depth2, int depth3) {\n            return ${t}(${getSqueezedParams(F,a)});\n          }\n        `;return new GlslLibRoutine(U,["coordinates.sampleTexture","coordinates.uvFromFlat"])}const l=n.width,c=n.height;return new GlslLibRoutine(`\n        float ${t}(int row, int col, int depth, int depth2, int depth3) {\n          int index = row * ${U} + col * ${Q} + depth * ${F} +\n          depth3 * ${s} + depth2;\n          vec2 uv = uvFromFlat(${l}, ${c}, index);\n          return sampleTexture(${e}, uv);\n        }\n      `,["coordinates.sampleTexture","coordinates.uvFromFlat"])}getUnpackedSampler6D(t,e,n){const B=n.unpackedShape,s=B[5],F=B[4]*s,Q=B[3]*F,U=B[2]*Q,i=B[1]*U,{newShape:a,keptDims:l}=squeezeShape(B);if(a.length<B.length){const s=squeezeInputShape(B,a),F=["row","col","depth","depth2","depth3","depth4"],Q=JSON.parse(JSON.stringify(n));Q.unpackedShape=s;const U=`\n            ${this.getUnpackedSamplerFromInput(t,e,Q).routineBody}\n            float ${t}(int row, int col, int depth,\n              int depth2, int depth3, int depth4) {\n              return ${t}(${getSqueezedParams(F,l)});\n            }\n          `;return new GlslLibRoutine(U,["coordinates.sampleTexture","coordinates.uvFromFlat"])}const c=n.width,g=n.height;return new GlslLibRoutine(`\n          float ${t}(int row, int col, int depth,\n            int depth2, int depth3, int depth4) {\n            int index = row * ${i} + col * ${U} + depth * ${Q} +\n            depth2 * ${F} + depth3 * ${s} + depth4;\n            vec2 uv = uvFromFlat(${c}, ${g}, index);\n            return sampleTexture(${e}, uv);\n          }\n        `,["coordinates.uvFromFlat","coordinates.sampleTexture","coordinates.coordsToOffset"])}toVec(){const t=this.context.outputTextureLayout,e=t.shape.length,n=t.strides,B=t.width,s=t.height,F=[];for(let t=0;t<e-1;++t)F.push(`\n        c[${t}] = offset / ${n[t]};`),F.push(`\n        offset -= c[${t}] * ${n[t]};`);F.push(`\n        c[${e-1}] = offset;`);const Q=`\n      void toVec(vec2 texCoords, out int c[${e}]) {\n        int offset = coordsToOffset(texCoords, ${B}, ${s});\n        ${F.join("")}\n      }\n      void toVec(int offset, out int c[${e}]) {\n        ${F.join("")}\n      }\n    `;return{toVec:new GlslLibRoutine(Q,["coordinates.coordsToOffset"])}}valueFrom(){const t={};return this.context.programInfo.inputNames.forEach(((e,n)=>{const B=this.context.inputTextureLayouts[n],s=(B.unpackedShape.length>0?B.unpackedShape:B.shape).length;let F=`_${e}`;t[F]=new GlslLibRoutine(this.getValueFromSingle(e,s,B.width,B.height,!1),[`shapeUtils.indicesToOffset${F}`,"coordinates.offsetToCoords","fragcolor.getColorAsFloat"]),F+="_T",t[F]=new GlslLibRoutine(this.getValueFromSingle(e,s,B.width,B.height,!0),[`shapeUtils.indicesToOffset${F}`,"coordinates.offsetToCoords","fragcolor.getColorAsFloat"])})),t}getValueFromSingle(t,e,n,B,s){let F=`_${t}`;s&&(F+="_T");return`\n        float ${F}(int m[${e}]) {\n          int offset = indicesToOffset${F}(m);\n          vec2 coords = offsetToCoords(offset, ${n}, ${B});\n          float value = getColorAsFloat(${getGlsl(this.context.glContext.version).texture2D}(${t}, coords));\n          return value;\n        }\n        `}getPackedValueFrom(t,e,n,B,s){let F=`_${t}_Pack`;s&&(F+="_T");return`\n        vec4 ${F}(int m[${e}]) {\n          int offset = indicesToOffset_${t}(m);\n          vec2 coords = offsetToCoords(offset, ${n}, ${B});\n          return ${getGlsl(this.context.glContext.version).texture2D}(${t}, coords);\n        }\n        `}}}}),EncodingGlslLib,init_glsl_encoding_lib=__esm({"web/lib/onnxjs/backends/webgl/glsl-encoding-lib.ts"(){init_glsl_definitions(),EncodingGlslLib=class t extends GlslLib{constructor(t){super(t)}getFunctions(){return{...this.encodeFloat32(),...this.decodeFloat32()}}getCustomTypes(){return{}}encodeFloat32(){return{encode:new GlslLibRoutine("highp vec4 encode(highp float f) {\n        return vec4(f, 0.0, 0.0, 0.0);\n      }\n        ")}}decodeFloat32(){return{decode:new GlslLibRoutine("highp float decode(highp vec4 rgba) {\n        return rgba.r;\n      }\n        ")}}encodeUint8(){const e=t.isLittleEndian()?"rgba.rgba=rgba.abgr;":"";return{encode:new GlslLibRoutine(`\n      highp vec4 encode(highp float f) {\n        highp float F = abs(f);\n        highp float Sign = step(0.0,-f);\n        highp float Exponent = floor(log2(F));\n        highp float Mantissa = (exp2(- Exponent) * F);\n        Exponent = floor(log2(F) + 127.0) + floor(log2(Mantissa));\n        highp vec4 rgba;\n        rgba[0] = 128.0 * Sign  + floor(Exponent*exp2(-1.0));\n        rgba[1] = 128.0 * mod(Exponent,2.0) + mod(floor(Mantissa*128.0),128.0);\n        rgba[2] = floor(mod(floor(Mantissa*exp2(23.0 -8.0)),exp2(8.0)));\n        rgba[3] = floor(exp2(23.0)*mod(Mantissa,exp2(-15.0)));\n        ${e}\n        rgba = rgba / 255.0; // values need to be normalized to [0,1]\n        return rgba;\n    }\n        `)}}decodeUint8(){const e=t.isLittleEndian()?"rgba.rgba=rgba.abgr;":"";return{decode:new GlslLibRoutine(`\n        highp float decode(highp vec4 rgba) {\n          rgba = rgba * 255.0; // values need to be de-normalized from [0,1] to [0,255]\n          ${e}\n          highp float Sign = 1.0 - step(128.0,rgba[0])*2.0;\n          highp float Exponent = 2.0 * mod(rgba[0],128.0) + step(128.0,rgba[1]) - 127.0;\n          highp float Mantissa = mod(rgba[1],128.0)*65536.0 + rgba[2]*256.0 +rgba[3] + float(0x800000);\n          highp float Result =  Sign * exp2(Exponent) * (Mantissa * exp2(-23.0 ));\n          return Result;\n      }\n        `)}}static isLittleEndian(){const t=new ArrayBuffer(4),e=new Uint32Array(t),n=new Uint8Array(t);if(e[0]=3735928559,239===n[0])return!0;if(222===n[0])return!1;throw new Error("unknown endianness")}}}}),FragColorGlslLib,init_glsl_fragcolor_lib=__esm({"web/lib/onnxjs/backends/webgl/glsl-fragcolor-lib.ts"(){init_glsl_definitions(),init_glsl_source(),FragColorGlslLib=class extends GlslLib{constructor(t){super(t)}getFunctions(){return{...this.setFragColor(),...this.getColorAsFloat()}}getCustomTypes(){return{}}setFragColor(){const t=getGlsl(this.context.glContext.version);return{setFragColor:new GlslLibRoutine(`\n        void setFragColor(float value) {\n            ${t.output} = encode(value);\n        }\n        `,["encoding.encode"])}}getColorAsFloat(){return{getColorAsFloat:new GlslLibRoutine("\n        float getColorAsFloat(vec4 color) {\n            return decode(color);\n        }\n        ",["encoding.decode"])}}}}}),ShapeUtilsGlslLib,init_glsl_shape_utils_lib=__esm({"web/lib/onnxjs/backends/webgl/glsl-shape-utils-lib.ts"(){init_glsl_definitions(),ShapeUtilsGlslLib=class t extends GlslLib{constructor(t){super(t)}getFunctions(){return{...this.bcastIndex(),...this.bcastMatmulIndex(),...this.offsetToIndices(),...this.indicesToOffset(),...this.incrementIndices()}}getCustomTypes(){return{}}bcastIndex(){const t=this.context.outputTextureLayout.shape.length,e={};return this.context.programInfo.inputNames.forEach(((n,B)=>{const s=this.context.inputTextureLayouts[B].unpackedShape;if(s.length<=t){const B=s.length,F=t-B,Q=`bcastIndices_${n}`;let U="";for(let t=0;t<B;++t)U+=`\n          realIndices[${t}] = int( mod(float(bcastedIndices[${F+t}]), ${s[t]}.0) );\n          `;const i=`\n        void ${Q} (int bcastedIndices[${t}], out int realIndices[${B}]) {\n          ${U}\n        }\n        `;e[Q]=new GlslLibRoutine(i)}})),e}bcastMatmulIndex(){const t=this.context.outputTextureLayout.shape.length,e={};return this.context.programInfo.inputNames.forEach(((n,B)=>{const s=this.context.inputTextureLayouts[B].shape;if(!(s.length<2||s.length>t)){const B=s.length,F=t-B,Q=`bcastMatmulIndices_${n}`;let U="";for(let t=0;t<B-2;++t)U+=`\n          realIndices[${t}] = int( mod(float(bcastedIndices[${F+t}]), ${s[t]}.0) );\n          `;const i=`\n        void ${Q}(int bcastedIndices[${t}], out int realIndices[${B}]) {\n          ${U}\n          realIndices[${B-1}] = bcastedIndices[${t-1}];\n          realIndices[${B-2}] = bcastedIndices[${t-2}];\n        }\n        `;e[Q]=new GlslLibRoutine(i)}})),e}indicesToOffset(){const e={};return this.context.programInfo.inputNames.forEach(((n,B)=>{const s=this.context.inputTextureLayouts[B].shape,F=this.context.inputTextureLayouts[B].strides,Q=s.length;let U=`indicesToOffset_${n}`;e[U]=new GlslLibRoutine(t.indexToOffsetSingle(U,Q,F)),U=`indicesToOffset_${n}_T`,e[U]=new GlslLibRoutine(t.indexToOffsetSingle(U,Q,F.slice().reverse()))})),e}static indexToOffsetSingle(t,e,n){let B="";for(let t=e-1;t>=0;--t)B+=`\n        offset += indices[${t}] * ${n[t]};\n        `;return`\n      int ${t}(int indices[${e}]) {\n        int offset = 0;\n        ${B}\n        return offset;\n      }\n      `}offsetToIndices(){const e={};return this.context.programInfo.inputNames.forEach(((n,B)=>{const s=this.context.inputTextureLayouts[B].shape,F=this.context.inputTextureLayouts[B].strides,Q=s.length;let U=`offsetToIndices_${n}`;e[U]=new GlslLibRoutine(t.offsetToIndicesSingle(U,Q,F)),U=`offsetToIndices_${n}_T`,e[U]=new GlslLibRoutine(t.offsetToIndicesSingle(U,Q,F.slice().reverse()))})),e}static offsetToIndicesSingle(t,e,n){const B=[];for(let t=0;t<e-1;++t)B.push(`\n      indices[${t}] = offset / ${n[t]};`),B.push(`\n        offset -= indices[${t}] * ${n[t]};`);return B.push(`\n      indices[${e-1}] = offset;`),`\n      void ${t}(int offset, out int indices[${e}]) {\n        ${B.join("")}\n      }\n      `}incrementIndices(){const t={};return this.context.programInfo.inputNames.forEach(((e,n)=>{const B=this.context.inputTextureLayouts[n].shape,s=B.length,F=`incrementIndices_${e}`;let Q="";for(let t=0;t<s;++t)Q+=`\n        shape[${t}] = ${B[t]};`;const U=`\n        void ${F}(int axis, out int indices[${s}]) {\n          int shape[${s}];\n          ${Q};\n          for(int i = ${s} -1 ; i >= 0; --i) {\n            if(i > axis) continue;\n            indices[i] += 1;\n            if(indices[i] < shape[i]) {\n              break;\n            }\n            indices[i] = 0;\n          }\n        }\n        `;t[F]=new GlslLibRoutine(U)})),t}}}}),VecGlslLib,init_glsl_vec_lib=__esm({"web/lib/onnxjs/backends/webgl/glsl-vec-lib.ts"(){init_glsl_definitions(),VecGlslLib=class extends GlslLib{constructor(t){super(t)}getCustomTypes(){return{}}getFunctions(){return{...this.binaryVecFunctions(),...this.copyVec(),...this.setVecItem(),...this.getVecItem()}}binaryVecFunctions(){const t=this.context.outputTextureLayout.shape.length,e={add:"+=",sub:"-=",mul:"*=",div:"/="},n={};for(const B in e){const s=`${B}Vec`;let F="";for(let n=0;n<t;++n)F+=`\n          dest[${n}] ${e[B]} src[${n}];\n          `;const Q=`\n        void ${s}(int src[${t}], out int dest[${t}]) {\n          ${F}\n        }\n        `;n[s]=new GlslLibRoutine(Q)}return n}copyVec(){const t=this.context.outputTextureLayout.shape.length;let e="";for(let n=0;n<t;++n)e+=`\n        dest[${n}] = src[${n}];\n        `;return{copyVec:new GlslLibRoutine(`\n      void copyVec(int src[${t}], out int dest[${t}]) {\n        ${e}\n      }\n      `)}}setVecItem(){const t=this.context.outputTextureLayout.shape.length;let e=`\n        if(index < 0)\n            index =${t} + index;\n        if (index == 0)\n            m[0] = value;\n        `;for(let n=1;n<t-1;++n)e+=`\n        else if (index == ${n})\n            m[${n}] = value;\n            `;e+=`\n        else\n            m[${t-1}] = value;\n        `;return{setVecItem:new GlslLibRoutine(`\n      void setVecItem(out int m[${t}], int index, int value) {\n        ${e}\n      }\n        `)}}getVecItem(){const t=this.context.outputTextureLayout.shape.length;let e=`\n        if(index < 0)\n            index = ${t} + index;\n        if (index == 0)\n            return m[0];\n      `;for(let n=1;n<t-1;++n)e+=`\n        else if (index == ${n})\n            return m[${n}];\n      `;e+=`\n        else\n            return m[${t-1}];\n        `;return{getVecItem:new GlslLibRoutine(`\n      int getVecItem(int m[${t}], int index) {\n        ${e}\n      }\n    `)}}}}}),glslRegistry,init_glsl_registered_libs=__esm({"web/lib/onnxjs/backends/webgl/glsl-registered-libs.ts"(){init_glsl_coordinate_lib(),init_glsl_encoding_lib(),init_glsl_fragcolor_lib(),init_glsl_shape_utils_lib(),init_glsl_vec_lib(),glslRegistry={encoding:EncodingGlslLib,fragcolor:FragColorGlslLib,vec:VecGlslLib,shapeUtils:ShapeUtilsGlslLib,coordinates:CoordsGlslLib}}}),GlslPreprocessor,init_glsl_preprocessor=__esm({"web/lib/onnxjs/backends/webgl/glsl-preprocessor.ts"(){init_glsl_definitions(),init_glsl_function_inliner(),init_glsl_registered_libs(),init_glsl_source(),GlslPreprocessor=class{constructor(t,e,n,B){this.libs={},this.glslLibRoutineDependencyGraph={},this.context=new GlslContext(t,e,n,B),Object.keys(glslRegistry).forEach((t=>{const e=new glslRegistry[t](this.context);this.libs[t]=e}));const s=this.glslLibRoutineDependencyGraph;for(const t in this.libs){const e=this.libs[t].getFunctions();for(const n in e){const B=t+"."+n;let F;s[B]?(F=s[B],F.routineBody=e[n].routineBody):(F=new GlslLibRoutineNode(B,e[n].routineBody),s[B]=F);const Q=e[n].dependencies;if(Q)for(let t=0;t<Q.length;++t)if(s[Q[t]])F.addDependency(s[Q[t]]);else{const e=new GlslLibRoutineNode(Q[t]);s[Q[t]]=e,F.addDependency(e)}}}}preprocess(){const t=this.context.programInfo;let e=t.shaderSource;return this.context.programInfo.hasMain||(e=`${e}\n      ${getDefaultFragShaderMain(this.context.glContext.version,this.context.outputTextureLayout.shape.length)}`),e=replaceInlines(e),`${getFragShaderPreamble(this.context.glContext.version)}\n    ${this.getUniforms(t.inputNames,t.variables)}\n    ${this.getImports(e)}\n    ${e}`}getImports(t){const e=this.selectGlslLibRoutinesToBeIncluded(t);if(0===e.length)return"";let n="";for(let t=0;t<e.length;++t){if(!e[t].routineBody)throw new Error(`Missing body for the Glsl Library routine: ${e[t].name}`);n+=e[t].routineBody+"\n"}return n}selectGlslLibRoutinesToBeIncluded(t){const e=[];return Object.keys(this.glslLibRoutineDependencyGraph).forEach((n=>{const B=n.split(".")[1];-1!==t.indexOf(B)&&e.push(this.glslLibRoutineDependencyGraph[n])})),TopologicalSortGlslRoutines.returnOrderedNodes(e)}getUniforms(t,e){const n=[];if(t)for(const e of t)n.push(`uniform sampler2D ${e};`);if(e)for(const t of e)n.push(`uniform ${t.type} ${t.name}${t.arrayLength?`[${t.arrayLength}]`:""};`);return n.join("\n")}}}}),ProgramManager,init_program_manager=__esm({"web/lib/onnxjs/backends/webgl/program-manager.ts"(){init_esm(),init_instrument(),init_glsl_preprocessor(),init_glsl_source(),ProgramManager=class{constructor(t,e,n){this.profiler=t,this.glContext=e,this.textureLayoutStrategy=n,this.repo=new Map,this.attributesBound=!1}getArtifact(t){return this.repo.get(t)}setArtifact(t,e){this.repo.set(t,e)}run(t,e,n){this.profiler.event("op",`ProgramManager.run ${t.programInfo.name??"unknown kernel"}`,(()=>{const B=this.glContext.gl,s=t.program;B.useProgram(s);try{this.bindOutput(n),this.attributesBound||this.bindAttributes(t.attribLocations),this.bindUniforms(t.uniformLocations,t.programInfo.variables??[],e)}catch(e){throw Logger.error("ProgramManager",t.programInfo.shaderSource),e}this.profiler.event("backend","GlContext.draw()",(()=>{this.glContext.draw()}))}),this.glContext)}dispose(){this.vertexShader&&this.glContext.deleteShader(this.vertexShader),this.repo.forEach((t=>this.glContext.deleteProgram(t.program)))}build(t,e,n){return this.profiler.event("backend","ProgramManager.build",(()=>{const B=new GlslPreprocessor(this.glContext,t,e,n),s=B.preprocess(),F=this.compile(s);return{programInfo:t,program:F,uniformLocations:this.getUniformLocations(F,B.context.programInfo.inputNames,B.context.programInfo.variables),attribLocations:this.getAttribLocations(F)}}))}compile(t){if(!this.vertexShader){Logger.verbose("ProrgramManager","Compiling and caching Vertex shader for the first time");const t=getVertexShaderSource(this.glContext.version);this.vertexShader=this.glContext.compileShader(t,this.glContext.gl.VERTEX_SHADER)}env2.debug&&Logger.verbose("ProrgramManager",`FragShader:\n${t}\n`);const e=this.glContext.compileShader(t,this.glContext.gl.FRAGMENT_SHADER),n=this.glContext.createProgram(this.vertexShader,e);return this.glContext.deleteShader(e),n}bindOutput(t){const e=t.width,n=t.height;Logger.verbose("ProrgramManager",`Binding output texture to Framebuffer: w/h=${e}/${n}, shape=${t.shape}, type=${t.tensor.type}`),this.glContext.attachFramebuffer(t.texture,e,n)}bindAttributes(t){const e=t.position,n=t.textureCoord;this.glContext.setVertexAttributes(e,n),this.attributesBound=!0}bindUniforms(t,e,n){const B=this.glContext.gl;let s=0;for(const{name:F,type:Q,location:U,arrayLength:i}of t){const t=e.find((t=>t.name===F))?.data;if("sampler2D"!==Q&&!t)throw new Error(`variable '${F}' does not have data defined in program info`);switch(Q){case"sampler2D":this.bindTexture(n[s],U,s),s++;break;case"float":i?B.uniform1fv(U,t):B.uniform1f(U,t);break;case"int":i?B.uniform1iv(U,t):B.uniform1i(U,t);break;default:throw new Error(`Uniform not implemented: ${Q}`)}}}bindTexture(t,e,n){this.glContext.bindTextureToUniform(t.texture,n,e)}getAttribLocations(t){return{position:this.getAttribLocation(t,"position"),textureCoord:this.getAttribLocation(t,"textureCoord")}}getUniformLocations(t,e,n){const B=[];if(e)for(const n of e)B.push({name:n,type:"sampler2D",location:this.getUniformLocation(t,n)});if(n)for(const e of n)B.push({...e,location:this.getUniformLocation(t,e.name)});return B}getUniformLocation(t,e){const n=this.glContext.gl.getUniformLocation(t,e);if(null===n)throw new Error(`Uniform ${e} not found.`);return n}getAttribLocation(t,e){return this.glContext.gl.getAttribLocation(t,e)}}}}),TextureManager,init_texture_manager=__esm({"web/lib/onnxjs/backends/webgl/texture-manager.ts"(){init_instrument(),init_texture_data_encoder(),TextureManager=class{constructor(t,e,n,B){this.glContext=t,this.layoutStrategy=e,this.profiler=n,this.config=B,this.pendingRead=new Map,B.reuseTextures&&(this.inUseTextures=new Map,this.idleTextures=new Map,this.textureLookup=new Map)}createTextureFromLayout(t,e,n,B){const s=this.toEncoderType(t),F=this.glContext.getEncoder(s,e.channels||1,B);if(e.isPacked&&1===B)throw new Error("not implemented");const Q=e.width,U=e.height;let i,a;if(this.config.reuseTextures){i=`${Q}x${U}_${F.format}_${F.internalFormat}_${F.textureType}`,a=this.inUseTextures.get(i),a||(a=[],this.inUseTextures.set(i,a));const e=this.idleTextures.get(i);if(e&&e.length>0){const s=e.pop();return a.push(s),1===B&&this.glContext.updateTexture(s,Q,U,F,this.toTextureData(t,n)),s}}Logger.verbose("TextureManager",`Creating new texture of size ${e.width}x${e.height}`);const l=this.glContext.allocateTexture(Q,U,F,this.toTextureData(t,n));return this.config.reuseTextures&&(a.push(l),this.textureLookup.set(l,i)),l}readTexture(t,e,n){return n||(n=1),this.profiler.event("backend","TextureManager.readTexture",(()=>{const B=t.shape.reduce(((t,e)=>t*e))*n,s=this.glContext.readTexture(t.texture,t.width,t.height,B,this.toEncoderType(e),n);return this.toTensorData(e,s)}))}async readTextureAsync(t,e,n){const B=t.tensor.dataId;if(n||(n=1),this.pendingRead.has(B)){const t=this.pendingRead.get(B);return new Promise((e=>t?.push(e)))}return this.profiler.event("backend","TextureManager.readTextureAsync",(async()=>{this.pendingRead.set(B,[]);const s=t.shape.reduce(((t,e)=>t*e))*n;await this.glContext.createAndWaitForFence();const F=this.glContext.readTexture(t.texture,t.width,t.height,s,this.toEncoderType(e),n),Q=this.toTensorData(e,F),U=this.pendingRead.get(B);return this.pendingRead.delete(B),U?.forEach((t=>t(Q))),Q}))}readUint8TextureAsFloat(t){return this.profiler.event("backend","TextureManager.readUint8TextureAsFloat",(()=>{const e=t.shape.reduce(((t,e)=>t*e)),n=this.glContext.readTexture(t.texture,t.width,t.height,4*e,"byte",4);return new Float32Array(n.buffer,n.byteOffset,e)}))}releaseTexture(t,e){let n;if(this.config.reuseTextures&&(n=this.textureLookup.get(t.texture),n)){e&&this.textureLookup.delete(n);const B=this.inUseTextures.get(n);if(B){const e=B.indexOf(t.texture);if(-1!==e){B.splice(e,1);let s=this.idleTextures.get(n);s||(s=[],this.idleTextures.set(n,s)),s.push(t.texture)}}}n&&!e||(Logger.verbose("TextureManager",`Deleting texture of size ${t.width}x${t.height}`),this.glContext.deleteTexture(t.texture))}toTensorData(t,e){switch(t){case"int16":return e instanceof Int16Array?e:Int16Array.from(e);case"int32":return e instanceof Int32Array?e:Int32Array.from(e);case"int8":return e instanceof Int8Array?e:Int8Array.from(e);case"uint16":return e instanceof Uint16Array?e:Uint16Array.from(e);case"uint32":return e instanceof Uint32Array?e:Uint32Array.from(e);case"uint8":case"bool":return e instanceof Uint8Array?e:Uint8Array.from(e);case"float32":return e instanceof Float32Array?e:Float32Array.from(e);case"float64":return e instanceof Float64Array?e:Float64Array.from(e);default:throw new Error(`TensorData type ${t} is not supported`)}}toTextureData(t,e){if(e)return e instanceof Float32Array?e:new Float32Array(e)}toEncoderType(t){return"float"}clearActiveTextures(){this.glContext.clearActiveTextures()}}}}),WebGLSessionHandler,init_session_handler=__esm({"web/lib/onnxjs/backends/webgl/session-handler.ts"(){init_instrument(),init_opset(),init_inference_handler(),init_op_resolve_rules(),init_program_manager(),init_texture_layout_strategy(),init_texture_manager(),WebGLSessionHandler=class{constructor(t,e){this.backend=t,this.context=e,this.layoutStrategy=new PreferLogicalStrategy(t.glContext.maxTextureSize),this.programManager=new ProgramManager(this.context.profiler,t.glContext,this.layoutStrategy),this.textureManager=new TextureManager(t.glContext,this.layoutStrategy,this.context.profiler,{reuseTextures:"full"===t.textureCacheMode}),this.packedTextureDataCache=new Map,this.unpackedTextureDataCache=new Map,this.pack=t.pack,this.pack2unpackMap=new Map,this.unpack2packMap=new Map}createInferenceHandler(){return new WebGLInferenceHandler(this)}onGraphInitialized(t){const e=t.getValues().filter((t=>-1===t.from&&t.tensor)).map((t=>t.tensor.dataId));this.initializers=new Set(e)}isInitializer(t){return!!this.initializers&&this.initializers.has(t)}addInitializer(t){this.initializers.add(t)}getTextureData(t,e){return e?this.packedTextureDataCache.get(t):this.unpackedTextureDataCache.get(t)}setTextureData(t,e,n=!1){Logger.verbose("WebGLSessionHandler","Storing Texture data in cache"),n?this.packedTextureDataCache.set(t,e):this.unpackedTextureDataCache.set(t,e)}dispose(){this.programManager.dispose(),this.textureManager.clearActiveTextures(),this.packedTextureDataCache.forEach((t=>this.textureManager.releaseTexture(t,!0))),this.packedTextureDataCache=new Map,this.unpackedTextureDataCache.forEach((t=>this.textureManager.releaseTexture(t,!0))),this.unpackedTextureDataCache=new Map}resolve(t,e,n){const B=resolveOperator(t,e,WEBGL_OP_RESOLVE_RULES);return{impl:B.opImpl,context:B.opInit?B.opInit(t,n):t}}}}}),WebGLContext;function linearSearchLastTrue(t){let e=0;for(;e<t.length;++e){if(!t[e]())break}return e-1}var init_webgl_context=__esm({"web/lib/onnxjs/backends/webgl/webgl-context.ts"(){init_esm(),init_texture_data_encoder(),init_texture_data_encoder(),init_utils(),WebGLContext=class{constructor(t,e){this.frameBufferBound=!1,this.itemsToPoll=[],this.gl=t,this.version=e,this.getExtensions(),this.vertexbuffer=this.createVertexbuffer(),this.framebuffer=this.createFramebuffer(),this.queryVitalParameters()}allocateTexture(t,e,n,B){const s=this.gl,F=s.createTexture();s.bindTexture(s.TEXTURE_2D,F),s.texParameteri(s.TEXTURE_2D,s.TEXTURE_MIN_FILTER,s.NEAREST),s.texParameteri(s.TEXTURE_2D,s.TEXTURE_MAG_FILTER,s.NEAREST),s.texParameteri(s.TEXTURE_2D,s.TEXTURE_WRAP_S,s.CLAMP_TO_EDGE),s.texParameteri(s.TEXTURE_2D,s.TEXTURE_WRAP_T,s.CLAMP_TO_EDGE);const Q=B?n.encode(B,t*e):null;return s.texImage2D(s.TEXTURE_2D,0,n.internalFormat,t,e,0,n.format,n.textureType,Q),this.checkError(),F}updateTexture(t,e,n,B,s){const F=this.gl;F.bindTexture(F.TEXTURE_2D,t);const Q=B.encode(s,e*n);F.texSubImage2D(F.TEXTURE_2D,0,0,0,e,n,B.format,B.textureType,Q),this.checkError()}attachFramebuffer(t,e,n){const B=this.gl;B.bindTexture(B.TEXTURE_2D,t),B.bindFramebuffer(B.FRAMEBUFFER,this.framebuffer),B.framebufferTexture2D(B.FRAMEBUFFER,B.COLOR_ATTACHMENT0,B.TEXTURE_2D,t,0),this.checkError(),B.viewport(0,0,e,n),B.scissor(0,0,e,n)}readTexture(t,e,n,B,s,F){const Q=this.gl;F||(F=1),this.frameBufferBound||this.attachFramebuffer(t,e,n);const U=this.getEncoder(s,F),i=U.allocate(e*n);return Q.bindTexture(Q.TEXTURE_2D,t),Q.framebufferTexture2D(Q.FRAMEBUFFER,Q.COLOR_ATTACHMENT0,Q.TEXTURE_2D,t,0),Q.readPixels(0,0,e,n,Q.RGBA,U.textureType,i),this.checkError(),U.decode(i,B)}isFramebufferReady(){return!0}getActiveTexture(){const t=this.gl;return"TEXTURE"+(t.getParameter(this.gl.ACTIVE_TEXTURE)-t.TEXTURE0)}getTextureBinding(){return this.gl.getParameter(this.gl.TEXTURE_BINDING_2D)}getFramebufferBinding(){return this.gl.getParameter(this.gl.FRAMEBUFFER_BINDING)}setVertexAttributes(t,e){const n=this.gl;n.vertexAttribPointer(t,3,n.FLOAT,!1,20,0),n.enableVertexAttribArray(t),-1!==e&&(n.vertexAttribPointer(e,2,n.FLOAT,!1,20,12),n.enableVertexAttribArray(e)),this.checkError()}createProgram(t,e){const n=this.gl,B=n.createProgram();return n.attachShader(B,t),n.attachShader(B,e),n.linkProgram(B),B}compileShader(t,e){const n=this.gl,B=n.createShader(e);if(!B)throw new Error(`createShader() returned null with type ${e}`);if(n.shaderSource(B,t),n.compileShader(B),!1===n.getShaderParameter(B,n.COMPILE_STATUS))throw new Error(`Failed to compile shader: ${n.getShaderInfoLog(B)}\nShader source:\n${t}`);return B}deleteShader(t){this.gl.deleteShader(t)}bindTextureToUniform(t,e,n){const B=this.gl;B.activeTexture(B.TEXTURE0+e),this.checkError(),B.bindTexture(B.TEXTURE_2D,t),this.checkError(),B.uniform1i(n,e),this.checkError()}draw(){this.gl.drawArrays(this.gl.TRIANGLE_STRIP,0,4),this.checkError()}checkError(){if(env2.debug){const t=this.gl,e=t.getError();let n="";switch(e){case t.NO_ERROR:return;case t.INVALID_ENUM:n="INVALID_ENUM";break;case t.INVALID_VALUE:n="INVALID_VALUE";break;case t.INVALID_OPERATION:n="INVALID_OPERATION";break;case t.INVALID_FRAMEBUFFER_OPERATION:n="INVALID_FRAMEBUFFER_OPERATION";break;case t.OUT_OF_MEMORY:n="OUT_OF_MEMORY";break;case t.CONTEXT_LOST_WEBGL:n="CONTEXT_LOST_WEBGL";break;default:n=`Unknown WebGL Error: ${e.toString(16)}`}throw new Error(n)}}deleteTexture(t){this.gl.deleteTexture(t)}deleteProgram(t){this.gl.deleteProgram(t)}getEncoder(t,e,n=0){if(2===this.version)return new RedFloat32DataEncoder(this.gl,e);switch(t){case"float":return 1===n||this.isRenderFloat32Supported?new RGBAFloatDataEncoder(this.gl,e):new RGBAFloatDataEncoder(this.gl,e,this.textureHalfFloatExtension.HALF_FLOAT_OES);case"int":throw new Error("not implemented");case"byte":return new Uint8DataEncoder(this.gl,e);default:throw new Error(`Invalid dataType: ${t}`)}}clearActiveTextures(){const t=this.gl;for(let e=0;e<this.maxTextureImageUnits;++e)t.activeTexture(t.TEXTURE0+e),t.bindTexture(t.TEXTURE_2D,null)}dispose(){if(this.disposed)return;const t=this.gl;t.bindFramebuffer(t.FRAMEBUFFER,null),t.deleteFramebuffer(this.framebuffer),t.bindBuffer(t.ARRAY_BUFFER,null),t.deleteBuffer(this.vertexbuffer),t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,null),t.finish(),this.disposed=!0}createDefaultGeometry(){return new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0])}createVertexbuffer(){const t=this.gl,e=t.createBuffer();if(!e)throw new Error("createBuffer() returned null");const n=this.createDefaultGeometry();return t.bindBuffer(t.ARRAY_BUFFER,e),t.bufferData(t.ARRAY_BUFFER,n,t.STATIC_DRAW),this.checkError(),e}createFramebuffer(){const t=this.gl.createFramebuffer();if(!t)throw new Error("createFramebuffer returned null");return t}queryVitalParameters(){const t=this.gl;if(this.isFloatTextureAttachableToFrameBuffer=this.checkFloatTextureAttachableToFrameBuffer(),this.isRenderFloat32Supported=this.checkRenderFloat32(),this.isFloat32DownloadSupported=this.checkFloat32Download(),1===this.version&&!this.textureHalfFloatExtension&&!this.isRenderFloat32Supported)throw new Error("both float32 and float16 TextureType are not supported");this.isBlendSupported=!this.isRenderFloat32Supported||this.checkFloat32Blend(),this.maxTextureSize=t.getParameter(t.MAX_TEXTURE_SIZE),this.maxTextureImageUnits=t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS),this.version}getExtensions(){2===this.version?(this.colorBufferFloatExtension=this.gl.getExtension("EXT_color_buffer_float"),this.disjointTimerQueryWebgl2Extension=this.gl.getExtension("EXT_disjoint_timer_query_webgl2")):(this.textureFloatExtension=this.gl.getExtension("OES_texture_float"),this.textureHalfFloatExtension=this.gl.getExtension("OES_texture_half_float"))}checkFloatTextureAttachableToFrameBuffer(){const t=this.gl,e=t.createTexture();t.bindTexture(t.TEXTURE_2D,e);const n=2===this.version?t.RGBA32F:t.RGBA;t.texImage2D(t.TEXTURE_2D,0,n,1,1,0,t.RGBA,t.FLOAT,null);const B=t.createFramebuffer();t.bindFramebuffer(t.FRAMEBUFFER,B),t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,e,0);const s=t.checkFramebufferStatus(t.FRAMEBUFFER)===t.FRAMEBUFFER_COMPLETE;return t.bindTexture(t.TEXTURE_2D,null),t.bindFramebuffer(t.FRAMEBUFFER,null),t.deleteTexture(e),t.deleteFramebuffer(B),s}checkRenderFloat32(){if(2===this.version){if(!this.colorBufferFloatExtension)return!1}else if(!this.textureFloatExtension)return!1;return this.isFloatTextureAttachableToFrameBuffer}checkFloat32Download(){if(2===this.version){if(!this.colorBufferFloatExtension)return!1}else{if(!this.textureFloatExtension)return!1;if(!this.gl.getExtension("WEBGL_color_buffer_float"))return!1}return this.isFloatTextureAttachableToFrameBuffer}checkFloat32Blend(){const t=this.gl;let e,n,B,s,F;try{e=t.createTexture(),n=t.createFramebuffer(),t.bindTexture(t.TEXTURE_2D,e);const Q=2===this.version?t.RGBA32F:t.RGBA;return t.texImage2D(t.TEXTURE_2D,0,Q,1,1,0,t.RGBA,t.FLOAT,null),t.bindFramebuffer(t.FRAMEBUFFER,n),t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,e,0),t.enable(t.BLEND),B=t.createShader(t.VERTEX_SHADER),B?(t.shaderSource(B,"void main(){}"),t.compileShader(B),s=t.createShader(t.FRAGMENT_SHADER),!!s&&(t.shaderSource(s,"precision highp float;void main(){gl_FragColor=vec4(0.5);}"),t.compileShader(s),F=t.createProgram(),!!F&&(t.attachShader(F,B),t.attachShader(F,s),t.linkProgram(F),t.useProgram(F),t.drawArrays(t.POINTS,0,1),t.getError()===t.NO_ERROR))):!1}finally{t.disable(t.BLEND),F&&t.deleteProgram(F),B&&t.deleteShader(B),s&&t.deleteShader(s),n&&(t.bindFramebuffer(t.FRAMEBUFFER,null),t.deleteFramebuffer(n)),e&&(t.bindTexture(t.TEXTURE_2D,null),t.deleteTexture(e))}}beginTimer(){if(2===this.version&&this.disjointTimerQueryWebgl2Extension){const t=this.gl,e=this.disjointTimerQueryWebgl2Extension,n=t.createQuery();return t.beginQuery(e.TIME_ELAPSED_EXT,n),n}throw new Error("WebGL1 profiling currently not supported.")}endTimer(){if(2!==this.version||!this.disjointTimerQueryWebgl2Extension)throw new Error("WebGL1 profiling currently not supported");{const t=this.gl,e=this.disjointTimerQueryWebgl2Extension;t.endQuery(e.TIME_ELAPSED_EXT)}}isTimerResultAvailable(t){let e=!1,n=!1;if(2!==this.version||!this.disjointTimerQueryWebgl2Extension)throw new Error("WebGL1 profiling currently not supported");{const B=this.gl,s=this.disjointTimerQueryWebgl2Extension;e=B.getQueryParameter(t,B.QUERY_RESULT_AVAILABLE),n=B.getParameter(s.GPU_DISJOINT_EXT)}return e&&!n}getTimerResult(t){let e=0;if(2!==this.version)throw new Error("WebGL1 profiling currently not supported");{const n=this.gl;e=n.getQueryParameter(t,n.QUERY_RESULT),n.deleteQuery(t)}return e/1e6}async waitForQueryAndGetTime(t){return await repeatedTry((()=>this.isTimerResultAvailable(t))),this.getTimerResult(t)}async createAndWaitForFence(){const t=this.createFence(this.gl);return this.pollFence(t)}createFence(t){let e;const n=t,B=n.fenceSync(n.SYNC_GPU_COMMANDS_COMPLETE,0);return t.flush(),e=null===B?()=>!0:()=>{const t=n.clientWaitSync(B,0,0);return t===n.ALREADY_SIGNALED||t===n.CONDITION_SATISFIED},{query:B,isFencePassed:e}}async pollFence(t){return new Promise((e=>{this.addItemToPoll((()=>t.isFencePassed()),(()=>e()))}))}pollItems(){const t=linearSearchLastTrue(this.itemsToPoll.map((t=>t.isDoneFn)));for(let e=0;e<=t;++e){const{resolveFn:t}=this.itemsToPoll[e];t()}this.itemsToPoll=this.itemsToPoll.slice(t+1)}async addItemToPoll(t,e){this.itemsToPoll.push({isDoneFn:t,resolveFn:e}),this.itemsToPoll.length>1||await repeatedTry((()=>(this.pollItems(),0===this.itemsToPoll.length)))}}}}),cache;function createWebGLContext(t){let e;if(t&&"webgl2"!==t||!("webgl2"in cache)?t&&"webgl"!==t||!("webgl"in cache)||(e=cache.webgl):e=cache.webgl2,!e)try{e=createNewWebGLContext(createOffscreenCanvas(),t)}catch(n){e=createNewWebGLContext(createCanvas(),t)}t=t||1===e.version?"webgl":"webgl2";const n=e.gl;return cache[t]=e,n.isContextLost()?(delete cache[t],createWebGLContext(t)):(n.disable(n.DEPTH_TEST),n.disable(n.STENCIL_TEST),n.disable(n.BLEND),n.disable(n.DITHER),n.disable(n.POLYGON_OFFSET_FILL),n.disable(n.SAMPLE_COVERAGE),n.enable(n.SCISSOR_TEST),n.enable(n.CULL_FACE),n.cullFace(n.BACK),e)}function createNewWebGLContext(t,e){let n;const B={alpha:!1,depth:!1,antialias:!1,stencil:!1,preserveDrawingBuffer:!1,premultipliedAlpha:!1,failIfMajorPerformanceCaveat:!1};if((!e||"webgl2"===e)&&(n=t.getContext("webgl2",B),n))try{return new WebGLContext(n,2)}catch(t){Logger.warning("GlContextFactory",`failed to create WebGLContext using contextId 'webgl2'. Error: ${t}`)}if((!e||"webgl"===e)&&(n=t.getContext("webgl",B)||t.getContext("experimental-webgl",B),n))try{return new WebGLContext(n,1)}catch(t){Logger.warning("GlContextFactory",`failed to create WebGLContext using contextId 'webgl' or 'experimental-webgl'. Error: ${t}`)}throw new Error("WebGL is not supported")}function createCanvas(){if("undefined"==typeof document)throw new TypeError("failed to create canvas: document is not supported");const t=document.createElement("canvas");return t.width=1,t.height=1,t}function createOffscreenCanvas(){if("undefined"==typeof OffscreenCanvas)throw new TypeError("failed to create offscreen canvas: OffscreenCanvas is not supported");return new OffscreenCanvas(1,1)}var init_webgl_context_factory=__esm({"web/lib/onnxjs/backends/webgl/webgl-context-factory.ts"(){init_instrument(),init_webgl_context(),cache={}}}),WebGLBackend,init_backend_webgl=__esm({"web/lib/onnxjs/backends/backend-webgl.ts"(){init_esm(),init_instrument(),init_session_handler(),init_webgl_context_factory(),WebGLBackend=class{get contextId(){return env2.webgl.contextId}set contextId(t){env2.webgl.contextId=t}get matmulMaxBatchSize(){return env2.webgl.matmulMaxBatchSize}set matmulMaxBatchSize(t){env2.webgl.matmulMaxBatchSize=t}get textureCacheMode(){return env2.webgl.textureCacheMode}set textureCacheMode(t){env2.webgl.textureCacheMode=t}get pack(){return env2.webgl.pack}set pack(t){env2.webgl.pack=t}get async(){return env2.webgl.async}set async(t){env2.webgl.async=t}initialize(){try{return this.glContext=createWebGLContext(this.contextId),"number"!=typeof this.matmulMaxBatchSize&&(this.matmulMaxBatchSize=16),"string"!=typeof this.textureCacheMode&&(this.textureCacheMode="full"),"boolean"!=typeof this.pack&&(this.pack=!1),"boolean"!=typeof this.async&&(this.async=!1),Logger.setWithEnv(env2),env2.webgl.context||Object.defineProperty(env2.webgl,"context",{value:this.glContext.gl}),Logger.verbose("WebGLBackend",`Created WebGLContext: ${typeof this.glContext} with matmulMaxBatchSize: ${this.matmulMaxBatchSize}; textureCacheMode: ${this.textureCacheMode}; pack: ${this.pack}; async: ${this.async}.`),!0}catch(t){return Logger.warning("WebGLBackend",`Unable to initialize WebGLBackend. ${t}`),!1}}createSessionHandler(t){return new WebGLSessionHandler(this,t)}dispose(){this.glContext.dispose()}}}}),backendsCache,backend;async function resolveBackend2(t){if(!t)return resolveBackend2(["webgl"]);{const e="string"==typeof t?[t]:t;for(const t of e){const e=backendsCache.get(t);if(e)return e;const n=await tryLoadBackend(t);if(n)return n}}throw new Error("no available backend to use")}async function tryLoadBackend(t){const e=backend;if(void 0!==e[t]&&isBackend(e[t])){const n=e[t];let B=n.initialize();if("object"==typeof B&&"then"in B&&(B=await B),B)return backendsCache.set(t,n),n}}function isBackend(t){const e=t;return"initialize"in e&&"function"==typeof e.initialize&&"createSessionHandler"in e&&"function"==typeof e.createSessionHandler&&"dispose"in e&&"function"==typeof e.dispose}var init_backend2=__esm({"web/lib/onnxjs/backend.ts"(){init_backend_webgl(),backendsCache=new Map,backend={webgl:new WebGLBackend}}}),KernelOp,ExecutionPlan,init_execution_plan=__esm({"web/lib/onnxjs/execution-plan.ts"(){init_instrument(),KernelOp=class{constructor(t,e){this.op=t,this.node=e}},ExecutionPlan=class{constructor(t,e,n){this.graph=t,this.profiler=n,this.initialize(e)}initialize(t){this.profiler.event("session","ExecutionPlan.initialize",(()=>{const e=this.graph.getNodes();if(e.length!==t.length)throw new Error("The size of nodes and OPs do not match.");this._ops=t.map(((t,n)=>new KernelOp(t,e[n]))),this.reset(),this._starter=[],this._ops.forEach(((t,e)=>{let n=!0;for(const e of t.node.inputs)if(!this._values[e]&&-1===this.graph.getInputIndices().indexOf(e)){n=!1;break}n&&this._starter.push(e)}))}))}reset(){this._values=this.graph.getValues().map((t=>t.tensor))}async execute(t,e){return this.profiler.event("session","ExecutionPlan.execute",(async()=>{this.reset();const n=t.createInferenceHandler(),B=this.graph.getInputIndices();if(e.length!==B.length)throw new Error(`number of input tensors don't match the number of inputs to the model: actual: ${e.length} expected: ${B.length}`);e.forEach(((t,e)=>{const n=B[e];this._values[n]=t}));const s=this._starter.slice(0),F=this.graph.getValues(),Q=this.graph.getNodes();let U=0;for(;U<s.length;){const t=s[U++],e=this._ops[t],B=e.node.inputs.map((t=>this._values[t]));if(-1!==B.indexOf(void 0))throw new Error(`unresolved input detected: op: ${e.node}`);const i=B;Logger.verbose("ExecPlan",`Runing op:${e.node.name} (${i.map(((t,n)=>`'${e.node.inputs[n]}': ${t.type}[${t.dims.join(",")}]`)).join(", ")})`);const a=await this.profiler.event("node",e.node.name,(async()=>e.op.impl(n,i,e.op.context)));if(a.length!==e.node.outputs.length)throw new Error("the size of output does not match model definition.");a.forEach(((t,n)=>{const B=e.node.outputs[n];if(this._values[B])throw new Error(`output [${B}] already has value: op:${e.node.name}`);this._values[B]=t}));const l=new Set;a.forEach(((t,n)=>{const B=e.node.outputs[n];for(const t of F[B].to){const e=Q[t];let n=!0;for(const t of e.inputs)if(!this._values[t]){n=!1;break}n&&l.add(t)}})),s.push(...l)}const i=[];for(let t=0;t<this.graph.getOutputIndices().length;t++){const e=this.graph.getOutputIndices()[t],n=this._values[e];if(void 0===n)throw new Error(`required output [${e}] does not have value`);0===e?await n.getData():n.data,i.push(n)}return Logger.verbose("ExecPlan","disposing of inferenceHandler"),n.dispose(),i}))}}}}),import_onnx3,ortFbs2,Attribute,init_attribute=__esm({"web/lib/onnxjs/attribute.ts"(){init_ort_generated(),import_onnx3=__toESM(require_onnx()),init_tensor2(),init_util(),ortFbs2=onnxruntime.experimental.fbs,Attribute=class t{constructor(e){if(this._attributes=new Map,null!=e){for(const n of e)n instanceof import_onnx3.onnx.AttributeProto?this._attributes.set(n.name,[t.getValue(n),t.getType(n)]):n instanceof ortFbs2.Attribute&&this._attributes.set(n.name(),[t.getValue(n),t.getType(n)]);if(this._attributes.size<e.length)throw new Error("duplicated attribute names")}}set(t,e,n){this._attributes.set(t,[n,e])}delete(t){this._attributes.delete(t)}getFloat(t,e){return this.get(t,"float",e)}getInt(t,e){return this.get(t,"int",e)}getString(t,e){return this.get(t,"string",e)}getTensor(t,e){return this.get(t,"tensor",e)}getFloats(t,e){return this.get(t,"floats",e)}getInts(t,e){return this.get(t,"ints",e)}getStrings(t,e){return this.get(t,"strings",e)}getTensors(t,e){return this.get(t,"tensors",e)}get(t,e,n){const B=this._attributes.get(t);if(void 0===B){if(void 0!==n)return n;throw new Error(`required attribute not found: ${t}`)}if(B[1]!==e)throw new Error(`type mismatch: expected ${e} but got ${B[1]}`);return B[0]}static getType(t){const e=t instanceof import_onnx3.onnx.AttributeProto?t.type:t.type();switch(e){case import_onnx3.onnx.AttributeProto.AttributeType.FLOAT:return"float";case import_onnx3.onnx.AttributeProto.AttributeType.INT:return"int";case import_onnx3.onnx.AttributeProto.AttributeType.STRING:return"string";case import_onnx3.onnx.AttributeProto.AttributeType.TENSOR:return"tensor";case import_onnx3.onnx.AttributeProto.AttributeType.FLOATS:return"floats";case import_onnx3.onnx.AttributeProto.AttributeType.INTS:return"ints";case import_onnx3.onnx.AttributeProto.AttributeType.STRINGS:return"strings";case import_onnx3.onnx.AttributeProto.AttributeType.TENSORS:return"tensors";default:throw new Error(`attribute type is not supported yet: ${import_onnx3.onnx.AttributeProto.AttributeType[e]}`)}}static getValue(t){const e=t instanceof import_onnx3.onnx.AttributeProto?t.type:t.type();if(e===import_onnx3.onnx.AttributeProto.AttributeType.GRAPH||e===import_onnx3.onnx.AttributeProto.AttributeType.GRAPHS)throw new Error("graph attribute is not supported yet");const n=this.getValueNoCheck(t);if(e===import_onnx3.onnx.AttributeProto.AttributeType.INT&&LongUtil.isLong(n))return LongUtil.longToNumber(n);if(e===import_onnx3.onnx.AttributeProto.AttributeType.INTS){const t=n,e=new Array(t.length);for(let n=0;n<t.length;n++){const B=t[n];e[n]=LongUtil.longToNumber(B)}return e}if(e===import_onnx3.onnx.AttributeProto.AttributeType.TENSOR)return t instanceof import_onnx3.onnx.AttributeProto?Tensor3.fromProto(n):Tensor3.fromOrtTensor(n);if(e===import_onnx3.onnx.AttributeProto.AttributeType.TENSORS){if(t instanceof import_onnx3.onnx.AttributeProto){return n.map((t=>Tensor3.fromProto(t)))}if(t instanceof ortFbs2.Attribute){return n.map((t=>Tensor3.fromOrtTensor(t)))}}if(e===import_onnx3.onnx.AttributeProto.AttributeType.STRING&&t instanceof import_onnx3.onnx.AttributeProto){return decodeUtf8String(n)}if(e===import_onnx3.onnx.AttributeProto.AttributeType.STRINGS&&t instanceof import_onnx3.onnx.AttributeProto){return n.map(decodeUtf8String)}return n}static getValueNoCheck(t){return t instanceof import_onnx3.onnx.AttributeProto?this.getValueNoCheckFromOnnxFormat(t):this.getValueNoCheckFromOrtFormat(t)}static getValueNoCheckFromOnnxFormat(t){switch(t.type){case import_onnx3.onnx.AttributeProto.AttributeType.FLOAT:return t.f;case import_onnx3.onnx.AttributeProto.AttributeType.INT:return t.i;case import_onnx3.onnx.AttributeProto.AttributeType.STRING:return t.s;case import_onnx3.onnx.AttributeProto.AttributeType.TENSOR:return t.t;case import_onnx3.onnx.AttributeProto.AttributeType.GRAPH:return t.g;case import_onnx3.onnx.AttributeProto.AttributeType.FLOATS:return t.floats;case import_onnx3.onnx.AttributeProto.AttributeType.INTS:return t.ints;case import_onnx3.onnx.AttributeProto.AttributeType.STRINGS:return t.strings;case import_onnx3.onnx.AttributeProto.AttributeType.TENSORS:return t.tensors;case import_onnx3.onnx.AttributeProto.AttributeType.GRAPHS:return t.graphs;default:throw new Error(`unsupported attribute type: ${import_onnx3.onnx.AttributeProto.AttributeType[t.type]}`)}}static getValueNoCheckFromOrtFormat(t){switch(t.type()){case ortFbs2.AttributeType.FLOAT:return t.f();case ortFbs2.AttributeType.INT:return t.i();case ortFbs2.AttributeType.STRING:return t.s();case ortFbs2.AttributeType.TENSOR:return t.t();case ortFbs2.AttributeType.GRAPH:return t.g();case ortFbs2.AttributeType.FLOATS:return t.floatsArray();case ortFbs2.AttributeType.INTS:{const e=[];for(let n=0;n<t.intsLength();n++)e.push(t.ints(n));return e}case ortFbs2.AttributeType.STRINGS:{const e=[];for(let n=0;n<t.stringsLength();n++)e.push(t.strings(n));return e}case ortFbs2.AttributeType.TENSORS:{const e=[];for(let n=0;n<t.tensorsLength();n++)e.push(t.tensors(n));return e}default:throw new Error(`unsupported attribute type: ${ortFbs2.AttributeType[t.type()]}`)}}}}}),import_onnx4,ortFbs3,Graph,Value,Node,GraphImpl,init_graph=__esm({"web/lib/onnxjs/graph.ts"(){init_attribute(),init_ort_generated(),import_onnx4=__toESM(require_onnx()),init_tensor2(),init_util(),ortFbs3=onnxruntime.experimental.fbs,Graph={from:(t,e)=>new GraphImpl(t,e)},Value=class{constructor(t){this._from=void 0,this._to=[],this.tensor=void 0,this.type=void 0,t&&(this.type=ProtoUtil.tensorValueTypeFromProto(t.type.tensorType))}get from(){return this._from}get to(){return this._to}},Node=class{constructor(t,e){t instanceof import_onnx4.onnx.NodeProto?(this.name=t.name,this.opType=t.opType,this.attributes=new Attribute(t.attribute)):t instanceof ortFbs3.Node&&(this.name=e??t.name(),this.opType=t.opType(),this.attributes=new Attribute(ProtoUtil.tensorAttributesFromORTFormat(t))),this.inputs=[],this.outputs=[],this.executeNode=!0}},GraphImpl=class{constructor(t,e){if(!t)throw new TypeError("graph is empty");this.buildGraph(t),this.transformGraph(e),this.checkIsAcyclic()}getInputIndices(){return this._allInputIndices}getInputNames(){return this._allInputNames}getOutputIndices(){return this._allOutputIndices}getOutputNames(){return this._allOutputNames}getValues(){return this._allData}getNodes(){return this._nodes}buildGraph(t){if(t instanceof import_onnx4.onnx.GraphProto)this.buildGraphFromOnnxFormat(t);else{if(!(t instanceof ortFbs3.Graph))throw new TypeError("Graph type is not supported.");this.buildGraphFromOrtFormat(t)}}buildGraphFromOnnxFormat(t){const e=new Map;this._allData=[],this._allInputIndices=[],this._allInputNames=[],this._allOutputIndices=[],this._allOutputNames=[],this._nodes=[];const n=new Map;if(!t.input)throw new Error("missing information in graph: input");const B=[];for(const n of t.input){if(e.has(n.name))throw new Error(`duplicated input name: ${n.name}`);const t=this._allData.push(new Value(n))-1;e.set(n.name,t),B.push(n.name)}if(!t.initializer)throw new Error("missing information in graph: initializer");for(const n of t.initializer){let t=e.get(n.name);if(void 0===t){const B=new Value;B.type={shape:{dims:ProtoUtil.tensorDimsFromProto(n.dims)},tensorType:ProtoUtil.tensorDataTypeFromProto(n.dataType)},t=this._allData.push(B)-1,e.set(n.name,t)}this._allData[t]._from=-1,this._allData[t].tensor=Tensor3.fromProto(n)}for(let t=0;t<this._allData.length;t++)this._allData[t].tensor||(this._allInputIndices.push(t),this._allInputNames.push(B[t]));if(!t.output)throw new Error("missing information in graph: output");for(const n of t.output){if(e.has(n.name))throw new Error(`duplicated output name: ${n.name}`);const t=this._allData.push(new Value(n))-1;e.set(n.name,t),this._allOutputIndices.push(t),this._allOutputNames.push(n.name)}if(!t.node)throw new Error("missing information in graph: node");for(const e of t.node){if(!e.name)for(let t=0;;t++){const B=`unnamed_${e.opType}_${t}`;if(!n.has(B)){e.name=B;break}}if(n.has(e.name))throw new Error(`duplicated node name: ${e.name}`);const t=this._nodes.push(new Node(e))-1;n.set(e.name,t)}for(let n=0;n<this._nodes.length;n++){const B=this._nodes[n],s=t.node[n];if(!s.output)throw new Error(`missing output for node: ${s.name}`);for(const t of s.output){let F=e.get(t);if(void 0===F&&(F=this._allData.push(new Value)-1,e.set(t,F)),B.outputs.push(F),void 0!==this._allData[F]._from)throw new Error(`multiple nodes output to one data value: ${F}`);if(this._allData[F]._from=n,"Constant"===s.opType){if(!s.attribute||1!==s.attribute.length||!s.attribute[0].t)throw new Error("missing attributes or missing tensor value in attributes for this Constant operator");if(!s.output||1!==s.output.length)throw new Error("missing output or incorrect number of outputs for this Constant operator");B.outputs.pop(),B.executeNode=!1,this._allData[F]._from=-1,this._allData[F].tensor=Tensor3.fromProto(s.attribute[0].t)}}}for(let n=0;n<this._nodes.length;n++){const B=this._nodes[n],s=t.node[n];if(!s.input)throw new Error(`missing input for node: ${s.name}`);for(const t of s.input){const F=e.get(t);if(void 0===F){if(""===t&&(3===s.input.length||4===s.input.length)&&"Resize"===s.opType)continue;throw new Error(`unrecognized input '${t}' for node: ${s.name}`)}B.inputs.push(F),this._allData[F]._to.push(n)}}return!0}buildGraphFromOrtFormat(t){const e=new Map;this._allData=[],this._allInputIndices=[],this._allInputNames=[],this._allOutputIndices=[],this._allOutputNames=[],this._nodes=[];const n=new Map,B=[];for(let n=0;n<t.inputsLength();n++){const s=t.inputs(n);if(e.has(s))throw new Error(`duplicated input name: ${s}`);for(let n=0;n<t.nodeArgsLength();n++)if(t.nodeArgs(n)?.name()===s){const F=new Value,Q=t.nodeArgs(n)?.type()?.valueType();if(Q!==ortFbs3.TypeInfoValue.tensor_type)throw new Error("Unexpected value type for the nodeArg.");const U=t.nodeArgs(n).type().value(new ortFbs3.TensorTypeAndShape),i=ProtoUtil.tensorDataTypeFromProto(U.elemType()),a=U.shape(),l=[];for(let t=0;t<a.dimLength();t++)l.push(LongUtil.longToNumber(a.dim(t).value().dimValue()));F.type={shape:{dims:l},tensorType:i};const c=this._allData.push(F)-1;e.set(s,c),B.push(s)}}for(let n=0;n<t.initializersLength();n++){const B=t.initializers(n);let s=e.get(B.name());if(void 0===s){const t=new Value,n=ProtoUtil.tensorDimsFromORTFormat(B),F=ProtoUtil.tensorDataTypeFromProto(B.dataType());t.type={shape:{dims:n},tensorType:F},s=this._allData.push(t)-1,e.set(B.name(),s)}this._allData[s]._from=-1,this._allData[s].tensor=Tensor3.fromOrtTensor(B)}for(let t=0;t<this._allData.length;t++)this._allData[t].tensor||(this._allInputIndices.push(t),this._allInputNames.push(B[t]));for(let n=0;n<t.outputsLength();n++){const B=t.outputs(n);if(e.has(B))throw new Error(`duplicated output name: ${B}`);const s=this._allData.push(new Value)-1;e.set(B,s),this._allOutputIndices.push(s),this._allOutputNames.push(B)}if(!t.nodes)throw new Error("missing information in graph: node");for(let e=0;e<t.nodesLength();e++){const B=t.nodes(e);let s=B.name();if(!s)for(let t=0;s=`unnamed_${B.opType()}_${t}`,n.has(s);t++);if(n.has(s))throw new Error(`duplicated node name: ${s}`);const F=this._nodes.push(new Node(B,s))-1;n.set(s,F)}for(let n=0;n<this._nodes.length;n++){const B=this._nodes[n],s=t.nodes(n);if(null==s)throw new Error(`No node exists at index ${n}`);if(0===s?.outputsLength())throw new Error(`missing output for node: ${s.name}`);for(let t=0;t<s?.outputsLength();t++){const F=s?.outputs(t);let Q=e.get(F);if(void 0===Q&&(Q=this._allData.push(new Value)-1,e.set(F,Q)),B.outputs.push(Q),void 0!==this._allData[Q]._from)throw new Error(`multiple nodes output to one data value: ${Q}`);if(this._allData[Q]._from=n,"Constant"===s.opType()){if(1!==s.attributesLength()||!s.attributes(0).t())throw new Error("missing attributes or missing tensor value in attributes for this Constant operator");if(1!==s.outputsLength())throw new Error("missing output or incorrect number of outputs for this Constant operator");B.outputs.pop(),B.executeNode=!1,this._allData[Q]._from=-1,this._allData[Q].tensor=Tensor3.fromOrtTensor(s.attributes(0).t())}}}for(let n=0;n<this._nodes.length;n++){const B=this._nodes[n],s=t.nodes(n);if(0===s.inputsLength())throw new Error(`missing input for node: ${s.name}`);for(let t=0;t<s.inputsLength();t++){const F=s.inputs(t),Q=e.get(F);if(void 0===Q)throw new Error(`unrecognized input '${F}' for node: ${s.name()}`);B.inputs.push(Q),this._allData[Q]._to.push(n)}}}checkIsAcyclic(){const t=new Set;this._allInputIndices.forEach((e=>{this._allData[e]._to.forEach((e=>{t.add(e)}))}));const e=Array.from(t),n=new Array(this._nodes.length).fill("white");for(;e.length>0;){const t=e.pop();"gray"===n[t]?n[t]="black":(e.push(t),n[t]="gray",this._nodes[t].outputs.forEach((B=>{const s=this._allData[B];if(void 0!==s.tensor)throw new Error("node outputs should not be initialized");if(s._from!==t)throw new Error("from property of the Value object doesn't match index of Node being processed");s._to.forEach((t=>{if("gray"===n[t])throw new Error("model graph is cyclic");"white"===n[t]&&e.push(t)}))})))}}transformGraph(t){this.removeAllIdentityNodes(),this.removeAllDropoutNodes(),this.fuseConvActivationNodes(),t&&t.transformGraph(this),this.finalizeGraph()}finalizeGraph(){let t=0;const e=new Array(this._nodes.length,0);let n=0;for(let t=0;t<this._nodes.length;t++)e[t]=n,this._nodes[t].executeNode?(n!==t&&(this._nodes[n]=this._nodes[t]),n++):this._nodes[t].outputs.forEach((t=>{this._allData[t]._from=-2}));this._nodes.splice(n,this._nodes.length-n);for(let t=0;t<this._allData.length;t++){const n=this._allData[t];void 0!==n._from&&-1!==n._from&&-2!==n._from&&(n._from=e[n._from]);for(let t=0;t<n._to.length;t++){if(!(n._to[t]>=0))throw new Error("Trying to update a removed node");n._to[t]=e[n._to[t]]}}t=0;for(let e=0;e<this._allData.length;e++)if(-2!==this._allData[e].from||-1!==this._allOutputIndices.indexOf(e+t)){if(t>0){let n=-1;void 0!==this._allData[e].from&&-1!==this._allData[e].from?(n=this._nodes[this._allData[e].from].outputs.indexOf(e+t),-1!==n&&(this._nodes[this._allData[e].from].outputs[n]=e)):(n=this._allInputIndices.indexOf(e+t),-1!==n&&(this._allInputIndices[n]=e)),this._allData[e].to.forEach((B=>{n=this._nodes[B].inputs.indexOf(e+t),-1!==n&&(this._nodes[B].inputs[n]=e)})),0===this._allData[e].to.length&&(n=this._allOutputIndices.indexOf(e+t),-1!==n&&(this._allOutputIndices[n]=e))}}else t++,this._allData.splice(e,1),e--}deleteNode(t){const e=this._nodes[t];if(e.outputs.length>1)for(let t=1;t<e.outputs.length;t++)if(this._allData[e.outputs[t]].to.length>0)throw new Error("Node deletion with more than one output connected to other nodes is not supported. ");e.executeNode=!1;const n=e.inputs[0],B=e.outputs[0],s=this._allData[B].to;for(let n=0;n<e.inputs.length;n++){const B=this._allData[e.inputs[n]].to.indexOf(t);if(-1===B)throw new Error("The Value object doesn't have the current Node in it's 'to' property ");this._allData[e.inputs[n]].to.splice(B,1)}this._allData[B]._to=[];const F=this._allOutputIndices.indexOf(B);if(-1!==F&&(this._allOutputIndices[F]=n),s&&s.length>0)for(const t of s){const e=this._nodes[t].inputs.indexOf(B);if(-1===e)throw new Error("The Node object doesn't have the output Value in it's 'inputs' property ");this._nodes[t].inputs[e]=n,this._allData[n].to.push(t)}}removeAllDropoutNodes(){let t=0;for(const e of this._nodes){if("Dropout"===e.opType){if(1!==e.inputs.length)throw new Error("Dropout nodes should only contain one input. ");if(1!==e.outputs.length&&2!==e.outputs.length)throw new Error("Dropout nodes should contain either 1 or 2 output(s)");if(2===e.outputs.length&&0!==this._allData[e.outputs[1]]._to.length)throw new Error("Dropout nodes's second output should not be referenced by other nodes");this.deleteNode(t)}t++}}removeAllIdentityNodes(){let t=0;for(const e of this._nodes)"Identity"===e.opType&&this.deleteNode(t),t++}isActivation(t){switch(t.opType){case"Relu":case"Sigmoid":case"Clip":return!0;default:return!1}}fuseConvActivationNodes(){for(const t of this._nodes)if("Conv"===t.opType){const e=this._allData[t.outputs[0]]._to;if(1===e.length&&this.isActivation(this._nodes[e[0]])){const n=this._nodes[e[0]];if("Clip"===n.opType)if(1===n.inputs.length)try{t.attributes.set("activation_params","floats",[n.attributes.getFloat("min"),n.attributes.getFloat("max")])}catch(e){t.attributes.set("activation_params","floats",[MIN_CLIP,MAX_CLIP])}else{if(!(n.inputs.length>=3&&void 0!==this._allData[n.inputs[1]].tensor&&void 0!==this._allData[n.inputs[2]].tensor))continue;t.attributes.set("activation_params","floats",[this._allData[n.inputs[1]].tensor.floatData[0],this._allData[n.inputs[2]].tensor.floatData[0]])}t.attributes.set("activation","string",n.opType),this.deleteNode(e[0])}}}}}}),import_onnx5,ortFbs4,Model,init_model=__esm({"web/lib/onnxjs/model.ts"(){init_flatbuffers(),init_graph(),init_ort_generated(),import_onnx5=__toESM(require_onnx()),init_util(),ortFbs4=onnxruntime.experimental.fbs,Model=class{constructor(){}load(t,e,n){if(!n)try{return void this.loadFromOnnxFormat(t,e)}catch(t){if(void 0!==n)throw t}this.loadFromOrtFormat(t,e)}loadFromOnnxFormat(t,e){const n=import_onnx5.onnx.ModelProto.decode(t);if(LongUtil.longToNumber(n.irVersion)<3)throw new Error("only support ONNX model with IR_VERSION>=3");this._opsets=n.opsetImport.map((t=>({domain:t.domain,version:LongUtil.longToNumber(t.version)}))),this._graph=Graph.from(n.graph,e)}loadFromOrtFormat(t,e){const n=new flatbuffers.ByteBuffer(t),B=ortFbs4.InferenceSession.getRootAsInferenceSession(n).model();if(LongUtil.longToNumber(B.irVersion())<3)throw new Error("only support ONNX model with IR_VERSION>=3");this._opsets=[];for(let t=0;t<B.opsetImportLength();t++){const e=B.opsetImport(t);this._opsets.push({domain:e?.domain(),version:LongUtil.longToNumber(e.version())})}this._graph=Graph.from(B.graph(),e)}get graph(){return this._graph}get opsets(){return this._opsets}}}}),Session,init_session=__esm({"web/lib/onnxjs/session.ts"(){init_promises(),init_backend2(),init_execution_plan(),init_instrument(),init_model(),Session=class{constructor(t={}){this._initialized=!1,this.backendHint=t.backendHint,this.profiler=Profiler.create(t.profiler),this.context={profiler:this.profiler,graphInputTypes:[],graphInputDims:[]}}get inputNames(){return this._model.graph.getInputNames()}get outputNames(){return this._model.graph.getOutputNames()}startProfiling(){this.profiler.start()}endProfiling(){this.profiler.stop()}async loadModel(t,e,n){await this.profiler.event("session","Session.loadModel",(async()=>{const B=await resolveBackend2(this.backendHint);if(this.sessionHandler=B.createSessionHandler(this.context),this._model=new Model,"string"==typeof t){const e=t.endsWith(".ort");if("undefined"!=typeof process&&process.versions&&process.versions.node){const n=await readFile(t);this.initialize(n,e)}else{const n=await fetch(t),B=await n.arrayBuffer();this.initialize(new Uint8Array(B),e)}}else if(ArrayBuffer.isView(t))this.initialize(t);else{const B=new Uint8Array(t,e||0,n||t.byteLength);this.initialize(B)}}))}initialize(t,e){if(this._initialized)throw new Error("already initialized");this.profiler.event("session","Session.initialize",(()=>{const n=this.sessionHandler.transformGraph?this.sessionHandler:void 0;this._model.load(t,n,e),this.sessionHandler.onGraphInitialized&&this.sessionHandler.onGraphInitialized(this._model.graph),this.initializeOps(this._model.graph),this._executionPlan=new ExecutionPlan(this._model.graph,this._ops,this.profiler)})),this._initialized=!0}async run(t){if(!this._initialized)throw new Error("session not initialized yet");return this.profiler.event("session","Session.run",(async()=>{const e=this.normalizeAndValidateInputs(t),n=await this._executionPlan.execute(this.sessionHandler,e);return this.createOutput(n)}))}normalizeAndValidateInputs(t){const e=this._model.graph.getInputNames();if(Array.isArray(t)){if(t.length!==e.length)throw new Error(`incorrect input array length: expected ${e.length} but got ${t.length}`)}else{if(t.size!==e.length)throw new Error(`incorrect input map size: expected ${e.length} but got ${t.size}`);const n=new Array(t.size);let B=0;for(let s=0;s<e.length;++s){const F=t.get(e[s]);if(!F)throw new Error(`missing input tensor for: '${name}'`);n[B++]=F}t=n}if(this.context.graphInputTypes&&0!==this.context.graphInputTypes.length&&this.context.graphInputDims&&0!==this.context.graphInputDims.length)this.validateInputTensorDims(this.context.graphInputDims,t,!1);else{const e=this._model.graph.getInputIndices(),n=this._model.graph.getValues(),B=new Array(e.length);for(let s=0;s<e.length;++s){const F=n[e[s]];B[s]=F.type.shape.dims,this.context.graphInputTypes.push(F.type.tensorType),this.context.graphInputDims.push(t[s].dims)}this.validateInputTensorDims(B,t,!0)}return this.validateInputTensorTypes(this.context.graphInputTypes,t),t}validateInputTensorTypes(t,e){for(let n=0;n<e.length;n++){const B=t[n],s=e[n].type;if(B!==s)throw new Error(`input tensor[${n}] check failed: expected type '${B}' but got ${s}`)}}validateInputTensorDims(t,e,n){for(let B=0;B<e.length;B++){const s=t[B],F=e[B].dims;if(!this.compareTensorDims(s,F,n))throw new Error(`input tensor[${B}] check failed: expected shape '[${s.join(",")}]' but got [${F.join(",")}]`)}}compareTensorDims(t,e,n){if(t.length!==e.length)return!1;for(let B=0;B<t.length;++B)if(t[B]!==e[B]&&(!n||0!==t[B]))return!1;return!0}createOutput(t){const e=this._model.graph.getOutputNames();if(t.length!==e.length)throw new Error("expected number of outputs do not match number of generated outputs");const n=new Map;for(let B=0;B<e.length;++B)n.set(e[B],t[B]);return n}initializeOps(t){const e=t.getNodes();this._ops=new Array(e.length);for(let n=0;n<e.length;n++)this._ops[n]=this.sessionHandler.resolve(e[n],this._model.opsets,t)}}}}),OnnxjsSessionHandler,init_session_handler_inference=__esm({"web/lib/onnxjs/session-handler-inference.ts"(){init_esm(),init_tensor2(),OnnxjsSessionHandler=class{constructor(t){this.session=t,this.inputNames=this.session.inputNames,this.outputNames=this.session.outputNames}async dispose(){}async run(t,e,n){const B=new Map;for(const e in t)if(Object.hasOwnProperty.call(t,e)){const n=t[e];B.set(e,new Tensor3(n.dims,n.type,void 0,void 0,n.data))}const s=await this.session.run(B),F={};return s.forEach(((t,e)=>{F[e]=new Tensor2(t.type,t.data,t.dims)})),F}startProfiling(){this.session.startProfiling()}endProfiling(){this.session.endProfiling()}}}}),backend_onnxjs_exports={},OnnxjsBackend,onnxjsBackend;__export(backend_onnxjs_exports,{onnxjsBackend:()=>onnxjsBackend});var init_backend_onnxjs=__esm({"web/lib/backend-onnxjs.ts"(){init_session(),init_session_handler_inference(),onnxjsBackend=new(OnnxjsBackend=class{async init(){}async createInferenceSessionHandler(t,e){const n=new Session(e);return await n.loadModel(t),new OnnxjsSessionHandler(n)}})}}),cpus,init_node_os=__esm({"nodejs-ignore:node:os"(){cpus=void 0}}),join,init_node_path=__esm({"nodejs-ignore:node:path"(){join=void 0}}),fs_exports={},readFile2,readFileSync,createReadStream;__export(fs_exports,{createReadStream:()=>createReadStream,readFile:()=>readFile2,readFileSync:()=>readFileSync});var init_fs=__esm({"nodejs-ignore:fs"(){readFile2=void 0,readFileSync=void 0,createReadStream=void 0}}),path_exports={},join2;__export(path_exports,{join:()=>join2});var init_path=__esm({"nodejs-ignore:path"(){join2=void 0}}),require_ort_wasm_simd_jsep=__commonJS({"web/lib/wasm/binding/ort-wasm-simd.jsep.js"(t,e){var n,B=(n="undefined"!=typeof document&&document.currentScript?document.currentScript.src:void 0,"undefined"!=typeof __filename&&(n=n||__filename),function(t={}){var e,B,s=t;s.ready=new Promise(((t,n)=>{e=t,B=n})),s.mountExternalData=(t,e)=>{(s.Fa||(s.Fa=new Map)).set(t,e)},s.unmountExternalData=()=>{delete s.Fa},s.jsepInit=(t,e,n,B,F,Q,U,i)=>{s.ab=t,s.Qa=e,s.Sa=n,s.La=B,s.Ra=F,s.sa=Q,s.Ta=U,s.Ua=i,e=(t,e,n)=>(...B)=>{const s=gt,F=e?.();B=t(...B);const Q=e?.();return F!==Q&&(t=Q,n(F),e=n=null),gt!=s?new Promise(((t,e)=>{bt={resolve:t,reject:e}})):B},n=e=>async(...n)=>{try{if(s.Ea)throw Error("Session already started");const B=s.Ea={Va:n[0],errors:[]},F=await e(...n);if(s.Ea!==B)throw Error("Session mismatch");t.flush();const Q=B.errors;if(0<Q.length){let t=await Promise.all(Q);if(t=t.filter((t=>t)),0<t.length)throw Error(t.join("\n"))}return F}finally{s.Ea=null}},s._OrtRun=n(e(s._OrtRun,(()=>s._OrtRun),(t=>s._OrtRun=t))),s._OrtRunWithBinding=n(e(s._OrtRunWithBinding,(()=>s._OrtRunWithBinding),(t=>s._OrtRunWithBinding=t))),s._OrtBindInput=e(s._OrtBindInput,(()=>s._OrtBindInput),(t=>s._OrtBindInput=t)),s.jsepRegisterBuffer=(e,n,B,s)=>t.registerBuffer(e,n,B,s),s.jsepUnregisterBuffers=e=>{t.unregisterBuffers(e)},s.jsepGetBuffer=e=>t.getBuffer(e),s.jsepCreateDownloader=(e,n,B)=>t.createDownloader(e,n,B)};var F,Q,U,i=Object.assign({},s),a="./this.program",l=(t,e)=>{throw e},c="object"==typeof window,g="function"==typeof importScripts,d="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node,I="";if(d){var o=(init_fs(),__toCommonJS(fs_exports)),r=(init_path(),__toCommonJS(path_exports));I=g?r.dirname(I)+"/":__dirname+"/",F=(t,e)=>(t=H(t)?new URL(t):r.normalize(t),o.readFileSync(t,e?void 0:"utf8")),U=t=>((t=F(t,!0)).buffer||(t=new Uint8Array(t)),t),Q=(t,e,n,B=!0)=>{t=H(t)?new URL(t):r.normalize(t),o.readFile(t,B?void 0:"utf8",((t,s)=>{t?n(t):e(B?s.buffer:s)}))},!s.thisProgram&&1<process.argv.length&&(a=process.argv[1].replace(/\\/g,"/")),process.argv.slice(2),l=(t,e)=>{throw process.exitCode=t,e},s.inspect=()=>"[Emscripten Module object]"}else(c||g)&&(g?I=self.location.href:"undefined"!=typeof document&&document.currentScript&&(I=document.currentScript.src),n&&(I=n),I=0!==I.indexOf("blob:")?I.substr(0,I.replace(/[?#].*/,"").lastIndexOf("/")+1):"",F=t=>{var e=new XMLHttpRequest;return e.open("GET",t,!1),e.send(null),e.responseText},g&&(U=t=>{var e=new XMLHttpRequest;return e.open("GET",t,!1),e.responseType="arraybuffer",e.send(null),new Uint8Array(e.response)}),Q=(t,e,n)=>{var B=new XMLHttpRequest;B.open("GET",t,!0),B.responseType="arraybuffer",B.onload=()=>{200==B.status||0==B.status&&B.response?e(B.response):n()},B.onerror=n,B.send(null)});var u=console.log.bind(console),b=console.error.bind(console);Object.assign(s,i),i=null,"object"!=typeof WebAssembly&&E("no native wasm support detected");var C,p,m,G,V,x,h,Z,S=!1;function y(){var t=C.buffer;s.HEAP8=m=new Int8Array(t),s.HEAP16=new Int16Array(t),s.HEAPU8=G=new Uint8Array(t),s.HEAPU16=new Uint16Array(t),s.HEAP32=V=new Int32Array(t),s.HEAPU32=x=new Uint32Array(t),s.HEAPF32=h=new Float32Array(t),s.HEAPF64=Z=new Float64Array(t)}var A=[],X=[],R=[],L=0,W=null,N=null;function E(t){throw b(t="Aborted("+t+")"),S=!0,p=1,t=new WebAssembly.RuntimeError(t+". Build with -sASSERTIONS for more info."),B(t),t}var T,Y=t=>t.startsWith("data:application/octet-stream;base64,"),H=t=>t.startsWith("file://");if(!Y(T="ort-wasm-simd.wasm")){var J=T;T=s.locateFile?s.locateFile(J,I):I+J}function f(t){if(U)return U(t);throw"both async and sync fetching of the wasm failed"}function k(t,e,n){return function(t){if(c||g){if("function"==typeof fetch&&!H(t))return fetch(t,{credentials:"same-origin"}).then((e=>{if(!e.ok)throw"failed to load wasm binary file at '"+t+"'";return e.arrayBuffer()})).catch((()=>f(t)));if(Q)return new Promise(((e,n)=>{Q(t,(t=>e(new Uint8Array(t))),n)}))}return Promise.resolve().then((()=>f(t)))}(t).then((t=>WebAssembly.instantiate(t,e))).then((t=>t)).then(n,(t=>{b(`failed to asynchronously prepare wasm: ${t}`),E(t)}))}var w,v={931056:(t,e,n,B)=>{if(void 0===s||!s.Fa)return 1;if((t=j(t>>>0)).startsWith("./")&&(t=t.substring(2)),!(t=s.Fa.get(t)))return 2;if((e>>>=0)+(n>>>=0)>t.byteLength)return 3;try{return G.set(t.subarray(e,e+n),B>>>0>>>0),0}catch{return 4}},931557:t=>s.Qa(t),931590:t=>s.Sa(t),931622:(t,e,n)=>{s.La(t,e,n,!0)},931661:(t,e,n)=>{s.La(t,e,n)},931694:t=>{s.sa("Abs",t,void 0)},931745:t=>{s.sa("Neg",t,void 0)},931796:t=>{s.sa("Floor",t,void 0)},931849:t=>{s.sa("Ceil",t,void 0)},931901:t=>{s.sa("Reciprocal",t,void 0)},931959:t=>{s.sa("Sqrt",t,void 0)},932011:t=>{s.sa("Exp",t,void 0)},932062:t=>{s.sa("Erf",t,void 0)},932113:t=>{s.sa("Sigmoid",t,void 0)},932168:t=>{s.sa("Log",t,void 0)},932219:t=>{s.sa("Sin",t,void 0)},932270:t=>{s.sa("Cos",t,void 0)},932321:t=>{s.sa("Tan",t,void 0)},932372:t=>{s.sa("Asin",t,void 0)},932424:t=>{s.sa("Acos",t,void 0)},932476:t=>{s.sa("Atan",t,void 0)},932528:t=>{s.sa("Sinh",t,void 0)},932580:t=>{s.sa("Cosh",t,void 0)},932632:t=>{s.sa("Asinh",t,void 0)},932685:t=>{s.sa("Acosh",t,void 0)},932738:t=>{s.sa("Atanh",t,void 0)},932791:t=>{s.sa("Tanh",t,void 0)},932843:t=>{s.sa("Not",t,void 0)},932894:(t,e,n)=>{s.sa("Clip",t,{min:e,max:n})},932963:t=>{s.sa("Clip",t,void 0)},933015:(t,e)=>{s.sa("Elu",t,{alpha:e})},933073:t=>{s.sa("Relu",t,void 0)},933125:(t,e)=>{s.sa("LeakyRelu",t,{alpha:e})},933189:(t,e)=>{s.sa("ThresholdedRelu",t,{alpha:e})},933259:(t,e)=>{s.sa("Cast",t,{to:e})},933317:t=>{s.sa("Add",t,void 0)},933368:t=>{s.sa("Sub",t,void 0)},933419:t=>{s.sa("Mul",t,void 0)},933470:t=>{s.sa("Div",t,void 0)},933521:t=>{s.sa("Pow",t,void 0)},933572:t=>{s.sa("Equal",t,void 0)},933625:t=>{s.sa("Greater",t,void 0)},933680:t=>{s.sa("GreaterOrEqual",t,void 0)},933742:t=>{s.sa("Less",t,void 0)},933794:t=>{s.sa("LessOrEqual",t,void 0)},933853:(t,e,n,B,F)=>{s.sa("ReduceMean",t,{keepDims:!!e,noopWithEmptyAxes:!!n,axes:B?Array.from(V.subarray(B>>>0,F>>>0)):[]})},934012:(t,e,n,B,F)=>{s.sa("ReduceMax",t,{keepDims:!!e,noopWithEmptyAxes:!!n,axes:B?Array.from(V.subarray(B>>>0,F>>>0)):[]})},934170:(t,e,n,B,F)=>{s.sa("ReduceMin",t,{keepDims:!!e,noopWithEmptyAxes:!!n,axes:B?Array.from(V.subarray(B>>>0,F>>>0)):[]})},934328:(t,e,n,B,F)=>{s.sa("ReduceProd",t,{keepDims:!!e,noopWithEmptyAxes:!!n,axes:B?Array.from(V.subarray(B>>>0,F>>>0)):[]})},934487:(t,e,n,B,F)=>{s.sa("ReduceSum",t,{keepDims:!!e,noopWithEmptyAxes:!!n,axes:B?Array.from(V.subarray(B>>>0,F>>>0)):[]})},934645:(t,e,n,B,F)=>{s.sa("ReduceL1",t,{keepDims:!!e,noopWithEmptyAxes:!!n,axes:B?Array.from(V.subarray(B>>>0,F>>>0)):[]})},934802:(t,e,n,B,F)=>{s.sa("ReduceL2",t,{keepDims:!!e,noopWithEmptyAxes:!!n,axes:B?Array.from(V.subarray(B>>>0,F>>>0)):[]})},934959:(t,e,n,B,F)=>{s.sa("ReduceLogSum",t,{keepDims:!!e,noopWithEmptyAxes:!!n,axes:B?Array.from(V.subarray(B>>>0,F>>>0)):[]})},935120:(t,e,n,B,F)=>{s.sa("ReduceSumSquare",t,{keepDims:!!e,noopWithEmptyAxes:!!n,axes:B?Array.from(V.subarray(B>>>0,F>>>0)):[]})},935284:(t,e,n,B,F)=>{s.sa("ReduceLogSumExp",t,{keepDims:!!e,noopWithEmptyAxes:!!n,axes:B?Array.from(V.subarray(B>>>0,F>>>0)):[]})},935448:t=>{s.sa("Where",t,void 0)},935501:(t,e,n)=>{s.sa("Transpose",t,{perm:e?Array.from(V.subarray(e>>>0,n>>>0)):[]})},935609:(t,e,n,B,F,Q,U,i,a,l,c,g,d,I,o)=>{s.sa("ConvTranspose",t,{format:a?"NHWC":"NCHW",autoPad:e,dilations:[n],group:B,kernel_shape:[F],pads:[Q,U],strides:[i],wIsConst:()=>!!m[l>>>0],outputPadding:c?Array.from(V.subarray(c>>>0,g>>>0)):[],outputShape:d?Array.from(V.subarray(d>>>0,I>>>0)):[],activation:j(o)})},936011:(t,e,n,B,F,Q,U,i,a,l,c,g,d,I)=>{s.sa("ConvTranspose",t,{format:i?"NHWC":"NCHW",autoPad:e,dilations:Array.from(V.subarray(n>>>0,2+(n>>>0)>>>0)),group:B,kernelShape:Array.from(V.subarray(F>>>0,2+(F>>>0)>>>0)),pads:Array.from(V.subarray(Q>>>0,4+(Q>>>0)>>>0)),strides:Array.from(V.subarray(U>>>0,2+(U>>>0)>>>0)),wIsConst:()=>!!m[a>>>0],outputPadding:l?Array.from(V.subarray(l>>>0,c>>>0)):[],outputShape:g?Array.from(V.subarray(g>>>0,d>>>0)):[],activation:j(I)})},936576:(t,e,n,B,F,Q,U,i,a,l,c,g,d,I,o)=>{s.sa("ConvTranspose",t,{format:a?"NHWC":"NCHW",autoPad:e,dilations:[n],group:B,kernel_shape:[F],pads:[Q,U],strides:[i],wIsConst:()=>!!m[l>>>0],outputPadding:c?Array.from(V.subarray(c>>>0,g>>>0)):[],outputShape:d?Array.from(V.subarray(d>>>0,I>>>0)):[],activation:j(o)})},936978:(t,e,n,B,F,Q,U,i,a,l,c,g,d,I)=>{s.sa("ConvTranspose",t,{format:i?"NHWC":"NCHW",autoPad:e,dilations:Array.from(V.subarray(n>>>0,2+(n>>>0)>>>0)),group:B,kernelShape:Array.from(V.subarray(F>>>0,2+(F>>>0)>>>0)),pads:Array.from(V.subarray(Q>>>0,4+(Q>>>0)>>>0)),strides:Array.from(V.subarray(U>>>0,2+(U>>>0)>>>0)),wIsConst:()=>!!m[a>>>0],outputPadding:l?Array.from(V.subarray(l>>>0,c>>>0)):[],outputShape:g?Array.from(V.subarray(g>>>0,d>>>0)):[],activation:j(I)})},937543:(t,e)=>{s.sa("GlobalAveragePool",t,{format:e?"NHWC":"NCHW"})},937634:(t,e,n,B,F,Q,U,i,a,l,c,g,d,I,o,r)=>{s.sa("AveragePool",t,{format:r?"NHWC":"NCHW",auto_pad:e,ceil_mode:n,count_include_pad:B,storage_order:F,dilations:[Q,U],kernel_shape:[i,a],pads:[l,c,g,d],strides:[I,o]})},937918:(t,e)=>{s.sa("GlobalAveragePool",t,{format:e?"NHWC":"NCHW"})},938009:(t,e,n,B,F,Q,U,i,a,l,c,g,d,I,o,r)=>{s.sa("AveragePool",t,{format:r?"NHWC":"NCHW",auto_pad:e,ceil_mode:n,count_include_pad:B,storage_order:F,dilations:[Q,U],kernel_shape:[i,a],pads:[l,c,g,d],strides:[I,o]})},938293:(t,e)=>{s.sa("GlobalMaxPool",t,{format:e?"NHWC":"NCHW"})},938380:(t,e,n,B,F,Q,U,i,a,l,c,g,d,I,o,r)=>{s.sa("MaxPool",t,{format:r?"NHWC":"NCHW",auto_pad:e,ceil_mode:n,count_include_pad:B,storage_order:F,dilations:[Q,U],kernel_shape:[i,a],pads:[l,c,g,d],strides:[I,o]})},938660:(t,e)=>{s.sa("GlobalMaxPool",t,{format:e?"NHWC":"NCHW"})},938747:(t,e,n,B,F,Q,U,i,a,l,c,g,d,I,o,r)=>{s.sa("MaxPool",t,{format:r?"NHWC":"NCHW",auto_pad:e,ceil_mode:n,count_include_pad:B,storage_order:F,dilations:[Q,U],kernel_shape:[i,a],pads:[l,c,g,d],strides:[I,o]})},939027:(t,e,n,B,F)=>{s.sa("Gemm",t,{alpha:e,beta:n,transA:B,transB:F})},939131:t=>{s.sa("MatMul",t,void 0)},939185:(t,e,n,B)=>{s.sa("ArgMax",t,{keepDims:!!e,selectLastIndex:!!n,axis:B})},939293:(t,e,n,B)=>{s.sa("ArgMin",t,{keepDims:!!e,selectLastIndex:!!n,axis:B})},939401:(t,e)=>{s.sa("Softmax",t,{axis:e})},939464:(t,e)=>{s.sa("Concat",t,{axis:e})},939524:(t,e,n,B,F)=>{s.sa("Split",t,{axis:e,numOutputs:n,splitSizes:B?Array.from(V.subarray(B>>>0,F>>>0)):[]})},939664:t=>{s.sa("Expand",t,void 0)},939718:(t,e)=>{s.sa("Gather",t,{axis:Number(e)})},939789:(t,e)=>{s.sa("GatherElements",t,{axis:Number(e)})},939868:(t,e,n,B,F,Q,U,i,a,l,c)=>{s.sa("Resize",t,{antialias:e,axes:n?Array.from(V.subarray(n>>>0,B>>>0)):[],coordinateTransformMode:j(F),cubicCoeffA:Q,excludeOutside:U,extrapolationValue:i,keepAspectRatioPolicy:j(a),mode:j(l),nearestMode:j(c)})},940214:(t,e,n,B,F,Q,U)=>{s.sa("Slice",t,{starts:e?Array.from(V.subarray(e>>>0,n>>>0)):[],ends:B?Array.from(V.subarray(B>>>0,F>>>0)):[],axes:Q?Array.from(V.subarray(Q>>>0,U>>>0)):[]})},940430:t=>{s.sa("Tile",t,void 0)},940482:(t,e,n)=>{s.sa("LayerNormalization",t,{axis:Number(e),epsilon:Number(n)})},940589:(t,e,n)=>{s.sa("InstanceNormalization",t,{epsilon:e,format:n?"NHWC":"NCHW"})},940703:(t,e,n)=>{s.sa("InstanceNormalization",t,{epsilon:e,format:n?"NHWC":"NCHW"})},940817:t=>{s.sa("Range",t,void 0)},940870:(t,e)=>{s.sa("Einsum",t,{equation:j(e)})},940951:(t,e,n,B,F)=>{s.sa("Pad",t,{mode:e,value:n,pads:B?Array.from(V.subarray(B>>>0,F>>>0)):[]})},941078:(t,e,n,B,F,Q)=>{s.sa("BatchNormalization",t,{epsilon:e,momentum:n,spatial:!!F,trainingMode:!!B,format:Q?"NHWC":"NCHW"})},941247:(t,e,n,B,F,Q)=>{s.sa("BatchNormalization",t,{epsilon:e,momentum:n,spatial:!!F,trainingMode:!!B,format:Q?"NHWC":"NCHW"})},941416:(t,e,n)=>{s.sa("CumSum",t,{exclusive:Number(e),reverse:Number(n)})},941513:(t,e,n,B,F,Q,U,i,a)=>{s.sa("Attention",t,{numHeads:e,isUnidirectional:n,maskFilterValue:B,scale:F,doRotary:Q,qkvHiddenSizes:U?Array.from(V.subarray(Number(i)>>>0,Number(i)+U>>>0)):[],pastPresentShareBuffer:!!a})},941785:t=>{s.sa("Gelu",t,void 0)},941837:(t,e,n,B,F,Q)=>{s.sa("MultiHeadAttention",t,{numHeads:e,isUnidirectional:n,maskFilterValue:B,scale:F,doRotary:Q})},941996:t=>{s.sa("BiasAdd",t,void 0)},942051:t=>{s.sa("BiasSplitGelu",t,void 0)},942112:(t,e)=>{s.sa("SkipLayerNormalization",t,{epsilon:e})},942193:(t,e,n,B,F,Q,U,i,a,l,c,g,d)=>{s.sa("Conv",t,{format:a?"NHWC":"NCHW",auto_pad:e,dilations:[n],group:B,kernel_shape:[F],pads:Q?Array.from(V.subarray(Q>>>0,U>>>0)):[],strides:[i],w_is_const:()=>!!m[l>>>0],activation:j(c),activation_params:g?Array.from(h.subarray(g>>>0,d>>>0)):[]})},942563:(t,e,n,B,F,Q,U,i,a,l,c,g,d,I,o,r)=>{s.sa("Conv",t,{format:g?"NHWC":"NCHW",auto_pad:e,dilations:[n,B],group:F,kernel_shape:[Q,U],pads:i?Array.from(V.subarray(i>>>0,a>>>0)):[],strides:[l,c],w_is_const:()=>!!m[d>>>0],activation:j(I),activation_params:o?Array.from(h.subarray(o>>>0,r>>>0)):[]})},942954:t=>{s.Ta(t)},942988:(t,e)=>s.Ua(t,e,s.Ea.Va,s.Ea.errors)};function z(t){this.name="ExitStatus",this.message=`Program terminated with exit(${t})`,this.status=t}function D(t){this.Ja=t-24,this.Oa=function(t){x[this.Ja+4>>>2>>>0]=t},this.Na=function(t){x[this.Ja+8>>>2>>>0]=t},this.$a=function(t,e){this.Ma(),this.Oa(t),this.Na(e)},this.Ma=function(){x[this.Ja+16>>>2>>>0]=0}}var M,O="undefined"!=typeof TextDecoder?new TextDecoder("utf8"):void 0,P=(t,e,n)=>{var B=(e>>>=0)+n;for(n=e;t[n]&&!(n>=B);)++n;if(16<n-e&&t.buffer&&O)return O.decode(t.subarray(e,n));for(B="";e<n;){var s=t[e++];if(128&s){var F=63&t[e++];if(192==(224&s))B+=String.fromCharCode((31&s)<<6|F);else{var Q=63&t[e++];65536>(s=224==(240&s)?(15&s)<<12|F<<6|Q:(7&s)<<18|F<<12|Q<<6|63&t[e++])?B+=String.fromCharCode(s):(s-=65536,B+=String.fromCharCode(55296|s>>10,56320|1023&s))}}else B+=String.fromCharCode(s)}return B},j=(t,e)=>(t>>>=0)?P(G,t,e):"",_=t=>{for(var e=0,n=0;n<t.length;++n){var B=t.charCodeAt(n);127>=B?e++:2047>=B?e+=2:55296<=B&&57343>=B?(e+=4,++n):e+=3}return e},K=(t,e,n,B)=>{if(!(0<B))return 0;var s=n>>>=0;B=n+B-1;for(var F=0;F<t.length;++F){var Q=t.charCodeAt(F);if(55296<=Q&&57343>=Q&&(Q=65536+((1023&Q)<<10)|1023&t.charCodeAt(++F)),127>=Q){if(n>=B)break;e[n++>>>0]=Q}else{if(2047>=Q){if(n+1>=B)break;e[n++>>>0]=192|Q>>6}else{if(65535>=Q){if(n+2>=B)break;e[n++>>>0]=224|Q>>12}else{if(n+3>=B)break;e[n++>>>0]=240|Q>>18,e[n++>>>0]=128|Q>>12&63}e[n++>>>0]=128|Q>>6&63}e[n++>>>0]=128|63&Q}}return e[n>>>0]=0,n-s},$=t=>0==t%4&&(0!=t%100||0==t%400),q=[0,31,60,91,121,152,182,213,244,274,305,335],tt=[0,31,59,90,120,151,181,212,243,273,304,334],et=t=>{var e=_(t)+1,n=ht(e);return n&&K(t,G,n,e),n},nt=[],Bt=(t,e)=>{nt.length=0;for(var n;n=G[t++>>>0];){var B=105!=n;e+=(B&=112!=n)&&e%8?4:0,nt.push(112==n?x[e>>>2>>>0]:105==n?V[e>>>2>>>0]:Z[e>>>3>>>0]),e+=B?8:4}return nt},st={},Ft=()=>{if(!M){var t,e={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:("object"==typeof navigator&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:a||"./this.program"};for(t in st)void 0===st[t]?delete e[t]:e[t]=st[t];var n=[];for(t in e)n.push(`${t}=${e[t]}`);M=n}return M},Qt=[null,[],[]],Ut=[31,29,31,30,31,30,31,31,30,31,30,31],it=[31,28,31,30,31,30,31,31,30,31,30,31];function at(t,e,n,B){function s(t,e,n){for(t="number"==typeof t?t.toString():t||"";t.length<e;)t=n[0]+t;return t}function F(t,e){return s(t,e,"0")}function Q(t,e){function n(t){return 0>t?-1:0<t?1:0}var B;return 0===(B=n(t.getFullYear()-e.getFullYear()))&&0===(B=n(t.getMonth()-e.getMonth()))&&(B=n(t.getDate()-e.getDate())),B}function U(t){switch(t.getDay()){case 0:return new Date(t.getFullYear()-1,11,29);case 1:return t;case 2:return new Date(t.getFullYear(),0,3);case 3:return new Date(t.getFullYear(),0,2);case 4:return new Date(t.getFullYear(),0,1);case 5:return new Date(t.getFullYear()-1,11,31);case 6:return new Date(t.getFullYear()-1,11,30)}}function i(t){var e=t.Ca;for(t=new Date(new Date(t.Da+1900,0,1).getTime());0<e;){var n=t.getMonth(),B=($(t.getFullYear())?Ut:it)[n];if(!(e>B-t.getDate())){t.setDate(t.getDate()+e);break}e-=B-t.getDate()+1,t.setDate(1),11>n?t.setMonth(n+1):(t.setMonth(0),t.setFullYear(t.getFullYear()+1))}return n=new Date(t.getFullYear()+1,0,4),e=U(new Date(t.getFullYear(),0,4)),n=U(n),0>=Q(e,t)?0>=Q(n,t)?t.getFullYear()+1:t.getFullYear():t.getFullYear()-1}t>>>=0,e>>>=0,n>>>=0;var a=x[40+(B>>>=0)>>>2>>>0];for(var l in B={Ya:V[B>>>2>>>0],Xa:V[B+4>>>2>>>0],Ga:V[B+8>>>2>>>0],Ka:V[B+12>>>2>>>0],Ha:V[B+16>>>2>>>0],Da:V[B+20>>>2>>>0],xa:V[B+24>>>2>>>0],Ca:V[B+28>>>2>>>0],bb:V[B+32>>>2>>>0],Wa:V[B+36>>>2>>>0],Za:a?j(a):""},n=j(n),a={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"})n=n.replace(new RegExp(l,"g"),a[l]);var c="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),g="January February March April May June July August September October November December".split(" ");for(l in a={"%a":t=>c[t.xa].substring(0,3),"%A":t=>c[t.xa],"%b":t=>g[t.Ha].substring(0,3),"%B":t=>g[t.Ha],"%C":t=>F((t.Da+1900)/100|0,2),"%d":t=>F(t.Ka,2),"%e":t=>s(t.Ka,2," "),"%g":t=>i(t).toString().substring(2),"%G":t=>i(t),"%H":t=>F(t.Ga,2),"%I":t=>(0==(t=t.Ga)?t=12:12<t&&(t-=12),F(t,2)),"%j":t=>{for(var e=0,n=0;n<=t.Ha-1;e+=($(t.Da+1900)?Ut:it)[n++]);return F(t.Ka+e,3)},"%m":t=>F(t.Ha+1,2),"%M":t=>F(t.Xa,2),"%n":()=>"\n","%p":t=>0<=t.Ga&&12>t.Ga?"AM":"PM","%S":t=>F(t.Ya,2),"%t":()=>"\t","%u":t=>t.xa||7,"%U":t=>F(Math.floor((t.Ca+7-t.xa)/7),2),"%V":t=>{var e=Math.floor((t.Ca+7-(t.xa+6)%7)/7);if(2>=(t.xa+371-t.Ca-2)%7&&e++,e)53==e&&(4==(n=(t.xa+371-t.Ca)%7)||3==n&&$(t.Da)||(e=1));else{e=52;var n=(t.xa+7-t.Ca-1)%7;(4==n||5==n&&$(t.Da%400-1))&&e++}return F(e,2)},"%w":t=>t.xa,"%W":t=>F(Math.floor((t.Ca+7-(t.xa+6)%7)/7),2),"%y":t=>(t.Da+1900).toString().substring(2),"%Y":t=>t.Da+1900,"%z":t=>{var e=0<=(t=t.Wa);return t=Math.abs(t)/60,(e?"+":"-")+String("0000"+(t/60*100+t%60)).slice(-4)},"%Z":t=>t.Za,"%%":()=>"%"},n=n.replace(/%%/g,"\0\0"),a)n.includes(l)&&(n=n.replace(new RegExp(l,"g"),a[l](B)));return l=function(t){var e=Array(_(t)+1);return K(t,e,0,e.length),e}(n=n.replace(/\0\0/g,"%")),l.length>e?0:(m.set(l,t>>>0),l.length-1)}var lt=t=>{try{t()}catch(t){E(t)}},ct=0,gt=null,dt=0,It=[],ot={},rt={},ut=0,bt=null,Ct=[];function pt(t){if(!S){if(0===ct){var e=!1,n=!1;t(((t=0)=>{if(!S&&(dt=t,e=!0,n)){ct=2,lt((()=>Wt(gt))),"undefined"!=typeof Browser&&Browser.Ia.Pa&&Browser.Ia.resume(),t=!1;try{var B=(0,Gt[rt[V[gt+8>>>2>>>0]]])()}catch(e){B=e,t=!0}var s=!1;if(!gt){var F=bt;F&&(bt=null,(t?F.reject:F.resolve)(B),s=!0)}if(t&&!s)throw B}})),n=!0,e||(ct=1,gt=function(){var t=ht(65548),e=t+12;x[t>>>2>>>0]=e,x[t+4>>>2>>>0]=e+65536,e=It[0];var n=ot[e];return void 0===n&&(n=ut++,ot[e]=n,rt[n]=e),V[t+8>>>2>>>0]=n,t}(),"undefined"!=typeof Browser&&Browser.Ia.Pa&&Browser.Ia.pause(),lt((()=>Rt(gt))))}else 2===ct?(ct=0,lt(Nt),Zt(gt),gt=null,Ct.forEach((t=>{if(!S)try{t();try{p=p=t=p,s.onExit?.(t),S=!0,l(t,new z(t))}catch(t){t instanceof z||"unwind"==t||l(1,t)}}catch(t){t instanceof z||"unwind"==t||l(1,t)}}))):E(`invalid state: ${ct}`);return dt}}var mt={n:function(t,e,n){return function(t){return pt((e=>{t().then(e)}))}((async()=>{await s.Ra(t,e,n)}))},a:function(t,e,n){throw new D(t>>>=0).$a(e>>>0,n>>>0),t},g:function(){return 0},J:function(){},A:function(){},C:function(){},L:function(){return 0},H:function(){},D:function(){},G:function(){},l:function(){},B:function(){},y:function(){},I:function(){},z:function(){},m:()=>1,q:function(t,e,n){t=e+2097152>>>0<4194305-!!t?(t>>>0)+4294967296*e:NaN,n>>>=0,t=new Date(1e3*t),V[n>>>2>>>0]=t.getUTCSeconds(),V[n+4>>>2>>>0]=t.getUTCMinutes(),V[n+8>>>2>>>0]=t.getUTCHours(),V[n+12>>>2>>>0]=t.getUTCDate(),V[n+16>>>2>>>0]=t.getUTCMonth(),V[n+20>>>2>>>0]=t.getUTCFullYear()-1900,V[n+24>>>2>>>0]=t.getUTCDay(),V[n+28>>>2>>>0]=(t.getTime()-Date.UTC(t.getUTCFullYear(),0,1,0,0,0,0))/864e5|0},r:function(t,e,n){t=e+2097152>>>0<4194305-!!t?(t>>>0)+4294967296*e:NaN,n>>>=0,t=new Date(1e3*t),V[n>>>2>>>0]=t.getSeconds(),V[n+4>>>2>>>0]=t.getMinutes(),V[n+8>>>2>>>0]=t.getHours(),V[n+12>>>2>>>0]=t.getDate(),V[n+16>>>2>>>0]=t.getMonth(),V[n+20>>>2>>>0]=t.getFullYear()-1900,V[n+24>>>2>>>0]=t.getDay(),V[n+28>>>2>>>0]=($(t.getFullYear())?q:tt)[t.getMonth()]+t.getDate()-1|0,V[n+36>>>2>>>0]=-60*t.getTimezoneOffset(),e=new Date(t.getFullYear(),6,1).getTimezoneOffset();var B=new Date(t.getFullYear(),0,1).getTimezoneOffset();V[n+32>>>2>>>0]=0|(e!=B&&t.getTimezoneOffset()==Math.min(B,e))},s:function(t){t>>>=0;var e=new Date(V[t+20>>>2>>>0]+1900,V[t+16>>>2>>>0],V[t+12>>>2>>>0],V[t+8>>>2>>>0],V[t+4>>>2>>>0],V[t>>>2>>>0],0),n=V[t+32>>>2>>>0],B=e.getTimezoneOffset(),s=new Date(e.getFullYear(),6,1).getTimezoneOffset(),F=new Date(e.getFullYear(),0,1).getTimezoneOffset(),Q=Math.min(F,s);return 0>n?V[t+32>>>2>>>0]=Number(s!=F&&Q==B):0<n!=(Q==B)&&(s=Math.max(F,s),e.setTime(e.getTime()+6e4*((0<n?Q:s)-B))),V[t+24>>>2>>>0]=e.getDay(),V[t+28>>>2>>>0]=($(e.getFullYear())?q:tt)[e.getMonth()]+e.getDate()-1|0,V[t>>>2>>>0]=e.getSeconds(),V[t+4>>>2>>>0]=e.getMinutes(),V[t+8>>>2>>>0]=e.getHours(),V[t+12>>>2>>>0]=e.getDate(),V[t+16>>>2>>>0]=e.getMonth(),V[t+20>>>2>>>0]=e.getYear(),t=e.getTime(),isNaN(t)?(V[xt()>>>2>>>0]=61,t=-1):t/=1e3,St((w=t,1<=+Math.abs(w)?0<w?+Math.floor(w/4294967296)>>>0:~~+Math.ceil((w-+(~~w>>>0))/4294967296)>>>0:0)),t>>>0},o:function(){return-52},p:function(){},w:function(t,e,n){function B(t){return(t=t.toTimeString().match(/\(([A-Za-z ]+)\)$/))?t[1]:"GMT"}n>>>=0;var s=(new Date).getFullYear(),F=new Date(s,0,1),Q=new Date(s,6,1);s=F.getTimezoneOffset();var U=Q.getTimezoneOffset();x[t>>>0>>>2>>>0]=60*Math.max(s,U),V[e>>>0>>>2>>>0]=Number(s!=U),t=B(F),e=B(Q),t=et(t),e=et(e),U<s?(x[n>>>2>>>0]=t,x[n+4>>>2>>>0]=e):(x[n>>>2>>>0]=e,x[n+4>>>2>>>0]=t)},e:()=>{E("")},b:function(t,e,n){return t>>>=0,e=Bt(e>>>0,n>>>0),v[t].apply(null,e)},i:function(t,e,n){return t>>>=0,e=Bt(e>>>0,n>>>0),v[t].apply(null,e)},h:()=>Date.now(),x:function(){return 4294901760},c:()=>performance.now(),K:function(t,e,n){return e>>>=0,G.copyWithin(t>>>0>>>0,e>>>0,e+(n>>>0)>>>0)},u:function(t){t>>>=0;var e=G.length;if(4294901760<t)return!1;for(var n=1;4>=n;n*=2){var B=e*(1+.2/n);B=Math.min(B,t+100663296);var s=Math;B=Math.max(t,B);t:{s=(s.min.call(s,4294901760,B+(65536-B%65536)%65536)-C.buffer.byteLength+65535)/65536;try{C.grow(s),y();var F=1;break t}catch(t){}F=void 0}if(F)return!0}return!1},E:function(t,e){t>>>=0,e>>>=0;var n=0;return Ft().forEach(((B,s)=>{var F=e+n;for(s=x[t+4*s>>>2>>>0]=F,F=0;F<B.length;++F)m[s++>>>0>>>0]=B.charCodeAt(F);m[s>>>0>>>0]=0,n+=B.length+1})),0},F:function(t,e){t>>>=0,e>>>=0;var n=Ft();x[t>>>2>>>0]=n.length;var B=0;return n.forEach((t=>B+=t.length+1)),x[e>>>2>>>0]=B,0},f:()=>52,k:function(){return 52},t:function(){return 70},j:function(t,e,n,B){e>>>=0,n>>>=0,B>>>=0;for(var s=0,F=0;F<n;F++){var Q=x[e>>>2>>>0],U=x[e+4>>>2>>>0];e+=8;for(var i=0;i<U;i++){var a=G[Q+i>>>0],l=Qt[t];0===a||10===a?((1===t?u:b)(P(l,0)),l.length=0):l.push(a)}s+=U}return x[B>>>2>>>0]=s,0},v:at,d:function(t,e,n,B){return at(t>>>0,e>>>0,n>>>0,B>>>0)}},Gt=function(){function t(t){return Gt=t.exports,Gt=function(){var t=Gt,e={};for(let[n,B]of Object.entries(t))e[n]="function"==typeof B?function(){It.push(n);try{return B.apply(null,arguments)}finally{S||(It.pop(),gt&&1===ct&&0===It.length&&(ct=0,lt(Lt),"undefined"!=typeof Fibers&&Fibers.cb()))}}:B;return e}(),Gt=function(){var t=Gt;t=Object.assign({},t);var e=t=>()=>t()>>>0,n=t=>e=>t(e)>>>0;return t.pa=e(t.pa),t.qa=n(t.qa),t.ua=e(t.ua),t.wa=n(t.wa),t}(),C=Gt.M,y(),X.unshift(Gt.N),0==--L&&(null!==W&&(clearInterval(W),W=null),N&&(t=N,N=null,t())),Gt}var e={a:mt};if(L++,s.instantiateWasm)try{return s.instantiateWasm(e,t)}catch(t){b(`Module.instantiateWasm callback failed with error: ${t}`),B(t)}return function(t,e){var n=T;return"function"!=typeof WebAssembly.instantiateStreaming||Y(n)||H(n)||d||"function"!=typeof fetch?k(n,t,e):fetch(n,{credentials:"same-origin"}).then((B=>WebAssembly.instantiateStreaming(B,t).then(e,(function(B){return b(`wasm streaming compile failed: ${B}`),b("falling back to ArrayBuffer instantiation"),k(n,t,e)}))))}(e,(function(e){t(e.instance)})).catch(B),{}}();s._OrtInit=(t,e)=>(s._OrtInit=Gt.O)(t,e),s._OrtGetLastError=(t,e)=>(s._OrtGetLastError=Gt.P)(t,e),s._OrtCreateSessionOptions=(t,e,n,B,F,Q,U,i,a,l)=>(s._OrtCreateSessionOptions=Gt.Q)(t,e,n,B,F,Q,U,i,a,l),s._OrtAppendExecutionProvider=(t,e)=>(s._OrtAppendExecutionProvider=Gt.R)(t,e),s._OrtAddFreeDimensionOverride=(t,e,n)=>(s._OrtAddFreeDimensionOverride=Gt.S)(t,e,n),s._OrtAddSessionConfigEntry=(t,e,n)=>(s._OrtAddSessionConfigEntry=Gt.T)(t,e,n),s._OrtReleaseSessionOptions=t=>(s._OrtReleaseSessionOptions=Gt.U)(t),s._OrtCreateSession=(t,e,n)=>(s._OrtCreateSession=Gt.V)(t,e,n),s._OrtReleaseSession=t=>(s._OrtReleaseSession=Gt.W)(t),s._OrtGetInputOutputCount=(t,e,n)=>(s._OrtGetInputOutputCount=Gt.X)(t,e,n),s._OrtGetInputName=(t,e)=>(s._OrtGetInputName=Gt.Y)(t,e),s._OrtGetOutputName=(t,e)=>(s._OrtGetOutputName=Gt.Z)(t,e),s._OrtFree=t=>(s._OrtFree=Gt._)(t),s._OrtCreateTensor=(t,e,n,B,F,Q)=>(s._OrtCreateTensor=Gt.$)(t,e,n,B,F,Q),s._OrtGetTensorData=(t,e,n,B,F)=>(s._OrtGetTensorData=Gt.aa)(t,e,n,B,F),s._OrtReleaseTensor=t=>(s._OrtReleaseTensor=Gt.ba)(t),s._OrtCreateRunOptions=(t,e,n,B)=>(s._OrtCreateRunOptions=Gt.ca)(t,e,n,B),s._OrtAddRunConfigEntry=(t,e,n)=>(s._OrtAddRunConfigEntry=Gt.da)(t,e,n),s._OrtReleaseRunOptions=t=>(s._OrtReleaseRunOptions=Gt.ea)(t),s._OrtCreateBinding=t=>(s._OrtCreateBinding=Gt.fa)(t),s._OrtBindInput=(t,e,n)=>(s._OrtBindInput=Gt.ga)(t,e,n),s._OrtBindOutput=(t,e,n,B)=>(s._OrtBindOutput=Gt.ha)(t,e,n,B),s._OrtClearBoundOutputs=t=>(s._OrtClearBoundOutputs=Gt.ia)(t),s._OrtReleaseBinding=t=>(s._OrtReleaseBinding=Gt.ja)(t),s._OrtRunWithBinding=(t,e,n,B,F)=>(s._OrtRunWithBinding=Gt.ka)(t,e,n,B,F),s._OrtRun=(t,e,n,B,F,Q,U,i)=>(s._OrtRun=Gt.la)(t,e,n,B,F,Q,U,i),s._OrtEndProfiling=t=>(s._OrtEndProfiling=Gt.ma)(t),s._JsepOutput=(t,e,n)=>(s._JsepOutput=Gt.na)(t,e,n),s._JsepGetNodeName=t=>(s._JsepGetNodeName=Gt.oa)(t);var Vt,xt=()=>(xt=Gt.pa)(),ht=s._malloc=t=>(ht=s._malloc=Gt.qa)(t),Zt=s._free=t=>(Zt=s._free=Gt.ra)(t),St=t=>(St=Gt.ta)(t),yt=()=>(yt=Gt.ua)(),At=t=>(At=Gt.va)(t),Xt=t=>(Xt=Gt.wa)(t),Rt=t=>(Rt=Gt.ya)(t),Lt=()=>(Lt=Gt.za)(),Wt=t=>(Wt=Gt.Aa)(t),Nt=()=>(Nt=Gt.Ba)();function Et(){if(!(0<L)){if(s.preRun)for("function"==typeof s.preRun&&(s.preRun=[s.preRun]);s.preRun.length;){var t=s.preRun.shift();A.unshift(t)}for(;0<A.length;)A.shift()(s);if(!(0<L||Vt||(Vt=!0,s.calledRun=!0,S))){for(;0<X.length;)X.shift()(s);for(e(s);0<R.length;)R.shift()(s)}}}return s.___start_em_js=943100,s.___stop_em_js=943261,s.stackAlloc=Xt,s.stackSave=yt,s.stackRestore=At,s.UTF8ToString=j,s.stringToUTF8=(t,e,n)=>K(t,G,e,n),s.lengthBytesUTF8=_,N=function t(){Vt||Et(),Vt||(N=t)},Et(),t.ready});"object"==typeof t&&"object"==typeof e?e.exports=B:"function"==typeof define&&define.amd&&define([],(()=>B))}}),require_worker_threads=__commonJS({"nodejs-ignore:worker_threads"(){}}),require_perf_hooks=__commonJS({"nodejs-ignore:perf_hooks"(){}}),os_exports={},cpus2;__export(os_exports,{cpus:()=>cpus2});var init_os=__esm({"nodejs-ignore:os"(){cpus2=void 0}}),require_ort_wasm_simd_threaded_jsep=__commonJS({"web/lib/wasm/binding/ort-wasm-simd-threaded.jsep.js"(t,e){var n,B=(n="undefined"!=typeof document&&document.currentScript?document.currentScript.src:void 0,"undefined"!=typeof __filename&&(n=n||__filename),function(t={}){function e(){return A.buffer!=L.buffer&&J(),L}function B(){return A.buffer!=L.buffer&&J(),W}function s(){return A.buffer!=L.buffer&&J(),N}function F(){return A.buffer!=L.buffer&&J(),E}function Q(){return A.buffer!=L.buffer&&J(),T}function U(){return A.buffer!=L.buffer&&J(),Y}var i,a,l=t;l.ready=new Promise(((t,e)=>{i=t,a=e})),l.mountExternalData=(t,e)=>{(l.cb||(l.cb=new Map)).set(t,e)},l.unmountExternalData=()=>{delete l.cb},l.jsepInit=(t,e,n,B,s,F,Q,U)=>{l.Mb=t,l.wb=e,l.yb=n,l.kb=B,l.xb=s,l.Ea=F,l.zb=Q,l.Ab=U,e=(t,e,n)=>(...B)=>{const s=ce,F=e?.();B=t(...B);const Q=e?.();return F!==Q&&(t=Q,n(F),e=n=null),ce!=s?new Promise(((t,e)=>{ue={resolve:t,reject:e}})):B},n=e=>async(...n)=>{try{if(l.bb)throw Error("Session already started");const B=l.bb={Cb:n[0],errors:[]},s=await e(...n);if(l.bb!==B)throw Error("Session mismatch");t.flush();const F=B.errors;if(0<F.length){let t=await Promise.all(F);if(t=t.filter((t=>t)),0<t.length)throw Error(t.join("\n"))}return s}finally{l.bb=null}},l._OrtRun=n(e(l._OrtRun,(()=>l._OrtRun),(t=>l._OrtRun=t))),l._OrtRunWithBinding=n(e(l._OrtRunWithBinding,(()=>l._OrtRunWithBinding),(t=>l._OrtRunWithBinding=t))),l._OrtBindInput=e(l._OrtBindInput,(()=>l._OrtBindInput),(t=>l._OrtBindInput=t)),l.jsepRegisterBuffer=(e,n,B,s)=>t.registerBuffer(e,n,B,s),l.jsepUnregisterBuffers=e=>{t.unregisterBuffers(e)},l.jsepGetBuffer=e=>t.getBuffer(e),l.jsepCreateDownloader=(e,n,B)=>t.createDownloader(e,n,B)};var c,g,d,I=Object.assign({},l),o="./this.program",r=(t,e)=>{throw e},u="object"==typeof window,b="function"==typeof importScripts,C="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node,p=l.ENVIRONMENT_IS_PTHREAD||!1,m="";function G(t){return l.locateFile?l.locateFile(t,m):m+t}if(C){var V=(init_fs(),__toCommonJS(fs_exports)),x=(init_path(),__toCommonJS(path_exports));let t;m=b?x.dirname(m)+"/":__dirname+"/",c=(t,e)=>(t=K(t)?new URL(t):x.normalize(t),V.readFileSync(t,e?void 0:"utf8")),d=t=>((t=c(t,!0)).buffer||(t=new Uint8Array(t)),t),g=(t,e,n,B=!0)=>{t=K(t)?new URL(t):x.normalize(t),V.readFile(t,B?void 0:"utf8",((t,s)=>{t?n(t):e(B?s.buffer:s)}))},!l.thisProgram&&1<process.argv.length&&(o=process.argv[1].replace(/\\/g,"/")),process.argv.slice(2),r=(t,e)=>{throw process.exitCode=t,e},l.inspect=()=>"[Emscripten Module object]";try{t=require_worker_threads()}catch(t){throw console.error('The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?'),t}global.Worker=t.Worker}else(u||b)&&(b?m=self.location.href:"undefined"!=typeof document&&document.currentScript&&(m=document.currentScript.src),void 0!==n&&n&&(m=n),m=0!==m.indexOf("blob:")?m.substr(0,m.replace(/[?#].*/,"").lastIndexOf("/")+1):"",C||(c=t=>{var e=new XMLHttpRequest;return e.open("GET",t,!1),e.send(null),e.responseText},b&&(d=t=>{var e=new XMLHttpRequest;return e.open("GET",t,!1),e.responseType="arraybuffer",e.send(null),new Uint8Array(e.response)}),g=(t,e,n)=>{var B=new XMLHttpRequest;B.open("GET",t,!0),B.responseType="arraybuffer",B.onload=()=>{200==B.status||0==B.status&&B.response?e(B.response):n()},B.onerror=n,B.send(null)}));C&&"undefined"==typeof performance&&(global.performance=require_perf_hooks().performance);var h=console.log.bind(console),Z=console.error.bind(console);C&&(h=(...t)=>V.writeSync(1,t.join(" ")+"\n"),Z=(...t)=>V.writeSync(2,t.join(" ")+"\n"));var S=h,y=Z;Object.assign(l,I),I=null,"object"!=typeof WebAssembly&&P("no native wasm support detected");var A,X,R,L,W,N,E,T,Y,H=!1;function J(){var t=A.buffer;l.HEAP8=L=new Int8Array(t),l.HEAP16=new Int16Array(t),l.HEAPU8=W=new Uint8Array(t),l.HEAPU16=new Uint16Array(t),l.HEAP32=N=new Int32Array(t),l.HEAPU32=E=new Uint32Array(t),l.HEAPF32=T=new Float32Array(t),l.HEAPF64=Y=new Float64Array(t)}var f=16777216;if(p)A=l.wasmMemory;else if(l.wasmMemory)A=l.wasmMemory;else if(!((A=new WebAssembly.Memory({initial:f/65536,maximum:65536,shared:!0})).buffer instanceof SharedArrayBuffer))throw y("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),C&&y("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and/or recent version)"),Error("bad memory");J(),f=A.buffer.byteLength;var k=[],w=[],v=[],z=0,D=null,M=null;function O(){if(0==--z&&(null!==D&&(clearInterval(D),D=null),M)){var t=M;M=null,t()}}function P(t){throw y(t="Aborted("+t+")"),H=!0,R=1,t=new WebAssembly.RuntimeError(t+". Build with -sASSERTIONS for more info."),a(t),t}var j,_=t=>t.startsWith("data:application/octet-stream;base64,"),K=t=>t.startsWith("file://");function $(t){if(d)return d(t);throw"both async and sync fetching of the wasm failed"}function q(t,e,n){return function(t){if(u||b){if("function"==typeof fetch&&!K(t))return fetch(t,{credentials:"same-origin"}).then((e=>{if(!e.ok)throw"failed to load wasm binary file at '"+t+"'";return e.arrayBuffer()})).catch((()=>$(t)));if(g)return new Promise(((e,n)=>{g(t,(t=>e(new Uint8Array(t))),n)}))}return Promise.resolve().then((()=>$(t)))}(t).then((t=>WebAssembly.instantiate(t,e))).then((t=>t)).then(n,(t=>{y(`failed to asynchronously prepare wasm: ${t}`),P(t)}))}_(j="ort-wasm-simd-threaded.wasm")||(j=G(j));var tt,et={932428:(t,e,n,s)=>{if(void 0===l||!l.cb)return 1;if((t=it(t>>>0)).startsWith("./")&&(t=t.substring(2)),!(t=l.cb.get(t)))return 2;if(s>>>=0,(e>>>=0)+(n>>>=0)>t.byteLength)return 3;try{return B().set(t.subarray(e,e+n),s>>>0),0}catch{return 4}},932929:t=>l.wb(t),932962:t=>l.yb(t),932994:(t,e,n)=>{l.kb(t,e,n,!0)},933033:(t,e,n)=>{l.kb(t,e,n)},933066:t=>{l.Ea("Abs",t,void 0)},933117:t=>{l.Ea("Neg",t,void 0)},933168:t=>{l.Ea("Floor",t,void 0)},933221:t=>{l.Ea("Ceil",t,void 0)},933273:t=>{l.Ea("Reciprocal",t,void 0)},933331:t=>{l.Ea("Sqrt",t,void 0)},933383:t=>{l.Ea("Exp",t,void 0)},933434:t=>{l.Ea("Erf",t,void 0)},933485:t=>{l.Ea("Sigmoid",t,void 0)},933540:t=>{l.Ea("Log",t,void 0)},933591:t=>{l.Ea("Sin",t,void 0)},933642:t=>{l.Ea("Cos",t,void 0)},933693:t=>{l.Ea("Tan",t,void 0)},933744:t=>{l.Ea("Asin",t,void 0)},933796:t=>{l.Ea("Acos",t,void 0)},933848:t=>{l.Ea("Atan",t,void 0)},933900:t=>{l.Ea("Sinh",t,void 0)},933952:t=>{l.Ea("Cosh",t,void 0)},934004:t=>{l.Ea("Asinh",t,void 0)},934057:t=>{l.Ea("Acosh",t,void 0)},934110:t=>{l.Ea("Atanh",t,void 0)},934163:t=>{l.Ea("Tanh",t,void 0)},934215:t=>{l.Ea("Not",t,void 0)},934266:(t,e,n)=>{l.Ea("Clip",t,{min:e,max:n})},934335:t=>{l.Ea("Clip",t,void 0)},934387:(t,e)=>{l.Ea("Elu",t,{alpha:e})},934445:t=>{l.Ea("Relu",t,void 0)},934497:(t,e)=>{l.Ea("LeakyRelu",t,{alpha:e})},934561:(t,e)=>{l.Ea("ThresholdedRelu",t,{alpha:e})},934631:(t,e)=>{l.Ea("Cast",t,{to:e})},934689:t=>{l.Ea("Add",t,void 0)},934740:t=>{l.Ea("Sub",t,void 0)},934791:t=>{l.Ea("Mul",t,void 0)},934842:t=>{l.Ea("Div",t,void 0)},934893:t=>{l.Ea("Pow",t,void 0)},934944:t=>{l.Ea("Equal",t,void 0)},934997:t=>{l.Ea("Greater",t,void 0)},935052:t=>{l.Ea("GreaterOrEqual",t,void 0)},935114:t=>{l.Ea("Less",t,void 0)},935166:t=>{l.Ea("LessOrEqual",t,void 0)},935225:(t,e,n,B,F)=>{l.Ea("ReduceMean",t,{keepDims:!!e,noopWithEmptyAxes:!!n,axes:B?Array.from(s().subarray(B>>>0,F>>>0)):[]})},935384:(t,e,n,B,F)=>{l.Ea("ReduceMax",t,{keepDims:!!e,noopWithEmptyAxes:!!n,axes:B?Array.from(s().subarray(B>>>0,F>>>0)):[]})},935542:(t,e,n,B,F)=>{l.Ea("ReduceMin",t,{keepDims:!!e,noopWithEmptyAxes:!!n,axes:B?Array.from(s().subarray(B>>>0,F>>>0)):[]})},935700:(t,e,n,B,F)=>{l.Ea("ReduceProd",t,{keepDims:!!e,noopWithEmptyAxes:!!n,axes:B?Array.from(s().subarray(B>>>0,F>>>0)):[]})},935859:(t,e,n,B,F)=>{l.Ea("ReduceSum",t,{keepDims:!!e,noopWithEmptyAxes:!!n,axes:B?Array.from(s().subarray(B>>>0,F>>>0)):[]})},936017:(t,e,n,B,F)=>{l.Ea("ReduceL1",t,{keepDims:!!e,noopWithEmptyAxes:!!n,axes:B?Array.from(s().subarray(B>>>0,F>>>0)):[]})},936174:(t,e,n,B,F)=>{l.Ea("ReduceL2",t,{keepDims:!!e,noopWithEmptyAxes:!!n,axes:B?Array.from(s().subarray(B>>>0,F>>>0)):[]})},936331:(t,e,n,B,F)=>{l.Ea("ReduceLogSum",t,{keepDims:!!e,noopWithEmptyAxes:!!n,axes:B?Array.from(s().subarray(B>>>0,F>>>0)):[]})},936492:(t,e,n,B,F)=>{l.Ea("ReduceSumSquare",t,{keepDims:!!e,noopWithEmptyAxes:!!n,axes:B?Array.from(s().subarray(B>>>0,F>>>0)):[]})},936656:(t,e,n,B,F)=>{l.Ea("ReduceLogSumExp",t,{keepDims:!!e,noopWithEmptyAxes:!!n,axes:B?Array.from(s().subarray(B>>>0,F>>>0)):[]})},936820:t=>{l.Ea("Where",t,void 0)},936873:(t,e,n)=>{l.Ea("Transpose",t,{perm:e?Array.from(s().subarray(e>>>0,n>>>0)):[]})},936981:(t,n,B,F,Q,U,i,a,c,g,d,I,o,r,u)=>{l.Ea("ConvTranspose",t,{format:c?"NHWC":"NCHW",autoPad:n,dilations:[B],group:F,kernel_shape:[Q],pads:[U,i],strides:[a],wIsConst:()=>!!e()[g>>>0],outputPadding:d?Array.from(s().subarray(d>>>0,I>>>0)):[],outputShape:o?Array.from(s().subarray(o>>>0,r>>>0)):[],activation:it(u)})},937383:(t,n,B,F,Q,U,i,a,c,g,d,I,o,r)=>{l.Ea("ConvTranspose",t,{format:a?"NHWC":"NCHW",autoPad:n,dilations:Array.from(s().subarray(B>>>0,2+(B>>>0)>>>0)),group:F,kernelShape:Array.from(s().subarray(Q>>>0,2+(Q>>>0)>>>0)),pads:Array.from(s().subarray(U>>>0,4+(U>>>0)>>>0)),strides:Array.from(s().subarray(i>>>0,2+(i>>>0)>>>0)),wIsConst:()=>!!e()[c>>>0],outputPadding:g?Array.from(s().subarray(g>>>0,d>>>0)):[],outputShape:I?Array.from(s().subarray(I>>>0,o>>>0)):[],activation:it(r)})},937948:(t,n,B,F,Q,U,i,a,c,g,d,I,o,r,u)=>{l.Ea("ConvTranspose",t,{format:c?"NHWC":"NCHW",autoPad:n,dilations:[B],group:F,kernel_shape:[Q],pads:[U,i],strides:[a],wIsConst:()=>!!e()[g>>>0],outputPadding:d?Array.from(s().subarray(d>>>0,I>>>0)):[],outputShape:o?Array.from(s().subarray(o>>>0,r>>>0)):[],activation:it(u)})},938350:(t,n,B,F,Q,U,i,a,c,g,d,I,o,r)=>{l.Ea("ConvTranspose",t,{format:a?"NHWC":"NCHW",autoPad:n,dilations:Array.from(s().subarray(B>>>0,2+(B>>>0)>>>0)),group:F,kernelShape:Array.from(s().subarray(Q>>>0,2+(Q>>>0)>>>0)),pads:Array.from(s().subarray(U>>>0,4+(U>>>0)>>>0)),strides:Array.from(s().subarray(i>>>0,2+(i>>>0)>>>0)),wIsConst:()=>!!e()[c>>>0],outputPadding:g?Array.from(s().subarray(g>>>0,d>>>0)):[],outputShape:I?Array.from(s().subarray(I>>>0,o>>>0)):[],activation:it(r)})},938915:(t,e)=>{l.Ea("GlobalAveragePool",t,{format:e?"NHWC":"NCHW"})},939006:(t,e,n,B,s,F,Q,U,i,a,c,g,d,I,o,r)=>{l.Ea("AveragePool",t,{format:r?"NHWC":"NCHW",auto_pad:e,ceil_mode:n,count_include_pad:B,storage_order:s,dilations:[F,Q],kernel_shape:[U,i],pads:[a,c,g,d],strides:[I,o]})},939290:(t,e)=>{l.Ea("GlobalAveragePool",t,{format:e?"NHWC":"NCHW"})},939381:(t,e,n,B,s,F,Q,U,i,a,c,g,d,I,o,r)=>{l.Ea("AveragePool",t,{format:r?"NHWC":"NCHW",auto_pad:e,ceil_mode:n,count_include_pad:B,storage_order:s,dilations:[F,Q],kernel_shape:[U,i],pads:[a,c,g,d],strides:[I,o]})},939665:(t,e)=>{l.Ea("GlobalMaxPool",t,{format:e?"NHWC":"NCHW"})},939752:(t,e,n,B,s,F,Q,U,i,a,c,g,d,I,o,r)=>{l.Ea("MaxPool",t,{format:r?"NHWC":"NCHW",auto_pad:e,ceil_mode:n,count_include_pad:B,storage_order:s,dilations:[F,Q],kernel_shape:[U,i],pads:[a,c,g,d],strides:[I,o]})},940032:(t,e)=>{l.Ea("GlobalMaxPool",t,{format:e?"NHWC":"NCHW"})},940119:(t,e,n,B,s,F,Q,U,i,a,c,g,d,I,o,r)=>{l.Ea("MaxPool",t,{format:r?"NHWC":"NCHW",auto_pad:e,ceil_mode:n,count_include_pad:B,storage_order:s,dilations:[F,Q],kernel_shape:[U,i],pads:[a,c,g,d],strides:[I,o]})},940399:(t,e,n,B,s)=>{l.Ea("Gemm",t,{alpha:e,beta:n,transA:B,transB:s})},940503:t=>{l.Ea("MatMul",t,void 0)},940557:(t,e,n,B)=>{l.Ea("ArgMax",t,{keepDims:!!e,selectLastIndex:!!n,axis:B})},940665:(t,e,n,B)=>{l.Ea("ArgMin",t,{keepDims:!!e,selectLastIndex:!!n,axis:B})},940773:(t,e)=>{l.Ea("Softmax",t,{axis:e})},940836:(t,e)=>{l.Ea("Concat",t,{axis:e})},940896:(t,e,n,B,F)=>{l.Ea("Split",t,{axis:e,numOutputs:n,splitSizes:B?Array.from(s().subarray(B>>>0,F>>>0)):[]})},941036:t=>{l.Ea("Expand",t,void 0)},941090:(t,e)=>{l.Ea("Gather",t,{axis:Number(e)})},941161:(t,e)=>{l.Ea("GatherElements",t,{axis:Number(e)})},941240:(t,e,n,B,F,Q,U,i,a,c,g)=>{l.Ea("Resize",t,{antialias:e,axes:n?Array.from(s().subarray(n>>>0,B>>>0)):[],coordinateTransformMode:it(F),cubicCoeffA:Q,excludeOutside:U,extrapolationValue:i,keepAspectRatioPolicy:it(a),mode:it(c),nearestMode:it(g)})},941586:(t,e,n,B,F,Q,U)=>{l.Ea("Slice",t,{starts:e?Array.from(s().subarray(e>>>0,n>>>0)):[],ends:B?Array.from(s().subarray(B>>>0,F>>>0)):[],axes:Q?Array.from(s().subarray(Q>>>0,U>>>0)):[]})},941802:t=>{l.Ea("Tile",t,void 0)},941854:(t,e,n)=>{l.Ea("LayerNormalization",t,{axis:Number(e),epsilon:Number(n)})},941961:(t,e,n)=>{l.Ea("InstanceNormalization",t,{epsilon:e,format:n?"NHWC":"NCHW"})},942075:(t,e,n)=>{l.Ea("InstanceNormalization",t,{epsilon:e,format:n?"NHWC":"NCHW"})},942189:t=>{l.Ea("Range",t,void 0)},942242:(t,e)=>{l.Ea("Einsum",t,{equation:it(e)})},942323:(t,e,n,B,F)=>{l.Ea("Pad",t,{mode:e,value:n,pads:B?Array.from(s().subarray(B>>>0,F>>>0)):[]})},942450:(t,e,n,B,s,F)=>{l.Ea("BatchNormalization",t,{epsilon:e,momentum:n,spatial:!!s,trainingMode:!!B,format:F?"NHWC":"NCHW"})},942619:(t,e,n,B,s,F)=>{l.Ea("BatchNormalization",t,{epsilon:e,momentum:n,spatial:!!s,trainingMode:!!B,format:F?"NHWC":"NCHW"})},942788:(t,e,n)=>{l.Ea("CumSum",t,{exclusive:Number(e),reverse:Number(n)})},942885:(t,e,n,B,F,Q,U,i,a)=>{l.Ea("Attention",t,{numHeads:e,isUnidirectional:n,maskFilterValue:B,scale:F,doRotary:Q,qkvHiddenSizes:U?Array.from(s().subarray(Number(i)>>>0,Number(i)+U>>>0)):[],pastPresentShareBuffer:!!a})},943157:t=>{l.Ea("Gelu",t,void 0)},943209:(t,e,n,B,s,F)=>{l.Ea("MultiHeadAttention",t,{numHeads:e,isUnidirectional:n,maskFilterValue:B,scale:s,doRotary:F})},943368:t=>{l.Ea("BiasAdd",t,void 0)},943423:t=>{l.Ea("BiasSplitGelu",t,void 0)},943484:(t,e)=>{l.Ea("SkipLayerNormalization",t,{epsilon:e})},943565:(t,n,B,F,U,i,a,c,g,d,I,o,r)=>{l.Ea("Conv",t,{format:g?"NHWC":"NCHW",auto_pad:n,dilations:[B],group:F,kernel_shape:[U],pads:i?Array.from(s().subarray(i>>>0,a>>>0)):[],strides:[c],w_is_const:()=>!!e()[d>>>0],activation:it(I),activation_params:o?Array.from(Q().subarray(o>>>0,r>>>0)):[]})},943935:(t,n,B,F,U,i,a,c,g,d,I,o,r,u,b,C)=>{l.Ea("Conv",t,{format:o?"NHWC":"NCHW",auto_pad:n,dilations:[B,F],group:U,kernel_shape:[i,a],pads:c?Array.from(s().subarray(c>>>0,g>>>0)):[],strides:[d,I],w_is_const:()=>!!e()[r>>>0],activation:it(u),activation_params:b?Array.from(Q().subarray(b>>>0,C>>>0)):[]})},944326:t=>{l.zb(t)},944360:(t,e)=>l.Ab(t,e,l.bb.Cb,l.bb.errors)};function nt(t){this.name="ExitStatus",this.message=`Program terminated with exit(${t})`,this.status=t}var Bt=t=>{t.terminate(),t.onmessage=()=>{}},st=t=>{0==rt.Ya.length&&(ot(),rt.lb(rt.Ya[0]));var e=rt.Ya.pop();if(!e)return 6;rt.Za.push(e),rt.Qa[t.Xa]=e,e.Xa=t.Xa;var n={cmd:"run",start_routine:t.Db,arg:t.tb,pthread_ptr:t.Xa};return C&&e.unref(),e.postMessage(n,t.Jb),0},Ft=0,Qt="undefined"!=typeof TextDecoder?new TextDecoder("utf8"):void 0,Ut=(t,e,n)=>{var B=(e>>>=0)+n;for(n=e;t[n]&&!(n>=B);)++n;if(16<n-e&&t.buffer&&Qt)return Qt.decode(t.buffer instanceof SharedArrayBuffer?t.slice(e,n):t.subarray(e,n));for(B="";e<n;){var s=t[e++];if(128&s){var F=63&t[e++];if(192==(224&s))B+=String.fromCharCode((31&s)<<6|F);else{var Q=63&t[e++];65536>(s=224==(240&s)?(15&s)<<12|F<<6|Q:(7&s)<<18|F<<12|Q<<6|63&t[e++])?B+=String.fromCharCode(s):(s-=65536,B+=String.fromCharCode(55296|s>>10,56320|1023&s))}}else B+=String.fromCharCode(s)}return B},it=(t,e)=>(t>>>=0)?Ut(B(),t,e):"",at=t=>{var e=Ee();return t=t(),Te(e),t};function lt(t,e){var n=arguments.length-2,B=arguments;return at((()=>{for(var s=Ye(8*n),F=s>>>3,Q=0;Q<n;Q++){var i=B[2+Q];U()[F+Q>>>0]=i}return Ae(t,n,s,e)}))}function ct(t){if(p)return lt(0,1,t);R=t,0<Ft||(rt.Eb(),l.onExit?.(t),H=!0),r(t,new nt(t))}var gt=t=>{if(R=t,p)throw bt(t),"unwind";ct(t)},dt=t=>{t instanceof nt||"unwind"==t||r(1,t)};function It(){for(var t=l.numThreads;t--;)ot();k.unshift((()=>{z++,function(t){p?t():Promise.all(rt.Ya.map(rt.lb)).then(t)}((()=>O()))}))}function ot(){var t=G("ort-wasm-simd-threaded.worker.js");t=new Worker(t),rt.Ya.push(t)}var rt={Ya:[],Za:[],pb:[],Qa:{},hb(){p?(rt.receiveObjectTransfer=rt.Bb,rt.threadInitTLS=rt.ob,rt.setExitStatus=rt.nb):It()},nb:t=>R=t,Nb:["$terminateWorker"],Eb:()=>{for(var t of rt.Za)Bt(t);for(t of rt.Ya)Bt(t);rt.Ya=[],rt.Za=[],rt.Qa=[]},mb:t=>{var e=t.Xa;delete rt.Qa[e],rt.Ya.push(t),rt.Za.splice(rt.Za.indexOf(t),1),t.Xa=0,Xe(e)},Bb(){},ob(){rt.pb.forEach((t=>t()))},lb:t=>new Promise((e=>{t.onmessage=n=>{var B=(n=n.data).cmd;if(n.targetThread&&n.targetThread!=xe()){var s=rt.Qa[n.targetThread];s?s.postMessage(n,n.transferList):y(`Internal error! Worker sent a message "${B}" to target pthread ${n.targetThread}, but that thread no longer exists!`)}else"checkMailbox"===B?ft():"spawnThread"===B?st(n):"cleanupThread"===B?rt.mb(rt.Qa[n.thread]):"killThread"===B?(n=n.thread,B=rt.Qa[n],delete rt.Qa[n],Bt(B),Xe(n),rt.Za.splice(rt.Za.indexOf(B),1),B.Xa=0):"cancelThread"===B?rt.Qa[n.thread].postMessage({cmd:"cancel"}):"loaded"===B?(t.loaded=!0,C&&!t.Xa&&t.unref(),e(t)):"alert"===B?alert(`Thread ${n.threadId}: ${n.text}`):"setimmediate"===n.target?t.postMessage(n):"callHandler"===B?l[n.handler](...n.args):B&&y(`worker sent an unknown command ${B}`)},t.onerror=t=>{throw y(`worker sent an error! ${t.filename}:${t.lineno}: ${t.message}`),t},C&&(t.on("message",(e=>t.onmessage({data:e}))),t.on("error",(e=>t.onerror(e))));var B,s=[];for(B of["onExit"])l.hasOwnProperty(B)&&s.push(B);t.postMessage({cmd:"load",handlers:s,urlOrBlob:l.mainScriptUrlOrBlob||n,wasmMemory:A,wasmModule:X})}))};l.PThread=rt;var ut=t=>{for(;0<t.length;)t.shift()(l)};function bt(t){if(p)return lt(1,0,t);gt(t)}function Ct(t){this.gb=t-24,this.sb=function(t){F()[this.gb+4>>>2>>>0]=t},this.rb=function(t){F()[this.gb+8>>>2>>>0]=t},this.hb=function(t,e){this.qb(),this.sb(t),this.rb(e)},this.qb=function(){F()[this.gb+16>>>2>>>0]=0}}function pt(t,e,n,B){return p?lt(2,1,t,e,n,B):mt(t,e,n,B)}function mt(t,e,n,B){if(t>>>=0,e>>>=0,n>>>=0,B>>>=0,"undefined"==typeof SharedArrayBuffer)return y("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var s=[];return p&&0===s.length?pt(t,e,n,B):(t={Db:n,Xa:t,tb:B,Jb:s},p?(t.Lb="spawnThread",postMessage(t,s),0):st(t))}function Gt(t,e,n){return p?lt(3,1,t,e,n):0}function Vt(t,e){if(p)return lt(4,1,t,e)}l.establishStackSpace=()=>{var t=xe(),e=F()[t+52>>>2>>>0];t=F()[t+56>>>2>>>0],Ne(e,e-t),Te(e)},l.invokeEntryPoint=(t,e)=>{t=He.apply(null,[t,e]),0<Ft?rt.nb(t):Re(t)};var xt=t=>{for(var e=0,n=0;n<t.length;++n){var B=t.charCodeAt(n);127>=B?e++:2047>=B?e+=2:55296<=B&&57343>=B?(e+=4,++n):e+=3}return e},ht=(t,e,n,B)=>{if(!(0<B))return 0;var s=n>>>=0;B=n+B-1;for(var F=0;F<t.length;++F){var Q=t.charCodeAt(F);if(55296<=Q&&57343>=Q&&(Q=65536+((1023&Q)<<10)|1023&t.charCodeAt(++F)),127>=Q){if(n>=B)break;e[n++>>>0]=Q}else{if(2047>=Q){if(n+1>=B)break;e[n++>>>0]=192|Q>>6}else{if(65535>=Q){if(n+2>=B)break;e[n++>>>0]=224|Q>>12}else{if(n+3>=B)break;e[n++>>>0]=240|Q>>18,e[n++>>>0]=128|Q>>12&63}e[n++>>>0]=128|Q>>6&63}e[n++>>>0]=128|63&Q}}return e[n>>>0]=0,n-s},Zt=(t,e,n)=>ht(t,B(),e,n);function St(t,e){if(p)return lt(5,1,t,e)}function yt(t,e,n){if(p)return lt(6,1,t,e,n)}function At(t,e,n){return p?lt(7,1,t,e,n):0}function Xt(t,e){if(p)return lt(8,1,t,e)}function Rt(t,e,n){if(p)return lt(9,1,t,e,n)}function Lt(t,e,n,B){if(p)return lt(10,1,t,e,n,B)}function Wt(t,e,n,B){if(p)return lt(11,1,t,e,n,B)}function Nt(t,e,n,B){if(p)return lt(12,1,t,e,n,B)}function Et(t){if(p)return lt(13,1,t)}function Tt(t,e){if(p)return lt(14,1,t,e)}function Yt(t,e,n){if(p)return lt(15,1,t,e,n)}var Ht=()=>{if(!(0<Ft))try{p?Re(R):gt(R)}catch(t){dt(t)}};function Jt(t){t>>>=0,"function"==typeof Atomics.Kb&&(Atomics.Kb(s(),t>>>2,t).value.then(ft),t+=128,Atomics.store(s(),t>>>2,1))}l.__emscripten_thread_mailbox_await=Jt;var ft=()=>{var t=xe();if(t&&(Jt(t),!H))try{Le(),Ht()}catch(t){dt(t)}};l.checkMailbox=ft;var kt=[],wt=t=>0==t%4&&(0!=t%100||0==t%400),vt=[0,31,60,91,121,152,182,213,244,274,305,335],zt=[0,31,59,90,120,151,181,212,243,273,304,334];function Dt(t,e,n,B,s,F,Q,U){return p?lt(16,1,t,e,n,B,s,F,Q,U):-52}function Mt(t,e,n,B,s,F,Q){if(p)return lt(17,1,t,e,n,B,s,F,Q)}var Ot,Pt=t=>{var e=xt(t)+1,n=he(e);return n&&Zt(t,n,e),n},jt=[],_t=(t,e)=>{jt.length=0;for(var n;n=B()[t++>>>0];){var Q=105!=n;e+=(Q&=112!=n)&&e%8?4:0,jt.push(112==n?F()[e>>>2>>>0]:105==n?s()[e>>>2>>>0]:U()[e>>>3>>>0]),e+=Q?8:4}return jt},Kt={},$t=()=>{if(!Ot){var t,e={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:("object"==typeof navigator&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:o||"./this.program"};for(t in Kt)void 0===Kt[t]?delete e[t]:e[t]=Kt[t];var n=[];for(t in e)n.push(`${t}=${e[t]}`);Ot=n}return Ot};function qt(t,n){if(p)return lt(18,1,t,n);t>>>=0,n>>>=0;var B=0;return $t().forEach(((s,Q)=>{var U=n+B;for(Q=F()[t+4*Q>>>2>>>0]=U,U=0;U<s.length;++U)e()[Q++>>>0>>>0]=s.charCodeAt(U);e()[Q>>>0>>>0]=0,B+=s.length+1})),0}function te(t,e){if(p)return lt(19,1,t,e);t>>>=0,e>>>=0;var n=$t();F()[t>>>2>>>0]=n.length;var B=0;return n.forEach((t=>B+=t.length+1)),F()[e>>>2>>>0]=B,0}function ee(t){return p?lt(20,1,t):52}function ne(t,e,n,B){return p?lt(21,1,t,e,n,B):52}function Be(t,e,n,B,s){return p?lt(22,1,t,e,n,B,s):70}var se=[null,[],[]];function Fe(t,e,n,s){if(p)return lt(23,1,t,e,n,s);e>>>=0,n>>>=0,s>>>=0;for(var Q=0,U=0;U<n;U++){var i=F()[e>>>2>>>0],a=F()[e+4>>>2>>>0];e+=8;for(var l=0;l<a;l++){var c=B()[i+l>>>0],g=se[t];0===c||10===c?((1===t?S:y)(Ut(g,0)),g.length=0):g.push(c)}Q+=a}return F()[s>>>2>>>0]=Q,0}var Qe=[31,29,31,30,31,30,31,31,30,31,30,31],Ue=[31,28,31,30,31,30,31,31,30,31,30,31];function ie(t,n,B,Q){function U(t,e,n){for(t="number"==typeof t?t.toString():t||"";t.length<e;)t=n[0]+t;return t}function i(t,e){return U(t,e,"0")}function a(t,e){function n(t){return 0>t?-1:0<t?1:0}var B;return 0===(B=n(t.getFullYear()-e.getFullYear()))&&0===(B=n(t.getMonth()-e.getMonth()))&&(B=n(t.getDate()-e.getDate())),B}function l(t){switch(t.getDay()){case 0:return new Date(t.getFullYear()-1,11,29);case 1:return t;case 2:return new Date(t.getFullYear(),0,3);case 3:return new Date(t.getFullYear(),0,2);case 4:return new Date(t.getFullYear(),0,1);case 5:return new Date(t.getFullYear()-1,11,31);case 6:return new Date(t.getFullYear()-1,11,30)}}function c(t){var e=t.$a;for(t=new Date(new Date(t.ab+1900,0,1).getTime());0<e;){var n=t.getMonth(),B=(wt(t.getFullYear())?Qe:Ue)[n];if(!(e>B-t.getDate())){t.setDate(t.getDate()+e);break}e-=B-t.getDate()+1,t.setDate(1),11>n?t.setMonth(n+1):(t.setMonth(0),t.setFullYear(t.getFullYear()+1))}return n=new Date(t.getFullYear()+1,0,4),e=l(new Date(t.getFullYear(),0,4)),n=l(n),0>=a(e,t)?0>=a(n,t)?t.getFullYear()+1:t.getFullYear():t.getFullYear()-1}t>>>=0,n>>>=0,B>>>=0,Q>>>=0;var g=F()[Q+40>>>2>>>0];for(var d in Q={Hb:s()[Q>>>2>>>0],Gb:s()[Q+4>>>2>>>0],eb:s()[Q+8>>>2>>>0],jb:s()[Q+12>>>2>>>0],fb:s()[Q+16>>>2>>>0],ab:s()[Q+20>>>2>>>0],Wa:s()[Q+24>>>2>>>0],$a:s()[Q+28>>>2>>>0],Ob:s()[Q+32>>>2>>>0],Fb:s()[Q+36>>>2>>>0],Ib:g?it(g):""},B=it(B),g={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"})B=B.replace(new RegExp(d,"g"),g[d]);var I="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),o="January February March April May June July August September October November December".split(" ");for(d in g={"%a":t=>I[t.Wa].substring(0,3),"%A":t=>I[t.Wa],"%b":t=>o[t.fb].substring(0,3),"%B":t=>o[t.fb],"%C":t=>i((t.ab+1900)/100|0,2),"%d":t=>i(t.jb,2),"%e":t=>U(t.jb,2," "),"%g":t=>c(t).toString().substring(2),"%G":t=>c(t),"%H":t=>i(t.eb,2),"%I":t=>(0==(t=t.eb)?t=12:12<t&&(t-=12),i(t,2)),"%j":t=>{for(var e=0,n=0;n<=t.fb-1;e+=(wt(t.ab+1900)?Qe:Ue)[n++]);return i(t.jb+e,3)},"%m":t=>i(t.fb+1,2),"%M":t=>i(t.Gb,2),"%n":()=>"\n","%p":t=>0<=t.eb&&12>t.eb?"AM":"PM","%S":t=>i(t.Hb,2),"%t":()=>"\t","%u":t=>t.Wa||7,"%U":t=>i(Math.floor((t.$a+7-t.Wa)/7),2),"%V":t=>{var e=Math.floor((t.$a+7-(t.Wa+6)%7)/7);if(2>=(t.Wa+371-t.$a-2)%7&&e++,e)53==e&&(4==(n=(t.Wa+371-t.$a)%7)||3==n&&wt(t.ab)||(e=1));else{e=52;var n=(t.Wa+7-t.$a-1)%7;(4==n||5==n&&wt(t.ab%400-1))&&e++}return i(e,2)},"%w":t=>t.Wa,"%W":t=>i(Math.floor((t.$a+7-(t.Wa+6)%7)/7),2),"%y":t=>(t.ab+1900).toString().substring(2),"%Y":t=>t.ab+1900,"%z":t=>{var e=0<=(t=t.Fb);return t=Math.abs(t)/60,(e?"+":"-")+String("0000"+(t/60*100+t%60)).slice(-4)},"%Z":t=>t.Ib,"%%":()=>"%"},B=B.replace(/%%/g,"\0\0"),g)B.includes(d)&&(B=B.replace(new RegExp(d,"g"),g[d](Q)));return d=function(t){var e=Array(xt(t)+1);return ht(t,e,0,e.length),e}(B=B.replace(/\0\0/g,"%")),d.length>n?0:(((t,n)=>{e().set(t,n>>>0)})(d,t),d.length-1)}var ae=t=>{try{t()}catch(t){P(t)}},le=0,ce=null,ge=0,de=[],Ie={},oe={},re=0,ue=null,be=[];function Ce(t){if(!H){if(0===le){var e=!1,n=!1;t(((t=0)=>{if(!H&&(ge=t,e=!0,n)){le=2,ae((()=>ke(ce))),"undefined"!=typeof Browser&&Browser.ib.vb&&Browser.ib.resume(),t=!1;try{var B=function(){var t=s()[ce+8>>>2>>>0];return t=Ge[oe[t]],--Ft,t()}()}catch(e){B=e,t=!0}var F=!1;if(!ce){var Q=ue;Q&&(ue=null,(t?Q.reject:Q.resolve)(B),F=!0)}if(t&&!F)throw B}})),n=!0,e||(le=1,ce=function(){var t=he(65548),e=t+12;F()[t>>>2>>>0]=e,F()[t+4>>>2>>>0]=e+65536,e=de[0];var n=Ie[e];return void 0===n&&(n=re++,Ie[e]=n,oe[n]=e),e=n,s()[t+8>>>2>>>0]=e,t}(),"undefined"!=typeof Browser&&Browser.ib.vb&&Browser.ib.pause(),ae((()=>Je(ce))))}else 2===le?(le=0,ae(we),Ze(ce),ce=null,be.forEach((t=>{if(!H)try{t(),Ht()}catch(t){dt(t)}}))):P(`invalid state: ${le}`);return ge}}rt.hb();var pe=[ct,bt,pt,Gt,Vt,St,yt,At,Xt,Rt,Lt,Wt,Nt,Et,Tt,Yt,Dt,Mt,qt,te,ee,ne,Be,Fe],me={r:function(t,e,n){return function(t){return Ce((e=>{t().then(e)}))}((async()=>{await l.xb(t,e,n)}))},b:function(t,e,n){throw new Ct(t>>>=0).hb(e>>>0,n>>>0),t},N:function(t){Se(t>>>0,!b,1,!u,131072,!1),rt.ob()},l:function(t){t>>>=0,p?postMessage({cmd:"cleanupThread",thread:t}):rt.mb(rt.Qa[t])},J:mt,i:Gt,T:Vt,F:St,H:yt,U:At,R:Xt,L:Rt,Q:Lt,p:Wt,G:Nt,D:Et,S:Tt,E:Yt,q:()=>1,B:function(t,e){(t>>>=0)==e>>>0?setTimeout((()=>ft())):p?postMessage({targetThread:t,cmd:"checkMailbox"}):(t=rt.Qa[t])&&t.postMessage({cmd:"checkMailbox"})},K:function(t,e,n,B){e>>>=0,kt.length=n,B=B>>>0>>>3;for(var s=0;s<n;s++)kt[s]=U()[B+s>>>0];return t=0>t?et[-t-1]:pe[t],rt.ub=e,e=t.apply(null,kt),rt.ub=0,e},M:Jt,W:function(t){C&&rt.Qa[t>>>0].ref()},u:function(t,e,n){t=e+2097152>>>0<4194305-!!t?(t>>>0)+4294967296*e:NaN,n>>>=0,t=new Date(1e3*t),s()[n>>>2>>>0]=t.getUTCSeconds(),s()[n+4>>>2>>>0]=t.getUTCMinutes(),s()[n+8>>>2>>>0]=t.getUTCHours(),s()[n+12>>>2>>>0]=t.getUTCDate(),s()[n+16>>>2>>>0]=t.getUTCMonth(),s()[n+20>>>2>>>0]=t.getUTCFullYear()-1900,s()[n+24>>>2>>>0]=t.getUTCDay(),t=(t.getTime()-Date.UTC(t.getUTCFullYear(),0,1,0,0,0,0))/864e5|0,s()[n+28>>>2>>>0]=t},v:function(t,e,n){t=e+2097152>>>0<4194305-!!t?(t>>>0)+4294967296*e:NaN,n>>>=0,t=new Date(1e3*t),s()[n>>>2>>>0]=t.getSeconds(),s()[n+4>>>2>>>0]=t.getMinutes(),s()[n+8>>>2>>>0]=t.getHours(),s()[n+12>>>2>>>0]=t.getDate(),s()[n+16>>>2>>>0]=t.getMonth(),s()[n+20>>>2>>>0]=t.getFullYear()-1900,s()[n+24>>>2>>>0]=t.getDay(),e=(wt(t.getFullYear())?vt:zt)[t.getMonth()]+t.getDate()-1|0,s()[n+28>>>2>>>0]=e,s()[n+36>>>2>>>0]=-60*t.getTimezoneOffset(),e=new Date(t.getFullYear(),6,1).getTimezoneOffset();var B=new Date(t.getFullYear(),0,1).getTimezoneOffset();t=0|(e!=B&&t.getTimezoneOffset()==Math.min(B,e)),s()[n+32>>>2>>>0]=t},w:function(t){t>>>=0;var e=new Date(s()[t+20>>>2>>>0]+1900,s()[t+16>>>2>>>0],s()[t+12>>>2>>>0],s()[t+8>>>2>>>0],s()[t+4>>>2>>>0],s()[t>>>2>>>0],0),n=s()[t+32>>>2>>>0],B=e.getTimezoneOffset(),F=new Date(e.getFullYear(),6,1).getTimezoneOffset(),Q=new Date(e.getFullYear(),0,1).getTimezoneOffset(),U=Math.min(Q,F);return 0>n?s()[t+32>>>2>>>0]=Number(F!=Q&&U==B):0<n!=(U==B)&&(F=Math.max(Q,F),e.setTime(e.getTime()+6e4*((0<n?U:F)-B))),s()[t+24>>>2>>>0]=e.getDay(),n=(wt(e.getFullYear())?vt:zt)[e.getMonth()]+e.getDate()-1|0,s()[t+28>>>2>>>0]=n,s()[t>>>2>>>0]=e.getSeconds(),s()[t+4>>>2>>>0]=e.getMinutes(),s()[t+8>>>2>>>0]=e.getHours(),s()[t+12>>>2>>>0]=e.getDate(),s()[t+16>>>2>>>0]=e.getMonth(),s()[t+20>>>2>>>0]=e.getYear(),t=e.getTime(),isNaN(t)?(s()[Ve()>>>2>>>0]=61,t=-1):t/=1e3,We((tt=t,1<=+Math.abs(tt)?0<tt?+Math.floor(tt/4294967296)>>>0:~~+Math.ceil((tt-+(~~tt>>>0))/4294967296)>>>0:0)),t>>>0},s:Dt,t:Mt,A:function(t,e,n){function B(t){return(t=t.toTimeString().match(/\(([A-Za-z ]+)\)$/))?t[1]:"GMT"}t>>>=0,e>>>=0,n>>>=0;var Q=(new Date).getFullYear(),U=new Date(Q,0,1),i=new Date(Q,6,1);Q=U.getTimezoneOffset();var a=i.getTimezoneOffset(),l=Math.max(Q,a);F()[t>>>2>>>0]=60*l,s()[e>>>2>>>0]=Number(Q!=a),t=B(U),e=B(i),t=Pt(t),e=Pt(e),a<Q?(F()[n>>>2>>>0]=t,F()[n+4>>>2>>>0]=e):(F()[n>>>2>>>0]=e,F()[n+4>>>2>>>0]=t)},d:()=>{P("")},c:function(t,e,n){return t>>>=0,e=_t(e>>>0,n>>>0),et[t].apply(null,e)},k:function(t,e,n){return t>>>=0,e=_t(e>>>0,n>>>0),et[t].apply(null,e)},m:()=>{},j:()=>Date.now(),V:()=>{throw Ft+=1,"unwind"},C:function(){return 4294901760},f:()=>performance.timeOrigin+performance.now(),g:()=>C?(init_os(),__toCommonJS(os_exports)).cpus().length:navigator.hardwareConcurrency,y:function(t){t>>>=0;var e=B().length;if(t<=e||4294901760<t)return!1;for(var n=1;4>=n;n*=2){var s=e*(1+.2/n);s=Math.min(s,t+100663296);var F=Math;s=Math.max(t,s);t:{F=(F.min.call(F,4294901760,s+(65536-s%65536)%65536)-A.buffer.byteLength+65535)/65536;try{A.grow(F),J();var Q=1;break t}catch(t){}Q=void 0}if(Q)return!0}return!1},O:qt,P:te,I:gt,h:ee,o:ne,x:Be,n:Fe,a:A||l.wasmMemory,z:ie,e:function(t,e,n,B){return ie(t>>>0,e>>>0,n>>>0,B>>>0)}},Ge=function(){function t(t,e){return Ge=t.exports,Ge=function(){var t=Ge,e={};for(let[n,B]of Object.entries(t))e[n]="function"==typeof B?function(){de.push(n);try{return B.apply(null,arguments)}finally{H||(de.pop(),ce&&1===le&&0===de.length&&(le=0,Ft+=1,ae(fe),"undefined"!=typeof Fibers&&Fibers.Pb()))}}:B;return e}(),Ge=function(){var t=Ge;t=Object.assign({},t);var e=t=>()=>t()>>>0,n=t=>e=>t(e)>>>0;return t.za=e(t.za),t.Aa=e(t.Aa),t.Ba=n(t.Ba),t.emscripten_main_runtime_thread_id=e(t.emscripten_main_runtime_thread_id),t.Na=e(t.Na),t.Pa=n(t.Pa),t}(),rt.pb.push(Ge.Da),w.unshift(Ge.X),X=e,O(),Ge}var e={a:me};if(z++,l.instantiateWasm)try{return l.instantiateWasm(e,t)}catch(t){y(`Module.instantiateWasm callback failed with error: ${t}`),a(t)}return function(t,e){var n=j;return"function"!=typeof WebAssembly.instantiateStreaming||_(n)||K(n)||C||"function"!=typeof fetch?q(n,t,e):fetch(n,{credentials:"same-origin"}).then((B=>WebAssembly.instantiateStreaming(B,t).then(e,(function(B){return y(`wasm streaming compile failed: ${B}`),y("falling back to ArrayBuffer instantiation"),q(n,t,e)}))))}(e,(function(e){t(e.instance,e.module)})).catch(a),{}}();l._OrtInit=(t,e)=>(l._OrtInit=Ge.Y)(t,e),l._OrtGetLastError=(t,e)=>(l._OrtGetLastError=Ge.Z)(t,e),l._OrtCreateSessionOptions=(t,e,n,B,s,F,Q,U,i,a)=>(l._OrtCreateSessionOptions=Ge._)(t,e,n,B,s,F,Q,U,i,a),l._OrtAppendExecutionProvider=(t,e)=>(l._OrtAppendExecutionProvider=Ge.$)(t,e),l._OrtAddFreeDimensionOverride=(t,e,n)=>(l._OrtAddFreeDimensionOverride=Ge.aa)(t,e,n),l._OrtAddSessionConfigEntry=(t,e,n)=>(l._OrtAddSessionConfigEntry=Ge.ba)(t,e,n),l._OrtReleaseSessionOptions=t=>(l._OrtReleaseSessionOptions=Ge.ca)(t),l._OrtCreateSession=(t,e,n)=>(l._OrtCreateSession=Ge.da)(t,e,n),l._OrtReleaseSession=t=>(l._OrtReleaseSession=Ge.ea)(t),l._OrtGetInputOutputCount=(t,e,n)=>(l._OrtGetInputOutputCount=Ge.fa)(t,e,n),l._OrtGetInputName=(t,e)=>(l._OrtGetInputName=Ge.ga)(t,e),l._OrtGetOutputName=(t,e)=>(l._OrtGetOutputName=Ge.ha)(t,e),l._OrtFree=t=>(l._OrtFree=Ge.ia)(t),l._OrtCreateTensor=(t,e,n,B,s,F)=>(l._OrtCreateTensor=Ge.ja)(t,e,n,B,s,F),l._OrtGetTensorData=(t,e,n,B,s)=>(l._OrtGetTensorData=Ge.ka)(t,e,n,B,s),l._OrtReleaseTensor=t=>(l._OrtReleaseTensor=Ge.la)(t),l._OrtCreateRunOptions=(t,e,n,B)=>(l._OrtCreateRunOptions=Ge.ma)(t,e,n,B),l._OrtAddRunConfigEntry=(t,e,n)=>(l._OrtAddRunConfigEntry=Ge.na)(t,e,n),l._OrtReleaseRunOptions=t=>(l._OrtReleaseRunOptions=Ge.oa)(t),l._OrtCreateBinding=t=>(l._OrtCreateBinding=Ge.pa)(t),l._OrtBindInput=(t,e,n)=>(l._OrtBindInput=Ge.qa)(t,e,n),l._OrtBindOutput=(t,e,n,B)=>(l._OrtBindOutput=Ge.ra)(t,e,n,B),l._OrtClearBoundOutputs=t=>(l._OrtClearBoundOutputs=Ge.sa)(t),l._OrtReleaseBinding=t=>(l._OrtReleaseBinding=Ge.ta)(t),l._OrtRunWithBinding=(t,e,n,B,s)=>(l._OrtRunWithBinding=Ge.ua)(t,e,n,B,s),l._OrtRun=(t,e,n,B,s,F,Q,U)=>(l._OrtRun=Ge.va)(t,e,n,B,s,F,Q,U),l._OrtEndProfiling=t=>(l._OrtEndProfiling=Ge.wa)(t),l._JsepOutput=(t,e,n)=>(l._JsepOutput=Ge.xa)(t,e,n),l._JsepGetNodeName=t=>(l._JsepGetNodeName=Ge.ya)(t);var Ve=()=>(Ve=Ge.za)(),xe=l._pthread_self=()=>(xe=l._pthread_self=Ge.Aa)(),he=l._malloc=t=>(he=l._malloc=Ge.Ba)(t),Ze=l._free=t=>(Ze=l._free=Ge.Ca)(t);l.__emscripten_tls_init=()=>(l.__emscripten_tls_init=Ge.Da)();var Se=l.__emscripten_thread_init=(t,e,n,B,s,F)=>(Se=l.__emscripten_thread_init=Ge.Fa)(t,e,n,B,s,F);l.__emscripten_thread_crashed=()=>(l.__emscripten_thread_crashed=Ge.Ga)();var ye,Ae=(t,e,n,B)=>(Ae=Ge.Ha)(t,e,n,B),Xe=t=>(Xe=Ge.Ia)(t),Re=l.__emscripten_thread_exit=t=>(Re=l.__emscripten_thread_exit=Ge.Ja)(t),Le=()=>(Le=Ge.Ka)(),We=t=>(We=Ge.La)(t),Ne=(t,e)=>(Ne=Ge.Ma)(t,e),Ee=()=>(Ee=Ge.Na)(),Te=t=>(Te=Ge.Oa)(t),Ye=t=>(Ye=Ge.Pa)(t),He=l.dynCall_ii=(t,e)=>(He=l.dynCall_ii=Ge.Ra)(t,e),Je=t=>(Je=Ge.Sa)(t),fe=()=>(fe=Ge.Ta)(),ke=t=>(ke=Ge.Ua)(t),we=()=>(we=Ge.Va)();function ve(){if(!(0<z))if(p)i(l),p||ut(w),startWorker(l);else{if(l.preRun)for("function"==typeof l.preRun&&(l.preRun=[l.preRun]);l.preRun.length;)k.unshift(l.preRun.shift());ut(k),0<z||ye||(ye=!0,l.calledRun=!0,H||(p||ut(w),i(l),p||ut(v)))}}return l.___start_em_js=944472,l.___stop_em_js=944633,l.wasmMemory=A,l.stackAlloc=Ye,l.stackSave=Ee,l.stackRestore=Te,l.keepRuntimeAlive=()=>0<Ft,l.UTF8ToString=it,l.stringToUTF8=Zt,l.lengthBytesUTF8=xt,l.ExitStatus=nt,l.PThread=rt,M=function t(){ye||ve(),ye||(M=t)},ve(),t.ready});"object"==typeof t&&"object"==typeof e?e.exports=B:"function"==typeof define&&define.amd&&define([],(()=>B))}}),require_ort_wasm_threaded_worker=__commonJS({"web/lib/wasm/binding/ort-wasm-threaded.worker.js"(t,e){e.exports='"use strict";var Module={};var ENVIRONMENT_IS_NODE=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string";if(ENVIRONMENT_IS_NODE){var nodeWorkerThreads=require("worker_threads");var parentPort=nodeWorkerThreads.parentPort;parentPort.on("message",data=>onmessage({data:data}));var fs=require("fs");var vm=require("vm");Object.assign(global,{self:global,require:require,Module:Module,location:{href:__filename},Worker:nodeWorkerThreads.Worker,importScripts:f=>vm.runInThisContext(fs.readFileSync(f,"utf8"),{filename:f}),postMessage:msg=>parentPort.postMessage(msg),performance:global.performance||{now:Date.now}})}var initializedJS=false;function threadPrintErr(){var text=Array.prototype.slice.call(arguments).join(" ");if(ENVIRONMENT_IS_NODE){fs.writeSync(2,text+"\\n");return}console.error(text)}function threadAlert(){var text=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:text,threadId:Module["_pthread_self"]()})}var err=threadPrintErr;self.alert=threadAlert;Module["instantiateWasm"]=(info,receiveInstance)=>{var module=Module["wasmModule"];Module["wasmModule"]=null;var instance=new WebAssembly.Instance(module,info);return receiveInstance(instance)};self.onunhandledrejection=e=>{throw e.reason||e};function handleMessage(e){try{if(e.data.cmd==="load"){let messageQueue=[];self.onmessage=e=>messageQueue.push(e);self.startWorker=instance=>{Module=instance;postMessage({"cmd":"loaded"});for(let msg of messageQueue){handleMessage(msg)}self.onmessage=handleMessage};Module["wasmModule"]=e.data.wasmModule;for(const handler of e.data.handlers){Module[handler]=(...args)=>{postMessage({cmd:"callHandler",handler:handler,args:args})}}Module["wasmMemory"]=e.data.wasmMemory;Module["buffer"]=Module["wasmMemory"].buffer;Module["ENVIRONMENT_IS_PTHREAD"]=true;if(typeof e.data.urlOrBlob=="string"){importScripts(e.data.urlOrBlob)}else{var objectUrl=URL.createObjectURL(e.data.urlOrBlob);importScripts(objectUrl);URL.revokeObjectURL(objectUrl)}ortWasmThreaded(Module)}else if(e.data.cmd==="run"){Module["__emscripten_thread_init"](e.data.pthread_ptr,/*is_main=*/0,/*is_runtime=*/0,/*can_block=*/1);Module["__emscripten_thread_mailbox_await"](e.data.pthread_ptr);Module["establishStackSpace"]();Module["PThread"].receiveObjectTransfer(e.data);Module["PThread"].threadInitTLS();if(!initializedJS){initializedJS=true}try{Module["invokeEntryPoint"](e.data.start_routine,e.data.arg)}catch(ex){if(ex!="unwind"){throw ex}}}else if(e.data.cmd==="cancel"){if(Module["_pthread_self"]()){Module["__emscripten_thread_exit"](-1)}}else if(e.data.target==="setimmediate"){}else if(e.data.cmd==="checkMailbox"){if(initializedJS){Module["checkMailbox"]()}}else if(e.data.cmd){err(`worker.js received unknown command ${e.data.cmd}`);err(e.data)}}catch(ex){Module["__emscripten_thread_crashed"]?.();throw ex}}self.onmessage=handleMessage;\n'}}),ortWasmFactory,ortWasmFactoryThreaded,wasm2,initialized,initializing,aborted,isMultiThreadSupported,isSimdSupported,getWasmFileName,initializeWebAssembly,getInstance,init_wasm_factory=__esm({"web/lib/wasm/wasm-factory.ts"(){init_node_path(),ortWasmFactory=require_ort_wasm_simd_jsep(),ortWasmFactoryThreaded=require_ort_wasm_simd_threaded_jsep(),initialized=!1,initializing=!1,aborted=!1,isMultiThreadSupported=t=>{if(1===t)return!1;if("undefined"==typeof SharedArrayBuffer)return"undefined"==typeof self||self.crossOriginIsolated||console.warn("env.wasm.numThreads is set to "+t+", but this will not work unless you enable crossOriginIsolated mode. See https://web.dev/cross-origin-isolation-guide/ for more info."),!1;"undefined"!=typeof process&&process.versions&&process.versions.node&&console.warn("env.wasm.numThreads is set to "+t+", however, currently onnxruntime-web does not support multi-threads in Node.js. Please consider using onnxruntime-node for performance critical scenarios.");try{return"undefined"!=typeof MessageChannel&&(new MessageChannel).port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11]))}catch(t){return!1}},isSimdSupported=()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch(t){return!1}},getWasmFileName=(t,e)=>t?e?"ort-wasm-simd-threaded.wasm":"ort-wasm-simd.wasm":e?"ort-wasm-threaded.wasm":"ort-wasm.wasm",initializeWebAssembly=async t=>{if(initialized)return Promise.resolve();if(initializing)throw new Error("multiple calls to 'initializeWebAssembly()' detected.");if(aborted)throw new Error("previous call to 'initializeWebAssembly()' failed.");initializing=!0;const e=t.initTimeout,n=t.numThreads,B=t.simd,s=isMultiThreadSupported(n),F=B&&isSimdSupported(),Q=t.wasmPaths,U="string"==typeof Q?Q:void 0,i=getWasmFileName(F,s),a="object"==typeof Q?Q[i]:void 0;let l=!1;const c=[];if(e>0&&c.push(new Promise((t=>{setTimeout((()=>{l=!0,t()}),e)}))),c.push(new Promise(((t,e)=>{const B=s?ortWasmFactoryThreaded:ortWasmFactory,F={locateFile:(t,e)=>{if(s&&t.endsWith(".worker.js")&&"undefined"!=typeof Blob)return URL.createObjectURL(new Blob([require_ort_wasm_threaded_worker()],{type:"text/javascript"}));if(t.endsWith(".wasm")){if(a)return a;const t=U??e;return"ort-wasm-simd.wasm"===i?t+"ort-wasm-simd.jsep.wasm":"ort-wasm-simd-threaded.wasm"===i?t+"ort-wasm-simd-threaded.jsep.wasm":t+i}return e+t}};if(s)if(F.numThreads=n,"undefined"==typeof Blob)F.mainScriptUrlOrBlob=join(__dirname,"ort-wasm-threaded.js");else{const t=`var ortWasmThreaded=${B.toString()};`;F.mainScriptUrlOrBlob=new Blob([t],{type:"text/javascript"})}B(F).then((e=>{initializing=!1,initialized=!0,wasm2=e,t()}),(t=>{initializing=!1,aborted=!0,e(t)}))}))),await Promise.race(c),l)throw new Error(`WebAssembly backend initializing failed due to timeout: ${e}ms`)},getInstance=()=>{if(initialized&&wasm2)return wasm2;throw new Error("WebAssembly is not initialized yet.")}}}),allocWasmString,iterateExtraOptions,checkLastError,init_wasm_utils=__esm({"web/lib/wasm/wasm-utils.ts"(){init_wasm_factory(),allocWasmString=(t,e)=>{const n=getInstance(),B=n.lengthBytesUTF8(t)+1,s=n._malloc(B);return n.stringToUTF8(t,s,B),e.push(s),s},iterateExtraOptions=(t,e,n,B)=>{if("object"==typeof t&&null!==t){if(n.has(t))throw new Error("Circular reference in options");n.add(t)}Object.entries(t).forEach((([t,s])=>{const F=e?e+t:t;if("object"==typeof s)iterateExtraOptions(s,F+".",n,B);else if("string"==typeof s||"number"==typeof s)B(F,s.toString());else{if("boolean"!=typeof s)throw new Error("Can't handle extra config type: "+typeof s);B(F,s?"1":"0")}}))},checkLastError=t=>{const e=getInstance(),n=e.stackSave();try{const n=e.stackAlloc(8);e._OrtGetLastError(n,n+4);const B=e.HEAP32[n/4],s=e.HEAPU32[n/4+1],F=s?e.UTF8ToString(s):"";throw new Error(`${t} ERROR_CODE: ${B}, ERROR_MESSAGE: ${F}`)}finally{e.stackRestore(n)}}}}),setRunOptions,init_run_options=__esm({"web/lib/wasm/run-options.ts"(){init_wasm_factory(),init_wasm_utils(),setRunOptions=t=>{const e=getInstance();let n=0;const B=[],s=t||{};try{if(void 0===t?.logSeverityLevel)s.logSeverityLevel=2;else if("number"!=typeof t.logSeverityLevel||!Number.isInteger(t.logSeverityLevel)||t.logSeverityLevel<0||t.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${t.logSeverityLevel}`);if(void 0===t?.logVerbosityLevel)s.logVerbosityLevel=0;else if("number"!=typeof t.logVerbosityLevel||!Number.isInteger(t.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${t.logVerbosityLevel}`);void 0===t?.terminate&&(s.terminate=!1);let F=0;return void 0!==t?.tag&&(F=allocWasmString(t.tag,B)),n=e._OrtCreateRunOptions(s.logSeverityLevel,s.logVerbosityLevel,!!s.terminate,F),0===n&&checkLastError("Can't create run options."),void 0!==t?.extra&&iterateExtraOptions(t.extra,"",new WeakSet,((t,s)=>{const F=allocWasmString(t,B),Q=allocWasmString(s,B);0!==e._OrtAddRunConfigEntry(n,F,Q)&&checkLastError(`Can't set a run config entry: ${t} - ${s}.`)})),[n,B]}catch(t){throw 0!==n&&e._OrtReleaseRunOptions(n),B.forEach((t=>e._free(t))),t}}}}),getGraphOptimzationLevel,getExecutionMode,appendDefaultOptions,setExecutionProviders,setSessionOptions,init_session_options=__esm({"web/lib/wasm/session-options.ts"(){init_wasm_factory(),init_wasm_utils(),getGraphOptimzationLevel=t=>{switch(t){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"all":return 99;default:throw new Error(`unsupported graph optimization level: ${t}`)}},getExecutionMode=t=>{switch(t){case"sequential":return 0;case"parallel":return 1;default:throw new Error(`unsupported execution mode: ${t}`)}},appendDefaultOptions=t=>{t.extra||(t.extra={}),t.extra.session||(t.extra.session={});const e=t.extra.session;e.use_ort_model_bytes_directly||(e.use_ort_model_bytes_directly="1"),t.executionProviders&&t.executionProviders.some((t=>"webgpu"===("string"==typeof t?t:t.name)))&&(t.enableMemPattern=!1)},setExecutionProviders=(t,e,n)=>{for(const B of e){let e="string"==typeof B?B:B.name;switch(e){case"webnn":if(e="WEBNN","string"!=typeof B){const e=B;if(e?.deviceType){const B=allocWasmString("deviceType",n),s=allocWasmString(e.deviceType,n);0!==getInstance()._OrtAddSessionConfigEntry(t,B,s)&&checkLastError(`Can't set a session config entry: 'deviceType' - ${e.deviceType}.`)}if(e?.numThreads){let B=e.numThreads;("number"!=typeof B||!Number.isInteger(B)||B<0)&&(B=0);const s=allocWasmString("numThreads",n),F=allocWasmString(B.toString(),n);0!==getInstance()._OrtAddSessionConfigEntry(t,s,F)&&checkLastError(`Can't set a session config entry: 'numThreads' - ${e.numThreads}.`)}if(e?.powerPreference){const B=allocWasmString("powerPreference",n),s=allocWasmString(e.powerPreference,n);0!==getInstance()._OrtAddSessionConfigEntry(t,B,s)&&checkLastError(`Can't set a session config entry: 'powerPreference' - ${e.powerPreference}.`)}}break;case"webgpu":if(e="JS","string"!=typeof B){const e=B;if(e?.preferredLayout){if("NCHW"!==e.preferredLayout&&"NHWC"!==e.preferredLayout)throw new Error(`preferredLayout must be either 'NCHW' or 'NHWC': ${e.preferredLayout}`);const B=allocWasmString("preferredLayout",n),s=allocWasmString(e.preferredLayout,n);0!==getInstance()._OrtAddSessionConfigEntry(t,B,s)&&checkLastError(`Can't set a session config entry: 'preferredLayout' - ${e.preferredLayout}.`)}}break;case"wasm":case"cpu":continue;default:throw new Error(`not supported execution provider: ${e}`)}const s=allocWasmString(e,n);0!==getInstance()._OrtAppendExecutionProvider(t,s)&&checkLastError(`Can't append execution provider: ${e}.`)}},setSessionOptions=t=>{const e=getInstance();let n=0;const B=[],s=t||{};appendDefaultOptions(s);try{const t=getGraphOptimzationLevel(s.graphOptimizationLevel??"all"),F=getExecutionMode(s.executionMode??"sequential"),Q="string"==typeof s.logId?allocWasmString(s.logId,B):0,U=s.logSeverityLevel??2;if(!Number.isInteger(U)||U<0||U>4)throw new Error(`log serverity level is not valid: ${U}`);const i=s.logVerbosityLevel??0;if(!Number.isInteger(i)||i<0||i>4)throw new Error(`log verbosity level is not valid: ${i}`);const a="string"==typeof s.optimizedModelFilePath?allocWasmString(s.optimizedModelFilePath,B):0;if(n=e._OrtCreateSessionOptions(t,!!s.enableCpuMemArena,!!s.enableMemPattern,F,!!s.enableProfiling,0,Q,U,i,a),0===n&&checkLastError("Can't create session options."),s.executionProviders&&setExecutionProviders(n,s.executionProviders,B),s.freeDimensionOverrides)for(const[t,F]of Object.entries(s.freeDimensionOverrides)){if("string"!=typeof t)throw new Error(`free dimension override name must be a string: ${t}`);if("number"!=typeof F||!Number.isInteger(F)||F<0)throw new Error(`free dimension override value must be a non-negative integer: ${F}`);const s=allocWasmString(t,B);0!==e._OrtAddFreeDimensionOverride(n,s,F)&&checkLastError(`Can't set a free dimension override: ${t} - ${F}.`)}return void 0!==s.extra&&iterateExtraOptions(s.extra,"",new WeakSet,((t,s)=>{const F=allocWasmString(t,B),Q=allocWasmString(s,B);0!==e._OrtAddSessionConfigEntry(n,F,Q)&&checkLastError(`Can't set a session config entry: ${t} - ${s}.`)})),[n,B]}catch(t){throw 0!==n&&e._OrtReleaseSessionOptions(n),B.forEach((t=>e._free(t))),t}}}}),tensorDataTypeStringToEnum,tensorDataTypeEnumToString,getTensorElementSize,tensorTypeToTypedArrayConstructor,logLevelStringToEnum,isGpuBufferSupportedType,dataLocationStringToEnum,init_wasm_common=__esm({"web/lib/wasm/wasm-common.ts"(){tensorDataTypeStringToEnum=t=>{switch(t){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float16":return 10;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;default:throw new Error(`unsupported data type: ${t}`)}},tensorDataTypeEnumToString=t=>{switch(t){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 10:return"float16";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";default:throw new Error(`unsupported data type: ${t}`)}},getTensorElementSize=t=>[void 0,4,1,1,2,2,4,8,void 0,1,2,8,4,8,void 0,void 0,void 0][t],tensorTypeToTypedArrayConstructor=t=>{switch(t){case"float16":case"uint16":return Uint16Array;case"float32":return Float32Array;case"uint8":case"bool":return Uint8Array;case"int8":return Int8Array;case"int16":return Int16Array;case"int32":return Int32Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw new Error(`unsupported type: ${t}`)}},logLevelStringToEnum=t=>{switch(t){case"verbose":return 0;case"info":return 1;case"warning":return 2;case"error":return 3;case"fatal":return 4;default:throw new Error(`unsupported logging level: ${t}`)}},isGpuBufferSupportedType=t=>"float32"===t||"int32"===t||"int64"===t||"bool"===t||"float16"===t||"uint32"===t,dataLocationStringToEnum=t=>{switch(t){case"none":return 0;case"cpu":return 1;case"cpu-pinned":return 2;case"texture":return 3;case"gpu-buffer":return 4;default:throw new Error(`unsupported data location: ${t}`)}}}}),loadFile,init_wasm_utils_load_file=__esm({"web/lib/wasm/wasm-utils-load-file.ts"(){init_fs(),init_promises(),loadFile=async t=>{if("string"!=typeof t)return t instanceof Blob?new Uint8Array(await t.arrayBuffer()):t instanceof Uint8Array?t:new Uint8Array(t);if("undefined"==typeof process||!process.versions||!process.versions.node){const e=await fetch(t);if(!e.ok)throw new Error(`failed to load external data file: ${t}`);const n=e.headers.get("Content-Length"),B=n?parseInt(n,10):0;if(B<1073741824)return new Uint8Array(await e.arrayBuffer());{if(!e.body)throw new Error(`failed to load external data file: ${t}, no response body.`);const n=e.body.getReader();let s;try{s=new ArrayBuffer(B)}catch(t){if(!(t instanceof RangeError))throw t;{const t=Math.ceil(B/65536);s=new WebAssembly.Memory({initial:t,maximum:t}).buffer}}let F=0;for(;;){const{done:t,value:e}=await n.read();if(t)break;const B=e.byteLength;new Uint8Array(s,F,B).set(e),F+=B}return new Uint8Array(s,0,B)}}try{return new Uint8Array(await readFile(t))}catch(e){if("ERR_FS_FILE_TOO_LARGE"===e.code){const e=createReadStream(t),n=[];for await(const t of e)n.push(t);return new Uint8Array(Buffer.concat(n))}throw e}}}}),logLevelPrefix,doLog,configLogLevel,debug,configureLogger,LOG,LOG_DEBUG,init_log=__esm({"web/lib/wasm/jsep/log.ts"(){init_wasm_common(),logLevelPrefix=["V","I","W","E","F"],doLog=(t,e)=>{console.log(`[${logLevelPrefix[t]},${(new Date).toISOString()}]${e}`)},configureLogger=(t,e)=>{configLogLevel=t,debug=e},LOG=(t,e)=>{const n=logLevelStringToEnum(t);n>=logLevelStringToEnum(configLogLevel)&&doLog(n,"function"==typeof e?e():e)},LOG_DEBUG=(...t)=>{debug&&LOG(...t)}}}),createView2,init_tensor_view=__esm({"web/lib/wasm/jsep/tensor-view.ts"(){init_wasm_common(),createView2=(t,e)=>new(tensorTypeToTypedArrayConstructor(e))(t)}}),init_types2=__esm({"web/lib/wasm/jsep/webgpu/types.ts"(){}}),calcNormalizedBufferSize,guid,createNewGpuDataId,downloadGpuData,GpuDataManagerImpl,createGpuDataManager,init_gpu_data_manager=__esm({"web/lib/wasm/jsep/webgpu/gpu-data-manager.ts"(){init_log(),init_types2(),calcNormalizedBufferSize=t=>16*Math.ceil(t/16),guid=1,createNewGpuDataId=()=>guid++,downloadGpuData=async(t,e,n,B)=>{const s=calcNormalizedBufferSize(n),F=t.device.createBuffer({size:s,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ});try{const Q=t.getCommandEncoder();t.endComputePass(),Q.copyBufferToBuffer(e,0,F,0,s),t.flush(),await F.mapAsync(GPUMapMode.READ);const U=F.getMappedRange();if(B){const t=B();return t.set(new Uint8Array(U,0,n)),t}return new Uint8Array(U.slice(0,n))}finally{F.destroy()}},GpuDataManagerImpl=class{constructor(t){this.backend=t,this.storageCache=new Map,this.freeBuffers=new Map,this.freeUniformBuffers=new Map,this.buffersForUploadingPending=[],this.buffersPending=[],this.externalBuffers=new Map}upload(t,e){const n=e.buffer,B=e.byteOffset,s=e.byteLength,F=calcNormalizedBufferSize(s),Q=this.storageCache.get(t);if(!Q)throw new Error("gpu data for uploading does not exist");if(Q.originalSize!==s)throw new Error(`inconsistent data size. gpu data size=${Q.originalSize}, data size=${s}`);const U=this.backend.device.createBuffer({mappedAtCreation:!0,size:F,usage:GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC}),i=U.getMappedRange();new Uint8Array(i).set(new Uint8Array(n,B,s)),U.unmap();const a=this.backend.getCommandEncoder();this.backend.endComputePass(),a.copyBufferToBuffer(U,0,Q.gpuData.buffer,0,F),LOG_DEBUG("verbose",(()=>`[WebGPU] GpuDataManager.upload(id=${t})`)),this.buffersForUploadingPending.push(U)}memcpy(t,e){const n=this.storageCache.get(t);if(!n)throw new Error("source gpu data for memcpy does not exist");const B=this.storageCache.get(e);if(!B)throw new Error("destination gpu data for memcpy does not exist");if(n.originalSize!==B.originalSize)throw new Error("inconsistent source and destination gpu data size");const s=calcNormalizedBufferSize(n.originalSize),F=this.backend.getCommandEncoder();this.backend.endComputePass(),F.copyBufferToBuffer(n.gpuData.buffer,0,B.gpuData.buffer,0,s)}registerExternalBuffer(t,e,n){let B;if(n){if(B=this.externalBuffers.get(n),void 0===B)throw new Error("previous buffer is not registered");if(t===n)return LOG_DEBUG("verbose",(()=>`[WebGPU] GpuDataManager.registerExternalBuffer(size=${e}) => id=${B}, buffer is the same, skip.`)),B;this.externalBuffers.delete(n)}else B=createNewGpuDataId();return this.storageCache.set(B,{gpuData:{id:B,type:0,buffer:t},originalSize:e}),this.externalBuffers.set(t,B),LOG_DEBUG("verbose",(()=>`[WebGPU] GpuDataManager.registerExternalBuffer(size=${e}) => id=${B}, registered.`)),B}unregisterExternalBuffer(t){const e=this.externalBuffers.get(t);void 0!==e&&(this.storageCache.delete(e),this.externalBuffers.delete(t),LOG_DEBUG("verbose",(()=>`[WebGPU] GpuDataManager.unregisterExternalBuffer() => id=${e}`)))}create(t,e=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST){const n=calcNormalizedBufferSize(t);let B;const s=(e&GPUBufferUsage.STORAGE)===GPUBufferUsage.STORAGE,F=(e&GPUBufferUsage.UNIFORM)===GPUBufferUsage.UNIFORM;if(s||F){const t=s?this.freeBuffers:this.freeUniformBuffers;let F=t.get(n);F||(F=[],t.set(n,F)),B=F.length>0?F.pop():this.backend.device.createBuffer({size:n,usage:e})}else B=this.backend.device.createBuffer({size:n,usage:e});const Q={id:createNewGpuDataId(),type:0,buffer:B};return this.storageCache.set(Q.id,{gpuData:Q,originalSize:t}),LOG_DEBUG("verbose",(()=>`[WebGPU] GpuDataManager.create(size=${t}) => id=${Q.id}`)),Q}get(t){return this.storageCache.get(t)?.gpuData}release(t){const e=this.storageCache.get(t);if(!e)throw new Error("releasing data does not exist");return LOG_DEBUG("verbose",(()=>`[WebGPU] GpuDataManager.release(id=${t}), gpuDataId=${e.gpuData.id}`)),this.storageCache.delete(t),this.buffersPending.push(e.gpuData.buffer),e.originalSize}async download(t,e){const n=this.storageCache.get(t);if(!n)throw new Error("data does not exist");await downloadGpuData(this.backend,n.gpuData.buffer,n.originalSize,e)}refreshPendingBuffers(){for(const t of this.buffersForUploadingPending)t.destroy();this.buffersForUploadingPending=[];for(const t of this.buffersPending)(t.usage&GPUBufferUsage.STORAGE)===GPUBufferUsage.STORAGE?this.freeBuffers.get(t.size).push(t):(t.usage&GPUBufferUsage.UNIFORM)===GPUBufferUsage.UNIFORM?this.freeUniformBuffers.get(t.size).push(t):t.destroy();this.buffersPending=[]}dispose(){this.freeBuffers.forEach((t=>{t.forEach((t=>{t.destroy()}))})),this.freeUniformBuffers.forEach((t=>{t.forEach((t=>{t.destroy()}))})),this.storageCache.forEach((t=>{t.gpuData.buffer.destroy()})),this.storageCache=new Map,this.freeBuffers=new Map,this.freeUniformBuffers=new Map}},createGpuDataManager=(...t)=>new GpuDataManagerImpl(...t)}}),AttributeWithCacheKeyImpl2,createAttributeWithCacheKey2,init_attribute_with_cache_key2=__esm({"web/lib/wasm/jsep/webgpu/attribute-with-cache-key.ts"(){AttributeWithCacheKeyImpl2=class{constructor(t){Object.assign(this,t)}get cacheKey(){return this.key||(this.key=Object.getOwnPropertyNames(this).sort().map((t=>`${this[t]}`)).join(";")),this.key}},createAttributeWithCacheKey2=t=>new AttributeWithCacheKeyImpl2(t)}}),MatMulUtil2,BroadcastUtil2,ShapeUtil2,PoolConvUtil2,GemmUtil2,MIN_CLIP2,MAX_CLIP2,init_util2=__esm({"web/lib/wasm/jsep/util.ts"(){MatMulUtil2=class{static calcMatMulShape(t,e){return t[1]!==e[0]?void 0:[t[0],e[1]]}},BroadcastUtil2=class{static calcShape(t,e,n=!1){const B=t.length,s=e.length;if(0===B)return e;if(0===s)return t;const F=Math.max(t.length,e.length),Q=new Array(F);if(n){if(B<2||s<2)return;const n=MatMulUtil2.calcMatMulShape([t[B-2],t[B-1]],[e[s-2],e[s-1]]);if(void 0===n)return;[Q[F-2],Q[F-1]]=n}for(let U=n?3:1;U<=F;U++){const n=B-U<0?1:t[B-U],i=s-U<0?1:e[s-U];if(n!==i&&n>1&&i>1)return;Q[F-U]=Math.max(n,i)}return Q}static isValidBroadcast(t,e){const n=t.length,B=e.length;if(n>B)return!1;for(let s=1;s<=n;s++)if(1!==t[n-s]&&t[n-s]!==e[B-s])return!1;return!0}},ShapeUtil2=class t{static size(e){return t.getSizeFromDimensionRange(e,0,e.length)}static sizeFromDimension(e,n){if(n<0||n>e.length)throw new Error(`invalid dimension of ${n} for sizeFromDimension as Tensor has ${e.length} dimensions.`);return t.getSizeFromDimensionRange(e,n,e.length)}static sizeToDimension(e,n){if(n<0||n>e.length)throw new Error(`invalid dimension of ${n} for sizeToDimension as Tensor has ${e.length} dimensions.`);return t.getSizeFromDimensionRange(e,0,n)}static getSizeFromDimensionRange(t,e,n){let B=1;for(let s=e;s<n;s++){if(t[s]<0)throw new Error("cannot get valid size from specified dimension range. Most likely the range contains negative values in them.");B*=t[s]}return B}static computeStrides(t){const e=t.length;if(0===e)return[];if(1===e)return[1];const n=new Array(e);n[e-1]=1,n[e-2]=t[e-1];for(let B=e-3;B>=0;--B)n[B]=n[B+1]*t[B+1];return n}static normalizeAxis(t,e){if(t<-e&&t>=e)throw new Error("unsupported axis for this operation.");return t<0?t+e:t}static normalizeAxes(t,e){return t.map((n=>this.normalizeAxis(n,e??t.length)))}static sortBasedOnPerm(t,e){return e?e.map((e=>t[e])):t.slice().reverse()}static padShape(t,e){const n=t.length;return t.map(((t,B)=>t+e[B]+e[B+n]))}static areEqual(t,e){return t.length===e.length&&t.every(((t,n)=>t===e[n]))}},PoolConvUtil2=class t{static adjustPoolAttributes(t,e,n,B,s,F){if(!t&&n.length!==e.length-2)throw new Error("length of specified kernel shapes should be 2 less than length of input dimensions");if(t)for(let t=0;t<e.length-2;t++)t>=n.length?n.push(e[t+2]):n[t]=e[t+2];for(let t=0;t<n.length;t++)if(t<B.length){if(B[t]<0)throw new Error("strides should be greater than or equal to 1")}else B.push(1);for(let t=0;t<n.length;t++)if(t<s.length){if(s[t]<0)throw new Error("dilations should be greater than or equal to 1")}else s.push(1);for(let t=0;t<2*n.length;t++)if(t<F.length){if(F[t]<0)throw new Error("pad should be greater than or equal to 1")}else F.push(0);for(let t=0;t<n.length;t++){if(n[t]<=0)throw new Error("kernel shapes need to be greater than 0");if(F[t]>=n[t]||F[t+n.length]>=n[t])throw new Error("pads should be smaller than kernel")}}static adjustPadsBasedOnAutoPad(e,n,B,s,F,Q,U){if(U){if(F.length!==2*(e.length-2))throw new Error("length of pads should be twice the length of data dimensions");if(n.length!==e.length-2)throw new Error("length of strides should be the length of data dimensions");if(s.length!==e.length-2)throw new Error("length of kernel shapes should be the length of data dimensions");for(let i=0;i<e.length-2;i++)t.adjustPadAndReturnShape(e[i+(Q?1:2)],n[i],B[i],s[i],F,i,i+e.length-2,U)}}static computePoolOutputShape(e,n,B,s,F,Q,U){if(n.length<=0)throw new Error("input shape must be of size greater than 0");const i=[n[0],n[1]];return t.computeShapeHelper(e,n,i,B,s,F,Q,U),i}static computeConvOutputShape(e,n,B,s,F,Q,U){if(e.length<=0||n.length<=0)throw new Error("invalid input tensor dims or invalid filter tensor dims");const i=[e[0],n[0]];return t.computeShapeHelper(!1,e,i,B,s,F,Q,U),i}static computeShapeHelper(e,n,B,s,F,Q,U,i){if(e)for(let t=0;t<n.length-2;t++)B.push(1);else for(let e=0;e<n.length-2;e++)B.push(t.adjustPadAndReturnShape(n[e+2],s[e],F[e],Q[e],U,e,e+n.length-2,i))}static adjustPadAndReturnShape(t,e,n,B,s,F,Q,U){const i=n*(B-1)+1;if(!U||"NOTSET"===U)return Math.floor((t+s[F]+s[Q]-i)/e+1);switch(U){case"VALID":return s[F]=0,s[Q]=0,Math.floor((t-i)/e+1);case"SAME_LOWER":case"SAME_UPPER":if(1!==n)throw new Error("Dilation not supported for SAME_UPPER or SAME_LOWER");{const n=((t+e-1)/e-1)*e+B-t;return s[F]="SAME_LOWER"===U?Math.floor((n+1)/2):Math.floor(n/2),s[Q]=n-s[F],Math.floor((t+n-B)/e+1)}default:throw new Error("Unsupported AutoPad type")}}},GemmUtil2=class{static getShapeOfGemmResult(t,e,n,B,s){if(2!==t.length||2!==n.length)throw new Error("shape need to be of size 2");let F,Q,U;e?(F=t[1],Q=t[0]):(F=t[0],Q=t[1]);let i=-1;if(B?(U=n[0],i=1):(U=n[1],i=0),n[i]!==Q)throw new Error("dimension mismatch");if(F<=0||U<=0||Q<=0)throw new Error("invalid shape specified");if(s&&!BroadcastUtil2.isValidBroadcast(s,[F,U]))throw new Error("gemm: invalid bias shape for broadcast");return[F,U,Q]}},MIN_CLIP2=-34028234663852886e22,MAX_CLIP2=34028234663852886e22}}),WORKGROUP_SIZE,getWgslMappedType,tensorTypeToWsglStorageType,tensorTypeToWsglValueType,createTensorShapeVariables,getMaxComponents,fillVector,castToF32,sumVector,getElementAt,createIndicesHelper,inputVariable,outputVariable,internalVariable,ShaderHelperImpl,createShaderHelper,getBroadcastDims,enableShapesUniforms,init_common=__esm({"web/lib/wasm/jsep/webgpu/ops/common.ts"(){init_wasm_common(),init_util2(),WORKGROUP_SIZE=64,getWgslMappedType=(t,e)=>{if(3===e)throw new Error("vec3 has same alignment as vec4, use vec4 instead");switch(t){case 10:return e>1?`vec${e}<f16>`:"f16";case 1:return e>1?`vec${e}<f32>`:"f32";case 6:return e>1?`vec${e}<i32>`:"i32";case 12:return e>1?`vec${e}<u32>`:"u32";case 7:if(e>1)throw new Error("currently not supported vecX of uint64 yet");return["vec2<u32>","i32"];case 13:if(e>1)throw new Error("currently not supported vecX of uint64 yet");return["vec2<u32>","u32"];case 9:if(4!==e)throw new Error("bool must be vec4");return["u32","vec4<bool>"];default:throw new Error(`Unknown data type: ${t}`)}},tensorTypeToWsglStorageType=(t,e=1)=>{const n=getWgslMappedType(t,e);return"string"==typeof n?n:n[0]},tensorTypeToWsglValueType=(t,e=1)=>{const n=getWgslMappedType(t,e);return"string"==typeof n?n:n[1]},createTensorShapeVariables=t=>0===t.length?[]:[{type:"uint32",data:t},{type:"uint32",data:ShapeUtil2.computeStrides(t)}],getMaxComponents=t=>t%4==0?4:t%2==0?2:1,fillVector=(t="f32",e,n="0")=>e&&1!==e?`vec${e}<${t}>(${n})`:`${t}(${n})`,castToF32=(t,e,n)=>"f32"===t?n:1===e?`f32(${n})`:`vec${e}f(${n})`,sumVector=(t,e)=>4===e?`(${t}.x + ${t}.y + ${t}.z + ${t}.w)`:2===e?`(${t}.x + ${t}.y)`:3===e?`(${t}.x + ${t}.y + ${t}.z)`:t,getElementAt=(t,e,n)=>t.startsWith("uniforms.")&&n>4?"string"==typeof e?`${t}[(${e}) / 4][(${e}) % 4]`:`${t}[${Math.floor(e/4)}][${e%4}]`:n>1?`${t}[${e}]`:t,createIndicesHelper=(t,e,n,B,s)=>{const F="number"==typeof n,Q=F?n:n.length,U=[...new Array(Q).keys()],i=Q<2?"u32":Q<=4?`vec${Q}<u32>`:`array<u32, ${Q}>`,a=getWgslMappedType(e,s),l="string"==typeof a?a:a[1],c="string"==typeof a?a:a[0],g={indices:i,value:l,storage:c,tensor:e},d=t=>"string"==typeof t?t:`${t}u`,I={offsetToIndices:!1,indicesToOffset:!1,broadcastedIndicesToOffset:!1,set:!1,setByIndices:!1,get:!1,getByIndices:!1},o=F?"uniforms.":"",r=`${o}${t}_shape`,u=`${o}${t}_strides`;let b="";for(let t=0;t<Q-1;t++)b+=`\n    let dim${t} = current / ${getElementAt(u,t,Q)};\n    let rest${t} = current % ${getElementAt(u,t,Q)};\n    indices[${t}] = dim${t};\n    current = rest${t};\n    `;b+=`indices[${Q-1}] = current;`;const C=Q<2?"":`\n  fn o2i_${t}(offset: u32) -> ${g.indices} {\n    var indices: ${g.indices};\n    var current = offset;\n    ${b}\n    return indices;\n  }`,p=[];if(Q>=2)for(let t=Q-1;t>=0;t--)p.push(`${getElementAt(u,t,Q)} * (indices[${t}])`);const m=Q<2?"":`\n  fn i2o_${t}(indices: ${g.indices}) -> u32 {\n    return ${p.join("+")};\n  }`,G=(...t)=>0===Q?"0u":`${g.indices}(${t.map(d).join(",")})`,V=(t,e)=>Q<2?`${t}`:`${getElementAt(t,e,Q)}`,x={},h=(e,n)=>(()=>{if(g.storage===g.value)return`${t}[${e}]=${n};`;if("vec2<u32>"===g.storage&&"i32"===g.value)return`${t}[${e}]=vec2<u32>(u32(${n}), select(0u, 0xFFFFFFFFu, ${n} < 0));`;if("vec2<u32>"===g.storage&&"u32"===g.value)return`${t}[${e}]=vec2<u32>(u32(${n}), 0u);`;if("u32"===g.storage&&"vec4<bool>"===g.value)return`${t}[${e}]=dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(${n}));`;throw new Error(`not supported combination of storage type ${g.storage} and value type ${g.value} yet`)})(),Z=e=>(()=>{if(g.storage===g.value)return`${t}[${e}]`;if("vec2<u32>"===g.storage&&"i32"===g.value)return`i32(${t}[${e}].x)`;if("vec2<u32>"===g.storage&&"u32"===g.value)return`u32(${t}[${e}].x)`;if("u32"===g.storage&&"vec4<bool>"===g.value)return`vec4<bool>(bool(${t}[${e}] & 0xFFu), bool(${t}[${e}] & 0xFF00u), bool(${t}[${e}] & 0xFF0000u), bool(${t}[${e}] & 0xFF000000u))`;throw new Error(`not supported combination of storage type ${g.storage} and value type ${g.value} yet`)})(),S=Q<2?"":`\n  fn get_${t}ByIndices(indices: ${g.indices}) -> ${l} {\n    return ${Z(`i2o_${t}(indices)`)};\n  }`,y=Q<2?"":(()=>{const e=U.map((t=>`d${t}: u32`)).join(", "),n=U.map((t=>`d${t}`)).join(", ");return`\n  fn get_${t}(${e}) -> ${l} {\n    return get_${t}ByIndices(${G(n)});\n  }`})(),A=Q<2?"":`\n  fn set_${t}ByIndices(indices: ${g.indices}, value: ${l}) {\n    ${h(`i2o_${t}(indices)`,"value")}\n  }`,X=Q<2?"":(()=>{const e=U.map((t=>`d${t}: u32`)).join(", "),n=U.map((t=>`d${t}`)).join(", ");return`\n  fn set_${t}(${e}, value: ${l}) {\n    set_${t}ByIndices(${G(n)}, value);\n  }`})();return{impl:()=>{const t=[];let e=!1;return I.offsetToIndices&&(t.push(C),e=!0),I.indicesToOffset&&(t.push(m),e=!0),I.broadcastedIndicesToOffset&&(Object.values(x).forEach((e=>t.push(e))),e=!0),I.set&&(t.push(X),e=!0),I.setByIndices&&(t.push(A),e=!0),I.get&&(t.push(y),e=!0),I.getByIndices&&(t.push(S),e=!0),!F&&e&&t.unshift(`const ${r} = ${g.indices}(${n.join(",")});`,`const ${u} = ${g.indices}(${ShapeUtil2.computeStrides(n).join(",")});`),t.join("\n")},type:g,offsetToIndices:e=>(I.offsetToIndices=!0,Q<2?e:`o2i_${t}(${e})`),indicesToOffset:e=>(I.indicesToOffset=!0,Q<2?e:`i2o_${t}(${e})`),broadcastedIndicesToOffset:(e,n)=>{I.broadcastedIndicesToOffset=!0;const B=`${n.name}broadcastedIndicesTo${t}Offset`;if(B in x)return`${B}(${e})`;const s=[];for(let t=Q-1;t>=0;t--){const e=n.indicesGet("outputIndices",t+n.rank-Q);s.push(`${V(u,t)} * (${e} % ${V(r,t)})`)}return x[B]=`fn ${B}(outputIndices: ${n.type.indices}) -> u32 {\n             return ${s.length>0?s.join("+"):"0u"};\n           }`,`${B}(${e})`},indices:G,indicesGet:V,indicesSet:(t,e,n)=>Q<2?`${t}=${n};`:`${getElementAt(t,e,Q)}=${n};`,set:(...e)=>{if(e.length!==Q+1)throw new Error(`indices length must be ${Q}`);const n=e[Q];if("string"!=typeof n)throw new Error("value must be string");const B=e.slice(0,Q).map(d).join(",");return 0===Q?h("0u",n):1===Q?h(B[0],n):(I.set=!0,I.setByIndices=!0,I.indicesToOffset=!0,`set_${t}(${B}, ${n})`)},setByOffset:h,setByIndices:(e,n)=>Q<2?h(e,n):(I.setByIndices=!0,I.indicesToOffset=!0,`set_${t}ByIndices(${e}, ${n});`),get:(...e)=>{if(e.length!==Q)throw new Error(`indices length must be ${Q}`);const n=e.map(d).join(",");return 0===Q?Z("0u"):1===Q?Z(n[0]):(I.get=!0,I.getByIndices=!0,I.indicesToOffset=!0,`get_${t}(${n})`)},getByOffset:Z,getByIndices:e=>Q<2?Z(e):(I.getByIndices=!0,I.indicesToOffset=!0,`get_${t}ByIndices(${e})`),usage:B,name:t,strides:u,shape:r,rank:Q}},inputVariable=(t,e,n,B=1)=>createIndicesHelper(t,e,n,"input",B),outputVariable=(t,e,n,B=1)=>createIndicesHelper(t,e,n,"output",B),internalVariable=(t,e,n,B=1)=>createIndicesHelper(t,e,n,"internal",B),ShaderHelperImpl=class{constructor(t){this.normalizedDispatchGroup=t,this.internalVariables=[],this.variables=[],this.uniforms=[],this.variableIndex=0}guardAgainstOutOfBoundsWorkgroupSizes(t){return`if (global_idx >= ${"number"==typeof t?`${t}u`:t}) { return; }`}mainStart(t=WORKGROUP_SIZE){const e="number"==typeof t?t:t[0],n="number"==typeof t?1:t[1],B="number"==typeof t?1:t[2],s=1===this.normalizedDispatchGroup[1]&&1===this.normalizedDispatchGroup[2];return`@compute @workgroup_size(${e}, ${n}, ${B})\n  fn main(${s?"@builtin(global_invocation_id) global_id : vec3<u32>,\n    @builtin(workgroup_id) workgroup_id : vec3<u32>,\n    @builtin(local_invocation_id) local_id : vec3<u32>":"@builtin(local_invocation_id) local_id : vec3<u32>,\n    @builtin(local_invocation_index) local_idx : u32,\n    @builtin(workgroup_id) workgroup_id : vec3<u32>,\n    @builtin(num_workgroups) num_workgroups : vec3<u32>"}) {\n    ${s?"let global_idx = global_id.x; let local_idx = local_id.x;":`let global_idx = (workgroup_id.z * num_workgroups[0] * num_workgroups[1] +\n          workgroup_id.y * num_workgroups[0] + workgroup_id.x) * ${e*n*B}u + local_idx;`}\n  `}appendVariableUniforms(t){0!==t.rank&&(t.shape.startsWith("uniforms.")&&this.uniforms.push({name:t.shape.replace("uniforms.",""),type:"u32",length:t.rank}),t.strides.startsWith("uniforms.")&&this.uniforms.push({name:t.strides.replace("uniforms.",""),type:"u32",length:t.rank}))}declareVariable(t,e){if("internal"===t.usage)throw new Error("cannot use internal variable with declareVariable(). use registerInternalVariables() instead.");this.variables.push(t),this.appendVariableUniforms(t);const n="input"===t.usage?"read":"read_write",B=t.type.storage;return`@group(0) @binding(${e}) var<storage, ${n}> ${t.name}: array<${B}>;`}declareVariables(...t){return t.map((t=>this.declareVariable(t,this.variableIndex++))).join("\n")}registerInternalVariable(t){if("internal"!==t.usage)throw new Error("cannot use input or output variable with registerInternalVariable(). use declareVariables() instead.");this.internalVariables.push(t),this.appendVariableUniforms(t)}registerInternalVariables(...t){return t.forEach((t=>this.registerInternalVariable(t))),this}registerUniform(t,e,n=1){return this.uniforms.push({name:t,type:e,length:n}),this}registerUniforms(t){return this.uniforms=this.uniforms.concat(t),this}uniformDeclaration(){if(0===this.uniforms.length)return"";const t=[];for(const{name:e,type:n,length:B}of this.uniforms)if(B&&B>4)t.push(`${e}:array<vec4<${n}>, ${Math.ceil(B/4)}>`);else{const s=null==B||1===B?n:`vec${B}<${n}>`;t.push(`${e}:${s}`)}return`\n      struct Uniforms { ${t.join(", ")} };\n      @group(0) @binding(${this.variableIndex}) var<uniform> uniforms: Uniforms;`}get additionalImplementations(){return this.uniformDeclaration()+this.variables.map((t=>t.impl())).join("\n")+this.internalVariables.map((t=>t.impl())).join("\n")}},createShaderHelper=t=>new ShaderHelperImpl(t),getBroadcastDims=(t,e)=>{const n=t.length,B=[];for(let s=0;s<n;s++){const F=n-1-s,Q=t[F]||1;(e[e.length-1-s]||1)>1&&1===Q&&B.unshift(F)}return B},enableShapesUniforms=t=>!0}}),validateInputs26,getAdjustedPerm2,getOutputShape2,permFunctionBody,createTransposeProgramInfo2,transpose2,parseTransposeAttributes2,init_transpose2=__esm({"web/lib/wasm/jsep/webgpu/ops/transpose.ts"(){init_util2(),init_attribute_with_cache_key2(),init_common(),validateInputs26=t=>{if(!t||1!==t.length)throw new Error("Transpose requires 1 input.")},getAdjustedPerm2=(t,e)=>e&&e.length!==t?[...new Array(t).keys()].reverse():e,getOutputShape2=(t,e)=>ShapeUtil2.sortBasedOnPerm(t,getAdjustedPerm2(t.length,e)),permFunctionBody=(t,e,n,B)=>{const s=[];s.push(`fn perm(i: ${B.type.indices}) -> ${n.type.indices} {\n    var a: ${n.type.indices};`);for(let B=0;B<e;++B)s.push(n.indicesSet("a",t[B],`i[${B}]`));return s.push("return a;}"),s.join("\n")},createTransposeProgramInfo2=(t,e)=>{const n=t.dataType,B=t.dims.length,s=getAdjustedPerm2(B,e),F=enableShapesUniforms(B),Q=getOutputShape2(t.dims,s),U=F?Q.length:Q,i=F?B:t.dims,a=outputVariable("output",n,U),l=inputVariable("a",n,i);return{name:"Transpose",shaderCache:{hint:`${e}`,inputDependencies:F?["rank"]:["dims"]},getRunData:t=>{const e=ShapeUtil2.size(Q);return{outputs:[{dims:Q,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(e/64)},programUniforms:F?[{type:"uint32",data:e},...createTensorShapeVariables(t[0].dims),...createTensorShapeVariables(Q)]:[{type:"uint32",data:e}]}},getShaderSource:t=>`\n  ${t.registerUniform("output_size","u32").declareVariables(l,a)}\n\n  ${permFunctionBody(s,B,l,a)}\n\n  ${t.mainStart()}\n    ${t.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n\n    let indices = ${a.offsetToIndices("global_idx")};\n    let aIndices = perm(indices);\n\n    ${a.setByOffset("global_idx",l.getByIndices("aIndices"))}\n  }`}},transpose2=(t,e)=>{validateInputs26(t.inputs),t.compute(createTransposeProgramInfo2(t.inputs[0],e.perm))},parseTransposeAttributes2=t=>createAttributeWithCacheKey2({perm:t.perm})}}),reduceOps,reduceSharedOps,reduceInitValues,reduceOutputValues,getInnerMostAxes,computeOutAndReduceShapes,expandShapeToKeepDim,areAxesInnerMostDims,getAxesPermutation,createReduceSharedProgramInfo,reduceCommon,reduceMeanShared,reduceL1Shared,reduceL2Shared,reduceLogSumExpShared,reduceMaxShared,reduceMinShared,reduceProdShared,reduceSumShared,reduceSumSquareShared,reduceLogSumShared,init_reduce_shared=__esm({"web/lib/wasm/jsep/webgpu/ops/reduce-shared.ts"(){init_util2(),init_common(),init_reduce2(),init_transpose2(),reduceOps={max:"select(bestValue, candidate, candidate > bestValue)",min:"select(bestValue, candidate, candidate < bestValue)",mean:"bestValue + candidate",sum:"bestValue + candidate",prod:"bestValue * candidate",sumSquare:"bestValue + candidate * candidate",logSumExp:"bestValue + exp(candidate)",l1:"bestValue + abs(candidate)",l2:"bestValue + candidate * candidate",logSum:"bestValue + candidate"},reduceSharedOps={max:"select(bestValue, candidate, candidate > bestValue)",min:"select(bestValue, candidate, candidate < bestValue)",mean:"bestValue + candidate",sum:"bestValue + candidate",prod:"bestValue * candidate",sumSquare:"bestValue + candidate",logSumExp:"bestValue + candidate",l1:"bestValue + candidate",l2:"bestValue + candidate",logSum:"bestValue + candidate"},reduceInitValues={max:"_A[offset]",min:"_A[offset]",mean:"0",sum:"0",prod:"1",sumSquare:"0",logSumExp:"0",l1:"0",l2:"0",logSum:"0"},reduceOutputValues={max:"bestValue",min:"bestValue",sum:"bestValue",prod:"bestValue",sumSquare:"bestValue",logSumExp:"log(bestValue)",l1:"bestValue",l2:"sqrt(bestValue)",logSum:"log(bestValue)"},getInnerMostAxes=(t,e)=>{const n=[];for(let B=e-t;B<e;++B)n.push(B);return n},computeOutAndReduceShapes=(t,e)=>{const n=[],B=t.length;for(let s=0;s<B;s++)-1===e.indexOf(s)&&n.push(t[s]);return[n,e.map((e=>t[e]))]},expandShapeToKeepDim=(t,e)=>{const n=t.length+e.length,B=[];let s=0;for(let F=0;F<n;F++)-1===e.indexOf(F)?B.push(t[s++]):B.push(1);return B},areAxesInnerMostDims=(t,e)=>{for(let n=0;n<t.length;++n)if(t[t.length-n-1]!==e-1-n)return!1;return!0},getAxesPermutation=(t,e)=>{const n=[];if(!areAxesInnerMostDims(t,e)){for(let B=0;B<e;++B)-1===t.indexOf(B)&&n.push(B);t.forEach((t=>n.push(t)))}return n},createReduceSharedProgramInfo=(t,e,n,B,s,F,Q)=>{const U=n[0].dims,i=ShapeUtil2.size(F),a=ShapeUtil2.size(Q),l=inputVariable("_A",n[0].dataType,U),c=outputVariable("output",s,F),g=`\n          var<workgroup> aBestValues : array<${c.type.storage}, 32>;\n       `;return{name:t,shaderCache:e,getShaderSource:t=>`\n        ${t.registerUniform("reduceSize","u32").declareVariables(l,c)}\n        ${g}\n        fn DIV_CEIL(a : u32, b : u32) -> u32 {\n          return ((a - 1u) / b + 1u);\n         }\n         ${t.mainStart(32)}\n\n          let outputIndex = global_idx / 32;\n          let offset = outputIndex * uniforms.reduceSize;\n\n          var bestValue = ${c.type.storage}(${reduceInitValues[B]});\n          let Length = uniforms.reduceSize;\n          for (var k = local_idx; k < Length; k = k + 32) {\n           let candidate = ${c.type.storage}(${l.getByOffset("offset + k")});\n           bestValue = ${reduceOps[B]};\n          }\n          aBestValues[local_idx] = bestValue;\n          workgroupBarrier();\n\n         var reduceSize = min(Length, 32u);\n         for (var currentSize = reduceSize / 2u; reduceSize > 1u;\n             currentSize = reduceSize / 2u) {\n           let interval = DIV_CEIL(reduceSize, 2u);\n           if (local_idx < currentSize) {\n            let candidate = aBestValues[local_idx + interval];\n            bestValue = ${reduceSharedOps[B]};\n            aBestValues[local_idx] = bestValue;\n           }\n           reduceSize = interval;\n           workgroupBarrier();\n         }\n\n         if (local_idx == 0u) {\n          ${c.setByOffset("outputIndex",""+("mean"===B?`bestValue / ${c.type.storage}(uniforms.reduceSize)`:`${reduceOutputValues[B]}`))};\n         }\n        }`,getRunData:()=>({outputs:[{dims:F,dataType:s}],dispatchGroup:{x:i},programUniforms:[{type:"uint32",data:a}]})}},reduceCommon=(t,e,n,B)=>{const s=1===t.inputs.length?n:createReduceAttributesFromInputs(t.inputs,n);let F=s.axes;0!==F.length||s.noopWithEmptyAxes||(F=t.inputs[0].dims.map(((t,e)=>e)));const Q=ShapeUtil2.normalizeAxes(F,t.inputs[0].dims.length);let U=Q,i=t.inputs[0];const a=getAxesPermutation(U,t.inputs[0].dims.length);a.length>0&&(i=t.compute(createTransposeProgramInfo2(t.inputs[0],a),{inputs:[0],outputs:[-1]})[0],U=getInnerMostAxes(U.length,i.dims.length));const[l,c]=computeOutAndReduceShapes(i.dims,U);let g=l;s.keepDims&&(g=expandShapeToKeepDim(l,Q)),t.compute(createReduceSharedProgramInfo(e,{hint:s.cacheKey,inputDependencies:["type"]},[i],B,t.inputs[0].dataType,g,c),{inputs:[i]})},reduceMeanShared=(t,e)=>{reduceCommon(t,"ReduceMeanShared",e,"mean")},reduceL1Shared=(t,e)=>{reduceCommon(t,"ReduceL1Shared",e,"l1")},reduceL2Shared=(t,e)=>{reduceCommon(t,"ReduceL2Shared",e,"l2")},reduceLogSumExpShared=(t,e)=>{reduceCommon(t,"ReduceLogSumExpShared",e,"logSumExp")},reduceMaxShared=(t,e)=>{reduceCommon(t,"ReduceMaxShared",e,"max")},reduceMinShared=(t,e)=>{reduceCommon(t,"ReduceMinShared",e,"min")},reduceProdShared=(t,e)=>{reduceCommon(t,"ReduceProdShared",e,"prod")},reduceSumShared=(t,e)=>{reduceCommon(t,"ReduceSumShared",e,"sum")},reduceSumSquareShared=(t,e)=>{reduceCommon(t,"ReduceSumSquareShared",e,"sumSquare")},reduceLogSumShared=(t,e)=>{reduceCommon(t,"ReduceLogSumShared",e,"logSum")}}}),validateInputs27,noOp,createReduceProgramInfo2,createReduceAttributesFromInputs,runReduceProgram,reduceLogSumNaive,reduceL1Naive,reduceL2Naive,reduceLogSumExpNaive,reduceMaxNaive,reduceMeanNaive,reduceMinNaive,reduceProdNaive,reduceSumNaive,reduceSumSquareNaive,useNaiveReduceMethod,reduceMean2,reduceL1,reduceL2,reduceLogSumExp,reduceMax2,reduceMin2,reduceProd2,reduceSum2,reduceSumSquare,reduceLogSum2,init_reduce2=__esm({"web/lib/wasm/jsep/webgpu/ops/reduce.ts"(){init_util2(),init_attribute_with_cache_key2(),init_common(),init_reduce_shared(),validateInputs27=t=>{if(!t||0===t.length||t.length>2)throw new Error("Reduce op requires 1 or 2 inputs.");if(2===t.length&&1!==t[1].dims.length)throw new Error("Invalid axes input dims.")},noOp=t=>["","",`var value = ${t.getByIndices("input_indices")};`,""],createReduceProgramInfo2=(t,e,n,B,s,F,Q=!1,U=!1)=>{const i=[],a=n[0].dims,l=a.length,c=ShapeUtil2.normalizeAxes(s,l),g=!U&&0===c.length;a.forEach(((t,e)=>{g||c.indexOf(e)>=0?Q&&i.push(1):i.push(t)}));const d=i.length,I=ShapeUtil2.size(i);return{name:t,shaderCache:e,getShaderSource:t=>{const e=[],s=inputVariable("_A",n[0].dataType,l),U=outputVariable("output",F,d),i=B(s,U,c);let I=i[2];for(let t=0,n=0;t<l;t++)g||c.indexOf(t)>=0?(Q&&n++,I=`for(var j${t}: u32 = 0; j${t} < ${a[t]}; j${t}++) {\n                  ${i[2].includes("last_index")?`let last_index = j${t};`:""}\n                  ${s.indicesSet("input_indices",t,`j${t}`)}\n                  ${I}\n                }`):(e.push(`${s.indicesSet("input_indices",t,U.indicesGet("output_indices",n))};`),n++);return`\n\n        ${t.registerUniform("output_size","u32").declareVariables(s,U)}\n\n        ${t.mainStart()}\n          ${t.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n          var input_indices: ${s.type.indices};\n          let output_indices = ${U.offsetToIndices("global_idx")};\n\n          ${e.join("\n")}\n          ${i[0]}       // init ops for reduce max/min\n          ${i[1]}\n          ${I}\n          ${i[3]}\n          ${4===i.length?U.setByOffset("global_idx","value"):i.slice(4).join("\n")}\n        }`},getRunData:()=>({outputs:[{dims:i,dataType:F}],dispatchGroup:{x:Math.ceil(I/64)},programUniforms:[{type:"uint32",data:I},...createTensorShapeVariables(a),...createTensorShapeVariables(i)]})}},createReduceAttributesFromInputs=(t,e)=>{const n=[];return t[1].dims[0]>0&&t[1].getBigInt64Array().forEach((t=>n.push(Number(t)))),createAttributeWithCacheKey2({axes:n,keepDims:e.keepDims,noopWithEmptyAxes:e.noopWithEmptyAxes})},runReduceProgram=(t,e,n,B)=>{const s=t.inputs,F=1===s.length?n:createReduceAttributesFromInputs(s,n);t.compute(createReduceProgramInfo2(e,{hint:F.cacheKey,inputDependencies:["rank"]},[s[0]],F.noopWithEmptyAxes&&0===F.axes.length?noOp:B,F.axes,s[0].dataType,F.keepDims,F.noopWithEmptyAxes),{inputs:[0]})},reduceLogSumNaive=(t,e)=>{validateInputs27(t.inputs);runReduceProgram(t,"ReduceLogSum",e,((t,e)=>[`var value = ${e.type.storage}(0);`,"",`value += ${t.getByIndices("input_indices")};`,"value = log(value);"]))},reduceL1Naive=(t,e)=>{validateInputs27(t.inputs);runReduceProgram(t,"ReduceL1",e,((t,e)=>[`var value = ${e.type.storage}(0);`,"",`value += abs(${t.getByIndices("input_indices")});`,""]))},reduceL2Naive=(t,e)=>{validateInputs27(t.inputs);runReduceProgram(t,"ReduceL2",e,((t,e)=>[`var t = ${e.type.value}(0); var value = ${e.type.value}(0);`,"",`t = ${t.getByIndices("input_indices")}; value += (t * t);`,"value = sqrt(value);"]))},reduceLogSumExpNaive=(t,e)=>{validateInputs27(t.inputs);runReduceProgram(t,"ReduceLogSumExp",e,((t,e)=>[`var value = ${e.type.storage}(0);`,"",`value += exp(${t.getByIndices("input_indices")});`,"value = log(value);"]))},reduceMaxNaive=(t,e)=>{validateInputs27(t.inputs);runReduceProgram(t,"ReduceMax",e,((t,e,n)=>{const B=[];for(let e=0;e<t.rank;e++)(n.indexOf(e)>=0||0===n.length)&&B.push(t.indicesSet("input_indices",e,0));return[`${B.join("\n")}`,`var value = ${t.getByIndices("input_indices")};`,`value = max(value, ${t.getByIndices("input_indices")});`,""]}))},reduceMeanNaive=(t,e)=>{validateInputs27(t.inputs);runReduceProgram(t,"ReduceMean",e,((e,n,B)=>{let s=1;for(let n=0;n<e.rank;n++)(B.indexOf(n)>=0||0===B.length)&&(s*=t.inputs[0].dims[n]);return["var sum = f32(0);","",`sum += f32(${e.getByIndices("input_indices")});`,`let value = ${n.type.value}(sum / ${s});`]}))},reduceMinNaive=(t,e)=>{validateInputs27(t.inputs);runReduceProgram(t,"ReduceMin",e,((t,e,n)=>{const B=[];for(let e=0;e<t.rank;e++)(n.indexOf(e)>=0||0===n.length)&&B.push(`input_indices[${e}] = 0;`);return[`${B.join("\n")}`,`var value = ${t.getByIndices("input_indices")};`,`value = min(value, ${t.getByIndices("input_indices")});`,""]}))},reduceProdNaive=(t,e)=>{validateInputs27(t.inputs);runReduceProgram(t,"ReduceProd",e,((t,e)=>[`var value = ${e.type.storage}(1);`,"",`value *= ${t.getByIndices("input_indices")};`,""]))},reduceSumNaive=(t,e)=>{validateInputs27(t.inputs);runReduceProgram(t,"ReduceSum",e,((t,e)=>[`var value = ${e.type.storage}(0);`,"",`value += ${t.getByIndices("input_indices")};`,""]))},reduceSumSquareNaive=(t,e)=>{validateInputs27(t.inputs);runReduceProgram(t,"ReduceSumSquare",e,((t,e)=>[`var t = ${e.type.value}(0); var value = ${e.type.value}(0);`,"",`t = ${t.getByIndices("input_indices")}; value += t * t;`,""]))},useNaiveReduceMethod=(t,e,n)=>{if(0===e.length)return n;let B=1,s=1;for(let n=0;n<e.length;n++)-1===e.indexOf(n)?B*=t[n]:s*=t[n];return s<32&&B>1024},reduceMean2=(t,e)=>{useNaiveReduceMethod(t.inputs[0].dims,e.axes,e.noopWithEmptyAxes)?reduceMeanNaive(t,e):reduceMeanShared(t,e)},reduceL1=(t,e)=>{useNaiveReduceMethod(t.inputs[0].dims,e.axes,e.noopWithEmptyAxes)?reduceL1Naive(t,e):reduceL1Shared(t,e)},reduceL2=(t,e)=>{useNaiveReduceMethod(t.inputs[0].dims,e.axes,e.noopWithEmptyAxes)?reduceL2Naive(t,e):reduceL2Shared(t,e)},reduceLogSumExp=(t,e)=>{useNaiveReduceMethod(t.inputs[0].dims,e.axes,e.noopWithEmptyAxes)?reduceLogSumExpNaive(t,e):reduceLogSumExpShared(t,e)},reduceMax2=(t,e)=>{useNaiveReduceMethod(t.inputs[0].dims,e.axes,e.noopWithEmptyAxes)?reduceMaxNaive(t,e):reduceMaxShared(t,e)},reduceMin2=(t,e)=>{useNaiveReduceMethod(t.inputs[0].dims,e.axes,e.noopWithEmptyAxes)?reduceMinNaive(t,e):reduceMinShared(t,e)},reduceProd2=(t,e)=>{useNaiveReduceMethod(t.inputs[0].dims,e.axes,e.noopWithEmptyAxes)?reduceProdNaive(t,e):reduceProdShared(t,e)},reduceSum2=(t,e)=>{useNaiveReduceMethod(t.inputs[0].dims,e.axes,e.noopWithEmptyAxes)?reduceSumNaive(t,e):reduceSumShared(t,e)},reduceSumSquare=(t,e)=>{useNaiveReduceMethod(t.inputs[0].dims,e.axes,e.noopWithEmptyAxes)?reduceSumSquareNaive(t,e):reduceSumSquareShared(t,e)},reduceLogSum2=(t,e)=>{useNaiveReduceMethod(t.inputs[0].dims,e.axes,e.noopWithEmptyAxes)?reduceLogSumNaive(t,e):reduceLogSumShared(t,e)}}}),validateInputs28,argMin,argMax,parseArgMinMaxAttributes,init_argminmax=__esm({"web/lib/wasm/jsep/webgpu/ops/argminmax.ts"(){init_wasm_common(),init_attribute_with_cache_key2(),init_reduce2(),validateInputs28=t=>{if(!t||0===t.length||t.length>2)throw new Error("ArgMinMaxOp op requires 1 or 2 inputs.");if(1!==t[0].dataType)throw new Error("Invalid input type.")},argMin=(t,e)=>{validateInputs28(t.inputs);t.compute(createReduceProgramInfo2("ArgMin",{hint:e.cacheKey,inputDependencies:["rank"]},[t.inputs[0]],((t,n,B)=>{const s=[];for(let e=0;e<t.rank;e++)(B.indexOf(e)>=0||0===B.length)&&s.push(`input_indices[${e}] = 0;`);return[`${s.join("\n")}`,`var value = ${t.getByIndices("input_indices")};\nvar best_index : i32 = 0;`,`if (${t.getByIndices("input_indices")} ${e.selectLastIndex>0?"<=":"<"} value) {\n         value = ${t.getByIndices("input_indices")};\n         best_index = i32(last_index);\n       }`,"",n.setByOffset("global_idx","best_index")]}),[e.axis],7,e.keepDims),{inputs:[0]})},argMax=(t,e)=>{validateInputs28(t.inputs);t.compute(createReduceProgramInfo2("argMax",{hint:e.cacheKey,inputDependencies:["rank"]},[t.inputs[0]],((t,n,B)=>{const s=[];for(let e=0;e<t.rank;e++)(B.indexOf(e)>=0||0===B.length)&&s.push(`input_indices[${e}] = 0;`);return[`${s.join("\n")}`,`var value = ${t.getByIndices("input_indices")};\nvar best_index : i32 = 0;`,`if (${t.getByIndices("input_indices")} ${e.selectLastIndex>0?">=":">"} value) {\n         value = ${t.getByIndices("input_indices")};\n         best_index = i32(last_index);\n       }`,"",n.setByOffset("global_idx","best_index")]}),[e.axis],7,e.keepDims),{inputs:[0]})},parseArgMinMaxAttributes=t=>createAttributeWithCacheKey2(t)}}),validateAttentionInputs,computeInPlaceSoftmax,computeAttentionProbs,computeVxAttentionScore,applyAttention,prepare,attention,init_attention=__esm({"web/lib/wasm/jsep/webgpu/ops/attention.ts"(){init_wasm_common(),init_types2(),init_common(),validateAttentionInputs=(t,e)=>{const n=t[0],B=t[1],s=t[2],F=t[3],Q=t[4],U=t[5];if(Q&&U)throw new Error("Attention cannot have both past and relative_position_bias");if(3!==n.dims.length)throw new Error('Input "input" must have 3 dimensions');const i=n.dims[0],a=n.dims[1],l=n.dims[2];if(1!==s.dims.length)throw new Error('Input "bias" is expected to have 1 dimensions');if(2!==B.dims.length)throw new Error('Input "weights" is expected to have 2 dimensions');if(B.dims[0]!==l)throw new Error("Input 1 dimension 0 should have same length as dimension 2 of input 0");if(s.dims[0]!==B.dims[1])throw new Error('Input "bias" dimension 0 should have same length as dimension 1 of input "weights"');let c=s.dims[0]/3,g=c,d=g;if(e.qkvHiddenSizes.length>0){if(3!==e.qkvHiddenSizes.length)throw new Error("qkv_hidden_sizes attribute should have 3 elements");for(const t of e.qkvHiddenSizes)if(t%e.numHeads!=0)throw new Error("qkv_hidden_sizes should be divisible by num_heads");c=e.qkvHiddenSizes[0],g=e.qkvHiddenSizes[1],d=e.qkvHiddenSizes[2]}const I=a;if(c!==g)throw new Error("qkv_hidden_sizes first element should be same as the second");if(s.dims[0]!==c+g+d)throw new Error('Input "bias" dimension 0 should have same length as sum of Q/K/V hidden sizes');let o=0;if(Q){if(g!==d)throw new Error('Input "past" expect k_hidden_size == v_hidden_size');if(5!==Q.dims.length)throw new Error('Input "past" must have 5 dimensions');if(2!==Q.dims[0])throw new Error('Input "past" first dimension must be 2');if(Q.dims[1]!==i)throw new Error('Input "past" second dimension must be batch_size');if(Q.dims[2]!==e.numHeads)throw new Error('Input "past" third dimension must be num_heads');if(Q.dims[4]!==g/e.numHeads)throw new Error('Input "past" fifth dimension must be k_hidden_size / num_heads');e.pastPresentShareBuffer||(o=Q.dims[3])}const r=I+o;if(F)throw new Error("Mask not supported");if(Q)throw new Error("past is not supported");if(U)throw new Error("relativePositionBias is not supported");return{batchSize:i,sequenceLength:a,pastSequenceLength:o,kvSequenceLength:I,totalSequenceLength:r,maxSequenceLength:-1,inputHiddenSize:l,hiddenSize:c,vHiddenSize:d,headSize:Math.floor(c/e.numHeads),vHeadSize:Math.floor(d/e.numHeads),numHeads:e.numHeads,isUnidirectional:!1,pastPresentShareBuffer:!1,maskFilterValue:e.maskFilterValue,maskType:0,scale:e.scale,broadcastResPosBias:!1,passPastInKv:!1,qkvFormat:1}},computeInPlaceSoftmax=(t,e,n,B)=>{const s=getMaxComponents(B);let F=64;const Q=B/s;Q<F?F=1:Q/8<64&&(F=Math.ceil(Q/8));const U=Math.ceil(B/s/F),i=[{type:tensorDataTypeEnumToString(e.dataType),data:1/B},{type:"uint32",data:Q},{type:"uint32",data:U}],a=tensorTypeToWsglStorageType(e.dataType,s);t.compute({name:"AttentionProbsSoftmax",shaderCache:{hint:`${F};${a};${s}`},getShaderSource:t=>{const n=outputVariable("x",e.dataType,e.dims,s);let B="thread_max_vector";2===s?B="max(thread_max_vector.x, thread_max_vector.y)":4===s&&(B="max(max(thread_max_vector.x, thread_max_vector.y), max(thread_max_vector.z, thread_max_vector.w))");const Q=tensorTypeToWsglValueType(e.dataType),U=[{name:"d_inv",type:Q},{name:"d_comp",type:"u32"},{name:"elements_per_wg",type:"u32"}];return`\n  var<workgroup> wgMax: array<f32, ${F}>;\n  var<workgroup> wgSum: array<f32, ${F}>;\n  ${t.registerUniforms(U).declareVariables(n)}\n  ${t.mainStart([F,1,1])}\n    let localOffset = local_idx * uniforms.elements_per_wg;\n    let offset: u32 = workgroup_id.x * uniforms.d_comp + localOffset;\n\n    var thread_max_vector = ${fillVector("f32",s,"-3.402823e+38f")};\n    for (var i: u32 = 0; i < uniforms.elements_per_wg && i + localOffset < uniforms.d_comp; i++) {\n      thread_max_vector = max(${castToF32(Q,s,"x[offset + i]")}, thread_max_vector);\n    }\n    wgMax[local_idx] = ${B};\n    workgroupBarrier();\n\n    var maxValue = -3.402823e+38f;\n    for (var i = 0u; i < ${F}; i++) {\n      maxValue = max(wgMax[i], maxValue);\n    }\n\n    var sumVector = ${fillVector("f32",s,"0")};\n    for (var i: u32 = 0; i < uniforms.elements_per_wg && i + localOffset < uniforms.d_comp; i++) {\n      sumVector += exp(${castToF32(Q,s,"x[offset + i]")} - maxValue);\n    }\n    wgSum[local_idx] = ${sumVector("sumVector",s)};\n    workgroupBarrier();\n\n    var sum: f32 = 0;\n    for (var i = 0u; i < ${F}; i++) {\n      sum += wgSum[i];\n    }\n\n    if (sum == 0) {\n      for (var i: u32 = 0; i < uniforms.elements_per_wg && i + localOffset < uniforms.d_comp; i++) {\n        x[offset + i] = ${fillVector("f32",s,"uniforms.d_inv")};\n      }\n    } else {\n      for (var i: u32 = 0; i < uniforms.elements_per_wg && i + localOffset < uniforms.d_comp; i++) {\n        let f32input = ${castToF32(Q,s,"x[offset + i]")};\n        x[offset + i] = ${n.type.value}(exp(f32input - maxValue) / sum);\n      }\n    }\n  }`},getRunData:()=>({outputs:[],dispatchGroup:{x:n},programUniforms:i})},{inputs:[e],outputs:[]})},computeAttentionProbs=(t,e,n,B,s,F)=>{const Q=[s.batchSize,s.numHeads,s.sequenceLength,s.kvSequenceLength+s.pastSequenceLength],U=0===F.scale?1/Math.sqrt(s.headSize):F.scale,i=getMaxComponents(s.headSize),a=s.headSize/i,l=12,c={x:Math.ceil(s.totalSequenceLength/l),y:Math.ceil(s.sequenceLength/l),z:s.batchSize*s.numHeads},g=tensorDataTypeEnumToString(e.dataType),d=[{type:"uint32",data:s.sequenceLength},{type:"uint32",data:a},{type:"uint32",data:s.totalSequenceLength},{type:"uint32",data:s.kvSequenceLength},{type:g,data:U}],I=[e,n],o=t.compute({name:"AttentionProbs",shaderCache:{hint:`${i}`,inputDependencies:["type","type"]},getRunData:()=>({outputs:[{dims:Q,dataType:e.dataType,gpuDataType:0}],dispatchGroup:c,programUniforms:d}),getShaderSource:t=>{const B=inputVariable("q",e.dataType,e.dims,i),s=inputVariable("key",n.dataType,n.dims,i),F=outputVariable("output",e.dataType,Q),U=tensorTypeToWsglStorageType(e.dataType),a=[{name:"M",type:"u32"},{name:"K",type:"u32"},{name:"N",type:"u32"},{name:"kv_sequence_length",type:"u32"},{name:"alpha",type:U}];return`\n  const beta: ${U} = 1.0;\n  const TILE_SIZE = 12u;\n\n  var<workgroup> tileQ: array<${B.type.storage}, 144>;\n  var<workgroup> tileK: array<${B.type.storage}, 144>;\n  ${t.registerUniforms(a).declareVariables(B,s,F)}\n  ${t.mainStart([l,l,1])}\n    // x holds the N and y holds the M\n    let headIdx = workgroup_id.z;\n    let m = workgroup_id.y * TILE_SIZE;\n    let n = workgroup_id.x * TILE_SIZE;\n    let lm = m + local_id.y;\n    let ln = n + local_id.x;\n\n    let qOffset = uniforms.M * uniforms.K * headIdx + m * uniforms.K;\n    let kOffset = uniforms.kv_sequence_length * uniforms.K * headIdx + n * uniforms.K;\n\n    var value = ${fillVector(U,i)};\n    for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {\n      if (m + local_id.y < uniforms.M && w + local_id.x < uniforms.K) {\n        tileQ[TILE_SIZE * local_id.y + local_id.x] = q[qOffset + local_id.y * uniforms.K + w + local_id.x];\n      }\n      if (n + local_id.y < uniforms.N && w + local_id.x < uniforms.K) {\n        tileK[TILE_SIZE * local_id.y + local_id.x] = key[kOffset + local_id.y * uniforms.K + w + local_id.x];\n      }\n      workgroupBarrier();\n\n      for (var k: u32 = 0u; k<TILE_SIZE && w+k < uniforms.K; k++) {\n        value += tileQ[TILE_SIZE * local_id.y + k] * tileK[TILE_SIZE * local_id.x + k];\n      }\n\n      workgroupBarrier();\n    }\n\n    let headOffset = headIdx * uniforms.M * uniforms.N;\n    if (lm < uniforms.M && ln < uniforms.N) {\n      let outputIdx = headOffset + lm * uniforms.N + ln;\n      output[outputIdx] = ${sumVector("value",i)} * uniforms.alpha;\n    }\n  }`}},{inputs:I,outputs:[-1]})[0];return computeInPlaceSoftmax(t,o,s.batchSize*s.numHeads*s.sequenceLength,s.totalSequenceLength),o},computeVxAttentionScore=(t,e,n,B)=>{const s=[B.batchSize,B.sequenceLength,B.vHiddenSize],F=12,Q={x:Math.ceil(B.vHeadSize/F),y:Math.ceil(B.sequenceLength/F),z:B.batchSize*B.numHeads},U=[{type:"uint32",data:B.sequenceLength},{type:"uint32",data:B.totalSequenceLength},{type:"uint32",data:B.vHeadSize},{type:"uint32",data:B.numHeads},{type:"uint32",data:B.vHiddenSize}];return t.compute({name:"AttentionScore",shaderCache:{inputDependencies:["type","type"]},getRunData:()=>({outputs:[{dims:s,dataType:e.dataType,gpuDataType:0}],dispatchGroup:Q,programUniforms:U}),getShaderSource:t=>{const B=inputVariable("probs",e.dataType,e.dims),Q=inputVariable("v",n.dataType,n.dims),U=outputVariable("output",e.dataType,s);return`\n  const TILE_SIZE = 12u;\n  var<workgroup> tileQ: array<${B.type.value}, 144>;\n  var<workgroup> tileK: array<${B.type.value}, 144>;\n  ${t.registerUniforms([{name:"M",type:"u32"},{name:"K",type:"u32"},{name:"N",type:"u32"},{name:"num_heads",type:"u32"},{name:"v_hidden_size",type:"u32"}]).declareVariables(B,Q,U)}\n  ${t.mainStart([F,F,1])}\n   let headIdx = workgroup_id.z;\n   let m = workgroup_id.y * TILE_SIZE + local_id.y;\n   let n = workgroup_id.x * TILE_SIZE + local_id.x;\n\n   let offsetA = headIdx * (uniforms.M * uniforms.K) + m * uniforms.K;\n   let offsetB = headIdx * (uniforms.N * uniforms.K) + n;\n\n   var value = ${B.type.storage}(0);\n   for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {\n     if (m < uniforms.M && w + local_id.x < uniforms.K) {\n       tileQ[TILE_SIZE * local_id.y + local_id.x] = probs[offsetA + w + local_id.x];\n     }\n     if (n < uniforms.N && w + local_id.y < uniforms.K) {\n       tileK[TILE_SIZE * local_id.y + local_id.x] = v[offsetB + (w + local_id.y) * uniforms.N];\n     }\n     workgroupBarrier();\n     for (var k: u32 = 0u; k<TILE_SIZE && w+k < uniforms.K; k++) {\n       value += tileQ[TILE_SIZE * local_id.y + k] * tileK[TILE_SIZE * k + local_id.x];\n     }\n     workgroupBarrier();\n   }\n\n   // we need to transpose output from BNSH_v to BSND_v\n   let batchIdx = workgroup_id.z / uniforms.num_heads;\n   let currentBatchHeadNumber = workgroup_id.z % uniforms.num_heads;\n   let headOffset = (batchIdx * uniforms.M * uniforms.num_heads + currentBatchHeadNumber) * uniforms.N;\n   if (m < uniforms.M && n < uniforms.N) {\n     let outputIdx = batchIdx * uniforms.M *uniforms.v_hidden_size + m * uniforms.v_hidden_size\n       + currentBatchHeadNumber * uniforms.N + n;\n     output[outputIdx] = value;\n   }\n  }`}},{inputs:[e,n],outputs:[0]})[0]},applyAttention=(t,e,n,B,s,F,Q,U,i,a,l)=>{const c=computeAttentionProbs(t,e,n,i,a,l);computeVxAttentionScore(t,c,B,a)},prepare=(t,e)=>{const n=[e.batchSize,e.numHeads,e.sequenceLength,e.headSize],B=e.sequenceLength,s=e.inputHiddenSize,F=e.headSize,Q=12,U={x:Math.ceil(e.headSize/Q),y:Math.ceil(e.sequenceLength/Q),z:e.batchSize*e.numHeads},i=[t.inputs[0],t.inputs[1],t.inputs[2]],a=[{type:"uint32",data:B},{type:"uint32",data:s},{type:"uint32",data:F},{type:"uint32",data:e.numHeads},{type:"uint32",data:e.headSize},{type:"uint32",data:e.hiddenSize},{type:"uint32",data:e.hiddenSize+e.hiddenSize+e.vHiddenSize}];return t.compute({name:"AttentionPrepare",shaderCache:{inputDependencies:["type","type","type"]},getRunData:()=>({outputs:[{dims:n,dataType:t.inputs[0].dataType,gpuDataType:0},{dims:n,dataType:t.inputs[0].dataType,gpuDataType:0},{dims:n,dataType:t.inputs[0].dataType,gpuDataType:0}],dispatchGroup:U,programUniforms:a}),getShaderSource:t=>{const e=outputVariable("output_q",i[0].dataType,n),B=outputVariable("output_k",i[0].dataType,n),s=outputVariable("output_v",i[0].dataType,n),F=inputVariable("input",i[0].dataType,i[0].dims),U=inputVariable("weight",i[1].dataType,i[1].dims),a=inputVariable("bias",i[2].dataType,i[2].dims),l=F.type.storage;return`\n  const TILE_SIZE = 12u;\n  var<workgroup> tileInput: array<${l}, 144>;\n  var<workgroup> tileWeightQ: array<${l}, 144>;\n  var<workgroup> tileWeightK: array<${l}, 144>;\n  var<workgroup> tileWeightV: array<${l}, 144>;\n  ${t.registerUniforms([{name:"M",type:"u32"},{name:"K",type:"u32"},{name:"N",type:"u32"},{name:"num_heads",type:"u32"},{name:"head_size",type:"u32"},{name:"hidden_size",type:"u32"},{name:"ldb",type:"u32"}]).declareVariables(F,U,a,e,B,s)}\n  ${t.mainStart([Q,Q,1])}\n    let batchIndex = workgroup_id.z / uniforms.num_heads;\n    let headNumber = workgroup_id.z % uniforms.num_heads;\n    let m = workgroup_id.y * TILE_SIZE + local_id.y;\n    let n = workgroup_id.x * TILE_SIZE + local_id.x;\n\n    let inputOffset = batchIndex * (uniforms.M * uniforms.K) + m * uniforms.K;\n    let biasOffsetQ = headNumber * uniforms.head_size;\n    let biasOffsetK = uniforms.hidden_size + biasOffsetQ;\n    let biasOffsetV = uniforms.hidden_size + biasOffsetK;\n\n    var valueQ = ${l}(0);\n    var valueK = ${l}(0);\n    var valueV = ${l}(0);\n    for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {\n      if (m < uniforms.M && w + local_id.x < uniforms.K) {\n        tileInput[TILE_SIZE * local_id.y + local_id.x] = input[inputOffset + w + local_id.x];\n      }\n      if (n < uniforms.N && w + local_id.y < uniforms.K) {\n        let offset = n + (w + local_id.y) * uniforms.ldb;\n        tileWeightQ[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetQ + offset];\n        tileWeightK[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetK + offset];\n        tileWeightV[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetV + offset];\n      }\n      workgroupBarrier();\n      for (var k: u32 = 0u; k<TILE_SIZE && w+k < uniforms.K; k++) {\n        let inputTileOffset = TILE_SIZE * local_id.y + k;\n        let weightTileOffset = TILE_SIZE * k + local_id.x;\n        valueQ += tileInput[inputTileOffset] * tileWeightQ[weightTileOffset];\n        valueK += tileInput[inputTileOffset] * tileWeightK[weightTileOffset];\n        valueV += tileInput[inputTileOffset] * tileWeightV[weightTileOffset];\n      }\n\n      workgroupBarrier();\n    }\n\n    let headOffset = (m * uniforms.N + n) % uniforms.head_size;\n    valueQ += bias[headOffset + biasOffsetQ];\n    valueK += bias[headOffset + biasOffsetK];\n    valueV += bias[headOffset + biasOffsetV];\n\n    let offset = workgroup_id.z * uniforms.M * uniforms.N;\n    if (m < uniforms.M && n < uniforms.N) {\n      let outputIdx = offset + m * uniforms.N + n;\n      output_q[outputIdx] = valueQ;\n      output_k[outputIdx] = valueK;\n      output_v[outputIdx] = valueV;\n    }\n  }`}},{inputs:i,outputs:[-1,-1,-1]})},attention=(t,e)=>{const n=validateAttentionInputs(t.inputs,e),[B,s,F]=prepare(t,n);return applyAttention(t,B,s,F,t.inputs[4],void 0,void 0,void 0,t.inputs[5],n,e)}}}),validateInputs29,createBatchNormInferenceProgramInfo,parseBatchNormAttributes,batchNorm,init_batch_norm=__esm({"web/lib/wasm/jsep/webgpu/ops/batch-norm.ts"(){init_esm(),init_util2(),init_attribute_with_cache_key2(),init_common(),validateInputs29=(t,e)=>{if(!t||5!==t.length)throw new Error("BatchNormalization requires 5 inputs");const n=(t,e,n)=>{const B=e.length;if(B!==t.length)throw new Error(`${n}: num dimensions != ${B}`);e.forEach(((e,B)=>{if(e!==t[B])throw new Error(`${n}: dim[${B}] do not match`)}))};if(t[0].dims.length>1){const B="NHWC"===e.format?e.spatial?t[0].dims.slice(-1):t[0].dims.slice(-1).concat(t[0].dims.slice(1,t[0].dims.length-1)):t[0].dims.slice(1,e.spatial?2:void 0);n(t[1].dims,B,"Invalid input scale"),n(t[2].dims,B,"Invalid input B"),n(t[3].dims,B,"Invalid input mean"),n(t[4].dims,B,"Invalid input var")}else n(t[1].dims,[1],"Invalid input scale"),n(t[2].dims,[1],"Invalid input B"),n(t[3].dims,[1],"Invalid input mean"),n(t[4].dims,[1],"Invalid input var")},createBatchNormInferenceProgramInfo=(t,e)=>{const{epsilon:n,spatial:B,format:s}=e,F=t[0].dims,Q=B?getMaxComponents(F[F.length-1]):1,U="NHWC"===s&&F.length>1?Q:1,i=ShapeUtil2.size(F)/Q,a=enableShapesUniforms(F.length)&&B,l=a?F.length:F,c=inputVariable("x",t[0].dataType,t[0].dims,Q),g=inputVariable("scale",t[1].dataType,t[1].dims,U),d=inputVariable("bias",t[2].dataType,t[2].dims,U),I=inputVariable("inputMean",t[3].dataType,t[3].dims,U),o=inputVariable("inputVar",t[4].dataType,t[4].dims,U),r=outputVariable("y",t[0].dataType,l,Q);return{name:"BatchNormalization",shaderCache:{hint:`${e.epsilon}_${e.format}_${B}_${Q}`,inputDependencies:a?["rank","type","type","type","type"]:void 0},getShaderSource:t=>`\n  const epsilon = ${n};\n  ${t.registerUniform("outputSize","u32").declareVariables(c,g,d,I,o,r)}\n  ${t.mainStart()}\n  ${t.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n    var outputIndices = ${r.offsetToIndices(`global_idx * ${Q}`)};\n    ${(()=>{let t="";if(B)t=`let cOffset = ${1===F.length?"0u":"NHWC"===s?`outputIndices[${F.length-1}] / ${Q}`:"outputIndices[1]"};`;else if("NCHW"===s)t=`\n            ${r.indicesSet("outputIndices","0","0")}\n            let cOffset = ${r.indicesToOffset("outputIndices")};`;else{t=`var cIndices = ${g.type.indices}(0);\n                       cIndices[0] = outputIndices[${F.length-1}];`;for(let e=1;e<g.rank;e++)t+=`cIndices[${e}] = outputIndices[${e}];`;t+=`let cOffset = ${g.indicesToOffset("cIndices")};`}return t})()}\n    let scale = ${g.getByOffset("cOffset")};\n    let bias = ${d.getByOffset("cOffset")};\n    let inputMean = ${I.getByOffset("cOffset")};\n    let inputVar = ${o.getByOffset("cOffset")};\n    let x = ${c.getByOffset("global_idx")};\n    let value = (x - inputMean) * inverseSqrt(inputVar + epsilon) * scale + bias;\n    ${r.setByOffset("global_idx","value")}\n  }`,getRunData:()=>({outputs:[{dims:t[0].dims,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(i/64)},programUniforms:a?[{type:"uint32",data:i},...createTensorShapeVariables(F)]:[{type:"uint32",data:i}]})}},parseBatchNormAttributes=t=>createAttributeWithCacheKey2(t),batchNorm=(t,e)=>{const{inputs:n,outputCount:B}=t,s=parseBatchNormAttributes({...e,outputCount:B});if(env2.webgpu.validateInputContent&&validateInputs29(n,s),e.trainingMode)throw new Error("BatchNormalization trainingMode is not supported yet.");t.compute(createBatchNormInferenceProgramInfo(n,s))}}}),validateInputs30,createBiasAddProgramInfo,biasAdd,init_bias_add=__esm({"web/lib/wasm/jsep/webgpu/ops/bias-add.ts"(){init_util2(),init_common(),validateInputs30=t=>{if(3!==t[0].dims.length)throw new Error("input should have 3 dimensions");if(![320,640,1280].includes(t[0].dims[2]))throw new Error("number of channels should be 320, 640 or 1280");if(1!==t[1].dims.length)throw new Error("bias is expected to have 1 dimensions");if(t[0].dims[2]!==t[1].dims[0])throw new Error("last dimension of input and bias are not the same")},createBiasAddProgramInfo=t=>{const e=t[0].dims,n=t[0].dims[2],B=ShapeUtil2.size(e)/4,s=t[0].dataType,F=inputVariable("input",s,e,4),Q=inputVariable("bias",s,[n],4),U=inputVariable("residual",s,e,4),i=outputVariable("output",s,e,4);return{name:"BiasAdd",getRunData:()=>({outputs:[{dims:e,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(B/64)}}),getShaderSource:t=>`\n  const channels = ${n}u / 4;\n  ${t.declareVariables(F,Q,U,i)}\n\n  ${t.mainStart()}\n    ${t.guardAgainstOutOfBoundsWorkgroupSizes(B)}\n    let value = ${F.getByOffset("global_idx")}\n      + ${Q.getByOffset("global_idx % channels")} + ${U.getByOffset("global_idx")};\n    ${i.setByOffset("global_idx","value")}\n  }`}},biasAdd=t=>{validateInputs30(t.inputs),t.compute(createBiasAddProgramInfo(t.inputs))}}}),createElementwiseProgramShader,createElementwiseProgramInfo2,abs2,acos2,acosh,asin2,asinh,atan2,atanh,parseCastAttributes2,cast2,generateClipAttributesFromInputs2,clip2,ceil2,cos2,cosh,parseAlphaAttributes,elu2,erfImpl,erf,exp2,floor2,gelu,leakyRelu2,not3,neg2,reciprocal,relu2,sigmoid2,sin2,sinh,sqrt2,tan2,tanh2,thresholdedRelu,log3,init_unary_op2=__esm({"web/lib/wasm/jsep/webgpu/ops/unary-op.ts"(){init_wasm_common(),init_util2(),init_attribute_with_cache_key2(),init_common(),createElementwiseProgramShader=(t,e,n,B,s,F)=>{const Q=Math.ceil(e/4);let U="";U="string"==typeof s?`${s}(a)`:s("a");const i=inputVariable("inputData",n,[Q],4),a=outputVariable("outputData",B,[Q],4);return`\n      ${t.registerUniform("vec_size","u32").declareVariables(i,a)}\n\n  ${F??""}\n\n  ${t.mainStart()}\n    ${t.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}\n\n    let a = ${i.getByOffset("global_idx")};\n    ${a.setByOffset("global_idx",U)}\n  }`},createElementwiseProgramInfo2=(t,e,n,B,s,F=t.dataType)=>({name:e,shaderCache:{hint:s,inputDependencies:["type"]},getShaderSource:e=>createElementwiseProgramShader(e,ShapeUtil2.size(t.dims),t.dataType,F,n,B),getRunData:e=>({outputs:[{dims:t.dims,dataType:F}],dispatchGroup:{x:Math.ceil(ShapeUtil2.size(e[0].dims)/64/4)},programUniforms:[{type:"uint32",data:Math.ceil(ShapeUtil2.size(t.dims)/4)}]})}),abs2=t=>{t.compute(createElementwiseProgramInfo2(t.inputs[0],"Abs","abs"))},acos2=t=>{t.compute(createElementwiseProgramInfo2(t.inputs[0],"Acos","acos"))},acosh=t=>{t.compute(createElementwiseProgramInfo2(t.inputs[0],"Acosh","acosh"))},asin2=t=>{t.compute(createElementwiseProgramInfo2(t.inputs[0],"Asin","asin"))},asinh=t=>{t.compute(createElementwiseProgramInfo2(t.inputs[0],"Asinh","asinh"))},atan2=t=>{t.compute(createElementwiseProgramInfo2(t.inputs[0],"Atan","atan"))},atanh=t=>{t.compute(createElementwiseProgramInfo2(t.inputs[0],"Atanh","atanh"))},parseCastAttributes2=t=>createAttributeWithCacheKey2(t),cast2=(t,e)=>{let n;switch(e.to){case 10:n="vec4<f16>";break;case 1:n="vec4<f32>";break;case 12:n="vec4<u32>";break;case 6:n="vec4<i32>";break;case 9:n="vec4<bool>";break;default:throw new RangeError(`not supported type (specified in attribute 'to' from 'Cast' operator): ${e.to}`)}t.compute(createElementwiseProgramInfo2(t.inputs[0],"Cast",n,void 0,e.cacheKey,e.to))},generateClipAttributesFromInputs2=t=>{const e=t.length>=2&&0!==t[1].data?t[1].getFloat32Array()[0]:MIN_CLIP2,n=t.length>=3&&0!==t[2].data?t[2].getFloat32Array()[0]:MAX_CLIP2;return createAttributeWithCacheKey2({min:e,max:n})},clip2=(t,e)=>{const n=1===t.inputs.length?e:generateClipAttributesFromInputs2(t.inputs),B=tensorTypeToWsglValueType(t.inputs[0].dataType);t.compute(createElementwiseProgramInfo2(t.inputs[0],"Clip",(t=>`clamp(${t}, clip_min_, clip_max_)`),`\n    const clip_min_: vec4<${B}> = vec4(${B}(${n.min}));\n    const clip_max_: vec4<${B}> = vec4(${B}(${n.max}));\n`,n.cacheKey),{inputs:[0]})},ceil2=t=>{t.compute(createElementwiseProgramInfo2(t.inputs[0],"Ceil","ceil"))},cos2=t=>{t.compute(createElementwiseProgramInfo2(t.inputs[0],"Cos","cos"))},cosh=t=>{t.compute(createElementwiseProgramInfo2(t.inputs[0],"Cosh","cosh"))},parseAlphaAttributes=t=>createAttributeWithCacheKey2(t),elu2=(t,e)=>{const n=tensorTypeToWsglValueType(t.inputs[0].dataType);t.compute(createElementwiseProgramInfo2(t.inputs[0],"Elu",(t=>`elu_vf32(${t})`),`\n  const elu_alpha_ = ${n}(${e.alpha});\n\n  fn elu_f32(a: ${n}) -> ${n} {\n  return select((exp(a) - 1.0) * elu_alpha_, a, a >= 0.0);\n  }\n\n  fn elu_vf32(v: vec4<${n}>) -> vec4<${n}> {\n  return vec4(elu_f32(v.x), elu_f32(v.y), elu_f32(v.z), elu_f32(v.w));\n  }`,e.cacheKey))},erfImpl=(t,e="f32")=>`\nconst r0: ${e} = 0.3275911;\nconst r1: ${e} = 0.254829592;\nconst r2: ${e} = -0.284496736;\nconst r3: ${e} = 1.421413741;\nconst r4: ${e} = -1.453152027;\nconst r5: ${e} = 1.061405429;\n\nfn erf_vf32(v: ${t}) -> ${t} {\n  let absv = abs(v);\n  let x = 1.0 / (1.0 + r0 * absv);\n  return sign(v) * (1.0 - ((((r5 * x + r4) * x + r3) * x + r2) * x + r1) * x * exp(-absv * absv));\n}`,erf=t=>{const e=tensorTypeToWsglValueType(t.inputs[0].dataType);t.compute(createElementwiseProgramInfo2(t.inputs[0],"Erf",(t=>`erf_vf32(${t})`),erfImpl(`vec4<${e}>`,e)))},exp2=t=>{t.compute(createElementwiseProgramInfo2(t.inputs[0],"Exp","exp"))},floor2=t=>{t.compute(createElementwiseProgramInfo2(t.inputs[0],"Floor","floor"))},gelu=t=>{const e=tensorTypeToWsglValueType(t.inputs[0].dataType);t.compute(createElementwiseProgramInfo2(t.inputs[0],"Gelu",(t=>`0.5 * ${t} * (1.0 + erf_vf32(${t} * 0.7071067811865475))`),erfImpl(`vec4<${e}>`,e)))},leakyRelu2=(t,e)=>{const n=tensorTypeToWsglValueType(t.inputs[0].dataType);t.compute(createElementwiseProgramInfo2(t.inputs[0],"LeakyRelu",(t=>`select(leaky_relu_alpha_ * ${t}, ${t}, ${t} >= vec4<${n}>(0.0))`),`const leaky_relu_alpha_ = ${n}(${e.alpha});`,e.cacheKey))},not3=t=>{t.compute(createElementwiseProgramInfo2(t.inputs[0],"Not",(t=>`!${t}`)))},neg2=t=>{t.compute(createElementwiseProgramInfo2(t.inputs[0],"Neg",(t=>`-${t}`)))},reciprocal=t=>{t.compute(createElementwiseProgramInfo2(t.inputs[0],"Reciprocal",(t=>`1.0/${t}`)))},relu2=t=>{const e=tensorTypeToWsglValueType(t.inputs[0].dataType);t.compute(createElementwiseProgramInfo2(t.inputs[0],"Relu",(t=>`select(vec4<${e}>(0.0), ${t}, ${t} > vec4<${e}>(0.0))`)))},sigmoid2=t=>{t.compute(createElementwiseProgramInfo2(t.inputs[0],"Sigmoid",(t=>`(1.0 / (1.0 + exp(-${t})))`)))},sin2=t=>{t.compute(createElementwiseProgramInfo2(t.inputs[0],"Sin","sin"))},sinh=t=>{t.compute(createElementwiseProgramInfo2(t.inputs[0],"Sinh","sinh"))},sqrt2=t=>{t.compute(createElementwiseProgramInfo2(t.inputs[0],"Sqrt","sqrt"))},tan2=t=>{t.compute(createElementwiseProgramInfo2(t.inputs[0],"Tan","tan"))},tanh2=t=>{t.compute(createElementwiseProgramInfo2(t.inputs[0],"Tanh","tanh"))},thresholdedRelu=(t,e)=>{const n=tensorTypeToWsglValueType(t.inputs[0].dataType);return t.compute(createElementwiseProgramInfo2(t.inputs[0],"ThresholdedRelu",(t=>`select(vec4<${n}>(0.0), ${t}, ${t} > thresholded_relu_alpha_)`),`const thresholded_relu_alpha_ = vec4<${n}>(${e.alpha});`,e.cacheKey)),0},log3=t=>{t.compute(createElementwiseProgramInfo2(t.inputs[0],"Log","log"))}}}),validateInputs31,createBiasSplitGeluProgramInfo,biasSplitGelu,init_bias_split_gelu=__esm({"web/lib/wasm/jsep/webgpu/ops/bias-split-gelu.ts"(){init_util2(),init_common(),init_unary_op2(),validateInputs31=t=>{if(3!==t[0].dims.length)throw new Error("input should have 3 dimensions");if(![2560,5120,10240].includes(t[0].dims[2]))throw new Error("hidden state should be 2560, 5120 or 10240");if(1!==t[1].dims.length)throw new Error("bias is expected to have 1 dimensions");if(t[0].dims[2]!==t[1].dims[0])throw new Error("last dimension of input and bias are not the same")},createBiasSplitGeluProgramInfo=t=>{const e=t[0].dims.slice();e[2]=e[2]/2;const n=inputVariable("input",t[0].dataType,t[0].dims,4),B=inputVariable("bias",t[0].dataType,[t[0].dims[2]],4),s=outputVariable("output",t[0].dataType,e,4),F=ShapeUtil2.size(e)/4,Q=tensorTypeToWsglStorageType(t[0].dataType);return{name:"BiasSplitGelu",getRunData:()=>({outputs:[{dims:e,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(F/64)}}),getShaderSource:e=>`\n  const M_SQRT2 = sqrt(2.0);\n  const halfChannels = ${t[0].dims[2]/4/2}u;\n\n  ${e.declareVariables(n,B,s)}\n\n  ${erfImpl(`vec4<${Q}>`,Q)}\n\n  ${e.mainStart()}\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes(F)}\n    let biasIdx = global_idx % halfChannels;\n    let batchIndex = global_idx / halfChannels;\n    let inputOffset = biasIdx + batchIndex * halfChannels * 2;\n    let valueLeft = input[inputOffset] + bias[biasIdx];\n    let valueRight = input[inputOffset + halfChannels] + bias[biasIdx + halfChannels];\n    let geluRight = valueRight * 0.5 * (erf_vf32(valueRight / M_SQRT2) + 1);\n\n    ${s.setByOffset("global_idx","valueLeft * geluRight")}\n  }`}},biasSplitGelu=t=>{validateInputs31(t.inputs),t.compute(createBiasSplitGeluProgramInfo(t.inputs))}}}),createBinaryOpProgramShader,createBinaryOpProgramInfo,runBinaryOp,add3,div2,equal2,mul2,pow2,sub2,greater2,less2,greaterOrEqual,lessOrEqual,init_binary_op2=__esm({"web/lib/wasm/jsep/webgpu/ops/binary-op.ts"(){init_wasm_common(),init_util2(),init_common(),createBinaryOpProgramShader=(t,e,n,B,s,F,Q,U,i,a,l,c,g)=>{let d,I;"string"==typeof U?d=I=(t,e)=>`${U}((${t}),(${e}))`:"function"==typeof U?d=I=U:(d=U.scalar,I=U.vector);const o=c?e.length:e,r=c?n.length:n,u=c?B.length:B,b=outputVariable("outputData",l,u,4),C=inputVariable("aData",i,o,4),p=inputVariable("bData",a,r,4);let m;if(s)if(F){const t=1===ShapeUtil2.size(e),B=1===ShapeUtil2.size(n),s=e.length>0&&e[e.length-1]%4==0,F=n.length>0&&n[n.length-1]%4==0;m=t||B?b.setByOffset("global_idx",I(t?`${C.type.value}(${C.getByOffset("0")}.x)`:C.getByOffset("global_idx"),B?`${p.type.value}(${p.getByOffset("0")}.x)`:p.getByOffset("global_idx"))):`\n            let outputIndices = ${b.offsetToIndices("global_idx * 4u")};\n            let offsetA = ${C.broadcastedIndicesToOffset("outputIndices",b)};\n            let offsetB = ${p.broadcastedIndicesToOffset("outputIndices",b)};\n            ${b.setByOffset("global_idx",I(Q||s?C.getByOffset("offsetA / 4u"):`${C.type.value}(${C.getByOffset("offsetA / 4u")}[offsetA % 4u])`,Q||F?p.getByOffset("offsetB / 4u"):`${p.type.value}(${p.getByOffset("offsetB / 4u")}[offsetB % 4u])`))}\n          `}else m=b.setByOffset("global_idx",I(C.getByOffset("global_idx"),p.getByOffset("global_idx")));else{if(!F)throw new Error("no necessary to use scalar implementation for element-wise binary op implementation.");const t=(t,e,n="")=>{const B=`aData[indexA${e}][componentA${e}]`,s=`bData[indexB${e}][componentB${e}]`;return`\n            let outputIndices${e} = ${b.offsetToIndices(`global_idx * 4u + ${e}u`)};\n            let offsetA${e} = ${C.broadcastedIndicesToOffset(`outputIndices${e}`,b)};\n            let offsetB${e} = ${p.broadcastedIndicesToOffset(`outputIndices${e}`,b)};\n            let indexA${e} = offsetA${e} / 4u;\n            let indexB${e} = offsetB${e} / 4u;\n            let componentA${e} = offsetA${e} % 4u;\n            let componentB${e} = offsetB${e} % 4u;\n            ${t}[${e}] = ${n}(${d(B,s)});\n          `};m=9===l?`\n            var data = vec4<u32>(0);\n            ${t("data",0,"u32")}\n            ${t("data",1,"u32")}\n            ${t("data",2,"u32")}\n            ${t("data",3,"u32")}\n            outputData[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`:`\n            ${t("outputData[global_idx]",0)}\n            ${t("outputData[global_idx]",1)}\n            ${t("outputData[global_idx]",2)}\n            ${t("outputData[global_idx]",3)}\n          `}return`\n        ${t.registerUniform("vec_size","u32").declareVariables(C,p,b)}\n\n        ${g??""}\n\n        ${t.mainStart()}\n        ${t.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}\n        ${m}\n      }`},createBinaryOpProgramInfo=(t,e,n,B,s,F,Q=n.dataType)=>{const U=!ShapeUtil2.areEqual(n.dims,B.dims);let i=n.dims,a=ShapeUtil2.size(n.dims),l=!1,c=!1;const g=[U];if(U){const t=BroadcastUtil2.calcShape(n.dims,B.dims,!1);if(!t)throw new Error("Can't perform binary op on the given tensors");i=t,a=ShapeUtil2.size(i);const e=1===ShapeUtil2.size(n.dims),s=1===ShapeUtil2.size(B.dims),F=n.dims.length>0&&n.dims[n.dims.length-1]%4==0,Q=B.dims.length>0&&B.dims[B.dims.length-1]%4==0;g.push(e),g.push(s),g.push(F),g.push(Q);let U=1;for(let t=1;t<i.length;t++){const e=n.dims[n.dims.length-t]??1;if(e!==(B.dims[B.dims.length-t]??1))break;U*=e}U%4==0?(c=!0,l=!0):(e||s||F||Q)&&(l=!0)}else l=!0;g.push(l);const d=enableShapesUniforms(n.dims.length)&&enableShapesUniforms(B.dims.length)&&enableShapesUniforms(i.length);return{name:t,shaderCache:{hint:e+g.map((t=>t.toString())).join("_"),inputDependencies:d?["rank","rank"]:["dims","dims"]},getShaderSource:t=>createBinaryOpProgramShader(t,n.dims,B.dims,i,l,U,c,s,n.dataType,B.dataType,Q,d,F),getRunData:()=>({outputs:[{dims:i,dataType:Q}],dispatchGroup:{x:Math.ceil(a/64/4)},programUniforms:d?[{type:"uint32",data:Math.ceil(ShapeUtil2.size(i)/4)},...createTensorShapeVariables(n.dims),...createTensorShapeVariables(B.dims),...createTensorShapeVariables(i)]:[{type:"uint32",data:Math.ceil(ShapeUtil2.size(i)/4)}]})}},runBinaryOp=(t,e,n,B,s,F)=>{t.compute(createBinaryOpProgramInfo(e,s??"",t.inputs[0],t.inputs[1],n,B,F))},add3=t=>{runBinaryOp(t,"Add",((t,e)=>`${t}+${e}`))},div2=t=>{runBinaryOp(t,"Div",((t,e)=>`${t}/${e}`))},equal2=t=>{runBinaryOp(t,"Equal",{scalar:(t,e)=>`u32(${t}==${e})`,vector:(t,e)=>`vec4<u32>(${t}==${e})`},void 0,void 0,9)},mul2=t=>{runBinaryOp(t,"Mul",((t,e)=>`${t}*${e}`))},pow2=t=>{const e=inputVariable("input",t.inputs[0].dataType,t.inputs[0].dims).type.value;runBinaryOp(t,"Pow",{scalar:(t,e)=>`pow_custom(${t},${e})`,vector:(t,e)=>`pow_vector_custom(${t},${e})`},`\n    fn pow_custom(a : ${e}, b : ${e}) -> ${e} {\n      if (b == ${e}(0.0)) {\n        return ${e}(1.0);\n      } else if (a < ${e}(0.0) && f32(b) != floor(f32(b))) {\n        return ${e}(pow(f32(a), f32(b))); // NaN\n      }\n      return select(sign(a), ${e}(1.0), round(f32(abs(b) % ${e}(2.0))) != 1.0) * ${e}(${"i32"===e?"round":""}(pow(f32(abs(a)), f32(b))));\n    }\n    fn pow_vector_custom(a : vec4<${e}>, b : vec4<${e}>) -> vec4<${e}> {\n      // TODO: implement vectorized pow\n      return vec4<${e}>(pow_custom(a.x, b.x), pow_custom(a.y, b.y), pow_custom(a.z, b.z), pow_custom(a.w, b.w));\n    }\n      `)},sub2=t=>{runBinaryOp(t,"Sub",((t,e)=>`${t}-${e}`))},greater2=t=>{runBinaryOp(t,"Greater",{scalar:(t,e)=>`u32(${t}>${e})`,vector:(t,e)=>`vec4<u32>(${t}>${e})`},void 0,void 0,9)},less2=t=>{runBinaryOp(t,"Less",{scalar:(t,e)=>`u32(${t}<${e})`,vector:(t,e)=>`vec4<u32>(${t}<${e})`},void 0,void 0,9)},greaterOrEqual=t=>{runBinaryOp(t,"GreaterOrEqual",{scalar:(t,e)=>`u32(${t}>=${e})`,vector:(t,e)=>`vec4<u32>(${t}>=${e})`},void 0,void 0,9)},lessOrEqual=t=>{runBinaryOp(t,"LessOrEqual",{scalar:(t,e)=>`u32(${t}<=${e})`,vector:(t,e)=>`vec4<u32>(${t}<=${e})`},void 0,void 0,9)}}}),validateInputs32,calculateInputIndexImpl,assignOutputData,createConcatProgramInfo,concat2,parseConcatAttributes2,init_concat2=__esm({"web/lib/wasm/jsep/webgpu/ops/concat.ts"(){init_util2(),init_attribute_with_cache_key2(),init_common(),validateInputs32=t=>{if(!t||t.length<1)throw new Error("too few inputs");const e=t[0].dataType,n=t[0].dims.length;for(const B of t){if(B.dataType!==e)throw new Error("input tensors should be one type");if(B.dims.length!==n)throw new Error("input tensors should have the same shape")}},calculateInputIndexImpl=(t,e)=>`\n  fn calculateInputIndex(index: u32) -> u32 {\n    let sizeInConcatAxis = array<u32, ${t}u>(${e});\n    for (var i: u32 = 0u; i < ${t}; i += 1u ) {\n      if (index < sizeInConcatAxis[i]) {\n        return i;\n      }\n    }\n    return ${t}u;\n  }`,assignOutputData=(t,e)=>{const n=t.length,B=[];for(let s=0;s<n;++s){const F=e.setByOffset("global_idx",t[s].getByIndices("indices"));1===n?B.push(F):0===s?B.push(`if (inputIndex == ${s}u) { ${F} }`):s===n-1?B.push(`else { ${F} }`):B.push(`else if (inputIndex == ${s}) { ${F} }`)}return B.join("\n")},createConcatProgramInfo=(t,e)=>{const n=t[0].dims.slice();if(e>=n.length||e<-1*n.length)throw new Error("axis specified for concat doesn't match input dimensionality");const B=e<0?n.length+e:e,s=n.slice(0);for(let e=1;e<t.length;e++){const F=t[e].dims.slice();for(let t=0;t<n.length;t++)if(t===B)s[B]+=F[t];else if(n[t]!==F[t])throw new Error("non concat dimensions must match")}const F=ShapeUtil2.size(s),Q=new Array(t.length),U=new Array(t.length),i=t[0].dataType;let a=0;const l=[],c=[],g=[],d=[{type:"uint32",data:F}];for(let e=0;e<t.length;++e)a+=t[e].dims[B],Q[e]=a,g.push(enableShapesUniforms(t[e].dims.length)),c.push(g[e]?t[e].dims.length:t[e].dims),U[e]=inputVariable(`input${e}`,i,c[e]),l.push(g[e]?"rank":"dims"),d.push({type:"uint32",data:Q[e]});for(let e=0;e<t.length;++e)g[e]&&d.push(...createTensorShapeVariables(t[e].dims));const I=enableShapesUniforms(s.length);I&&d.push(...createTensorShapeVariables(s));const o=I?s.length:s,r=outputVariable("output",i,o),u=r.indicesGet("indices",B),b=Array.from(Array(Q.length).keys()).map((t=>`uniforms.sizeInConcatAxis${t}`)).join(",");return{name:"Concat",shaderCache:{hint:`${e}`,inputDependencies:l},getRunData:()=>({outputs:[{dims:s,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(F/64)},programUniforms:d}),getShaderSource:e=>`\n\n  ${(()=>{e.registerUniform("outputSize","u32");for(let n=0;n<t.length;n++)e.registerUniform(`sizeInConcatAxis${n}`,"u32");return e.declareVariables(...U,r)})()}\n\n  ${calculateInputIndexImpl(Q.length,b)}\n\n  ${e.mainStart()}\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n\n    var indices = ${r.offsetToIndices("global_idx")};\n\n    let inputIndex = calculateInputIndex(${u});\n    if (inputIndex != 0u) {\n      let sizeInConcatAxis = array<u32, ${Q.length}u>(${b});\n      ${u} -= sizeInConcatAxis[inputIndex - 1u];\n    }\n\n    ${assignOutputData(U,r)}\n  }`}},concat2=(t,e)=>{validateInputs32(t.inputs),t.compute(createConcatProgramInfo(t.inputs,e.axis))},parseConcatAttributes2=t=>createAttributeWithCacheKey2({axis:t.axis})}}),getActivationSnippet2,parseInternalActivationAttributes2,init_fuse_utils2=__esm({"web/lib/wasm/jsep/webgpu/ops/fuse-utils.ts"(){init_util2(),getActivationSnippet2=(t,e)=>{switch(t.activation){case"Relu":return{activationFunction:"",applyActivation:`value = max(value, ${e}(0.0));`};case"Sigmoid":return{activationFunction:"",applyActivation:`value = (${e}(1.0) / (${e}(1.0) + exp(-value)));`};case"Clip":return{activationFunction:`const clip_min_=${e}(${t.clipMin});const clip_max_=${e}(${t.clipMax});`,applyActivation:"value = clamp(value, clip_min_, clip_max_);"};default:return{activationFunction:"",applyActivation:""}}},parseInternalActivationAttributes2=t=>{const e=t?.activation||"";if("Clip"===e){const[n,B]=t?.activation_params||[MIN_CLIP2,MAX_CLIP2];return{activation:e,clipMax:B,clipMin:n,activationCacheKey:`${e}:${n},${B}`}}return{activation:e,activationCacheKey:e}}}}),typeSnippet,biasSnippet,init_activation_util=__esm({"web/lib/wasm/jsep/webgpu/ops/3rd-party/activation_util.ts"(){typeSnippet=(t,e)=>{switch(t){case 1:return e;case 2:return`vec2<${e}>`;case 3:return`vec3<${e}>`;case 4:return`vec4<${e}>`;default:throw new Error(`${t}-component is not supported.`)}},biasSnippet=t=>`\n      ${t?"value = value + getBiasByOutputCoords(coords);":""}\n      `}}),utilFunctions,init_conv_util=__esm({"web/lib/wasm/jsep/webgpu/ops/3rd-party/conv_util.ts"(){utilFunctions=t=>`\nfn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {\n  return dot(coords, vec4<i32>(\n      shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));\n}\nfn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {\n  return dot(coords, vec4<i32>(\n    i32(${t}.x), i32(${t}.y), i32(${t}.z), 1));\n}\n`}}),writeDataToSubAVec4Snippet,calculateResultSnippet,makeMatMulPackedVec4Source,writeDataToSubASnippet,readDataFromSubASnippet,makeMatMulPackedSource,matMulReadWriteFnSource,createMatmulProgramInfo2,init_matmul_packed_webgpu=__esm({"web/lib/wasm/jsep/webgpu/ops/3rd-party/matmul_packed_webgpu.ts"(){init_util2(),init_common(),init_fuse_utils2(),init_activation_util(),writeDataToSubAVec4Snippet=(t,e)=>t?`\n        mm_Asub[inputRow][inputCol] = mm_readA(batch,\n          kStart + inputRow,\n          globalRowStart / innerElementSize + inputCol${e?", batchIndices":""});\n        `:`\n        mm_Asub[inputRow][inputCol] = mm_readA(batch,\n          globalRow + innerRow,\n          kStart / innerElementSize + inputCol${e?", batchIndices":""});\n        `,calculateResultSnippet=(t,e)=>t?`\n        let ACached0 = mm_Asub[k * innerElementSize][localRow];\n        let ACached1 = mm_Asub[k * innerElementSize + 1][localRow];\n        let ACached2 = mm_Asub[k * innerElementSize + 2][localRow];\n        ${3===e?"":"let ACached3 = mm_Asub[k * innerElementSize + 3][localRow];"}\n        for (var i = 0; i < rowPerThread; i = i + 1) {\n          acc[i] = BCached0 * ACached0[i] + acc[i];\n          acc[i] = BCached1 * ACached1[i] + acc[i];\n          acc[i] = BCached2 * ACached2[i] + acc[i];\n          ${3===e?"":"acc[i] = BCached3 * ACached3[i] + acc[i];"}\n        }`:`\n        for (var i = 0; i < rowPerThread; i = i + 1) {\n          let ACached = mm_Asub[tileRow + i][k];\n          acc[i] = BCached0 * ACached.x + acc[i];\n          acc[i] = BCached1 * ACached.y + acc[i];\n          acc[i] = BCached2 * ACached.z + acc[i];\n          ${3===e?"":"acc[i] = BCached3 * ACached.w + acc[i];"}\n        }`,makeMatMulPackedVec4Source=(t,e,n="f32",B,s=!1,F=32,Q=!1,U=32)=>{const i=e[1]*t[1],a=e[0]*t[0],l=s?i:F,c=s?F:i,g=l/e[0],d=F/e[1];if((!s||4!==g||4!==t[1])&&(s||3!==g&&4!==g)||l%e[0]!=0||F%e[1]!=0||4!==t[0])throw new Error(`If transposeA ${s} is true, innerElementSize ${g} and workPerThread[1] ${t[1]} must be 4.\n      Otherwise, innerElementSize ${g} must be 3 or 4.\n  tileAWidth ${l} must be divisible by workgroupSize[0]${e[0]}. tileInner ${F} must be divisible by workgroupSize[1] ${e[1]}. colPerThread ${t[0]} must be 4.`);return`\nvar<workgroup> mm_Asub: array<array<vec${g}<${n}>, ${l/g}>, ${c}>;\nvar<workgroup> mm_Bsub: array<array<vec4<${n}>, ${a/t[0]}>, ${F}>;\n\nconst rowPerThread = ${t[1]};\nconst colPerThread = ${t[0]};\nconst innerElementSize = ${g};\nconst tileInner = ${F};\n\n@compute @workgroup_size(${e[0]}, ${e[1]}, ${e[2]})\nfn main(@builtin(local_invocation_id) localId : vec3<u32>,\n        @builtin(global_invocation_id) globalId : vec3<u32>,\n        @builtin(workgroup_id) workgroupId : vec3<u32>) {\n  let localRow = i32(localId.y);\n  let tileRow = localRow * rowPerThread;\n  let tileCol = i32(localId.x);\n\n  let globalRow =i32(globalId.y) * rowPerThread;\n  let globalCol = i32(globalId.x);\n  let batch = ${Q?"0":"i32(globalId.z)"};\n  ${B?`let batchIndices = ${B.offsetToIndices("u32(batch)")};`:""}\n  let globalRowStart = i32(workgroupId.y) * ${i};\n\n  let numTiles = ${Q?`${Math.ceil(U/F)}`:"(uniforms.dimInner - 1) / tileInner + 1"};\n  var kStart = ${Q?`i32(globalId.z) * ${U}`:"0"};\n\n  var acc: array<vec4<${n}>, rowPerThread>;\n\n  // Loop over shared dimension.\n  let tileRowB = localRow * ${d};\n  for (var t = 0; t < numTiles; t = t + 1) {\n      // Load one tile of A into local memory.\n      for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n          let inputRow = tileRow + innerRow;\n          let inputCol = tileCol;\n          ${writeDataToSubAVec4Snippet(s,B)}\n      }\n\n      // Load one tile of B into local memory.\n      for (var innerRow = 0; innerRow < ${d}; innerRow = innerRow + 1) {\n          let inputRow = tileRowB + innerRow;\n          let inputCol = tileCol;\n          mm_Bsub[inputRow][inputCol] = mm_readB(batch, kStart + inputRow, globalCol${B?", batchIndices":""});\n      }\n      kStart = kStart + tileInner;\n      workgroupBarrier();\n\n      // Compute acc values for a single thread.\n      for (var k = 0; k < tileInner / innerElementSize; k = k + 1) {\n          let BCached0 = mm_Bsub[k * innerElementSize][tileCol];\n          let BCached1 = mm_Bsub[k * innerElementSize + 1][tileCol];\n          let BCached2 = mm_Bsub[k * innerElementSize + 2][tileCol];\n          ${3===g?"":"let BCached3 = mm_Bsub[k * innerElementSize + 3][tileCol];"}\n\n          ${calculateResultSnippet(s,g)}\n      }\n\n      workgroupBarrier();\n  }\n\n  for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n      mm_write(batch, globalRow + innerRow, globalCol, acc[innerRow]);\n  }\n}`},writeDataToSubASnippet=(t,e)=>t?`\n            mm_Asub[inputRow][inputCol] = mm_readA(batch,\n              kStart + inputRow,\n              globalRowStart + inputCol${e?", batchIndices":""});\n            `:`\n            mm_Asub[inputRow][inputCol] = mm_readA(batch,\n              globalRowStart + inputRow,\n              kStart + inputCol${e?", batchIndices":""});\n            `,readDataFromSubASnippet=t=>t?"let ACached = mm_Asub[k][tileRow + innerRow];":"let ACached = mm_Asub[tileRow + innerRow][k];",makeMatMulPackedSource=(t,e,n="f32",B,s=!1,F=32,Q=!1,U=32,i=!1)=>{const a=t[1]*e[1],l=t[0]*e[0],c=s?a:F,g=s?F:a;if(g%e[1]!=0||c%e[0]!=0||F%e[1]!=0)throw new Error(`tileAHight ${g} must be divisible by workgroupSize[1]${e[1]}, tileAWidth ${c} must be divisible by workgroupSize[0]${e[0]}, tileInner ${F} must be divisible by workgroupSize[1]${e[1]}`);const d=g/e[1],I=c/e[0],o=F/e[1],r=i?`\n    let localRow = i32(localId.y);\n    let localCol = i32(localId.x);\n    let globalRowStart = i32(workgroupId.y) * ${a};\n    let globalColStart = i32(workgroupId.x) * ${l};\n\n    // Loop over shared dimension.\n    for (var t = 0; t < numTiles; t = t + 1) {\n      // Load one tile of A into local memory.\n      for (var inputRow = localRow; inputRow < ${g}; inputRow = inputRow + ${e[1]}) {\n        for (var inputCol = localCol; inputCol < ${c}; inputCol = inputCol + ${e[0]}) {\n          ${writeDataToSubASnippet(s,B)}\n        }\n      }\n      // Load one tile of B into local memory.\n      for (var inputRow = localRow; inputRow < ${F}; inputRow = inputRow + ${e[1]}) {\n            for (var inputCol = localCol; inputCol < ${l}; inputCol = inputCol + ${e[0]}) {\n          mm_Bsub[inputRow][inputCol] = mm_readB(batch,\n            kStart + inputRow,\n            globalColStart + inputCol${B?", batchIndices":""});\n        }\n      }\n      kStart = kStart + tileInner;\n      workgroupBarrier();\n\n      // Compute acc values for a single thread.\n      var BCached : array<${n}, colPerThread>;\n      for (var k = 0; k < tileInner; k = k + 1) {\n        for (var inner = 0; inner < colPerThread; inner = inner + 1) {\n          BCached[inner] = mm_Bsub[k][localCol + inner * ${e[0]}];\n        }\n        for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n          let ACached = ${s?`mm_Asub[k][localRow + innerRow * ${e[1]}];`:`mm_Asub[localRow + innerRow * ${e[1]}][k];`}\n          for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n            acc[innerRow][innerCol] = acc[innerRow][innerCol] +\n                ACached * BCached[innerCol];\n          }\n        }\n      }\n      workgroupBarrier();\n    }\n    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n      let gRow = globalRowStart + localRow + innerRow * ${e[1]};\n      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n        let gCol = globalColStart + localCol + innerCol * ${e[0]};\n        mm_write(batch, gRow, gCol, acc[innerRow][innerCol]);\n      }\n    }\n    `:`\nlet tileRow = i32(localId.y) * rowPerThread;\nlet tileCol = i32(localId.x) * colPerThread;\n\nlet globalRow = i32(globalId.y) * rowPerThread;\nlet globalCol = i32(globalId.x) * colPerThread;\nlet globalRowStart = i32(workgroupId.y) * ${a};\n\nlet tileRowA = i32(localId.y) * ${d};\nlet tileColA = i32(localId.x) * ${I};\nlet tileRowB = i32(localId.y) * ${o};\n// Loop over shared dimension.\nfor (var t = 0; t < numTiles; t = t + 1) {\n  // Load one tile of A into local memory.\n  for (var innerRow = 0; innerRow < ${d}; innerRow = innerRow + 1) {\n    for (var innerCol = 0; innerCol < ${I}; innerCol = innerCol + 1) {\n      let inputRow = tileRowA + innerRow;\n      let inputCol = tileColA + innerCol;\n      ${writeDataToSubASnippet(s,B)}\n    }\n  }\n\n  // Load one tile of B into local memory.\n  for (var innerRow = 0; innerRow < ${o}; innerRow = innerRow + 1) {\n    for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n      let inputRow = tileRowB + innerRow;\n      let inputCol = tileCol + innerCol;\n      mm_Bsub[inputRow][inputCol] = mm_readB(batch,\n        kStart + inputRow,\n        globalCol + innerCol${B?", batchIndices":""});\n    }\n  }\n  kStart = kStart + tileInner;\n  workgroupBarrier();\n\n  // Compute acc values for a single thread.\n  var BCached : array<${n}, colPerThread>;\n  for (var k = 0; k < tileInner; k = k + 1) {\n    for (var inner = 0; inner < colPerThread; inner = inner + 1) {\n      BCached[inner] = mm_Bsub[k][tileCol + inner];\n    }\n\n    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n      ${readDataFromSubASnippet(s)}\n      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n        acc[innerRow][innerCol] = acc[innerRow][innerCol] + ACached * BCached[innerCol];\n      }\n    }\n  }\n\n  workgroupBarrier();\n}\n\nfor (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n  for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n    mm_write(batch, globalRow + innerRow, globalCol + innerCol,\n        acc[innerRow][innerCol]);\n  }\n}\n`;return`\n  var<workgroup> mm_Asub : array<array<${n}, ${c}>, ${g}>;\n  var<workgroup> mm_Bsub : array<array<${n}, ${l}>, ${F}>;\n  const rowPerThread = ${t[1]};\n  const colPerThread = ${t[0]};\n  const tileInner = ${F};\n\n@compute @workgroup_size(${e[0]}, ${e[1]}, ${e[2]})\nfn main(@builtin(local_invocation_id) localId : vec3<u32>,\n        @builtin(global_invocation_id) globalId : vec3<u32>,\n        @builtin(workgroup_id) workgroupId : vec3<u32>) {\n    let batch = ${Q?"0":"i32(globalId.z)"};\n    ${B?`let batchIndices = ${B.offsetToIndices("u32(batch)")};`:""}\n    let numTiles = ${Q?`${Math.ceil(U/F)}`:"(uniforms.dimInner - 1) / tileInner + 1"};\n    var kStart = ${Q?`i32(globalId.z) * ${U}`:"0"};\n\n    var acc : array<array<${n}, colPerThread>, rowPerThread>;\n\n    // Without this initialization strange values show up in acc.\n    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n        acc[innerRow][innerCol] = 0.0;\n      }\n    }\n    ${r}\n  }\n`},matMulReadWriteFnSource=(t,e,n,B,s,F=!1)=>{const[Q,U,i]=s,[a,l,c,g]=B,d=getBroadcastDims(Q,i),I=getBroadcastDims(U,i),o=tensorTypeToWsglStorageType(B[0].type.tensor);return`\n    fn mm_readA(batch: i32, row: i32, colIn: i32, batchIndices: ${a.type.indices}) -> ${typeSnippet(t,o)} {\n      var value = ${typeSnippet(t,o)}(0.0);\n      let col = colIn * ${t};\n      if(row < uniforms.dimAOuter && col < uniforms.dimInner)\n      {\n        ${(()=>{const t=l.rank,e=a.rank;let n=`var aIndices: ${l.type.indices};`;for(let B=t-2-1,s=e-1;B>=0;B--,s--)n+=`\naIndices[${B}] = ${e>1?`batchIndices[${s}]`:"batchIndices"};`;return d.forEach((t=>{n+=`\naIndices[${t}] = 0;`})),n+=`\naIndices[${t-2}] = u32(row);\n                   aIndices[${t-1}] = u32(colIn);`,n})()}\n        value = ${l.getByIndices("aIndices")};\n      }\n      return value;\n    }\n\n    fn mm_readB(batch: i32, row: i32, colIn: i32, batchIndices: ${a.type.indices}) -> ${typeSnippet(t,o)} {\n      var value = ${typeSnippet(t,o)}(0.0);\n      let col = colIn * ${t};\n      if(row < uniforms.dimInner && col < uniforms.dimBOuter)\n      {\n        ${(()=>{const t=c.rank,e=a.rank;let n=`var bIndices: ${c.type.indices};`;for(let B=t-2-1,s=e-1;B>=0;B--,s--)n+=`\nbIndices[${B}] = ${e>1?`batchIndices[${s}]`:"batchIndices"};`;return I.forEach((t=>{n+=`\nbIndices[${t}] = 0;`})),n+=`\nbIndices[${t-2}] = u32(row);\n                   bIndices[${t-1}] = u32(colIn);`,n})()}\n        value = ${c.getByIndices("bIndices")};\n      }\n      return value;\n    }\n\n    fn mm_write(batch: i32, row: i32, colIn: i32, valueIn: ${typeSnippet(t,o)}) {\n      let col = colIn * ${t};\n      if (row < uniforms.dimAOuter && col < uniforms.dimBOuter) {\n        var value = valueIn;\n        let coords = vec3<i32>(batch, row, colIn);\n        ${e?`value = value + ${F?"bias[colIn]":`${typeSnippet(t,o)}(bias[row])`};`:""}\n        ${n}\n        ${g.setByIndices("vec3<u32>(coords)","value")}\n      }\n    }\n    `},createMatmulProgramInfo2=(t,e,n,B,s=!1)=>{const F=t[0].dims,Q=t[1].dims,U=F.slice(0,-2),i=Q.slice(0,-2),a=B?B.slice(0,-2):n.slice(0,-2),l=enableShapesUniforms(a.length),c=l?a.length:a,g=internalVariable("batchDims",t[0].dataType,c,1),d=ShapeUtil2.size(a),I=F[F.length-2],o=F[F.length-1],r=Q[Q.length-1],u=o%4==0&&r%4==0,b=I<=8?[4,1,1]:[4,4,1],C=[8,8,1],p=[Math.ceil(r/C[0]/b[0]),Math.ceil(I/C[1]/b[1]),Math.ceil(d/C[2]/b[2])],m=tensorTypeToWsglStorageType(t[0].dataType),G=u?4:1,V=[...U,I,o/G],x=enableShapesUniforms(V.length),h=x?V.length:V,Z=[...i,o,r/G],S=enableShapesUniforms(Z.length),y=S?Z.length:Z,A=[d,I,r/G],X=inputVariable("a",t[0].dataType,h,G),R=inputVariable("b",t[1].dataType,y,G),L=outputVariable("result",t[0].dataType,A.length,G),W=[X,R],N=[{type:"int32",data:I},{type:"int32",data:r},{type:"int32",data:o}];l&&N.push(...createTensorShapeVariables(a)),x&&N.push(...createTensorShapeVariables(V)),S&&N.push(...createTensorShapeVariables(Z));const E=[];E.push(x?"rank":"dims"),E.push(S?"rank":"dims");const T=t.length>2,{activationFunction:Y,applyActivation:H}=getActivationSnippet2(e,L.type.value),J=matMulReadWriteFnSource(G,T,H,[g,X,R,L],[U,i,a],s);if(T){const e=s?G:1;W.push(inputVariable("bias",t[2].dataType,t[2].dims.length,e)),N.push(...createTensorShapeVariables(t[2].dims)),E.push("rank")}N.push(...createTensorShapeVariables(A));return{name:"MatMul",shaderCache:{hint:e.activationCacheKey+`${b}${u}${s}`,inputDependencies:E},getRunData:()=>({outputs:[{dims:n,dataType:t[0].dataType}],dispatchGroup:{x:p[0],y:p[1],z:p[2]},programUniforms:N}),getShaderSource:t=>`\n  ${t.registerUniform("dimAOuter","i32").registerUniform("dimBOuter","i32").registerUniform("dimInner","i32").registerInternalVariables(g).declareVariables(...W,L)}\n  ${Y}\n  ${J}\n  ${u?makeMatMulPackedVec4Source(b,C,m,g):makeMatMulPackedSource(b,C,m,g)}\n                   `}}}}),conv2dCommonSnippet,createConv2DMatMulProgramInfo,init_conv2d_mm_webgpu=__esm({"web/lib/wasm/jsep/webgpu/ops/3rd-party/conv2d_mm_webgpu.ts"(){init_log(),init_common(),init_fuse_utils2(),init_activation_util(),init_conv_util(),init_matmul_packed_webgpu(),conv2dCommonSnippet=(t,e,n,B,s=!1,F,Q=4,U=4,i=4,a="f32")=>{const l=t?"\n    let coord = vec4<i32>(batch, xRow, xCol, xCh);\n    ":"\n    let coord = vec4<i32>(batch, xCh, xRow, xCol);\n    ",c=t?"\n    let coords = vec4<i32>(\n      batch,\n      row / outWidth,\n      row % outWidth,\n      col);\n    ":"\n    let coords = vec4<i32>(\n      batch,\n      row,\n      col / outWidth,\n      col % outWidth);\n    ",g=t?"i32(uniforms.x_shape[1])":"i32(uniforms.x_shape[2])",d=t?"i32(uniforms.x_shape[2])":"i32(uniforms.x_shape[3])",I=t?"row":"col",o=t?"col":"row",r=`\n    let inChannels = i32(uniforms.w_shape[2]);\n    let outWidth = ${t?"i32(uniforms.result_shape[2])":"i32(uniforms.result_shape[3])"};\n    let outRow = ${I} / outWidth;\n    let outCol = ${I} % outWidth;\n\n    let WRow = ${o} / (filterDims[1] * inChannels);\n    let WCol = ${o} / inChannels % filterDims[1];\n    let xRow = outRow * stride[0] + dilation[0] * WRow - pad[0];\n    let xCol = outCol * stride[1] + dilation[1] * WCol - pad[1];\n    let xCh = ${o} % inChannels;\n    var resData = ${typeSnippet(Q,a)}(0.0);\n    // The bounds checking is always needed since we use it to pad zero for\n    // the 'same' padding type.\n    if (xRow >= 0 && xRow < ${g} && xCol >= 0 && xCol < ${d}) {\n      ${l}\n      let xIndex = getIndexFromCoords4D(coord, vec4<i32>(uniforms.x_shape));\n      ${(t=>{switch(t){case 1:return"resData = x[xIndex];";case 3:return`resData = vec3<${a}>(x[xIndex], x[xIndex + 1], x[xIndex + 2]);`;case 4:return"resData = x[xIndex / 4];";default:throw new Error(`innerElementSize ${t} is not supported.`)}})(Q)}\n    }\n    return resData;`,u=t?e&&B?`\n    let col = colIn * ${Q};\n    ${r}`:`\n    let col = colIn * ${Q};\n    if (row < uniforms.dimAOuter && col < uniforms.dimInner) {\n      ${r}\n    }\n    return ${typeSnippet(Q,a)}(0.0);`:B&&n?`\n    let col = colIn * ${Q};\n    ${r}`:`\n    let col = colIn * ${Q};\n    if (row < uniforms.dimInner && col < uniforms.dimBOuter) {\n      ${r}\n    }\n    return ${typeSnippet(Q,a)}(0.0);`,b=`${(t=>{switch(t){case 1:return"return w[row * i32(uniforms.w_shape[3]) + colIn];";case 4:return"return w[row * i32(uniforms.w_shape[3]) / 4 + colIn];";default:throw new Error(`innerElementSize ${t} is not supported.`)}})(U)}`,C=typeSnippet(i,a),p=typeSnippet(t?Q:U,a),m=typeSnippet(t?U:Q,a),{activationFunction:G,applyActivation:V}=getActivationSnippet2(F,C);return`\n    ${G}\n    fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${p} {\n      ${t?u:b}\n    }\n\n    fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${m} {\n      ${t?b:u}\n    }\n\n    fn mm_write(batch: i32, row : i32, colIn : i32, valueIn : ${C}) {\n      let col = colIn * ${i};\n      if (row < uniforms.dimAOuter && col < uniforms.dimBOuter)\n      {\n      var value = valueIn;\n      let outWidth = ${t?"i32(uniforms.result_shape[2])":"i32(uniforms.result_shape[3])"};\n      ${c}\n      ${biasSnippet(s)}\n      ${V}\n      setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);\n      }\n    }`},createConv2DMatMulProgramInfo=(t,e,n,B,s,F,Q,U)=>{const i="NHWC"===e.format,a=i?t[0].dims[3]:t[0].dims[1],l=n[0],c=i?n[2]:n[3],g=i?n[1]:n[2],d=i?n[3]:n[1],I=i&&(a%4==0||a%3==0)&&d%4==0,o=i?d:c*g,r=i?c*g:d,u=[8,8,1],b=B<=8?[4,1,1]:[4,4,1],C=[Math.ceil(o/u[0]/b[0]),Math.ceil(r/u[1]/b[1]),Math.ceil(l/u[2]/b[2])];LOG_DEBUG("verbose",(()=>`[conv2d_mm_webgpu] dispatch = ${C}`));const p=I?i&&a%4!=0?3:4:1,m=u[1]*b[1],G=u[0]*b[0],V=Math.max(u[0]*p,u[1]),x=B%m==0,h=s%G==0,Z=F%V==0,S=I?[p,4,4]:[1,1,1],y=tensorTypeToWsglStorageType(t[0].dataType),A=I?4:1,X=[{type:"int32",data:B},{type:"int32",data:s},{type:"int32",data:F}],R=[inputVariable("x",t[0].dataType,t[0].dims.length,3===p?1:p),inputVariable("w",t[1].dataType,t[1].dims.length,A)];X.push(...createTensorShapeVariables(t[0].dims)),X.push(...createTensorShapeVariables(t[1].dims));let L=`\n      fn setOutputAtIndex(flatIndex : i32, value : ${I?`vec4<${y}>`:y}) {\n        result[flatIndex] = ${I?`vec4<${y}>`:y}(value);\n      }\n      fn setOutputAtCoords(d0 : i32, d1 : i32, d2 : i32, d3 : i32, value : ${I?`vec4<${y}>`:y}) {\n        let flatIndex = getOutputIndexFromCoords(vec4<i32>(d0, d1, d2, d3));\n        setOutputAtIndex(flatIndex ${I?"/ 4":""}, value);\n      }`;if(Q){const e=inputVariable("bias",t[2].dataType,t[2].dims.length,A);R.push(e),X.push(...createTensorShapeVariables(t[2].dims)),L+=`\n        fn getBiasByOutputCoords(coords : vec4<i32>) -> ${I?`vec4<${y}>`:y} {\n          return bias[coords.${i?"w":"y"}${I?"/ 4":""}];\n        }`}const W=outputVariable("result",t[0].dataType,n.length,A);return X.push(...createTensorShapeVariables(n)),{name:"Conv2DMatMul",shaderCache:{hint:e.cacheKey},getRunData:()=>({outputs:[{dims:n,dataType:t[0].dataType}],dispatchGroup:{x:C[0],y:C[1],z:C[2]},programUniforms:X}),getShaderSource:t=>`\n        ${utilFunctions("uniforms.result_strides")}\n        //struct Uniforms { xShape : vec4<i32>, wShape : vec4<i32>, outShape : vec4<i32>,\n        //  outShapeStrides: vec3<i32>, filterDims : vec2<i32>, pad : vec2<i32>, stride : vec2<i32>,\n        //  dilation : vec2<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32 };\n        ${t.registerUniform("dimAOuter","i32").registerUniform("dimBOuter","i32").registerUniform("dimInner","i32").declareVariables(...R,W)}\n        const filterDims : vec2<i32> = vec2<i32>(${e.kernelShape[0]}, ${e.kernelShape[1]});\n        const pad : vec2<i32> = vec2<i32>(${e.pads[0]}, ${e.pads[1]});\n        const stride : vec2<i32> = vec2<i32>(${e.strides[0]}, ${e.strides[1]});\n        const dilation : vec2<i32> = vec2<i32>(${e.dilations[0]}, ${e.dilations[1]});\n        ${L}\n        ${conv2dCommonSnippet(i,x,h,Z,Q,e,S[0],S[1],S[2],y)}\n            ${I?makeMatMulPackedVec4Source(b,u,y,void 0,!i,V):makeMatMulPackedSource(b,u,y,void 0,!i,V,!1,void 0,U)}`}}}}),createGroupedConvProgramInfo,createGroupedConvVectorizeProgramInfo,init_conv_grouped2=__esm({"web/lib/wasm/jsep/webgpu/ops/conv-grouped.ts"(){init_util2(),init_common(),init_conv2(),init_fuse_utils2(),createGroupedConvProgramInfo=(t,e,n)=>{const B=t.length>2,s=B?"value += b[output_channel];":"",F=t[0].dims,Q=t[1].dims,U=Q[0]/e.group,i="NHWC"===e.format,a=calculateOutputShape2(F,Q,e.dilations,e.pads,e.strides,i),l=ShapeUtil2.size(a),c=outputVariable("output",t[0].dataType,a),{activationFunction:g,applyActivation:d}=getActivationSnippet2(e,c.type.value),I=inputVariable("x",t[0].dataType,F),o=inputVariable("w",t[1].dataType,Q),r=[I,o];B&&r.push(inputVariable("b",t[2].dataType,t[2].dims));return{name:"GroupedConv",shaderCache:{hint:e.cacheKey},getRunData:()=>({outputs:[{dims:n?n(a):a,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(l/64)}}),getShaderSource:t=>`\n  const strides: vec2<u32> = vec2(${e.strides[0]}u, ${e.strides[1]}u);\n  const pads: vec2<u32> = vec2(${e.pads[0]}u, ${e.pads[1]}u);\n\n  ${t.declareVariables(...r,c)}\n\n  ${g}\n\n  ${t.mainStart()}\n    ${t.guardAgainstOutOfBoundsWorkgroupSizes(l)}\n\n    let outputIndices = ${c.offsetToIndices("global_idx")};\n    let batch: u32 = outputIndices[0];\n    let output_channel: u32 = outputIndices[${i?3:1}];\n    let xRCCorner: vec2<u32> = vec2<u32>(outputIndices[${i?1:2}], outputIndices[${i?2:3}]) * strides - pads;\n    let group_id: u32 = output_channel / ${U}u;\n\n    var value: ${c.type.value} = ${c.type.value}(0);\n    for (var wInChannel: u32 = 0u; wInChannel < ${Q[1]}u; wInChannel++) {\n      let input_channel = group_id * ${Q[1]}u + wInChannel;\n      for (var wHeight: u32 = 0u; wHeight < ${Q[2]}u; wHeight++) {\n        let xHeight = xRCCorner.x + wHeight * ${e.dilations[0]}u;\n\n        if (xHeight < 0u || xHeight >= ${F[i?1:2]}u) {\n          continue;\n        }\n\n        for (var wWidth: u32 = 0u; wWidth < ${Q[3]}u; wWidth++) {\n          let xWidth = xRCCorner.y + wWidth * ${e.dilations[1]}u;\n          if (xWidth < 0u || xWidth >= ${F[i?2:3]}u) {\n            continue;\n          }\n\n          let xVal = ${i?I.get("batch","xHeight","xWidth","input_channel"):I.get("batch","input_channel","xHeight","xWidth")};\n          let wVal = ${o.get("output_channel","wInChannel","wHeight","wWidth")};\n          value += xVal*wVal;\n        }\n      }\n    }\n    ${s}\n    ${d}\n    ${c.setByOffset("global_idx","value")}\n  }`}},createGroupedConvVectorizeProgramInfo=(t,e,n)=>{const B=t.length>2,s=getMaxComponents(n[3]),F=getMaxComponents(n[2]),Q=ShapeUtil2.size(n)/s/F,U=[t[0].dims[0],t[0].dims[1],t[0].dims[2],t[0].dims[3]/s],i=[t[1].dims[0],t[1].dims[1],t[1].dims[2],t[1].dims[3]/s],a=[n[0],n[1],n[2],n[3]/s],l=[{type:"uint32",data:Q},{type:"int32",data:e.strides},{type:"int32",data:e.pads},...createTensorShapeVariables(U),...createTensorShapeVariables(i),...createTensorShapeVariables(a)],c=(F-1)*e.strides[1]+i[1];return{name:"GroupedConv-Vectorize",shaderCache:{hint:`${e.activationCacheKey};${s};${F};${c};${i[0]};${i[1]}`,inputDependencies:B?["rank","rank","type"]:["rank","rank"]},getRunData:()=>({outputs:[{dims:n,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(Q/64)},programUniforms:l}),getShaderSource:n=>{const Q=outputVariable("output",t[0].dataType,a.length,s),{activationFunction:l,applyActivation:g}=getActivationSnippet2(e,Q.type.value),d=inputVariable("x",t[0].dataType,U.length,s),I=inputVariable("w",t[1].dataType,i.length,s),o=[d,I];B&&o.push(inputVariable("b",t[2].dataType,t[2].dims,s));const r=B?"value += b[output_channel];":"";return`\n  ${n.registerUniform("output_size","u32").registerUniform("strides","i32",2).registerUniform("pads","i32",2).declareVariables(...o,Q)}\n  ${l}\n  ${n.mainStart()}\n    ${n.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n    let width0 = uniforms.output_shape[3];\n    let output_channel = global_idx % width0;\n    var index1 = global_idx / width0;\n    let width1 = uniforms.output_shape[2] / ${F}u;\n    let col = (index1 % width1) * ${F}u;\n    index1 = index1 / width1;\n    let row = index1 % uniforms.output_shape[1];\n    let batch = index1 / uniforms.output_shape[1];\n\n    let x_corner = vec2<i32>(i32(row), i32(col)) * uniforms.strides - uniforms.pads;\n\n    var x_vals: array<${d.type.value}, ${c}>;\n    var values: array<${Q.type.value}, ${F}>;\n    let input_channel = output_channel;\n    // Use constant instead of uniform can give better performance for w's height/width.\n    for (var w_height: u32 = 0u; w_height < ${i[0]}; w_height++) {\n      let x_height = x_corner.x + i32(w_height);\n      if (x_height >= 0 || u32(x_height) < uniforms.x_shape[1]) {\n        for (var i = 0; i < ${c}; i++) {\n          let x_width = x_corner.y + i;\n          if (x_width >= 0 && u32(x_width) < uniforms.x_shape[2]) {\n            x_vals[i] = ${d.get("batch","u32(x_height)","u32(x_width)","input_channel")};\n          } else {\n            x_vals[i] = ${d.type.value}(0);\n          }\n        }\n        for (var w_width: u32 = 0u; w_width < ${i[1]}; w_width++) {\n          let w_val = ${I.get("w_height","w_width","0","output_channel")};\n          for (var i = 0u; i < ${F}u; i++) {\n            values[i] = fma(x_vals[i * ${e.strides[1]}u + w_width], w_val, values[i]);\n          }\n        }\n      }\n    }\n\n    for (var i = 0u; i < ${F}u; i++) {\n      var value = values[i];\n      ${r}\n      ${g}\n      ${Q.set("batch","row","col + i","output_channel","value")};\n    }\n  }`}}}}}),createNaiveMatmulProgramInfo,validateInputs33,matMul2,init_matmul2=__esm({"web/lib/wasm/jsep/webgpu/ops/matmul.ts"(){init_util2(),init_matmul_packed_webgpu(),init_common(),init_fuse_utils2(),createNaiveMatmulProgramInfo=(t,e,n,B,s=!1)=>{const F=t[0].dims,Q=t[1].dims,U=F[F.length-2],i=Q[Q.length-1],a=F[F.length-1],l=getMaxComponents(i),c=getMaxComponents(a),g=getMaxComponents(U),d=ShapeUtil2.size(n)/l/g,I=t.length>2,o=B?B.slice(0,-2):n.slice(0,-2),r=[ShapeUtil2.size(o),U,i],u=[{type:"uint32",data:d},{type:"uint32",data:U},{type:"uint32",data:i},{type:"uint32",data:a},...createTensorShapeVariables(o),...createTensorShapeVariables(F),...createTensorShapeVariables(Q)];I&&u.push(...createTensorShapeVariables(t[2].dims)),u.push(...createTensorShapeVariables(r));return{name:"MatMulNaive",shaderCache:{hint:`${e.activationCacheKey}_${l}_${c}_${g}_${s}`,inputDependencies:I?["rank","rank","rank"]:["rank","rank"]},getRunData:()=>({outputs:[{dims:n,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(d/64)},programUniforms:u}),getShaderSource:B=>{const U=internalVariable("batch_dims",t[0].dataType,o.length),i=inputVariable("a",t[0].dataType,F.length,c),a=inputVariable("b",t[1].dataType,Q.length,l),d=outputVariable("output",t[0].dataType,r.length,l),{activationFunction:u,applyActivation:b}=getActivationSnippet2(e,d.type.value),C=[i,a];let p="";if(I){const e=s?l:1;C.push(inputVariable("bias",t[2].dataType,t[2].dims.length,e)),p=""+(s?`value += bias[col / ${e}];`:`value += ${d.type.value}(bias[row + i]);`)}const m=F.slice(0,-2),G=Q.slice(0,-2),V=getBroadcastDims(m,o),x=getBroadcastDims(G,o),h=(t,e)=>{const n=t.rank,B=t.name;if(2===n)return`var ${B}_indices = ${t.type.indices}(0u, 0u);`;const s=U.rank;let F=`var ${B}_indices: ${t.type.indices};`;for(let t=n-2-1,e=s-1;t>=0;t--,e--)F+=`\n${B}_indices[${t}] = ${s>1?`batch_indices[${e}]`:"batch_indices"};`;return e.forEach((t=>{F+=`\n${B}_indices[${t}] = 0;`})),F+=`${B}_indices[${n-2}] = 0u;\n                     ${B}_indices[${n-1}] = 0u;`,F};return`\n  ${B.registerUniform("outputSize","u32").registerUniform("M","u32").registerUniform("N","u32").registerUniform("K","u32").registerInternalVariables(U).declareVariables(...C,d)}\n  ${u}\n  ${B.mainStart()}\n    ${B.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n    let col = (global_idx % (uniforms.N / ${l})) * ${l};\n    var index1 = global_idx / (uniforms.N / ${l});\n    let stride1 = uniforms.M / ${g};\n    let row = (index1 % stride1) * ${g};\n    let batch = index1 / stride1;\n\n    ${2===n.length?"":`let batch_indices = ${U.offsetToIndices("batch")};`}\n    ${h(i,V)}\n    let a_offset = ${i.indicesToOffset("a_indices")};\n    ${h(a,x)}\n    let b_offset = ${a.indicesToOffset("b_indices")};\n    var values: array<${d.type.value}, ${g}>;\n    for (var k: u32 = 0u; k < uniforms.K; k = k + ${c}) {\n      ${(()=>{let t=`var a_data: ${i.type.value};`;for(let e=0;e<c;e++)t+=`\n              let b_data${e} = b[(b_offset + (k + ${e}) * uniforms.N + col) / ${l}];`;for(let e=0;e<g;e++){t+=`a_data = a[(a_offset + (row + ${e}) * uniforms.K + k) / ${c}];`;for(let n=0;n<c;n++)t+=`\n            values[${e}] = fma(${a.type.value}(a_data${1===c?"":`[${n}]`}), b_data${n}, values[${e}]);\n`}return t})()}\n    }\n    for (var i = 0u; i < ${g}u; i++) {\n      var value = values[i];\n      ${p}\n      ${b}\n      let cur_indices = ${d.type.indices}(batch, row + i, col);\n      let offset = ${d.indicesToOffset("cur_indices")};\n      ${d.setByOffset(`offset / ${l}`,"value")};\n    }\n  }\n  `}}},validateInputs33=t=>{if(!t||2!==t.length)throw new Error("MatMul requires 2 inputs.");if(t[0].dims[t[0].dims.length-1]!==t[1].dims[t[1].dims.length-2])throw new Error("shared dimension does not match.")},matMul2=t=>{validateInputs33(t.inputs);const e=BroadcastUtil2.calcShape(t.inputs[0].dims,t.inputs[1].dims,!0);if(!e)throw new Error("Can't use matmul on the given tensors");const n=e[e.length-1],B=t.inputs[0].dims[t.inputs[0].dims.length-1];n<8&&B<8?t.compute(createNaiveMatmulProgramInfo(t.inputs,{activation:"",activationCacheKey:""},e)):t.compute(createMatmulProgramInfo2(t.inputs,{activation:"",activationCacheKey:""},e))}}}),calculateOutputShape2,weightTransposeAttribute,validateInputs34,getAdjustedConvAttributes2,parseConvAttributes2,conv2d2,conv1d,conv2,init_conv2=__esm({"web/lib/wasm/jsep/webgpu/ops/conv.ts"(){init_util2(),init_attribute_with_cache_key2(),init_conv2d_mm_webgpu(),init_matmul_packed_webgpu(),init_conv_grouped2(),init_fuse_utils2(),init_matmul2(),init_transpose2(),calculateOutputShape2=(t,e,n,B,s,F)=>{const Q=t[0],U=t.slice(F?1:2,F?3:4),i=U.length,a=e[0],l=e.slice(2).map(((t,e)=>t+(t-1)*(n[e]-1))),c=U.map(((t,e)=>t+B[e]+B[e+i])).map(((t,e)=>Math.floor((t-l[e]+s[e])/s[e])));return c.splice(0,0,Q),c.splice(F?3:1,0,a),c},weightTransposeAttribute=[2,3,1,0],validateInputs34=(t,e)=>{if(!t||2!==t.length&&3!==t.length)throw new Error("Conv requires 2 or 3 inputs");if(4!==t[0].dims.length&&3!==t[0].dims.length)throw new Error("currently only support conv 1D and 2D");if(t[0].dims.length!==t[1].dims.length)throw new Error("filter does not have same dimension as input");if(t[0].dims["NHWC"===e.format?t[0].dims.length-1:1]!==t[1].dims[1]*e.group)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");if(3===t.length&&(1!==t[2].dims.length||t[1].dims[0]!==t[2].dims[0]))throw new Error("invalid bias");const n=t[0].dims.length-2;if(e.dilations.length!==n)throw new Error(`dilations should be ${n}D`);if(e.strides.length!==n)throw new Error(`strides should be ${n}D`);if(e.pads.length!==2*n)throw new Error(`pads should be ${2*n}D`);if(0!==e.kernelShape.length&&e.kernelShape.length!==t[1].dims.length-2)throw new Error("invalid kernel shape")},getAdjustedConvAttributes2=(t,e)=>{const n=t.kernelShape.slice();for(let t=2;t<e[1].dims.length;++t)0===n[t-2]&&(n[t-2]=e[1].dims[t]);const B=t.pads.slice();PoolConvUtil2.adjustPadsBasedOnAutoPad(e[0].dims,t.strides,t.dilations,n,B,"NHWC"===t.format,t.autoPad);const s=Object.assign({},t);return Object.assign(s,{kernelShape:n,pads:B,cacheKey:t.cacheKey}),s},parseConvAttributes2=t=>{const e=parseInternalActivationAttributes2(t),n=t.format,B=["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][t.auto_pad],s=t.dilations,F=t.group,Q=t.kernel_shape,U=t.pads,i=t.strides,a=t.w_is_const();return createAttributeWithCacheKey2({autoPad:B,format:n,dilations:s,group:F,kernelShape:Q,pads:U,strides:i,wIsConst:a,...e})},conv2d2=(t,e,n)=>{const B=getAdjustedConvAttributes2(n,e),s="NHWC"===n.format;if(1!==n.group){if(!!0&&s&&e[1].dims[0]===n.group&&1===e[1].dims[1]&&1===n.dilations[0]&&1===n.dilations[1]){const F=calculateOutputShape2(e[0].dims,e[1].dims,n.dilations,B.pads,n.strides,s),Q=t.kernelCustomData.wT??t.compute(createTransposeProgramInfo2(e[1],weightTransposeAttribute),{inputs:[1],outputs:[n.wIsConst?-2:-1]})[0];n.wIsConst&&!t.kernelCustomData.wT&&(t.kernelCustomData.wT=Q);const U=[e[0],Q];3===e.length&&U.push(e[2]),t.compute(createGroupedConvVectorizeProgramInfo(U,B,F),{inputs:U})}else t.compute(createGroupedConvProgramInfo(e,B));return}const F=3===e.length,Q=e[0].dims[s?1:2],U=e[0].dims[s?2:3],i=e[0].dims[s?3:1],a=e[1].dims[2],l=e[1].dims[3],c=calculateOutputShape2(e[0].dims,e[1].dims,n.dilations,B.pads,n.strides,s),g=c[s?1:2],d=c[s?2:3],I=c[s?3:1],o=s&&a===Q&&l===U&&0===n.pads[0]&&0===n.pads[1];if(o||1===a&&1===l&&1===n.dilations[0]&&1===n.dilations[1]&&1===n.strides[0]&&1===n.strides[1]&&0===n.pads[0]&&0===n.pads[1]){const a=c[0];let l,r,u;const b=[];if(s){const B=t.kernelCustomData.wT??t.compute(createTransposeProgramInfo2(e[1],weightTransposeAttribute),{inputs:[1],outputs:[n.wIsConst?-2:-1]})[0];if(n.wIsConst&&!t.kernelCustomData.wT&&(t.kernelCustomData.wT=B),o){const t=Q*U*i;l=e[0].reshape([1,a,t]),r=B.reshape([1,t,I]),u=[1,a,I]}else l=e[0].reshape([a,Q*U,i]),r=B.reshape([1,i,I]),u=[a,g*d,I];b.push(l),b.push(r)}else l=e[0].reshape([a,i,Q*U]),r=e[1].reshape([1,I,i]),u=[a,I,g*d],b.push(r),b.push(l);F&&b.push(e[2]);const C=u[2],p=b[0].dims[b[0].dims.length-1];return void(C<8&&p<8?t.compute(createNaiveMatmulProgramInfo(b,B,c,u,s),{inputs:b}):t.compute(createMatmulProgramInfo2(b,B,c,u,s),{inputs:b}))}const r=t.kernelCustomData.wT??t.compute(createTransposeProgramInfo2(e[1],weightTransposeAttribute),{inputs:[1],outputs:[n.wIsConst?-2:-1]})[0];n.wIsConst&&!t.kernelCustomData.wT&&(t.kernelCustomData.wT=r);const u=[e[0],r];F&&u.push(e[2]);const b=s?g*d:I,C=s?I:g*d,p=a*l*i;t.compute(createConv2DMatMulProgramInfo(u,B,c,b,C,p,F,!0),{inputs:u})},conv1d=(t,e)=>{const n="NHWC"===e.format,B=[t.inputs[0].reshape(n?[t.inputs[0].dims[0],1,t.inputs[0].dims[1],t.inputs[0].dims[2]]:[t.inputs[0].dims[0],t.inputs[0].dims[1],1,t.inputs[0].dims[2]]),t.inputs[1].reshape([t.inputs[1].dims[0],t.inputs[1].dims[1],1,t.inputs[1].dims[2]])];3===t.inputs.length&&B.push(t.inputs[2]);const s=[0,e.pads[0],0,e.pads[1]],F=[1].concat(e.strides),Q=[1].concat(e.dilations),U=[1].concat(e.kernelShape),i=getAdjustedConvAttributes2({...e,pads:s,strides:F,dilations:Q,kernelShape:U},B);t.compute(createGroupedConvProgramInfo(B,i,(t=>n?[t[0],t[2],t[3]]:[])))},conv2=(t,e)=>{validateInputs34(t.inputs,e),3===t.inputs[0].dims.length?conv1d(t,e):conv2d2(t,t.inputs,e)}}}),conv2dTransposeCommonSnippet,createConv2DTransposeMatMulProgramInfo,init_conv_backprop_mm_webgpu=__esm({"web/lib/wasm/jsep/webgpu/ops/3rd-party/conv_backprop_mm_webgpu.ts"(){init_log(),init_common(),init_fuse_utils2(),init_activation_util(),init_conv_util(),init_matmul_packed_webgpu(),conv2dTransposeCommonSnippet=(t,e=!1,n,B=4)=>{const s=typeSnippet(B,"f32"),F=t?"\n    let coords = vec4<i32>(\n      batch,\n      row / outWidth,\n      row % outWidth,\n      col);\n    ":"\n    let coords = vec4<i32>(\n      batch,\n      row,\n      col / outWidth,\n      col % outWidth);\n    ",Q=t?"row":"col",U=t?"col":"row",i=`\n      let inChannels = ${t?"outBackprop[3]":"outBackprop[1]"};\n      let outWidth = ${t?"i32(uniforms.result_shape[2])":"i32(uniforms.result_shape[3])"};\n      let outRow = ${Q} / outWidth;\n      let outCol = ${Q} % outWidth;\n\n      let WRow = ${U} / (filterDims[1] * inChannels);\n      let WCol = ${U} / inChannels % filterDims[1];\n      let xR = f32(outRow - pads[0] + dilation[0] * WRow) / f32(strides[0]);\n      let xC = f32(outCol - pads[1] + dilation[1] * WCol) / f32(strides[1]);\n      if (xR < 0.0 || xR >= f32(${t?"outBackprop[1]":"outBackprop[2]"}) || fract(xR) > 0.0) {\n        return ${s}(0.0);\n      }\n      if (xC < 0.0 || xC >= f32(${t?"outBackprop[2]":"outBackprop[3]"}) || fract(xC) > 0.0) {\n        return ${s}(0.0);\n      }\n      let iXR = i32(xR);\n      let iXC = i32(xC);\n      let xCh = ${U} % inChannels;\n      ${t?"\n      let coord = vec4<i32>(batch, iXR, iXC, xCh);\n      ":"\n      let coord = vec4<i32>(batch, xCh, iXR, iXC);\n      "}\n      return x[getIndexFromCoords4D(coord, vec4<i32>(uniforms.x_shape))/${B}];`,a=t?`\n      let col = colIn * ${B};\n      if (row < uniforms.dimAOuter && col < uniforms.dimInner) {\n        ${i}\n      }\n      return ${s}(0.0);`:`\n      let col = colIn * ${B};\n      if (row < uniforms.dimInner && col < uniforms.dimBOuter) {\n        ${i}\n      }\n      return ${s}(0.0);`,l=`\n      let col = colIn * ${B};\n      let inChannels = ${t?"outBackprop[3]":"outBackprop[1]"};\n      let coordX = filterDims.x - 1 - row / (filterDims[1] * inChannels);\n      let coordY = filterDims.y - 1 - (row / inChannels) % filterDims[1];\n      if (${t?"row < uniforms.dimInner && col < uniforms.dimBOuter":"row < uniforms.dimInner && col < uniforms.dimAOuter"}  && coordX >= 0 && coordY >= 0) {\n        let rowInner = row % inChannels;\n        let coord = vec4<i32>(coordX, coordY, col, rowInner);\n        ${(t=>{switch(t){case 1:return"return w[getIndexFromCoords4D(coord, vec4<i32>(uniforms.w_shape))];";case 4:return"\n            let coord1 = vec4<i32>(coordX, coordY, col + 1, rowInner);\n            let coord2 = vec4<i32>(coordX, coordY, col + 2, rowInner);\n            let coord3 = vec4<i32>(coordX, coordY, col + 3, rowInner);\n            let v0 = w[getIndexFromCoords4D(coord, vec4<i32>(uniforms.w_shape))];\n            let v1 = w[getIndexFromCoords4D(coord1, vec4<i32>(uniforms.w_shape))];\n            let v2 = w[getIndexFromCoords4D(coord2, vec4<i32>(uniforms.w_shape))];\n            let v3 = w[getIndexFromCoords4D(coord3, vec4<i32>(uniforms.w_shape))];\n            return vec4<f32>(v0, v1, v2, v3);\n            ";default:throw new Error(`innerElementSize ${t} is not supported.`)}})(B)}\n      }\n      return ${s}(0.0);\n      `,{activationFunction:c,applyActivation:g}=getActivationSnippet2(n,s);return`\n      ${c}\n  fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${s} {\n    ${t?a:l}\n  }\n\n  fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${s} {\n    ${t?l:a}\n  }\n\n  fn mm_write(batch: i32, row : i32, colIn : i32, valueInput : ${s}) {\n    let col = colIn * ${B};\n    if (row < uniforms.dimAOuter && col < uniforms.dimBOuter) {\n      var value = valueInput;\n      let outWidth = ${t?"i32(uniforms.result_shape[2])":"i32(uniforms.result_shape[3])"};\n      ${F}\n      ${biasSnippet(e)}\n      ${g}\n      result[getIndexFromCoords4D(coords, vec4<i32>(uniforms.result_shape))/${B}] = value;\n    }\n  }`},createConv2DTransposeMatMulProgramInfo=(t,e,n,B,s,F,Q,U)=>{const i="NHWC"===e.format,a=i?t[0].dims[3]:t[0].dims[1],l=n[0],c=i?n[2]:n[3],g=i?n[1]:n[2],d=i?n[3]:n[1],I=i?a%4==0&&d%4==0:c%4==0&&d%4==0,o=i?d:c*g,r=i?c*g:d,u=I?[8,8,1]:[o<=4||r<=4?4:16,o>4&&r<=4?4:16,1],b=I?[4,4,1]:[o<=4?1:4,o>4&&r<=4?1:4,1],C=[Math.ceil(o/u[0]/b[0]),Math.ceil(r/u[1]/b[1]),Math.ceil(l/u[2]/b[2])];LOG_DEBUG("verbose",(()=>`[conv_backprop_mm_webgpu] dispatch = ${C}`));const p=I?4:1,m=Math.max(u[0]*p,u[1]),G=I?4:1,V=[{type:"int32",data:B},{type:"int32",data:s},{type:"int32",data:F}],x=inputVariable("x",t[0].dataType,t[0].dims.length,G),h=inputVariable("w",t[1].dataType,t[1].dims.length,1),Z=outputVariable("result",t[0].dataType,n.length,G),S=[x,h];V.push(...createTensorShapeVariables(t[0].dims)),V.push(...createTensorShapeVariables(t[1].dims));let y="";if(Q){const e=inputVariable("bias",t[2].dataType,t[2].dims.length,G);S.push(e),V.push(...createTensorShapeVariables(t[2].dims)),y+=`\n        fn getBiasByOutputCoords(coords : vec4<i32>) -> ${I?"vec4<f32>":"f32"} {\n          return bias[coords.${i?"w":"y"}${I?"/ 4":""}];\n        }`}return V.push(...createTensorShapeVariables(n)),{name:"Conv2DTransposeMatMul",shaderCache:{hint:e.cacheKey},getRunData:()=>({outputs:[{dims:n,dataType:t[0].dataType}],dispatchGroup:{x:C[0],y:C[1],z:C[2]},programUniforms:V}),getShaderSource:n=>`\n        ${utilFunctions("uniforms.result_strides")}\n        ${n.registerUniform("dimAOuter","i32").registerUniform("dimBOuter","i32").registerUniform("dimInner","i32").declareVariables(...S,Z)};\n        const outBackprop : vec4<i32> = vec4<i32>(${t[0].dims.join(",")});\n        const filterDims : vec2<i32> = vec2<i32>(${e.kernelShape[i?1:2]}, ${e.kernelShape[i?2:3]});\n        const effectiveFilterDims : vec2<i32> = filterDims + vec2<i32>(\n              ${e.dilations[0]<=1?0:(e.kernelShape[i?1:2]-1)*(e.dilations[0]-1)},\n              ${e.dilations[1]<=1?0:(e.kernelShape[i?2:3]-1)*(e.dilations[1]-1)});\n        const pads : vec2<i32> = vec2<i32>(i32(effectiveFilterDims[0]) - 1 - (${e.pads[0]+e.pads[2]})/2,\n                                         i32(effectiveFilterDims[1]) - 1 - (${e.pads[1]+e.pads[3]})/2);\n        const strides : vec2<i32> = vec2<i32>(${e.strides[0]}, ${e.strides[1]});\n        const dilation : vec2<i32> = vec2<i32>(${e.dilations[0]}, ${e.dilations[1]});\n        const dimAOuter : i32 = ${B};\n        const dimBOuter : i32 = ${s};\n        const dimInner : i32 = ${F};\n        ${y}\n        ${conv2dTransposeCommonSnippet(i,Q,e,p)}\n        ${I?makeMatMulPackedVec4Source(b,u,"f32",void 0,!i,m):makeMatMulPackedSource(b,u,"f32",void 0,!i,m,!1,void 0,U)}`}}}}),createConvTranspose2DOpProgramShaderSource,createConvTranspose2DProgramInfo,init_conv_backprop_webgpu=__esm({"web/lib/wasm/jsep/webgpu/ops/3rd-party/conv_backprop_webgpu.ts"(){init_log(),init_util2(),init_common(),createConvTranspose2DOpProgramShaderSource=(t,e,n,B,s,F,Q=!1,U)=>{const i="NHWC"===n.format,a=i?1:2,l=i?2:3,c=i?3:1,g=ShapeUtil2.size(B),d=Q?2:1,I=n.group,o=e[1].dims,r=o[0]/I,u=o[1];let b=`\n  fn setOutputAtIndex(flatIndex : u32, value : ${Q?`vec4<${U}>`:U}) {\n    result[flatIndex] = ${Q?`vec4<${U}>`:U}(value);\n  }`;s&&(b+=`\n    fn getBiasByOutputCoords(coords : vec4<u32>) -> ${Q?`vec4<${U}>`:U} {\n      return bias[coords.${i?"w":"y"}${Q?"/ 4":""}];\n    }`);const C=Q?4:1,p=inputVariable("W",e[1].dataType,e[1].dims,C),m=inputVariable("Dy",e[0].dataType,e[0].dims,C),G=[m,p];s&&G.push(inputVariable("bias",e[2].dataType,[B[c]],C));const V=outputVariable("result",e[0].dataType,B,C),x=`{\n        let batch: u32 = ${F?"global_id.z":"workgroup_id.z"} / outShape[1];\n        let r = ${F?"global_id.z":"workgroup_id.z"} % outShape[1];\n        let c = ${F?"global_id.y":"workgroup_id.y"} * ${d};\n        let d1: u32 = ${F?"global_id.x":"workgroup_id.x"} * 4;\n\n        let dyCorner = vec2<i32>(i32(r), i32(c)) - vec2<i32>(pads);\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        var dotProd: array<vec4<${U}>, ${d}>;\n        for (var i = 0; i < ${d}; i++) {\n          dotProd[i] = vec4<${U}>(0.0);\n        }\n        for (var wR: u32 = 0; wR < filterDims[0]; wR = wR + 1) {\n          var dyR = (${U}(dyCorner.x) + ${U}(wR)) / ${U}(strides.x);\n          let wRPerm = filterDims[0] - 1 - wR;\n          if (dyR < 0.0 || dyR >= ${U}(outBackprop[1]) ||\n              fract(dyR) > 0.0 || wRPerm < 0) {\n            continue;\n          }\n          let idyR: u32 = u32(dyR);\n\n          for (var wC: u32 = 0; wC < filterDims[1]; wC = wC + 1) {\n            let dyC = (${U}(dyCorner.y) + ${U}(wC)) / ${U}(strides.y);\n            let dyC2 = (${U}(dyCorner.y) + 1.0 + ${U}(wC)) / ${U}(strides.y);\n            let wCPerm = filterDims[1] - 1 - wC;\n            if (wCPerm < 0) {\n              continue;\n            }\n            var bDyCVal = true;\n            var bDyCVal2 = true;\n            if (dyC < 0.0 || dyC >= ${U}(outBackprop[2]) ||\n                fract(dyC) > 0.0) {\n              bDyCVal = false;\n            }\n            if (dyC2 < 0.0 || dyC2 >= ${U}(outBackprop[2]) ||\n                fract(dyC2) > 0.0) {\n              bDyCVal2 = false;\n            }\n\n            let idyC: u32 = u32(dyC);\n            let idyC2: u32 = u32(dyC2);\n            if (bDyCVal && bDyCVal2) {\n              let d2Length = outBackprop[3];\n              for (var d2 :u32 = 0; d2 < d2Length; d2 = d2 + 4) {\n                let wValue0 = ${p.get("u32(wRPerm)","u32(wCPerm)","d1","d2")};\n                let wValue1 = ${p.get("u32(wRPerm)","u32(wCPerm)","d1 + 1","d2")};\n                let wValue2 = ${p.get("u32(wRPerm)","u32(wCPerm)","d1 + 2","d2")};\n                let wValue3 = ${p.get("u32(wRPerm)","u32(wCPerm)","d1 + 3","d2")};\n\n                var xValue = ${m.get("batch","idyR","idyC","d2")};\n                let tmpval = vec4<${U}>(dot(xValue, wValue0),\n                                      dot(xValue, wValue1),\n                                      dot(xValue, wValue2),\n                                      dot(xValue, wValue3));\n                dotProd[0] = dotProd[0] + tmpval;\n\n                xValue =  ${m.get("batch","idyR","idyC2","d2")};\n\n                dotProd[1] = dotProd[1] + vec4<${U}>(dot(xValue, wValue0),\n                                                    dot(xValue, wValue1),\n                                                    dot(xValue, wValue2),\n                                                    dot(xValue, wValue3));\n              }\n            } else if (bDyCVal) {\n              let d2Length = outBackprop[${c}];\n              for (var d2: u32 = 0; d2 < d2Length; d2 = d2 + 4) {\n                let wValue0 = ${p.get("u32(wRPerm)","u32(wCPerm)","d1","d2")};\n                let wValue1 = ${p.get("u32(wRPerm)","u32(wCPerm)","d1 + 1","d2")};\n                let wValue2 = ${p.get("u32(wRPerm)","u32(wCPerm)","d1 + 2","d2")};\n                let wValue3 = ${p.get("u32(wRPerm)","u32(wCPerm)","d1 + 3","d2")};\n\n                var xValue = ${m.get("batch","idyR","idyC","d2")};\n                let tmpval = vec4<${U}>(dot(xValue, wValue0),\n                                      dot(xValue, wValue1),\n                                      dot(xValue, wValue2),\n                                      dot(xValue, wValue3));\n                dotProd[0] = dotProd[0] + tmpval;\n              }\n            } else if (bDyCVal2) {\n              let d2Length = outBackprop[3];\n              for (var d2: u32 = 0; d2 < d2Length; d2 = d2 + 4) {\n                let wValue0 = ${p.get("u32(wRPerm)","u32(wCPerm)","d1","d2")};\n                let wValue1 = ${p.get("u32(wRPerm)","u32(wCPerm)","d1 + 1","d2")};\n                let wValue2 = ${p.get("u32(wRPerm)","u32(wCPerm)","d1 + 2","d2")};\n                let wValue3 = ${p.get("u32(wRPerm)","u32(wCPerm)","d1 + 3","d2")};\n\n                var xValue = ${m.get("batch","idyR","idyC2","d2")};\n                let tmpval = vec4<${U}>(dot(xValue, wValue0),\n                                      dot(xValue, wValue1),\n                                      dot(xValue, wValue2),\n                                      dot(xValue, wValue3));\n                dotProd[1] = dotProd[1] + tmpval;\n              }\n            }\n          }\n        }\n\n        for (var i: u32 = 0; i < ${d}; i = i + 1) {\n          let value = dotProd[i] + ${s?"bias[c+i]":`vec4<${U}>(0.0)`};\n          ${V.set("batch","r","c + i","d1","value")};\n        }\n      }`,h=`\n          let outputIndices = ${V.offsetToIndices("global_idx")};\n          let batch = ${V.indicesGet("outputIndices",0)};\n          let d1 = ${V.indicesGet("outputIndices",c)};\n          let r = ${V.indicesGet("outputIndices",a)};\n          let c = ${V.indicesGet("outputIndices",l)};\n          let dyCorner = vec2<i32>(i32(r), i32(c)) - pads;\n          let dyRCorner = dyCorner.x;\n          let dyCCorner = dyCorner.y;\n          let groupId = d1 / ${u};\n          let wOutChannel = d1 - groupId * ${u};\n          // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n          // ? = to be determined. : = across all values in that axis.\n          var dotProd = ${U}(0.0);\n          for (var wR: u32 = 0; wR < effectiveFilterDims.x; wR = wR + 1) {\n            if (wR % dilations.x != 0) {\n              continue;\n            }\n            let dyR = (${U}(dyRCorner) + ${U}(wR)) / ${U}(strides[0]);\n            let wRPerm = filterDims.x - 1 - wR / dilations.x;\n            if (dyR < 0.0 || dyR >= ${U}(outBackprop[${a}]) || fract(dyR) > 0.0 ||\n                wRPerm < 0) {\n              continue;\n            }\n            let idyR: u32 = u32(dyR);\n\n            for (var wC: u32 = 0; wC < effectiveFilterDims.y; wC = wC + 1) {\n              if (wC % dilations.y != 0) {\n                continue;\n              }\n              let dyC = (${U}(dyCCorner) + ${U}(wC)) / ${U}(strides.y);\n              let wCPerm = filterDims.y - 1 - wC / dilations.y;\n              if (dyC < 0.0 || dyC >= ${U}(outBackprop[${l}]) ||\n                  fract(dyC) > 0.0 || wCPerm < 0) {\n                continue;\n              }\n              let idyC: u32 = u32(dyC);\n              var inputChannel = groupId * ${r};\n              for (var d2: u32 = 0; d2 < ${r}; d2 = d2 + 1) {\n                let xValue = ${i?m.get("batch","idyR","idyC","inputChannel"):m.get("batch","inputChannel","idyR","idyC")};\n                let wValue = ${p.get("inputChannel","wOutChannel","u32(wRPerm)","u32(wCPerm)")};\n                dotProd = dotProd + xValue * wValue;\n                inputChannel = inputChannel + 1;\n              }\n            }\n          }\n          let value = dotProd + ${s?"bias[d1]":`${U}(0.0)`};\n          ${V.setByOffset("global_idx","value")};\n        `;return`\n  ${t.declareVariables(...G,V)}\n  ${b}\n  const outShape : vec4<u32> = vec4<u32>(${B.join(",")});\n  const outBackprop : vec4<u32> = vec4<u32>(${e[0].dims.join(",")});\n  const strides : vec2<u32> = vec2<u32>(${n.strides[0]}, ${n.strides[1]});\n  const filterDims : vec2<u32> = vec2<u32>(${n.kernelShape[i?1:2]}, ${n.kernelShape[i?2:3]});\n  const dilations : vec2<u32> = vec2<u32>(${n.dilations[0]}, ${n.dilations[1]});\n  const effectiveFilterDims : vec2<u32> = filterDims + vec2<u32>(\n          ${n.dilations[0]<=1?0:(n.kernelShape[i?1:2]-1)*(n.dilations[0]-1)},\n          ${n.dilations[1]<=1?0:(n.kernelShape[i?2:3]-1)*(n.dilations[1]-1)});\n  const pads : vec2<i32> = vec2<i32>(i32(effectiveFilterDims[0]) - 1 - (${n.pads[0]+n.pads[2]})/2,\n                                     i32(effectiveFilterDims[1]) - 1 - (${n.pads[1]+n.pads[3]})/2);\n    ${t.mainStart()}\n    ${t.guardAgainstOutOfBoundsWorkgroupSizes(g)};\n  ${Q?x:h}}`},createConvTranspose2DProgramInfo=(t,e,n)=>{const B=t.length>2,s=e.outputShape,F=ShapeUtil2.size(s),Q=[Math.ceil(F/64),1,1];LOG_DEBUG("verbose",(()=>`[conv2d_backprop_webgpu] dispatch = ${Q}`));const U=tensorTypeToWsglStorageType(t[0].dataType);return{name:"ConvTranspose2D",shaderCache:{hint:e.cacheKey},getRunData:()=>({dispatchGroup:{x:Q[0],y:Q[1],z:Q[2]},outputs:[{dims:n?n(s):s,dataType:t[0].dataType}]}),getShaderSource:n=>createConvTranspose2DOpProgramShaderSource(n,t,e,s,B,1===Q[1]&&1===Q[2],!1,U)}}}}),computeTotalPad2,distributePadding2,calculateOutputShapeAndPads2,getAdjustedConvTransposeAttributes2,parseConvTransposeAttributes2,validateInputs35,weightTransposePerm,convTranspose2d2,convTranspose1d,convTranspose2,init_conv_transpose2=__esm({"web/lib/wasm/jsep/webgpu/ops/conv-transpose.ts"(){init_attribute_with_cache_key2(),init_conv_backprop_mm_webgpu(),init_conv_backprop_webgpu(),init_fuse_utils2(),init_transpose2(),computeTotalPad2=(t,e,n,B,s,F)=>(t-1)*e+n+(B-1)*s+1-F,distributePadding2=(t,e,n,B,s)=>{const F=Math.floor(t/2);"SAME_UPPER"===e?(n[B]=F,n[s]=t-F):"SAME_LOWER"===e&&(n[B]=t-F,n[s]=F)},calculateOutputShapeAndPads2=(t,e,n,B,s,F,Q,U,i,a)=>{const l=t.length-2,c=0===a.length;if(0===i.length)for(let t=0;t<l;++t)i.push(0);const g=t[0],d=e[U?3:1]*s;for(let s=0,g=t.length-l-(U?1:0);s<l;++s,++g){const U=t[g],d=c?U*Q[s]:a[s],I=computeTotalPad2(U,Q[s],F[s],e[g],n[s],d);distributePadding2(I,B,F,s,s+l),c&&a.push(Q[s]*(U-1)+i[s]+(e[g]-1)*n[s]+1-F[s]-F[s+l])}a.splice(0,0,g),a.splice(U?3:1,0,d)},getAdjustedConvTransposeAttributes2=(t,e)=>{const n=t.kernelShape.slice();if(0===t.kernelShape.length||0===t.kernelShape.reduce(((t,e)=>t*e),1)){n.length=0;for(let t=2;t<e[1].dims.length;++t)n.push(e[1].dims[t])}const B="NHWC"===t.format;n.splice(0,0,e[1].dims[0]),n.splice(B?3:1,0,e[1].dims[1]);const s=t.pads.slice(),F=t.outputShape.slice(),Q=t.outputPadding.slice(),U=e[0].dims;let i=t.dilations.slice();if(0===i.reduce(((t,e)=>t+e),0)){const t=e[0].dims.length-2;i=new Array(t).fill(1)}let a=t.strides.slice();if(0===a.reduce(((t,e)=>t+e),0)){const t=e[0].dims.length-2;a=new Array(t).fill(1)}calculateOutputShapeAndPads2(U,n,i,t.autoPad,t.group,s,a,B,Q,F);const l=Object.assign({},t),c=t.cacheKey+[n.join("n,"),s.join(","),a.join(","),Q.join(","),F.join(","),i.join(",")].join("_");return Object.assign(l,{kernelShape:n,pads:s,outputPadding:Q,outputShape:F,dilations:i,strides:a,cacheKey:c}),l},parseConvTransposeAttributes2=t=>{const e=parseInternalActivationAttributes2(t),n=t.format,B=["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][void 0===t.autoPad?0:t.autoPad],s=t.dilations,F=t.group,Q=t.kernelShape,U=t.pads,i=t.strides,a=t.wIsConst(),l=t.outputPadding,c=t.outputShape;return createAttributeWithCacheKey2({autoPad:B,format:n,dilations:s,group:F,kernelShape:Q,outputPadding:l,outputShape:c,pads:U,strides:i,wIsConst:a,...e})},validateInputs35=(t,e)=>{if(!t||2!==t.length&&3!==t.length)throw new Error("Conv requires 2 or 3 inputs");if(4!==t[0].dims.length&&3!==t[0].dims.length)throw new Error("currently only support 2-dimensional conv");if(t[0].dims.length!==t[1].dims.length)throw new Error("filter does not have same dimension as input");if(t[0].dims["NHWC"===e.format?t[0].dims.length-1:1]!==t[1].dims[0])throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");const n=t[1].dims[1]*e.group;if(3===t.length&&(1!==t[2].dims.length||t[2].dims[0]!==n))throw new Error("invalid bias");const B=t[0].dims.length-2;if(e.dilations.reduce(((t,e)=>t+e),0)>0&&e.dilations.length!==B)throw new Error(`dilations should be ${B}D`);if(e.strides.reduce(((t,e)=>t+e),0)>0&&e.strides.length!==B)throw new Error(`strides should be ${B}D`);if(e.pads.reduce(((t,e)=>t+e),0)>0&&e.pads.length!==2*B)throw new Error(`pads should be ${2*B}D`);if(e.outputPadding.length!==B&&0!==e.outputPadding.length)throw new Error(`output_padding should be ${B}D`);if(e.kernelShape.reduce(((t,e)=>t+e),0)>0&&0!==e.kernelShape.length&&e.kernelShape.length!==t[1].dims.length-2)throw new Error("invalid kernel shape");if(0!==e.outputShape.length&&e.outputShape.length!==t[0].dims.length-2)throw new Error("invalid output shape")},weightTransposePerm=[2,3,1,0],convTranspose2d2=(t,e,n)=>{const B=getAdjustedConvTransposeAttributes2(n,e),s="NHWC"===n.format,F=B.outputShape,Q=F[s?3:1],U=e[0].dims[s?3:1];if(1!==B.group||1===Q&&1===U)return void t.compute(createConvTranspose2DProgramInfo(e,B));const i=F[s?1:2],a=F[s?2:3],l=s?i*a:Q,c=s?Q:i*a,g=e[1].dims[2]*e[1].dims[3]*U,d=t.kernelCustomData.wT??t.compute(createTransposeProgramInfo2(e[1],weightTransposePerm),{inputs:[1],outputs:[n.wIsConst?-2:-1]})[0];n.wIsConst&&!t.kernelCustomData.wT&&(t.kernelCustomData.wT=d);const I=[e[0],d],o=3===e.length;o&&(s||1!==e[2].dims.length?I.push(e[2]):I.push(e[2].reshape([e[2].dims[0],1,1]))),t.compute(createConv2DTransposeMatMulProgramInfo(I,B,F,l,c,g,o,!0),{inputs:I})},convTranspose1d=(t,e)=>{const n="NHWC"===e.format,B=[t.inputs[0].reshape(n?[t.inputs[0].dims[0],1,t.inputs[0].dims[1],t.inputs[0].dims[2]]:[t.inputs[0].dims[0],t.inputs[0].dims[1],1,t.inputs[0].dims[2]]),t.inputs[1].reshape([t.inputs[1].dims[0],t.inputs[1].dims[1],1,t.inputs[1].dims[2]])];3===B.length&&B.push(t.inputs[2]);let s=e.kernelShape;0!==s.length&&0!==s[0]||(s=[t.inputs[1].dims[2]]);let F=e.dilations;0!==F.length&&0!==F[0]||(F=[1]);let Q=e.strides;0!==Q.length&&0!==Q[0]||(Q=[1]);let U=e.pads;0===U.length&&(U=[0,0]),U=[0,U[0],0,U[1]],Q=[1].concat(Q),F=[1].concat(F),s=[1].concat(s);const i=getAdjustedConvTransposeAttributes2({...e,pads:U,strides:Q,dilations:F,kernelShape:s},B);t.compute(createConvTranspose2DProgramInfo(B,i,(t=>n?[t[0],t[2],t[3]]:[t[0],t[1],t[3]])))},convTranspose2=(t,e)=>{validateInputs35(t.inputs,e),3===t.inputs[0].dims.length?convTranspose1d(t,e):convTranspose2d2(t,t.inputs,e)}}}),createCumsumProgramInfo,cumsum,parseCumSumAttributes,init_cumsum=__esm({"web/lib/wasm/jsep/webgpu/ops/cumsum.ts"(){init_wasm_common(),init_util2(),init_attribute_with_cache_key2(),init_common(),createCumsumProgramInfo=(t,e,n,B)=>{const s=ShapeUtil2.size(e),F=e.length,Q=inputVariable("input",t,F),U=outputVariable("output",t,F),i=6===n.dataType?n.getInt32Array()[0]:Number(n.getBigInt64Array()[0]),a=ShapeUtil2.normalizeAxis(i,F);return{name:"CumSum",shaderCache:{hint:B.cacheKey,inputDependencies:["rank"]},getRunData:()=>({outputs:[{dims:e,dataType:t}],dispatchGroup:{x:Math.ceil(s/64)},programUniforms:[{type:"uint32",data:s},{type:"int32",data:a},...createTensorShapeVariables(e),...createTensorShapeVariables(e)]}),getShaderSource:t=>{const e=` i32(${Q.indicesGet("inputIndices","uniforms.axis")}) `,n=getElementAt("uniforms.input_shape","uniforms.axis",F),s=B.reverse?e+(B.exclusive?" + 1":""):"0",i=B.reverse?n:e+(B.exclusive?"":" + 1");return`\n                ${t.registerUniform("outputSize","u32").registerUniform("axis","u32").declareVariables(Q,U)}\n                ${t.mainStart()}\n                  ${t.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n                  var inputIndices = ${U.offsetToIndices("global_idx")};\n                  var sum = ${U.type.value}(0);\n                  let first : i32 = ${s};\n                  let last : i32 = ${i};\n                  for (var i : i32 = first; i < last; i++) {\n                    ${Q.indicesSet("inputIndices","uniforms.axis","u32(i)")};\n                    sum = sum + ${Q.getByIndices("inputIndices")};\n                  }\n                  ${U.setByOffset("global_idx","sum")};\n                }`}}},cumsum=(t,e)=>{const n=t.inputs[0].dims,B=t.inputs[0].dataType,s=t.inputs[1];t.compute(createCumsumProgramInfo(B,n,s,e),{inputs:[0]})},parseCumSumAttributes=t=>{const e=1===t.exclusive,n=1===t.reverse;return createAttributeWithCacheKey2({exclusive:e,reverse:n})}}}),symbolPattern,termPattern,termPatternOnly,lhsPattern,lhsPatternOnly,EinsumTerm,EinsumEquation,appendMax,createEinsumProgramInfo,einsum,parseEinsumAttributes,init_einsum=__esm({"web/lib/wasm/jsep/webgpu/ops/einsum.ts"(){init_util2(),init_attribute_with_cache_key2(),init_common(),termPatternOnly="^"+(termPattern="("+(symbolPattern="[a-zA-Z]|\\.\\.\\.")+")+")+"$",lhsPatternOnly="^"+(lhsPattern="("+termPattern+",)*"+termPattern)+"$",EinsumTerm=class{constructor(t=-1){this.symbolToIndices=new Map,this.inputIndex=t}addSymbol(t,e){let n=this.symbolToIndices.get(t);void 0===n?n=[e]:n.push(e),this.symbolToIndices.set(t,n)}},EinsumEquation=class{constructor(t,e){this.equation=e,this.hasEllipsis=!1,this.symbolToInfo=new Map,this.lhs=new Array,this.outputDims=[];let[n,B]=e.includes("->")?e.split("->",2):[e,""];if(!n.match(RegExp(lhsPatternOnly)))throw new Error("Invalid LHS term");if(n.split(",").forEach(((e,n)=>{const B=t[n].dims.slice();if(!e.match(RegExp(termPatternOnly)))throw new Error("Invalid LHS term");const s=this.processTerm(e,!0,B,n);this.lhs.push(s)})),""===B)B+=[...this.symbolToInfo.entries()].filter((([t,e])=>1===e.count||"..."===t)).map((([t])=>t)).join("");else if(!B.match(RegExp(termPattern)))throw new Error("Invalid RHS");const s=B.match(RegExp(symbolPattern,"g"));s?.forEach((t=>{if("..."===t)this.outputDims=this.outputDims.concat(this.ellipsisDims);else{const e=this.symbolToInfo.get(t);if(void 0===e)throw new Error("Invalid RHS symbol");this.outputDims.push(e.dimValue)}})),this.rhs=this.processTerm(B,!1,this.outputDims)}addSymbol(t,e,n){let B=this.symbolToInfo.get(t);if(void 0!==B){if(B.dimValue!==e&&1!==B.count)throw new Error("Dimension mismatch");B.count++,B.inputIndices.push(n)}else B={count:1,dimValue:e,inputIndices:[n]};this.symbolToInfo.set(t,B)}processTerm(t,e,n,B=-1){const s=n.length;let F=!1,Q=[],U=0;if(!t.match(RegExp(termPatternOnly))&&!e&&""!==t)throw new Error("Invalid LHS term");const i=t.match(RegExp(symbolPattern,"g")),a=new EinsumTerm(B);return i?.forEach(((t,l)=>{if("..."===t){if(F)throw new Error("Only one ellipsis is allowed per input term");F=!0;const t=s-i.length+1;if(t<0)throw new Error("Ellipsis out of bounds");if(Q=n.slice(U,U+t),this.hasEllipsis){if(this.ellipsisDims.length!==Q.length||this.ellipsisDims.toString()!==Q.toString())throw new Error("Ellipsis dimensions mismatch")}else{if(!e)throw new Error("Ellipsis must be specified in the LHS");this.hasEllipsis=!0,this.ellipsisDims=Q}for(let t=0;t<Q.length;t++){const e=String.fromCharCode("0".charCodeAt(0)+t);a.addSymbol(e,l+t),this.addSymbol(e,n[U++],B)}}else a.addSymbol(t,l+(this.hasEllipsis?this.ellipsisDims.length-1:0)),this.addSymbol(t,n[U++],B)})),a}},appendMax=t=>t+"_max",createEinsumProgramInfo=(t,e,n,B,s)=>{const F=e.map(((e,n)=>t[n]?e.length:e)).map(((t,e)=>inputVariable(`input${e}`,n,t))),Q=ShapeUtil2.size(s),U=enableShapesUniforms(s.length),i=U?s.length:s,a=outputVariable("output",n,i),l=[...B.symbolToInfo.keys()].filter((t=>!B.rhs.symbolToIndices.has(t)));return{name:"Einsum",shaderCache:{hint:B.equation,inputDependencies:t.map((t=>t?"rank":"dims"))},getRunData:()=>{const F=l.filter((t=>B.symbolToInfo.has(t))).map((t=>({type:"uint32",data:B.symbolToInfo.get(t)?.dimValue||0})));F.push({type:"uint32",data:Q});const i=e.filter(((e,n)=>t[n])).map(((t,e)=>[...createTensorShapeVariables(t)])).reduce(((t,e)=>t.concat(e)),F);return U&&i.push(...createTensorShapeVariables(s)),{outputs:[{dims:s,dataType:n}],dispatchGroup:{x:Math.ceil(Q/64)},programUniforms:i}},getShaderSource:t=>{const e=[],n=[],s=[],Q=[],U=[],i=B.symbolToInfo.size===B.rhs.symbolToIndices.size;B.symbolToInfo.forEach(((t,i)=>{if(B.rhs.symbolToIndices.has(i)){const n=B.rhs.symbolToIndices.get(i)?.[0];void 0!==n&&B.lhs.forEach(((B,s)=>{if(t.inputIndices.includes(s)){const t=B.symbolToIndices.get(i);if(void 0===t)throw new Error("Invalid symbol error");t.forEach((t=>{e.push(`${F[s].indicesSet(`input${s}Indices`,t,a.indicesGet("outputIndices",n))}`)}))}}))}else B.lhs.forEach(((e,B)=>{if(t.inputIndices.includes(B)){const t=e.symbolToIndices.get(i);if(void 0===t)throw new Error("Invalid symbol error");t.forEach((t=>{n.push(`${F[B].indicesSet(`input${B}Indices`,t,`${i}`)}`)})),U.push(`prod *= ${F[B].getByIndices(`input${B}Indices`)};`)}})),s.push(`for(var ${i}: u32 = 0; ${i} < uniforms.${appendMax(i)}; ${i}++) {`),Q.push("}")}));const c=i?[...e,`let sum = ${F.map(((t,e)=>t.getByIndices(`input${e}Indices`))).join(" * ")};`]:[...e,"var sum = 0.0;",...s,...n,"var prod = 1.0;",...U,"sum += prod;",...Q];return`\n            ${t.registerUniforms(l.map((t=>({name:`${appendMax(t)}`,type:"u32"})))).registerUniform("outputSize","u32").declareVariables(...F,a)}\n\n            ${t.mainStart()}\n            ${t.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n            var outputIndices = ${a.offsetToIndices("global_idx")};\n            ${F.map(((t,e)=>`var input${e}Indices: ${F[e].type.indices};`)).join("\n")}\n            ${c.join("\n")};\n            ${a.setByOffset("global_idx","sum")};\n          }`}}},einsum=(t,e)=>{const n=new EinsumEquation(t.inputs,e.equation),B=t.inputs.map(((t,e)=>enableShapesUniforms(t.dims.length))),s=n.outputDims,F=t.inputs.map(((t,e)=>t.dims));t.compute(createEinsumProgramInfo(B,F,t.inputs[0].dataType,n,s))},parseEinsumAttributes=t=>{const e=t.equation.replace(/\s+/g,"");return createAttributeWithCacheKey2({equation:e})}}}),validateInputs36,getAdjustedShape,calculateOutputShape3,createExpandProgramInfo,expand,init_expand=__esm({"web/lib/wasm/jsep/webgpu/ops/expand.ts"(){init_wasm_common(),init_util2(),init_common(),validateInputs36=t=>{if(!t||2!==t.length)throw new Error("Expand requires 2 input.");const e=t[0].dims,n=Array.from(t[1].getBigInt64Array(),Number);let B=n.length<e.length?0:n.length-e.length,s=e.length<n.length?0:e.length-n.length;for(;B<n.length&&s<e.length;++B,++s)if(n[B]!==e[s]&&1!==n[B]&&1!==e[s])throw new Error("Expand requires shape to be broadcastable to input")},getAdjustedShape=(t,e)=>{const n=t.length-e.length,B=[];for(let e=0;e<n;++e)B.push(t[e]);for(let s=0;s<e.length;++s)B.push(1===e[s]?t[s+n]:e[s]);return B},calculateOutputShape3=(t,e)=>t.length>e.length?getAdjustedShape(t,e):getAdjustedShape(e,t),createExpandProgramInfo=t=>{const e=t[0].dims,n=Array.from(t[1].getBigInt64Array(),Number),B=calculateOutputShape3(e,n),s=t[0].dataType,F=9===s?4:1,Q=Math.ceil(ShapeUtil2.size(B)/F),U=enableShapesUniforms(e.length),i=enableShapesUniforms(B.length),a=[{type:"uint32",data:Q}];return U&&a.push(...createTensorShapeVariables(e)),i&&a.push(...createTensorShapeVariables(B)),{name:"Expand",shaderCache:{hint:`${B.length}`,inputDependencies:[U?"rank":"dims"]},getShaderSource:t=>{const n=U?e.length:e,Q=i?B.length:B,a=inputVariable("input",s,n,F),l=outputVariable("output",s,Q,F);let c;if(9===s){const t=(t,e,n="")=>`\n          let outputIndices${e} = ${l.offsetToIndices(`outputOffset + ${e}u`)};\n          let offset${e} = ${a.broadcastedIndicesToOffset(`outputIndices${e}`,l)};\n          let index${e} = offset${e} / 4u;\n          let component${e} = offset${e} % 4u;\n          ${t}[${e}] = ${n}(${a.getByOffset(`index${e}`)}[component${e}]);\n        `;c=`\n        let outputOffset = global_idx * ${F};\n        var data = vec4<u32>(0);\n        ${t("data",0,"u32")}\n        ${t("data",1,"u32")}\n        ${t("data",2,"u32")}\n        ${t("data",3,"u32")}\n        ${l.setByOffset("global_idx","data")}\n      }`}else c=`\n        let outputIndices = ${l.offsetToIndices("global_idx")};\n        let inputOffset = ${a.broadcastedIndicesToOffset("outputIndices",l)};\n        ${l.setByOffset("global_idx",a.getByOffset("inputOffset"))}\n      }`;return`\n    ${t.registerUniform("vec_size","u32").declareVariables(a,l)}\n    ${t.mainStart()}\n    ${t.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}\n    ${c}`},getRunData:()=>({outputs:[{dims:B,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(Q/64)},programUniforms:a})}},expand=t=>{validateInputs36(t.inputs),t.compute(createExpandProgramInfo(t.inputs),{inputs:[0]})}}}),validateInputs37,createGatherProgramInfo2,parseGatherAttributes2,gather2,init_gather2=__esm({"web/lib/wasm/jsep/webgpu/ops/gather.ts"(){init_wasm_common(),init_util2(),init_attribute_with_cache_key2(),init_common(),validateInputs37=t=>{if(!t||2!==t.length)throw new Error("Gather requires 2 inputs.")},createGatherProgramInfo2=(t,e)=>{const n=t[0].dims,B=t[1].dims,s=n.length,F=ShapeUtil2.normalizeAxis(e.axis,s),Q=n.slice(0);Q.splice(F,1,...B);const U=n[F],i=9===t[0].dataType?4:1,a=Math.ceil(ShapeUtil2.size(Q)/i),l=enableShapesUniforms(t[0].dims.length),c=l?t[0].dims.length:t[0].dims,g=enableShapesUniforms(t[1].dims.length),d=g?t[1].dims.length:t[1].dims,I=enableShapesUniforms(Q.length),o=I?Q.length:Q,r=[{type:"uint32",data:a},{type:"int32",data:U},{type:"uint32",data:F}];l&&r.push(...createTensorShapeVariables(t[0].dims)),g&&r.push(...createTensorShapeVariables(t[1].dims)),I&&r.push(...createTensorShapeVariables(Q));const u=[];u.push(l?"rank":"dims"),u.push(g?"rank":"dims");return{name:"Gather",shaderCache:{hint:e.cacheKey,inputDependencies:u},getRunData:()=>({outputs:[{dims:Q,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(a/64)},programUniforms:r}),getShaderSource:e=>{const n=inputVariable("data",t[0].dataType,c,i),U=inputVariable("inputIndices",t[1].dataType,d),a=outputVariable("output",t[0].dataType,o,i),l=t=>{const e=B.length;let i=`var indicesIndices${t}  = ${U.type.indices}(0);`;for(let n=0;n<e;n++)i+=`${e>1?`indicesIndices${t}[${n}]`:`indicesIndices${t}`} = ${Q.length>1?`outputIndices${t}[uniforms.axis + ${n}]`:`outputIndices${t}`};`;i+=`\n          var idx${t} = ${U.getByIndices(`indicesIndices${t}`)};\n          if (idx${t} < 0) {\n            idx${t} = idx${t} + uniforms.axisDimLimit;\n          }\n          var dataIndices${t} = ${n.type.indices}(0);\n        `;for(let n=0,B=0;n<s;n++)n===F?(i+=`${s>1?`dataIndices${t}[${n}]`:`dataIndices${t}`} = u32(idx${t});`,B+=e):(i+=`${s>1?`dataIndices${t}[${n}]`:`dataIndices${t}`} = ${Q.length>1?`outputIndices${t}[${B}]`:`outputIndices${t}`};`,B++);return i};let g;if(9===t[0].dataType){const t=(t,e,B="")=>`\n          let outputIndices${e} = ${a.offsetToIndices(`outputOffset + ${e}u`)};\n          ${l(e)};\n          let offset${e} = ${n.indicesToOffset(`dataIndices${e}`)};\n          let index${e} = offset${e} / 4u;\n          let component${e} = offset${e} % 4u;\n          ${t}[${e}] = ${B}(${n.getByOffset(`index${e}`)}[component${e}]);\n        `;g=`\n        let outputOffset = global_idx * ${i};\n        var value = vec4<u32>(0);\n        ${t("value",0,"u32")}\n        ${t("value",1,"u32")}\n        ${t("value",2,"u32")}\n        ${t("value",3,"u32")}\n        ${a.setByOffset("global_idx","value")}\n      `}else g=`\n      let outputIndices = ${a.offsetToIndices("global_idx")};\n      ${l("")};\n      let value = ${n.getByIndices("dataIndices")};\n      ${a.setByOffset("global_idx","value")};\n      `;return`\n      ${e.registerUniform("outputSize","u32").registerUniform("axisDimLimit","i32").registerUniform("axis","u32").declareVariables(n,U,a)}\n      ${e.mainStart()}\n        ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n        ${g}\n      }`}}},parseGatherAttributes2=t=>createAttributeWithCacheKey2({axis:t.axis}),gather2=(t,e)=>{const n=t.inputs;validateInputs37(n),t.compute(createGatherProgramInfo2(t.inputs,e))}}}),validateInputs38,createGatherElementsProgramInfo,parseGatherElementsAttributes,gatherElements,init_gather_elements=__esm({"web/lib/wasm/jsep/webgpu/ops/gather-elements.ts"(){init_util2(),init_attribute_with_cache_key2(),init_common(),validateInputs38=t=>{if(!t||2!==t.length)throw new Error("GatherElements requires 2 inputs.");if(t[0].dims.length<1)throw new Error("GatherElements requires that the data input be rank >= 1.");if(t[0].dims.length!==t[1].dims.length)throw new Error("GatherElements requires that the data input and\n                     indices input tensors be of same rank.")},createGatherElementsProgramInfo=(t,e)=>{const n=t[0].dims,B=t[0].dataType,s=n.length,F=t[1].dims,Q=t[1].dataType,U=ShapeUtil2.normalizeAxis(e.axis,s),i=n[U],a=F.slice(0),l=ShapeUtil2.size(a),c=inputVariable("input",B,s),g=inputVariable("indicesInput",Q,F.length),d=outputVariable("output",B,a.length),I=[{type:"uint32",data:l},{type:"int32",data:i},{type:"uint32",data:U}];I.push(...createTensorShapeVariables(n)),I.push(...createTensorShapeVariables(F)),I.push(...createTensorShapeVariables(a));return{name:"GatherElements",shaderCache:{inputDependencies:["rank","rank"]},getRunData:()=>({outputs:[{dims:a,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(l/64)},programUniforms:I}),getShaderSource:t=>`\n      ${t.registerUniform("outputSize","u32").registerUniform("axisDimLimit","i32").registerUniform("axis","u32").declareVariables(c,g,d)}\n      ${t.mainStart()}\n      ${t.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n\n      let outputIndices = ${d.offsetToIndices("global_idx")};\n\n      var idx = ${g.getByOffset("global_idx")};\n      if (idx < 0) {\n        idx = idx + uniforms.axisDimLimit;\n      }\n      var inputIndices = ${c.type.indices}(outputIndices);\n      ${c.indicesSet("inputIndices","uniforms.axis","u32(idx)")};\n      let value = ${c.getByIndices("inputIndices")};\n\n      ${d.setByOffset("global_idx","value")};\n  }`}},parseGatherElementsAttributes=t=>createAttributeWithCacheKey2({axis:t.axis}),gatherElements=(t,e)=>{const n=t.inputs;validateInputs38(n),t.compute(createGatherElementsProgramInfo(t.inputs,e))}}}),validateInputs39,createGemmProgramInfo2,parseGemmAttributes2,gemm2,init_gemm2=__esm({"web/lib/wasm/jsep/webgpu/ops/gemm.ts"(){init_util2(),init_common(),validateInputs39=t=>{if(!t)throw new Error("Input is missing");if(t.length<2||t.length>3)throw new Error("Invaid input number.");if(3===t.length&&t[2].dims.length>2)throw new Error("Invalid input shape of C");if(t[0].dataType!==t[1].dataType||3===t.length&&t[0].dataType!==t[2].dataType)throw new Error("Input types are mismatched")},createGemmProgramInfo2=(t,e)=>{const n=t[0].dims.slice(),B=t[1].dims.slice(),[s,F,Q]=GemmUtil2.getShapeOfGemmResult(n,e.transA,B,e.transB,3===t.length?t[2].dims:void 0),U=[s,F];if(!U)throw new Error("Can't use gemm on the given tensors");const i=ShapeUtil2.size(U),a=[{type:"uint32",data:i},{type:"uint32",data:s},{type:"uint32",data:F},{type:"uint32",data:Q},{type:"float32",data:e.alpha},{type:"float32",data:e.beta}],l=["type","type"];3===t.length&&(a.push(...createTensorShapeVariables(t[2].dims)),l.push("rank")),a.push(...createTensorShapeVariables(U));return{name:"Gemm",shaderCache:{hint:`${e.cacheKey}`,inputDependencies:l},getRunData:()=>({outputs:[{dims:U,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(i/64)},programUniforms:a}),getShaderSource:n=>{let B="";e.transA&&e.transB?B="value += a[k * uniforms.M + m] * b[n * uniforms.K + k];":e.transA&&!e.transB?B="value += a[k * uniforms.M + m] * b[k * uniforms.N + n];":!e.transA&&e.transB?B="value += a[m * uniforms.K + k] * b[n * uniforms.K + k];":e.transA||e.transB||(B="value += a[m * uniforms.K + k] * b[k * uniforms.N + n];");const s=1===e.alpha?"":"value *= uniforms.alpha;",F=inputVariable("a",t[0].dataType,t[0].dims),Q=inputVariable("b",t[1].dataType,t[1].dims),i=F.type.value;let a=null;const l=[F,Q];3===t.length&&(a=inputVariable("c",t[2].dataType,t[2].dims.length),l.push(a));const c=outputVariable("output",t[0].dataType,U.length);l.push(c);return`\n  ${n.registerUniforms([{name:"output_size",type:"u32"},{name:"M",type:"u32"},{name:"N",type:"u32"},{name:"K",type:"u32"},{name:"alpha",type:"f32"},{name:"beta",type:"f32"}]).declareVariables(...l)}\n\n  ${n.mainStart()}\n    ${n.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n\n    let m = global_idx / uniforms.N;\n    let n = global_idx % uniforms.N;\n\n    var value = ${i}(0);\n    for (var k: u32 = 0u; k < uniforms.K; k++) {\n      ${B}\n    }\n\n    ${s}\n    ${null!=a?`let cOffset = ${a.broadcastedIndicesToOffset("vec2(m, n)",c)}; value += ${i}(uniforms.beta) * ${a.getByOffset("cOffset")};`:""}\n    output[global_idx] = value;\n  }`}}},parseGemmAttributes2=t=>({transA:t.transA,transB:t.transB,alpha:t.alpha,beta:t.beta,cacheKey:`${t.transA};${t.transB};${1===t.alpha}`}),gemm2=(t,e)=>{validateInputs39(t.inputs),t.compute(createGemmProgramInfo2(t.inputs,e))}}}),createInstanceNormProgramInfo,computeMean,createInstanceNormNHWCProgramInfo,instanceNorm,init_instance_norm=__esm({"web/lib/wasm/jsep/webgpu/ops/instance-norm.ts"(){init_wasm_common(),init_util2(),init_common(),createInstanceNormProgramInfo=(t,e)=>{const n=t[0].dims,B=n,s=ShapeUtil2.sizeToDimension(n,2),F=ShapeUtil2.sizeFromDimension(n,2),Q=getMaxComponents(F),U=F/Q,i=[n[0],n[1],U],a=[{type:"uint32",data:F},{type:"uint32",data:U}];a.push(...createTensorShapeVariables(i),...createTensorShapeVariables(i));return{name:"InstanceNormalization",shaderCache:{hint:`${e.epsilon};${Q}`,inputDependencies:["rank","type","type"]},getRunData:()=>({outputs:[{dims:B,dataType:t[0].dataType}],dispatchGroup:{x:s},programUniforms:a}),getShaderSource:n=>{const B=inputVariable("x",t[0].dataType,i.length,Q),s=inputVariable("scale",t[1].dataType,t[1].dims),F=inputVariable("bias",t[2].dataType,t[2].dims),U=outputVariable("output",t[0].dataType,i.length,Q),a=[B,s,F,U],l=B.type.value,c=1===Q?"f32":`vec${Q}<f32>`;return`\n  var<workgroup> meanShared : f32;\n  var<workgroup> squaredNormShared : f32;\n  var<workgroup> workgroupShared : array<${c}, 64>;\n  const workgroupSize = 64u;\n  ${n.registerUniforms([{name:"normSize",type:"u32"},{name:"normPackedSize",type:"u32"}]).declareVariables(...a)}\n  ${n.mainStart(64)}\n    let norm = global_idx / workgroupSize;\n    let batch = norm / uniforms.x_shape[1];\n    let channel = norm % uniforms.x_shape[1];\n    let localIndex = local_id.x;\n\n    // initialize workgroup memory\n    var initial = ${c}(0);\n    for (var h = localIndex; h < uniforms.normPackedSize; h += workgroupSize) {\n      initial = initial + ${c}(${B.get("batch","channel","h")});\n    }\n    workgroupShared[localIndex] = initial;\n    workgroupBarrier();\n\n    // Calculate the mean of current channel data.\n    for (var currSize = workgroupSize >> 1;  currSize > 0; currSize = currSize >> 1) {\n      if (localIndex < currSize) {\n        workgroupShared[localIndex] = workgroupShared[localIndex] + workgroupShared[localIndex + currSize];\n      }\n      workgroupBarrier();\n    }\n    if (localIndex == 0) {\n      meanShared = ${sumVector("workgroupShared[0]",Q)} / f32(uniforms.normSize);\n    }\n    workgroupBarrier();\n\n    // reinitialize workgroup memory.\n    initial = ${c}(0);\n    for (var h = localIndex; h < uniforms.normPackedSize; h += workgroupSize) {\n      let deviation =  ${c}(${B.get("batch","channel","h")}) - ${c}(meanShared);\n      initial = initial + deviation * deviation;\n    }\n    workgroupShared[localIndex] = initial;\n    workgroupBarrier();\n\n    // Calculate the sum of square of deviation of current channel data.\n    for (var currSize = workgroupSize >> 1;  currSize > 0; currSize = currSize >> 1) {\n      if (localIndex < currSize) {\n        workgroupShared[localIndex] = workgroupShared[localIndex] + workgroupShared[localIndex + currSize];\n      }\n      workgroupBarrier();\n    }\n    if (localIndex == 0) {\n      squaredNormShared = ${sumVector("workgroupShared[0]",Q)};\n    }\n    workgroupBarrier();\n\n    let invStdDev = inverseSqrt(squaredNormShared / f32(uniforms.normSize) + f32(${e.epsilon}));\n    let channelScale = invStdDev * f32(${s.getByOffset("channel")});\n    let channelShift = f32(${F.getByOffset("channel")}) - meanShared * channelScale;\n    for (var h = localIndex; h < uniforms.normPackedSize; h += workgroupSize) {\n      let value = ${B.get("batch","channel","h")} * ${l}(${c}(channelScale)) + ${l}(${c}(channelShift));\n      ${U.set("batch","channel","h","value")};\n    }\n  }`}}},computeMean=(t,e,n,B,s,F,Q,U)=>{const i=getMaxComponents(Q),a=64,l=1===i?"vec2f":`mat2x${i}f`,c=1===i?"f32":`vec${i}f`,g=(t,e)=>`${l}(${t}, ${e})`,d=s*Q/i,I=[{type:"uint32",data:Math.ceil(F/a)},{type:"uint32",data:F},{type:"uint32",data:Math.floor(Q/i)},{type:"uint32",data:Math.floor(F*Q/i)}],o=t.compute({name:"InstanceNormComputeMean",shaderCache:{hint:`${i}`,inputDependencies:["type"]},getRunData:()=>({outputs:[{dims:[s,Q,a,2],dataType:1}],dispatchGroup:{x:s*Q/i},programUniforms:I}),getShaderSource:t=>{const n=inputVariable("input",e.dataType,e.dims,i);return`\n  ${t.declareVariables(n)}\n  @group(0) @binding(1) var<storage, read_write> output : array<${l}>;\n  struct Uniforms {wg_size:u32, H:u32, C:u32, image_size:u32};\n  @group(0) @binding(2) var<uniform> uniforms: Uniforms;\n\n  ${t.mainStart(a)}\n    let currentImageNumber = global_idx / 64 / uniforms.C;\n    let currentChannelNumber = (global_idx / 64) % uniforms.C;\n    let wgId = global_idx % 64;\n    let wgOffset = wgId * uniforms.wg_size;\n    if (wgOffset >= uniforms.H) {\n        return;\n    }\n    let wgMax = min(wgOffset + uniforms.wg_size, uniforms.H);\n\n    let offset = currentImageNumber * uniforms.image_size + currentChannelNumber;\n    var sum = ${fillVector("f32",i)};\n    var squaredSum = ${fillVector("f32",i)};\n    for (var i: u32 = wgOffset; i < wgMax; i++) {\n        let value = ${c}(input[offset + i * uniforms.C]);\n        sum += value;\n        squaredSum += value * value;\n    }\n    output[global_idx] = ${g("sum","squaredSum")};\n  }`}},{inputs:[e],outputs:[-1]})[0],r=[{type:"uint32",data:d},{type:"uint32",data:F},{type:"uint32",data:Math.floor(Q/i)},{type:"uint32",data:Math.floor(a*Q/i)}];return t.compute({name:"InstanceNormComputeChannelScaleShift",shaderCache:{hint:`${i};${U}`,inputDependencies:["type","type","type"]},getRunData:()=>({outputs:[{dims:[s,Q,2],dataType:1}],dispatchGroup:{x:Math.ceil(d/64)},programUniforms:r}),getShaderSource:t=>{const e=inputVariable("scale",n.dataType,n.dims,i),s=inputVariable("bias",B.dataType,B.dims,i);return`\n  @group(0) @binding(0) var<storage, read> input : array<${l}>;\n  @group(0) @binding(1) var<storage, read> scale : array<${e.type.storage}>;\n  @group(0) @binding(2) var<storage, read> bias : array<${s.type.storage}>;\n  @group(0) @binding(3) var<storage, read_write> output : array<${l}>;\n  struct Uniforms {units_of_work : u32, H: u32, C : u32, image_size : u32};\n  @group(0) @binding(4) var<uniform> uniforms: Uniforms;\n\n  ${t.mainStart()}\n    ${t.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.units_of_work")}\n    let currentImageNumber = global_idx / uniforms.C;\n    let currentChannelNumber = global_idx % uniforms.C;\n\n    let offset = currentImageNumber * uniforms.image_size;\n    var sum = ${fillVector("f32",i)};\n    var squaredSum = ${fillVector("f32",i)};\n    for (var i: u32 = 0; i < 64; i++) {\n        let value = input[offset + i + currentChannelNumber * 64];\n        sum += value[0];\n        squaredSum += value[1];\n    }\n    sum = sum / f32(uniforms.H);\n    squaredSum = squaredSum / f32(uniforms.H);\n    let invStdDev = inverseSqrt(squaredSum - sum * sum + f32(${U}));\n    let channelScale = invStdDev * ${c}(scale[currentChannelNumber]);\n    let channelShift = ${c}(bias[currentChannelNumber]) - sum * channelScale;\n\n    output[global_idx] = ${g("channelScale","channelShift")};\n  }`}},{inputs:[o,n,B],outputs:[-1]})[0]},createInstanceNormNHWCProgramInfo=(t,e,n)=>{const B=e[0].dims,s=B,F=B[0],Q=B[B.length-1],U=ShapeUtil2.sizeFromDimension(B,1)/Q,i=getMaxComponents(Q),a=ShapeUtil2.size(s)/i,l=[{type:"uint32",data:U},{type:"uint32",data:Math.floor(Q/i)}],c=computeMean(t,e[0],e[1],e[2],F,U,Q,n.epsilon);t.compute({name:"InstanceNormalizationNHWC",shaderCache:{hint:`${i}`,inputDependencies:["type","type"]},getRunData:()=>({outputs:[{dims:s,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(a/64)},programUniforms:l}),getShaderSource:t=>{const n=tensorTypeToWsglStorageType(e[0].dataType),B=1===i?"vec2f":`mat2x${i}f`,F=1===i?n:`vec${i}<${n}>`,Q=inputVariable("input",e[0].dataType,e[0].dims,i),U=outputVariable("output",e[0].dataType,s,i);return`\n  @group(0) @binding(0) var<storage, read> input : array<${Q.type.storage}>;\n  @group(0) @binding(1) var<storage, read> scaleInput : array<${B}>;\n  @group(0) @binding(2) var<storage, read_write> output : array<${U.type.storage}>;\n  struct Uniforms {H: u32, C : u32};\n  @group(0) @binding(3) var<uniform> uniforms: Uniforms;\n\n  ${t.mainStart()}\n    let currentImageNumber = global_idx / (uniforms.C * uniforms.H);\n    let currentChannelNumber = global_idx % uniforms.C;\n\n    let scaleOffset = currentImageNumber * uniforms.C + currentChannelNumber;\n    let scale = scaleInput[scaleOffset];\n    output[global_idx] = fma(input[global_idx], ${F}(scale[0]), ${F}(scale[1]));\n  }`}},{inputs:[e[0],c]})},instanceNorm=(t,e)=>{"NHWC"===e.format?createInstanceNormNHWCProgramInfo(t,t.inputs,e):t.compute(createInstanceNormProgramInfo(t.inputs,e))}}}),validateInputs40,createLayerNormProgramInfo,layerNorm,init_layer_norm=__esm({"web/lib/wasm/jsep/webgpu/ops/layer-norm.ts"(){init_wasm_common(),init_util2(),init_common(),validateInputs40=t=>{if(!t||t.length<2)throw new Error("layerNorm requires at least 2 inputs.")},createLayerNormProgramInfo=(t,e,n)=>{const B=t[0].dims,s=t[1],F=t[2],Q=B,U=ShapeUtil2.normalizeAxis(e.axis,B.length),i=ShapeUtil2.sizeToDimension(B,U),a=ShapeUtil2.sizeFromDimension(B,U),l=ShapeUtil2.size(s.dims),c=F?ShapeUtil2.size(F.dims):0;if(l!==a||F&&c!==a)throw new Error(`Size of X.shape()[axis:] == ${a}.\n       Size of scale and bias (if provided) must match this.\n       Got scale size of ${l} and bias size of ${c}`);const g=[];for(let t=0;t<B.length;++t)t<U?g.push(B[t]):g.push(1);const d=getMaxComponents(a),I=["type","type"],o=[{type:"uint32",data:i},{type:"float32",data:a},{type:"uint32",data:Math.floor(a/d)},{type:"float32",data:e.epsilon}];F&&I.push("type");const r=n>1,u=n>2,b=[{dims:Q,dataType:t[0].dataType}];return r&&b.push({dims:g,dataType:1}),u&&b.push({dims:g,dataType:1}),{name:"LayerNormalization",shaderCache:{hint:`${d};${n}`,inputDependencies:I},getRunData:()=>({outputs:b,dispatchGroup:{x:Math.ceil(i/64)},programUniforms:o}),getShaderSource:e=>{const n=tensorTypeToWsglStorageType(t[0].dataType),B=[inputVariable("x",t[0].dataType,t[0].dims,d),inputVariable("scale",s.dataType,s.dims,d)];F&&B.push(inputVariable("bias",F.dataType,F.dims,d)),B.push(outputVariable("output",t[0].dataType,Q,d)),r&&B.push(outputVariable("mean_data_output",1,g)),u&&B.push(outputVariable("inv_std_output",1,g));return`\n  ${e.registerUniforms([{name:"norm_count",type:"u32"},{name:"norm_size",type:"f32"},{name:"norm_size_vectorized",type:"u32"},{name:"epsilon",type:"f32"}]).declareVariables(...B)}\n  ${e.mainStart()}\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.norm_count")}\n    let offset = global_idx * uniforms.norm_size_vectorized;\n    var meanVector = ${fillVector("f32",d)};\n    var meanSquareVector = ${fillVector("f32",d)};\n\n    for (var h: u32 = 0u; h < uniforms.norm_size_vectorized; h++) {\n      let value = ${castToF32(n,d,"x[h + offset]")};\n      meanVector += value;\n      meanSquareVector += value * value;\n    }\n    let mean = ${sumVector("meanVector",d)} / uniforms.norm_size;\n    let invStdDev =\n        inverseSqrt(${sumVector("meanSquareVector",d)} / uniforms.norm_size - mean * mean + uniforms.epsilon);\n\n    for (var j: u32 = 0; j < uniforms.norm_size_vectorized; j++) {\n      let f32input = ${castToF32(n,d,"x[j + offset]")};\n      let f32scale = ${castToF32(n,d,"scale[j]")};\n      output[j + offset] = ${B[0].type.value}((f32input - mean) * invStdDev * f32scale\n        ${F?`+ ${castToF32(n,d,"bias[j]")}`:""}\n      );\n    }\n\n    ${r?"mean_data_output[global_idx] = mean":""};\n    ${u?"inv_std_output[global_idx] = invStdDev":""};\n  }`}}},layerNorm=(t,e)=>{validateInputs40(t.inputs),t.compute(createLayerNormProgramInfo(t.inputs,e,t.outputCount))}}}),validateInputs41,parseMultiHeadAttentionAttributes,weightTransposeAttribute2,addBiasTranspose,maybeTransposeToBNSHAndAddBias,multiHeadAttention,init_multi_head_attentiion=__esm({"web/lib/wasm/jsep/webgpu/ops/multi-head-attentiion.ts"(){init_util2(),init_attribute_with_cache_key2(),init_types2(),init_attention(),init_common(),init_transpose2(),validateInputs41=(t,e)=>{const n=t[0],B=t[1],s=t[2],F=t[3],Q=t[4],U=t[5],i=t[6],a=t[7];if(3!==n.dims.length&&5!==n.dims.length)throw new Error("Input query is expected to have 3 or 5 dimensions");const l=n.dims[0],c=n.dims[1],g=3===n.dims.length?n.dims[2]:e.numHeads*n.dims[4];let d=c,I=0,o=0;const r=Math.floor(g/e.numHeads);if(i&&a){if(4!==i.dims.length)throw new Error('Input "past_key" is expected to have 4 dimensions');if(4!==a.dims.length)throw new Error('Input "past_value" is expected to have 4 dimensions');I=i.dims[2],o=i.dims[2]}else if(i||a)throw new Error('Input "past_key" and "past_value" shall be both present or both absent');let u;if(B){if(3!==n.dims.length)throw new Error('Input "query" is expected to have 3 dimensions when key is given');if(B.dims.length<3||B.dims.length>5)throw new Error('Input "key" is expected to have 3, 4, or 5 dimensions');if(n.dims[0]!==B.dims[0])throw new Error('Input "query" and "key" shall have same dim 0 (batch size)');if(3===B.dims.length){if(B.dims[2]!==n.dims[2])throw new Error('Input "query" and "key" shall have same dim 2 (hidden_size)');u=2,d=B.dims[1]}else if(5===B.dims.length){if(B.dims[2]!==e.numHeads||2!==B.dims[3]||B.dims[4]!==r)throw new Error('Expect "key" shape (batch_size, kv_sequence_length, num_heads, 2, head_size) for packed kv');if(s)throw new Error('Expect "value" be none when "key" has packed kv format.');u=5,d=B.dims[1]}else{if(B.dims[1]!==e.numHeads||B.dims[3]!==r)throw new Error('Expect "key" shape (batch_size, num_heads, kv_sequence_length, head_size) for past_key');u=0,d=B.dims[2]}}else{if(3!==n.dims.length&&5!==n.dims.length)throw new Error('Input "query" is expected to have 3 or 5 dimensions when key is empty');if(5===n.dims.length&&(n.dims[2]!==e.numHeads||3!==n.dims[3]))throw new Error('Expect "query" shape (batch_size, kv_sequence_length, num_heads, 3, head_size) for packed kv');u=3}if(F){if(1!==F.dims.length)throw new Error('Input "bias" is expected to have 1 dimension');if(s&&5===n.dims.length&&2===n.dims[3])throw new Error("bias is not allowed for packed kv.")}let b=0;if(Q){b=8;const t=Q.dims;if(1===t.length?t[0]===l?b=1:t[0]===3*l+2&&(b=3):2===t.length&&t[0]===l&&t[1]===d&&(b=5),8===b)throw new Error('Input "key_padding_mask" shape shall be (batch_size) or (batch_size, kv_sequence_length)');throw new Error("Mask not supported")}let C=!1,p=g;if(s){if(3!==s.dims.length&&4!==s.dims.length)throw new Error('Input "value" is expected to have 3 or 4 dimensions');if(n.dims[0]!==s.dims[0])throw new Error('Input "query" and "value" shall have same dim 0 (batch_size)');if(3===s.dims.length){if(d!==s.dims[1])throw new Error('Input "key" and "value" shall have the same dim 1 (kv_sequence_length)');p=s.dims[2]}else{if(d!==s.dims[2])throw new Error('Input "past_key" and "past_value" shall have the same dim 2 (kv_sequence_length)');p=s.dims[1]*s.dims[3],C=!0}}const m=I+d;if(Q)throw new Error("Key padding mask is not supported");if(U)throw new Error("extraAddQk is not supported");if(i)throw new Error("pastKey is not supported");if(a)throw new Error("pastValue is not supported");return{batchSize:l,sequenceLength:c,pastSequenceLength:I,kvSequenceLength:d,totalSequenceLength:m,maxSequenceLength:o,inputHiddenSize:0,hiddenSize:g,vHiddenSize:p,headSize:r,vHeadSize:Math.floor(p/e.numHeads),numHeads:e.numHeads,isUnidirectional:!1,pastPresentShareBuffer:!1,maskFilterValue:e.maskFilterValue,maskType:b,scale:e.scale,broadcastResPosBias:!1,passPastInKv:C,qkvFormat:u}},parseMultiHeadAttentionAttributes=t=>createAttributeWithCacheKey2({...t}),weightTransposeAttribute2=createAttributeWithCacheKey2({perm:[0,2,1,3]}),addBiasTranspose=(t,e,n,B,s,F,Q)=>{const U=[B,s,F],i=ShapeUtil2.size(U),a=[{type:"uint32",data:i},{type:"uint32",data:Q},{type:"uint32",data:F}];return t.compute({name:"MultiHeadAttentionAddBias",shaderCache:{inputDependencies:["type","type"]},getRunData:()=>({outputs:[{dims:U,dataType:e.dataType,gpuDataType:0}],dispatchGroup:{x:Math.ceil(i/64)},programUniforms:a}),getShaderSource:t=>{const B=outputVariable("qkv_with_bias",e.dataType,U),s=inputVariable("qkv",e.dataType,U),F=inputVariable("bias",n.dataType,U);return`\n  ${t.registerUniforms([{name:"output_size",type:"u32"},{name:"bias_offset",type:"u32"},{name:"hidden_size",type:"u32"}]).declareVariables(s,F,B)}\n  ${t.mainStart()}\n    ${t.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n    let bias_offset_idx = (global_idx % uniforms.hidden_size) + uniforms.bias_offset;\n\n    qkv_with_bias[global_idx] = qkv[global_idx] + bias[bias_offset_idx];\n  }`}},{inputs:[e,n],outputs:[-1]})[0]},maybeTransposeToBNSHAndAddBias=(t,e,n,B,s,F,Q,U)=>{let i=F;if(Q){if(1===B)throw new Error("AddBiasReshape is not implemented. Please export your model with packed QKV or KV");return i=addBiasTranspose(t,F,Q,e,B,n*s,U),i=i.reshape([e,B,n,s]),t.compute(createTransposeProgramInfo2(i,weightTransposeAttribute2.perm),{inputs:[i],outputs:[-1]})[0]}return 3===F.dims.length&&(i=F.reshape([e,B,n,s])),t.compute(createTransposeProgramInfo2(i,weightTransposeAttribute2.perm),{inputs:[i],outputs:[-1]})[0]},multiHeadAttention=(t,e)=>{const n=validateInputs41(t.inputs,e);if(5===t.inputs[0].dims.length)throw new Error("Packed QKV is not implemented");if(5===t.inputs[1]?.dims.length)throw new Error("Packed KV is not implemented");const B=t.inputs[1]&&t.inputs[2]&&4===t.inputs[1].dims.length&&4===t.inputs[2].dims.length,s=maybeTransposeToBNSHAndAddBias(t,n.batchSize,n.numHeads,n.sequenceLength,n.headSize,t.inputs[0],t.inputs[3],0);if(B)return applyAttention(t,s,t.inputs[1],t.inputs[2],t.inputs[4],void 0,void 0,void 0,t.inputs[5],n,e);const F=maybeTransposeToBNSHAndAddBias(t,n.batchSize,n.numHeads,n.kvSequenceLength,n.headSize,t.inputs[1],t.inputs[3],n.hiddenSize),Q=maybeTransposeToBNSHAndAddBias(t,n.batchSize,n.numHeads,n.kvSequenceLength,n.vHeadSize,t.inputs[2],t.inputs[3],2*n.hiddenSize);applyAttention(t,s,F,Q,t.inputs[4],void 0,t.inputs[6],t.inputs[7],t.inputs[5],n,e)}}}),validateInputs42,getPadConstant2,getPadReflect2,getPadEdge2,getPadWrap,getPadSnippet,createPadProgramInfo2,createPadAttributesFromInputs,pad,init_pad2=__esm({"web/lib/wasm/jsep/webgpu/ops/pad.ts"(){init_wasm_common(),init_util2(),init_common(),validateInputs42=t=>{if(!t||t.length<1)throw new Error("Too few inputs");if(1!==t[0].dataType)throw new Error("Input type must be float.");if(t.length>=2){let e=2*t[0].dims.length===t[1].dims[0];if(4===t.length&&(e=2*t[3].dims[0]===t[1].dims[0]),!e)throw new Error("The pads should be a 1D tensor of shape [2 * input_rank] or [2 * num_axes].")}},getPadConstant2=(t,e,n)=>{let B="";for(let s=e-1;s>=0;--s)B+=`\n            k = i32(${t.indicesGet("indices",s)}) - ${getElementAt("uniforms.pads",s,n)};\n            if (k < 0) {\n              break;\n            }\n            if (k >= i32(${getElementAt("uniforms.x_shape",s,e)})) {\n              break;\n            }\n            offset += k * i32(${getElementAt("uniforms.x_strides",s,e)});\n        `;return`\n          value = ${t.type.value}(uniforms.constant_value);\n          for (var i = 0; i < 1; i++) {\n            var offset = 0;\n            var k = 0;\n            ${B}\n            value = x[offset];\n          }\n      `},getPadReflect2=(t,e,n)=>{let B="";for(let s=e-1;s>=0;--s)B+=`\n                k = i32(${t.indicesGet("indices",s)}) - ${getElementAt("uniforms.pads",s,n)};\n                if (k < 0) {\n                  k = -k;\n                }\n                {\n                  let _2n_1 = 2 * (i32(${getElementAt("uniforms.x_shape",s,e)}) - 1);\n                  k = k % _2n_1;\n                  if(k >= i32(${getElementAt("uniforms.x_shape",s,e)})) {\n                    k = _2n_1 - k;\n                  }\n                }\n                offset += k * i32(${getElementAt("uniforms.x_strides",s,e)});\n            `;return`\n              var offset = 0;\n              var k = 0;\n              ${B}\n              value = x[offset];\n          `},getPadEdge2=(t,e,n)=>{let B="";for(let s=e-1;s>=0;--s)B+=`\n                k = i32(${t.indicesGet("indices",s)}) - ${getElementAt("uniforms.pads",s,n)};\n                if (k < 0) {\n                  k = 0;\n                }\n                if (k >= i32(${getElementAt("uniforms.x_shape",s,e)})) {\n                  k = i32(${getElementAt("uniforms.x_shape",s,e)}) - 1;\n                }\n                offset += k * i32(${getElementAt("uniforms.x_strides",s,e)});\n            `;return`\n              var offset = 0;\n              var k = 0;\n              ${B}\n              value = x[offset];\n          `},getPadWrap=(t,e,n)=>{let B="";for(let s=e-1;s>=0;--s)B+=`\n                k = i32(${t.indicesGet("indices",s)}) - ${getElementAt("uniforms.pads",s,n)};\n                if (k < 0)  {\n                  k += i32(${getElementAt("uniforms.x_shape",s,e)}]);\n                }\n                if (k >= i32(${getElementAt("uniforms.x_shape",s,e)})) {\n                  k -= i32(${getElementAt("uniforms.x_shape",s,e)});\n                }\n                offset += k * i32(${getElementAt("uniforms.x_strides",s,e)});\n            `;return`\n              var offset = 0;\n              var k = 0;\n              ${B}\n              value = x[offset];\n          `},getPadSnippet=(t,e,n)=>{switch(n.mode){case 0:return getPadConstant2(t,e,n.pads.length);case 1:return getPadReflect2(t,e,n.pads.length);case 2:return getPadEdge2(t,e,n.pads.length);case 3:return getPadWrap(t,e,n.pads.length);default:throw new Error("Invalid mode")}},createPadProgramInfo2=(t,e)=>{const n=ShapeUtil2.padShape(t[0].dims.slice(),e.pads),B=t[0].dims,s=[{type:"uint32",data:ShapeUtil2.size(n)},{type:"uint32",data:e.pads}];if(0===e.mode){const n=tensorDataTypeEnumToString(t[0].dataType);s.push({type:n,data:e.value})}s.push(...createTensorShapeVariables(t[0].dims),...createTensorShapeVariables(n));return{name:"Pad",shaderCache:{hint:`${e.mode}`,inputDependencies:["rank"]},getRunData:()=>({outputs:[{dims:n,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(ShapeUtil2.size(n)/64)},programUniforms:s}),getShaderSource:s=>{const F=outputVariable("output",t[0].dataType,n.length),Q=inputVariable("x",t[0].dataType,B.length),U=Q.type.value,i=getPadSnippet(F,B.length,e),a=[{name:"output_size",type:"u32"},{name:"pads",type:"i32",length:e.pads.length}];return 0===e.mode&&a.push({name:"constant_value",type:U}),`\n            ${s.registerUniforms(a).declareVariables(Q,F)}\n            ${s.mainStart()}\n            ${s.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n\n            let indices = ${F.offsetToIndices("global_idx")};\n\n            var value = ${U}(0);\n            ${i}\n            output[global_idx] = value;\n        }`}}},createPadAttributesFromInputs=(t,e)=>{if(t.length>1){const n=t[1].getBigInt64Array(),B=t.length>=3&&t[2].data?t[2].getFloat32Array()[0]:0,s=t[0].dims.length,F=new Int32Array(2*s).fill(0);if(t.length>=4){const e=t[3].getBigInt64Array();for(let t=0;t<e.length;t++)F[Number(e[t])]=Number(n[t]),F[Number(e[t])+s]=Number(n[t+e.length])}else n.forEach(((t,e)=>F[Number(e)]=Number(t)));const Q=[];return F.forEach((t=>Q.push(t))),{mode:e.mode,value:B,pads:Q}}return e},pad=(t,e)=>{validateInputs42(t.inputs);const n=createPadAttributesFromInputs(t.inputs,e);t.compute(createPadProgramInfo2(t.inputs,n),{inputs:[0]})}}}),validateInputs43,getAdjustedPoolAttributesAndOutputShape2,getUniformAndPadInfo,generatePoolingCode2,createShaderKeyFromAttributes,createAveragePoolShaderKeyFromAttributes,createMaxPoolShaderKeyFromAttributes,parsePoolCommonAttributes,createAveragePoolProgramInfo2,parseAveragePoolAttributes2,averagePool2,globalPoolAttributes,parseGlobalAveragePoolAttributes2,globalAveragePool2,createMaxPoolProgramInfo2,maxPool2,parseMaxPoolAttributes2,parseGlobalMaxPoolAttributes,globalMaxPool2,init_pool2=__esm({"web/lib/wasm/jsep/webgpu/ops/pool.ts"(){init_esm(),init_util2(),init_common(),validateInputs43=t=>{if(env2.webgpu.validateInputContent&&(!t||1!==t.length))throw new Error("Pool ops requires 1 input.")},getAdjustedPoolAttributesAndOutputShape2=(t,e,n)=>{const B="NHWC"===e.format,s=t.dims.slice();B&&s.splice(1,0,s.pop());const F=Object.hasOwnProperty.call(e,"dilations"),Q=e.kernelShape.slice(),U=e.strides.slice(),i=F?e.dilations.slice():[],a=e.pads.slice();PoolConvUtil2.adjustPoolAttributes(n,s,Q,U,i,a);const l=PoolConvUtil2.computePoolOutputShape(n,s,U,i,Q,a,e.autoPad),c=Object.assign({},e);F?Object.assign(c,{kernelShape:Q,strides:U,pads:a,dilations:i,cacheKey:e.cacheKey}):Object.assign(c,{kernelShape:Q,strides:U,pads:a,cacheKey:e.cacheKey});const g=l.slice();return g.push(g.splice(1,1)[0]),[c,B?g:l]},getUniformAndPadInfo=(t,e)=>{const n="NHWC"===e.format,B=[{type:"uint32",data:ShapeUtil2.size(t)},{type:"uint32",data:ShapeUtil2.size(e.kernelShape)}],s=[{name:"outputSize",type:"u32"},{name:"kernelSize",type:"u32"}];if(e.kernelShape.length<=2){const t=e.kernelShape[e.kernelShape.length-1],n=e.strides[e.strides.length-1],F=e.pads[e.pads.length/2-1],Q=e.pads[e.pads.length-1],U=!!(F+Q);B.push({type:"uint32",data:t},{type:"uint32",data:n},{type:"uint32",data:F},{type:"uint32",data:Q}),s.push({name:"kw",type:"u32"},{name:"sw",type:"u32"},{name:"pwStart",type:"u32"},{name:"pwEnd",type:"u32"});let i=!1;if(2===e.kernelShape.length){const t=e.kernelShape[e.kernelShape.length-2],n=e.strides[e.strides.length-2],F=e.pads[e.pads.length/2-2],Q=e.pads[e.pads.length-2];i=!!(F+Q),B.push({type:"uint32",data:t},{type:"uint32",data:n},{type:"uint32",data:F},{type:"uint32",data:Q}),s.push({name:"kh",type:"u32"},{name:"sh",type:"u32"},{name:"phStart",type:"u32"},{name:"phEnd",type:"u32"})}return[B,s,!0,U,i]}{if(n)throw new Error("Pooling with kernelShape.length > 2 is not supported for NHWC format.");const t=ShapeUtil2.computeStrides(e.kernelShape);B.push({type:"uint32",data:t},{type:"uint32",data:e.pads},{type:"uint32",data:e.strides}),s.push({name:"kernelStrides",type:"u32",length:t.length},{name:"pads",type:"u32",length:e.pads.length},{name:"strides",type:"u32",length:e.strides.length});return[B,s,!!e.pads.reduce(((t,e)=>t+e)),!1,!1]}},generatePoolingCode2=(t,e,n,B,s,F,Q,U,i,a,l,c)=>{const g="NHWC"===s.format,d=e.type.value,I=outputVariable("output",e.type.tensor,B);if(s.kernelShape.length<=2){let B="",a="",o="";const r=n-(g?2:1);if(B=l?`\n                for (var i: u32 = 0u; i < uniforms.kw; i++) {\n                  xIndices[${r}] = indices[${r}] * uniforms.sw - uniforms.pwStart + i;\n                  if (xIndices[${r}] < 0 || xIndices[${r}]\n                      >= uniforms.x_shape[${r}]) {\n                    pad++;\n                    continue;\n                  }\n                  let x_val = x[${e.indicesToOffset("xIndices")}];\n                  ${F}\n                }`:`\n                for (var i: u32 = 0u; i < uniforms.kw; i++) {\n                  xIndices[${r}] = indices[${r}] * uniforms.sw - uniforms.pwStart + i;\n                  let x_val = x[${e.indicesToOffset("xIndices")}];\n                  ${F}\n                }`,2===s.kernelShape.length){const t=n-(g?3:2);a=c?`\n                for (var j: u32 = 0u; j < uniforms.kh; j++) {\n                  xIndices[${t}] = indices[${t}] * uniforms.sh - uniforms.phStart + j;\n                  if (xIndices[${t}] < 0 || xIndices[${t}] >= uniforms.x_shape[${t}]) {\n                    pad += i32(uniforms.kw);\n                    continue;\n                  }\n              `:`\n                for (var j: u32 = 0u; j < uniforms.kh; j++) {\n                  xIndices[${t}] = indices[${t}] * uniforms.sh - uniforms.phStart + j;\n                `,o="\n              }\n            "}return`\n            ${t.registerUniforms(i).declareVariables(e,I)}\n\n            ${t.mainStart()}\n              ${t.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n\n              let indices = ${I.offsetToIndices("global_idx")};\n              var xIndices = ${I.offsetToIndices("global_idx")};\n\n              var value = ${d}(${U});\n              var pad = 0;\n              ${a}\n              ${B}\n              ${o}\n              ${Q}\n\n              output[global_idx] = value;\n            }`}{if(g)throw new Error("Pooling with kernelShape.length > 2 is not supported for NHWC format.");const B=s.kernelShape.length,l=s.pads.length;let c="";c=a?`\n                if (xIndices[j] >= uniforms.x_shape[j]) {\n                  pad++;\n                  isPad = true;\n                  break;\n                }\n              }\n              if (!isPad) {\n                let x_val = x[${e.indicesToOffset("xIndices")}];\n                ${F}\n              }`:`\n              }\n              let x_val = x[${e.indicesToOffset("xIndices")}];\n              ${F}\n            `;return`\n            ${t.registerUniforms(i).declareVariables(e,I)}\n\n            ${t.mainStart()}\n              ${t.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n              let indices = ${I.offsetToIndices("global_idx")};\n              var xIndices = ${I.offsetToIndices("global_idx")};\n\n              var offsets: array<u32, ${B}>;\n\n              var value = ${d}(${U});\n              var pad = 0;\n              var isPad = false;\n\n              for (var i: u32 = 0u; i < uniforms.kernelSize; i++) {\n                var offset = i;\n                for (var j = 0u; j < ${B-1}u; j++) {\n                  offsets[j] = offset / ${getElementAt("uniforms.kernelStrides","j",B)};\n                  offset -= offsets[j] * ${getElementAt("uniforms.kernelStrides","j",B)};\n                }\n                offsets[${B-1}] = offset;\n\n                isPad = false;\n                for (var j = ${n-B}u; j < ${n}u; j++) {\n                  xIndices[j] = indices[j] * ${getElementAt("uniforms.strides",`j - ${n-B}u`,B)}\n                    + offsets[j - ${n-B}u] - ${getElementAt("uniforms.pads","j - 2u",l)};\n                  ${c}\n              }\n              ${Q}\n\n              output[global_idx] = value;\n            }`}},createShaderKeyFromAttributes=t=>`${t.format};${t.ceilMode};${t.autoPad};${t.kernelShape.length}`,createAveragePoolShaderKeyFromAttributes=t=>`${createShaderKeyFromAttributes(t)};${t.countIncludePad}`,createMaxPoolShaderKeyFromAttributes=t=>`${createShaderKeyFromAttributes(t)};${t.storageOrder};${t.dilations}`,parsePoolCommonAttributes=t=>({format:t.format,autoPad:["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][t.auto_pad],ceilMode:t.ceil_mode,kernelShape:t.kernel_shape,strides:t.strides,pads:t.pads}),createAveragePoolProgramInfo2=(t,e,n,B)=>{const[s,F]=getAdjustedPoolAttributesAndOutputShape2(e,B,n),Q=inputVariable("x",e.dataType,e.dims.length),U=Q.type.value;let i="";s.countIncludePad?i+=`value /= ${U}(uniforms.kernelSize);`:i+=`value /= ${U}(i32(uniforms.kernelSize) - pad);`;const[a,l,c,g,d]=getUniformAndPadInfo(F,s);a.push(...createTensorShapeVariables(e.dims),...createTensorShapeVariables(F));return{name:t,shaderCache:{hint:`${B.cacheKey};${c};${g};${d}`,inputDependencies:["rank"]},getRunData:()=>({outputs:[{dims:F,dataType:e.dataType}],dispatchGroup:{x:Math.ceil(ShapeUtil2.size(F)/64)},programUniforms:a}),getShaderSource:t=>generatePoolingCode2(t,Q,e.dims.length,F.length,s,"value += x_val;",i,0,l,c,g,d)}},parseAveragePoolAttributes2=t=>{const e=0!==t.count_include_pad,n=parsePoolCommonAttributes(t);if(0!==n.ceilMode)throw new Error("using ceil() in shape computation is not yet supported for AveragePool");const B={countIncludePad:e,...n,cacheKey:""};return{...B,cacheKey:createAveragePoolShaderKeyFromAttributes(B)}},averagePool2=(t,e)=>{validateInputs43(t.inputs),t.compute(createAveragePoolProgramInfo2("AveragePool",t.inputs[0],!1,e))},globalPoolAttributes={autoPad:"",ceilMode:0,countIncludePad:!1,kernelShape:[],strides:[],pads:[],storageOrder:0,dilations:[]},parseGlobalAveragePoolAttributes2=t=>{const e=t.format;return{format:e,...globalPoolAttributes,cacheKey:e}},globalAveragePool2=(t,e)=>{validateInputs43(t.inputs),t.compute(createAveragePoolProgramInfo2("GlobalAveragePool",t.inputs[0],!0,e))},createMaxPoolProgramInfo2=(t,e,n,B)=>{const[s,F]=getAdjustedPoolAttributesAndOutputShape2(e,B,n),Q=inputVariable("x",e.dataType,e.dims.length),[U,i,a,l,c]=getUniformAndPadInfo(F,s);return U.push(...createTensorShapeVariables(e.dims),...createTensorShapeVariables(F)),{name:t,shaderCache:{hint:`${B.cacheKey};${a};${l};${c}`,inputDependencies:["rank"]},getRunData:()=>({outputs:[{dims:F,dataType:e.dataType}],dispatchGroup:{x:Math.ceil(ShapeUtil2.size(F)/64)},programUniforms:U}),getShaderSource:t=>generatePoolingCode2(t,Q,e.dims.length,F.length,s,"\n      value = max(x_val, value);\n    ","",-1e5,i,a,l,c)}},maxPool2=(t,e)=>{validateInputs43(t.inputs),t.compute(createMaxPoolProgramInfo2("MaxPool",t.inputs[0],!1,e))},parseMaxPoolAttributes2=t=>{const e=t.storage_order,n=t.dilations,B=parsePoolCommonAttributes(t);if(0!==e)throw new Error("column major storage order is not yet supported for MaxPool");if(0!==B.ceilMode)throw new Error("using ceil() in shape computation is not yet supported for MaxPool");const s={storageOrder:e,dilations:n,...B,cacheKey:""};return{...s,cacheKey:createMaxPoolShaderKeyFromAttributes(s)}},parseGlobalMaxPoolAttributes=t=>{const e=t.format;return{format:e,...globalPoolAttributes,cacheKey:e}},globalMaxPool2=(t,e)=>{validateInputs43(t.inputs),t.compute(createMaxPoolProgramInfo2("GlobalMaxPool",t.inputs[0],!0,e))}}}),validateInputsContent,createRangeProgramInfo,range,init_range=__esm({"web/lib/wasm/jsep/webgpu/ops/range.ts"(){init_esm(),init_wasm_common(),init_common(),validateInputsContent=(t,e,n)=>{if(t===e||t<e&&n<0||t>e&&n>0)throw new Error("Range these inputs' contents are invalid.")},createRangeProgramInfo=(t,e,n,B)=>{const s=Math.abs(Math.ceil((e-t)/n)),F=[s],Q=s,U=tensorDataTypeEnumToString(B),i=[{type:"uint32",data:Q},{type:U,data:t},{type:U,data:n},...createTensorShapeVariables(F)];return{name:"Range",shaderCache:{hint:`${B}`},getShaderSource:t=>{const e=outputVariable("output",B,F.length),n=e.type.value,s=[{name:"outputSize",type:"u32"},{name:"start",type:n},{name:"delta",type:n}];return`\n        ${t.registerUniforms(s).declareVariables(e)}\n        ${t.mainStart()}\n        ${t.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n        output[global_idx] = uniforms.start + ${n}(global_idx) * uniforms.delta;\n      }`},getRunData:()=>({outputs:[{dims:F,dataType:B}],dispatchGroup:{x:Math.ceil(Q/64)},programUniforms:i})}},range=t=>{let e=0,n=0,B=0;6===t.inputs[0].dataType?(e=t.inputs[0].getInt32Array()[0],n=t.inputs[1].getInt32Array()[0],B=t.inputs[2].getInt32Array()[0]):1===t.inputs[0].dataType&&(e=t.inputs[0].getFloat32Array()[0],n=t.inputs[1].getFloat32Array()[0],B=t.inputs[2].getFloat32Array()[0]),env2.webgpu.validateInputContent&&validateInputsContent(e,n,B),t.compute(createRangeProgramInfo(e,n,B,t.inputs[0].dataType),{inputs:[]})}}}),validateScales,updateScales,validateInputs44,getOriginalCoordinateFromResizedCoordinate,getNearestPixelFromOriginal,updateRoI,initOutputShape,adjustOutputShape,calculateOriginalIndicesFromOutputIndices,calculateInputIndicesFromOutputIndices,checkInputIndices,setChannelAndBatchIndices,bilinearInterpolation,bicubicInterpolation,trilinearInterpolation,createResizeProgramInfo,getOpsetVersionFromCustomDataBuffer,resize2,parseResizeAttributes,init_resize=__esm({"web/lib/wasm/jsep/webgpu/ops/resize.ts"(){init_util2(),init_attribute_with_cache_key2(),init_common(),validateScales=(t,e)=>{if(t.every((t=>t>0||(()=>{throw new Error("Resize requires scales input values to be positive")}))),t.length>0)if("linear"===e.mode){if(!(2===t.length||3===t.length||4===t.length&&1===t[0]&&1===t[1]||4===t.length&&1===t[0]&&1===t[3]||5===t.length&&1===t[0]&&1===t[1]))throw new Error("For linear mode, Resize requires scales to be 2D, 3D, 4D with either two outermost or one innermost and\n            one outermost scale values equal to 1, or 5D with two outermost scale values equal to 1")}else if("cubic"===e.mode&&!(2===t.length||4===t.length&&1===t[0]&&1===t[1]||4===t.length&&1===t[0]&&1===t[3]))throw new Error("Resize requires scales input size to be 2 or 4 for cubic mode")},updateScales=(t,e,n)=>{e.every((t=>t>=0&&t<n||(()=>{throw new Error("Resize requires axes input values to be positive and less than rank")})));const B=new Array(n).fill(1);return e.forEach(((e,n)=>B[e]=t[n])),B},validateInputs44=(t,e,n,B,s,F)=>{const[Q,U,i]=n>10?[1,2,3]:[-1,t.length>1?1:-1,-1],a=t[0].dims.length;if(Q>0&&t.length>Q&&t[Q].dims.length>0)t[Q].getFloat32Array().forEach((t=>F.push(t)));else if("tf_crop_and_resize"===e.coordinateTransformMode)throw new Error("Resize requires RoI input to be specified when coordinateTransformMode is tfCropAndResize");if(U>0&&t.length>U&&t[U].dims.length>0){if(t[U].getFloat32Array().forEach((t=>B.push(t))),0!==B.length&&B.length!==a&&n>=18&&B.length!==e.axes.length)throw new Error("Resize requires scales input size to be same as input rank or axes size for opset 18 and up");validateScales(B,e),e.axes.length>0&&updateScales(B,e.axes,a).forEach(((t,e)=>B[e]=t))}if(i>0&&t.length>i&&(t[i].getBigInt64Array().forEach((t=>s.push(Number(t)))),s.length!==a||n>=18&&s.length===e.axes.length))throw new Error("Resize requires sizes input size to be same as input rank or axes size for opset 18 and up");if(e.axes.length>0){if(B.length!==e.axes.length)throw new Error('Resize requires "scales" input size to be of axes rank when axes attributes is specified');if(s.length!==e.axes.length)throw new Error('Resize requires "sizes" input size to be of rank axes rank when axes attributes is specified')}if(void 0!==B&&void 0!==s&&B.length>0&&s.length>a)throw new Error("Resize requires only of scales or sizes to be specified")},getOriginalCoordinateFromResizedCoordinate=(t,e)=>`fn getOriginalCoordinateFromResizedCoordinate(xResized: u32, xScale: f32, lengthResized: u32,\n     lengthOriginal: u32, roiStart: f32, roiEnd: f32) -> ${e} { `+(()=>{switch(t){case"asymmetric":return`return ${e}(xResized) / ${e}(xScale);`;case"pytorch_half_pixel":return`if (lengthResized > 1) {\n                    return (${e}(xResized) + 0.5) / ${e}(xScale) - 0.5;\n                  } else {\n                    return 0.0;\n                  }`;case"tf_half_pixel_for_nn":return`return (${e}(xResized) + 0.5) / ${e}(xScale);`;case"align_corners":return`if (lengthResized == 1) {\n                    return 0.0;\n                  } else {\n                    // The whole part and the fractional part are calculated separately due to inaccuracy of floating\n                    // point division. As an example, f32(21) / f32(7) may evaluate to 2.99... instead of 3, causing an\n                    // offset-by-one error later in floor().\n                    let whole = ${e}(xResized * (lengthOriginal - 1) / (lengthResized - 1));\n                    let fract =\n                        ${e}(xResized * (lengthOriginal - 1) % (lengthResized - 1)) / ${e}(lengthResized - 1);\n                    return whole + fract;\n                  }`;case"tf_crop_and_resize":return`if (lengthResized > 1) {\n                    return ${e}(roiStart) * ${e}(lengthOriginal - 1) +\n                        (${e}(xResized) * ${e}(roiEnd - roiStart) * ${e}(lengthOriginal - 1)) /\n                        ${e}(lengthResized - 1);\n                  } else {\n                    return 0.5 * ${e}(roiStart + roiEnd) * ${e}(lengthOriginal - 1);\n                  }`;case"half_pixel_symmetric":return`const outputWidth = ${e}xScale * ${e}(lengthResized);\n                  const adjustment = ${e}(lengthResized) / outputWidth;\n                  const center = ${e}(lengthOriginal) / 2;\n                  const offset = center * (1 - adjustment);\n                  return offset + ((${e}(xResized) + 0.5) / ${e}(xScale)) - 0.5;`;case"half_pixel":return`return ((${e}(xResized) + 0.5) / ${e}(xScale)) - 0.5;`;default:throw new Error(`Coordinate transform mode ${t} is not supported`)}})()+"}",getNearestPixelFromOriginal=(t,e,n)=>`fn getNearestPixelFromOriginal(xOriginal: ${n}, isDownSample: bool) -> ${n} {`+(()=>{switch(t){case"round_prefer_ceil":return"if (fract(xOriginal) == 0.5) {             return ceil(xOriginal);           } else {             return round(xOriginal);           }";case"floor":return"return floor(xOriginal);";case"ceil":return"return ceil(xOriginal);";case"round_prefer_floor":return"if (fract(xOriginal) == 0.5) {                     return floor(xOriginal);                   } else {                     return round(xOriginal);                   }";default:if(e<11)return"if (isDownSample)                     {                       return ceil(xOriginal);                     } else {                       return xOriginal;                     }";throw new Error(`Nearest mode ${t} is not supported`)}})()+"}",updateRoI=(t,e,n)=>{const B=new Array(n).fill(0).concat(new Array(n).fill(1)),s=0===t.length?B:t.slice();return e.length>0?(e.forEach(((t,F)=>{B[t]=s[F],B[F+n]=s[e.length+F]})),B):s},initOutputShape=(t,e,n,B)=>{let s=[];if(n.length>0)if(B.length>0){if(t.forEach((t=>s.push(t))),Math.max(...B)>t.length)throw new Error("axes is out of bound");B.forEach(((t,e)=>s[t]=n[e]))}else n.forEach((t=>s.push(t)));else{if(0===e.length)throw new Error("Resize requires either scales or sizes.");s=t.map(((t,n)=>Math.round(t*e[n])))}return s},adjustOutputShape=(t,e,n)=>{const B=(()=>{switch(n.keepAspectRatioPolicy){case"not_larger":return n.axes.length>0?Math.min(...n.axes.map((t=>e[t])),Number.MAX_VALUE):Math.min(...e,Number.MAX_VALUE);case"not_smaller":return n.axes.length>0?Math.max(...n.axes.map((t=>e[t])),Number.MIN_VALUE):Math.max(...e,Number.MIN_VALUE);default:throw new Error(`Keep aspect ratio policy ${n.keepAspectRatioPolicy} is not supported`)}})();e.fill(1,0,e.length);const s=t.slice();return n.axes.length>0?(n.axes.forEach((t=>e[t]=B)),n.axes.forEach((n=>s[n]=Math.round(t[n]*e[n])))):(e.fill(B,0,e.length),s.forEach(((t,n)=>s[n]=Math.round(t*e[n])))),s},calculateOriginalIndicesFromOutputIndices=(t,e,n,B,s)=>`\n    fn calculateOriginalIndicesFromOutputIndices(output_indices: ${t.type.indices}) -> array<${t.type.value}, ${n.length}> {\n      var original_indices: array<${t.type.value}, ${n.length}>;\n      for (var i:u32 = 0; i < ${n.length}; i++) {\n        var output_index = ${t.indicesGet("output_indices","i")};\n        var scale = ${getElementAt("uniforms.scales","i",B)};\n        var roi_low = ${getElementAt("uniforms.roi","i",s)};\n        var roi_hi = ${getElementAt("uniforms.roi",`i + ${e.length}`,s)};\n        if (scale == 1.0) {\n          original_indices[i] = ${t.type.value}(output_index);\n        } else {\n          var input_shape_i = ${getElementAt("uniforms.input_shape","i",e.length)};\n          var output_shape_i = ${getElementAt("uniforms.output_shape","i",n.length)};\n          original_indices[i] = getOriginalCoordinateFromResizedCoordinate(output_index, scale, output_shape_i,\n                                                                           input_shape_i, roi_low, roi_hi);\n        }\n      }\n      return original_indices;\n    }`,calculateInputIndicesFromOutputIndices=(t,e,n,B,s,F,Q)=>`\n    fn calculateInputIndicesFromOutputIndices(output_indices: ${e.type.indices}) -> ${t.type.indices} {\n      var input_indices: ${t.type.indices};\n      for (var i:u32 = 0; i < ${B.length}; i++) {\n        var output_index = ${e.indicesGet("output_indices","i")};\n        var input_index: u32;\n        var scale = ${getElementAt("uniforms.scales","i",s)};\n        if (scale == 1.0) {\n          input_index = output_index;\n        } else {\n          var roi_low = ${getElementAt("uniforms.roi","i",F)};\n          var roi_hi = ${getElementAt("uniforms.roi",`i + ${n.length}`,F)};\n          var input_shape_i = ${getElementAt("uniforms.input_shape","i",n.length)};\n          var output_shape_i = ${getElementAt("uniforms.output_shape","i",B.length)};\n          var original_idx = getOriginalCoordinateFromResizedCoordinate(output_index, scale, output_shape_i,\n                                                                        input_shape_i, roi_low, roi_hi);\n          if (!${Q} || (original_idx >= 0 && original_idx < ${e.type.value}(input_shape_i))) {\n            if (original_idx < 0) {\n              input_index = 0;\n            } else if (original_idx > ${e.type.value}(input_shape_i - 1)) {\n              input_index = input_shape_i - 1;\n            } else {\n              input_index = u32(getNearestPixelFromOriginal(original_idx, scale < 1));\n            }\n          } else {\n            input_index = u32(original_idx);\n          }\n        }\n        ${t.indicesSet("input_indices","i"," input_index")}\n      }\n      return input_indices;\n    }`,checkInputIndices=(t,e)=>`\n    fn checkInputIndices(input_indices: ${t.type.indices}) -> bool {\n      for (var i:u32 = 0; i < ${e.length}; i++) {\n        var input_index = ${t.indicesGet("input_indices","i")};\n        if (input_index < 0 || input_index >= ${getElementAt("uniforms.input_shape","i",e.length)}) {\n          return false;\n        }\n      }\n      return true;\n    }`,setChannelAndBatchIndices=(t,e,n,B)=>t.rank>B?`\n    ${t.indicesSet("input_indices",e,"channel")};\n    ${t.indicesSet("input_indices",n,"batch")};\n`:"",bilinearInterpolation=(t,e,n,B,s)=>{const[F,Q,U,i]=2===n.length?[-1,0,1,-1]:[0,2,3,1],a=t.type.value;return`\n    fn getInputValue(batch: u32, channel: u32, row: u32, col: u32) -> ${a} {\n      var input_indices: ${t.type.indices};\n      ${t.indicesSet("input_indices",Q,`max(0, min(row, ${n[Q]} - 1))`)};\n      ${t.indicesSet("input_indices",U,`max(0, min(col, ${n[U]} - 1))`)};\n      ${setChannelAndBatchIndices(t,i,F,2)}\n      return ${t.getByIndices("input_indices")};\n    }\n\n    fn bilinearInterpolation(output_indices: ${e.type.indices}) -> ${a} {\n      var originalIndices = calculateOriginalIndicesFromOutputIndices(output_indices);\n      var row:${a} = originalIndices[${Q}];\n      var col:${a} = originalIndices[${U}];\n      ${B?`if (row < 0 || row > (${n[Q]} - 1) || col < 0 || col > (${n[U]} - 1)) {\n        return ${s};\n      }`:""};\n      row = max(0, min(row, ${n[Q]} - 1));\n      col = max(0, min(col, ${n[U]} - 1));\n      var row1: u32 = u32(row);\n      var col1: u32 = u32(col);\n      var row2: u32 = u32(row + 1);\n      var col2: u32 = u32(col + 1);\n      var channel: u32 = ${n.length>2?`u32(originalIndices[${i}])`:"0"};\n      var batch: u32 =  ${n.length>2?`u32(originalIndices[${F}])`:"0"};\n      var x11: ${a} = getInputValue(batch, channel, row1, col1);\n      var x12: ${a} = getInputValue(batch, channel, row1, col2);\n      var x21: ${a} = getInputValue(batch, channel, row2, col1);\n      var x22: ${a} = getInputValue(batch, channel, row2, col2);\n      var dx1: ${a} = abs(row - ${a}(row1));\n      var dx2: ${a} = abs(${a}(row2) - row);\n      var dy1: ${a} = abs(col - ${a}(col1));\n      var dy2: ${a} = abs(${a}(col2) - col);\n      if (row1 == row2) {\n        dx1 = 0.5;\n        dx2 = 0.5;\n      }\n      if (col1 == col2) {\n        dy1 = 0.5;\n        dy2 = 0.5;\n      }\n      return (x11 * dx2 * dy2 + x12 * dx2 * dy1 + x21 * dx1 * dy2 + x22 * dx1 * dy1);\n    }`},bicubicInterpolation=(t,e,n,B,s,F,Q,U,i,a)=>{const l=2===n.length,[c,g]=l?[0,1]:[2,3],d=t.type.value,I=Q=>{const l=Q===c?"row":"col";return`\n      fn ${l}CubicInterpolation(input_indices: ${t.type.indices}, output_indices: ${e.type.indices}) -> ${d} {\n        var output_index = ${e.indicesGet("output_indices",Q)};\n        var originalIdx: ${d} = getOriginalCoordinateFromResizedCoordinate(output_index, ${s[Q]},\n        ${B[Q]}, ${n[Q]}, ${F[Q]}, ${F[Q]} + ${n.length});\n        var fractOriginalIdx: ${d} = originalIdx - floor(originalIdx);\n        var coefs = getCubicInterpolationCoefs(fractOriginalIdx);\n\n        if (${U} && (originalIdx < 0 || originalIdx > (${n[Q]} - 1))) {\n          return ${i};\n        }\n        var data: array<${d}, 4> = array<${d}, 4>(0.0, 0.0, 0.0, 0.0);\n        for (var i: i32 = -1; i < 3; i++) {\n          var ${l}: ${d} = originalIdx + ${d}(i);\n          if (${l} < 0 || ${l} >= ${n[Q]}) {\n            ${a?"coefs[i + 1] = 0.0;\n                        continue;":U?`return ${i};`:`${l} = max(0, min(${l}, ${n[Q]} - 1));`};\n          }\n        var input_indices_copy: ${t.type.indices} = input_indices;\n          ${t.indicesSet("input_indices_copy",Q,`u32(${l})`)};\n          data[i + 1] = ${Q===c?t.getByIndices("input_indices_copy"):"rowCubicInterpolation(input_indices_copy, output_indices)"};\n        }\n        return cubicInterpolation1D(data, coefs);\n      }`};return`\n    ${I(c)};\n    ${I(g)};\n  fn getCubicInterpolationCoefs(s: ${d}) -> array<${d}, 4> {\n    var absS = abs(s);\n    var coeffs: array<${d}, 4> = array<${d}, 4>(0.0, 0.0, 0.0, 0.0);\n    var oneMinusAbsS: ${d} = 1.0 - absS;\n    var twoMinusAbsS: ${d} = 2.0 - absS;\n    var onePlusAbsS: ${d} = 1.0 + absS;\n    coeffs[0] = ((${Q} * onePlusAbsS - 5 * ${Q}) * onePlusAbsS + 8 * ${Q}) * onePlusAbsS - 4 * ${Q};\n    coeffs[1] = ((${Q} + 2) * absS - (${Q} + 3)) * absS * absS + 1;\n    coeffs[2] = ((${Q} + 2) * oneMinusAbsS - (${Q} + 3)) * oneMinusAbsS * oneMinusAbsS + 1;\n    coeffs[3] = ((${Q} * twoMinusAbsS - 5 * ${Q}) * twoMinusAbsS + 8 * ${Q}) * twoMinusAbsS - 4 * ${Q};\n    return coeffs;\n  }\n\n  fn cubicInterpolation1D(x: array<${d}, 4>, coefs: array<${d}, 4>) -> ${d} {\n    var coefsSum: ${d} = coefs[0] + coefs[1] + coefs[2] + coefs[3];\n    return (x[0] * coefs[0] + x[1] * coefs[1]+ x[2] * coefs[2]+ x[3] * coefs[3]) / coefsSum;\n  }\n\n  fn bicubicInterpolation(output_indices: ${e.type.indices}) -> ${d} {\n    var input_indices: ${t.type.indices} = output_indices;\n    return colCubicInterpolation(input_indices, output_indices);\n  }\n    `},trilinearInterpolation=(t,e,n,B,s)=>{const[F,Q,U,i,a]=3===n.length?[-1,0,1,2,-1]:[0,2,3,4,1],l=t.type.value;return`\n    fn getInputValue(batch: u32, channel: u32, depth:u32, height: u32, width: u32) -> ${l} {\n      var input_indices: ${t.type.indices};\n      ${t.indicesSet("input_indices",Q,`max(0, min(depth, ${n[Q]} - 1))`)};\n      ${t.indicesSet("input_indices",U,`max(0, min(height, ${n[U]} - 1))`)};\n      ${t.indicesSet("input_indices",i,`max(0, min(width, ${n[i]} - 1))`)};\n      ${setChannelAndBatchIndices(t,a,F,3)}\n      return ${t.getByIndices("input_indices")};\n    }\n\n    fn trilinearInterpolation(output_indices: ${e.type.indices}) -> ${l} {\n      var originalIndices = calculateOriginalIndicesFromOutputIndices(output_indices);\n      var depth:${l} = originalIndices[${Q}];\n      var height:${l} = originalIndices[${U}];\n      var width:${l} = originalIndices[${i}];\n      ${B?`if (depth < 0 || depth > (${n[Q]} - 1) || height < 0 || height > (${n[U]} - 1) || width < 0 || (width > ${n[i]} - 1)) {\n      return ${s};\n        }`:""};\n\n    depth = max(0, min(depth, ${n[Q]} - 1));\n      height = max(0, min(height, ${n[U]} - 1));\n      width = max(0, min(width, ${n[i]} - 1));\n      var depth1: u32 = u32(depth);\n      var height1: u32 = u32(height);\n      var width1: u32 = u32(width);\n      var depth2: u32 = u32(depth + 1);\n      var height2: u32 = u32(height + 1);\n      var width2: u32 = u32(width + 1);\n      var channel: u32 = ${n.length>3?`u32(originalIndices[${a}])`:"0"};\n      var batch: u32 =  ${n.length>3?`u32(originalIndices[${F}])`:"0"};\n\n      var x111: ${l} = getInputValue(batch, channel, depth1, height1, width1);\n      var x112: ${l} = getInputValue(batch, channel, depth1, height1, width2);\n      var x121: ${l} = getInputValue(batch, channel, depth1, height2, width1);\n      var x122: ${l} = getInputValue(batch, channel, depth1, height2, width2);\n      var x211: ${l} = getInputValue(batch, channel, depth2, height1, width1);\n      var x212: ${l} = getInputValue(batch, channel, depth2, height1, width2);\n      var x221: ${l} = getInputValue(batch, channel, depth2, height2, width1);\n      var x222: ${l} = getInputValue(batch, channel, depth2, height2, width2);\n      var dx1: ${l} = abs(depth - ${l}(depth1));\n      var dx2: ${l} = abs(${l}(depth2) - depth);\n      var dy1: ${l} = abs(height - ${l}(height1));\n      var dy2: ${l} = abs(${l}(height2) - height);\n      var dz1: ${l} = abs(width - ${l}(width1));\n      var dz2: ${l} = abs(${l}(width2) - width);\n      if (depth1 == depth2) {\n        dx1 = 0.5;\n        dx2 = 0.5;\n      }\n      if (height1 == height2) {\n        dy1 = 0.5;\n        dy2 = 0.5;\n      }\n      if (width1 == width2) {\n        dz1 = 0.5;\n        dz2 = 0.5;\n      }\n      return (x111 * dx2 * dy2 * dz2 + x112 * dx2 * dy2 * dz1 + x121 * dx2 * dy1 *dz2 + x122 * dx2 * dy1 * dz1 +\n              x211 * dx1 * dy2 * dz2 + x212 * dx1 * dy2 * dz1 + x221 * dx1 * dy1 *dz2 + x222 * dx1 * dy1 * dz1);\n    }`},createResizeProgramInfo=(t,e,n,B,s,F)=>{const Q=t.dims,U=updateRoI(F,e.axes,Q.length);let i=initOutputShape(Q,B,s,e.axes),a=B.slice();0===B.length&&(a=Q.map(((t,e)=>0===t?1:i[e]/t)),"stretch"!==e.keepAspectRatioPolicy&&(i=adjustOutputShape(Q,a,e)));const l=outputVariable("output",t.dataType,i.length),c=inputVariable("input",t.dataType,Q.length),g=ShapeUtil2.size(i),d=Q.length===i.length&&Q.every(((t,e)=>t===i[e])),I="tf_crop_and_resize"===e.coordinateTransformMode,o=e.extrapolationValue,r=c.type.value;return{name:"Resize",shaderCache:{hint:`${e.cacheKey}|${n}|${a.length>0?a:""}|${s.length>0?s:""}|${U.length>0?U:""}|${d}|${Q}`,inputDependencies:["rank"]},getShaderSource:t=>`\n      ${d?"":`\n      ${getOriginalCoordinateFromResizedCoordinate(e.coordinateTransformMode,r)};\n      ${(()=>{switch(e.mode){case"nearest":return`\n              ${checkInputIndices(c,Q)};\n              ${getNearestPixelFromOriginal(e.nearestMode,n,r)};\n              ${calculateInputIndicesFromOutputIndices(c,l,Q,i,a.length,U.length,I)};\n              `;case"linear":return`\n              ${calculateOriginalIndicesFromOutputIndices(l,Q,i,a.length,U.length)};\n              ${(()=>{if(2===Q.length||4===Q.length)return`${bilinearInterpolation(c,l,Q,I,o)}`;if(3===Q.length||5===Q.length)return`${trilinearInterpolation(c,l,Q,I,o)}`;throw Error("Linear mode only supports input dims 2, 3, 4 and 5 are supported in linear mode.")})()};\n            `;case"cubic":return`\n            ${(()=>{if(2===Q.length||4===Q.length)return`${bicubicInterpolation(c,l,Q,i,a,U,e.cubicCoeffA,I,e.extrapolationValue,e.excludeOutside)}`;throw Error("Cubic mode only supports input dims 2 and 4 are supported in linear mode.")})()};\n            `;default:throw Error("Invalid resize mode")}})()};\n      `}\n      ${t.registerUniform("output_size","u32").registerUniform("scales","f32",a.length).registerUniform("roi","f32",U.length).declareVariables(c,l)}\n      ${t.mainStart()}\n        ${t.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n        ${d?"output[global_idx] = input[global_idx];":`\n        let output_indices = ${l.offsetToIndices("global_idx")};\n        var input_indices: ${c.type.indices};\n        ${(()=>{switch(e.mode){case"nearest":return`input_indices = calculateInputIndicesFromOutputIndices(output_indices);\n                if (checkInputIndices(input_indices)) {\n                  output[global_idx] = ${c.getByIndices("input_indices")};\n                } else {\n                  output[global_idx] = ${e.extrapolationValue};\n                }`;case"linear":return`output[global_idx] = ${2===Q.length||4===Q.length?"bilinearInterpolation":"trilinearInterpolation"}(output_indices);`;case"cubic":return"output[global_idx] = bicubicInterpolation(output_indices);";default:throw Error(`Unsupported resize mode: ${e.mode}`)}})()};\n`}\n      }`,getRunData:()=>({outputs:[{dims:i,dataType:t.dataType}],dispatchGroup:{x:Math.ceil(g/64)},programUniforms:[{type:"uint32",data:g},{type:"float32",data:a},{type:"float32",data:U},...createTensorShapeVariables(Q),...createTensorShapeVariables(i)]})}},getOpsetVersionFromCustomDataBuffer=t=>{const e=t.customDataBuffer;return new Uint32Array(e,e.byteOffset,1)[0]},resize2=(t,e)=>{const n=[],B=[],s=[],F=getOpsetVersionFromCustomDataBuffer(t);if(0!==e.antialias)throw Error("Only default value (0) for Antialias attribute is supported");validateInputs44(t.inputs,e,F,n,B,s),t.compute(createResizeProgramInfo(t.inputs[0],e,F,n,B,s),{inputs:[0]})},parseResizeAttributes=t=>{const e=t.antialias,n=t.axes,B=t.coordinateTransformMode,s=t.cubicCoeffA,F=0!==t.excludeOutside,Q=t.extrapolationValue,U=t.keepAspectRatioPolicy,i=t.mode,a=""===t.nearestMode?"simple":t.nearestMode;return createAttributeWithCacheKey2({antialias:e,axes:n,coordinateTransformMode:B,cubicCoeffA:s,excludeOutside:F,extrapolationValue:Q,keepAspectRatioPolicy:U,mode:i,nearestMode:a})}}}),validateInputs45,createSkipLayerNormProgramInfo,skipLayerNorm,parseSkipLayerNormAttributes,init_skip_layer_norm=__esm({"web/lib/wasm/jsep/webgpu/ops/skip-layer-norm.ts"(){init_wasm_common(),init_util2(),init_attribute_with_cache_key2(),init_common(),validateInputs45=t=>{if(!t||t.length<3)throw new Error("layerNorm requires at least 3 inputs.");const e=t[0],n=t[1],B=t[2];if(e.dataType!==n.dataType||e.dataType!==B.dataType)throw new Error("All inputs must have the same data type");if(3!==e.dims.length&&2!==e.dims.length)throw new Error("Input must be 2D or 3D");if(3!==n.dims.length&&2!==n.dims.length)throw new Error("Skip must be 2D or 3D");const s=e.dims[e.dims.length-1],F=e.dims[e.dims.length-2];if(n.dims[n.dims.length-1]!==s)throw new Error("Skip must have the same hidden size as input");if(n.dims[n.dims.length-2]!==F)throw new Error("Skip must have the same sequence length as input");if(1!==B.dims.length)throw new Error("Gamma must be 1D");if(B.dims[B.dims.length-1]!==s)throw new Error("Gamma must have the same hidden size as input");if(t.length>3){const e=t[3];if(1!==e.dims.length)throw new Error("Beta must be 1D");if(e.dims[e.dims.length-1]!==s)throw new Error("Beta must have the same hidden size as input")}if(t.length>4){const e=t[4];if(1!==e.dims.length)throw new Error("Bias must be 1D");if(e.dims[e.dims.length-1]!==s)throw new Error("Bias must have the same hidden size as input")}},createSkipLayerNormProgramInfo=(t,e,n,B)=>{const s=t[0].dims,F=s,Q=ShapeUtil2.size(s),U=s.slice(-1)[0],i=B?s.slice(0,-1).concat(1):[],a=t.length>3,l=t.length>4,c=B&&n>1,g=B&&n>2,d=n>3,I=getMaxComponents(U),o=[inputVariable("x",t[0].dataType,t[0].dims,I),inputVariable("skip",t[1].dataType,t[1].dims,I),inputVariable("gamma",t[2].dataType,t[2].dims,I)];a&&o.push(inputVariable("beta",t[3].dataType,t[3].dims,I)),l&&o.push(inputVariable("bias",t[4].dataType,t[4].dims,I)),o.push(outputVariable("output",t[0].dataType,F,I)),c&&o.push(outputVariable("meanOutput",1,i)),g&&o.push(outputVariable("invStdOutput",1,i)),d&&o.push(outputVariable("inputSkipBiasSum",t[0].dataType,F,I));const r=tensorTypeToWsglStorageType(t[0].dataType),u=[{dims:F,dataType:t[0].dataType}];return n>1&&u.push({dims:i,dataType:1}),n>2&&u.push({dims:i,dataType:1}),n>3&&u.push({dims:s,dataType:t[0].dataType}),{name:"SkipLayerNormalization",shaderCache:{hint:e.cacheKey},getShaderSource:t=>`\n      const hiddenSize: f32 = ${U};\n      const hiddenSizeVectorized: u32 = ${U/I};\n      const epsilon: f32 = ${e.epsilon};\n\n      ${t.declareVariables(...o)}\n\n      ${t.mainStart()}\n        ${t.guardAgainstOutOfBoundsWorkgroupSizes(Q/U)}\n        let offset = global_idx * hiddenSizeVectorized;\n        var sum = ${fillVector("f32",I)};\n        var squareSum = ${fillVector("f32",I)};\n        for (var i: u32 = 0; i < hiddenSizeVectorized; i++) {\n          let skipValue = skip[offset + i];\n          let biasValue = ${l?"bias[i]":"0.0"};\n          let inputValue = x[offset + i];\n          let value = inputValue + skipValue + biasValue;\n          ${d?"inputSkipBiasSum[offset + i] = value;":""}\n          output[offset + i] = value;\n          let f32Value = ${castToF32(r,I,"value")};\n          sum += f32Value;\n          squareSum += f32Value * f32Value;\n        }\n        let mean = ${sumVector("sum",I)} / hiddenSize;\n        let invStdDev = inverseSqrt(${sumVector("squareSum",I)} / hiddenSize - mean * mean + epsilon);\n        ${c?"meanOutput[global_idx] = mean;":""}\n        ${g?"invStdOutput[global_idx] = invStdDev;":""}\n        for (var i: u32 = 0; i < hiddenSizeVectorized; i++) {\n          output[offset + i] = (output[offset + i] - ${r}(mean)) * ${r}(invStdDev) * gamma[i]\n           + ${a?"beta[i]":"0.0"};\n        }\n      }`,getRunData:()=>({outputs:u,dispatchGroup:{x:Math.ceil(Q/U/64)}})}},skipLayerNorm=(t,e)=>{const n=!1;validateInputs45(t.inputs);const B=[0];t.outputCount>1&&B.push(-3),t.outputCount>2&&B.push(-3),t.outputCount>3&&B.push(3),t.compute(createSkipLayerNormProgramInfo(t.inputs,e,t.outputCount,n),{outputs:B})},parseSkipLayerNormAttributes=t=>{const e=t.epsilon;return createAttributeWithCacheKey2({epsilon:e})}}}),validateInputs46,readInput,createSliceAttributesFromInputs,fixStartEndValues,calculateInputIndicesImpl,createSliceProgramInfo2,slice2,parseSliceAttributes2,init_slice2=__esm({"web/lib/wasm/jsep/webgpu/ops/slice.ts"(){init_wasm_common(),init_util2(),init_attribute_with_cache_key2(),init_common(),validateInputs46=(t,e)=>{if(!t||t.length<1)throw new Error("too few inputs");if(0!==e.axes.length){if(e.axes.length!==e.starts.length||e.axes.length!==e.ends.length)throw new Error("axes, starts and ends must have the same length")}else if(e.starts.length!==e.ends.length)throw new Error("starts and ends must have the same length");t.slice(1).forEach(((e,n)=>{if(6!==t[n+1].dataType&&7!==t[n+1].dataType)throw new Error(`Input ${n} must be an array of int32 or int64`)}))},readInput=(t,e)=>{const n=[];if(t.length>e)if(7===t[e].dataType)t[e].getBigInt64Array().forEach((t=>n.push(Number(t))));else{if(6!==t[e].dataType)throw new Error(`Input ${e} must be an array of int32 or int64`);t[e].getInt32Array().forEach((t=>n.push(Number(t))))}return n},createSliceAttributesFromInputs=(t,e)=>{if(t.length>1){const e=readInput(t,1),n=readInput(t,2);let B=readInput(t,3);return 0===B.length&&(B=[...Array(t[0].dims.length).keys()]),createAttributeWithCacheKey2({starts:e,ends:n,axes:B})}return e},fixStartEndValues=(t,e,n,B,s)=>{let F=t;return t<0&&(F+=n[B[e]]),s[e]<0?Math.max(0,Math.min(F,n[B[e]]-1)):Math.max(0,Math.min(F,n[B[e]]))},calculateInputIndicesImpl=(t,e,n)=>`fn calculateInputIndices(output_indices: ${e.type.indices}) -> ${t.type.indices} {\n          var input_indices: ${t.type.indices};\n          var carry = 0u;\n          for (var i = ${n.length}; i >= 0; i--) {\n            let input_shape_i = ${getElementAt("uniforms.input_shape","i",n.length)};\n            let steps_i = ${getElementAt("uniforms.steps","i",n.length)};\n            let signs_i = ${getElementAt("uniforms.signs","i",n.length)};\n            let starts_i = ${getElementAt("uniforms.starts","i",n.length)};\n            var output_index = ${e.indicesGet("output_indices","i")};\n            var input_index = output_index * steps_i + starts_i + carry;\n            carry = input_index / input_shape_i;\n            input_index = input_index % input_shape_i;\n            if (signs_i < 0) {\n              input_index = input_shape_i - input_index - 1u + starts_i;\n            }\n            ${t.indicesSet("input_indices","i","input_index")};\n          }\n          return input_indices;\n      }`,createSliceProgramInfo2=(t,e)=>{const n=t[0].dims,B=ShapeUtil2.size(n),s=e.axes.length>0?ShapeUtil2.normalizeAxes(e.axes,n.length):[...Array(n.length).keys()];let F=readInput(t,4);F.forEach((t=>0!==t||(()=>{throw new Error("step cannot be 0")}))),0===F.length&&(F=Array(s.length).fill(1));const Q=e.starts.map(((t,e)=>fixStartEndValues(t,e,n,s,F))),U=e.ends.map(((t,e)=>fixStartEndValues(t,e,n,s,F)));if(s.length!==Q.length||s.length!==U.length)throw new Error("start, ends and axes should have the same number of elements");if(s.length!==n.length)for(let t=0;t<n.length;++t)s.includes(t)||(Q.splice(t,0,0),U.splice(t,0,n[t]),F.splice(t,0,1));const i=F.map((t=>Math.sign(t)));F.forEach(((t,e,n)=>{if(t<0){const B=(U[e]-Q[e])/t,s=Q[e],i=s+B*F[e];Q[e]=i,U[e]=s,n[e]=-t}}));const a=n.slice(0);s.forEach(((t,e)=>{a[t]=Math.ceil((U[t]-Q[t])/F[t])}));const l={dims:a,dataType:t[0].dataType},c=outputVariable("output",t[0].dataType,a.length),g=inputVariable("input",t[0].dataType,t[0].dims.length),d=ShapeUtil2.size(a),I=[{name:"outputSize",type:"u32"},{name:"starts",type:"u32",length:Q.length},{name:"signs",type:"i32",length:i.length},{name:"steps",type:"u32",length:F.length}],o=[{type:"uint32",data:d},{type:"uint32",data:Q},{type:"int32",data:i},{type:"uint32",data:F},...createTensorShapeVariables(t[0].dims),...createTensorShapeVariables(a)];return{name:"Slice",shaderCache:{hint:`${i.length}_${Q.length}_${F.length}`,inputDependencies:["rank"]},getShaderSource:t=>`\n      ${t.registerUniforms(I).declareVariables(g,c)}\n        ${calculateInputIndicesImpl(g,c,n)}\n        ${t.mainStart()}\n          ${t.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n          let output_indices = ${c.offsetToIndices("global_idx")};\n          let input_indices = calculateInputIndices(output_indices);\n          ${c.setByOffset("global_idx",g.getByIndices("input_indices"))}\n      }`,getRunData:()=>({outputs:[l],dispatchGroup:{x:Math.ceil(B/64)},programUniforms:o})}},slice2=(t,e)=>{validateInputs46(t.inputs,e);const n=createSliceAttributesFromInputs(t.inputs,e);t.compute(createSliceProgramInfo2(t.inputs,n),{inputs:[0]})},parseSliceAttributes2=t=>{const e=t.starts,n=t.ends,B=t.axes;return createAttributeWithCacheKey2({starts:e,ends:n,axes:B})}}}),validateInputs47,createSoftmaxProgramInfo,softmax2,parseSoftmaxAttributes2,init_softmax2=__esm({"web/lib/wasm/jsep/webgpu/ops/softmax.ts"(){init_util2(),init_attribute_with_cache_key2(),init_common(),validateInputs47=t=>{if(!t||1!==t.length)throw new Error("Softmax op requires 1 input.")},createSoftmaxProgramInfo=(t,e)=>{const n=t.dims,B=ShapeUtil2.size(n);let s=e.axis;if(s<0&&(s=n.length+s),s<n.length-1)throw new Error("softmax only supports last axis for now.");const F=n[s],Q=B/F,U=getMaxComponents(F),i=F/U,a=inputVariable("x",t.dataType,t.dims,U),l=outputVariable("result",t.dataType,t.dims,U),c=a.type.value,g="f32"===tensorTypeToWsglStorageType(t.dataType)?`var threadMax = ${c}(-3.402823e+38f);`:`var threadMax = ${c}(-65504.0h);`;return{name:"Softmax",shaderCache:{hint:`${U}`,inputDependencies:["type"]},getRunData:()=>({outputs:[{dims:n,dataType:t.dataType}],dispatchGroup:{x:Q},programUniforms:[{type:"uint32",data:i}]}),getShaderSource:t=>{return`\n      var<workgroup> rowMaxShared : ${c};\n      var<workgroup> rowSumShared : ${c};\n      var<workgroup> threadShared : array<${c}, 64>;\n\n      fn getValue(row: i32, col: i32, row_stride: i32) -> ${c} {\n        let index = row * row_stride + col;\n        return x[index];\n      }\n\n      fn setValue(row: i32, col: i32, row_stride: i32, value: ${c}) {\n        let index = row * row_stride + col;\n        result[index] = value;\n      }\n      ${t.registerUniform("packedCols","i32").declareVariables(a,l)}\n      ${t.mainStart()}\n        let gindex = i32(global_idx);\n        let lindex = i32(local_idx);\n        const wg = 64;\n        let row = gindex / wg;\n        let cols = uniforms.packedCols;\n        let row_stride : i32 = uniforms.packedCols;\n\n        // find the rows max\n        ${g}\n        for (var col = lindex; col < cols; col += wg) {\n          let value = getValue(row, col, row_stride);\n          threadMax = max(threadMax, value);\n        }\n        if (lindex < cols) {\n          threadShared[lindex] = threadMax;\n        }\n        workgroupBarrier();\n\n        var reduceSize = min(cols, wg);\n        for (var currSize = reduceSize >> 1;  currSize > 0; currSize = reduceSize >> 1) {\n          reduceSize = currSize + (reduceSize & 1);\n          if (lindex < currSize) {\n            threadShared[lindex] = max(threadShared[lindex], threadShared[lindex + reduceSize]);\n          }\n          workgroupBarrier();\n        }\n        if (lindex == 0) {\n          rowMaxShared = ${c}(${e="threadShared[0]",n=U,4===n?`max(max(${e}.x, ${e}.y), max(${e}.z, ${e}.w))`:2===n?`max(${e}.x, ${e}.y)`:3===n?`max(max(${e}.x, ${e}.y), ${e}.z)`:e});\n        }\n        workgroupBarrier();\n\n        // find the rows sum\n        var threadSum = ${c}(0.0);\n        for (var col = lindex; col < cols; col += wg) {\n          let subExp = exp(getValue(row, col, row_stride) - rowMaxShared);\n          threadSum += subExp;\n        }\n        threadShared[lindex] = threadSum;\n        workgroupBarrier();\n\n        for (var currSize = wg >> 1;  currSize > 0; currSize = currSize >> 1) {\n          if (lindex < currSize) {\n            threadShared[lindex] = threadShared[lindex] + threadShared[lindex + currSize];\n          }\n          workgroupBarrier();\n        }\n        if (lindex == 0) {\n          rowSumShared = ${c}(${sumVector("threadShared[0]",U)});\n        }\n        workgroupBarrier();\n\n        // calculate final value for each element in the row\n        for (var col = lindex; col < cols; col += wg) {\n          let value = exp(getValue(row, col, row_stride) - rowMaxShared) / rowSumShared;\n          setValue(row, col, row_stride, value);\n        }\n      }`;var e,n}}},softmax2=(t,e)=>{validateInputs47(t.inputs),t.compute(createSoftmaxProgramInfo(t.inputs[0],e))},parseSoftmaxAttributes2=t=>createAttributeWithCacheKey2({axis:t.axis})}}),validateInputs48,createSplitAttributesFromInputs,calculateOutputIndexImpl,writeBufferDataImpl,createSplitProgramInfo2,split2,parseSplitAttributes2,init_split2=__esm({"web/lib/wasm/jsep/webgpu/ops/split.ts"(){init_util2(),init_attribute_with_cache_key2(),init_common(),validateInputs48=t=>{if(!t||t.length<1)throw new Error("too few inputs")},createSplitAttributesFromInputs=(t,e)=>{const n=[];let B=e.numOutputs;return t[1].dims[0]>0&&(t[1].getBigInt64Array().forEach((t=>n.push(Number(t)))),B=n.length),createAttributeWithCacheKey2({numOutputs:B,axis:e.axis,splitSizes:n})},calculateOutputIndexImpl=t=>`\nfn calculateOutputIndex(index: u32) -> u32 {\n    for (var i: u32 = 0u; i < ${t}u; i += 1u ) {\n    if (index < ${getElementAt("uniforms.size_in_split_axis","i",t)}) {\n        return i;\n    }\n    }\n    return ${t}u;\n}`,writeBufferDataImpl=t=>{const e=t.length,n=[];for(let B=0;B<e;++B){const s=t[B].setByIndices("indices","input[global_idx]");1===e?n.push(s):0===B?n.push(`if (output_number == ${B}u) { ${s} }`):B===e-1?n.push(`else { ${s} }`):n.push(`else if (output_number == ${B}) { ${s} }`)}return`\n      fn writeBufferData(output_number: u32, indices: ${t[0].type.indices}, global_idx: u32) {\n        ${n.join("\n")}\n      }`},createSplitProgramInfo2=(t,e)=>{const n=t[0].dims,B=ShapeUtil2.size(n),s=t[0].dataType,F=ShapeUtil2.normalizeAxis(e.axis,n.length),Q=new Array(e.numOutputs),U=inputVariable("input",s,n),i=new Array(e.numOutputs),a=[],l=[];let c=0;const g=[{type:"uint32",data:B}];for(let B=0;B<e.numOutputs;B++){c+=e.splitSizes[B],i[B]=c;const F=n.slice();F[e.axis]=e.splitSizes[B],l.push(F),Q[B]=outputVariable(`output${B}`,s,F),a.push({dims:l[B],dataType:t[0].dataType})}g.push({type:"uint32",data:i}),g.push(...createTensorShapeVariables(n)),l.forEach((t=>g.push(...createTensorShapeVariables(t))));return{name:"Split",shaderCache:{hint:e.cacheKey,inputDependencies:["rank"]},getShaderSource:t=>`\n  ${t.registerUniform("input_size","u32").registerUniform("size_in_split_axis","u32",i.length).declareVariables(U,...Q)}\n  ${calculateOutputIndexImpl(i.length)}\n  ${writeBufferDataImpl(Q)}\n\n  ${t.mainStart()}\n    ${t.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.input_size")}\n\n    var indices = ${U.offsetToIndices("global_idx")};\n    var index = ${U.indicesGet("indices",F)};\n    let output_number = calculateOutputIndex(index);\n    if (output_number != 0) {\n      index -= ${getElementAt("uniforms.size_in_split_axis","output_number - 1u",i.length)};\n      ${U.indicesSet("indices",F,"index")};\n    }\n    writeBufferData(output_number, indices, global_idx);\n  }`,getRunData:()=>({outputs:a,dispatchGroup:{x:Math.ceil(B/64)},programUniforms:g})}},split2=(t,e)=>{validateInputs48(t.inputs);const n=1===t.inputs.length?e:createSplitAttributesFromInputs(t.inputs,e);t.compute(createSplitProgramInfo2(t.inputs,n),{inputs:[0]})},parseSplitAttributes2=t=>{const e=t.axis,n=t.splitSizes,B=t.numOutputs<0?n.length:t.numOutputs;if(B!==n.length)throw new Error("numOutputs and splitSizes lengh must be equal");return createAttributeWithCacheKey2({axis:e,numOutputs:B,splitSizes:n})}}}),getRepeats,validateInputs49,getOutputShape3,createTileProgramInfo2,tile2,init_tile2=__esm({"web/lib/wasm/jsep/webgpu/ops/tile.ts"(){init_wasm_common(),init_util2(),init_common(),getRepeats=t=>Array.from(t.getBigInt64Array(),Number),validateInputs49=t=>{if(!t||2!==t.length)throw new Error("Tile requires 2 inputs.");if(1!==t[0].dataType&&6!==t[0].dataType&&12!==t[0].dataType)throw new Error("Tile only support float, int32, and uint32 data types");if(7!==t[1].dataType)throw new Error("Tile `repeats` input should be of int64 data type");if(1!==t[1].dims.length)throw new Error("Tile `repeats` input should be 1-D");if(getRepeats(t[1]).length!==t[0].dims.length)throw new Error("Tile `repeats` input should have same number of elements as rank of input data tensor")},getOutputShape3=(t,e)=>{const n=[];for(let B=0;B<t.length;++B)n.push(t[B]*e[B]);return n},createTileProgramInfo2=t=>{const e=t[0].dims,n=getRepeats(t[1]),B=getOutputShape3(e,n),s=ShapeUtil2.size(B),F=t[0].dataType,Q=inputVariable("input",F,e.length),U=outputVariable("output",F,B.length);return{name:"Tile",shaderCache:{hint:`${n}`,inputDependencies:["rank"]},getRunData:()=>({outputs:[{dims:B,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(s/64)},programUniforms:[{type:"uint32",data:s},...createTensorShapeVariables(t[0].dims),...createTensorShapeVariables(B)]}),getShaderSource:t=>`\n      const inputShape = ${Q.indices(...e)};\n      ${t.registerUniform("output_size","u32").declareVariables(Q,U)}\n      ${t.mainStart()}\n      ${t.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n      let output_indices = ${U.offsetToIndices("global_idx")};\n      var input_indices: ${Q.type.indices};\n      for (var i = 0; i < ${e.length}; i++) {\n        let input_dim_i = ${Q.indicesGet("uniforms.input_shape","i")};\n        let input_dim_value = ${U.indicesGet("output_indices","i")}  % input_dim_i;\n\n        ${Q.indicesSet("input_indices","i","input_dim_value")}\n      }\n      ${U.setByOffset("global_idx",Q.getByIndices("input_indices"))}\n    }`}},tile2=t=>{validateInputs49(t.inputs),t.compute(createTileProgramInfo2(t.inputs),{inputs:[0]})}}}),createWhereOpProgramShader,createWhereOpProgramInfo,where,init_where=__esm({"web/lib/wasm/jsep/webgpu/ops/where.ts"(){init_wasm_common(),init_util2(),init_common(),createWhereOpProgramShader=(t,e,n,B,s)=>{const F=outputVariable("output_data",s,n.length,4),Q=inputVariable("a_data",e[1].dataType,e[1].dims.length,4),U=inputVariable("b_data",e[2].dataType,e[2].dims.length,4),i=inputVariable("c_data",e[0].dataType,e[0].dims.length,4);let a;const l=(t,e,n)=>`select(${e}, ${t}, ${n})`;if(B){const t=(t,e,n="")=>{const B=`a_data[index_a${e}][component_a${e}]`,s=`b_data[index_b${e}][component_b${e}]`,a=`bool(c_data[index_c${e}] & ${4278190080>>>8*(3-e)}u)`;return`\n            let output_indices${e} = ${F.offsetToIndices(`global_idx * 4u + ${e}u`)};\n            let offset_a${e} = ${Q.broadcastedIndicesToOffset(`output_indices${e}`,F)};\n            let offset_b${e} = ${U.broadcastedIndicesToOffset(`output_indices${e}`,F)};\n            let offset_c${e} = ${i.broadcastedIndicesToOffset(`output_indices${e}`,F)};\n            let index_a${e} = offset_a${e} / 4u;\n            let index_b${e} = offset_b${e} / 4u;\n            let index_c${e} = offset_c${e} / 4u;\n            let component_a${e} = offset_a${e} % 4u;\n            let component_b${e} = offset_b${e} % 4u;\n            ${t}[${e}] = ${n}(${l(B,s,a)});\n          `};a=9===s?`\n            var data = vec4<u32>(0);\n            ${t("data",0,"u32")}\n            ${t("data",1,"u32")}\n            ${t("data",2,"u32")}\n            ${t("data",3,"u32")}\n            output_data[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`:`\n            ${t("output_data[global_idx]",0)}\n            ${t("output_data[global_idx]",1)}\n            ${t("output_data[global_idx]",2)}\n            ${t("output_data[global_idx]",3)}\n          `}else a=F.setByOffset("global_idx",l(Q.getByOffset("global_idx"),U.getByOffset("global_idx"),i.getByOffset("global_idx")));return`\n        ${t.registerUniform("vec_size","u32").declareVariables(i,Q,U,F)}\n        ${t.mainStart()}\n        ${t.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}\n        ${a}\n      }`},createWhereOpProgramInfo=t=>{const e=t[1].dims,n=t[2].dims,B=t[0].dims,s=t[1].dataType,F=!(ShapeUtil2.areEqual(e,n)&&ShapeUtil2.areEqual(n,B));let Q=e,U=ShapeUtil2.size(e);if(F){const t=BroadcastUtil2.calcShape(BroadcastUtil2.calcShape(e,n,!1),B,!1);if(!t)throw new Error("Can't perform where op on the given tensors");Q=t,U=ShapeUtil2.size(Q)}const i=Math.ceil(U/4);return{name:"Where",shaderCache:{inputDependencies:["rank","rank","rank"]},getShaderSource:e=>createWhereOpProgramShader(e,t,Q,F,s),getRunData:()=>({outputs:[{dims:Q,dataType:s}],dispatchGroup:{x:Math.ceil(U/64/4)},programUniforms:[{type:"uint32",data:i},...createTensorShapeVariables(B),...createTensorShapeVariables(e),...createTensorShapeVariables(n),...createTensorShapeVariables(Q)]})}},where=t=>{t.compute(createWhereOpProgramInfo(t.inputs))}}}),WEBGPU_OP_RESOLVE_RULES,init_op_resolve_rules2=__esm({"web/lib/wasm/jsep/webgpu/op-resolve-rules.ts"(){init_argminmax(),init_attention(),init_batch_norm(),init_bias_add(),init_bias_split_gelu(),init_binary_op2(),init_concat2(),init_conv2(),init_conv_transpose2(),init_cumsum(),init_einsum(),init_expand(),init_gather2(),init_gather_elements(),init_gemm2(),init_instance_norm(),init_layer_norm(),init_matmul2(),init_multi_head_attentiion(),init_pad2(),init_pool2(),init_range(),init_reduce2(),init_resize(),init_skip_layer_norm(),init_slice2(),init_softmax2(),init_split2(),init_tile2(),init_transpose2(),init_unary_op2(),init_where(),WEBGPU_OP_RESOLVE_RULES=new Map([["Abs",[abs2]],["Acos",[acos2]],["Acosh",[acosh]],["Add",[add3]],["ArgMax",[argMax,parseArgMinMaxAttributes]],["ArgMin",[argMin,parseArgMinMaxAttributes]],["Asin",[asin2]],["Asinh",[asinh]],["Atan",[atan2]],["Atanh",[atanh]],["Attention",[attention]],["AveragePool",[averagePool2,parseAveragePoolAttributes2]],["BatchNormalization",[batchNorm]],["BiasAdd",[biasAdd]],["BiasSplitGelu",[biasSplitGelu]],["Cast",[cast2,parseCastAttributes2]],["Ceil",[ceil2]],["Clip",[clip2]],["Concat",[concat2,parseConcatAttributes2]],["Conv",[conv2,parseConvAttributes2]],["ConvTranspose",[convTranspose2,parseConvTransposeAttributes2]],["Cos",[cos2]],["Cosh",[cosh]],["CumSum",[cumsum,parseCumSumAttributes]],["Div",[div2]],["Einsum",[einsum,parseEinsumAttributes]],["Elu",[elu2,parseAlphaAttributes]],["Equal",[equal2]],["Erf",[erf]],["Exp",[exp2]],["Expand",[expand]],["Floor",[floor2]],["FusedConv",[conv2,parseConvAttributes2]],["Gather",[gather2,parseGatherAttributes2]],["GatherElements",[gatherElements,parseGatherElementsAttributes]],["Gelu",[gelu]],["Gemm",[gemm2,parseGemmAttributes2]],["GlobalAveragePool",[globalAveragePool2,parseGlobalAveragePoolAttributes2]],["GlobalMaxPool",[globalMaxPool2,parseGlobalMaxPoolAttributes]],["Greater",[greater2]],["GreaterOrEqual",[greaterOrEqual]],["InstanceNormalization",[instanceNorm]],["LayerNormalization",[layerNorm]],["LeakyRelu",[leakyRelu2,parseAlphaAttributes]],["Less",[less2]],["LessOrEqual",[lessOrEqual]],["Log",[log3]],["MatMul",[matMul2]],["MaxPool",[maxPool2,parseMaxPoolAttributes2]],["Mul",[mul2]],["MultiHeadAttention",[multiHeadAttention,parseMultiHeadAttentionAttributes]],["Neg",[neg2]],["Not",[not3]],["Pad",[pad]],["Pow",[pow2]],["Range",[range]],["Reciprocal",[reciprocal]],["ReduceMin",[reduceMin2]],["ReduceMean",[reduceMean2]],["ReduceMax",[reduceMax2]],["ReduceSum",[reduceSum2]],["ReduceProd",[reduceProd2]],["ReduceL1",[reduceL1]],["ReduceL2",[reduceL2]],["ReduceLogSum",[reduceLogSum2]],["ReduceLogSumExp",[reduceLogSumExp]],["ReduceSumSquare",[reduceSumSquare]],["Relu",[relu2]],["Resize",[resize2,parseResizeAttributes]],["Sigmoid",[sigmoid2]],["Sin",[sin2]],["Sinh",[sinh]],["Slice",[slice2,parseSliceAttributes2]],["SkipLayerNormalization",[skipLayerNorm,parseSkipLayerNormAttributes]],["Split",[split2,parseSplitAttributes2]],["Sqrt",[sqrt2]],["Softmax",[softmax2,parseSoftmaxAttributes2]],["Sub",[sub2]],["Tan",[tan2]],["Tanh",[tanh2]],["ThresholdedRelu",[thresholdedRelu,parseAlphaAttributes]],["Tile",[tile2]],["Transpose",[transpose2,parseTransposeAttributes2]],["Where",[where]]])}}),ProgramManager2,init_program_manager2=__esm({"web/lib/wasm/jsep/webgpu/program-manager.ts"(){init_esm(),init_log(),init_common(),ProgramManager2=class{constructor(t){this.backend=t,this.repo=new Map,this.attributesBound=!1}getArtifact(t){return this.repo.get(t)}setArtifact(t,e){this.repo.set(t,e)}run(t,e,n,B,s){TRACE_FUNC_BEGIN(t.programInfo.name);const F=this.backend.device,Q=this.backend.getComputePassEncoder();this.backend.writeTimestamp(2*this.backend.pendingDispatchNumber),Q.setPipeline(t.computePipeline);const U=[];for(const t of e)U.push({binding:U.length,resource:{buffer:t.buffer}});for(const t of n)U.push({binding:U.length,resource:{buffer:t.buffer}});s&&U.push({binding:U.length,resource:s});const i=F.createBindGroup({layout:t.computePipeline.getBindGroupLayout(0),entries:U,label:t.programInfo.name});Q.setBindGroup(0,i),Q.dispatchWorkgroups(...B),this.backend.writeTimestamp(2*this.backend.pendingDispatchNumber+1),this.backend.pendingDispatchNumber++,(this.backend.pendingDispatchNumber>=this.backend.maxDispatchNumber||"at-passes"===this.backend.queryType)&&this.backend.endComputePass(),this.backend.pendingDispatchNumber>=this.backend.maxDispatchNumber&&this.backend.flush(),TRACE_FUNC_END(t.programInfo.name)}dispose(){}build(t,e){TRACE_FUNC_BEGIN(t.name);const n=this.backend.device,B=[];n.features.has("shader-f16")&&B.push("enable f16;");const s=createShaderHelper(e),F=t.getShaderSource(s),Q=`${B.join("\n")}\n${s.additionalImplementations}\n${F}`,U=n.createShaderModule({code:Q,label:t.name});LOG_DEBUG("verbose",(()=>`[WebGPU] ${t.name} shader code: ${Q}`));const i=n.createComputePipeline({compute:{module:U,entryPoint:"main"},layout:"auto",label:t.name});return TRACE_FUNC_END(t.name),{programInfo:t,computePipeline:i}}normalizeDispatchGroupSize(t){const e="number"==typeof t?t:t.x,n="number"==typeof t?1:t.y||1,B="number"==typeof t?1:t.z||1,s=this.backend.device.limits.maxComputeWorkgroupsPerDimension;if(e<=s&&n<=s&&B<=s)return[e,n,B];const F=e*n*B;let Q=Math.ceil(Math.sqrt(F));if(Q>s){if(Q=Math.ceil(Math.cbrt(F)),Q>s)throw new Error("Total dispatch size exceeds WebGPU maximum.");return[Q,Q,Q]}return[Q,Q,1]}}}}),getProgramInputTensorInfoDependencyKey,getProgramInfoUniqueKey2,WebGpuBackend,init_backend_webgpu=__esm({"web/lib/wasm/jsep/backend-webgpu.ts"(){init_esm(),init_wasm_common(),init_log(),init_tensor_view(),init_gpu_data_manager(),init_op_resolve_rules2(),init_program_manager2(),getProgramInputTensorInfoDependencyKey=(t,e)=>{if(e.length!==t.length)throw new Error(`inputDependencies length ${e.length} is not equal to inputTensors length ${t.length}.`);const n=[];for(let B=0;B<t.length;++B){const s=t[B].dataType;switch(e[B]){case"none":n.push("");break;case"type":n.push(`${s}`);break;case"rank":{const e=t[B].dims.length;n.push(`${s};${e}`);break}case"dims":{const e=t[B].dims.join(",");n.push(`${s};${e}`);break}default:throw new Error(`unsupported input dependency: ${e[B]}`)}}return n.join("|")},getProgramInfoUniqueKey2=(t,e,n)=>{let B=t.name;return t.shaderCache?.hint&&(B+="["+t.shaderCache.hint+"]"),B+=":"+n+`:${getProgramInputTensorInfoDependencyKey(e,t.shaderCache?.inputDependencies??new Array(e.length).fill("dims"))}`,B},WebGpuBackend=class{constructor(){this.currentKernelId=null,this.commandEncoder=null,this.computePassEncoder=null,this.maxDispatchNumber=16,this.pendingDispatchNumber=0,this.pendingKernels=[],this.pendingQueries=new Map,this.sessionExternalDataMapping=new Map}get currentKernelCustomData(){if(null===this.currentKernelId)throw new Error("currentKernelCustomData(): currentKernelId is null. (should not happen)");let t=this.kernelCustomData.get(this.currentKernelId);return t||(t={},this.kernelCustomData.set(this.currentKernelId,t)),t}async initialize(t,e){this.env=t;const n=[],B={requiredLimits:{maxComputeWorkgroupStorageSize:e.limits.maxComputeWorkgroupStorageSize,maxComputeWorkgroupsPerDimension:e.limits.maxComputeWorkgroupsPerDimension,maxStorageBufferBindingSize:e.limits.maxStorageBufferBindingSize,maxBufferSize:e.limits.maxBufferSize,maxComputeInvocationsPerWorkgroup:e.limits.maxComputeInvocationsPerWorkgroup,maxComputeWorkgroupSizeX:e.limits.maxComputeWorkgroupSizeX,maxComputeWorkgroupSizeY:e.limits.maxComputeWorkgroupSizeY,maxComputeWorkgroupSizeZ:e.limits.maxComputeWorkgroupSizeZ},requiredFeatures:n};e.features.has("chromium-experimental-timestamp-query-inside-passes")?n.push("chromium-experimental-timestamp-query-inside-passes"):e.features.has("timestamp-query")&&n.push("timestamp-query"),e.features.has("shader-f16")&&n.push("shader-f16"),this.device=await e.requestDevice(B),this.gpuDataManager=createGpuDataManager(this),this.programManager=new ProgramManager2(this),this.kernels=new Map,this.kernelPersistentData=new Map,this.kernelCustomData=new Map,configureLogger(t.logLevel,!!t.debug),this.device.onuncapturederror=t=>{t.error instanceof GPUValidationError&&console.error(`An uncaught WebGPU validation error was raised: ${t.error.message}`)},Object.defineProperty(this.env.webgpu,"device",{value:this.device}),this.setQueryType()}dispose(){void 0!==this.querySet&&this.querySet.destroy(),this.gpuDataManager.dispose()}getCommandEncoder(){return this.commandEncoder||(this.commandEncoder=this.device.createCommandEncoder(),this.setQueryType(),"none"!==this.queryType&&void 0===this.querySet&&(this.querySet=this.device.createQuerySet({type:"timestamp",count:2*this.maxDispatchNumber}),this.queryResolveBuffer=this.device.createBuffer({size:2*this.maxDispatchNumber*8,usage:GPUBufferUsage.COPY_SRC|GPUBufferUsage.QUERY_RESOLVE}))),this.commandEncoder}getComputePassEncoder(){if(!this.computePassEncoder){const t={};"at-passes"===this.queryType&&(t.timestampWrites={querySet:this.querySet,beginningOfPassWriteIndex:2*this.pendingDispatchNumber,endOfPassWriteIndex:2*this.pendingDispatchNumber+1}),this.computePassEncoder=this.getCommandEncoder().beginComputePass(t)}return this.computePassEncoder}endComputePass(){this.computePassEncoder&&(this.computePassEncoder.end(),this.computePassEncoder=null)}flush(){if(!this.commandEncoder)return;let t;TRACE_FUNC_BEGIN(),this.endComputePass(),"none"!==this.queryType&&(this.commandEncoder.resolveQuerySet(this.querySet,0,2*this.pendingDispatchNumber,this.queryResolveBuffer,0),t=this.device.createBuffer({size:2*this.pendingDispatchNumber*8,usage:GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST}),this.pendingQueries.set(t,this.pendingKernels),this.pendingKernels=[],this.commandEncoder.copyBufferToBuffer(this.queryResolveBuffer,0,t,0,2*this.pendingDispatchNumber*8)),this.device.queue.submit([this.commandEncoder.finish()]),this.gpuDataManager.refreshPendingBuffers(),this.commandEncoder=null,this.pendingDispatchNumber=0,"none"!==this.queryType&&t.mapAsync(GPUMapMode.READ).then((()=>{const e=new BigUint64Array(t.getMappedRange()),n=this.pendingQueries.get(t);for(let t=0;t<e.length/2;t++){const B=n[t],s=B.kernelId,F=this.kernels.get(s),Q=F.kernelType,U=F.kernelName,i=B.programName,a=B.inputTensorViews,l=B.outputTensorViews,c=e[2*t],g=e[2*t+1];void 0===this.queryTimeBase&&(this.queryTimeBase=c);const d=Number(c-this.queryTimeBase),I=Number(g-this.queryTimeBase);if(!Number.isSafeInteger(d)||!Number.isSafeInteger(I))throw new RangeError("incorrect timestamp range");if(this.env.webgpu.profiling?.ondata)this.env.webgpu.profiling.ondata({version:1,inputsMetadata:a.map((t=>({dims:t.dims,dataType:tensorDataTypeEnumToString(t.dataType)}))),outputsMetadata:l.map((t=>({dims:t.dims,dataType:tensorDataTypeEnumToString(t.dataType)}))),kernelId:s,kernelType:Q,kernelName:U,programName:i,startTime:d,endTime:I});else{let t="";a.forEach(((e,n)=>{t+=`input[${n}]: [${e.dims}] | ${tensorDataTypeEnumToString(e.dataType)}, `}));let e="";l.forEach(((t,n)=>{e+=`output[${n}]: [${t.dims}] | ${tensorDataTypeEnumToString(t.dataType)}, `})),console.log(`[profiling] kernel "${s}|${Q}|${U}|${i}" ${t}${e}execution time: ${I-d} ns`)}TRACE("GPU",`${i}::${c}::${g}`)}t.unmap(),this.pendingQueries.delete(t)})),TRACE_FUNC_END()}run(t,e,n,B,s){TRACE_FUNC_BEGIN(t.name);const F=[];for(let t=0;t<e.length;++t){const n=this.gpuDataManager.get(e[t].data);if(!n)throw new Error(`no GPU data for input: ${e[t].data}`);F[t]=n}const{outputs:Q,dispatchGroup:U,programUniforms:i}=t.getRunData(e),a=0===n.length?Q.map(((t,e)=>e)):n;if(a.length!==Q.length)throw new Error(`Output size ${a.length} must be equal to ${Q.length}.`);const l=[],c=[];for(let t=0;t<Q.length;++t){if(!Number.isInteger(a[t])||a[t]<-3||a[t]>=Q.length)throw new Error(`Invalid output index: ${a[t]}`);if(-3===a[t])continue;const e=-1===a[t],n=-2===a[t],F=e||n?s(Q[t].dataType,Q[t].dims):B(a[t],Q[t].dataType,Q[t].dims),U=this.gpuDataManager.get(F.data);if(!U)throw new Error(`no GPU data for output: ${F.data}`);if(e&&this.temporaryData.push(U),n){let t=this.kernelPersistentData.get(this.currentKernelId);t||(t=[],this.kernelPersistentData.set(this.currentKernelId,t)),t.push(U)}l.push(F),c.push(U)}let g;if(i){let t=0;const e=[];i.forEach((n=>{const B="number"==typeof n.data?[n.data]:n.data;if(0===B.length)return;const s=B.length<=2?4*B.length:16;t=Math.ceil(t/s)*s,e.push(t),t+=B.length>4?16*Math.ceil(B.length/4):4*B.length}));const n=16;t=Math.ceil(t/n)*n;const B=new ArrayBuffer(t);i.forEach(((t,n)=>{const s=e[n],F="number"==typeof t.data?[t.data]:t.data;"int32"===t.type?new Int32Array(B,s,F.length).set(F):"uint32"===t.type?new Uint32Array(B,s,F.length).set(F):new Float32Array(B,s,F.length).set(F)}));const s=this.gpuDataManager.create(t,GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM);this.device.queue.writeBuffer(s.buffer,0,B,0,t),this.gpuDataManager.release(s.id),g={offset:0,size:t,buffer:s.buffer}}const d=this.programManager.normalizeDispatchGroupSize(U),I=1===d[1]&&1===d[2],o=getProgramInfoUniqueKey2(t,e,I);let r=this.programManager.getArtifact(o);if(r||(r=this.programManager.build(t,d),this.programManager.setArtifact(o,r),LOG_DEBUG("info",(()=>`[artifact] key: ${o}, programName: ${t.name}`))),LOG_DEBUG("info",(()=>`[ProgramManager] run "${t.name}" (key=${o}) with ${d[0]}x${d[1]}x${d[2]}`)),"none"!==this.queryType){const t={kernelId:this.currentKernelId,programName:r.programInfo.name,inputTensorViews:e,outputTensorViews:l};this.pendingKernels.push(t)}return this.programManager.run(r,F,c,d,g),TRACE_FUNC_END(t.name),l}upload(t,e){this.gpuDataManager.upload(t,e)}memcpy(t,e){this.gpuDataManager.memcpy(t,e)}async download(t,e){await this.gpuDataManager.download(t,e)}alloc(t){return this.gpuDataManager.create(t).id}free(t){return this.gpuDataManager.release(t)}createKernel(t,e,n,B){const s=WEBGPU_OP_RESOLVE_RULES.get(t);if(!s)throw new Error(`kernel not implemented: ${t}`);const F={kernelType:t,kernelName:B,kernelEntry:s[0],attributes:[s[1],n]};this.kernels.set(e,F)}releaseKernel(t){const e=this.kernelPersistentData.get(t);if(e){for(const t of e)this.gpuDataManager.release(t.id);this.kernelPersistentData.delete(t)}this.kernelCustomData.delete(t),this.kernels.delete(t)}computeKernel(t,e,n){const B=this.kernels.get(t);if(!B)throw new Error(`kernel not created: ${t}`);const s=B.kernelType,F=B.kernelName,Q=B.kernelEntry,U=B.attributes;if(null!==this.currentKernelId)throw new Error(`kernel "[${s}] ${F}" is not allowed to be called recursively`);this.currentKernelId=t,U[0]&&(U[1]=U[0](U[1]),U[0]=void 0),LOG_DEBUG("info",(()=>`[WebGPU] Start to run kernel "[${s}] ${F}"...`));const i=this.env.debug;this.temporaryData=[];try{return i&&this.device.pushErrorScope("validation"),Q(e,U[1]),0}catch(t){return n.push(Promise.resolve(`[WebGPU] Kernel "[${s}] ${F}" failed. ${t}`)),1}finally{i&&n.push(this.device.popErrorScope().then((t=>t?`GPU validation error for kernel "[${s}] ${F}": ${t.message}`:null)));for(const t of this.temporaryData)this.gpuDataManager.release(t.id);this.temporaryData=[],this.currentKernelId=null}}registerBuffer(t,e,n,B){let s=this.sessionExternalDataMapping.get(t);s||(s=new Map,this.sessionExternalDataMapping.set(t,s));const F=s.get(e),Q=this.gpuDataManager.registerExternalBuffer(n,B,F?.[1]);return s.set(e,[Q,n]),Q}unregisterBuffers(t){const e=this.sessionExternalDataMapping.get(t);e&&(e.forEach((t=>this.gpuDataManager.unregisterExternalBuffer(t[1]))),this.sessionExternalDataMapping.delete(t))}getBuffer(t){const e=this.gpuDataManager.get(t);if(!e)throw new Error(`no GPU data for buffer: ${t}`);return e.buffer}createDownloader(t,e,n){return async()=>{const B=await downloadGpuData(this,t,e);return createView2(B.buffer,n)}}writeTimestamp(t){"inside-passes"===this.queryType&&this.computePassEncoder.writeTimestamp(this.querySet,t)}setQueryType(){this.queryType="none",("default"===this.env.webgpu.profiling?.mode||this.env.wasm.trace)&&(this.device.features.has("chromium-experimental-timestamp-query-inside-passes")?this.queryType="inside-passes":this.device.features.has("timestamp-query")&&(this.queryType="at-passes"))}}}}),init_exports={},TensorViewImpl,ComputeContextImpl,init;__export(init_exports,{init:()=>init});var init_init=__esm({"web/lib/wasm/jsep/init.ts"(){init_wasm_common(),init_backend_webgpu(),init_log(),init_util2(),TensorViewImpl=class t{constructor(t,e,n,B){this.module=t,this.dataType=e,this.data=n,this.dims=B}getFloat32Array(){if(1!==this.dataType)throw new Error("Invalid data type");const t=ShapeUtil2.size(this.dims);return 0===t?new Float32Array:new Float32Array(this.module.HEAP8.buffer,this.data,t)}getBigInt64Array(){if(7!==this.dataType)throw new Error("Invalid data type");const t=ShapeUtil2.size(this.dims);return 0===t?new BigInt64Array:new BigInt64Array(this.module.HEAP8.buffer,this.data,t)}getInt32Array(){if(6!==this.dataType)throw new Error("Invalid data type");const t=ShapeUtil2.size(this.dims);return 0===t?new Int32Array:new Int32Array(this.module.HEAP8.buffer,this.data,t)}reshape(e){if(ShapeUtil2.size(e)!==ShapeUtil2.size(this.dims))throw new Error("Invalid new shape");return new t(this.module,this.dataType,this.data,e)}},ComputeContextImpl=class{constructor(t,e,n){this.module=t,this.backend=e,this.customDataOffset=0,this.customDataSize=0;const B=t.HEAPU32;let s=n>>>2;this.opKernelContext=B[s++];const F=B[s++];this.outputCount=B[s++],this.customDataOffset=B[s++],this.customDataSize=B[s++];const Q=[];for(let e=0;e<F;e++){const e=B[s++],n=B[s++],F=B[s++],U=[];for(let t=0;t<F;t++)U.push(B[s++]);Q.push(new TensorViewImpl(t,e,n,U))}this.inputs=Q}get kernelCustomData(){return this.backend.currentKernelCustomData}get customDataBuffer(){return this.module.HEAPU8.subarray(this.customDataOffset,this.customDataOffset+this.customDataSize)}compute(t,e){const n=e?.inputs?.map((t=>"number"==typeof t?this.inputs[t]:t))??this.inputs,B=e?.outputs??[];return this.backend.run(t,n,B,((t,e,n)=>new TensorViewImpl(this.module,e,this.output(t,n),n)),((t,e)=>{const n=getTensorElementSize(t);if(!n)throw new Error(`Unsupported data type: ${t}`);const B=n*ShapeUtil2.size(e);return new TensorViewImpl(this.module,t,this.backend.gpuDataManager.create(B).id,e)}))}output(t,e){const n=this.module.stackSave();try{const n=this.module.stackAlloc(4*(1+e.length));let B=n>>2;this.module.HEAPU32[B++]=e.length;for(let t=0;t<e.length;t++)this.module.HEAPU32[B++]=e[t];return this.module._JsepOutput(this.opKernelContext,t,n)}catch(n){throw new Error(`Failed to generate kernel's output[${t}] with dims [${e}]. If you are running with pre-allocated output, please make sure the output type/dims are correct. Error: ${n}`)}finally{this.module.stackRestore(n)}}},init=async(t,e,n)=>{const B=t.jsepInit;if(!B)throw new Error("Failed to initialize JSEP. The WebAssembly module is not built with JSEP support.");const s=new WebGpuBackend;await s.initialize(e,n),B(s,(t=>s.alloc(t)),(t=>s.free(t)),((e,n,B,F=!1)=>{if(F)LOG_DEBUG("verbose",(()=>`[WebGPU] jsepCopyGpuToGpu: src=${e}, dst=${n}, size=${B}`)),s.memcpy(e,n);else{LOG_DEBUG("verbose",(()=>`[WebGPU] jsepCopyCpuToGpu: dataOffset=${e}, gpuDataId=${n}, size=${B}`));const F=t.HEAPU8.subarray(e>>>0,(e>>>0)+B);s.upload(n,F)}}),(async(e,n,B)=>{LOG_DEBUG("verbose",(()=>`[WebGPU] jsepCopyGpuToCpu: gpuDataId=${e}, dataOffset=${n}, size=${B}`)),await s.download(e,(()=>t.HEAPU8.subarray(n>>>0,(n>>>0)+B)))}),((e,n,B)=>s.createKernel(e,n,B,t.UTF8ToString(t._JsepGetNodeName(n)))),(t=>s.releaseKernel(t)),((e,n,B,F)=>{LOG_DEBUG("verbose",(()=>`[WebGPU] jsepRun: sessionHandle=${B}, kernel=${e}, contextDataOffset=${n}`));const Q=new ComputeContextImpl(t,s,n);return s.computeKernel(e,Q,F)}))}}}),initOrt,initRuntime,initEp,activeSessions,getSessionInputOutputCount,copyFromExternalBuffer,createSession,releaseSession,prepareInputOutputTensor,run,endProfiling,extractTransferableBuffers,init_wasm_core_impl=__esm({"web/lib/wasm/wasm-core-impl.ts"(){init_run_options(),init_session_options(),init_wasm_common(),init_wasm_factory(),init_wasm_utils(),init_wasm_utils_load_file(),initOrt=(t,e)=>{0!==getInstance()._OrtInit(t,e)&&checkLastError("Can't initialize onnxruntime.")},initRuntime=async t=>{initOrt(t.wasm.numThreads,logLevelStringToEnum(t.logLevel))},initEp=async(t,e)=>{if("webgpu"===e){if("undefined"==typeof navigator||!navigator.gpu)throw new Error("WebGPU is not supported in current environment");const e=await navigator.gpu.requestAdapter();if(!e)throw new Error('Failed to get GPU adapter. You may need to enable flag "--enable-unsafe-webgpu" if you are using Chrome.');if(!t.wasm.simd)throw new Error("Not supported for WebGPU=ON and SIMD=OFF. Please set `env.wasm.simd` to true when using `webgpu` EP");const n=(init_init(),__toCommonJS(init_exports)).init;await n(getInstance(),t,e)}},activeSessions=new Map,getSessionInputOutputCount=t=>{const e=getInstance(),n=e.stackSave();try{const n=e.stackAlloc(8);return 0!==e._OrtGetInputOutputCount(t,n,n+4)&&checkLastError("Can't get session input/output count."),[e.HEAP32[n/4],e.HEAP32[n/4+1]]}finally{e.stackRestore(n)}},copyFromExternalBuffer=t=>{const e=getInstance(),n=e._malloc(t.byteLength);if(0===n)throw new Error(`Can't create a session. failed to allocate a buffer of size ${t.byteLength}.`);return e.HEAPU8.set(t,n),[n,t.byteLength]},createSession=async(t,e)=>{let n,B;const s=getInstance();Array.isArray(t)?[n,B]=t:t.buffer===s.HEAPU8.buffer?[n,B]=[t.byteOffset,t.byteLength]:[n,B]=copyFromExternalBuffer(t);let F=0,Q=0,U=0,i=[];const a=[],l=[];try{if([Q,i]=setSessionOptions(e),e?.externalData&&s.mountExternalData){const t=[];for(const n of e.externalData){const e="string"==typeof n?n:n.path;t.push(loadFile("string"==typeof n?n:n.data).then((t=>{s.mountExternalData(e,t)})))}await Promise.all(t)}F=s._OrtCreateSession(n,B,Q),0===F&&checkLastError("Can't create a session.");const[t,c]=getSessionInputOutputCount(F),g=[],d=[],I=[];for(let e=0;e<t;e++){const t=s._OrtGetInputName(F,e);0===t&&checkLastError("Can't get an input name."),a.push(t),g.push(s.UTF8ToString(t))}for(let t=0;t<c;t++){const n=s._OrtGetOutputName(F,t);0===n&&checkLastError("Can't get an output name."),l.push(n);const B=s.UTF8ToString(n);d.push(B);{const t="string"==typeof e?.preferredOutputLocation?e.preferredOutputLocation:e?.preferredOutputLocation?.[B]??"cpu";if("cpu"!==t&&"cpu-pinned"!==t&&"gpu-buffer"!==t)throw new Error(`Not supported preferred output location: ${t}.`);I.push(t)}}let o=null;return I.some((t=>"gpu-buffer"===t))&&(U=s._OrtCreateBinding(F),0===U&&checkLastError("Can't create IO binding."),o={handle:U,outputPreferredLocations:I,outputPreferredLocationsEncoded:I.map((t=>dataLocationStringToEnum(t)))}),activeSessions.set(F,[F,a,l,o]),[F,g,d]}catch(t){throw a.forEach((t=>s._OrtFree(t))),l.forEach((t=>s._OrtFree(t))),0!==U&&s._OrtReleaseBinding(U),0!==F&&s._OrtReleaseSession(F),t}finally{s._free(n),0!==Q&&s._OrtReleaseSessionOptions(Q),i.forEach((t=>s._free(t))),s.unmountExternalData?.()}},releaseSession=t=>{const e=getInstance(),n=activeSessions.get(t);if(!n)throw new Error(`cannot release session. invalid session id: ${t}`);const[B,s,F,Q]=n;Q&&e._OrtReleaseBinding(Q.handle),e.jsepUnregisterBuffers?.(t),s.forEach((t=>e._OrtFree(t))),F.forEach((t=>e._OrtFree(t))),e._OrtReleaseSession(B),activeSessions.delete(t)},prepareInputOutputTensor=(t,e,n,B,s)=>{if(!t)return void e.push(0);const F=getInstance(),Q=t[0],U=t[1],i=t[3];let a,l;if("string"===Q&&"gpu-buffer"===i)throw new Error("String tensor is not supported on GPU.");if("gpu-buffer"===i){const e=t[2].gpuBuffer,n=getTensorElementSize(tensorDataTypeStringToEnum(Q));l=U.reduce(((t,e)=>t*e),1)*n,a=F.jsepRegisterBuffer(B,s,e,l)}else{const e=t[2];if(Array.isArray(e)){l=4*e.length,a=F._malloc(l),n.push(a);let t=a/4;for(let B=0;B<e.length;B++){if("string"!=typeof e[B])throw new TypeError(`tensor data at index ${B} is not a string`);F.HEAPU32[t++]=allocWasmString(e[B],n)}}else l=e.byteLength,a=F._malloc(l),n.push(a),F.HEAPU8.set(new Uint8Array(e.buffer,e.byteOffset,l),a)}const c=F.stackSave(),g=F.stackAlloc(4*U.length);try{let t=g/4;U.forEach((e=>F.HEAP32[t++]=e));const n=F._OrtCreateTensor(tensorDataTypeStringToEnum(Q),a,l,g,U.length,dataLocationStringToEnum(i));0===n&&checkLastError(`Can't create tensor for input/output. session=${B}, index=${s}.`),e.push(n)}finally{F.stackRestore(c)}},run=async(t,e,n,B,s,F)=>{const Q=getInstance(),U=activeSessions.get(t);if(!U)throw new Error(`cannot run inference. invalid session id: ${t}`);const[i,a,l,c]=U,g=e.length,d=B.length;let I=0,o=[];const r=[],u=[],b=[],C=Q.stackSave(),p=Q.stackAlloc(4*g),m=Q.stackAlloc(4*g),G=Q.stackAlloc(4*d),V=Q.stackAlloc(4*d);try{[I,o]=setRunOptions(F);for(let B=0;B<g;B++)prepareInputOutputTensor(n[B],r,b,t,e[B]);for(let e=0;e<d;e++)prepareInputOutputTensor(s[e],u,b,t,g+B[e]);let U,C=p/4,x=m/4,h=G/4,Z=V/4;for(let t=0;t<g;t++)Q.HEAPU32[C++]=r[t],Q.HEAPU32[x++]=a[e[t]];for(let t=0;t<d;t++)Q.HEAPU32[h++]=u[t],Q.HEAPU32[Z++]=l[B[t]];if(c){const{handle:n,outputPreferredLocations:F,outputPreferredLocationsEncoded:U}=c;if(a.length!==g)throw new Error(`input count from feeds (${g}) is expected to be always equal to model's input count (${a.length}).`);for(let B=0;B<g;B++){const s=e[B];0!==await Q._OrtBindInput(n,a[s],r[B])&&checkLastError(`Can't bind input[${B}] for session=${t}.`)}for(let e=0;e<d;e++){const i=B[e],a=s[e]?.[3];if(a){0!==Q._OrtBindOutput(n,l[i],u[e],0)&&checkLastError(`Can't bind pre-allocated output[${e}] for session=${t}.`)}else{0!==Q._OrtBindOutput(n,l[i],0,U[i])&&checkLastError(`Can't bind output[${e}] to ${F[e]} for session=${t}.`)}}}U=c?await Q._OrtRunWithBinding(i,c.handle,d,G,I):await Q._OrtRun(i,m,p,g,V,d,G,I),0!==U&&checkLastError("failed to call OrtRun().");const S=[];for(let t=0;t<d;t++){const e=Q.HEAPU32[G/4+t];if(e===u[t]){S.push(s[t]);continue}const n=Q.stackSave(),F=Q.stackAlloc(16);let U,i=!1,a=0;try{0!==Q._OrtGetTensorData(e,F,F+4,F+8,F+12)&&checkLastError(`Can't access output tensor data on index ${t}.`);let n=F/4;const s=Q.HEAPU32[n++];a=Q.HEAPU32[n++];const l=Q.HEAPU32[n++],g=Q.HEAPU32[n++],d=[];for(let t=0;t<g;t++)d.push(Q.HEAPU32[l/4+t]);Q._OrtFree(l);const I=d.reduce(((t,e)=>t*e),1);U=tensorDataTypeEnumToString(s);const o=c?.outputPreferredLocations[B[t]];if("string"===U){if("gpu-buffer"===o)throw new Error("String tensor is not supported on GPU.");const t=[];let e=a/4;for(let n=0;n<I;n++){const B=Q.HEAPU32[e++],s=n===I-1?void 0:Q.HEAPU32[e]-B;t.push(Q.UTF8ToString(B,s))}S.push([U,d,t,"cpu"])}else if("gpu-buffer"===o&&I>0){const t=Q.jsepGetBuffer(a),n=getTensorElementSize(s);if(void 0===n||!isGpuBufferSupportedType(U))throw new Error(`Unsupported data type: ${U}`);i=!0,S.push([U,d,{gpuBuffer:t,download:Q.jsepCreateDownloader(t,I*n,U),dispose:()=>{Q._OrtReleaseTensor(e)}},"gpu-buffer"])}else{const t=new(tensorTypeToTypedArrayConstructor(U))(I);new Uint8Array(t.buffer,t.byteOffset,t.byteLength).set(Q.HEAPU8.subarray(a,a+t.byteLength)),S.push([U,d,t,"cpu"])}}finally{Q.stackRestore(n),"string"===U&&a&&Q._free(a),i||Q._OrtReleaseTensor(e)}}return c&&Q._OrtClearBoundOutputs(c.handle),S}finally{Q.stackRestore(C),r.forEach((t=>Q._OrtReleaseTensor(t))),u.forEach((t=>Q._OrtReleaseTensor(t))),b.forEach((t=>Q._free(t))),0!==I&&Q._OrtReleaseRunOptions(I),o.forEach((t=>Q._free(t)))}},endProfiling=t=>{const e=getInstance(),n=activeSessions.get(t);if(!n)throw new Error("invalid session id");const B=n[0],s=e._OrtEndProfiling(B);0===s&&checkLastError("Can't get an profile file name."),e._OrtFree(s)},extractTransferableBuffers=t=>{const e=[];for(const n of t){const t=n[2];!Array.isArray(t)&&"buffer"in t&&e.push(t.buffer)}return e}}}),require_main=__commonJS({"proxy-worker:./proxy-worker/main"(t,e){e.exports='/*!\n * ONNX Runtime Web v1.17.1\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n"use strict";\n(() => {\n  var __defProp = Object.defineProperty;\n  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;\n  var __getOwnPropNames = Object.getOwnPropertyNames;\n  var __hasOwnProp = Object.prototype.hasOwnProperty;\n  var __esm = (fn, res) => function __init() {\n    return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;\n  };\n  var __commonJS = (cb, mod) => function __require() {\n    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;\n  };\n  var __export = (target, all) => {\n    for (var name in all)\n      __defProp(target, name, { get: all[name], enumerable: true });\n  };\n  var __copyProps = (to, from, except, desc) => {\n    if (from && typeof from === "object" || typeof from === "function") {\n      for (let key of __getOwnPropNames(from))\n        if (!__hasOwnProp.call(to, key) && key !== except)\n          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n    }\n    return to;\n  };\n  var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);\n\n  // nodejs-ignore:fs\n  var fs_exports = {};\n  __export(fs_exports, {\n    createReadStream: () => createReadStream,\n    readFile: () => readFile,\n    readFileSync: () => readFileSync\n  });\n  var readFile, readFileSync, createReadStream;\n  var init_fs = __esm({\n    "nodejs-ignore:fs"() {\n      readFile = void 0;\n      readFileSync = void 0;\n      createReadStream = void 0;\n    }\n  });\n\n  // nodejs-ignore:path\n  var path_exports = {};\n  __export(path_exports, {\n    join: () => join2\n  });\n  var join2;\n  var init_path = __esm({\n    "nodejs-ignore:path"() {\n      join2 = void 0;\n    }\n  });\n\n  // web/lib/wasm/binding/ort-wasm-simd.jsep.js\n  var require_ort_wasm_simd_jsep = __commonJS({\n    "web/lib/wasm/binding/ort-wasm-simd.jsep.js"(exports, module) {\n      "use strict";\n      var ortWasm = (() => {\n        var _scriptDir = typeof document !== "undefined" && document.currentScript ? document.currentScript.src : void 0;\n        if (typeof __filename !== "undefined")\n          _scriptDir = _scriptDir || __filename;\n        return function(moduleArg = {}) {\n          var d = moduleArg, aa, k;\n          d.ready = new Promise((a, b) => {\n            aa = a;\n            k = b;\n          });\n          "use strict";\n          d.mountExternalData = (a, b) => {\n            (d.Fa || (d.Fa = /* @__PURE__ */ new Map())).set(a, b);\n          };\n          d.unmountExternalData = () => {\n            delete d.Fa;\n          };\n          d.jsepInit = (a, b, c, e, g, h, l, t) => {\n            d.ab = a;\n            d.Qa = b;\n            d.Sa = c;\n            d.La = e;\n            d.Ra = g;\n            d.sa = h;\n            d.Ta = l;\n            d.Ua = t;\n            b = (m, n, q) => (...u) => {\n              const w = p, f = n?.();\n              u = m(...u);\n              const r = n?.();\n              f !== r && (m = r, q(f), n = q = null);\n              return p != w ? ba() : u;\n            };\n            c = (m) => async (...n) => {\n              try {\n                if (d.Ea)\n                  throw Error("Session already started");\n                const q = d.Ea = { Va: n[0], errors: [] }, u = await m(...n);\n                if (d.Ea !== q)\n                  throw Error("Session mismatch");\n                a.flush();\n                const w = q.errors;\n                if (0 < w.length) {\n                  let f = await Promise.all(w);\n                  f = f.filter((r) => r);\n                  if (0 < f.length)\n                    throw Error(f.join("\\n"));\n                }\n                return u;\n              } finally {\n                d.Ea = null;\n              }\n            };\n            d._OrtRun = c(b(d._OrtRun, () => d._OrtRun, (m) => d._OrtRun = m));\n            d._OrtRunWithBinding = c(b(d._OrtRunWithBinding, () => d._OrtRunWithBinding, (m) => d._OrtRunWithBinding = m));\n            d._OrtBindInput = b(d._OrtBindInput, () => d._OrtBindInput, (m) => d._OrtBindInput = m);\n            d.jsepRegisterBuffer = (m, n, q, u) => a.registerBuffer(m, n, q, u);\n            d.jsepUnregisterBuffers = (m) => {\n              a.unregisterBuffers(m);\n            };\n            d.jsepGetBuffer = (m) => a.getBuffer(m);\n            d.jsepCreateDownloader = (m, n, q) => a.createDownloader(m, n, q);\n          };\n          var ca = Object.assign({}, d), da = "./this.program", x = (a, b) => {\n            throw b;\n          }, ea = "object" == typeof window, y = "function" == typeof importScripts, fa = "object" == typeof process && "object" == typeof process.versions && "string" == typeof process.versions.node, z = "", A, B, C;\n          if (fa) {\n            var fs = (init_fs(), __toCommonJS(fs_exports)), D = (init_path(), __toCommonJS(path_exports));\n            z = y ? D.dirname(z) + "/" : __dirname + "/";\n            A = (a, b) => {\n              a = E(a) ? new URL(a) : D.normalize(a);\n              return fs.readFileSync(a, b ? void 0 : "utf8");\n            };\n            C = (a) => {\n              a = A(a, true);\n              a.buffer || (a = new Uint8Array(a));\n              return a;\n            };\n            B = (a, b, c, e = true) => {\n              a = E(a) ? new URL(a) : D.normalize(a);\n              fs.readFile(a, e ? void 0 : "utf8", (g, h) => {\n                g ? c(g) : b(e ? h.buffer : h);\n              });\n            };\n            !d.thisProgram && 1 < process.argv.length && (da = process.argv[1].replace(/\\\\/g, "/"));\n            process.argv.slice(2);\n            x = (a, b) => {\n              process.exitCode = a;\n              throw b;\n            };\n            d.inspect = () => "[Emscripten Module object]";\n          } else if (ea || y)\n            y ? z = self.location.href : "undefined" != typeof document && document.currentScript && (z = document.currentScript.src), _scriptDir && (z = _scriptDir), 0 !== z.indexOf("blob:") ? z = z.substr(0, z.replace(/[?#].*/, "").lastIndexOf("/") + 1) : z = "", A = (a) => {\n              var b = new XMLHttpRequest();\n              b.open("GET", a, false);\n              b.send(null);\n              return b.responseText;\n            }, y && (C = (a) => {\n              var b = new XMLHttpRequest();\n              b.open("GET", a, false);\n              b.responseType = "arraybuffer";\n              b.send(null);\n              return new Uint8Array(b.response);\n            }), B = (a, b, c) => {\n              var e = new XMLHttpRequest();\n              e.open("GET", a, true);\n              e.responseType = "arraybuffer";\n              e.onload = () => {\n                200 == e.status || 0 == e.status && e.response ? b(e.response) : c();\n              };\n              e.onerror = c;\n              e.send(null);\n            };\n          var ha = console.log.bind(console), G = console.error.bind(console);\n          Object.assign(d, ca);\n          ca = null;\n          "object" != typeof WebAssembly && H("no native wasm support detected");\n          var I, J = false, K, L, M, N, O, ia, ja;\n          function ka() {\n            var a = I.buffer;\n            d.HEAP8 = L = new Int8Array(a);\n            d.HEAP16 = new Int16Array(a);\n            d.HEAPU8 = M = new Uint8Array(a);\n            d.HEAPU16 = new Uint16Array(a);\n            d.HEAP32 = N = new Int32Array(a);\n            d.HEAPU32 = O = new Uint32Array(a);\n            d.HEAPF32 = ia = new Float32Array(a);\n            d.HEAPF64 = ja = new Float64Array(a);\n          }\n          var la = [], ma = [], na = [], P = 0, oa = null, Q = null;\n          function H(a) {\n            a = "Aborted(" + a + ")";\n            G(a);\n            J = true;\n            K = 1;\n            a = new WebAssembly.RuntimeError(a + ". Build with -sASSERTIONS for more info.");\n            k(a);\n            throw a;\n          }\n          var pa = (a) => a.startsWith("data:application/octet-stream;base64,"), E = (a) => a.startsWith("file://"), R;\n          R = "ort-wasm-simd.wasm";\n          if (!pa(R)) {\n            var qa = R;\n            R = d.locateFile ? d.locateFile(qa, z) : z + qa;\n          }\n          function ra(a) {\n            if (C)\n              return C(a);\n            throw "both async and sync fetching of the wasm failed";\n          }\n          function sa(a) {\n            if (ea || y) {\n              if ("function" == typeof fetch && !E(a))\n                return fetch(a, { credentials: "same-origin" }).then((b) => {\n                  if (!b.ok)\n                    throw "failed to load wasm binary file at \'" + a + "\'";\n                  return b.arrayBuffer();\n                }).catch(() => ra(a));\n              if (B)\n                return new Promise((b, c) => {\n                  B(a, (e) => b(new Uint8Array(e)), c);\n                });\n            }\n            return Promise.resolve().then(() => ra(a));\n          }\n          function ta(a, b, c) {\n            return sa(a).then((e) => WebAssembly.instantiate(e, b)).then((e) => e).then(c, (e) => {\n              G(`failed to asynchronously prepare wasm: ${e}`);\n              H(e);\n            });\n          }\n          function ua(a, b) {\n            var c = R;\n            return "function" != typeof WebAssembly.instantiateStreaming || pa(c) || E(c) || fa || "function" != typeof fetch ? ta(c, a, b) : fetch(c, { credentials: "same-origin" }).then((e) => WebAssembly.instantiateStreaming(e, a).then(b, function(g) {\n              G(`wasm streaming compile failed: ${g}`);\n              G("falling back to ArrayBuffer instantiation");\n              return ta(c, a, b);\n            }));\n          }\n          var S, va = {\n            931056: (a, b, c, e) => {\n              if ("undefined" == typeof d || !d.Fa)\n                return 1;\n              a = T(a >>> 0);\n              a.startsWith("./") && (a = a.substring(2));\n              a = d.Fa.get(a);\n              if (!a)\n                return 2;\n              b >>>= 0;\n              c >>>= 0;\n              if (b + c > a.byteLength)\n                return 3;\n              try {\n                return M.set(a.subarray(b, b + c), e >>> 0 >>> 0), 0;\n              } catch {\n                return 4;\n              }\n            },\n            931557: (a) => d.Qa(a),\n            931590: (a) => d.Sa(a),\n            931622: (a, b, c) => {\n              d.La(a, b, c, true);\n            },\n            931661: (a, b, c) => {\n              d.La(a, b, c);\n            },\n            931694: (a) => {\n              d.sa("Abs", a, void 0);\n            },\n            931745: (a) => {\n              d.sa("Neg", a, void 0);\n            },\n            931796: (a) => {\n              d.sa("Floor", a, void 0);\n            },\n            931849: (a) => {\n              d.sa("Ceil", a, void 0);\n            },\n            931901: (a) => {\n              d.sa("Reciprocal", a, void 0);\n            },\n            931959: (a) => {\n              d.sa("Sqrt", a, void 0);\n            },\n            932011: (a) => {\n              d.sa("Exp", a, void 0);\n            },\n            932062: (a) => {\n              d.sa("Erf", a, void 0);\n            },\n            932113: (a) => {\n              d.sa("Sigmoid", a, void 0);\n            },\n            932168: (a) => {\n              d.sa("Log", a, void 0);\n            },\n            932219: (a) => {\n              d.sa("Sin", a, void 0);\n            },\n            932270: (a) => {\n              d.sa("Cos", a, void 0);\n            },\n            932321: (a) => {\n              d.sa("Tan", a, void 0);\n            },\n            932372: (a) => {\n              d.sa("Asin", a, void 0);\n            },\n            932424: (a) => {\n              d.sa("Acos", a, void 0);\n            },\n            932476: (a) => {\n              d.sa("Atan", a, void 0);\n            },\n            932528: (a) => {\n              d.sa("Sinh", a, void 0);\n            },\n            932580: (a) => {\n              d.sa("Cosh", a, void 0);\n            },\n            932632: (a) => {\n              d.sa("Asinh", a, void 0);\n            },\n            932685: (a) => {\n              d.sa("Acosh", a, void 0);\n            },\n            932738: (a) => {\n              d.sa("Atanh", a, void 0);\n            },\n            932791: (a) => {\n              d.sa("Tanh", a, void 0);\n            },\n            932843: (a) => {\n              d.sa("Not", a, void 0);\n            },\n            932894: (a, b, c) => {\n              d.sa("Clip", a, { min: b, max: c });\n            },\n            932963: (a) => {\n              d.sa("Clip", a, void 0);\n            },\n            933015: (a, b) => {\n              d.sa("Elu", a, { alpha: b });\n            },\n            933073: (a) => {\n              d.sa("Relu", a, void 0);\n            },\n            933125: (a, b) => {\n              d.sa("LeakyRelu", a, { alpha: b });\n            },\n            933189: (a, b) => {\n              d.sa("ThresholdedRelu", a, { alpha: b });\n            },\n            933259: (a, b) => {\n              d.sa("Cast", a, { to: b });\n            },\n            933317: (a) => {\n              d.sa("Add", a, void 0);\n            },\n            933368: (a) => {\n              d.sa("Sub", a, void 0);\n            },\n            933419: (a) => {\n              d.sa("Mul", a, void 0);\n            },\n            933470: (a) => {\n              d.sa("Div", a, void 0);\n            },\n            933521: (a) => {\n              d.sa("Pow", a, void 0);\n            },\n            933572: (a) => {\n              d.sa("Equal", a, void 0);\n            },\n            933625: (a) => {\n              d.sa("Greater", a, void 0);\n            },\n            933680: (a) => {\n              d.sa("GreaterOrEqual", a, void 0);\n            },\n            933742: (a) => {\n              d.sa("Less", a, void 0);\n            },\n            933794: (a) => {\n              d.sa("LessOrEqual", a, void 0);\n            },\n            933853: (a, b, c, e, g) => {\n              d.sa("ReduceMean", a, { keepDims: !!b, noopWithEmptyAxes: !!c, axes: e ? Array.from(N.subarray(e >>> 0, g >>> 0)) : [] });\n            },\n            934012: (a, b, c, e, g) => {\n              d.sa("ReduceMax", a, { keepDims: !!b, noopWithEmptyAxes: !!c, axes: e ? Array.from(N.subarray(e >>> 0, g >>> 0)) : [] });\n            },\n            934170: (a, b, c, e, g) => {\n              d.sa("ReduceMin", a, { keepDims: !!b, noopWithEmptyAxes: !!c, axes: e ? Array.from(N.subarray(e >>> 0, g >>> 0)) : [] });\n            },\n            934328: (a, b, c, e, g) => {\n              d.sa("ReduceProd", a, { keepDims: !!b, noopWithEmptyAxes: !!c, axes: e ? Array.from(N.subarray(e >>> 0, g >>> 0)) : [] });\n            },\n            934487: (a, b, c, e, g) => {\n              d.sa("ReduceSum", a, { keepDims: !!b, noopWithEmptyAxes: !!c, axes: e ? Array.from(N.subarray(e >>> 0, g >>> 0)) : [] });\n            },\n            934645: (a, b, c, e, g) => {\n              d.sa("ReduceL1", a, { keepDims: !!b, noopWithEmptyAxes: !!c, axes: e ? Array.from(N.subarray(\n                e >>> 0,\n                g >>> 0\n              )) : [] });\n            },\n            934802: (a, b, c, e, g) => {\n              d.sa("ReduceL2", a, { keepDims: !!b, noopWithEmptyAxes: !!c, axes: e ? Array.from(N.subarray(e >>> 0, g >>> 0)) : [] });\n            },\n            934959: (a, b, c, e, g) => {\n              d.sa("ReduceLogSum", a, { keepDims: !!b, noopWithEmptyAxes: !!c, axes: e ? Array.from(N.subarray(e >>> 0, g >>> 0)) : [] });\n            },\n            935120: (a, b, c, e, g) => {\n              d.sa("ReduceSumSquare", a, { keepDims: !!b, noopWithEmptyAxes: !!c, axes: e ? Array.from(N.subarray(e >>> 0, g >>> 0)) : [] });\n            },\n            935284: (a, b, c, e, g) => {\n              d.sa("ReduceLogSumExp", a, { keepDims: !!b, noopWithEmptyAxes: !!c, axes: e ? Array.from(N.subarray(e >>> 0, g >>> 0)) : [] });\n            },\n            935448: (a) => {\n              d.sa("Where", a, void 0);\n            },\n            935501: (a, b, c) => {\n              d.sa("Transpose", a, { perm: b ? Array.from(N.subarray(b >>> 0, c >>> 0)) : [] });\n            },\n            935609: (a, b, c, e, g, h, l, t, m, n, q, u, w, f, r) => {\n              d.sa("ConvTranspose", a, { format: m ? "NHWC" : "NCHW", autoPad: b, dilations: [c], group: e, kernel_shape: [g], pads: [h, l], strides: [t], wIsConst: () => !!L[n >>> 0], outputPadding: q ? Array.from(N.subarray(q >>> 0, u >>> 0)) : [], outputShape: w ? Array.from(N.subarray(w >>> 0, f >>> 0)) : [], activation: T(r) });\n            },\n            936011: (a, b, c, e, g, h, l, t, m, n, q, u, w, f) => {\n              d.sa(\n                "ConvTranspose",\n                a,\n                { format: t ? "NHWC" : "NCHW", autoPad: b, dilations: Array.from(N.subarray(c >>> 0, (c >>> 0) + 2 >>> 0)), group: e, kernelShape: Array.from(N.subarray(g >>> 0, (g >>> 0) + 2 >>> 0)), pads: Array.from(N.subarray(h >>> 0, (h >>> 0) + 4 >>> 0)), strides: Array.from(N.subarray(l >>> 0, (l >>> 0) + 2 >>> 0)), wIsConst: () => !!L[m >>> 0], outputPadding: n ? Array.from(N.subarray(n >>> 0, q >>> 0)) : [], outputShape: u ? Array.from(N.subarray(u >>> 0, w >>> 0)) : [], activation: T(f) }\n              );\n            },\n            936576: (a, b, c, e, g, h, l, t, m, n, q, u, w, f, r) => {\n              d.sa("ConvTranspose", a, {\n                format: m ? "NHWC" : "NCHW",\n                autoPad: b,\n                dilations: [c],\n                group: e,\n                kernel_shape: [g],\n                pads: [h, l],\n                strides: [t],\n                wIsConst: () => !!L[n >>> 0],\n                outputPadding: q ? Array.from(N.subarray(q >>> 0, u >>> 0)) : [],\n                outputShape: w ? Array.from(N.subarray(w >>> 0, f >>> 0)) : [],\n                activation: T(r)\n              });\n            },\n            936978: (a, b, c, e, g, h, l, t, m, n, q, u, w, f) => {\n              d.sa("ConvTranspose", a, { format: t ? "NHWC" : "NCHW", autoPad: b, dilations: Array.from(N.subarray(c >>> 0, (c >>> 0) + 2 >>> 0)), group: e, kernelShape: Array.from(N.subarray(g >>> 0, (g >>> 0) + 2 >>> 0)), pads: Array.from(N.subarray(h >>> 0, (h >>> 0) + 4 >>> 0)), strides: Array.from(N.subarray(l >>> 0, (l >>> 0) + 2 >>> 0)), wIsConst: () => !!L[m >>> 0], outputPadding: n ? Array.from(N.subarray(n >>> 0, q >>> 0)) : [], outputShape: u ? Array.from(N.subarray(u >>> 0, w >>> 0)) : [], activation: T(f) });\n            },\n            937543: (a, b) => {\n              d.sa("GlobalAveragePool", a, { format: b ? "NHWC" : "NCHW" });\n            },\n            937634: (a, b, c, e, g, h, l, t, m, n, q, u, w, f, r, v) => {\n              d.sa("AveragePool", a, { format: v ? "NHWC" : "NCHW", auto_pad: b, ceil_mode: c, count_include_pad: e, storage_order: g, dilations: [h, l], kernel_shape: [t, m], pads: [n, q, u, w], strides: [f, r] });\n            },\n            937918: (a, b) => {\n              d.sa("GlobalAveragePool", a, { format: b ? "NHWC" : "NCHW" });\n            },\n            938009: (a, b, c, e, g, h, l, t, m, n, q, u, w, f, r, v) => {\n              d.sa("AveragePool", a, { format: v ? "NHWC" : "NCHW", auto_pad: b, ceil_mode: c, count_include_pad: e, storage_order: g, dilations: [h, l], kernel_shape: [t, m], pads: [n, q, u, w], strides: [f, r] });\n            },\n            938293: (a, b) => {\n              d.sa("GlobalMaxPool", a, { format: b ? "NHWC" : "NCHW" });\n            },\n            938380: (a, b, c, e, g, h, l, t, m, n, q, u, w, f, r, v) => {\n              d.sa("MaxPool", a, { format: v ? "NHWC" : "NCHW", auto_pad: b, ceil_mode: c, count_include_pad: e, storage_order: g, dilations: [h, l], kernel_shape: [t, m], pads: [n, q, u, w], strides: [f, r] });\n            },\n            938660: (a, b) => {\n              d.sa("GlobalMaxPool", a, { format: b ? "NHWC" : "NCHW" });\n            },\n            938747: (a, b, c, e, g, h, l, t, m, n, q, u, w, f, r, v) => {\n              d.sa("MaxPool", a, { format: v ? "NHWC" : "NCHW", auto_pad: b, ceil_mode: c, count_include_pad: e, storage_order: g, dilations: [h, l], kernel_shape: [t, m], pads: [n, q, u, w], strides: [f, r] });\n            },\n            939027: (a, b, c, e, g) => {\n              d.sa("Gemm", a, { alpha: b, beta: c, transA: e, transB: g });\n            },\n            939131: (a) => {\n              d.sa("MatMul", a, void 0);\n            },\n            939185: (a, b, c, e) => {\n              d.sa("ArgMax", a, { keepDims: !!b, selectLastIndex: !!c, axis: e });\n            },\n            939293: (a, b, c, e) => {\n              d.sa("ArgMin", a, {\n                keepDims: !!b,\n                selectLastIndex: !!c,\n                axis: e\n              });\n            },\n            939401: (a, b) => {\n              d.sa("Softmax", a, { axis: b });\n            },\n            939464: (a, b) => {\n              d.sa("Concat", a, { axis: b });\n            },\n            939524: (a, b, c, e, g) => {\n              d.sa("Split", a, { axis: b, numOutputs: c, splitSizes: e ? Array.from(N.subarray(e >>> 0, g >>> 0)) : [] });\n            },\n            939664: (a) => {\n              d.sa("Expand", a, void 0);\n            },\n            939718: (a, b) => {\n              d.sa("Gather", a, { axis: Number(b) });\n            },\n            939789: (a, b) => {\n              d.sa("GatherElements", a, { axis: Number(b) });\n            },\n            939868: (a, b, c, e, g, h, l, t, m, n, q) => {\n              d.sa("Resize", a, {\n                antialias: b,\n                axes: c ? Array.from(N.subarray(c >>> 0, e >>> 0)) : [],\n                coordinateTransformMode: T(g),\n                cubicCoeffA: h,\n                excludeOutside: l,\n                extrapolationValue: t,\n                keepAspectRatioPolicy: T(m),\n                mode: T(n),\n                nearestMode: T(q)\n              });\n            },\n            940214: (a, b, c, e, g, h, l) => {\n              d.sa("Slice", a, { starts: b ? Array.from(N.subarray(b >>> 0, c >>> 0)) : [], ends: e ? Array.from(N.subarray(e >>> 0, g >>> 0)) : [], axes: h ? Array.from(N.subarray(h >>> 0, l >>> 0)) : [] });\n            },\n            940430: (a) => {\n              d.sa("Tile", a, void 0);\n            },\n            940482: (a, b, c) => {\n              d.sa("LayerNormalization", a, { axis: Number(b), epsilon: Number(c) });\n            },\n            940589: (a, b, c) => {\n              d.sa("InstanceNormalization", a, { epsilon: b, format: c ? "NHWC" : "NCHW" });\n            },\n            940703: (a, b, c) => {\n              d.sa("InstanceNormalization", a, { epsilon: b, format: c ? "NHWC" : "NCHW" });\n            },\n            940817: (a) => {\n              d.sa("Range", a, void 0);\n            },\n            940870: (a, b) => {\n              d.sa("Einsum", a, { equation: T(b) });\n            },\n            940951: (a, b, c, e, g) => {\n              d.sa("Pad", a, { mode: b, value: c, pads: e ? Array.from(N.subarray(e >>> 0, g >>> 0)) : [] });\n            },\n            941078: (a, b, c, e, g, h) => {\n              d.sa("BatchNormalization", a, { epsilon: b, momentum: c, spatial: !!g, trainingMode: !!e, format: h ? "NHWC" : "NCHW" });\n            },\n            941247: (a, b, c, e, g, h) => {\n              d.sa("BatchNormalization", a, { epsilon: b, momentum: c, spatial: !!g, trainingMode: !!e, format: h ? "NHWC" : "NCHW" });\n            },\n            941416: (a, b, c) => {\n              d.sa("CumSum", a, { exclusive: Number(b), reverse: Number(c) });\n            },\n            941513: (a, b, c, e, g, h, l, t, m) => {\n              d.sa("Attention", a, { numHeads: b, isUnidirectional: c, maskFilterValue: e, scale: g, doRotary: h, qkvHiddenSizes: l ? Array.from(N.subarray(Number(t) >>> 0, Number(t) + l >>> 0)) : [], pastPresentShareBuffer: !!m });\n            },\n            941785: (a) => {\n              d.sa("Gelu", a, void 0);\n            },\n            941837: (a, b, c, e, g, h) => {\n              d.sa("MultiHeadAttention", a, { numHeads: b, isUnidirectional: c, maskFilterValue: e, scale: g, doRotary: h });\n            },\n            941996: (a) => {\n              d.sa("BiasAdd", a, void 0);\n            },\n            942051: (a) => {\n              d.sa("BiasSplitGelu", a, void 0);\n            },\n            942112: (a, b) => {\n              d.sa("SkipLayerNormalization", a, { epsilon: b });\n            },\n            942193: (a, b, c, e, g, h, l, t, m, n, q, u, w) => {\n              d.sa("Conv", a, { format: m ? "NHWC" : "NCHW", auto_pad: b, dilations: [c], group: e, kernel_shape: [g], pads: h ? Array.from(N.subarray(h >>> 0, l >>> 0)) : [], strides: [t], w_is_const: () => !!L[n >>> 0], activation: T(q), activation_params: u ? Array.from(ia.subarray(u >>> 0, w >>> 0)) : [] });\n            },\n            942563: (a, b, c, e, g, h, l, t, m, n, q, u, w, f, r, v) => {\n              d.sa("Conv", a, { format: u ? "NHWC" : "NCHW", auto_pad: b, dilations: [c, e], group: g, kernel_shape: [\n                h,\n                l\n              ], pads: t ? Array.from(N.subarray(t >>> 0, m >>> 0)) : [], strides: [n, q], w_is_const: () => !!L[w >>> 0], activation: T(f), activation_params: r ? Array.from(ia.subarray(r >>> 0, v >>> 0)) : [] });\n            },\n            942954: (a) => {\n              d.Ta(a);\n            },\n            942988: (a, b) => d.Ua(a, b, d.Ea.Va, d.Ea.errors)\n          };\n          function wa(a) {\n            this.name = "ExitStatus";\n            this.message = `Program terminated with exit(${a})`;\n            this.status = a;\n          }\n          function xa(a) {\n            this.Ja = a - 24;\n            this.Oa = function(b) {\n              O[this.Ja + 4 >>> 2 >>> 0] = b;\n            };\n            this.Na = function(b) {\n              O[this.Ja + 8 >>> 2 >>> 0] = b;\n            };\n            this.$a = function(b, c) {\n              this.Ma();\n              this.Oa(b);\n              this.Na(c);\n            };\n            this.Ma = function() {\n              O[this.Ja + 16 >>> 2 >>> 0] = 0;\n            };\n          }\n          var ya = 0, za = 0, Aa = "undefined" != typeof TextDecoder ? new TextDecoder("utf8") : void 0, Ba = (a, b, c) => {\n            b >>>= 0;\n            var e = b + c;\n            for (c = b; a[c] && !(c >= e); )\n              ++c;\n            if (16 < c - b && a.buffer && Aa)\n              return Aa.decode(a.subarray(b, c));\n            for (e = ""; b < c; ) {\n              var g = a[b++];\n              if (g & 128) {\n                var h = a[b++] & 63;\n                if (192 == (g & 224))\n                  e += String.fromCharCode((g & 31) << 6 | h);\n                else {\n                  var l = a[b++] & 63;\n                  g = 224 == (g & 240) ? (g & 15) << 12 | h << 6 | l : (g & 7) << 18 | h << 12 | l << 6 | a[b++] & 63;\n                  65536 > g ? e += String.fromCharCode(g) : (g -= 65536, e += String.fromCharCode(55296 | g >> 10, 56320 | g & 1023));\n                }\n              } else\n                e += String.fromCharCode(g);\n            }\n            return e;\n          }, T = (a, b) => (a >>>= 0) ? Ba(M, a, b) : "", Ca = (a) => {\n            for (var b = 0, c = 0; c < a.length; ++c) {\n              var e = a.charCodeAt(c);\n              127 >= e ? b++ : 2047 >= e ? b += 2 : 55296 <= e && 57343 >= e ? (b += 4, ++c) : b += 3;\n            }\n            return b;\n          }, Da = (a, b, c, e) => {\n            c >>>= 0;\n            if (!(0 < e))\n              return 0;\n            var g = c;\n            e = c + e - 1;\n            for (var h = 0; h < a.length; ++h) {\n              var l = a.charCodeAt(h);\n              if (55296 <= l && 57343 >= l) {\n                var t = a.charCodeAt(++h);\n                l = 65536 + ((l & 1023) << 10) | t & 1023;\n              }\n              if (127 >= l) {\n                if (c >= e)\n                  break;\n                b[c++ >>> 0] = l;\n              } else {\n                if (2047 >= l) {\n                  if (c + 1 >= e)\n                    break;\n                  b[c++ >>> 0] = 192 | l >> 6;\n                } else {\n                  if (65535 >= l) {\n                    if (c + 2 >= e)\n                      break;\n                    b[c++ >>> 0] = 224 | l >> 12;\n                  } else {\n                    if (c + 3 >= e)\n                      break;\n                    b[c++ >>> 0] = 240 | l >> 18;\n                    b[c++ >>> 0] = 128 | l >> 12 & 63;\n                  }\n                  b[c++ >>> 0] = 128 | l >> 6 & 63;\n                }\n                b[c++ >>> 0] = 128 | l & 63;\n              }\n            }\n            b[c >>> 0] = 0;\n            return c - g;\n          }, U = (a) => 0 === a % 4 && (0 !== a % 100 || 0 === a % 400), Ea = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335], Fa = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334], Ha = (a) => {\n            var b = Ca(a) + 1, c = Ga(b);\n            c && Da(a, M, c, b);\n            return c;\n          }, Ia = [], Ja = (a, b) => {\n            Ia.length = 0;\n            for (var c; c = M[a++ >>> 0]; ) {\n              var e = 105 != c;\n              e &= 112 != c;\n              b += e && b % 8 ? 4 : 0;\n              Ia.push(112 == c ? O[b >>> 2 >>> 0] : 105 == c ? N[b >>> 2 >>> 0] : ja[b >>> 3 >>> 0]);\n              b += e ? 8 : 4;\n            }\n            return Ia;\n          }, Ka = {}, Na = () => {\n            if (!Ma) {\n              var a = { USER: "web_user", LOGNAME: "web_user", PATH: "/", PWD: "/", HOME: "/home/web_user", LANG: ("object" == typeof navigator && navigator.languages && navigator.languages[0] || "C").replace("-", "_") + ".UTF-8", _: da || "./this.program" }, b;\n              for (b in Ka)\n                void 0 === Ka[b] ? delete a[b] : a[b] = Ka[b];\n              var c = [];\n              for (b in a)\n                c.push(`${b}=${a[b]}`);\n              Ma = c;\n            }\n            return Ma;\n          }, Ma, Oa = [null, [], []], Pa = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], Qa = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n          function Ra(a) {\n            var b = Array(Ca(a) + 1);\n            Da(a, b, 0, b.length);\n            return b;\n          }\n          function Sa(a, b, c, e) {\n            function g(f, r, v) {\n              for (f = "number" == typeof f ? f.toString() : f || ""; f.length < r; )\n                f = v[0] + f;\n              return f;\n            }\n            function h(f, r) {\n              return g(f, r, "0");\n            }\n            function l(f, r) {\n              function v(La) {\n                return 0 > La ? -1 : 0 < La ? 1 : 0;\n              }\n              var F;\n              0 === (F = v(f.getFullYear() - r.getFullYear())) && 0 === (F = v(f.getMonth() - r.getMonth())) && (F = v(f.getDate() - r.getDate()));\n              return F;\n            }\n            function t(f) {\n              switch (f.getDay()) {\n                case 0:\n                  return new Date(f.getFullYear() - 1, 11, 29);\n                case 1:\n                  return f;\n                case 2:\n                  return new Date(f.getFullYear(), 0, 3);\n                case 3:\n                  return new Date(\n                    f.getFullYear(),\n                    0,\n                    2\n                  );\n                case 4:\n                  return new Date(f.getFullYear(), 0, 1);\n                case 5:\n                  return new Date(f.getFullYear() - 1, 11, 31);\n                case 6:\n                  return new Date(f.getFullYear() - 1, 11, 30);\n              }\n            }\n            function m(f) {\n              var r = f.Ca;\n              for (f = new Date(new Date(f.Da + 1900, 0, 1).getTime()); 0 < r; ) {\n                var v = f.getMonth(), F = (U(f.getFullYear()) ? Pa : Qa)[v];\n                if (r > F - f.getDate())\n                  r -= F - f.getDate() + 1, f.setDate(1), 11 > v ? f.setMonth(v + 1) : (f.setMonth(0), f.setFullYear(f.getFullYear() + 1));\n                else {\n                  f.setDate(f.getDate() + r);\n                  break;\n                }\n              }\n              v = new Date(f.getFullYear() + 1, 0, 4);\n              r = t(new Date(\n                f.getFullYear(),\n                0,\n                4\n              ));\n              v = t(v);\n              return 0 >= l(r, f) ? 0 >= l(v, f) ? f.getFullYear() + 1 : f.getFullYear() : f.getFullYear() - 1;\n            }\n            a >>>= 0;\n            b >>>= 0;\n            c >>>= 0;\n            e >>>= 0;\n            var n = O[e + 40 >>> 2 >>> 0];\n            e = { Ya: N[e >>> 2 >>> 0], Xa: N[e + 4 >>> 2 >>> 0], Ga: N[e + 8 >>> 2 >>> 0], Ka: N[e + 12 >>> 2 >>> 0], Ha: N[e + 16 >>> 2 >>> 0], Da: N[e + 20 >>> 2 >>> 0], xa: N[e + 24 >>> 2 >>> 0], Ca: N[e + 28 >>> 2 >>> 0], bb: N[e + 32 >>> 2 >>> 0], Wa: N[e + 36 >>> 2 >>> 0], Za: n ? T(n) : "" };\n            c = T(c);\n            n = {\n              "%c": "%a %b %d %H:%M:%S %Y",\n              "%D": "%m/%d/%y",\n              "%F": "%Y-%m-%d",\n              "%h": "%b",\n              "%r": "%I:%M:%S %p",\n              "%R": "%H:%M",\n              "%T": "%H:%M:%S",\n              "%x": "%m/%d/%y",\n              "%X": "%H:%M:%S",\n              "%Ec": "%c",\n              "%EC": "%C",\n              "%Ex": "%m/%d/%y",\n              "%EX": "%H:%M:%S",\n              "%Ey": "%y",\n              "%EY": "%Y",\n              "%Od": "%d",\n              "%Oe": "%e",\n              "%OH": "%H",\n              "%OI": "%I",\n              "%Om": "%m",\n              "%OM": "%M",\n              "%OS": "%S",\n              "%Ou": "%u",\n              "%OU": "%U",\n              "%OV": "%V",\n              "%Ow": "%w",\n              "%OW": "%W",\n              "%Oy": "%y"\n            };\n            for (var q in n)\n              c = c.replace(new RegExp(q, "g"), n[q]);\n            var u = "Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "), w = "January February March April May June July August September October November December".split(" ");\n            n = { "%a": (f) => u[f.xa].substring(0, 3), "%A": (f) => u[f.xa], "%b": (f) => w[f.Ha].substring(0, 3), "%B": (f) => w[f.Ha], "%C": (f) => h((f.Da + 1900) / 100 | 0, 2), "%d": (f) => h(f.Ka, 2), "%e": (f) => g(f.Ka, 2, " "), "%g": (f) => m(f).toString().substring(2), "%G": (f) => m(f), "%H": (f) => h(f.Ga, 2), "%I": (f) => {\n              f = f.Ga;\n              0 == f ? f = 12 : 12 < f && (f -= 12);\n              return h(f, 2);\n            }, "%j": (f) => {\n              for (var r = 0, v = 0; v <= f.Ha - 1; r += (U(f.Da + 1900) ? Pa : Qa)[v++])\n                ;\n              return h(f.Ka + r, 3);\n            }, "%m": (f) => h(f.Ha + 1, 2), "%M": (f) => h(f.Xa, 2), "%n": () => "\\n", "%p": (f) => 0 <= f.Ga && 12 > f.Ga ? "AM" : "PM", "%S": (f) => h(f.Ya, 2), "%t": () => "\t", "%u": (f) => f.xa || 7, "%U": (f) => h(Math.floor((f.Ca + 7 - f.xa) / 7), 2), "%V": (f) => {\n              var r = Math.floor((f.Ca + 7 - (f.xa + 6) % 7) / 7);\n              2 >= (f.xa + 371 - f.Ca - 2) % 7 && r++;\n              if (r)\n                53 == r && (v = (f.xa + 371 - f.Ca) % 7, 4 == v || 3 == v && U(f.Da) || (r = 1));\n              else {\n                r = 52;\n                var v = (f.xa + 7 - f.Ca - 1) % 7;\n                (4 == v || 5 == v && U(f.Da % 400 - 1)) && r++;\n              }\n              return h(r, 2);\n            }, "%w": (f) => f.xa, "%W": (f) => h(Math.floor((f.Ca + 7 - (f.xa + 6) % 7) / 7), 2), "%y": (f) => (f.Da + 1900).toString().substring(2), "%Y": (f) => f.Da + 1900, "%z": (f) => {\n              f = f.Wa;\n              var r = 0 <= f;\n              f = Math.abs(f) / 60;\n              return (r ? "+" : "-") + String("0000" + (f / 60 * 100 + f % 60)).slice(-4);\n            }, "%Z": (f) => f.Za, "%%": () => "%" };\n            c = c.replace(/%%/g, "\\0\\0");\n            for (q in n)\n              c.includes(q) && (c = c.replace(new RegExp(q, "g"), n[q](e)));\n            c = c.replace(/\\0\\0/g, "%");\n            q = Ra(c);\n            if (q.length > b)\n              return 0;\n            L.set(q, a >>> 0);\n            return q.length - 1;\n          }\n          var V = (a) => {\n            try {\n              a();\n            } catch (b) {\n              H(b);\n            }\n          };\n          function Ta() {\n            var a = W, b = {};\n            for (let [c, e] of Object.entries(a))\n              b[c] = "function" == typeof e ? function() {\n                X.push(c);\n                try {\n                  return e.apply(null, arguments);\n                } finally {\n                  J || (X.pop(), p && 1 === Y && 0 === X.length && (Y = 0, V(Ua), "undefined" != typeof Fibers && Fibers.cb()));\n                }\n              } : e;\n            return b;\n          }\n          var Y = 0, p = null, Va = 0, X = [], Wa = {}, Xa = {}, Ya = 0, Za = null, $a = [];\n          function ba() {\n            return new Promise((a, b) => {\n              Za = { resolve: a, reject: b };\n            });\n          }\n          function ab() {\n            var a = Ga(65548), b = a + 12;\n            O[a >>> 2 >>> 0] = b;\n            O[a + 4 >>> 2 >>> 0] = b + 65536;\n            b = X[0];\n            var c = Wa[b];\n            void 0 === c && (c = Ya++, Wa[b] = c, Xa[c] = b);\n            N[a + 8 >>> 2 >>> 0] = c;\n            return a;\n          }\n          function bb(a) {\n            if (!J) {\n              if (0 === Y) {\n                var b = false, c = false;\n                a((e = 0) => {\n                  if (!J && (Va = e, b = true, c)) {\n                    Y = 2;\n                    V(() => cb(p));\n                    "undefined" != typeof Browser && Browser.Ia.Pa && Browser.Ia.resume();\n                    e = false;\n                    try {\n                      var g = (0, W[Xa[N[p + 8 >>> 2 >>> 0]]])();\n                    } catch (t) {\n                      g = t, e = true;\n                    }\n                    var h = false;\n                    if (!p) {\n                      var l = Za;\n                      l && (Za = null, (e ? l.reject : l.resolve)(g), h = true);\n                    }\n                    if (e && !h)\n                      throw g;\n                  }\n                });\n                c = true;\n                b || (Y = 1, p = ab(), "undefined" != typeof Browser && Browser.Ia.Pa && Browser.Ia.pause(), V(() => db(p)));\n              } else\n                2 === Y ? (Y = 0, V(eb), fb(p), p = null, $a.forEach((e) => {\n                  if (!J)\n                    try {\n                      e();\n                      try {\n                        K = K = e = K, d.onExit?.(e), J = true, x(e, new wa(e));\n                      } catch (g) {\n                        g instanceof wa || "unwind" == g || x(1, g);\n                      }\n                    } catch (g) {\n                      g instanceof wa || "unwind" == g || x(1, g);\n                    }\n                })) : H(`invalid state: ${Y}`);\n              return Va;\n            }\n          }\n          function gb(a) {\n            return bb((b) => {\n              a().then(b);\n            });\n          }\n          var jb = { n: function(a, b, c) {\n            return gb(async () => {\n              await d.Ra(a, b, c);\n            });\n          }, a: function(a, b, c) {\n            a >>>= 0;\n            new xa(a).$a(b >>> 0, c >>> 0);\n            ya = a;\n            za++;\n            throw ya;\n          }, g: function() {\n            return 0;\n          }, J: function() {\n          }, A: function() {\n          }, C: function() {\n          }, L: function() {\n            return 0;\n          }, H: function() {\n          }, D: function() {\n          }, G: function() {\n          }, l: function() {\n          }, B: function() {\n          }, y: function() {\n          }, I: function() {\n          }, z: function() {\n          }, m: () => 1, q: function(a, b, c) {\n            a = b + 2097152 >>> 0 < 4194305 - !!a ? (a >>> 0) + 4294967296 * b : NaN;\n            c >>>= 0;\n            a = new Date(1e3 * a);\n            N[c >>> 2 >>> 0] = a.getUTCSeconds();\n            N[c + 4 >>> 2 >>> 0] = a.getUTCMinutes();\n            N[c + 8 >>> 2 >>> 0] = a.getUTCHours();\n            N[c + 12 >>> 2 >>> 0] = a.getUTCDate();\n            N[c + 16 >>> 2 >>> 0] = a.getUTCMonth();\n            N[c + 20 >>> 2 >>> 0] = a.getUTCFullYear() - 1900;\n            N[c + 24 >>> 2 >>> 0] = a.getUTCDay();\n            N[c + 28 >>> 2 >>> 0] = (a.getTime() - Date.UTC(a.getUTCFullYear(), 0, 1, 0, 0, 0, 0)) / 864e5 | 0;\n          }, r: function(a, b, c) {\n            a = b + 2097152 >>> 0 < 4194305 - !!a ? (a >>> 0) + 4294967296 * b : NaN;\n            c >>>= 0;\n            a = new Date(1e3 * a);\n            N[c >>> 2 >>> 0] = a.getSeconds();\n            N[c + 4 >>> 2 >>> 0] = a.getMinutes();\n            N[c + 8 >>> 2 >>> 0] = a.getHours();\n            N[c + 12 >>> 2 >>> 0] = a.getDate();\n            N[c + 16 >>> 2 >>> 0] = a.getMonth();\n            N[c + 20 >>> 2 >>> 0] = a.getFullYear() - 1900;\n            N[c + 24 >>> 2 >>> 0] = a.getDay();\n            N[c + 28 >>> 2 >>> 0] = (U(a.getFullYear()) ? Ea : Fa)[a.getMonth()] + a.getDate() - 1 | 0;\n            N[c + 36 >>> 2 >>> 0] = -(60 * a.getTimezoneOffset());\n            b = new Date(a.getFullYear(), 6, 1).getTimezoneOffset();\n            var e = new Date(a.getFullYear(), 0, 1).getTimezoneOffset();\n            N[c + 32 >>> 2 >>> 0] = (b != e && a.getTimezoneOffset() == Math.min(e, b)) | 0;\n          }, s: function(a) {\n            a >>>= 0;\n            var b = new Date(N[a + 20 >>> 2 >>> 0] + 1900, N[a + 16 >>> 2 >>> 0], N[a + 12 >>> 2 >>> 0], N[a + 8 >>> 2 >>> 0], N[a + 4 >>> 2 >>> 0], N[a >>> 2 >>> 0], 0), c = N[a + 32 >>> 2 >>> 0], e = b.getTimezoneOffset(), g = new Date(b.getFullYear(), 6, 1).getTimezoneOffset(), h = new Date(b.getFullYear(), 0, 1).getTimezoneOffset(), l = Math.min(h, g);\n            0 > c ? N[a + 32 >>> 2 >>> 0] = Number(g != h && l == e) : 0 < c != (l == e) && (g = Math.max(h, g), b.setTime(b.getTime() + 6e4 * ((0 < c ? l : g) - e)));\n            N[a + 24 >>> 2 >>> 0] = b.getDay();\n            N[a + 28 >>> 2 >>> 0] = (U(b.getFullYear()) ? Ea : Fa)[b.getMonth()] + b.getDate() - 1 | 0;\n            N[a >>> 2 >>> 0] = b.getSeconds();\n            N[a + 4 >>> 2 >>> 0] = b.getMinutes();\n            N[a + 8 >>> 2 >>> 0] = b.getHours();\n            N[a + 12 >>> 2 >>> 0] = b.getDate();\n            N[a + 16 >>> 2 >>> 0] = b.getMonth();\n            N[a + 20 >>> 2 >>> 0] = b.getYear();\n            a = b.getTime();\n            isNaN(a) ? (N[hb() >>> 2 >>> 0] = 61, a = -1) : a /= 1e3;\n            return ib((S = a, 1 <= +Math.abs(S) ? 0 < S ? +Math.floor(S / 4294967296) >>> 0 : ~~+Math.ceil((S - +(~~S >>> 0)) / 4294967296) >>> 0 : 0)), a >>> 0;\n          }, o: function() {\n            return -52;\n          }, p: function() {\n          }, w: function(a, b, c) {\n            function e(m) {\n              return (m = m.toTimeString().match(/\\(([A-Za-z ]+)\\)$/)) ? m[1] : "GMT";\n            }\n            c >>>= 0;\n            var g = (/* @__PURE__ */ new Date()).getFullYear(), h = new Date(g, 0, 1), l = new Date(g, 6, 1);\n            g = h.getTimezoneOffset();\n            var t = l.getTimezoneOffset();\n            O[a >>> 0 >>> 2 >>> 0] = 60 * Math.max(g, t);\n            N[b >>> 0 >>> 2 >>> 0] = Number(g != t);\n            a = e(h);\n            b = e(l);\n            a = Ha(a);\n            b = Ha(b);\n            t < g ? (O[c >>> 2 >>> 0] = a, O[c + 4 >>> 2 >>> 0] = b) : (O[c >>> 2 >>> 0] = b, O[c + 4 >>> 2 >>> 0] = a);\n          }, e: () => {\n            H("");\n          }, b: function(a, b, c) {\n            a >>>= 0;\n            b = Ja(b >>> 0, c >>> 0);\n            return va[a].apply(null, b);\n          }, i: function(a, b, c) {\n            a >>>= 0;\n            b = Ja(b >>> 0, c >>> 0);\n            return va[a].apply(null, b);\n          }, h: () => Date.now(), x: function() {\n            return 4294901760;\n          }, c: () => performance.now(), K: function(a, b, c) {\n            b >>>= 0;\n            return M.copyWithin(a >>> 0 >>> 0, b >>> 0, b + (c >>> 0) >>> 0);\n          }, u: function(a) {\n            a >>>= 0;\n            var b = M.length;\n            if (4294901760 < a)\n              return false;\n            for (var c = 1; 4 >= c; c *= 2) {\n              var e = b * (1 + 0.2 / c);\n              e = Math.min(e, a + 100663296);\n              var g = Math;\n              e = Math.max(a, e);\n              a: {\n                g = (g.min.call(g, 4294901760, e + (65536 - e % 65536) % 65536) - I.buffer.byteLength + 65535) / 65536;\n                try {\n                  I.grow(g);\n                  ka();\n                  var h = 1;\n                  break a;\n                } catch (l) {\n                }\n                h = void 0;\n              }\n              if (h)\n                return true;\n            }\n            return false;\n          }, E: function(a, b) {\n            a >>>= 0;\n            b >>>= 0;\n            var c = 0;\n            Na().forEach((e, g) => {\n              var h = b + c;\n              g = O[a + 4 * g >>> 2 >>> 0] = h;\n              for (h = 0; h < e.length; ++h)\n                L[g++ >>> 0 >>> 0] = e.charCodeAt(h);\n              L[g >>> 0 >>> 0] = 0;\n              c += e.length + 1;\n            });\n            return 0;\n          }, F: function(a, b) {\n            a >>>= 0;\n            b >>>= 0;\n            var c = Na();\n            O[a >>> 2 >>> 0] = c.length;\n            var e = 0;\n            c.forEach((g) => e += g.length + 1);\n            O[b >>> 2 >>> 0] = e;\n            return 0;\n          }, f: () => 52, k: function() {\n            return 52;\n          }, t: function() {\n            return 70;\n          }, j: function(a, b, c, e) {\n            b >>>= 0;\n            c >>>= 0;\n            e >>>= 0;\n            for (var g = 0, h = 0; h < c; h++) {\n              var l = O[b >>> 2 >>> 0], t = O[b + 4 >>> 2 >>> 0];\n              b += 8;\n              for (var m = 0; m < t; m++) {\n                var n = M[l + m >>> 0], q = Oa[a];\n                0 === n || 10 === n ? ((1 === a ? ha : G)(Ba(q, 0)), q.length = 0) : q.push(n);\n              }\n              g += t;\n            }\n            O[e >>> 2 >>> 0] = g;\n            return 0;\n          }, v: Sa, d: function(a, b, c, e) {\n            return Sa(a >>> 0, b >>> 0, c >>> 0, e >>> 0);\n          } }, W = function() {\n            function a(c) {\n              W = c.exports;\n              W = Ta();\n              W = kb();\n              I = W.M;\n              ka();\n              ma.unshift(W.N);\n              P--;\n              0 == P && (null !== oa && (clearInterval(oa), oa = null), Q && (c = Q, Q = null, c()));\n              return W;\n            }\n            var b = { a: jb };\n            P++;\n            if (d.instantiateWasm)\n              try {\n                return d.instantiateWasm(b, a);\n              } catch (c) {\n                G(`Module.instantiateWasm callback failed with error: ${c}`), k(c);\n              }\n            ua(b, function(c) {\n              a(c.instance);\n            }).catch(k);\n            return {};\n          }();\n          d._OrtInit = (a, b) => (d._OrtInit = W.O)(a, b);\n          d._OrtGetLastError = (a, b) => (d._OrtGetLastError = W.P)(a, b);\n          d._OrtCreateSessionOptions = (a, b, c, e, g, h, l, t, m, n) => (d._OrtCreateSessionOptions = W.Q)(a, b, c, e, g, h, l, t, m, n);\n          d._OrtAppendExecutionProvider = (a, b) => (d._OrtAppendExecutionProvider = W.R)(a, b);\n          d._OrtAddFreeDimensionOverride = (a, b, c) => (d._OrtAddFreeDimensionOverride = W.S)(a, b, c);\n          d._OrtAddSessionConfigEntry = (a, b, c) => (d._OrtAddSessionConfigEntry = W.T)(a, b, c);\n          d._OrtReleaseSessionOptions = (a) => (d._OrtReleaseSessionOptions = W.U)(a);\n          d._OrtCreateSession = (a, b, c) => (d._OrtCreateSession = W.V)(a, b, c);\n          d._OrtReleaseSession = (a) => (d._OrtReleaseSession = W.W)(a);\n          d._OrtGetInputOutputCount = (a, b, c) => (d._OrtGetInputOutputCount = W.X)(a, b, c);\n          d._OrtGetInputName = (a, b) => (d._OrtGetInputName = W.Y)(a, b);\n          d._OrtGetOutputName = (a, b) => (d._OrtGetOutputName = W.Z)(a, b);\n          d._OrtFree = (a) => (d._OrtFree = W._)(a);\n          d._OrtCreateTensor = (a, b, c, e, g, h) => (d._OrtCreateTensor = W.$)(a, b, c, e, g, h);\n          d._OrtGetTensorData = (a, b, c, e, g) => (d._OrtGetTensorData = W.aa)(a, b, c, e, g);\n          d._OrtReleaseTensor = (a) => (d._OrtReleaseTensor = W.ba)(a);\n          d._OrtCreateRunOptions = (a, b, c, e) => (d._OrtCreateRunOptions = W.ca)(a, b, c, e);\n          d._OrtAddRunConfigEntry = (a, b, c) => (d._OrtAddRunConfigEntry = W.da)(a, b, c);\n          d._OrtReleaseRunOptions = (a) => (d._OrtReleaseRunOptions = W.ea)(a);\n          d._OrtCreateBinding = (a) => (d._OrtCreateBinding = W.fa)(a);\n          d._OrtBindInput = (a, b, c) => (d._OrtBindInput = W.ga)(a, b, c);\n          d._OrtBindOutput = (a, b, c, e) => (d._OrtBindOutput = W.ha)(a, b, c, e);\n          d._OrtClearBoundOutputs = (a) => (d._OrtClearBoundOutputs = W.ia)(a);\n          d._OrtReleaseBinding = (a) => (d._OrtReleaseBinding = W.ja)(a);\n          d._OrtRunWithBinding = (a, b, c, e, g) => (d._OrtRunWithBinding = W.ka)(a, b, c, e, g);\n          d._OrtRun = (a, b, c, e, g, h, l, t) => (d._OrtRun = W.la)(a, b, c, e, g, h, l, t);\n          d._OrtEndProfiling = (a) => (d._OrtEndProfiling = W.ma)(a);\n          d._JsepOutput = (a, b, c) => (d._JsepOutput = W.na)(a, b, c);\n          d._JsepGetNodeName = (a) => (d._JsepGetNodeName = W.oa)(a);\n          var hb = () => (hb = W.pa)(), Ga = d._malloc = (a) => (Ga = d._malloc = W.qa)(a), fb = d._free = (a) => (fb = d._free = W.ra)(a), ib = (a) => (ib = W.ta)(a), lb = () => (lb = W.ua)(), mb = (a) => (mb = W.va)(a), nb = (a) => (nb = W.wa)(a), db = (a) => (db = W.ya)(a), Ua = () => (Ua = W.za)(), cb = (a) => (cb = W.Aa)(a), eb = () => (eb = W.Ba)();\n          d.___start_em_js = 943100;\n          d.___stop_em_js = 943261;\n          function kb() {\n            var a = W;\n            a = Object.assign({}, a);\n            var b = (e) => () => e() >>> 0, c = (e) => (g) => e(g) >>> 0;\n            a.pa = b(a.pa);\n            a.qa = c(a.qa);\n            a.ua = b(a.ua);\n            a.wa = c(a.wa);\n            return a;\n          }\n          d.stackAlloc = nb;\n          d.stackSave = lb;\n          d.stackRestore = mb;\n          d.UTF8ToString = T;\n          d.stringToUTF8 = (a, b, c) => Da(a, M, b, c);\n          d.lengthBytesUTF8 = Ca;\n          var Z;\n          Q = function ob() {\n            Z || pb();\n            Z || (Q = ob);\n          };\n          function pb() {\n            if (!(0 < P)) {\n              if (d.preRun)\n                for ("function" == typeof d.preRun && (d.preRun = [d.preRun]); d.preRun.length; ) {\n                  var a = d.preRun.shift();\n                  la.unshift(a);\n                }\n              for (; 0 < la.length; )\n                la.shift()(d);\n              if (!(0 < P || Z || (Z = true, d.calledRun = true, J))) {\n                for (; 0 < ma.length; )\n                  ma.shift()(d);\n                for (aa(d); 0 < na.length; )\n                  na.shift()(d);\n              }\n            }\n          }\n          pb();\n          return moduleArg.ready;\n        };\n      })();\n      if (typeof exports === "object" && typeof module === "object")\n        module.exports = ortWasm;\n      else if (typeof define === "function" && define["amd"])\n        define([], () => ortWasm);\n    }\n  });\n\n  // nodejs-ignore:worker_threads\n  var require_worker_threads = __commonJS({\n    "nodejs-ignore:worker_threads"() {\n    }\n  });\n\n  // nodejs-ignore:perf_hooks\n  var require_perf_hooks = __commonJS({\n    "nodejs-ignore:perf_hooks"() {\n    }\n  });\n\n  // nodejs-ignore:os\n  var os_exports = {};\n  __export(os_exports, {\n    cpus: () => cpus\n  });\n  var cpus;\n  var init_os = __esm({\n    "nodejs-ignore:os"() {\n      cpus = void 0;\n    }\n  });\n\n  // web/lib/wasm/binding/ort-wasm-simd-threaded.jsep.js\n  var require_ort_wasm_simd_threaded_jsep = __commonJS({\n    "web/lib/wasm/binding/ort-wasm-simd-threaded.jsep.js"(exports, module) {\n      "use strict";\n      var ortWasmThreaded = (() => {\n        var _scriptDir = typeof document !== "undefined" && document.currentScript ? document.currentScript.src : void 0;\n        if (typeof __filename !== "undefined")\n          _scriptDir = _scriptDir || __filename;\n        return function(moduleArg = {}) {\n          function d() {\n            l.buffer != m.buffer && u();\n            return m;\n          }\n          function v() {\n            l.buffer != m.buffer && u();\n            return aa;\n          }\n          function z() {\n            l.buffer != m.buffer && u();\n            return ba;\n          }\n          function A() {\n            l.buffer != m.buffer && u();\n            return ca;\n          }\n          function da() {\n            l.buffer != m.buffer && u();\n            return ea;\n          }\n          function fa() {\n            l.buffer != m.buffer && u();\n            return ha;\n          }\n          var B = moduleArg, ia, C;\n          B.ready = new Promise((a, b) => {\n            ia = a;\n            C = b;\n          });\n          "use strict";\n          B.mountExternalData = (a, b) => {\n            (B.cb || (B.cb = /* @__PURE__ */ new Map())).set(a, b);\n          };\n          B.unmountExternalData = () => {\n            delete B.cb;\n          };\n          B.jsepInit = (a, b, c, e, f, h, k, q) => {\n            B.Mb = a;\n            B.wb = b;\n            B.yb = c;\n            B.kb = e;\n            B.xb = f;\n            B.Ea = h;\n            B.zb = k;\n            B.Ab = q;\n            b = (n, p, r) => (...w) => {\n              const y = D, g = p?.();\n              w = n(...w);\n              const t = p?.();\n              g !== t && (n = t, r(g), p = r = null);\n              return D != y ? ja() : w;\n            };\n            c = (n) => async (...p) => {\n              try {\n                if (B.bb)\n                  throw Error("Session already started");\n                const r = B.bb = { Cb: p[0], errors: [] }, w = await n(...p);\n                if (B.bb !== r)\n                  throw Error("Session mismatch");\n                a.flush();\n                const y = r.errors;\n                if (0 < y.length) {\n                  let g = await Promise.all(y);\n                  g = g.filter((t) => t);\n                  if (0 < g.length)\n                    throw Error(g.join("\\n"));\n                }\n                return w;\n              } finally {\n                B.bb = null;\n              }\n            };\n            B._OrtRun = c(b(B._OrtRun, () => B._OrtRun, (n) => B._OrtRun = n));\n            B._OrtRunWithBinding = c(b(B._OrtRunWithBinding, () => B._OrtRunWithBinding, (n) => B._OrtRunWithBinding = n));\n            B._OrtBindInput = b(B._OrtBindInput, () => B._OrtBindInput, (n) => B._OrtBindInput = n);\n            B.jsepRegisterBuffer = (n, p, r, w) => a.registerBuffer(n, p, r, w);\n            B.jsepUnregisterBuffers = (n) => {\n              a.unregisterBuffers(n);\n            };\n            B.jsepGetBuffer = (n) => a.getBuffer(n);\n            B.jsepCreateDownloader = (n, p, r) => a.createDownloader(n, p, r);\n          };\n          var ka = Object.assign({}, B), la = "./this.program", ma = (a, b) => {\n            throw b;\n          }, na = "object" == typeof window, E = "function" == typeof importScripts, F = "object" == typeof process && "object" == typeof process.versions && "string" == typeof process.versions.node, G = B.ENVIRONMENT_IS_PTHREAD || false, H = "";\n          function oa(a) {\n            return B.locateFile ? B.locateFile(a, H) : H + a;\n          }\n          var pa, I, J;\n          if (F) {\n            var fs = (init_fs(), __toCommonJS(fs_exports)), qa = (init_path(), __toCommonJS(path_exports));\n            H = E ? qa.dirname(H) + "/" : __dirname + "/";\n            pa = (b, c) => {\n              b = ra(b) ? new URL(b) : qa.normalize(b);\n              return fs.readFileSync(b, c ? void 0 : "utf8");\n            };\n            J = (b) => {\n              b = pa(b, true);\n              b.buffer || (b = new Uint8Array(b));\n              return b;\n            };\n            I = (b, c, e, f = true) => {\n              b = ra(b) ? new URL(b) : qa.normalize(b);\n              fs.readFile(b, f ? void 0 : "utf8", (h, k) => {\n                h ? e(h) : c(f ? k.buffer : k);\n              });\n            };\n            !B.thisProgram && 1 < process.argv.length && (la = process.argv[1].replace(/\\\\/g, "/"));\n            process.argv.slice(2);\n            ma = (b, c) => {\n              process.exitCode = b;\n              throw c;\n            };\n            B.inspect = () => "[Emscripten Module object]";\n            let a;\n            try {\n              a = require_worker_threads();\n            } catch (b) {\n              throw console.error(\'The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?\'), b;\n            }\n            global.Worker = a.Worker;\n          } else if (na || E)\n            E ? H = self.location.href : "undefined" != typeof document && document.currentScript && (H = document.currentScript.src), typeof _scriptDir !== "undefined" && _scriptDir && (H = _scriptDir), 0 !== H.indexOf("blob:") ? H = H.substr(0, H.replace(/[?#].*/, "").lastIndexOf("/") + 1) : H = "", F || (pa = (a) => {\n              var b = new XMLHttpRequest();\n              b.open(\n                "GET",\n                a,\n                false\n              );\n              b.send(null);\n              return b.responseText;\n            }, E && (J = (a) => {\n              var b = new XMLHttpRequest();\n              b.open("GET", a, false);\n              b.responseType = "arraybuffer";\n              b.send(null);\n              return new Uint8Array(b.response);\n            }), I = (a, b, c) => {\n              var e = new XMLHttpRequest();\n              e.open("GET", a, true);\n              e.responseType = "arraybuffer";\n              e.onload = () => {\n                200 == e.status || 0 == e.status && e.response ? b(e.response) : c();\n              };\n              e.onerror = c;\n              e.send(null);\n            });\n          F && "undefined" == typeof performance && (global.performance = require_perf_hooks().performance);\n          var sa = console.log.bind(console), ta = console.error.bind(console);\n          F && (sa = (...a) => fs.writeSync(1, a.join(" ") + "\\n"), ta = (...a) => fs.writeSync(2, a.join(" ") + "\\n"));\n          var ua = sa, K = ta;\n          Object.assign(B, ka);\n          ka = null;\n          "object" != typeof WebAssembly && L("no native wasm support detected");\n          var l, va, M = false, O, m, aa, ba, ca, ea, ha;\n          function u() {\n            var a = l.buffer;\n            B.HEAP8 = m = new Int8Array(a);\n            B.HEAP16 = new Int16Array(a);\n            B.HEAPU8 = aa = new Uint8Array(a);\n            B.HEAPU16 = new Uint16Array(a);\n            B.HEAP32 = ba = new Int32Array(a);\n            B.HEAPU32 = ca = new Uint32Array(a);\n            B.HEAPF32 = ea = new Float32Array(a);\n            B.HEAPF64 = ha = new Float64Array(a);\n          }\n          var wa = 16777216;\n          if (G)\n            l = B.wasmMemory;\n          else if (B.wasmMemory)\n            l = B.wasmMemory;\n          else if (l = new WebAssembly.Memory({ initial: wa / 65536, maximum: 65536, shared: true }), !(l.buffer instanceof SharedArrayBuffer))\n            throw K("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"), F && K("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and/or recent version)"), Error("bad memory");\n          u();\n          wa = l.buffer.byteLength;\n          var xa = [], ya = [], za = [], P = 0, Aa = null, Q = null;\n          function Ba() {\n            P--;\n            if (0 == P && (null !== Aa && (clearInterval(Aa), Aa = null), Q)) {\n              var a = Q;\n              Q = null;\n              a();\n            }\n          }\n          function L(a) {\n            a = "Aborted(" + a + ")";\n            K(a);\n            M = true;\n            O = 1;\n            a = new WebAssembly.RuntimeError(a + ". Build with -sASSERTIONS for more info.");\n            C(a);\n            throw a;\n          }\n          var Ca = (a) => a.startsWith("data:application/octet-stream;base64,"), ra = (a) => a.startsWith("file://"), R;\n          R = "ort-wasm-simd-threaded.wasm";\n          Ca(R) || (R = oa(R));\n          function Da(a) {\n            if (J)\n              return J(a);\n            throw "both async and sync fetching of the wasm failed";\n          }\n          function Ea(a) {\n            if (na || E) {\n              if ("function" == typeof fetch && !ra(a))\n                return fetch(a, { credentials: "same-origin" }).then((b) => {\n                  if (!b.ok)\n                    throw "failed to load wasm binary file at \'" + a + "\'";\n                  return b.arrayBuffer();\n                }).catch(() => Da(a));\n              if (I)\n                return new Promise((b, c) => {\n                  I(a, (e) => b(new Uint8Array(e)), c);\n                });\n            }\n            return Promise.resolve().then(() => Da(a));\n          }\n          function Fa(a, b, c) {\n            return Ea(a).then((e) => WebAssembly.instantiate(e, b)).then((e) => e).then(c, (e) => {\n              K(`failed to asynchronously prepare wasm: ${e}`);\n              L(e);\n            });\n          }\n          function Ga(a, b) {\n            var c = R;\n            return "function" != typeof WebAssembly.instantiateStreaming || Ca(c) || ra(c) || F || "function" != typeof fetch ? Fa(c, a, b) : fetch(c, { credentials: "same-origin" }).then((e) => WebAssembly.instantiateStreaming(e, a).then(b, function(f) {\n              K(`wasm streaming compile failed: ${f}`);\n              K("falling back to ArrayBuffer instantiation");\n              return Fa(c, a, b);\n            }));\n          }\n          var S, Ha = {\n            932428: (a, b, c, e) => {\n              if ("undefined" == typeof B || !B.cb)\n                return 1;\n              a = T(a >>> 0);\n              a.startsWith("./") && (a = a.substring(2));\n              a = B.cb.get(a);\n              if (!a)\n                return 2;\n              b >>>= 0;\n              c >>>= 0;\n              e >>>= 0;\n              if (b + c > a.byteLength)\n                return 3;\n              try {\n                return v().set(a.subarray(b, b + c), e >>> 0), 0;\n              } catch {\n                return 4;\n              }\n            },\n            932929: (a) => B.wb(a),\n            932962: (a) => B.yb(a),\n            932994: (a, b, c) => {\n              B.kb(a, b, c, true);\n            },\n            933033: (a, b, c) => {\n              B.kb(a, b, c);\n            },\n            933066: (a) => {\n              B.Ea("Abs", a, void 0);\n            },\n            933117: (a) => {\n              B.Ea("Neg", a, void 0);\n            },\n            933168: (a) => {\n              B.Ea("Floor", a, void 0);\n            },\n            933221: (a) => {\n              B.Ea("Ceil", a, void 0);\n            },\n            933273: (a) => {\n              B.Ea("Reciprocal", a, void 0);\n            },\n            933331: (a) => {\n              B.Ea("Sqrt", a, void 0);\n            },\n            933383: (a) => {\n              B.Ea("Exp", a, void 0);\n            },\n            933434: (a) => {\n              B.Ea("Erf", a, void 0);\n            },\n            933485: (a) => {\n              B.Ea("Sigmoid", a, void 0);\n            },\n            933540: (a) => {\n              B.Ea("Log", a, void 0);\n            },\n            933591: (a) => {\n              B.Ea("Sin", a, void 0);\n            },\n            933642: (a) => {\n              B.Ea("Cos", a, void 0);\n            },\n            933693: (a) => {\n              B.Ea("Tan", a, void 0);\n            },\n            933744: (a) => {\n              B.Ea("Asin", a, void 0);\n            },\n            933796: (a) => {\n              B.Ea("Acos", a, void 0);\n            },\n            933848: (a) => {\n              B.Ea("Atan", a, void 0);\n            },\n            933900: (a) => {\n              B.Ea("Sinh", a, void 0);\n            },\n            933952: (a) => {\n              B.Ea("Cosh", a, void 0);\n            },\n            934004: (a) => {\n              B.Ea("Asinh", a, void 0);\n            },\n            934057: (a) => {\n              B.Ea("Acosh", a, void 0);\n            },\n            934110: (a) => {\n              B.Ea("Atanh", a, void 0);\n            },\n            934163: (a) => {\n              B.Ea("Tanh", a, void 0);\n            },\n            934215: (a) => {\n              B.Ea("Not", a, void 0);\n            },\n            934266: (a, b, c) => {\n              B.Ea("Clip", a, { min: b, max: c });\n            },\n            934335: (a) => {\n              B.Ea("Clip", a, void 0);\n            },\n            934387: (a, b) => {\n              B.Ea("Elu", a, { alpha: b });\n            },\n            934445: (a) => {\n              B.Ea("Relu", a, void 0);\n            },\n            934497: (a, b) => {\n              B.Ea("LeakyRelu", a, { alpha: b });\n            },\n            934561: (a, b) => {\n              B.Ea("ThresholdedRelu", a, { alpha: b });\n            },\n            934631: (a, b) => {\n              B.Ea("Cast", a, { to: b });\n            },\n            934689: (a) => {\n              B.Ea("Add", a, void 0);\n            },\n            934740: (a) => {\n              B.Ea("Sub", a, void 0);\n            },\n            934791: (a) => {\n              B.Ea("Mul", a, void 0);\n            },\n            934842: (a) => {\n              B.Ea("Div", a, void 0);\n            },\n            934893: (a) => {\n              B.Ea("Pow", a, void 0);\n            },\n            934944: (a) => {\n              B.Ea("Equal", a, void 0);\n            },\n            934997: (a) => {\n              B.Ea("Greater", a, void 0);\n            },\n            935052: (a) => {\n              B.Ea("GreaterOrEqual", a, void 0);\n            },\n            935114: (a) => {\n              B.Ea("Less", a, void 0);\n            },\n            935166: (a) => {\n              B.Ea("LessOrEqual", a, void 0);\n            },\n            935225: (a, b, c, e, f) => {\n              B.Ea("ReduceMean", a, { keepDims: !!b, noopWithEmptyAxes: !!c, axes: e ? Array.from(z().subarray(e >>> 0, f >>> 0)) : [] });\n            },\n            935384: (a, b, c, e, f) => {\n              B.Ea("ReduceMax", a, { keepDims: !!b, noopWithEmptyAxes: !!c, axes: e ? Array.from(z().subarray(e >>> 0, f >>> 0)) : [] });\n            },\n            935542: (a, b, c, e, f) => {\n              B.Ea("ReduceMin", a, { keepDims: !!b, noopWithEmptyAxes: !!c, axes: e ? Array.from(z().subarray(e >>> 0, f >>> 0)) : [] });\n            },\n            935700: (a, b, c, e, f) => {\n              B.Ea("ReduceProd", a, { keepDims: !!b, noopWithEmptyAxes: !!c, axes: e ? Array.from(z().subarray(e >>> 0, f >>> 0)) : [] });\n            },\n            935859: (a, b, c, e, f) => {\n              B.Ea("ReduceSum", a, { keepDims: !!b, noopWithEmptyAxes: !!c, axes: e ? Array.from(z().subarray(e >>> 0, f >>> 0)) : [] });\n            },\n            936017: (a, b, c, e, f) => {\n              B.Ea("ReduceL1", a, { keepDims: !!b, noopWithEmptyAxes: !!c, axes: e ? Array.from(z().subarray(e >>> 0, f >>> 0)) : [] });\n            },\n            936174: (a, b, c, e, f) => {\n              B.Ea("ReduceL2", a, { keepDims: !!b, noopWithEmptyAxes: !!c, axes: e ? Array.from(z().subarray(e >>> 0, f >>> 0)) : [] });\n            },\n            936331: (a, b, c, e, f) => {\n              B.Ea("ReduceLogSum", a, { keepDims: !!b, noopWithEmptyAxes: !!c, axes: e ? Array.from(z().subarray(e >>> 0, f >>> 0)) : [] });\n            },\n            936492: (a, b, c, e, f) => {\n              B.Ea("ReduceSumSquare", a, { keepDims: !!b, noopWithEmptyAxes: !!c, axes: e ? Array.from(z().subarray(e >>> 0, f >>> 0)) : [] });\n            },\n            936656: (a, b, c, e, f) => {\n              B.Ea("ReduceLogSumExp", a, { keepDims: !!b, noopWithEmptyAxes: !!c, axes: e ? Array.from(z().subarray(e >>> 0, f >>> 0)) : [] });\n            },\n            936820: (a) => {\n              B.Ea("Where", a, void 0);\n            },\n            936873: (a, b, c) => {\n              B.Ea("Transpose", a, { perm: b ? Array.from(z().subarray(b >>> 0, c >>> 0)) : [] });\n            },\n            936981: (a, b, c, e, f, h, k, q, n, p, r, w, y, g, t) => {\n              B.Ea("ConvTranspose", a, { format: n ? "NHWC" : "NCHW", autoPad: b, dilations: [c], group: e, kernel_shape: [f], pads: [h, k], strides: [q], wIsConst: () => !!d()[p >>> 0], outputPadding: r ? Array.from(z().subarray(r >>> 0, w >>> 0)) : [], outputShape: y ? Array.from(z().subarray(y >>> 0, g >>> 0)) : [], activation: T(t) });\n            },\n            937383: (a, b, c, e, f, h, k, q, n, p, r, w, y, g) => {\n              B.Ea(\n                "ConvTranspose",\n                a,\n                { format: q ? "NHWC" : "NCHW", autoPad: b, dilations: Array.from(z().subarray(c >>> 0, (c >>> 0) + 2 >>> 0)), group: e, kernelShape: Array.from(z().subarray(f >>> 0, (f >>> 0) + 2 >>> 0)), pads: Array.from(z().subarray(h >>> 0, (h >>> 0) + 4 >>> 0)), strides: Array.from(z().subarray(k >>> 0, (k >>> 0) + 2 >>> 0)), wIsConst: () => !!d()[n >>> 0], outputPadding: p ? Array.from(z().subarray(p >>> 0, r >>> 0)) : [], outputShape: w ? Array.from(z().subarray(w >>> 0, y >>> 0)) : [], activation: T(g) }\n              );\n            },\n            937948: (a, b, c, e, f, h, k, q, n, p, r, w, y, g, t) => {\n              B.Ea("ConvTranspose", a, { format: n ? "NHWC" : "NCHW", autoPad: b, dilations: [c], group: e, kernel_shape: [f], pads: [h, k], strides: [q], wIsConst: () => !!d()[p >>> 0], outputPadding: r ? Array.from(z().subarray(r >>> 0, w >>> 0)) : [], outputShape: y ? Array.from(z().subarray(y >>> 0, g >>> 0)) : [], activation: T(t) });\n            },\n            938350: (a, b, c, e, f, h, k, q, n, p, r, w, y, g) => {\n              B.Ea("ConvTranspose", a, { format: q ? "NHWC" : "NCHW", autoPad: b, dilations: Array.from(z().subarray(c >>> 0, (c >>> 0) + 2 >>> 0)), group: e, kernelShape: Array.from(z().subarray(f >>> 0, (f >>> 0) + 2 >>> 0)), pads: Array.from(z().subarray(h >>> 0, (h >>> 0) + 4 >>> 0)), strides: Array.from(z().subarray(k >>> 0, (k >>> 0) + 2 >>> 0)), wIsConst: () => !!d()[n >>> 0], outputPadding: p ? Array.from(z().subarray(p >>> 0, r >>> 0)) : [], outputShape: w ? Array.from(z().subarray(w >>> 0, y >>> 0)) : [], activation: T(g) });\n            },\n            938915: (a, b) => {\n              B.Ea("GlobalAveragePool", a, { format: b ? "NHWC" : "NCHW" });\n            },\n            939006: (a, b, c, e, f, h, k, q, n, p, r, w, y, g, t, x) => {\n              B.Ea("AveragePool", a, { format: x ? "NHWC" : "NCHW", auto_pad: b, ceil_mode: c, count_include_pad: e, storage_order: f, dilations: [h, k], kernel_shape: [q, n], pads: [p, r, w, y], strides: [g, t] });\n            },\n            939290: (a, b) => {\n              B.Ea("GlobalAveragePool", a, { format: b ? "NHWC" : "NCHW" });\n            },\n            939381: (a, b, c, e, f, h, k, q, n, p, r, w, y, g, t, x) => {\n              B.Ea("AveragePool", a, { format: x ? "NHWC" : "NCHW", auto_pad: b, ceil_mode: c, count_include_pad: e, storage_order: f, dilations: [h, k], kernel_shape: [q, n], pads: [p, r, w, y], strides: [g, t] });\n            },\n            939665: (a, b) => {\n              B.Ea("GlobalMaxPool", a, { format: b ? "NHWC" : "NCHW" });\n            },\n            939752: (a, b, c, e, f, h, k, q, n, p, r, w, y, g, t, x) => {\n              B.Ea("MaxPool", a, { format: x ? "NHWC" : "NCHW", auto_pad: b, ceil_mode: c, count_include_pad: e, storage_order: f, dilations: [h, k], kernel_shape: [\n                q,\n                n\n              ], pads: [p, r, w, y], strides: [g, t] });\n            },\n            940032: (a, b) => {\n              B.Ea("GlobalMaxPool", a, { format: b ? "NHWC" : "NCHW" });\n            },\n            940119: (a, b, c, e, f, h, k, q, n, p, r, w, y, g, t, x) => {\n              B.Ea("MaxPool", a, { format: x ? "NHWC" : "NCHW", auto_pad: b, ceil_mode: c, count_include_pad: e, storage_order: f, dilations: [h, k], kernel_shape: [q, n], pads: [p, r, w, y], strides: [g, t] });\n            },\n            940399: (a, b, c, e, f) => {\n              B.Ea("Gemm", a, { alpha: b, beta: c, transA: e, transB: f });\n            },\n            940503: (a) => {\n              B.Ea("MatMul", a, void 0);\n            },\n            940557: (a, b, c, e) => {\n              B.Ea("ArgMax", a, { keepDims: !!b, selectLastIndex: !!c, axis: e });\n            },\n            940665: (a, b, c, e) => {\n              B.Ea("ArgMin", a, { keepDims: !!b, selectLastIndex: !!c, axis: e });\n            },\n            940773: (a, b) => {\n              B.Ea("Softmax", a, { axis: b });\n            },\n            940836: (a, b) => {\n              B.Ea("Concat", a, { axis: b });\n            },\n            940896: (a, b, c, e, f) => {\n              B.Ea("Split", a, { axis: b, numOutputs: c, splitSizes: e ? Array.from(z().subarray(e >>> 0, f >>> 0)) : [] });\n            },\n            941036: (a) => {\n              B.Ea("Expand", a, void 0);\n            },\n            941090: (a, b) => {\n              B.Ea("Gather", a, { axis: Number(b) });\n            },\n            941161: (a, b) => {\n              B.Ea("GatherElements", a, { axis: Number(b) });\n            },\n            941240: (a, b, c, e, f, h, k, q, n, p, r) => {\n              B.Ea("Resize", a, { antialias: b, axes: c ? Array.from(z().subarray(c >>> 0, e >>> 0)) : [], coordinateTransformMode: T(f), cubicCoeffA: h, excludeOutside: k, extrapolationValue: q, keepAspectRatioPolicy: T(n), mode: T(p), nearestMode: T(r) });\n            },\n            941586: (a, b, c, e, f, h, k) => {\n              B.Ea("Slice", a, { starts: b ? Array.from(z().subarray(b >>> 0, c >>> 0)) : [], ends: e ? Array.from(z().subarray(e >>> 0, f >>> 0)) : [], axes: h ? Array.from(z().subarray(h >>> 0, k >>> 0)) : [] });\n            },\n            941802: (a) => {\n              B.Ea("Tile", a, void 0);\n            },\n            941854: (a, b, c) => {\n              B.Ea("LayerNormalization", a, { axis: Number(b), epsilon: Number(c) });\n            },\n            941961: (a, b, c) => {\n              B.Ea(\n                "InstanceNormalization",\n                a,\n                { epsilon: b, format: c ? "NHWC" : "NCHW" }\n              );\n            },\n            942075: (a, b, c) => {\n              B.Ea("InstanceNormalization", a, { epsilon: b, format: c ? "NHWC" : "NCHW" });\n            },\n            942189: (a) => {\n              B.Ea("Range", a, void 0);\n            },\n            942242: (a, b) => {\n              B.Ea("Einsum", a, { equation: T(b) });\n            },\n            942323: (a, b, c, e, f) => {\n              B.Ea("Pad", a, { mode: b, value: c, pads: e ? Array.from(z().subarray(e >>> 0, f >>> 0)) : [] });\n            },\n            942450: (a, b, c, e, f, h) => {\n              B.Ea("BatchNormalization", a, { epsilon: b, momentum: c, spatial: !!f, trainingMode: !!e, format: h ? "NHWC" : "NCHW" });\n            },\n            942619: (a, b, c, e, f, h) => {\n              B.Ea("BatchNormalization", a, {\n                epsilon: b,\n                momentum: c,\n                spatial: !!f,\n                trainingMode: !!e,\n                format: h ? "NHWC" : "NCHW"\n              });\n            },\n            942788: (a, b, c) => {\n              B.Ea("CumSum", a, { exclusive: Number(b), reverse: Number(c) });\n            },\n            942885: (a, b, c, e, f, h, k, q, n) => {\n              B.Ea("Attention", a, { numHeads: b, isUnidirectional: c, maskFilterValue: e, scale: f, doRotary: h, qkvHiddenSizes: k ? Array.from(z().subarray(Number(q) >>> 0, Number(q) + k >>> 0)) : [], pastPresentShareBuffer: !!n });\n            },\n            943157: (a) => {\n              B.Ea("Gelu", a, void 0);\n            },\n            943209: (a, b, c, e, f, h) => {\n              B.Ea("MultiHeadAttention", a, { numHeads: b, isUnidirectional: c, maskFilterValue: e, scale: f, doRotary: h });\n            },\n            943368: (a) => {\n              B.Ea("BiasAdd", a, void 0);\n            },\n            943423: (a) => {\n              B.Ea("BiasSplitGelu", a, void 0);\n            },\n            943484: (a, b) => {\n              B.Ea("SkipLayerNormalization", a, { epsilon: b });\n            },\n            943565: (a, b, c, e, f, h, k, q, n, p, r, w, y) => {\n              B.Ea("Conv", a, { format: n ? "NHWC" : "NCHW", auto_pad: b, dilations: [c], group: e, kernel_shape: [f], pads: h ? Array.from(z().subarray(h >>> 0, k >>> 0)) : [], strides: [q], w_is_const: () => !!d()[p >>> 0], activation: T(r), activation_params: w ? Array.from(da().subarray(w >>> 0, y >>> 0)) : [] });\n            },\n            943935: (a, b, c, e, f, h, k, q, n, p, r, w, y, g, t, x) => {\n              B.Ea("Conv", a, { format: w ? "NHWC" : "NCHW", auto_pad: b, dilations: [c, e], group: f, kernel_shape: [h, k], pads: q ? Array.from(z().subarray(q >>> 0, n >>> 0)) : [], strides: [p, r], w_is_const: () => !!d()[y >>> 0], activation: T(g), activation_params: t ? Array.from(da().subarray(t >>> 0, x >>> 0)) : [] });\n            },\n            944326: (a) => {\n              B.zb(a);\n            },\n            944360: (a, b) => B.Ab(a, b, B.bb.Cb, B.bb.errors)\n          };\n          function Ia(a) {\n            this.name = "ExitStatus";\n            this.message = `Program terminated with exit(${a})`;\n            this.status = a;\n          }\n          var Ja = (a) => {\n            a.terminate();\n            a.onmessage = () => {\n            };\n          }, La = (a) => {\n            0 == U.Ya.length && (Ka(), U.lb(U.Ya[0]));\n            var b = U.Ya.pop();\n            if (!b)\n              return 6;\n            U.Za.push(b);\n            U.Qa[a.Xa] = b;\n            b.Xa = a.Xa;\n            var c = { cmd: "run", start_routine: a.Db, arg: a.tb, pthread_ptr: a.Xa };\n            F && b.unref();\n            b.postMessage(c, a.Jb);\n            return 0;\n          }, V = 0, Ma = "undefined" != typeof TextDecoder ? new TextDecoder("utf8") : void 0, Na = (a, b, c) => {\n            b >>>= 0;\n            var e = b + c;\n            for (c = b; a[c] && !(c >= e); )\n              ++c;\n            if (16 < c - b && a.buffer && Ma)\n              return Ma.decode(a.buffer instanceof SharedArrayBuffer ? a.slice(b, c) : a.subarray(b, c));\n            for (e = ""; b < c; ) {\n              var f = a[b++];\n              if (f & 128) {\n                var h = a[b++] & 63;\n                if (192 == (f & 224))\n                  e += String.fromCharCode((f & 31) << 6 | h);\n                else {\n                  var k = a[b++] & 63;\n                  f = 224 == (f & 240) ? (f & 15) << 12 | h << 6 | k : (f & 7) << 18 | h << 12 | k << 6 | a[b++] & 63;\n                  65536 > f ? e += String.fromCharCode(f) : (f -= 65536, e += String.fromCharCode(55296 | f >> 10, 56320 | f & 1023));\n                }\n              } else\n                e += String.fromCharCode(f);\n            }\n            return e;\n          }, T = (a, b) => (a >>>= 0) ? Na(v(), a, b) : "", Qa = (a) => {\n            var b = Oa();\n            a = a();\n            Pa(b);\n            return a;\n          };\n          function W(a, b) {\n            var c = arguments.length - 2, e = arguments;\n            return Qa(() => {\n              for (var f = Ra(8 * c), h = f >>> 3, k = 0; k < c; k++) {\n                var q = e[2 + k];\n                fa()[h + k >>> 0] = q;\n              }\n              return Sa(a, c, f, b);\n            });\n          }\n          function Ta(a) {\n            if (G)\n              return W(0, 1, a);\n            O = a;\n            0 < V || (U.Eb(), B.onExit?.(a), M = true);\n            ma(a, new Ia(a));\n          }\n          var Va = (a) => {\n            O = a;\n            if (G)\n              throw Ua(a), "unwind";\n            Ta(a);\n          }, Wa = (a) => {\n            a instanceof Ia || "unwind" == a || ma(1, a);\n          };\n          function Xa() {\n            for (var a = B.numThreads; a--; )\n              Ka();\n            xa.unshift(() => {\n              P++;\n              Ya(() => Ba());\n            });\n          }\n          function Ka() {\n            var a = oa("ort-wasm-simd-threaded.worker.js");\n            a = new Worker(a);\n            U.Ya.push(a);\n          }\n          function Ya(a) {\n            G ? a() : Promise.all(U.Ya.map(U.lb)).then(a);\n          }\n          var U = { Ya: [], Za: [], pb: [], Qa: {}, hb() {\n            G ? (U.receiveObjectTransfer = U.Bb, U.threadInitTLS = U.ob, U.setExitStatus = U.nb) : Xa();\n          }, nb: (a) => O = a, Nb: ["$terminateWorker"], Eb: () => {\n            for (var a of U.Za)\n              Ja(a);\n            for (a of U.Ya)\n              Ja(a);\n            U.Ya = [];\n            U.Za = [];\n            U.Qa = [];\n          }, mb: (a) => {\n            var b = a.Xa;\n            delete U.Qa[b];\n            U.Ya.push(a);\n            U.Za.splice(U.Za.indexOf(a), 1);\n            a.Xa = 0;\n            Za(b);\n          }, Bb() {\n          }, ob() {\n            U.pb.forEach((a) => a());\n          }, lb: (a) => new Promise((b) => {\n            a.onmessage = (h) => {\n              h = h.data;\n              var k = h.cmd;\n              if (h.targetThread && h.targetThread != $a()) {\n                var q = U.Qa[h.targetThread];\n                q ? q.postMessage(h, h.transferList) : K(`Internal error! Worker sent a message "${k}" to target pthread ${h.targetThread}, but that thread no longer exists!`);\n              } else if ("checkMailbox" === k)\n                ab();\n              else if ("spawnThread" === k)\n                La(h);\n              else if ("cleanupThread" === k)\n                U.mb(U.Qa[h.thread]);\n              else if ("killThread" === k)\n                h = h.thread, k = U.Qa[h], delete U.Qa[h], Ja(k), Za(h), U.Za.splice(U.Za.indexOf(k), 1), k.Xa = 0;\n              else if ("cancelThread" === k)\n                U.Qa[h.thread].postMessage({ cmd: "cancel" });\n              else if ("loaded" === k)\n                a.loaded = true, F && !a.Xa && a.unref(), b(a);\n              else if ("alert" === k)\n                alert(`Thread ${h.threadId}: ${h.text}`);\n              else if ("setimmediate" === h.target)\n                a.postMessage(h);\n              else if ("callHandler" === k)\n                B[h.handler](...h.args);\n              else\n                k && K(`worker sent an unknown command ${k}`);\n            };\n            a.onerror = (h) => {\n              K(`${"worker sent an error!"} ${h.filename}:${h.lineno}: ${h.message}`);\n              throw h;\n            };\n            F && (a.on("message", (h) => a.onmessage({ data: h })), a.on("error", (h) => a.onerror(h)));\n            var c = [], e = ["onExit"], f;\n            for (f of e)\n              B.hasOwnProperty(f) && c.push(f);\n            a.postMessage({ cmd: "load", handlers: c, urlOrBlob: B.mainScriptUrlOrBlob || _scriptDir, wasmMemory: l, wasmModule: va });\n          }) };\n          B.PThread = U;\n          var bb = (a) => {\n            for (; 0 < a.length; )\n              a.shift()(B);\n          };\n          B.establishStackSpace = () => {\n            var a = $a(), b = A()[a + 52 >>> 2 >>> 0];\n            a = A()[a + 56 >>> 2 >>> 0];\n            cb(b, b - a);\n            Pa(b);\n          };\n          function Ua(a) {\n            if (G)\n              return W(1, 0, a);\n            Va(a);\n          }\n          B.invokeEntryPoint = (a, b) => {\n            a = db.apply(null, [a, b]);\n            0 < V ? U.nb(a) : eb(a);\n          };\n          function fb(a) {\n            this.gb = a - 24;\n            this.sb = function(b) {\n              A()[this.gb + 4 >>> 2 >>> 0] = b;\n            };\n            this.rb = function(b) {\n              A()[this.gb + 8 >>> 2 >>> 0] = b;\n            };\n            this.hb = function(b, c) {\n              this.qb();\n              this.sb(b);\n              this.rb(c);\n            };\n            this.qb = function() {\n              A()[this.gb + 16 >>> 2 >>> 0] = 0;\n            };\n          }\n          var gb = 0, hb = 0;\n          function ib(a, b, c, e) {\n            return G ? W(2, 1, a, b, c, e) : jb(a, b, c, e);\n          }\n          function jb(a, b, c, e) {\n            a >>>= 0;\n            b >>>= 0;\n            c >>>= 0;\n            e >>>= 0;\n            if ("undefined" == typeof SharedArrayBuffer)\n              return K("Current environment does not support SharedArrayBuffer, pthreads are not available!"), 6;\n            var f = [];\n            if (G && 0 === f.length)\n              return ib(a, b, c, e);\n            a = { Db: c, Xa: a, tb: e, Jb: f };\n            return G ? (a.Lb = "spawnThread", postMessage(a, f), 0) : La(a);\n          }\n          function kb(a, b, c) {\n            return G ? W(3, 1, a, b, c) : 0;\n          }\n          function lb(a, b) {\n            if (G)\n              return W(4, 1, a, b);\n          }\n          var mb = (a) => {\n            for (var b = 0, c = 0; c < a.length; ++c) {\n              var e = a.charCodeAt(c);\n              127 >= e ? b++ : 2047 >= e ? b += 2 : 55296 <= e && 57343 >= e ? (b += 4, ++c) : b += 3;\n            }\n            return b;\n          }, nb = (a, b, c, e) => {\n            c >>>= 0;\n            if (!(0 < e))\n              return 0;\n            var f = c;\n            e = c + e - 1;\n            for (var h = 0; h < a.length; ++h) {\n              var k = a.charCodeAt(h);\n              if (55296 <= k && 57343 >= k) {\n                var q = a.charCodeAt(++h);\n                k = 65536 + ((k & 1023) << 10) | q & 1023;\n              }\n              if (127 >= k) {\n                if (c >= e)\n                  break;\n                b[c++ >>> 0] = k;\n              } else {\n                if (2047 >= k) {\n                  if (c + 1 >= e)\n                    break;\n                  b[c++ >>> 0] = 192 | k >> 6;\n                } else {\n                  if (65535 >= k) {\n                    if (c + 2 >= e)\n                      break;\n                    b[c++ >>> 0] = 224 | k >> 12;\n                  } else {\n                    if (c + 3 >= e)\n                      break;\n                    b[c++ >>> 0] = 240 | k >> 18;\n                    b[c++ >>> 0] = 128 | k >> 12 & 63;\n                  }\n                  b[c++ >>> 0] = 128 | k >> 6 & 63;\n                }\n                b[c++ >>> 0] = 128 | k & 63;\n              }\n            }\n            b[c >>> 0] = 0;\n            return c - f;\n          }, ob = (a, b, c) => nb(a, v(), b, c);\n          function pb(a, b) {\n            if (G)\n              return W(5, 1, a, b);\n          }\n          function qb(a, b, c) {\n            if (G)\n              return W(6, 1, a, b, c);\n          }\n          function rb(a, b, c) {\n            return G ? W(7, 1, a, b, c) : 0;\n          }\n          function sb(a, b) {\n            if (G)\n              return W(8, 1, a, b);\n          }\n          function tb(a, b, c) {\n            if (G)\n              return W(9, 1, a, b, c);\n          }\n          function ub(a, b, c, e) {\n            if (G)\n              return W(10, 1, a, b, c, e);\n          }\n          function vb(a, b, c, e) {\n            if (G)\n              return W(11, 1, a, b, c, e);\n          }\n          function wb(a, b, c, e) {\n            if (G)\n              return W(12, 1, a, b, c, e);\n          }\n          function xb(a) {\n            if (G)\n              return W(13, 1, a);\n          }\n          function yb(a, b) {\n            if (G)\n              return W(14, 1, a, b);\n          }\n          function zb(a, b, c) {\n            if (G)\n              return W(15, 1, a, b, c);\n          }\n          var Ab = () => {\n            if (!(0 < V))\n              try {\n                G ? eb(O) : Va(O);\n              } catch (a) {\n                Wa(a);\n              }\n          };\n          function Bb(a) {\n            a >>>= 0;\n            "function" === typeof Atomics.Kb && (Atomics.Kb(z(), a >>> 2, a).value.then(ab), a += 128, Atomics.store(z(), a >>> 2, 1));\n          }\n          B.__emscripten_thread_mailbox_await = Bb;\n          var ab = () => {\n            var a = $a();\n            if (a && (Bb(a), !M))\n              try {\n                Cb(), Ab();\n              } catch (b) {\n                Wa(b);\n              }\n          };\n          B.checkMailbox = ab;\n          var Db = [], X = (a) => 0 === a % 4 && (0 !== a % 100 || 0 === a % 400), Eb = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335], Fb = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];\n          function Gb(a, b, c, e, f, h, k, q) {\n            return G ? W(16, 1, a, b, c, e, f, h, k, q) : -52;\n          }\n          function Hb(a, b, c, e, f, h, k) {\n            if (G)\n              return W(17, 1, a, b, c, e, f, h, k);\n          }\n          var Jb = (a) => {\n            var b = mb(a) + 1, c = Ib(b);\n            c && ob(a, c, b);\n            return c;\n          }, Kb = [], Lb = (a, b) => {\n            Kb.length = 0;\n            for (var c; c = v()[a++ >>> 0]; ) {\n              var e = 105 != c;\n              e &= 112 != c;\n              b += e && b % 8 ? 4 : 0;\n              Kb.push(112 == c ? A()[b >>> 2 >>> 0] : 105 == c ? z()[b >>> 2 >>> 0] : fa()[b >>> 3 >>> 0]);\n              b += e ? 8 : 4;\n            }\n            return Kb;\n          }, Mb = {}, Ob = () => {\n            if (!Nb) {\n              var a = { USER: "web_user", LOGNAME: "web_user", PATH: "/", PWD: "/", HOME: "/home/web_user", LANG: ("object" == typeof navigator && navigator.languages && navigator.languages[0] || "C").replace("-", "_") + ".UTF-8", _: la || "./this.program" }, b;\n              for (b in Mb)\n                void 0 === Mb[b] ? delete a[b] : a[b] = Mb[b];\n              var c = [];\n              for (b in a)\n                c.push(`${b}=${a[b]}`);\n              Nb = c;\n            }\n            return Nb;\n          }, Nb;\n          function Pb(a, b) {\n            if (G)\n              return W(18, 1, a, b);\n            a >>>= 0;\n            b >>>= 0;\n            var c = 0;\n            Ob().forEach((e, f) => {\n              var h = b + c;\n              f = A()[a + 4 * f >>> 2 >>> 0] = h;\n              for (h = 0; h < e.length; ++h)\n                d()[f++ >>> 0 >>> 0] = e.charCodeAt(h);\n              d()[f >>> 0 >>> 0] = 0;\n              c += e.length + 1;\n            });\n            return 0;\n          }\n          function Qb(a, b) {\n            if (G)\n              return W(19, 1, a, b);\n            a >>>= 0;\n            b >>>= 0;\n            var c = Ob();\n            A()[a >>> 2 >>> 0] = c.length;\n            var e = 0;\n            c.forEach((f) => e += f.length + 1);\n            A()[b >>> 2 >>> 0] = e;\n            return 0;\n          }\n          function Rb(a) {\n            return G ? W(20, 1, a) : 52;\n          }\n          function Tb(a, b, c, e) {\n            return G ? W(21, 1, a, b, c, e) : 52;\n          }\n          function Ub(a, b, c, e, f) {\n            return G ? W(22, 1, a, b, c, e, f) : 70;\n          }\n          var Vb = [null, [], []];\n          function Wb(a, b, c, e) {\n            if (G)\n              return W(23, 1, a, b, c, e);\n            b >>>= 0;\n            c >>>= 0;\n            e >>>= 0;\n            for (var f = 0, h = 0; h < c; h++) {\n              var k = A()[b >>> 2 >>> 0], q = A()[b + 4 >>> 2 >>> 0];\n              b += 8;\n              for (var n = 0; n < q; n++) {\n                var p = v()[k + n >>> 0], r = Vb[a];\n                0 === p || 10 === p ? ((1 === a ? ua : K)(Na(r, 0)), r.length = 0) : r.push(p);\n              }\n              f += q;\n            }\n            A()[e >>> 2 >>> 0] = f;\n            return 0;\n          }\n          var Xb = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], Yb = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n          function Zb(a) {\n            var b = Array(mb(a) + 1);\n            nb(a, b, 0, b.length);\n            return b;\n          }\n          var $b = (a, b) => {\n            d().set(a, b >>> 0);\n          };\n          function ac(a, b, c, e) {\n            function f(g, t, x) {\n              for (g = "number" == typeof g ? g.toString() : g || ""; g.length < t; )\n                g = x[0] + g;\n              return g;\n            }\n            function h(g, t) {\n              return f(g, t, "0");\n            }\n            function k(g, t) {\n              function x(Sb) {\n                return 0 > Sb ? -1 : 0 < Sb ? 1 : 0;\n              }\n              var N;\n              0 === (N = x(g.getFullYear() - t.getFullYear())) && 0 === (N = x(g.getMonth() - t.getMonth())) && (N = x(g.getDate() - t.getDate()));\n              return N;\n            }\n            function q(g) {\n              switch (g.getDay()) {\n                case 0:\n                  return new Date(g.getFullYear() - 1, 11, 29);\n                case 1:\n                  return g;\n                case 2:\n                  return new Date(g.getFullYear(), 0, 3);\n                case 3:\n                  return new Date(\n                    g.getFullYear(),\n                    0,\n                    2\n                  );\n                case 4:\n                  return new Date(g.getFullYear(), 0, 1);\n                case 5:\n                  return new Date(g.getFullYear() - 1, 11, 31);\n                case 6:\n                  return new Date(g.getFullYear() - 1, 11, 30);\n              }\n            }\n            function n(g) {\n              var t = g.$a;\n              for (g = new Date(new Date(g.ab + 1900, 0, 1).getTime()); 0 < t; ) {\n                var x = g.getMonth(), N = (X(g.getFullYear()) ? Xb : Yb)[x];\n                if (t > N - g.getDate())\n                  t -= N - g.getDate() + 1, g.setDate(1), 11 > x ? g.setMonth(x + 1) : (g.setMonth(0), g.setFullYear(g.getFullYear() + 1));\n                else {\n                  g.setDate(g.getDate() + t);\n                  break;\n                }\n              }\n              x = new Date(g.getFullYear() + 1, 0, 4);\n              t = q(new Date(\n                g.getFullYear(),\n                0,\n                4\n              ));\n              x = q(x);\n              return 0 >= k(t, g) ? 0 >= k(x, g) ? g.getFullYear() + 1 : g.getFullYear() : g.getFullYear() - 1;\n            }\n            a >>>= 0;\n            b >>>= 0;\n            c >>>= 0;\n            e >>>= 0;\n            var p = A()[e + 40 >>> 2 >>> 0];\n            e = { Hb: z()[e >>> 2 >>> 0], Gb: z()[e + 4 >>> 2 >>> 0], eb: z()[e + 8 >>> 2 >>> 0], jb: z()[e + 12 >>> 2 >>> 0], fb: z()[e + 16 >>> 2 >>> 0], ab: z()[e + 20 >>> 2 >>> 0], Wa: z()[e + 24 >>> 2 >>> 0], $a: z()[e + 28 >>> 2 >>> 0], Ob: z()[e + 32 >>> 2 >>> 0], Fb: z()[e + 36 >>> 2 >>> 0], Ib: p ? T(p) : "" };\n            c = T(c);\n            p = {\n              "%c": "%a %b %d %H:%M:%S %Y",\n              "%D": "%m/%d/%y",\n              "%F": "%Y-%m-%d",\n              "%h": "%b",\n              "%r": "%I:%M:%S %p",\n              "%R": "%H:%M",\n              "%T": "%H:%M:%S",\n              "%x": "%m/%d/%y",\n              "%X": "%H:%M:%S",\n              "%Ec": "%c",\n              "%EC": "%C",\n              "%Ex": "%m/%d/%y",\n              "%EX": "%H:%M:%S",\n              "%Ey": "%y",\n              "%EY": "%Y",\n              "%Od": "%d",\n              "%Oe": "%e",\n              "%OH": "%H",\n              "%OI": "%I",\n              "%Om": "%m",\n              "%OM": "%M",\n              "%OS": "%S",\n              "%Ou": "%u",\n              "%OU": "%U",\n              "%OV": "%V",\n              "%Ow": "%w",\n              "%OW": "%W",\n              "%Oy": "%y"\n            };\n            for (var r in p)\n              c = c.replace(new RegExp(r, "g"), p[r]);\n            var w = "Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "), y = "January February March April May June July August September October November December".split(" ");\n            p = { "%a": (g) => w[g.Wa].substring(0, 3), "%A": (g) => w[g.Wa], "%b": (g) => y[g.fb].substring(0, 3), "%B": (g) => y[g.fb], "%C": (g) => h((g.ab + 1900) / 100 | 0, 2), "%d": (g) => h(g.jb, 2), "%e": (g) => f(g.jb, 2, " "), "%g": (g) => n(g).toString().substring(2), "%G": (g) => n(g), "%H": (g) => h(g.eb, 2), "%I": (g) => {\n              g = g.eb;\n              0 == g ? g = 12 : 12 < g && (g -= 12);\n              return h(g, 2);\n            }, "%j": (g) => {\n              for (var t = 0, x = 0; x <= g.fb - 1; t += (X(g.ab + 1900) ? Xb : Yb)[x++])\n                ;\n              return h(g.jb + t, 3);\n            }, "%m": (g) => h(g.fb + 1, 2), "%M": (g) => h(g.Gb, 2), "%n": () => "\\n", "%p": (g) => 0 <= g.eb && 12 > g.eb ? "AM" : "PM", "%S": (g) => h(g.Hb, 2), "%t": () => "\t", "%u": (g) => g.Wa || 7, "%U": (g) => h(Math.floor((g.$a + 7 - g.Wa) / 7), 2), "%V": (g) => {\n              var t = Math.floor((g.$a + 7 - (g.Wa + 6) % 7) / 7);\n              2 >= (g.Wa + 371 - g.$a - 2) % 7 && t++;\n              if (t)\n                53 == t && (x = (g.Wa + 371 - g.$a) % 7, 4 == x || 3 == x && X(g.ab) || (t = 1));\n              else {\n                t = 52;\n                var x = (g.Wa + 7 - g.$a - 1) % 7;\n                (4 == x || 5 == x && X(g.ab % 400 - 1)) && t++;\n              }\n              return h(t, 2);\n            }, "%w": (g) => g.Wa, "%W": (g) => h(Math.floor((g.$a + 7 - (g.Wa + 6) % 7) / 7), 2), "%y": (g) => (g.ab + 1900).toString().substring(2), "%Y": (g) => g.ab + 1900, "%z": (g) => {\n              g = g.Fb;\n              var t = 0 <= g;\n              g = Math.abs(g) / 60;\n              return (t ? "+" : "-") + String("0000" + (g / 60 * 100 + g % 60)).slice(-4);\n            }, "%Z": (g) => g.Ib, "%%": () => "%" };\n            c = c.replace(/%%/g, "\\0\\0");\n            for (r in p)\n              c.includes(r) && (c = c.replace(new RegExp(r, "g"), p[r](e)));\n            c = c.replace(/\\0\\0/g, "%");\n            r = Zb(c);\n            if (r.length > b)\n              return 0;\n            $b(r, a);\n            return r.length - 1;\n          }\n          var bc = (a) => {\n            try {\n              a();\n            } catch (b) {\n              L(b);\n            }\n          };\n          function cc() {\n            var a = Y, b = {};\n            for (let [c, e] of Object.entries(a))\n              b[c] = "function" == typeof e ? function() {\n                dc.push(c);\n                try {\n                  return e.apply(null, arguments);\n                } finally {\n                  M || (dc.pop(), D && 1 === Z && 0 === dc.length && (Z = 0, V += 1, bc(ec), "undefined" != typeof Fibers && Fibers.Pb()));\n                }\n              } : e;\n            return b;\n          }\n          var Z = 0, D = null, fc = 0, dc = [], gc = {}, hc = {}, ic = 0, jc = null, kc = [];\n          function ja() {\n            return new Promise((a, b) => {\n              jc = { resolve: a, reject: b };\n            });\n          }\n          function lc() {\n            var a = Ib(65548), b = a + 12;\n            A()[a >>> 2 >>> 0] = b;\n            A()[a + 4 >>> 2 >>> 0] = b + 65536;\n            b = dc[0];\n            var c = gc[b];\n            void 0 === c && (c = ic++, gc[b] = c, hc[c] = b);\n            b = c;\n            z()[a + 8 >>> 2 >>> 0] = b;\n            return a;\n          }\n          function mc() {\n            var a = z()[D + 8 >>> 2 >>> 0];\n            a = Y[hc[a]];\n            --V;\n            return a();\n          }\n          function nc(a) {\n            if (!M) {\n              if (0 === Z) {\n                var b = false, c = false;\n                a((e = 0) => {\n                  if (!M && (fc = e, b = true, c)) {\n                    Z = 2;\n                    bc(() => oc(D));\n                    "undefined" != typeof Browser && Browser.ib.vb && Browser.ib.resume();\n                    e = false;\n                    try {\n                      var f = mc();\n                    } catch (q) {\n                      f = q, e = true;\n                    }\n                    var h = false;\n                    if (!D) {\n                      var k = jc;\n                      k && (jc = null, (e ? k.reject : k.resolve)(f), h = true);\n                    }\n                    if (e && !h)\n                      throw f;\n                  }\n                });\n                c = true;\n                b || (Z = 1, D = lc(), "undefined" != typeof Browser && Browser.ib.vb && Browser.ib.pause(), bc(() => pc(D)));\n              } else\n                2 === Z ? (Z = 0, bc(qc), rc(D), D = null, kc.forEach((e) => {\n                  if (!M)\n                    try {\n                      e(), Ab();\n                    } catch (f) {\n                      Wa(f);\n                    }\n                })) : L(`invalid state: ${Z}`);\n              return fc;\n            }\n          }\n          function sc(a) {\n            return nc((b) => {\n              a().then(b);\n            });\n          }\n          U.hb();\n          var tc = [Ta, Ua, ib, kb, lb, pb, qb, rb, sb, tb, ub, vb, wb, xb, yb, zb, Gb, Hb, Pb, Qb, Rb, Tb, Ub, Wb], xc = { r: function(a, b, c) {\n            return sc(async () => {\n              await B.xb(a, b, c);\n            });\n          }, b: function(a, b, c) {\n            a >>>= 0;\n            new fb(a).hb(b >>> 0, c >>> 0);\n            gb = a;\n            hb++;\n            throw gb;\n          }, N: function(a) {\n            uc(a >>> 0, !E, 1, !na, 131072, false);\n            U.ob();\n          }, l: function(a) {\n            a >>>= 0;\n            G ? postMessage({ cmd: "cleanupThread", thread: a }) : U.mb(U.Qa[a]);\n          }, J: jb, i: kb, T: lb, F: pb, H: qb, U: rb, R: sb, L: tb, Q: ub, p: vb, G: wb, D: xb, S: yb, E: zb, q: () => 1, B: function(a, b) {\n            a >>>= 0;\n            a == b >>> 0 ? setTimeout(() => ab()) : G ? postMessage({\n              targetThread: a,\n              cmd: "checkMailbox"\n            }) : (a = U.Qa[a]) && a.postMessage({ cmd: "checkMailbox" });\n          }, K: function(a, b, c, e) {\n            b >>>= 0;\n            Db.length = c;\n            e = e >>> 0 >>> 3;\n            for (var f = 0; f < c; f++)\n              Db[f] = fa()[e + f >>> 0];\n            a = 0 > a ? Ha[-a - 1] : tc[a];\n            U.ub = b;\n            b = a.apply(null, Db);\n            U.ub = 0;\n            return b;\n          }, M: Bb, W: function(a) {\n            F && U.Qa[a >>> 0].ref();\n          }, u: function(a, b, c) {\n            a = b + 2097152 >>> 0 < 4194305 - !!a ? (a >>> 0) + 4294967296 * b : NaN;\n            c >>>= 0;\n            a = new Date(1e3 * a);\n            z()[c >>> 2 >>> 0] = a.getUTCSeconds();\n            z()[c + 4 >>> 2 >>> 0] = a.getUTCMinutes();\n            z()[c + 8 >>> 2 >>> 0] = a.getUTCHours();\n            z()[c + 12 >>> 2 >>> 0] = a.getUTCDate();\n            z()[c + 16 >>> 2 >>> 0] = a.getUTCMonth();\n            z()[c + 20 >>> 2 >>> 0] = a.getUTCFullYear() - 1900;\n            z()[c + 24 >>> 2 >>> 0] = a.getUTCDay();\n            a = (a.getTime() - Date.UTC(a.getUTCFullYear(), 0, 1, 0, 0, 0, 0)) / 864e5 | 0;\n            z()[c + 28 >>> 2 >>> 0] = a;\n          }, v: function(a, b, c) {\n            a = b + 2097152 >>> 0 < 4194305 - !!a ? (a >>> 0) + 4294967296 * b : NaN;\n            c >>>= 0;\n            a = new Date(1e3 * a);\n            z()[c >>> 2 >>> 0] = a.getSeconds();\n            z()[c + 4 >>> 2 >>> 0] = a.getMinutes();\n            z()[c + 8 >>> 2 >>> 0] = a.getHours();\n            z()[c + 12 >>> 2 >>> 0] = a.getDate();\n            z()[c + 16 >>> 2 >>> 0] = a.getMonth();\n            z()[c + 20 >>> 2 >>> 0] = a.getFullYear() - 1900;\n            z()[c + 24 >>> 2 >>> 0] = a.getDay();\n            b = (X(a.getFullYear()) ? Eb : Fb)[a.getMonth()] + a.getDate() - 1 | 0;\n            z()[c + 28 >>> 2 >>> 0] = b;\n            z()[c + 36 >>> 2 >>> 0] = -(60 * a.getTimezoneOffset());\n            b = new Date(a.getFullYear(), 6, 1).getTimezoneOffset();\n            var e = new Date(a.getFullYear(), 0, 1).getTimezoneOffset();\n            a = (b != e && a.getTimezoneOffset() == Math.min(e, b)) | 0;\n            z()[c + 32 >>> 2 >>> 0] = a;\n          }, w: function(a) {\n            a >>>= 0;\n            var b = new Date(z()[a + 20 >>> 2 >>> 0] + 1900, z()[a + 16 >>> 2 >>> 0], z()[a + 12 >>> 2 >>> 0], z()[a + 8 >>> 2 >>> 0], z()[a + 4 >>> 2 >>> 0], z()[a >>> 2 >>> 0], 0), c = z()[a + 32 >>> 2 >>> 0], e = b.getTimezoneOffset(), f = new Date(\n              b.getFullYear(),\n              6,\n              1\n            ).getTimezoneOffset(), h = new Date(b.getFullYear(), 0, 1).getTimezoneOffset(), k = Math.min(h, f);\n            0 > c ? z()[a + 32 >>> 2 >>> 0] = Number(f != h && k == e) : 0 < c != (k == e) && (f = Math.max(h, f), b.setTime(b.getTime() + 6e4 * ((0 < c ? k : f) - e)));\n            z()[a + 24 >>> 2 >>> 0] = b.getDay();\n            c = (X(b.getFullYear()) ? Eb : Fb)[b.getMonth()] + b.getDate() - 1 | 0;\n            z()[a + 28 >>> 2 >>> 0] = c;\n            z()[a >>> 2 >>> 0] = b.getSeconds();\n            z()[a + 4 >>> 2 >>> 0] = b.getMinutes();\n            z()[a + 8 >>> 2 >>> 0] = b.getHours();\n            z()[a + 12 >>> 2 >>> 0] = b.getDate();\n            z()[a + 16 >>> 2 >>> 0] = b.getMonth();\n            z()[a + 20 >>> 2 >>> 0] = b.getYear();\n            a = b.getTime();\n            isNaN(a) ? (z()[vc() >>> 2 >>> 0] = 61, a = -1) : a /= 1e3;\n            return wc((S = a, 1 <= +Math.abs(S) ? 0 < S ? +Math.floor(S / 4294967296) >>> 0 : ~~+Math.ceil((S - +(~~S >>> 0)) / 4294967296) >>> 0 : 0)), a >>> 0;\n          }, s: Gb, t: Hb, A: function(a, b, c) {\n            function e(p) {\n              return (p = p.toTimeString().match(/\\(([A-Za-z ]+)\\)$/)) ? p[1] : "GMT";\n            }\n            a >>>= 0;\n            b >>>= 0;\n            c >>>= 0;\n            var f = (/* @__PURE__ */ new Date()).getFullYear(), h = new Date(f, 0, 1), k = new Date(f, 6, 1);\n            f = h.getTimezoneOffset();\n            var q = k.getTimezoneOffset(), n = Math.max(f, q);\n            A()[a >>> 2 >>> 0] = 60 * n;\n            z()[b >>> 2 >>> 0] = Number(f != q);\n            a = e(h);\n            b = e(k);\n            a = Jb(a);\n            b = Jb(b);\n            q < f ? (A()[c >>> 2 >>> 0] = a, A()[c + 4 >>> 2 >>> 0] = b) : (A()[c >>> 2 >>> 0] = b, A()[c + 4 >>> 2 >>> 0] = a);\n          }, d: () => {\n            L("");\n          }, c: function(a, b, c) {\n            a >>>= 0;\n            b = Lb(b >>> 0, c >>> 0);\n            return Ha[a].apply(null, b);\n          }, k: function(a, b, c) {\n            a >>>= 0;\n            b = Lb(b >>> 0, c >>> 0);\n            return Ha[a].apply(null, b);\n          }, m: () => {\n          }, j: () => Date.now(), V: () => {\n            V += 1;\n            throw "unwind";\n          }, C: function() {\n            return 4294901760;\n          }, f: () => performance.timeOrigin + performance.now(), g: () => F ? (init_os(), __toCommonJS(os_exports)).cpus().length : navigator.hardwareConcurrency, y: function(a) {\n            a >>>= 0;\n            var b = v().length;\n            if (a <= b || 4294901760 < a)\n              return false;\n            for (var c = 1; 4 >= c; c *= 2) {\n              var e = b * (1 + 0.2 / c);\n              e = Math.min(e, a + 100663296);\n              var f = Math;\n              e = Math.max(a, e);\n              a: {\n                f = (f.min.call(f, 4294901760, e + (65536 - e % 65536) % 65536) - l.buffer.byteLength + 65535) / 65536;\n                try {\n                  l.grow(f);\n                  u();\n                  var h = 1;\n                  break a;\n                } catch (k) {\n                }\n                h = void 0;\n              }\n              if (h)\n                return true;\n            }\n            return false;\n          }, O: Pb, P: Qb, I: Va, h: Rb, o: Tb, x: Ub, n: Wb, a: l || B.wasmMemory, z: ac, e: function(a, b, c, e) {\n            return ac(a >>> 0, b >>> 0, c >>> 0, e >>> 0);\n          } }, Y = function() {\n            function a(c, e) {\n              Y = c.exports;\n              Y = cc();\n              Y = yc();\n              U.pb.push(Y.Da);\n              ya.unshift(Y.X);\n              va = e;\n              Ba();\n              return Y;\n            }\n            var b = { a: xc };\n            P++;\n            if (B.instantiateWasm)\n              try {\n                return B.instantiateWasm(b, a);\n              } catch (c) {\n                K(`Module.instantiateWasm callback failed with error: ${c}`), C(c);\n              }\n            Ga(b, function(c) {\n              a(c.instance, c.module);\n            }).catch(C);\n            return {};\n          }();\n          B._OrtInit = (a, b) => (B._OrtInit = Y.Y)(a, b);\n          B._OrtGetLastError = (a, b) => (B._OrtGetLastError = Y.Z)(a, b);\n          B._OrtCreateSessionOptions = (a, b, c, e, f, h, k, q, n, p) => (B._OrtCreateSessionOptions = Y._)(a, b, c, e, f, h, k, q, n, p);\n          B._OrtAppendExecutionProvider = (a, b) => (B._OrtAppendExecutionProvider = Y.$)(a, b);\n          B._OrtAddFreeDimensionOverride = (a, b, c) => (B._OrtAddFreeDimensionOverride = Y.aa)(a, b, c);\n          B._OrtAddSessionConfigEntry = (a, b, c) => (B._OrtAddSessionConfigEntry = Y.ba)(a, b, c);\n          B._OrtReleaseSessionOptions = (a) => (B._OrtReleaseSessionOptions = Y.ca)(a);\n          B._OrtCreateSession = (a, b, c) => (B._OrtCreateSession = Y.da)(a, b, c);\n          B._OrtReleaseSession = (a) => (B._OrtReleaseSession = Y.ea)(a);\n          B._OrtGetInputOutputCount = (a, b, c) => (B._OrtGetInputOutputCount = Y.fa)(a, b, c);\n          B._OrtGetInputName = (a, b) => (B._OrtGetInputName = Y.ga)(a, b);\n          B._OrtGetOutputName = (a, b) => (B._OrtGetOutputName = Y.ha)(a, b);\n          B._OrtFree = (a) => (B._OrtFree = Y.ia)(a);\n          B._OrtCreateTensor = (a, b, c, e, f, h) => (B._OrtCreateTensor = Y.ja)(a, b, c, e, f, h);\n          B._OrtGetTensorData = (a, b, c, e, f) => (B._OrtGetTensorData = Y.ka)(a, b, c, e, f);\n          B._OrtReleaseTensor = (a) => (B._OrtReleaseTensor = Y.la)(a);\n          B._OrtCreateRunOptions = (a, b, c, e) => (B._OrtCreateRunOptions = Y.ma)(a, b, c, e);\n          B._OrtAddRunConfigEntry = (a, b, c) => (B._OrtAddRunConfigEntry = Y.na)(a, b, c);\n          B._OrtReleaseRunOptions = (a) => (B._OrtReleaseRunOptions = Y.oa)(a);\n          B._OrtCreateBinding = (a) => (B._OrtCreateBinding = Y.pa)(a);\n          B._OrtBindInput = (a, b, c) => (B._OrtBindInput = Y.qa)(a, b, c);\n          B._OrtBindOutput = (a, b, c, e) => (B._OrtBindOutput = Y.ra)(a, b, c, e);\n          B._OrtClearBoundOutputs = (a) => (B._OrtClearBoundOutputs = Y.sa)(a);\n          B._OrtReleaseBinding = (a) => (B._OrtReleaseBinding = Y.ta)(a);\n          B._OrtRunWithBinding = (a, b, c, e, f) => (B._OrtRunWithBinding = Y.ua)(a, b, c, e, f);\n          B._OrtRun = (a, b, c, e, f, h, k, q) => (B._OrtRun = Y.va)(a, b, c, e, f, h, k, q);\n          B._OrtEndProfiling = (a) => (B._OrtEndProfiling = Y.wa)(a);\n          B._JsepOutput = (a, b, c) => (B._JsepOutput = Y.xa)(a, b, c);\n          B._JsepGetNodeName = (a) => (B._JsepGetNodeName = Y.ya)(a);\n          var vc = () => (vc = Y.za)(), $a = B._pthread_self = () => ($a = B._pthread_self = Y.Aa)(), Ib = B._malloc = (a) => (Ib = B._malloc = Y.Ba)(a), rc = B._free = (a) => (rc = B._free = Y.Ca)(a);\n          B.__emscripten_tls_init = () => (B.__emscripten_tls_init = Y.Da)();\n          var uc = B.__emscripten_thread_init = (a, b, c, e, f, h) => (uc = B.__emscripten_thread_init = Y.Fa)(a, b, c, e, f, h);\n          B.__emscripten_thread_crashed = () => (B.__emscripten_thread_crashed = Y.Ga)();\n          var Sa = (a, b, c, e) => (Sa = Y.Ha)(a, b, c, e), Za = (a) => (Za = Y.Ia)(a), eb = B.__emscripten_thread_exit = (a) => (eb = B.__emscripten_thread_exit = Y.Ja)(a), Cb = () => (Cb = Y.Ka)(), wc = (a) => (wc = Y.La)(a), cb = (a, b) => (cb = Y.Ma)(a, b), Oa = () => (Oa = Y.Na)(), Pa = (a) => (Pa = Y.Oa)(a), Ra = (a) => (Ra = Y.Pa)(a), db = B.dynCall_ii = (a, b) => (db = B.dynCall_ii = Y.Ra)(a, b), pc = (a) => (pc = Y.Sa)(a), ec = () => (ec = Y.Ta)(), oc = (a) => (oc = Y.Ua)(a), qc = () => (qc = Y.Va)();\n          B.___start_em_js = 944472;\n          B.___stop_em_js = 944633;\n          function yc() {\n            var a = Y;\n            a = Object.assign({}, a);\n            var b = (e) => () => e() >>> 0, c = (e) => (f) => e(f) >>> 0;\n            a.za = b(a.za);\n            a.Aa = b(a.Aa);\n            a.Ba = c(a.Ba);\n            a.emscripten_main_runtime_thread_id = b(a.emscripten_main_runtime_thread_id);\n            a.Na = b(a.Na);\n            a.Pa = c(a.Pa);\n            return a;\n          }\n          B.wasmMemory = l;\n          B.stackAlloc = Ra;\n          B.stackSave = Oa;\n          B.stackRestore = Pa;\n          B.keepRuntimeAlive = () => 0 < V;\n          B.UTF8ToString = T;\n          B.stringToUTF8 = ob;\n          B.lengthBytesUTF8 = mb;\n          B.ExitStatus = Ia;\n          B.PThread = U;\n          var zc;\n          Q = function Ac() {\n            zc || Bc();\n            zc || (Q = Ac);\n          };\n          function Bc() {\n            if (!(0 < P))\n              if (G)\n                ia(B), G || bb(ya), startWorker(B);\n              else {\n                if (B.preRun)\n                  for ("function" == typeof B.preRun && (B.preRun = [B.preRun]); B.preRun.length; )\n                    xa.unshift(B.preRun.shift());\n                bb(xa);\n                0 < P || zc || (zc = true, B.calledRun = true, M || (G || bb(ya), ia(B), G || bb(za)));\n              }\n          }\n          Bc();\n          return moduleArg.ready;\n        };\n      })();\n      if (typeof exports === "object" && typeof module === "object")\n        module.exports = ortWasmThreaded;\n      else if (typeof define === "function" && define["amd"])\n        define([], () => ortWasmThreaded);\n    }\n  });\n\n  // web/lib/wasm/binding/ort-wasm-threaded.worker.js\n  var require_ort_wasm_threaded_worker = __commonJS({\n    "web/lib/wasm/binding/ort-wasm-threaded.worker.js"(exports, module) {\n      module.exports = \'"use strict";var Module={};var ENVIRONMENT_IS_NODE=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string";if(ENVIRONMENT_IS_NODE){var nodeWorkerThreads=require("worker_threads");var parentPort=nodeWorkerThreads.parentPort;parentPort.on("message",data=>onmessage({data:data}));var fs=require("fs");var vm=require("vm");Object.assign(global,{self:global,require:require,Module:Module,location:{href:__filename},Worker:nodeWorkerThreads.Worker,importScripts:f=>vm.runInThisContext(fs.readFileSync(f,"utf8"),{filename:f}),postMessage:msg=>parentPort.postMessage(msg),performance:global.performance||{now:Date.now}})}var initializedJS=false;function threadPrintErr(){var text=Array.prototype.slice.call(arguments).join(" ");if(ENVIRONMENT_IS_NODE){fs.writeSync(2,text+"\\\\n");return}console.error(text)}function threadAlert(){var text=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:text,threadId:Module["_pthread_self"]()})}var err=threadPrintErr;self.alert=threadAlert;Module["instantiateWasm"]=(info,receiveInstance)=>{var module=Module["wasmModule"];Module["wasmModule"]=null;var instance=new WebAssembly.Instance(module,info);return receiveInstance(instance)};self.onunhandledrejection=e=>{throw e.reason||e};function handleMessage(e){try{if(e.data.cmd==="load"){let messageQueue=[];self.onmessage=e=>messageQueue.push(e);self.startWorker=instance=>{Module=instance;postMessage({"cmd":"loaded"});for(let msg of messageQueue){handleMessage(msg)}self.onmessage=handleMessage};Module["wasmModule"]=e.data.wasmModule;for(const handler of e.data.handlers){Module[handler]=(...args)=>{postMessage({cmd:"callHandler",handler:handler,args:args})}}Module["wasmMemory"]=e.data.wasmMemory;Module["buffer"]=Module["wasmMemory"].buffer;Module["ENVIRONMENT_IS_PTHREAD"]=true;if(typeof e.data.urlOrBlob=="string"){importScripts(e.data.urlOrBlob)}else{var objectUrl=URL.createObjectURL(e.data.urlOrBlob);importScripts(objectUrl);URL.revokeObjectURL(objectUrl)}ortWasmThreaded(Module)}else if(e.data.cmd==="run"){Module["__emscripten_thread_init"](e.data.pthread_ptr,/*is_main=*/0,/*is_runtime=*/0,/*can_block=*/1);Module["__emscripten_thread_mailbox_await"](e.data.pthread_ptr);Module["establishStackSpace"]();Module["PThread"].receiveObjectTransfer(e.data);Module["PThread"].threadInitTLS();if(!initializedJS){initializedJS=true}try{Module["invokeEntryPoint"](e.data.start_routine,e.data.arg)}catch(ex){if(ex!="unwind"){throw ex}}}else if(e.data.cmd==="cancel"){if(Module["_pthread_self"]()){Module["__emscripten_thread_exit"](-1)}}else if(e.data.target==="setimmediate"){}else if(e.data.cmd==="checkMailbox"){if(initializedJS){Module["checkMailbox"]()}}else if(e.data.cmd){err(`worker.js received unknown command ${e.data.cmd}`);err(e.data)}}catch(ex){Module["__emscripten_thread_crashed"]?.();throw ex}}self.onmessage=handleMessage;\\n\';\n    }\n  });\n\n  // web/lib/wasm/wasm-common.ts\n  var tensorDataTypeStringToEnum, tensorDataTypeEnumToString, getTensorElementSize, tensorTypeToTypedArrayConstructor, logLevelStringToEnum, isGpuBufferSupportedType, dataLocationStringToEnum;\n  var init_wasm_common = __esm({\n    "web/lib/wasm/wasm-common.ts"() {\n      "use strict";\n      tensorDataTypeStringToEnum = (type) => {\n        switch (type) {\n          case "int8":\n            return 3 /* int8 */;\n          case "uint8":\n            return 2 /* uint8 */;\n          case "bool":\n            return 9 /* bool */;\n          case "int16":\n            return 5 /* int16 */;\n          case "uint16":\n            return 4 /* uint16 */;\n          case "int32":\n            return 6 /* int32 */;\n          case "uint32":\n            return 12 /* uint32 */;\n          case "float16":\n            return 10 /* float16 */;\n          case "float32":\n            return 1 /* float */;\n          case "float64":\n            return 11 /* double */;\n          case "string":\n            return 8 /* string */;\n          case "int64":\n            return 7 /* int64 */;\n          case "uint64":\n            return 13 /* uint64 */;\n          default:\n            throw new Error(`unsupported data type: ${type}`);\n        }\n      };\n      tensorDataTypeEnumToString = (typeProto) => {\n        switch (typeProto) {\n          case 3 /* int8 */:\n            return "int8";\n          case 2 /* uint8 */:\n            return "uint8";\n          case 9 /* bool */:\n            return "bool";\n          case 5 /* int16 */:\n            return "int16";\n          case 4 /* uint16 */:\n            return "uint16";\n          case 6 /* int32 */:\n            return "int32";\n          case 12 /* uint32 */:\n            return "uint32";\n          case 10 /* float16 */:\n            return "float16";\n          case 1 /* float */:\n            return "float32";\n          case 11 /* double */:\n            return "float64";\n          case 8 /* string */:\n            return "string";\n          case 7 /* int64 */:\n            return "int64";\n          case 13 /* uint64 */:\n            return "uint64";\n          default:\n            throw new Error(`unsupported data type: ${typeProto}`);\n        }\n      };\n      getTensorElementSize = (dateType) => [void 0, 4, 1, 1, 2, 2, 4, 8, void 0, 1, 2, 8, 4, 8, void 0, void 0, void 0][dateType];\n      tensorTypeToTypedArrayConstructor = (type) => {\n        switch (type) {\n          case "float16":\n            return Uint16Array;\n          case "float32":\n            return Float32Array;\n          case "uint8":\n            return Uint8Array;\n          case "int8":\n            return Int8Array;\n          case "uint16":\n            return Uint16Array;\n          case "int16":\n            return Int16Array;\n          case "int32":\n            return Int32Array;\n          case "bool":\n            return Uint8Array;\n          case "float64":\n            return Float64Array;\n          case "uint32":\n            return Uint32Array;\n          case "int64":\n            return BigInt64Array;\n          case "uint64":\n            return BigUint64Array;\n          default:\n            throw new Error(`unsupported type: ${type}`);\n        }\n      };\n      logLevelStringToEnum = (logLevel) => {\n        switch (logLevel) {\n          case "verbose":\n            return 0;\n          case "info":\n            return 1;\n          case "warning":\n            return 2;\n          case "error":\n            return 3;\n          case "fatal":\n            return 4;\n          default:\n            throw new Error(`unsupported logging level: ${logLevel}`);\n        }\n      };\n      isGpuBufferSupportedType = (type) => type === "float32" || type === "int32" || type === "int64" || type === "bool" || type === "float16" || type === "uint32";\n      dataLocationStringToEnum = (location) => {\n        switch (location) {\n          case "none":\n            return 0;\n          case "cpu":\n            return 1;\n          case "cpu-pinned":\n            return 2;\n          case "texture":\n            return 3;\n          case "gpu-buffer":\n            return 4;\n          default:\n            throw new Error(`unsupported data location: ${location}`);\n        }\n      };\n    }\n  });\n\n  // common/dist/esm/backend-impl.js\n  var init_backend_impl = __esm({\n    "common/dist/esm/backend-impl.js"() {\n      "use strict";\n    }\n  });\n\n  // common/dist/esm/backend.js\n  var init_backend = __esm({\n    "common/dist/esm/backend.js"() {\n      "use strict";\n      init_backend_impl();\n    }\n  });\n\n  // common/dist/esm/version.js\n  var version;\n  var init_version = __esm({\n    "common/dist/esm/version.js"() {\n      "use strict";\n      version = "1.17.1";\n    }\n  });\n\n  // common/dist/esm/env-impl.js\n  var logLevelValue, env;\n  var init_env_impl = __esm({\n    "common/dist/esm/env-impl.js"() {\n      "use strict";\n      init_version();\n      logLevelValue = "warning";\n      env = {\n        wasm: {},\n        webgl: {},\n        webgpu: {},\n        versions: { common: version },\n        set logLevel(value) {\n          if (value === void 0) {\n            return;\n          }\n          if (typeof value !== "string" || ["verbose", "info", "warning", "error", "fatal"].indexOf(value) === -1) {\n            throw new Error(`Unsupported logging level: ${value}`);\n          }\n          logLevelValue = value;\n        },\n        get logLevel() {\n          return logLevelValue;\n        }\n      };\n      Object.defineProperty(env, "logLevel", { enumerable: true });\n    }\n  });\n\n  // common/dist/esm/env.js\n  var env2;\n  var init_env = __esm({\n    "common/dist/esm/env.js"() {\n      "use strict";\n      init_env_impl();\n      env2 = env;\n    }\n  });\n\n  // common/dist/esm/tensor-conversion-impl.js\n  var init_tensor_conversion_impl = __esm({\n    "common/dist/esm/tensor-conversion-impl.js"() {\n      "use strict";\n    }\n  });\n\n  // common/dist/esm/tensor-factory-impl.js\n  var init_tensor_factory_impl = __esm({\n    "common/dist/esm/tensor-factory-impl.js"() {\n      "use strict";\n      init_tensor_impl();\n    }\n  });\n\n  // common/dist/esm/tensor-impl-type-mapping.js\n  var init_tensor_impl_type_mapping = __esm({\n    "common/dist/esm/tensor-impl-type-mapping.js"() {\n      "use strict";\n    }\n  });\n\n  // common/dist/esm/tensor-utils-impl.js\n  var init_tensor_utils_impl = __esm({\n    "common/dist/esm/tensor-utils-impl.js"() {\n      "use strict";\n      init_tensor_impl();\n    }\n  });\n\n  // common/dist/esm/tensor-impl.js\n  var init_tensor_impl = __esm({\n    "common/dist/esm/tensor-impl.js"() {\n      "use strict";\n      init_tensor_conversion_impl();\n      init_tensor_factory_impl();\n      init_tensor_impl_type_mapping();\n      init_tensor_utils_impl();\n    }\n  });\n\n  // common/dist/esm/tensor.js\n  var init_tensor = __esm({\n    "common/dist/esm/tensor.js"() {\n      "use strict";\n      init_tensor_impl();\n    }\n  });\n\n  // common/dist/esm/trace.js\n  var TRACE, TRACE_FUNC, TRACE_FUNC_BEGIN, TRACE_FUNC_END;\n  var init_trace = __esm({\n    "common/dist/esm/trace.js"() {\n      "use strict";\n      init_env_impl();\n      TRACE = (deviceType, label) => {\n        if (!env.wasm.trace) {\n          return;\n        }\n        console.timeStamp(`${deviceType}::ORT::${label}`);\n      };\n      TRACE_FUNC = (msg, extraMsg) => {\n        const stack = new Error().stack?.split(/\\r\\n|\\r|\\n/g) || [];\n        let hasTraceFunc = false;\n        for (let i = 0; i < stack.length; i++) {\n          if (hasTraceFunc && !stack[i].includes("TRACE_FUNC")) {\n            let label = `FUNC_${msg}::${stack[i].trim().split(" ")[1]}`;\n            if (extraMsg) {\n              label += `::${extraMsg}`;\n            }\n            TRACE("CPU", label);\n            return;\n          }\n          if (stack[i].includes("TRACE_FUNC")) {\n            hasTraceFunc = true;\n          }\n        }\n      };\n      TRACE_FUNC_BEGIN = (extraMsg) => {\n        if (!env.wasm.trace) {\n          return;\n        }\n        TRACE_FUNC("BEGIN", extraMsg);\n      };\n      TRACE_FUNC_END = (extraMsg) => {\n        if (!env.wasm.trace) {\n          return;\n        }\n        TRACE_FUNC("END", extraMsg);\n      };\n    }\n  });\n\n  // common/dist/esm/inference-session-impl.js\n  var init_inference_session_impl = __esm({\n    "common/dist/esm/inference-session-impl.js"() {\n      "use strict";\n      init_backend_impl();\n      init_tensor();\n      init_trace();\n    }\n  });\n\n  // common/dist/esm/inference-session.js\n  var init_inference_session = __esm({\n    "common/dist/esm/inference-session.js"() {\n      "use strict";\n      init_inference_session_impl();\n    }\n  });\n\n  // common/dist/esm/onnx-value.js\n  var init_onnx_value = __esm({\n    "common/dist/esm/onnx-value.js"() {\n      "use strict";\n    }\n  });\n\n  // common/dist/esm/training-session-impl.js\n  var init_training_session_impl = __esm({\n    "common/dist/esm/training-session-impl.js"() {\n      "use strict";\n      init_backend_impl();\n      init_tensor();\n    }\n  });\n\n  // common/dist/esm/training-session.js\n  var init_training_session = __esm({\n    "common/dist/esm/training-session.js"() {\n      "use strict";\n      init_training_session_impl();\n    }\n  });\n\n  // common/dist/esm/index.js\n  var init_esm = __esm({\n    "common/dist/esm/index.js"() {\n      "use strict";\n      init_backend();\n      init_env();\n      init_inference_session();\n      init_tensor();\n      init_trace();\n      init_onnx_value();\n      init_training_session();\n    }\n  });\n\n  // web/lib/wasm/jsep/log.ts\n  var logLevelPrefix, doLog, configLogLevel, debug, configureLogger, LOG, LOG_DEBUG;\n  var init_log = __esm({\n    "web/lib/wasm/jsep/log.ts"() {\n      "use strict";\n      init_wasm_common();\n      logLevelPrefix = ["V", "I", "W", "E", "F"];\n      doLog = (level, message) => {\n        console.log(`[${logLevelPrefix[level]},${(/* @__PURE__ */ new Date()).toISOString()}]${message}`);\n      };\n      configureLogger = ($configLogLevel, $debug) => {\n        configLogLevel = $configLogLevel;\n        debug = $debug;\n      };\n      LOG = (logLevel, msg) => {\n        const messageLevel = logLevelStringToEnum(logLevel);\n        const configLevel = logLevelStringToEnum(configLogLevel);\n        if (messageLevel >= configLevel) {\n          doLog(messageLevel, typeof msg === "function" ? msg() : msg);\n        }\n      };\n      LOG_DEBUG = (...args) => {\n        if (debug) {\n          LOG(...args);\n        }\n      };\n    }\n  });\n\n  // web/lib/wasm/jsep/tensor-view.ts\n  var createView;\n  var init_tensor_view = __esm({\n    "web/lib/wasm/jsep/tensor-view.ts"() {\n      "use strict";\n      init_wasm_common();\n      createView = (dataBuffer, type) => new (tensorTypeToTypedArrayConstructor(type))(dataBuffer);\n    }\n  });\n\n  // web/lib/wasm/jsep/webgpu/types.ts\n  var init_types = __esm({\n    "web/lib/wasm/jsep/webgpu/types.ts"() {\n      "use strict";\n    }\n  });\n\n  // web/lib/wasm/jsep/webgpu/gpu-data-manager.ts\n  var calcNormalizedBufferSize, guid, createNewGpuDataId, downloadGpuData, GpuDataManagerImpl, createGpuDataManager;\n  var init_gpu_data_manager = __esm({\n    "web/lib/wasm/jsep/webgpu/gpu-data-manager.ts"() {\n      "use strict";\n      init_log();\n      init_types();\n      calcNormalizedBufferSize = (size) => Math.ceil(size / 16) * 16;\n      guid = 1;\n      createNewGpuDataId = () => guid++;\n      downloadGpuData = async (backend, gpuBuffer, originalSize, getTargetBuffer) => {\n        const bufferSize = calcNormalizedBufferSize(originalSize);\n        const gpuReadBuffer = backend.device.createBuffer(\n          // eslint-disable-next-line no-bitwise\n          { size: bufferSize, usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ }\n        );\n        try {\n          const commandEncoder = backend.getCommandEncoder();\n          backend.endComputePass();\n          commandEncoder.copyBufferToBuffer(\n            gpuBuffer,\n            0,\n            gpuReadBuffer,\n            0,\n            bufferSize\n            /* size */\n          );\n          backend.flush();\n          await gpuReadBuffer.mapAsync(GPUMapMode.READ);\n          const arrayBuffer = gpuReadBuffer.getMappedRange();\n          if (getTargetBuffer) {\n            const targetBuffer = getTargetBuffer();\n            targetBuffer.set(new Uint8Array(arrayBuffer, 0, originalSize));\n            return targetBuffer;\n          } else {\n            return new Uint8Array(arrayBuffer.slice(0, originalSize));\n          }\n        } finally {\n          gpuReadBuffer.destroy();\n        }\n      };\n      GpuDataManagerImpl = class {\n        constructor(backend) {\n          this.backend = backend;\n          this.storageCache = /* @__PURE__ */ new Map();\n          this.freeBuffers = /* @__PURE__ */ new Map();\n          this.freeUniformBuffers = /* @__PURE__ */ new Map();\n          this.buffersForUploadingPending = [];\n          this.buffersPending = [];\n          this.externalBuffers = /* @__PURE__ */ new Map();\n        }\n        upload(id, data) {\n          const srcArrayBuffer = data.buffer;\n          const srcOffset = data.byteOffset;\n          const srcLength = data.byteLength;\n          const size = calcNormalizedBufferSize(srcLength);\n          const gpuDataCache = this.storageCache.get(id);\n          if (!gpuDataCache) {\n            throw new Error("gpu data for uploading does not exist");\n          }\n          if (gpuDataCache.originalSize !== srcLength) {\n            throw new Error(`inconsistent data size. gpu data size=${gpuDataCache.originalSize}, data size=${srcLength}`);\n          }\n          const gpuBufferForUploading = this.backend.device.createBuffer(\n            // eslint-disable-next-line no-bitwise\n            { mappedAtCreation: true, size, usage: GPUBufferUsage.MAP_WRITE | GPUBufferUsage.COPY_SRC }\n          );\n          const arrayBuffer = gpuBufferForUploading.getMappedRange();\n          new Uint8Array(arrayBuffer).set(new Uint8Array(srcArrayBuffer, srcOffset, srcLength));\n          gpuBufferForUploading.unmap();\n          const commandEncoder = this.backend.getCommandEncoder();\n          this.backend.endComputePass();\n          commandEncoder.copyBufferToBuffer(gpuBufferForUploading, 0, gpuDataCache.gpuData.buffer, 0, size);\n          LOG_DEBUG("verbose", () => `[WebGPU] GpuDataManager.upload(id=${id})`);\n          this.buffersForUploadingPending.push(gpuBufferForUploading);\n        }\n        memcpy(sourceId, destinationId) {\n          const sourceGpuDataCache = this.storageCache.get(sourceId);\n          if (!sourceGpuDataCache) {\n            throw new Error("source gpu data for memcpy does not exist");\n          }\n          const destinationGpuDataCache = this.storageCache.get(destinationId);\n          if (!destinationGpuDataCache) {\n            throw new Error("destination gpu data for memcpy does not exist");\n          }\n          if (sourceGpuDataCache.originalSize !== destinationGpuDataCache.originalSize) {\n            throw new Error("inconsistent source and destination gpu data size");\n          }\n          const size = calcNormalizedBufferSize(sourceGpuDataCache.originalSize);\n          const commandEncoder = this.backend.getCommandEncoder();\n          this.backend.endComputePass();\n          commandEncoder.copyBufferToBuffer(\n            sourceGpuDataCache.gpuData.buffer,\n            0,\n            destinationGpuDataCache.gpuData.buffer,\n            0,\n            size\n          );\n        }\n        registerExternalBuffer(buffer, originalSize, previousBuffer) {\n          let id;\n          if (previousBuffer) {\n            id = this.externalBuffers.get(previousBuffer);\n            if (id === void 0) {\n              throw new Error("previous buffer is not registered");\n            }\n            if (buffer === previousBuffer) {\n              LOG_DEBUG(\n                "verbose",\n                () => `[WebGPU] GpuDataManager.registerExternalBuffer(size=${originalSize}) => id=${id}, buffer is the same, skip.`\n              );\n              return id;\n            }\n            this.externalBuffers.delete(previousBuffer);\n          } else {\n            id = createNewGpuDataId();\n          }\n          this.storageCache.set(id, { gpuData: { id, type: 0 /* default */, buffer }, originalSize });\n          this.externalBuffers.set(buffer, id);\n          LOG_DEBUG(\n            "verbose",\n            () => `[WebGPU] GpuDataManager.registerExternalBuffer(size=${originalSize}) => id=${id}, registered.`\n          );\n          return id;\n        }\n        unregisterExternalBuffer(buffer) {\n          const id = this.externalBuffers.get(buffer);\n          if (id !== void 0) {\n            this.storageCache.delete(id);\n            this.externalBuffers.delete(buffer);\n            LOG_DEBUG("verbose", () => `[WebGPU] GpuDataManager.unregisterExternalBuffer() => id=${id}`);\n          }\n        }\n        // eslint-disable-next-line no-bitwise\n        create(size, usage = GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST) {\n          const bufferSize = calcNormalizedBufferSize(size);\n          let gpuBuffer;\n          const isStorage = (usage & GPUBufferUsage.STORAGE) === GPUBufferUsage.STORAGE;\n          const isUniform = (usage & GPUBufferUsage.UNIFORM) === GPUBufferUsage.UNIFORM;\n          if (isStorage || isUniform) {\n            const freeBuffers = isStorage ? this.freeBuffers : this.freeUniformBuffers;\n            let buffers = freeBuffers.get(bufferSize);\n            if (!buffers) {\n              buffers = [];\n              freeBuffers.set(bufferSize, buffers);\n            }\n            if (buffers.length > 0) {\n              gpuBuffer = buffers.pop();\n            } else {\n              gpuBuffer = this.backend.device.createBuffer({ size: bufferSize, usage });\n            }\n          } else {\n            gpuBuffer = this.backend.device.createBuffer({ size: bufferSize, usage });\n          }\n          const gpuData = { id: createNewGpuDataId(), type: 0 /* default */, buffer: gpuBuffer };\n          this.storageCache.set(gpuData.id, { gpuData, originalSize: size });\n          LOG_DEBUG("verbose", () => `[WebGPU] GpuDataManager.create(size=${size}) => id=${gpuData.id}`);\n          return gpuData;\n        }\n        get(id) {\n          return this.storageCache.get(id)?.gpuData;\n        }\n        release(id) {\n          const cachedData = this.storageCache.get(id);\n          if (!cachedData) {\n            throw new Error("releasing data does not exist");\n          }\n          LOG_DEBUG("verbose", () => `[WebGPU] GpuDataManager.release(id=${id}), gpuDataId=${cachedData.gpuData.id}`);\n          this.storageCache.delete(id);\n          this.buffersPending.push(cachedData.gpuData.buffer);\n          return cachedData.originalSize;\n        }\n        async download(id, getTargetBuffer) {\n          const cachedData = this.storageCache.get(id);\n          if (!cachedData) {\n            throw new Error("data does not exist");\n          }\n          await downloadGpuData(this.backend, cachedData.gpuData.buffer, cachedData.originalSize, getTargetBuffer);\n        }\n        refreshPendingBuffers() {\n          for (const buffer of this.buffersForUploadingPending) {\n            buffer.destroy();\n          }\n          this.buffersForUploadingPending = [];\n          for (const buffer of this.buffersPending) {\n            if ((buffer.usage & GPUBufferUsage.STORAGE) === GPUBufferUsage.STORAGE) {\n              this.freeBuffers.get(buffer.size).push(buffer);\n            } else if ((buffer.usage & GPUBufferUsage.UNIFORM) === GPUBufferUsage.UNIFORM) {\n              this.freeUniformBuffers.get(buffer.size).push(buffer);\n            } else {\n              buffer.destroy();\n            }\n          }\n          this.buffersPending = [];\n        }\n        dispose() {\n          this.freeBuffers.forEach((buffers) => {\n            buffers.forEach((buffer) => {\n              buffer.destroy();\n            });\n          });\n          this.freeUniformBuffers.forEach((buffers) => {\n            buffers.forEach((buffer) => {\n              buffer.destroy();\n            });\n          });\n          this.storageCache.forEach((storage) => {\n            storage.gpuData.buffer.destroy();\n          });\n          this.storageCache = /* @__PURE__ */ new Map();\n          this.freeBuffers = /* @__PURE__ */ new Map();\n          this.freeUniformBuffers = /* @__PURE__ */ new Map();\n        }\n      };\n      createGpuDataManager = (...args) => new GpuDataManagerImpl(...args);\n    }\n  });\n\n  // web/lib/wasm/jsep/webgpu/attribute-with-cache-key.ts\n  var AttributeWithCacheKeyImpl, createAttributeWithCacheKey;\n  var init_attribute_with_cache_key = __esm({\n    "web/lib/wasm/jsep/webgpu/attribute-with-cache-key.ts"() {\n      "use strict";\n      AttributeWithCacheKeyImpl = class {\n        constructor(attribute) {\n          Object.assign(this, attribute);\n        }\n        get cacheKey() {\n          if (!this.key) {\n            this.key = Object.getOwnPropertyNames(this).sort().map((name) => `${this[name]}`).join(";");\n          }\n          return this.key;\n        }\n      };\n      createAttributeWithCacheKey = (attribute) => new AttributeWithCacheKeyImpl(attribute);\n    }\n  });\n\n  // web/lib/wasm/jsep/util.ts\n  var MatMulUtil, BroadcastUtil, ShapeUtil, PoolConvUtil, GemmUtil, MIN_CLIP, MAX_CLIP;\n  var init_util = __esm({\n    "web/lib/wasm/jsep/util.ts"() {\n      "use strict";\n      MatMulUtil = class {\n        /**\n         * Calculate the expected shape when matrix multiplication\n         * @param a The shape of tensor A. Should be a tuple of 2 positive integers\n         * @param b The shape of tensor B. Should be a tuple of 2 positive integers\n         * @returns The expected shape of the result, or undefined if N/A\n         */\n        static calcMatMulShape(a, b) {\n          return a[1] !== b[0] ? void 0 : [a[0], b[1]];\n        }\n      };\n      BroadcastUtil = class {\n        /**\n         * Calculate the expected shape when broadcasting 2 tensors\n         * @param a The shape of tensor A. Should be an array of positive integers\n         * @param b The shape of tensor B. Should be an array of positive integers\n         * @param isMatMul Whether the operation is MatMul\n         * @returns The expected shape of the result, or undefined if N/A\n         */\n        static calcShape(adims, bdims, isMatMul = false) {\n          const arank = adims.length;\n          const brank = bdims.length;\n          if (arank === 0) {\n            return bdims;\n          }\n          if (brank === 0) {\n            return adims;\n          }\n          const crank = Math.max(adims.length, bdims.length);\n          const cdims = new Array(crank);\n          if (isMatMul) {\n            if (arank < 2 || brank < 2) {\n              return void 0;\n            }\n            const cShapeMatMul = MatMulUtil.calcMatMulShape([adims[arank - 2], adims[arank - 1]], [bdims[brank - 2], bdims[brank - 1]]);\n            if (cShapeMatMul === void 0) {\n              return void 0;\n            }\n            [cdims[crank - 2], cdims[crank - 1]] = cShapeMatMul;\n          }\n          for (let i = isMatMul ? 3 : 1; i <= crank; i++) {\n            const aLen = arank - i < 0 ? 1 : adims[arank - i];\n            const bLen = brank - i < 0 ? 1 : bdims[brank - i];\n            if (aLen !== bLen && aLen > 1 && bLen > 1) {\n              return void 0;\n            }\n            cdims[crank - i] = Math.max(aLen, bLen);\n          }\n          return cdims;\n        }\n        /**\n         * Determine if a shape is unidirectional broadcastable to another shape\n         * @param shape The input shape\n         * @param finalShape The desired shape after broadcasting\n         */\n        static isValidBroadcast(shape, finalShape) {\n          const inputRank = shape.length;\n          const finalRank = finalShape.length;\n          if (inputRank > finalRank) {\n            return false;\n          }\n          for (let i = 1; i <= inputRank; i++) {\n            if (shape[inputRank - i] !== 1 && shape[inputRank - i] !== finalShape[finalRank - i]) {\n              return false;\n            }\n          }\n          return true;\n        }\n      };\n      ShapeUtil = class _ShapeUtil {\n        /**\n         * calculate the size (number of elements)\n         */\n        static size(dims) {\n          return _ShapeUtil.getSizeFromDimensionRange(dims, 0, dims.length);\n        }\n        /**\n         * calculate the size (number of elements) from the given axis (inclusive)\n         */\n        static sizeFromDimension(dims, axis) {\n          if (axis < 0 || axis > dims.length) {\n            throw new Error(`invalid dimension of ${axis} for sizeFromDimension as Tensor has ${dims.length} dimensions.`);\n          }\n          return _ShapeUtil.getSizeFromDimensionRange(dims, axis, dims.length);\n        }\n        /**\n         * calculate the size (number of elements) to the given axis (exclusive)\n         */\n        static sizeToDimension(dims, axis) {\n          if (axis < 0 || axis > dims.length) {\n            throw new Error(`invalid dimension of ${axis} for sizeToDimension as Tensor has ${dims.length} dimensions.`);\n          }\n          return _ShapeUtil.getSizeFromDimensionRange(dims, 0, axis);\n        }\n        /**\n         * calculate the size (number of elements) from and to the given axis [start, end)\n         */\n        static getSizeFromDimensionRange(dims, start, end) {\n          let size = 1;\n          for (let i = start; i < end; i++) {\n            if (dims[i] < 0) {\n              throw new Error(\n                // eslint-disable-next-line max-len\n                "cannot get valid size from specified dimension range. Most likely the range contains negative values in them."\n              );\n            }\n            size *= dims[i];\n          }\n          return size;\n        }\n        static computeStrides(dims) {\n          const rank = dims.length;\n          if (rank === 0) {\n            return [];\n          } else if (rank === 1) {\n            return [1];\n          }\n          const strides = new Array(rank);\n          strides[rank - 1] = 1;\n          strides[rank - 2] = dims[rank - 1];\n          for (let i = rank - 3; i >= 0; --i) {\n            strides[i] = strides[i + 1] * dims[i + 1];\n          }\n          return strides;\n        }\n        /**\n         * normailze axis of range [-r, r) into [0, r).\n         */\n        static normalizeAxis(axis, tensorRank) {\n          if (axis < -tensorRank && axis >= tensorRank) {\n            throw new Error("unsupported axis for this operation.");\n          }\n          return axis < 0 ? axis + tensorRank : axis;\n        }\n        static normalizeAxes(axes, tensorRank) {\n          return axes.map((x) => this.normalizeAxis(x, tensorRank ?? axes.length));\n        }\n        /**\n         * Sorts a given array based on the indices in the Perm array\n         * Used in Transpose\n         * @param a Array to be sorted such as dims or strides\n         * @param perm Perm given; if null a will be reversed\n         */\n        static sortBasedOnPerm(a, perm) {\n          if (perm) {\n            return perm.map((v) => a[v]);\n          } else {\n            return a.slice().reverse();\n          }\n        }\n        /**\n         * Pads a given shape according to the padding values\n         * @param dims shape of the Tensor to be padded\n         * @param pad pad values\n         */\n        static padShape(dims, pad2) {\n          const rank = dims.length;\n          return dims.map((v, i) => v + pad2[i] + pad2[i + rank]);\n        }\n        /**\n         * Determines if the two shapes are identical\n         * @param shape1\n         * @param shape2\n         */\n        static areEqual(shape1, shape2) {\n          if (shape1.length !== shape2.length) {\n            return false;\n          }\n          return shape1.every((v, i) => v === shape2[i]);\n        }\n      };\n      PoolConvUtil = class _PoolConvUtil {\n        /**\n         * Adjust the kernel, strides, pads to correct rank. Set to default value if not present\n         * @param isGlobalOperator If true, perform global pooling.\n         * @param inputDims The input tensor dimension.\n         * @param kernelShape The size of the kernel along each axis.\n         * @param strides Stride along each axis.\n         * @param dilations Dilation along each axis.\n         * @param pads Padding for the beginning and ending along each axis.\n         */\n        static adjustPoolAttributes(isGlobalOperator, inputDims, kernelShape, strides, dilations, pads) {\n          if (!isGlobalOperator && kernelShape.length !== inputDims.length - 2) {\n            throw new Error("length of specified kernel shapes should be 2 less than length of input dimensions");\n          }\n          if (isGlobalOperator) {\n            for (let dim = 0; dim < inputDims.length - 2; dim++) {\n              if (dim >= kernelShape.length) {\n                kernelShape.push(inputDims[dim + 2]);\n              } else {\n                kernelShape[dim] = inputDims[dim + 2];\n              }\n            }\n          }\n          for (let dim = 0; dim < kernelShape.length; dim++) {\n            if (dim < strides.length) {\n              if (strides[dim] < 0) {\n                throw new Error("strides should be greater than or equal to 1");\n              }\n            } else {\n              strides.push(1);\n            }\n          }\n          for (let dim = 0; dim < kernelShape.length; dim++) {\n            if (dim < dilations.length) {\n              if (dilations[dim] < 0) {\n                throw new Error("dilations should be greater than or equal to 1");\n              }\n            } else {\n              dilations.push(1);\n            }\n          }\n          for (let dim = 0; dim < kernelShape.length * 2; dim++) {\n            if (dim < pads.length) {\n              if (pads[dim] < 0) {\n                throw new Error("pad should be greater than or equal to 1");\n              }\n            } else {\n              pads.push(0);\n            }\n          }\n          for (let dim = 0; dim < kernelShape.length; dim++) {\n            if (kernelShape[dim] <= 0) {\n              throw new Error("kernel shapes need to be greater than 0");\n            }\n            if (pads[dim] >= kernelShape[dim] || pads[dim + kernelShape.length] >= kernelShape[dim]) {\n              throw new Error("pads should be smaller than kernel");\n            }\n          }\n        }\n        // adjust pad values based on \'autoPad\' attribute\n        static adjustPadsBasedOnAutoPad(inputDims, strides, dilations, kernelShape, pads, isChannelLast, autoPad) {\n          if (!autoPad) {\n            return;\n          }\n          if (pads.length !== 2 * (inputDims.length - 2)) {\n            throw new Error("length of pads should be twice the length of data dimensions");\n          }\n          if (strides.length !== inputDims.length - 2) {\n            throw new Error("length of strides should be the length of data dimensions");\n          }\n          if (kernelShape.length !== inputDims.length - 2) {\n            throw new Error("length of kernel shapes should be the length of data dimensions");\n          }\n          for (let dim = 0; dim < inputDims.length - 2; dim++) {\n            _PoolConvUtil.adjustPadAndReturnShape(\n              inputDims[dim + (isChannelLast ? 1 : 2)],\n              strides[dim],\n              dilations[dim],\n              kernelShape[dim],\n              pads,\n              dim,\n              dim + inputDims.length - 2,\n              autoPad\n            );\n          }\n        }\n        /**\n         * Calculate the output shape for Pool ops based on input attributes. (Should be used only for Pool ops)\n         * @param isGlobalOperator If true, perform global pooling.\n         * @param inputDims The input tensor dimension. (inputs[0].dims)\n         * @param strides Stride along each axis.\n         * @param dilations Dilation along each axis.\n         * @param kernelShape The size of the kernel along each axis.\n         * @param pads Padding for the beginning and ending along each axis.\n         * @param autoPad DEPRECATED attribute supported for legacy models. Specifies how to implicitly calculate pads in each\n         *     dimension. Can take values NOTSET, SAME_UPPER, SAME_LOWER, or VALID.\n         */\n        static computePoolOutputShape(isGlobalOperator, inputDims, strides, dilations, kernelShape, pads, autoPad) {\n          if (inputDims.length <= 0) {\n            throw new Error("input shape must be of size greater than 0");\n          }\n          const outputDims = [inputDims[0], inputDims[1]];\n          _PoolConvUtil.computeShapeHelper(\n            isGlobalOperator,\n            inputDims,\n            outputDims,\n            strides,\n            dilations,\n            kernelShape,\n            pads,\n            autoPad\n          );\n          return outputDims;\n        }\n        /**\n         * Calculate the output shape for Conv op based on input attributes. (Should be used only for Conv op)\n         * @param inputDims The input tensor dimension. (inputs[0].dims)\n         * @param filterDims The filter tensor dimension. (inputs[1].dims)\n         * @param strides Stride along each axis.\n         * @param kernelShape The size of the kernel along each axis.\n         * @param pads Padding for the beginning and ending along each axis.\n         * @param autoPad DEPRECATED attribute supported for legacy models. Specifies how to implicitly calculate pads in each\n         *     dimension. Can take values NOTSET, SAME_UPPER, SAME_LOWER, or VALID.\n         */\n        static computeConvOutputShape(inputDims, filterDims, strides, dilations, kernelShape, pads, autoPad) {\n          if (inputDims.length <= 0 || filterDims.length <= 0) {\n            throw new Error("invalid input tensor dims or invalid filter tensor dims");\n          }\n          const outputDims = [inputDims[0], filterDims[0]];\n          _PoolConvUtil.computeShapeHelper(false, inputDims, outputDims, strides, dilations, kernelShape, pads, autoPad);\n          return outputDims;\n        }\n        // will compute output shapes for data dimensions ONLY (i.e.) no batch size and channels\n        // called by computePoolOutputShape() and computeConvOutputShape()\n        // adjust pads based on \'autoPad\' attribute prior to shape computation\n        static computeShapeHelper(isGlobalOperator, inputDims, outputDims, strides, dilations, kernelShape, pads, autoPad) {\n          if (isGlobalOperator) {\n            for (let dim = 0; dim < inputDims.length - 2; dim++) {\n              outputDims.push(1);\n            }\n          } else {\n            for (let dim = 0; dim < inputDims.length - 2; dim++) {\n              outputDims.push(_PoolConvUtil.adjustPadAndReturnShape(\n                inputDims[dim + 2],\n                strides[dim],\n                dilations[dim],\n                kernelShape[dim],\n                pads,\n                dim,\n                dim + inputDims.length - 2,\n                autoPad\n              ));\n            }\n          }\n        }\n        // helper for computeShapeHelper() and adjustPadsBasedOnAutoPad()\n        // adjusts pad value for given \'autoPad\' string and computes output shape along a particular dimension\n        static adjustPadAndReturnShape(inSize, stride, dilation, kernel, pads, padHeadIndex, padTailIndex, autoPad) {\n          const dkernel = dilation * (kernel - 1) + 1;\n          if (autoPad && autoPad !== "NOTSET") {\n            switch (autoPad) {\n              case "VALID":\n                pads[padHeadIndex] = 0;\n                pads[padTailIndex] = 0;\n                return Math.floor((inSize - dkernel) / stride + 1);\n              case "SAME_LOWER":\n              case "SAME_UPPER":\n                if (dilation !== 1) {\n                  throw new Error("Dilation not supported for SAME_UPPER or SAME_LOWER");\n                } else {\n                  const legacyTargetSize = (inSize + stride - 1) / stride;\n                  const padNeeded = (legacyTargetSize - 1) * stride + kernel - inSize;\n                  pads[padHeadIndex] = autoPad === "SAME_LOWER" ? Math.floor((padNeeded + 1) / 2) : Math.floor(padNeeded / 2);\n                  pads[padTailIndex] = padNeeded - pads[padHeadIndex];\n                  return Math.floor((inSize + padNeeded - kernel) / stride + 1);\n                }\n              default:\n                throw new Error("Unsupported AutoPad type");\n            }\n          } else {\n            return Math.floor((inSize + pads[padHeadIndex] + pads[padTailIndex] - dkernel) / stride + 1);\n          }\n        }\n      };\n      GemmUtil = class {\n        // will make sure input shapes are compatible for this op\n        // and return back the shape of the output in the form of a tuple\n        // will throw exception if the input shapes are not compatible\n        static getShapeOfGemmResult(leftShape, transLeft, rightShape, transRight, biasShape) {\n          if (leftShape.length !== 2 || rightShape.length !== 2) {\n            throw new Error("shape need to be of size 2");\n          }\n          let M;\n          let K;\n          let N;\n          if (transLeft) {\n            M = leftShape[1];\n            K = leftShape[0];\n          } else {\n            M = leftShape[0];\n            K = leftShape[1];\n          }\n          let kDim = -1;\n          if (transRight) {\n            N = rightShape[0];\n            kDim = 1;\n          } else {\n            N = rightShape[1];\n            kDim = 0;\n          }\n          if (rightShape[kDim] !== K) {\n            throw new Error("dimension mismatch");\n          }\n          if (M <= 0 || N <= 0 || K <= 0) {\n            throw new Error("invalid shape specified");\n          }\n          if (biasShape && !BroadcastUtil.isValidBroadcast(biasShape, [M, N])) {\n            throw new Error("gemm: invalid bias shape for broadcast");\n          }\n          return [M, N, K];\n        }\n      };\n      MIN_CLIP = -34028234663852886e22;\n      MAX_CLIP = 34028234663852886e22;\n    }\n  });\n\n  // web/lib/wasm/jsep/webgpu/ops/common.ts\n  var WORKGROUP_SIZE, getWgslMappedType, tensorTypeToWsglStorageType, tensorTypeToWsglValueType, createTensorShapeVariables, getMaxComponents, fillVector, castToF32, sumVector, getElementAt, createIndicesHelper, inputVariable, outputVariable, internalVariable, ShaderHelperImpl, createShaderHelper, getBroadcastDims, enableShapesUniforms;\n  var init_common = __esm({\n    "web/lib/wasm/jsep/webgpu/ops/common.ts"() {\n      "use strict";\n      init_wasm_common();\n      init_util();\n      WORKGROUP_SIZE = 64;\n      getWgslMappedType = (type, components) => {\n        if (components === 3) {\n          throw new Error("vec3 has same alignment as vec4, use vec4 instead");\n        }\n        switch (type) {\n          case 10 /* float16 */:\n            return components > 1 ? `vec${components}<f16>` : "f16";\n          case 1 /* float */:\n            return components > 1 ? `vec${components}<f32>` : "f32";\n          case 6 /* int32 */:\n            return components > 1 ? `vec${components}<i32>` : "i32";\n          case 12 /* uint32 */:\n            return components > 1 ? `vec${components}<u32>` : "u32";\n          case 7 /* int64 */:\n            if (components > 1) {\n              throw new Error("currently not supported vecX of uint64 yet");\n            }\n            return ["vec2<u32>", "i32"];\n          case 13 /* uint64 */:\n            if (components > 1) {\n              throw new Error("currently not supported vecX of uint64 yet");\n            }\n            return ["vec2<u32>", "u32"];\n          case 9 /* bool */:\n            if (components !== 4) {\n              throw new Error("bool must be vec4");\n            }\n            return ["u32", "vec4<bool>"];\n          default:\n            throw new Error(`Unknown data type: ${type}`);\n        }\n      };\n      tensorTypeToWsglStorageType = (type, components = 1) => {\n        const mappedType = getWgslMappedType(type, components);\n        return typeof mappedType === "string" ? mappedType : mappedType[0];\n      };\n      tensorTypeToWsglValueType = (type, components = 1) => {\n        const mappedType = getWgslMappedType(type, components);\n        return typeof mappedType === "string" ? mappedType : mappedType[1];\n      };\n      createTensorShapeVariables = (dims) => dims.length === 0 ? [] : [{ type: "uint32", data: dims }, { type: "uint32", data: ShapeUtil.computeStrides(dims) }];\n      getMaxComponents = (size) => {\n        if (size % 4 === 0) {\n          return 4;\n        } else if (size % 2 === 0) {\n          return 2;\n        }\n        return 1;\n      };\n      fillVector = (dataType = "f32", components, value = "0") => {\n        if (!components || components === 1) {\n          return `${dataType}(${value})`;\n        }\n        return `vec${components}<${dataType}>(${value})`;\n      };\n      castToF32 = (dataType, components, value) => {\n        if (dataType === "f32") {\n          return value;\n        }\n        if (components === 1) {\n          return `f32(${value})`;\n        }\n        return `vec${components}f(${value})`;\n      };\n      sumVector = (name, components) => {\n        if (components === 4) {\n          return `(${name}.x + ${name}.y + ${name}.z + ${name}.w)`;\n        } else if (components === 2) {\n          return `(${name}.x + ${name}.y)`;\n        } else if (components === 3) {\n          return `(${name}.x + ${name}.y + ${name}.z)`;\n        }\n        return name;\n      };\n      getElementAt = (name, index, length) => {\n        if (name.startsWith("uniforms.") && length > 4) {\n          if (typeof index === "string") {\n            return `${name}[(${index}) / 4][(${index}) % 4]`;\n          } else {\n            return `${name}[${Math.floor(index / 4)}][${index % 4}]`;\n          }\n        } else {\n          return length > 1 ? `${name}[${index}]` : name;\n        }\n      };\n      createIndicesHelper = (name, tensorType, shapeOrRank, usage, components) => {\n        const useUniform = typeof shapeOrRank === "number";\n        const rank = useUniform ? shapeOrRank : shapeOrRank.length;\n        const rankIdentity = [...new Array(rank).keys()];\n        const indicesType = rank < 2 ? "u32" : rank <= 4 ? `vec${rank}<u32>` : `array<u32, ${rank}>`;\n        const mappedType = getWgslMappedType(tensorType, components);\n        const valueType = typeof mappedType === "string" ? mappedType : mappedType[1];\n        const storageType = typeof mappedType === "string" ? mappedType : mappedType[0];\n        const type = { indices: indicesType, value: valueType, storage: storageType, tensor: tensorType };\n        const normalizeDim = (dim) => typeof dim === "string" ? dim : `${dim}u`;\n        const implementationUsed = {\n          offsetToIndices: false,\n          indicesToOffset: false,\n          broadcastedIndicesToOffset: false,\n          set: false,\n          setByIndices: false,\n          get: false,\n          getByIndices: false\n        };\n        const uniformPrefix = useUniform ? "uniforms." : "";\n        const shape = `${uniformPrefix}${name}_shape`;\n        const strides = `${uniformPrefix}${name}_strides`;\n        let o2iSnippet = "";\n        for (let i = 0; i < rank - 1; i++) {\n          o2iSnippet += `\n    let dim${i} = current / ${getElementAt(strides, i, rank)};\n    let rest${i} = current % ${getElementAt(strides, i, rank)};\n    indices[${i}] = dim${i};\n    current = rest${i};\n    `;\n        }\n        o2iSnippet += `indices[${rank - 1}] = current;`;\n        const offsetToIndicesImplementation = rank < 2 ? "" : `\n  fn o2i_${name}(offset: u32) -> ${type.indices} {\n    var indices: ${type.indices};\n    var current = offset;\n    ${o2iSnippet}\n    return indices;\n  }`;\n        const offsetToIndices = (varOffset) => {\n          implementationUsed.offsetToIndices = true;\n          return rank < 2 ? varOffset : `o2i_${name}(${varOffset})`;\n        };\n        const offsets = [];\n        if (rank >= 2) {\n          for (let i = rank - 1; i >= 0; i--) {\n            offsets.push(`${getElementAt(strides, i, rank)} * (indices[${i}])`);\n          }\n        }\n        const indicesToOffsetImplementation = rank < 2 ? "" : `\n  fn i2o_${name}(indices: ${type.indices}) -> u32 {\n    return ${offsets.join("+")};\n  }`;\n        const indicesToOffset = (varIndices) => {\n          implementationUsed.indicesToOffset = true;\n          return rank < 2 ? varIndices : `i2o_${name}(${varIndices})`;\n        };\n        const indices = (...init2) => rank === 0 ? "0u" : `${type.indices}(${init2.map(normalizeDim).join(",")})`;\n        const indicesGet = (varIndices, idx) => {\n          if (rank < 2) {\n            return `${varIndices}`;\n          } else {\n            return `${getElementAt(varIndices, idx, rank)}`;\n          }\n        };\n        const indicesSet = (varIndices, idx, value) => {\n          if (rank < 2) {\n            return `${varIndices}=${value};`;\n          } else {\n            return `${getElementAt(varIndices, idx, rank)}=${value};`;\n          }\n        };\n        const broadcastedIndicesToOffsetImplementation = {};\n        const broadcastedIndicesToOffset = (varIndices, output) => {\n          implementationUsed.broadcastedIndicesToOffset = true;\n          const implKey = `${output.name}broadcastedIndicesTo${name}Offset`;\n          if (implKey in broadcastedIndicesToOffsetImplementation) {\n            return `${implKey}(${varIndices})`;\n          }\n          const offsets2 = [];\n          for (let i = rank - 1; i >= 0; i--) {\n            const idx = output.indicesGet("outputIndices", i + output.rank - rank);\n            offsets2.push(`${indicesGet(strides, i)} * (${idx} % ${indicesGet(shape, i)})`);\n          }\n          broadcastedIndicesToOffsetImplementation[implKey] = `fn ${implKey}(outputIndices: ${output.type.indices}) -> u32 {\n             return ${offsets2.length > 0 ? offsets2.join("+") : "0u"};\n           }`;\n          return `${implKey}(${varIndices})`;\n        };\n        const setByOffset = (offset, value) => (() => {\n          if (type.storage === type.value) {\n            return `${name}[${offset}]=${value};`;\n          } else if (type.storage === "vec2<u32>" && type.value === "i32") {\n            return `${name}[${offset}]=vec2<u32>(u32(${value}), select(0u, 0xFFFFFFFFu, ${value} < 0));`;\n          } else if (type.storage === "vec2<u32>" && type.value === "u32") {\n            return `${name}[${offset}]=vec2<u32>(u32(${value}), 0u);`;\n          } else if (type.storage === "u32" && type.value === "vec4<bool>") {\n            return `${name}[${offset}]=dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(${value}));`;\n          } else {\n            throw new Error(`not supported combination of storage type ${type.storage} and value type ${type.value} yet`);\n          }\n        })();\n        const getByOffset = (offset) => (() => {\n          if (type.storage === type.value) {\n            return `${name}[${offset}]`;\n          } else if (type.storage === "vec2<u32>" && type.value === "i32") {\n            return `i32(${name}[${offset}].x)`;\n          } else if (type.storage === "vec2<u32>" && type.value === "u32") {\n            return `u32(${name}[${offset}].x)`;\n          } else if (type.storage === "u32" && type.value === "vec4<bool>") {\n            return `vec4<bool>(bool(${name}[${offset}] & 0xFFu), bool(${name}[${offset}] & 0xFF00u), bool(${name}[${offset}] & 0xFF0000u), bool(${name}[${offset}] & 0xFF000000u))`;\n          } else {\n            throw new Error(`not supported combination of storage type ${type.storage} and value type ${type.value} yet`);\n          }\n        })();\n        const getByIndicesImplementation = rank < 2 ? "" : `\n  fn get_${name}ByIndices(indices: ${type.indices}) -> ${valueType} {\n    return ${getByOffset(`i2o_${name}(indices)`)};\n  }`;\n        const getImplementation = rank < 2 ? "" : (() => {\n          const functionParams = rankIdentity.map((i) => `d${i}: u32`).join(", ");\n          const dimsParams = rankIdentity.map((i) => `d${i}`).join(", ");\n          return `\n  fn get_${name}(${functionParams}) -> ${valueType} {\n    return get_${name}ByIndices(${indices(dimsParams)});\n  }`;\n        })();\n        const get = (...indices2) => {\n          if (indices2.length !== rank) {\n            throw new Error(`indices length must be ${rank}`);\n          }\n          const normalizedIndices = indices2.map(normalizeDim).join(",");\n          if (rank === 0) {\n            return getByOffset("0u");\n          } else if (rank === 1) {\n            return getByOffset(normalizedIndices[0]);\n          } else {\n            implementationUsed.get = true;\n            implementationUsed.getByIndices = true;\n            implementationUsed.indicesToOffset = true;\n            return `get_${name}(${normalizedIndices})`;\n          }\n        };\n        const getByIndices = (varIndices) => {\n          if (rank < 2) {\n            return getByOffset(varIndices);\n          } else {\n            implementationUsed.getByIndices = true;\n            implementationUsed.indicesToOffset = true;\n            return `get_${name}ByIndices(${varIndices})`;\n          }\n        };\n        const setByIndicesImplementation = rank < 2 ? "" : `\n  fn set_${name}ByIndices(indices: ${type.indices}, value: ${valueType}) {\n    ${setByOffset(`i2o_${name}(indices)`, "value")}\n  }`;\n        const setImplementation = rank < 2 ? "" : (() => {\n          const functionParams = rankIdentity.map((i) => `d${i}: u32`).join(", ");\n          const dimsParams = rankIdentity.map((i) => `d${i}`).join(", ");\n          return `\n  fn set_${name}(${functionParams}, value: ${valueType}) {\n    set_${name}ByIndices(${indices(dimsParams)}, value);\n  }`;\n        })();\n        const set = (...indicesAndValue) => {\n          if (indicesAndValue.length !== rank + 1) {\n            throw new Error(`indices length must be ${rank}`);\n          }\n          const value = indicesAndValue[rank];\n          if (typeof value !== "string") {\n            throw new Error("value must be string");\n          }\n          const normalizedIndices = indicesAndValue.slice(0, rank).map(normalizeDim).join(",");\n          if (rank === 0) {\n            return setByOffset("0u", value);\n          } else if (rank === 1) {\n            return setByOffset(normalizedIndices[0], value);\n          } else {\n            implementationUsed.set = true;\n            implementationUsed.setByIndices = true;\n            implementationUsed.indicesToOffset = true;\n            return `set_${name}(${normalizedIndices}, ${value})`;\n          }\n        };\n        const setByIndices = (varIndices, value) => {\n          if (rank < 2) {\n            return setByOffset(varIndices, value);\n          } else {\n            implementationUsed.setByIndices = true;\n            implementationUsed.indicesToOffset = true;\n            return `set_${name}ByIndices(${varIndices}, ${value});`;\n          }\n        };\n        const impl = () => {\n          const impls = [];\n          let needShapeStrides = false;\n          if (implementationUsed.offsetToIndices) {\n            impls.push(offsetToIndicesImplementation);\n            needShapeStrides = true;\n          }\n          if (implementationUsed.indicesToOffset) {\n            impls.push(indicesToOffsetImplementation);\n            needShapeStrides = true;\n          }\n          if (implementationUsed.broadcastedIndicesToOffset) {\n            Object.values(broadcastedIndicesToOffsetImplementation).forEach((impl2) => impls.push(impl2));\n            needShapeStrides = true;\n          }\n          if (implementationUsed.set) {\n            impls.push(setImplementation);\n            needShapeStrides = true;\n          }\n          if (implementationUsed.setByIndices) {\n            impls.push(setByIndicesImplementation);\n            needShapeStrides = true;\n          }\n          if (implementationUsed.get) {\n            impls.push(getImplementation);\n            needShapeStrides = true;\n          }\n          if (implementationUsed.getByIndices) {\n            impls.push(getByIndicesImplementation);\n            needShapeStrides = true;\n          }\n          if (!useUniform && needShapeStrides) {\n            impls.unshift(\n              `const ${shape} = ${type.indices}(${shapeOrRank.join(",")});`,\n              `const ${strides} = ${type.indices}(${ShapeUtil.computeStrides(shapeOrRank).join(",")});`\n            );\n          }\n          return impls.join("\\n");\n        };\n        return {\n          impl,\n          type,\n          offsetToIndices,\n          indicesToOffset,\n          broadcastedIndicesToOffset,\n          indices,\n          indicesGet,\n          indicesSet,\n          set,\n          setByOffset,\n          setByIndices,\n          get,\n          getByOffset,\n          getByIndices,\n          // isVec4,\n          usage,\n          name,\n          strides,\n          shape,\n          rank\n        };\n      };\n      inputVariable = (name, type, shapeOrRank, components = 1) => createIndicesHelper(name, type, shapeOrRank, "input", components);\n      outputVariable = (name, type, shapeOrRank, components = 1) => createIndicesHelper(name, type, shapeOrRank, "output", components);\n      internalVariable = (name, type, shapeOrRank, components = 1) => createIndicesHelper(name, type, shapeOrRank, "internal", components);\n      ShaderHelperImpl = class {\n        constructor(normalizedDispatchGroup) {\n          this.normalizedDispatchGroup = normalizedDispatchGroup;\n          this.internalVariables = [];\n          this.variables = [];\n          this.uniforms = [];\n          this.variableIndex = 0;\n        }\n        guardAgainstOutOfBoundsWorkgroupSizes(size) {\n          const sizeInCode = typeof size === "number" ? `${size}u` : size;\n          return `if (global_idx >= ${sizeInCode}) { return; }`;\n        }\n        mainStart(workgroupSize = WORKGROUP_SIZE) {\n          const workgroupSizeX = typeof workgroupSize === "number" ? workgroupSize : workgroupSize[0];\n          const workgroupSizeY = typeof workgroupSize === "number" ? 1 : workgroupSize[1];\n          const workgroupSizeZ = typeof workgroupSize === "number" ? 1 : workgroupSize[2];\n          const is1DimensionDispatch = this.normalizedDispatchGroup[1] === 1 && this.normalizedDispatchGroup[2] === 1;\n          const paramList = is1DimensionDispatch ? `@builtin(global_invocation_id) global_id : vec3<u32>,\n    @builtin(workgroup_id) workgroup_id : vec3<u32>,\n    @builtin(local_invocation_id) local_id : vec3<u32>` : `@builtin(local_invocation_id) local_id : vec3<u32>,\n    @builtin(local_invocation_index) local_idx : u32,\n    @builtin(workgroup_id) workgroup_id : vec3<u32>,\n    @builtin(num_workgroups) num_workgroups : vec3<u32>`;\n          const globalIdxDefinition = is1DimensionDispatch ? "let global_idx = global_id.x; let local_idx = local_id.x;" : `let global_idx = (workgroup_id.z * num_workgroups[0] * num_workgroups[1] +\n          workgroup_id.y * num_workgroups[0] + workgroup_id.x) * ${workgroupSizeX * workgroupSizeY * workgroupSizeZ}u + local_idx;`;\n          return `@compute @workgroup_size(${workgroupSizeX}, ${workgroupSizeY}, ${workgroupSizeZ})\n  fn main(${paramList}) {\n    ${globalIdxDefinition}\n  `;\n        }\n        appendVariableUniforms(variable) {\n          if (variable.rank !== 0) {\n            if (variable.shape.startsWith("uniforms.")) {\n              this.uniforms.push({ name: variable.shape.replace("uniforms.", ""), type: "u32", length: variable.rank });\n            }\n            if (variable.strides.startsWith("uniforms.")) {\n              this.uniforms.push({ name: variable.strides.replace("uniforms.", ""), type: "u32", length: variable.rank });\n            }\n          }\n        }\n        declareVariable(variable, bindingIndex) {\n          if (variable.usage === "internal") {\n            throw new Error("cannot use internal variable with declareVariable(). use registerInternalVariables() instead.");\n          }\n          this.variables.push(variable);\n          this.appendVariableUniforms(variable);\n          const access = variable.usage === "input" ? "read" : "read_write";\n          const storageType = variable.type.storage;\n          return `@group(0) @binding(${bindingIndex}) var<storage, ${access}> ${variable.name}: array<${storageType}>;`;\n        }\n        declareVariables(...variables) {\n          return variables.map((v) => this.declareVariable(v, this.variableIndex++)).join("\\n");\n        }\n        registerInternalVariable(variable) {\n          if (variable.usage !== "internal") {\n            throw new Error(\n              "cannot use input or output variable with registerInternalVariable(). use declareVariables() instead."\n            );\n          }\n          this.internalVariables.push(variable);\n          this.appendVariableUniforms(variable);\n        }\n        registerInternalVariables(...variables) {\n          variables.forEach((v) => this.registerInternalVariable(v));\n          return this;\n        }\n        registerUniform(name, type, length = 1) {\n          this.uniforms.push({ name, type, length });\n          return this;\n        }\n        registerUniforms(additionalUniforms) {\n          this.uniforms = this.uniforms.concat(additionalUniforms);\n          return this;\n        }\n        uniformDeclaration() {\n          if (this.uniforms.length === 0) {\n            return "";\n          }\n          const uniformSnippets = [];\n          for (const { name, type, length } of this.uniforms) {\n            if (length && length > 4) {\n              uniformSnippets.push(`${name}:array<vec4<${type}>, ${Math.ceil(length / 4)}>`);\n            } else {\n              const typeTemp = length == null || length === 1 ? type : `vec${length}<${type}>`;\n              uniformSnippets.push(`${name}:${typeTemp}`);\n            }\n          }\n          return `\n      struct Uniforms { ${uniformSnippets.join(", ")} };\n      @group(0) @binding(${this.variableIndex}) var<uniform> uniforms: Uniforms;`;\n        }\n        /**\n         * Get additional implementation that needs to be added to the shader source.\n         */\n        get additionalImplementations() {\n          return this.uniformDeclaration() + this.variables.map((i) => i.impl()).join("\\n") + this.internalVariables.map((i) => i.impl()).join("\\n");\n        }\n      };\n      createShaderHelper = (dispatchGroup) => new ShaderHelperImpl(dispatchGroup);\n      getBroadcastDims = (inShape, outShape) => {\n        const inRank = inShape.length;\n        const dims = [];\n        for (let i = 0; i < inRank; i++) {\n          const dim = inRank - 1 - i;\n          const a = inShape[dim] || 1;\n          const b = outShape[outShape.length - 1 - i] || 1;\n          if (b > 1 && a === 1) {\n            dims.unshift(dim);\n          }\n        }\n        return dims;\n      };\n      enableShapesUniforms = (_rank) => true;\n    }\n  });\n\n  // web/lib/wasm/jsep/webgpu/ops/transpose.ts\n  var validateInputs, getAdjustedPerm, getOutputShape, permFunctionBody, createTransposeProgramInfo, transpose, parseTransposeAttributes;\n  var init_transpose = __esm({\n    "web/lib/wasm/jsep/webgpu/ops/transpose.ts"() {\n      "use strict";\n      init_util();\n      init_attribute_with_cache_key();\n      init_common();\n      validateInputs = (inputs) => {\n        if (!inputs || inputs.length !== 1) {\n          throw new Error("Transpose requires 1 input.");\n        }\n      };\n      getAdjustedPerm = (inputRank, perm) => perm && perm.length !== inputRank ? [...new Array(inputRank).keys()].reverse() : perm;\n      getOutputShape = (inputShape, perm) => ShapeUtil.sortBasedOnPerm(inputShape, getAdjustedPerm(inputShape.length, perm));\n      permFunctionBody = (perm, rank, input, output) => {\n        const reverseFunc = [];\n        reverseFunc.push(`fn perm(i: ${output.type.indices}) -> ${input.type.indices} {\n    var a: ${input.type.indices};`);\n        for (let i = 0; i < rank; ++i) {\n          reverseFunc.push(input.indicesSet("a", perm[i], `i[${i}]`));\n        }\n        reverseFunc.push("return a;}");\n        return reverseFunc.join("\\n");\n      };\n      createTransposeProgramInfo = (inputTensor, permAttr) => {\n        const inputDataType = inputTensor.dataType;\n        const inputRank = inputTensor.dims.length;\n        const perm = getAdjustedPerm(inputRank, permAttr);\n        const useShapesUniforms = enableShapesUniforms(inputRank);\n        const outputShape = getOutputShape(inputTensor.dims, perm);\n        const outShapeOrRank = useShapesUniforms ? outputShape.length : outputShape;\n        const inShapeOrRank = useShapesUniforms ? inputRank : inputTensor.dims;\n        const output = outputVariable("output", inputDataType, outShapeOrRank);\n        const input = inputVariable("a", inputDataType, inShapeOrRank);\n        const getShaderSource = (shaderHelper) => `\n  ${shaderHelper.registerUniform("output_size", "u32").declareVariables(input, output)}\n\n  ${permFunctionBody(perm, inputRank, input, output)}\n\n  ${shaderHelper.mainStart()}\n    ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n\n    let indices = ${output.offsetToIndices("global_idx")};\n    let aIndices = perm(indices);\n\n    ${output.setByOffset("global_idx", input.getByIndices("aIndices"))}\n  }`;\n        return {\n          name: "Transpose",\n          shaderCache: { hint: `${permAttr}`, inputDependencies: useShapesUniforms ? ["rank"] : ["dims"] },\n          getRunData: (inputs) => {\n            const outputSize = ShapeUtil.size(outputShape);\n            return {\n              outputs: [{ dims: outputShape, dataType: inputs[0].dataType }],\n              dispatchGroup: { x: Math.ceil(\n                outputSize / 64\n                /* workgroup size */\n              ) },\n              programUniforms: useShapesUniforms ? [\n                { type: "uint32", data: outputSize },\n                ...createTensorShapeVariables(inputs[0].dims),\n                ...createTensorShapeVariables(outputShape)\n              ] : [\n                { type: "uint32", data: outputSize }\n              ]\n            };\n          },\n          getShaderSource\n        };\n      };\n      transpose = (context, attributes) => {\n        validateInputs(context.inputs);\n        context.compute(createTransposeProgramInfo(context.inputs[0], attributes.perm));\n      };\n      parseTransposeAttributes = (attributes) => createAttributeWithCacheKey({ perm: attributes.perm });\n    }\n  });\n\n  // web/lib/wasm/jsep/webgpu/ops/reduce-shared.ts\n  var reduceOps, reduceSharedOps, reduceInitValues, reduceOutputValues, getInnerMostAxes, computeOutAndReduceShapes, expandShapeToKeepDim, areAxesInnerMostDims, getAxesPermutation, createReduceSharedProgramInfo, reduceCommon, reduceMeanShared, reduceL1Shared, reduceL2Shared, reduceLogSumExpShared, reduceMaxShared, reduceMinShared, reduceProdShared, reduceSumShared, reduceSumSquareShared, reduceLogSumShared;\n  var init_reduce_shared = __esm({\n    "web/lib/wasm/jsep/webgpu/ops/reduce-shared.ts"() {\n      "use strict";\n      init_util();\n      init_common();\n      init_reduce();\n      init_transpose();\n      reduceOps = {\n        max: "select(bestValue, candidate, candidate > bestValue)",\n        min: "select(bestValue, candidate, candidate < bestValue)",\n        mean: "bestValue + candidate",\n        sum: "bestValue + candidate",\n        prod: "bestValue * candidate",\n        sumSquare: "bestValue + candidate * candidate",\n        logSumExp: "bestValue + exp(candidate)",\n        l1: "bestValue + abs(candidate)",\n        l2: "bestValue + candidate * candidate",\n        logSum: "bestValue + candidate"\n      };\n      reduceSharedOps = {\n        max: "select(bestValue, candidate, candidate > bestValue)",\n        min: "select(bestValue, candidate, candidate < bestValue)",\n        mean: "bestValue + candidate",\n        sum: "bestValue + candidate",\n        prod: "bestValue * candidate",\n        sumSquare: "bestValue + candidate",\n        logSumExp: "bestValue + candidate",\n        l1: "bestValue + candidate",\n        l2: "bestValue + candidate",\n        logSum: "bestValue + candidate"\n      };\n      reduceInitValues = {\n        max: "_A[offset]",\n        min: "_A[offset]",\n        mean: "0",\n        sum: "0",\n        prod: "1",\n        sumSquare: "0",\n        logSumExp: "0",\n        l1: "0",\n        l2: "0",\n        logSum: "0"\n      };\n      reduceOutputValues = {\n        max: "bestValue",\n        min: "bestValue",\n        sum: "bestValue",\n        prod: "bestValue",\n        sumSquare: "bestValue",\n        logSumExp: "log(bestValue)",\n        l1: "bestValue",\n        l2: "sqrt(bestValue)",\n        logSum: "log(bestValue)"\n      };\n      getInnerMostAxes = (numInnerAxes, rank) => {\n        const res = [];\n        for (let i = rank - numInnerAxes; i < rank; ++i) {\n          res.push(i);\n        }\n        return res;\n      };\n      computeOutAndReduceShapes = (shape, axes) => {\n        const outputShape = [];\n        const rank = shape.length;\n        for (let dim = 0; dim < rank; dim++) {\n          if (axes.indexOf(dim) === -1) {\n            outputShape.push(shape[dim]);\n          }\n        }\n        const reduceShape = axes.map((dim) => shape[dim]);\n        return [outputShape, reduceShape];\n      };\n      expandShapeToKeepDim = (shape, axes) => {\n        const rank = shape.length + axes.length;\n        const expandShape = [];\n        let shapeIdx = 0;\n        for (let dim = 0; dim < rank; dim++) {\n          if (axes.indexOf(dim) === -1) {\n            expandShape.push(shape[shapeIdx++]);\n          } else {\n            expandShape.push(1);\n          }\n        }\n        return expandShape;\n      };\n      areAxesInnerMostDims = (axes, rank) => {\n        for (let i = 0; i < axes.length; ++i) {\n          if (axes[axes.length - i - 1] !== rank - 1 - i) {\n            return false;\n          }\n        }\n        return true;\n      };\n      getAxesPermutation = (axes, rank) => {\n        const res = [];\n        if (!areAxesInnerMostDims(axes, rank)) {\n          for (let i = 0; i < rank; ++i) {\n            if (axes.indexOf(i) === -1) {\n              res.push(i);\n            }\n          }\n          axes.forEach((axis) => res.push(axis));\n        }\n        return res;\n      };\n      createReduceSharedProgramInfo = (name, shaderCache, inputs, reduceType, outputDataType, outputShape, reduceShape) => {\n        const inputShape = inputs[0].dims;\n        const outputSize = ShapeUtil.size(outputShape);\n        const reduceSize = ShapeUtil.size(reduceShape);\n        const input = inputVariable("_A", inputs[0].dataType, inputShape);\n        const output = outputVariable("output", outputDataType, outputShape);\n        const workgroupSize = 32;\n        const sharedMemorySnippet = `\n          var<workgroup> aBestValues : array<${output.type.storage}, ${workgroupSize}>;\n       `;\n        const getShaderSource = (shaderHelper) => `\n        ${shaderHelper.registerUniform("reduceSize", "u32").declareVariables(input, output)}\n        ${sharedMemorySnippet}\n        fn DIV_CEIL(a : u32, b : u32) -> u32 {\n          return ((a - 1u) / b + 1u);\n         }\n         ${shaderHelper.mainStart(workgroupSize)}\n\n          let outputIndex = global_idx / ${workgroupSize};\n          let offset = outputIndex * uniforms.reduceSize;\n\n          var bestValue = ${output.type.storage}(${reduceInitValues[reduceType]});\n          let Length = uniforms.reduceSize;\n          for (var k = local_idx; k < Length; k = k + ${workgroupSize}) {\n           let candidate = ${output.type.storage}(${input.getByOffset("offset + k")});\n           bestValue = ${reduceOps[reduceType]};\n          }\n          aBestValues[local_idx] = bestValue;\n          workgroupBarrier();\n\n         var reduceSize = min(Length, ${workgroupSize}u);\n         for (var currentSize = reduceSize / 2u; reduceSize > 1u;\n             currentSize = reduceSize / 2u) {\n           let interval = DIV_CEIL(reduceSize, 2u);\n           if (local_idx < currentSize) {\n            let candidate = aBestValues[local_idx + interval];\n            bestValue = ${reduceSharedOps[reduceType]};\n            aBestValues[local_idx] = bestValue;\n           }\n           reduceSize = interval;\n           workgroupBarrier();\n         }\n\n         if (local_idx == 0u) {\n          ${output.setByOffset(\n          "outputIndex",\n          `${reduceType === "mean" ? `bestValue / ${output.type.storage}(uniforms.reduceSize)` : `${reduceOutputValues[reduceType]}`}`\n        )};\n         }\n        }`;\n        return {\n          name,\n          shaderCache,\n          getShaderSource,\n          getRunData: () => ({\n            outputs: [{ dims: outputShape, dataType: outputDataType }],\n            dispatchGroup: { x: outputSize },\n            programUniforms: [{ type: "uint32", data: reduceSize }]\n          })\n        };\n      };\n      reduceCommon = (context, name, attributes, reduceType) => {\n        const updatedAttributes = context.inputs.length === 1 ? attributes : createReduceAttributesFromInputs(context.inputs, attributes);\n        let updatedAxes = updatedAttributes.axes;\n        if (updatedAxes.length === 0 && !updatedAttributes.noopWithEmptyAxes) {\n          updatedAxes = context.inputs[0].dims.map((_dim, i) => i);\n        }\n        const normalizeAxes = ShapeUtil.normalizeAxes(updatedAxes, context.inputs[0].dims.length);\n        let axes = normalizeAxes;\n        let input = context.inputs[0];\n        const permutedAxes = getAxesPermutation(axes, context.inputs[0].dims.length);\n        if (permutedAxes.length > 0) {\n          input = context.compute(\n            createTransposeProgramInfo(context.inputs[0], permutedAxes),\n            { inputs: [0], outputs: [-1] }\n          )[0];\n          axes = getInnerMostAxes(axes.length, input.dims.length);\n        }\n        const [outputShape, reduceShape] = computeOutAndReduceShapes(input.dims, axes);\n        let finalOutputShape = outputShape;\n        if (updatedAttributes.keepDims) {\n          finalOutputShape = expandShapeToKeepDim(outputShape, normalizeAxes);\n        }\n        context.compute(\n          createReduceSharedProgramInfo(\n            name,\n            { hint: updatedAttributes.cacheKey, inputDependencies: ["type"] },\n            [input],\n            reduceType,\n            context.inputs[0].dataType,\n            finalOutputShape,\n            reduceShape\n          ),\n          { inputs: [input] }\n        );\n      };\n      reduceMeanShared = (context, attributes) => {\n        reduceCommon(context, "ReduceMeanShared", attributes, "mean");\n      };\n      reduceL1Shared = (context, attributes) => {\n        reduceCommon(context, "ReduceL1Shared", attributes, "l1");\n      };\n      reduceL2Shared = (context, attributes) => {\n        reduceCommon(context, "ReduceL2Shared", attributes, "l2");\n      };\n      reduceLogSumExpShared = (context, attributes) => {\n        reduceCommon(context, "ReduceLogSumExpShared", attributes, "logSumExp");\n      };\n      reduceMaxShared = (context, attributes) => {\n        reduceCommon(context, "ReduceMaxShared", attributes, "max");\n      };\n      reduceMinShared = (context, attributes) => {\n        reduceCommon(context, "ReduceMinShared", attributes, "min");\n      };\n      reduceProdShared = (context, attributes) => {\n        reduceCommon(context, "ReduceProdShared", attributes, "prod");\n      };\n      reduceSumShared = (context, attributes) => {\n        reduceCommon(context, "ReduceSumShared", attributes, "sum");\n      };\n      reduceSumSquareShared = (context, attributes) => {\n        reduceCommon(context, "ReduceSumSquareShared", attributes, "sumSquare");\n      };\n      reduceLogSumShared = (context, attributes) => {\n        reduceCommon(context, "ReduceLogSumShared", attributes, "logSum");\n      };\n    }\n  });\n\n  // web/lib/wasm/jsep/webgpu/ops/reduce.ts\n  var validateInputs2, noOp, createReduceProgramInfo, createReduceAttributesFromInputs, runReduceProgram, reduceLogSumNaive, reduceL1Naive, reduceL2Naive, reduceLogSumExpNaive, reduceMaxNaive, reduceMeanNaive, reduceMinNaive, reduceProdNaive, reduceSumNaive, reduceSumSquareNaive, useNaiveReduceMethod, reduceMean, reduceL1, reduceL2, reduceLogSumExp, reduceMax, reduceMin, reduceProd, reduceSum, reduceSumSquare, reduceLogSum;\n  var init_reduce = __esm({\n    "web/lib/wasm/jsep/webgpu/ops/reduce.ts"() {\n      "use strict";\n      init_util();\n      init_attribute_with_cache_key();\n      init_common();\n      init_reduce_shared();\n      validateInputs2 = (inputs) => {\n        if (!inputs || inputs.length === 0 || inputs.length > 2) {\n          throw new Error("Reduce op requires 1 or 2 inputs.");\n        }\n        if (inputs.length === 2 && inputs[1].dims.length !== 1) {\n          throw new Error("Invalid axes input dims.");\n        }\n      };\n      noOp = (input) => ["", "", `var value = ${input.getByIndices("input_indices")};`, ""];\n      createReduceProgramInfo = (name, shaderCache, inputs, reduceOp, axesInput, outputDataType, keepDims = false, noopWithEmptyAxes = false) => {\n        const outputShape = [];\n        const inputShape = inputs[0].dims;\n        const inputRank = inputShape.length;\n        const axes = ShapeUtil.normalizeAxes(axesInput, inputRank);\n        const reduceOnAllAxes = !noopWithEmptyAxes && axes.length === 0;\n        inputShape.forEach((d, i) => {\n          if (reduceOnAllAxes || axes.indexOf(i) >= 0) {\n            if (keepDims) {\n              outputShape.push(1);\n            }\n          } else {\n            outputShape.push(d);\n          }\n        });\n        const outputRank = outputShape.length;\n        const outputSize = ShapeUtil.size(outputShape);\n        const getShaderSource = (shaderHelper) => {\n          const idxCopy = [];\n          const input = inputVariable("_A", inputs[0].dataType, inputRank);\n          const output = outputVariable("output", outputDataType, outputRank);\n          const ops = reduceOp(input, output, axes);\n          let reduceOps2 = ops[2];\n          for (let k = 0, l = 0; k < inputRank; k++) {\n            if (reduceOnAllAxes || axes.indexOf(k) >= 0) {\n              if (keepDims) {\n                l++;\n              }\n              reduceOps2 = `for(var j${k}: u32 = 0; j${k} < ${inputShape[k]}; j${k}++) {\n                  ${ops[2].includes("last_index") ? `let last_index = j${k};` : ""}\n                  ${input.indicesSet("input_indices", k, `j${k}`)}\n                  ${reduceOps2}\n                }`;\n            } else {\n              idxCopy.push(`${input.indicesSet("input_indices", k, output.indicesGet("output_indices", l))};`);\n              l++;\n            }\n          }\n          return `\n\n        ${shaderHelper.registerUniform("output_size", "u32").declareVariables(input, output)}\n\n        ${shaderHelper.mainStart()}\n          ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n          var input_indices: ${input.type.indices};\n          let output_indices = ${output.offsetToIndices("global_idx")};\n\n          ${idxCopy.join("\\n")}\n          ${ops[0]}       // init ops for reduce max/min\n          ${ops[1]}\n          ${reduceOps2}\n          ${ops[3]}\n          ${ops.length === 4 ? output.setByOffset("global_idx", "value") : ops.slice(4).join("\\n")}\n        }`;\n        };\n        return {\n          name,\n          shaderCache,\n          getShaderSource,\n          getRunData: () => ({\n            outputs: [{ dims: outputShape, dataType: outputDataType }],\n            dispatchGroup: { x: Math.ceil(\n              outputSize / 64\n              /* workgroup size */\n            ) },\n            programUniforms: [\n              { type: "uint32", data: outputSize },\n              ...createTensorShapeVariables(inputShape),\n              ...createTensorShapeVariables(outputShape)\n            ]\n          })\n        };\n      };\n      createReduceAttributesFromInputs = (inputs, attributes) => {\n        const axes = [];\n        if (inputs[1].dims[0] > 0) {\n          inputs[1].getBigInt64Array().forEach((v) => axes.push(Number(v)));\n        }\n        return createAttributeWithCacheKey(\n          { axes, keepDims: attributes.keepDims, noopWithEmptyAxes: attributes.noopWithEmptyAxes }\n        );\n      };\n      runReduceProgram = (context, name, attributes, reduceOp) => {\n        const inputs = context.inputs;\n        const updatedAttributes = inputs.length === 1 ? attributes : createReduceAttributesFromInputs(inputs, attributes);\n        context.compute(\n          createReduceProgramInfo(\n            name,\n            { hint: updatedAttributes.cacheKey, inputDependencies: ["rank"] },\n            [inputs[0]],\n            updatedAttributes.noopWithEmptyAxes && updatedAttributes.axes.length === 0 ? noOp : reduceOp,\n            updatedAttributes.axes,\n            inputs[0].dataType,\n            updatedAttributes.keepDims,\n            updatedAttributes.noopWithEmptyAxes\n          ),\n          { inputs: [0] }\n        );\n      };\n      reduceLogSumNaive = (context, attributes) => {\n        validateInputs2(context.inputs);\n        const reduceOp = (input, output) => [\n          `var value = ${output.type.storage}(0);`,\n          "",\n          `value += ${input.getByIndices("input_indices")};`,\n          "value = log(value);"\n        ];\n        runReduceProgram(context, "ReduceLogSum", attributes, reduceOp);\n      };\n      reduceL1Naive = (context, attributes) => {\n        validateInputs2(context.inputs);\n        const reduceOp = (input, output) => [\n          `var value = ${output.type.storage}(0);`,\n          "",\n          `value += abs(${input.getByIndices("input_indices")});`,\n          ""\n        ];\n        runReduceProgram(context, "ReduceL1", attributes, reduceOp);\n      };\n      reduceL2Naive = (context, attributes) => {\n        validateInputs2(context.inputs);\n        const reduceOp = (input, output) => [\n          `var t = ${output.type.value}(0); var value = ${output.type.value}(0);`,\n          "",\n          `t = ${input.getByIndices("input_indices")}; value += (t * t);`,\n          "value = sqrt(value);"\n        ];\n        runReduceProgram(context, "ReduceL2", attributes, reduceOp);\n      };\n      reduceLogSumExpNaive = (context, attributes) => {\n        validateInputs2(context.inputs);\n        const reduceOp = (input, output) => [\n          `var value = ${output.type.storage}(0);`,\n          "",\n          `value += exp(${input.getByIndices("input_indices")});`,\n          "value = log(value);"\n        ];\n        runReduceProgram(context, "ReduceLogSumExp", attributes, reduceOp);\n      };\n      reduceMaxNaive = (context, attributes) => {\n        validateInputs2(context.inputs);\n        const reduceOp = (input, _output, axes) => {\n          const idxZero = [];\n          for (let k = 0; k < input.rank; k++) {\n            if (axes.indexOf(k) >= 0 || axes.length === 0) {\n              idxZero.push(input.indicesSet("input_indices", k, 0));\n            }\n          }\n          return [\n            `${idxZero.join("\\n")}`,\n            `var value = ${input.getByIndices("input_indices")};`,\n            `value = max(value, ${input.getByIndices("input_indices")});`,\n            ""\n          ];\n        };\n        runReduceProgram(context, "ReduceMax", attributes, reduceOp);\n      };\n      reduceMeanNaive = (context, attributes) => {\n        validateInputs2(context.inputs);\n        const reduceOp = (input, output, axes) => {\n          let size = 1;\n          for (let k = 0; k < input.rank; k++) {\n            if (axes.indexOf(k) >= 0 || axes.length === 0) {\n              size *= context.inputs[0].dims[k];\n            }\n          }\n          return [\n            "var sum = f32(0);",\n            "",\n            `sum += f32(${input.getByIndices("input_indices")});`,\n            `let value = ${output.type.value}(sum / ${size});`\n          ];\n        };\n        runReduceProgram(context, "ReduceMean", attributes, reduceOp);\n      };\n      reduceMinNaive = (context, attributes) => {\n        validateInputs2(context.inputs);\n        const reduceOp = (input, _output, axes) => {\n          const idxZero = [];\n          for (let k = 0; k < input.rank; k++) {\n            if (axes.indexOf(k) >= 0 || axes.length === 0) {\n              idxZero.push(`input_indices[${k}] = 0;`);\n            }\n          }\n          return [\n            `${idxZero.join("\\n")}`,\n            `var value = ${input.getByIndices("input_indices")};`,\n            `value = min(value, ${input.getByIndices("input_indices")});`,\n            ""\n          ];\n        };\n        runReduceProgram(context, "ReduceMin", attributes, reduceOp);\n      };\n      reduceProdNaive = (context, attributes) => {\n        validateInputs2(context.inputs);\n        const reduceOp = (input, output) => [\n          `var value = ${output.type.storage}(1);`,\n          "",\n          `value *= ${input.getByIndices("input_indices")};`,\n          ""\n        ];\n        runReduceProgram(context, "ReduceProd", attributes, reduceOp);\n      };\n      reduceSumNaive = (context, attributes) => {\n        validateInputs2(context.inputs);\n        const reduceOp = (input, output) => [\n          `var value = ${output.type.storage}(0);`,\n          "",\n          `value += ${input.getByIndices("input_indices")};`,\n          ""\n        ];\n        runReduceProgram(context, "ReduceSum", attributes, reduceOp);\n      };\n      reduceSumSquareNaive = (context, attributes) => {\n        validateInputs2(context.inputs);\n        const reduceOp = (input, output) => [\n          `var t = ${output.type.value}(0); var value = ${output.type.value}(0);`,\n          "",\n          `t = ${input.getByIndices("input_indices")}; value += t * t;`,\n          ""\n        ];\n        runReduceProgram(context, "ReduceSumSquare", attributes, reduceOp);\n      };\n      useNaiveReduceMethod = (shape, axes, noopWithEmptyAxes) => {\n        if (axes.length === 0) {\n          return noopWithEmptyAxes;\n        }\n        let outputSize = 1;\n        let reduceSize = 1;\n        for (let dim = 0; dim < axes.length; dim++) {\n          if (axes.indexOf(dim) === -1) {\n            outputSize *= shape[dim];\n          } else {\n            reduceSize *= shape[dim];\n          }\n        }\n        return reduceSize < 32 && outputSize > 1024;\n      };\n      reduceMean = (context, attributes) => {\n        if (useNaiveReduceMethod(context.inputs[0].dims, attributes.axes, attributes.noopWithEmptyAxes)) {\n          reduceMeanNaive(context, attributes);\n        } else {\n          reduceMeanShared(context, attributes);\n        }\n      };\n      reduceL1 = (context, attributes) => {\n        if (useNaiveReduceMethod(context.inputs[0].dims, attributes.axes, attributes.noopWithEmptyAxes)) {\n          reduceL1Naive(context, attributes);\n        } else {\n          reduceL1Shared(context, attributes);\n        }\n      };\n      reduceL2 = (context, attributes) => {\n        if (useNaiveReduceMethod(context.inputs[0].dims, attributes.axes, attributes.noopWithEmptyAxes)) {\n          reduceL2Naive(context, attributes);\n        } else {\n          reduceL2Shared(context, attributes);\n        }\n      };\n      reduceLogSumExp = (context, attributes) => {\n        if (useNaiveReduceMethod(context.inputs[0].dims, attributes.axes, attributes.noopWithEmptyAxes)) {\n          reduceLogSumExpNaive(context, attributes);\n        } else {\n          reduceLogSumExpShared(context, attributes);\n        }\n      };\n      reduceMax = (context, attributes) => {\n        if (useNaiveReduceMethod(context.inputs[0].dims, attributes.axes, attributes.noopWithEmptyAxes)) {\n          reduceMaxNaive(context, attributes);\n        } else {\n          reduceMaxShared(context, attributes);\n        }\n      };\n      reduceMin = (context, attributes) => {\n        if (useNaiveReduceMethod(context.inputs[0].dims, attributes.axes, attributes.noopWithEmptyAxes)) {\n          reduceMinNaive(context, attributes);\n        } else {\n          reduceMinShared(context, attributes);\n        }\n      };\n      reduceProd = (context, attributes) => {\n        if (useNaiveReduceMethod(context.inputs[0].dims, attributes.axes, attributes.noopWithEmptyAxes)) {\n          reduceProdNaive(context, attributes);\n        } else {\n          reduceProdShared(context, attributes);\n        }\n      };\n      reduceSum = (context, attributes) => {\n        if (useNaiveReduceMethod(context.inputs[0].dims, attributes.axes, attributes.noopWithEmptyAxes)) {\n          reduceSumNaive(context, attributes);\n        } else {\n          reduceSumShared(context, attributes);\n        }\n      };\n      reduceSumSquare = (context, attributes) => {\n        if (useNaiveReduceMethod(context.inputs[0].dims, attributes.axes, attributes.noopWithEmptyAxes)) {\n          reduceSumSquareNaive(context, attributes);\n        } else {\n          reduceSumSquareShared(context, attributes);\n        }\n      };\n      reduceLogSum = (context, attributes) => {\n        if (useNaiveReduceMethod(context.inputs[0].dims, attributes.axes, attributes.noopWithEmptyAxes)) {\n          reduceLogSumNaive(context, attributes);\n        } else {\n          reduceLogSumShared(context, attributes);\n        }\n      };\n    }\n  });\n\n  // web/lib/wasm/jsep/webgpu/ops/argminmax.ts\n  var validateInputs3, argMin, argMax, parseArgMinMaxAttributes;\n  var init_argminmax = __esm({\n    "web/lib/wasm/jsep/webgpu/ops/argminmax.ts"() {\n      "use strict";\n      init_wasm_common();\n      init_attribute_with_cache_key();\n      init_reduce();\n      validateInputs3 = (inputs) => {\n        if (!inputs || inputs.length === 0 || inputs.length > 2) {\n          throw new Error("ArgMinMaxOp op requires 1 or 2 inputs.");\n        }\n        if (inputs[0].dataType !== 1 /* float */) {\n          throw new Error("Invalid input type.");\n        }\n      };\n      argMin = (context, attributes) => {\n        validateInputs3(context.inputs);\n        const argMinMaxOp = (input, output, axes) => {\n          const idxZero = [];\n          for (let k = 0; k < input.rank; k++) {\n            if (axes.indexOf(k) >= 0 || axes.length === 0) {\n              idxZero.push(`input_indices[${k}] = 0;`);\n            }\n          }\n          return [\n            `${idxZero.join("\\n")}`,\n            `var value = ${input.getByIndices("input_indices")};\nvar best_index : i32 = 0;`,\n            `if (${input.getByIndices("input_indices")} ${attributes.selectLastIndex > 0 ? "<=" : "<"} value) {\n         value = ${input.getByIndices("input_indices")};\n         best_index = i32(last_index);\n       }`,\n            "",\n            output.setByOffset("global_idx", "best_index")\n          ];\n        };\n        context.compute(\n          createReduceProgramInfo(\n            "ArgMin",\n            { hint: attributes.cacheKey, inputDependencies: ["rank"] },\n            [context.inputs[0]],\n            argMinMaxOp,\n            [attributes.axis],\n            7 /* int64 */,\n            attributes.keepDims\n          ),\n          { inputs: [0] }\n        );\n      };\n      argMax = (context, attributes) => {\n        validateInputs3(context.inputs);\n        const argMinMaxOp = (input, output, axes) => {\n          const idxZero = [];\n          for (let k = 0; k < input.rank; k++) {\n            if (axes.indexOf(k) >= 0 || axes.length === 0) {\n              idxZero.push(`input_indices[${k}] = 0;`);\n            }\n          }\n          return [\n            `${idxZero.join("\\n")}`,\n            `var value = ${input.getByIndices("input_indices")};\nvar best_index : i32 = 0;`,\n            `if (${input.getByIndices("input_indices")} ${attributes.selectLastIndex > 0 ? ">=" : ">"} value) {\n         value = ${input.getByIndices("input_indices")};\n         best_index = i32(last_index);\n       }`,\n            "",\n            output.setByOffset("global_idx", "best_index")\n          ];\n        };\n        context.compute(\n          createReduceProgramInfo(\n            "argMax",\n            { hint: attributes.cacheKey, inputDependencies: ["rank"] },\n            [context.inputs[0]],\n            argMinMaxOp,\n            [attributes.axis],\n            7 /* int64 */,\n            attributes.keepDims\n          ),\n          { inputs: [0] }\n        );\n      };\n      parseArgMinMaxAttributes = (attributes) => createAttributeWithCacheKey(attributes);\n    }\n  });\n\n  // web/lib/wasm/jsep/webgpu/ops/attention.ts\n  var validateAttentionInputs, computeInPlaceSoftmax, computeAttentionProbs, computeVxAttentionScore, applyAttention, prepare, attention;\n  var init_attention = __esm({\n    "web/lib/wasm/jsep/webgpu/ops/attention.ts"() {\n      "use strict";\n      init_wasm_common();\n      init_types();\n      init_common();\n      validateAttentionInputs = (inputs, attributes) => {\n        const input = inputs[0];\n        const weights = inputs[1];\n        const bias = inputs[2];\n        const maskIndex = inputs[3];\n        const past = inputs[4];\n        const relativePositionBias = inputs[5];\n        if (past && relativePositionBias) {\n          throw new Error("Attention cannot have both past and relative_position_bias");\n        }\n        if (input.dims.length !== 3) {\n          throw new Error(\'Input "input" must have 3 dimensions\');\n        }\n        const batchSize = input.dims[0];\n        const sequenceLength = input.dims[1];\n        const inputHiddenSize = input.dims[2];\n        if (bias.dims.length !== 1) {\n          throw new Error(\'Input "bias" is expected to have 1 dimensions\');\n        }\n        if (weights.dims.length !== 2) {\n          throw new Error(\'Input "weights" is expected to have 2 dimensions\');\n        }\n        if (weights.dims[0] !== inputHiddenSize) {\n          throw new Error("Input 1 dimension 0 should have same length as dimension 2 of input 0");\n        }\n        if (bias.dims[0] !== weights.dims[1]) {\n          throw new Error(\'Input "bias" dimension 0 should have same length as dimension 1 of input "weights"\');\n        }\n        let qHiddenSize = bias.dims[0] / 3;\n        let kHiddenSize = qHiddenSize;\n        let vHiddenSize = kHiddenSize;\n        if (attributes.qkvHiddenSizes.length > 0) {\n          if (attributes.qkvHiddenSizes.length !== 3) {\n            throw new Error("qkv_hidden_sizes attribute should have 3 elements");\n          }\n          for (const sz of attributes.qkvHiddenSizes) {\n            if (sz % attributes.numHeads !== 0) {\n              throw new Error("qkv_hidden_sizes should be divisible by num_heads");\n            }\n          }\n          qHiddenSize = attributes.qkvHiddenSizes[0];\n          kHiddenSize = attributes.qkvHiddenSizes[1];\n          vHiddenSize = attributes.qkvHiddenSizes[2];\n        }\n        const kvSequenceLength = sequenceLength;\n        if (qHiddenSize !== kHiddenSize) {\n          throw new Error("qkv_hidden_sizes first element should be same as the second");\n        }\n        if (bias.dims[0] !== qHiddenSize + kHiddenSize + vHiddenSize) {\n          throw new Error(\'Input "bias" dimension 0 should have same length as sum of Q/K/V hidden sizes\');\n        }\n        let pastSequenceLength = 0;\n        if (past) {\n          if (kHiddenSize !== vHiddenSize) {\n            throw new Error(\'Input "past" expect k_hidden_size == v_hidden_size\');\n          }\n          if (past.dims.length !== 5) {\n            throw new Error(\'Input "past" must have 5 dimensions\');\n          }\n          if (past.dims[0] !== 2) {\n            throw new Error(\'Input "past" first dimension must be 2\');\n          }\n          if (past.dims[1] !== batchSize) {\n            throw new Error(\'Input "past" second dimension must be batch_size\');\n          }\n          if (past.dims[2] !== attributes.numHeads) {\n            throw new Error(\'Input "past" third dimension must be num_heads\');\n          }\n          if (past.dims[4] !== kHiddenSize / attributes.numHeads) {\n            throw new Error(\'Input "past" fifth dimension must be k_hidden_size / num_heads\');\n          }\n          if (!attributes.pastPresentShareBuffer) {\n            pastSequenceLength = past.dims[3];\n          }\n        }\n        const totalSequenceLength = kvSequenceLength + pastSequenceLength;\n        const maxSequenceLength = -1;\n        const maskType = 0 /* none */;\n        if (maskIndex) {\n          throw new Error("Mask not supported");\n        }\n        if (past) {\n          throw new Error("past is not supported");\n        }\n        if (relativePositionBias) {\n          throw new Error("relativePositionBias is not supported");\n        }\n        return {\n          batchSize,\n          sequenceLength,\n          pastSequenceLength,\n          kvSequenceLength,\n          totalSequenceLength,\n          maxSequenceLength,\n          inputHiddenSize,\n          hiddenSize: qHiddenSize,\n          vHiddenSize,\n          headSize: Math.floor(qHiddenSize / attributes.numHeads),\n          vHeadSize: Math.floor(vHiddenSize / attributes.numHeads),\n          numHeads: attributes.numHeads,\n          isUnidirectional: false,\n          pastPresentShareBuffer: false,\n          maskFilterValue: attributes.maskFilterValue,\n          maskType,\n          scale: attributes.scale,\n          broadcastResPosBias: false,\n          passPastInKv: false,\n          qkvFormat: 1 /* qkvBNSH */\n        };\n      };\n      computeInPlaceSoftmax = (context, input, n, d) => {\n        const components = getMaxComponents(d);\n        let WG = 64;\n        const dComp = d / components;\n        if (dComp < WG) {\n          WG = 1;\n        } else if (dComp / 8 < 64) {\n          WG = Math.ceil(dComp / 8);\n        }\n        const elementsPerWG = Math.ceil(d / components / WG);\n        const tensorDataType = tensorDataTypeEnumToString(input.dataType);\n        const programUniforms = [{ type: tensorDataType, data: 1 / d }, { type: "uint32", data: dComp }, { type: "uint32", data: elementsPerWG }];\n        const dataType = tensorTypeToWsglStorageType(input.dataType, components);\n        const getShaderSource = (shaderHelper) => {\n          const inputHelper = outputVariable("x", input.dataType, input.dims, components);\n          let threadMaxValue = "thread_max_vector";\n          if (components === 2) {\n            threadMaxValue = "max(thread_max_vector.x, thread_max_vector.y)";\n          } else if (components === 4) {\n            threadMaxValue = "max(max(thread_max_vector.x, thread_max_vector.y), max(thread_max_vector.z, thread_max_vector.w))";\n          }\n          const elemValueType = tensorTypeToWsglValueType(input.dataType);\n          const uniforms = [\n            { name: "d_inv", type: elemValueType },\n            { name: "d_comp", type: "u32" },\n            { name: "elements_per_wg", type: "u32" }\n          ];\n          return `\n  var<workgroup> wgMax: array<f32, ${WG}>;\n  var<workgroup> wgSum: array<f32, ${WG}>;\n  ${shaderHelper.registerUniforms(uniforms).declareVariables(inputHelper)}\n  ${shaderHelper.mainStart([\n            WG,\n            1,\n            1\n          ])}\n    let localOffset = local_idx * uniforms.elements_per_wg;\n    let offset: u32 = workgroup_id.x * uniforms.d_comp + localOffset;\n\n    var thread_max_vector = ${fillVector("f32", components, "-3.402823e+38f")};\n    for (var i: u32 = 0; i < uniforms.elements_per_wg && i + localOffset < uniforms.d_comp; i++) {\n      thread_max_vector = max(${castToF32(elemValueType, components, "x[offset + i]")}, thread_max_vector);\n    }\n    wgMax[local_idx] = ${threadMaxValue};\n    workgroupBarrier();\n\n    var maxValue = -3.402823e+38f;\n    for (var i = 0u; i < ${WG}; i++) {\n      maxValue = max(wgMax[i], maxValue);\n    }\n\n    var sumVector = ${fillVector("f32", components, "0")};\n    for (var i: u32 = 0; i < uniforms.elements_per_wg && i + localOffset < uniforms.d_comp; i++) {\n      sumVector += exp(${castToF32(elemValueType, components, "x[offset + i]")} - maxValue);\n    }\n    wgSum[local_idx] = ${sumVector("sumVector", components)};\n    workgroupBarrier();\n\n    var sum: f32 = 0;\n    for (var i = 0u; i < ${WG}; i++) {\n      sum += wgSum[i];\n    }\n\n    if (sum == 0) {\n      for (var i: u32 = 0; i < uniforms.elements_per_wg && i + localOffset < uniforms.d_comp; i++) {\n        x[offset + i] = ${fillVector("f32", components, "uniforms.d_inv")};\n      }\n    } else {\n      for (var i: u32 = 0; i < uniforms.elements_per_wg && i + localOffset < uniforms.d_comp; i++) {\n        let f32input = ${castToF32(elemValueType, components, "x[offset + i]")};\n        x[offset + i] = ${inputHelper.type.value}(exp(f32input - maxValue) / sum);\n      }\n    }\n  }`;\n        };\n        context.compute(\n          {\n            name: "AttentionProbsSoftmax",\n            shaderCache: { hint: `${WG};${dataType};${components}` },\n            getShaderSource,\n            getRunData: () => ({ outputs: [], dispatchGroup: { x: n }, programUniforms })\n          },\n          { inputs: [input], outputs: [] }\n        );\n      };\n      computeAttentionProbs = (context, q, key, _bias, parameters, attributes) => {\n        const probsShape = [\n          parameters.batchSize,\n          parameters.numHeads,\n          parameters.sequenceLength,\n          parameters.kvSequenceLength + parameters.pastSequenceLength\n        ];\n        const alpha = attributes.scale === 0 ? 1 / Math.sqrt(parameters.headSize) : attributes.scale;\n        const components = getMaxComponents(parameters.headSize);\n        const vectorizedHeadSize = parameters.headSize / components;\n        const TILE_SIZE = 12;\n        const dispatch = {\n          x: Math.ceil(parameters.totalSequenceLength / TILE_SIZE),\n          y: Math.ceil(parameters.sequenceLength / TILE_SIZE),\n          z: parameters.batchSize * parameters.numHeads\n        };\n        const tensorDataType = tensorDataTypeEnumToString(q.dataType);\n        const programUniforms = [\n          { type: "uint32", data: parameters.sequenceLength },\n          { type: "uint32", data: vectorizedHeadSize },\n          { type: "uint32", data: parameters.totalSequenceLength },\n          { type: "uint32", data: parameters.kvSequenceLength },\n          { type: tensorDataType, data: alpha }\n        ];\n        const inputs = [q, key];\n        const getShaderSource = (shaderHelper) => {\n          const qInput = inputVariable("q", q.dataType, q.dims, components);\n          const kInput = inputVariable("key", key.dataType, key.dims, components);\n          const output = outputVariable("output", q.dataType, probsShape);\n          const dataType = tensorTypeToWsglStorageType(q.dataType);\n          const uniforms = [\n            { name: "M", type: "u32" },\n            { name: "K", type: "u32" },\n            { name: "N", type: "u32" },\n            { name: "kv_sequence_length", type: "u32" },\n            { name: "alpha", type: dataType }\n          ];\n          return `\n  const beta: ${dataType} = 1.0;\n  const TILE_SIZE = ${TILE_SIZE}u;\n\n  var<workgroup> tileQ: array<${qInput.type.storage}, ${TILE_SIZE * TILE_SIZE}>;\n  var<workgroup> tileK: array<${qInput.type.storage}, ${TILE_SIZE * TILE_SIZE}>;\n  ${shaderHelper.registerUniforms(uniforms).declareVariables(qInput, kInput, output)}\n  ${shaderHelper.mainStart([\n            TILE_SIZE,\n            TILE_SIZE,\n            1\n          ])}\n    // x holds the N and y holds the M\n    let headIdx = workgroup_id.z;\n    let m = workgroup_id.y * TILE_SIZE;\n    let n = workgroup_id.x * TILE_SIZE;\n    let lm = m + local_id.y;\n    let ln = n + local_id.x;\n\n    let qOffset = uniforms.M * uniforms.K * headIdx + m * uniforms.K;\n    let kOffset = uniforms.kv_sequence_length * uniforms.K * headIdx + n * uniforms.K;\n\n    var value = ${fillVector(dataType, components)};\n    for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {\n      if (m + local_id.y < uniforms.M && w + local_id.x < uniforms.K) {\n        tileQ[TILE_SIZE * local_id.y + local_id.x] = q[qOffset + local_id.y * uniforms.K + w + local_id.x];\n      }\n      if (n + local_id.y < uniforms.N && w + local_id.x < uniforms.K) {\n        tileK[TILE_SIZE * local_id.y + local_id.x] = key[kOffset + local_id.y * uniforms.K + w + local_id.x];\n      }\n      workgroupBarrier();\n\n      for (var k: u32 = 0u; k<TILE_SIZE && w+k < uniforms.K; k++) {\n        value += tileQ[TILE_SIZE * local_id.y + k] * tileK[TILE_SIZE * local_id.x + k];\n      }\n\n      workgroupBarrier();\n    }\n\n    let headOffset = headIdx * uniforms.M * uniforms.N;\n    if (lm < uniforms.M && ln < uniforms.N) {\n      let outputIdx = headOffset + lm * uniforms.N + ln;\n      output[outputIdx] = ${sumVector("value", components)} * uniforms.alpha;\n    }\n  }`;\n        };\n        const probs = context.compute(\n          {\n            name: "AttentionProbs",\n            shaderCache: { hint: `${components}`, inputDependencies: ["type", "type"] },\n            getRunData: () => ({\n              outputs: [{ dims: probsShape, dataType: q.dataType, gpuDataType: 0 /* default */ }],\n              dispatchGroup: dispatch,\n              programUniforms\n            }),\n            getShaderSource\n          },\n          { inputs, outputs: [-1] }\n        )[0];\n        computeInPlaceSoftmax(\n          context,\n          probs,\n          parameters.batchSize * parameters.numHeads * parameters.sequenceLength,\n          parameters.totalSequenceLength\n        );\n        return probs;\n      };\n      computeVxAttentionScore = (context, probs, v, params) => {\n        const outputShape = [params.batchSize, params.sequenceLength, params.vHiddenSize];\n        const TILE_SIZE = 12;\n        const dispatch = {\n          x: Math.ceil(params.vHeadSize / TILE_SIZE),\n          y: Math.ceil(params.sequenceLength / TILE_SIZE),\n          z: params.batchSize * params.numHeads\n        };\n        const programUniforms = [\n          { type: "uint32", data: params.sequenceLength },\n          { type: "uint32", data: params.totalSequenceLength },\n          { type: "uint32", data: params.vHeadSize },\n          { type: "uint32", data: params.numHeads },\n          { type: "uint32", data: params.vHiddenSize }\n        ];\n        const getShaderSource = (shaderHelper) => {\n          const probsHelper = inputVariable("probs", probs.dataType, probs.dims);\n          const vHelper = inputVariable("v", v.dataType, v.dims);\n          const output = outputVariable("output", probs.dataType, outputShape);\n          const uniforms = [\n            { name: "M", type: "u32" },\n            { name: "K", type: "u32" },\n            { name: "N", type: "u32" },\n            { name: "num_heads", type: "u32" },\n            { name: "v_hidden_size", type: "u32" }\n          ];\n          return `\n  const TILE_SIZE = ${TILE_SIZE}u;\n  var<workgroup> tileQ: array<${probsHelper.type.value}, ${TILE_SIZE * TILE_SIZE}>;\n  var<workgroup> tileK: array<${probsHelper.type.value}, ${TILE_SIZE * TILE_SIZE}>;\n  ${shaderHelper.registerUniforms(uniforms).declareVariables(probsHelper, vHelper, output)}\n  ${shaderHelper.mainStart([\n            TILE_SIZE,\n            TILE_SIZE,\n            1\n          ])}\n   let headIdx = workgroup_id.z;\n   let m = workgroup_id.y * TILE_SIZE + local_id.y;\n   let n = workgroup_id.x * TILE_SIZE + local_id.x;\n\n   let offsetA = headIdx * (uniforms.M * uniforms.K) + m * uniforms.K;\n   let offsetB = headIdx * (uniforms.N * uniforms.K) + n;\n\n   var value = ${probsHelper.type.storage}(0);\n   for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {\n     if (m < uniforms.M && w + local_id.x < uniforms.K) {\n       tileQ[TILE_SIZE * local_id.y + local_id.x] = probs[offsetA + w + local_id.x];\n     }\n     if (n < uniforms.N && w + local_id.y < uniforms.K) {\n       tileK[TILE_SIZE * local_id.y + local_id.x] = v[offsetB + (w + local_id.y) * uniforms.N];\n     }\n     workgroupBarrier();\n     for (var k: u32 = 0u; k<TILE_SIZE && w+k < uniforms.K; k++) {\n       value += tileQ[TILE_SIZE * local_id.y + k] * tileK[TILE_SIZE * k + local_id.x];\n     }\n     workgroupBarrier();\n   }\n\n   // we need to transpose output from BNSH_v to BSND_v\n   let batchIdx = workgroup_id.z / uniforms.num_heads;\n   let currentBatchHeadNumber = workgroup_id.z % uniforms.num_heads;\n   let headOffset = (batchIdx * uniforms.M * uniforms.num_heads + currentBatchHeadNumber) * uniforms.N;\n   if (m < uniforms.M && n < uniforms.N) {\n     let outputIdx = batchIdx * uniforms.M *uniforms.v_hidden_size + m * uniforms.v_hidden_size\n       + currentBatchHeadNumber * uniforms.N + n;\n     output[outputIdx] = value;\n   }\n  }`;\n        };\n        return context.compute(\n          {\n            name: "AttentionScore",\n            shaderCache: { inputDependencies: ["type", "type"] },\n            getRunData: () => ({\n              outputs: [{ dims: outputShape, dataType: probs.dataType, gpuDataType: 0 /* default */ }],\n              dispatchGroup: dispatch,\n              programUniforms\n            }),\n            getShaderSource\n          },\n          { inputs: [probs, v], outputs: [0] }\n        )[0];\n      };\n      applyAttention = (context, q, k, v, _maskIndex, _past, _pastKey, _pastValue, relativePositionBias, parameters, attributes) => {\n        const probs = computeAttentionProbs(context, q, k, relativePositionBias, parameters, attributes);\n        computeVxAttentionScore(context, probs, v, parameters);\n      };\n      prepare = (context, parameters) => {\n        const outputShape = [\n          parameters.batchSize,\n          parameters.numHeads,\n          parameters.sequenceLength,\n          parameters.headSize\n        ];\n        const M = parameters.sequenceLength;\n        const K = parameters.inputHiddenSize;\n        const N = parameters.headSize;\n        const TILE_SIZE = 12;\n        const dispatch = {\n          x: Math.ceil(parameters.headSize / TILE_SIZE),\n          y: Math.ceil(parameters.sequenceLength / TILE_SIZE),\n          z: parameters.batchSize * parameters.numHeads\n        };\n        const inputs = [context.inputs[0], context.inputs[1], context.inputs[2]];\n        const programUniforms = [\n          { type: "uint32", data: M },\n          { type: "uint32", data: K },\n          { type: "uint32", data: N },\n          { type: "uint32", data: parameters.numHeads },\n          { type: "uint32", data: parameters.headSize },\n          { type: "uint32", data: parameters.hiddenSize },\n          { type: "uint32", data: parameters.hiddenSize + parameters.hiddenSize + parameters.vHiddenSize }\n        ];\n        const getShaderSource = (shaderHelper) => {\n          const outputQ = outputVariable("output_q", inputs[0].dataType, outputShape);\n          const outputK = outputVariable("output_k", inputs[0].dataType, outputShape);\n          const outputV = outputVariable("output_v", inputs[0].dataType, outputShape);\n          const input = inputVariable("input", inputs[0].dataType, inputs[0].dims);\n          const weight = inputVariable("weight", inputs[1].dataType, inputs[1].dims);\n          const bias = inputVariable("bias", inputs[2].dataType, inputs[2].dims);\n          const dataType = input.type.storage;\n          const uniforms = [\n            { name: "M", type: "u32" },\n            { name: "K", type: "u32" },\n            { name: "N", type: "u32" },\n            { name: "num_heads", type: "u32" },\n            { name: "head_size", type: "u32" },\n            { name: "hidden_size", type: "u32" },\n            { name: "ldb", type: "u32" }\n          ];\n          return `\n  const TILE_SIZE = ${TILE_SIZE}u;\n  var<workgroup> tileInput: array<${dataType}, ${TILE_SIZE * TILE_SIZE}>;\n  var<workgroup> tileWeightQ: array<${dataType}, ${TILE_SIZE * TILE_SIZE}>;\n  var<workgroup> tileWeightK: array<${dataType}, ${TILE_SIZE * TILE_SIZE}>;\n  var<workgroup> tileWeightV: array<${dataType}, ${TILE_SIZE * TILE_SIZE}>;\n  ${shaderHelper.registerUniforms(uniforms).declareVariables(input, weight, bias, outputQ, outputK, outputV)}\n  ${shaderHelper.mainStart([\n            TILE_SIZE,\n            TILE_SIZE,\n            1\n          ])}\n    let batchIndex = workgroup_id.z / uniforms.num_heads;\n    let headNumber = workgroup_id.z % uniforms.num_heads;\n    let m = workgroup_id.y * TILE_SIZE + local_id.y;\n    let n = workgroup_id.x * TILE_SIZE + local_id.x;\n\n    let inputOffset = batchIndex * (uniforms.M * uniforms.K) + m * uniforms.K;\n    let biasOffsetQ = headNumber * uniforms.head_size;\n    let biasOffsetK = uniforms.hidden_size + biasOffsetQ;\n    let biasOffsetV = uniforms.hidden_size + biasOffsetK;\n\n    var valueQ = ${dataType}(0);\n    var valueK = ${dataType}(0);\n    var valueV = ${dataType}(0);\n    for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {\n      if (m < uniforms.M && w + local_id.x < uniforms.K) {\n        tileInput[TILE_SIZE * local_id.y + local_id.x] = input[inputOffset + w + local_id.x];\n      }\n      if (n < uniforms.N && w + local_id.y < uniforms.K) {\n        let offset = n + (w + local_id.y) * uniforms.ldb;\n        tileWeightQ[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetQ + offset];\n        tileWeightK[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetK + offset];\n        tileWeightV[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetV + offset];\n      }\n      workgroupBarrier();\n      for (var k: u32 = 0u; k<TILE_SIZE && w+k < uniforms.K; k++) {\n        let inputTileOffset = TILE_SIZE * local_id.y + k;\n        let weightTileOffset = TILE_SIZE * k + local_id.x;\n        valueQ += tileInput[inputTileOffset] * tileWeightQ[weightTileOffset];\n        valueK += tileInput[inputTileOffset] * tileWeightK[weightTileOffset];\n        valueV += tileInput[inputTileOffset] * tileWeightV[weightTileOffset];\n      }\n\n      workgroupBarrier();\n    }\n\n    let headOffset = (m * uniforms.N + n) % uniforms.head_size;\n    valueQ += bias[headOffset + biasOffsetQ];\n    valueK += bias[headOffset + biasOffsetK];\n    valueV += bias[headOffset + biasOffsetV];\n\n    let offset = workgroup_id.z * uniforms.M * uniforms.N;\n    if (m < uniforms.M && n < uniforms.N) {\n      let outputIdx = offset + m * uniforms.N + n;\n      output_q[outputIdx] = valueQ;\n      output_k[outputIdx] = valueK;\n      output_v[outputIdx] = valueV;\n    }\n  }`;\n        };\n        return context.compute(\n          {\n            name: "AttentionPrepare",\n            shaderCache: { inputDependencies: ["type", "type", "type"] },\n            getRunData: () => ({\n              outputs: [\n                { dims: outputShape, dataType: context.inputs[0].dataType, gpuDataType: 0 /* default */ },\n                { dims: outputShape, dataType: context.inputs[0].dataType, gpuDataType: 0 /* default */ },\n                { dims: outputShape, dataType: context.inputs[0].dataType, gpuDataType: 0 /* default */ }\n              ],\n              dispatchGroup: dispatch,\n              programUniforms\n            }),\n            getShaderSource\n          },\n          { inputs, outputs: [-1, -1, -1] }\n        );\n      };\n      attention = (context, attributes) => {\n        const params = validateAttentionInputs(context.inputs, attributes);\n        const [q, k, v] = prepare(context, params);\n        return applyAttention(\n          context,\n          q,\n          k,\n          v,\n          context.inputs[4],\n          void 0,\n          void 0,\n          void 0,\n          context.inputs[5],\n          params,\n          attributes\n        );\n      };\n    }\n  });\n\n  // web/lib/wasm/jsep/webgpu/ops/batch-norm.ts\n  var validateInputs4, createBatchNormInferenceProgramInfo, parseBatchNormAttributes, batchNorm;\n  var init_batch_norm = __esm({\n    "web/lib/wasm/jsep/webgpu/ops/batch-norm.ts"() {\n      "use strict";\n      init_esm();\n      init_util();\n      init_attribute_with_cache_key();\n      init_common();\n      validateInputs4 = (inputs, attributes) => {\n        if (!inputs || inputs.length !== 5) {\n          throw new Error("BatchNormalization requires 5 inputs");\n        }\n        const checkShapeEqual = (actual, expected, message) => {\n          const r = expected.length;\n          if (r !== actual.length) {\n            throw new Error(`${message}: num dimensions != ${r}`);\n          }\n          expected.forEach((v, i) => {\n            if (v !== actual[i]) {\n              throw new Error(`${message}: dim[${i}] do not match`);\n            }\n          });\n        };\n        if (inputs[0].dims.length > 1) {\n          const shape = attributes.format === "NHWC" ? attributes.spatial ? inputs[0].dims.slice(-1) : inputs[0].dims.slice(-1).concat(inputs[0].dims.slice(1, inputs[0].dims.length - 1)) : inputs[0].dims.slice(1, attributes.spatial ? 2 : void 0);\n          checkShapeEqual(inputs[1].dims, shape, "Invalid input scale");\n          checkShapeEqual(inputs[2].dims, shape, "Invalid input B");\n          checkShapeEqual(inputs[3].dims, shape, "Invalid input mean");\n          checkShapeEqual(inputs[4].dims, shape, "Invalid input var");\n        } else {\n          checkShapeEqual(inputs[1].dims, [1], "Invalid input scale");\n          checkShapeEqual(inputs[2].dims, [1], "Invalid input B");\n          checkShapeEqual(inputs[3].dims, [1], "Invalid input mean");\n          checkShapeEqual(inputs[4].dims, [1], "Invalid input var");\n        }\n      };\n      createBatchNormInferenceProgramInfo = (inputs, attributes) => {\n        const { epsilon, spatial, format } = attributes;\n        const yShape = inputs[0].dims;\n        const components = spatial ? getMaxComponents(yShape[yShape.length - 1]) : 1;\n        const cComponents = format === "NHWC" && yShape.length > 1 ? components : 1;\n        const outputSize = ShapeUtil.size(yShape) / components;\n        const useShapesUniforms = enableShapesUniforms(yShape.length) && spatial;\n        const shapeOrRank = useShapesUniforms ? yShape.length : yShape;\n        const x = inputVariable("x", inputs[0].dataType, inputs[0].dims, components);\n        const scale = inputVariable("scale", inputs[1].dataType, inputs[1].dims, cComponents);\n        const bias = inputVariable("bias", inputs[2].dataType, inputs[2].dims, cComponents);\n        const inputMean = inputVariable("inputMean", inputs[3].dataType, inputs[3].dims, cComponents);\n        const inputVar = inputVariable("inputVar", inputs[4].dataType, inputs[4].dims, cComponents);\n        const y = outputVariable("y", inputs[0].dataType, shapeOrRank, components);\n        const calcCOffset = () => {\n          let cOffset = "";\n          if (spatial) {\n            cOffset = `let cOffset = ${yShape.length === 1 ? "0u" : format === "NHWC" ? `outputIndices[${yShape.length - 1}] / ${components}` : "outputIndices[1]"};`;\n          } else {\n            if (format === "NCHW") {\n              cOffset = `\n            ${y.indicesSet("outputIndices", "0", "0")}\n            let cOffset = ${y.indicesToOffset("outputIndices")};`;\n            } else {\n              cOffset = `var cIndices = ${scale.type.indices}(0);\n                       cIndices[0] = outputIndices[${yShape.length - 1}];`;\n              for (let i = 1; i < scale.rank; i++) {\n                cOffset += `cIndices[${i}] = outputIndices[${i}];`;\n              }\n              cOffset += `let cOffset = ${scale.indicesToOffset("cIndices")};`;\n            }\n          }\n          return cOffset;\n        };\n        const getInferenceModeShaderSource = (helper) => `\n  const epsilon = ${epsilon};\n  ${helper.registerUniform("outputSize", "u32").declareVariables(x, scale, bias, inputMean, inputVar, y)}\n  ${helper.mainStart()}\n  ${helper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n    var outputIndices = ${y.offsetToIndices(`global_idx * ${components}`)};\n    ${calcCOffset()}\n    let scale = ${scale.getByOffset("cOffset")};\n    let bias = ${bias.getByOffset("cOffset")};\n    let inputMean = ${inputMean.getByOffset("cOffset")};\n    let inputVar = ${inputVar.getByOffset("cOffset")};\n    let x = ${x.getByOffset("global_idx")};\n    let value = (x - inputMean) * inverseSqrt(inputVar + epsilon) * scale + bias;\n    ${y.setByOffset("global_idx", "value")}\n  }`;\n        return {\n          name: "BatchNormalization",\n          shaderCache: {\n            hint: `${attributes.epsilon}_${attributes.format}_${spatial}_${components}`,\n            inputDependencies: useShapesUniforms ? ["rank", "type", "type", "type", "type"] : void 0\n          },\n          getShaderSource: getInferenceModeShaderSource,\n          getRunData: () => ({\n            outputs: [{ dims: inputs[0].dims, dataType: inputs[0].dataType }],\n            dispatchGroup: { x: Math.ceil(\n              outputSize / 64\n              /* workgroup size */\n            ) },\n            programUniforms: useShapesUniforms ? [\n              { type: "uint32", data: outputSize },\n              ...createTensorShapeVariables(yShape)\n            ] : [\n              { type: "uint32", data: outputSize }\n            ]\n          })\n        };\n      };\n      parseBatchNormAttributes = (attributes) => createAttributeWithCacheKey(attributes);\n      batchNorm = (context, attributes) => {\n        const { inputs, outputCount } = context;\n        const updatedAttributes = parseBatchNormAttributes({ ...attributes, outputCount });\n        if (env2.webgpu.validateInputContent) {\n          validateInputs4(inputs, updatedAttributes);\n        }\n        if (attributes.trainingMode) {\n          throw new Error("BatchNormalization trainingMode is not supported yet.");\n        } else {\n          context.compute(createBatchNormInferenceProgramInfo(inputs, updatedAttributes));\n        }\n      };\n    }\n  });\n\n  // web/lib/wasm/jsep/webgpu/ops/bias-add.ts\n  var validateInputs5, createBiasAddProgramInfo, biasAdd;\n  var init_bias_add = __esm({\n    "web/lib/wasm/jsep/webgpu/ops/bias-add.ts"() {\n      "use strict";\n      init_util();\n      init_common();\n      validateInputs5 = (inputs) => {\n        if (inputs[0].dims.length !== 3) {\n          throw new Error("input should have 3 dimensions");\n        }\n        if (![320, 640, 1280].includes(inputs[0].dims[2])) {\n          throw new Error("number of channels should be 320, 640 or 1280");\n        }\n        if (inputs[1].dims.length !== 1) {\n          throw new Error("bias is expected to have 1 dimensions");\n        }\n        if (inputs[0].dims[2] !== inputs[1].dims[0]) {\n          throw new Error("last dimension of input and bias are not the same");\n        }\n      };\n      createBiasAddProgramInfo = (inputs) => {\n        const outputShape = inputs[0].dims;\n        const channels = inputs[0].dims[2];\n        const outputSize = ShapeUtil.size(outputShape) / 4;\n        const dataType = inputs[0].dataType;\n        const input = inputVariable("input", dataType, outputShape, 4);\n        const bias = inputVariable("bias", dataType, [channels], 4);\n        const residual = inputVariable("residual", dataType, outputShape, 4);\n        const output = outputVariable("output", dataType, outputShape, 4);\n        const getShaderSource = (shaderHelper) => `\n  const channels = ${channels}u / 4;\n  ${shaderHelper.declareVariables(input, bias, residual, output)}\n\n  ${shaderHelper.mainStart()}\n    ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes(outputSize)}\n    let value = ${input.getByOffset("global_idx")}\n      + ${bias.getByOffset("global_idx % channels")} + ${residual.getByOffset("global_idx")};\n    ${output.setByOffset("global_idx", "value")}\n  }`;\n        return {\n          name: "BiasAdd",\n          getRunData: () => ({\n            outputs: [{ dims: outputShape, dataType: inputs[0].dataType }],\n            dispatchGroup: { x: Math.ceil(\n              outputSize / 64\n              /* workgroup size */\n            ) }\n          }),\n          getShaderSource\n        };\n      };\n      biasAdd = (context) => {\n        validateInputs5(context.inputs);\n        context.compute(createBiasAddProgramInfo(context.inputs));\n      };\n    }\n  });\n\n  // web/lib/wasm/jsep/webgpu/ops/unary-op.ts\n  var createElementwiseProgramShader, createElementwiseProgramInfo, abs, acos, acosh, asin, asinh, atan, atanh, parseCastAttributes, cast, generateClipAttributesFromInputs, clip, ceil, cos, cosh, parseAlphaAttributes, elu, erfImpl, erf, exp, floor, gelu, leakyRelu, not, neg, reciprocal, relu, sigmoid, sin, sinh, sqrt, tan, tanh, thresholdedRelu, log;\n  var init_unary_op = __esm({\n    "web/lib/wasm/jsep/webgpu/ops/unary-op.ts"() {\n      "use strict";\n      init_wasm_common();\n      init_util();\n      init_attribute_with_cache_key();\n      init_common();\n      createElementwiseProgramShader = (shaderHelper, datasize, inputDataType, outputDataType, funcCall, additionalImplementation) => {\n        const vecSize = Math.ceil(datasize / 4);\n        let expression = "";\n        if (typeof funcCall === "string") {\n          expression = `${funcCall}(a)`;\n        } else {\n          expression = funcCall("a");\n        }\n        const input = inputVariable("inputData", inputDataType, [vecSize], 4);\n        const output = outputVariable("outputData", outputDataType, [vecSize], 4);\n        return `\n      ${shaderHelper.registerUniform("vec_size", "u32").declareVariables(input, output)}\n\n  ${additionalImplementation ?? ""}\n\n  ${shaderHelper.mainStart()}\n    ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}\n\n    let a = ${input.getByOffset("global_idx")};\n    ${output.setByOffset("global_idx", expression)}\n  }`;\n      };\n      createElementwiseProgramInfo = (input, name, funcCall, additionalImplementation, cacheKey, outputDataType = input.dataType) => ({\n        name,\n        shaderCache: { hint: cacheKey, inputDependencies: ["type"] },\n        getShaderSource: (shaderHelper) => createElementwiseProgramShader(\n          shaderHelper,\n          ShapeUtil.size(input.dims),\n          input.dataType,\n          outputDataType,\n          funcCall,\n          additionalImplementation\n        ),\n        getRunData: (inputTensors) => ({\n          outputs: [{ dims: input.dims, dataType: outputDataType }],\n          dispatchGroup: { x: Math.ceil(\n            ShapeUtil.size(inputTensors[0].dims) / 64 / 4\n            /* vec size */\n          ) },\n          programUniforms: [\n            { type: "uint32", data: Math.ceil(ShapeUtil.size(input.dims) / 4) }\n          ]\n        })\n      });\n      abs = (context) => {\n        context.compute(createElementwiseProgramInfo(context.inputs[0], "Abs", "abs"));\n      };\n      acos = (context) => {\n        context.compute(createElementwiseProgramInfo(context.inputs[0], "Acos", "acos"));\n      };\n      acosh = (context) => {\n        context.compute(createElementwiseProgramInfo(context.inputs[0], "Acosh", "acosh"));\n      };\n      asin = (context) => {\n        context.compute(createElementwiseProgramInfo(context.inputs[0], "Asin", "asin"));\n      };\n      asinh = (context) => {\n        context.compute(createElementwiseProgramInfo(context.inputs[0], "Asinh", "asinh"));\n      };\n      atan = (context) => {\n        context.compute(createElementwiseProgramInfo(context.inputs[0], "Atan", "atan"));\n      };\n      atanh = (context) => {\n        context.compute(createElementwiseProgramInfo(context.inputs[0], "Atanh", "atanh"));\n      };\n      parseCastAttributes = (attributes) => createAttributeWithCacheKey(attributes);\n      cast = (context, attributes) => {\n        let func;\n        switch (attributes.to) {\n          case 10 /* float16 */:\n            func = "vec4<f16>";\n            break;\n          case 1 /* float */:\n            func = "vec4<f32>";\n            break;\n          case 12 /* uint32 */:\n            func = "vec4<u32>";\n            break;\n          case 6 /* int32 */:\n            func = "vec4<i32>";\n            break;\n          case 9 /* bool */:\n            func = "vec4<bool>";\n            break;\n          default:\n            throw new RangeError(`not supported type (specified in attribute \'to\' from \'Cast\' operator): ${attributes.to}`);\n        }\n        context.compute(\n          createElementwiseProgramInfo(context.inputs[0], "Cast", func, void 0, attributes.cacheKey, attributes.to)\n        );\n      };\n      generateClipAttributesFromInputs = (inputs) => {\n        const min = inputs.length >= 2 && inputs[1].data !== 0 ? inputs[1].getFloat32Array()[0] : MIN_CLIP;\n        const max = inputs.length >= 3 && inputs[2].data !== 0 ? inputs[2].getFloat32Array()[0] : MAX_CLIP;\n        return createAttributeWithCacheKey({ min, max });\n      };\n      clip = (context, clipAttributes) => {\n        const attributes = context.inputs.length === 1 ? clipAttributes : generateClipAttributesFromInputs(context.inputs);\n        const dataType = tensorTypeToWsglValueType(context.inputs[0].dataType);\n        context.compute(\n          createElementwiseProgramInfo(\n            context.inputs[0],\n            "Clip",\n            (a) => `clamp(${a}, clip_min_, clip_max_)`,\n            `\n    const clip_min_: vec4<${dataType}> = vec4(${dataType}(${attributes.min}));\n    const clip_max_: vec4<${dataType}> = vec4(${dataType}(${attributes.max}));\n`,\n            attributes.cacheKey\n          ),\n          { inputs: [0] }\n        );\n      };\n      ceil = (context) => {\n        context.compute(createElementwiseProgramInfo(context.inputs[0], "Ceil", "ceil"));\n      };\n      cos = (context) => {\n        context.compute(createElementwiseProgramInfo(context.inputs[0], "Cos", "cos"));\n      };\n      cosh = (context) => {\n        context.compute(createElementwiseProgramInfo(context.inputs[0], "Cosh", "cosh"));\n      };\n      parseAlphaAttributes = (attributes) => createAttributeWithCacheKey(attributes);\n      elu = (context, attributes) => {\n        const dataType = tensorTypeToWsglValueType(context.inputs[0].dataType);\n        context.compute(createElementwiseProgramInfo(\n          context.inputs[0],\n          "Elu",\n          (a) => `elu_vf32(${a})`,\n          `\n  const elu_alpha_ = ${dataType}(${attributes.alpha});\n\n  fn elu_f32(a: ${dataType}) -> ${dataType} {\n  return select((exp(a) - 1.0) * elu_alpha_, a, a >= 0.0);\n  }\n\n  fn elu_vf32(v: vec4<${dataType}>) -> vec4<${dataType}> {\n  return vec4(elu_f32(v.x), elu_f32(v.y), elu_f32(v.z), elu_f32(v.w));\n  }`,\n          attributes.cacheKey\n        ));\n      };\n      erfImpl = (dataType, varType = "f32") => `\nconst r0: ${varType} = 0.3275911;\nconst r1: ${varType} = 0.254829592;\nconst r2: ${varType} = -0.284496736;\nconst r3: ${varType} = 1.421413741;\nconst r4: ${varType} = -1.453152027;\nconst r5: ${varType} = 1.061405429;\n\nfn erf_vf32(v: ${dataType}) -> ${dataType} {\n  let absv = abs(v);\n  let x = 1.0 / (1.0 + r0 * absv);\n  return sign(v) * (1.0 - ((((r5 * x + r4) * x + r3) * x + r2) * x + r1) * x * exp(-absv * absv));\n}`;\n      erf = (context) => {\n        const dataType = tensorTypeToWsglValueType(context.inputs[0].dataType);\n        context.compute(createElementwiseProgramInfo(\n          context.inputs[0],\n          "Erf",\n          (a) => `erf_vf32(${a})`,\n          erfImpl(`vec4<${dataType}>`, dataType)\n        ));\n      };\n      exp = (context) => {\n        context.compute(createElementwiseProgramInfo(context.inputs[0], "Exp", "exp"));\n      };\n      floor = (context) => {\n        context.compute(createElementwiseProgramInfo(context.inputs[0], "Floor", "floor"));\n      };\n      gelu = (context) => {\n        const dataType = tensorTypeToWsglValueType(context.inputs[0].dataType);\n        context.compute(createElementwiseProgramInfo(\n          context.inputs[0],\n          "Gelu",\n          (a) => `0.5 * ${a} * (1.0 + erf_vf32(${a} * 0.7071067811865475))`,\n          erfImpl(`vec4<${dataType}>`, dataType)\n        ));\n      };\n      leakyRelu = (context, attributes) => {\n        const dataType = tensorTypeToWsglValueType(context.inputs[0].dataType);\n        context.compute(createElementwiseProgramInfo(\n          context.inputs[0],\n          "LeakyRelu",\n          (a) => `select(leaky_relu_alpha_ * ${a}, ${a}, ${a} >= vec4<${dataType}>(0.0))`,\n          `const leaky_relu_alpha_ = ${dataType}(${attributes.alpha});`,\n          attributes.cacheKey\n        ));\n      };\n      not = (context) => {\n        context.compute(createElementwiseProgramInfo(context.inputs[0], "Not", (a) => `!${a}`));\n      };\n      neg = (context) => {\n        context.compute(createElementwiseProgramInfo(context.inputs[0], "Neg", (a) => `-${a}`));\n      };\n      reciprocal = (context) => {\n        context.compute(createElementwiseProgramInfo(context.inputs[0], "Reciprocal", (a) => `1.0/${a}`));\n      };\n      relu = (context) => {\n        const dataType = tensorTypeToWsglValueType(context.inputs[0].dataType);\n        context.compute(createElementwiseProgramInfo(\n          context.inputs[0],\n          "Relu",\n          (a) => `select(vec4<${dataType}>(0.0), ${a}, ${a} > vec4<${dataType}>(0.0))`\n        ));\n      };\n      sigmoid = (context) => {\n        context.compute(createElementwiseProgramInfo(context.inputs[0], "Sigmoid", (a) => `(1.0 / (1.0 + exp(-${a})))`));\n      };\n      sin = (context) => {\n        context.compute(createElementwiseProgramInfo(context.inputs[0], "Sin", "sin"));\n      };\n      sinh = (context) => {\n        context.compute(createElementwiseProgramInfo(context.inputs[0], "Sinh", "sinh"));\n      };\n      sqrt = (context) => {\n        context.compute(createElementwiseProgramInfo(context.inputs[0], "Sqrt", "sqrt"));\n      };\n      tan = (context) => {\n        context.compute(createElementwiseProgramInfo(context.inputs[0], "Tan", "tan"));\n      };\n      tanh = (context) => {\n        context.compute(createElementwiseProgramInfo(context.inputs[0], "Tanh", "tanh"));\n      };\n      thresholdedRelu = (context, attributes) => {\n        const dataType = tensorTypeToWsglValueType(context.inputs[0].dataType);\n        context.compute(createElementwiseProgramInfo(\n          context.inputs[0],\n          "ThresholdedRelu",\n          (a) => `select(vec4<${dataType}>(0.0), ${a}, ${a} > thresholded_relu_alpha_)`,\n          `const thresholded_relu_alpha_ = vec4<${dataType}>(${attributes.alpha});`,\n          attributes.cacheKey\n        ));\n        return 0;\n      };\n      log = (context) => {\n        context.compute(createElementwiseProgramInfo(context.inputs[0], "Log", "log"));\n      };\n    }\n  });\n\n  // web/lib/wasm/jsep/webgpu/ops/bias-split-gelu.ts\n  var validateInputs6, createBiasSplitGeluProgramInfo, biasSplitGelu;\n  var init_bias_split_gelu = __esm({\n    "web/lib/wasm/jsep/webgpu/ops/bias-split-gelu.ts"() {\n      "use strict";\n      init_util();\n      init_common();\n      init_unary_op();\n      validateInputs6 = (inputs) => {\n        if (inputs[0].dims.length !== 3) {\n          throw new Error("input should have 3 dimensions");\n        }\n        if (![2560, 5120, 10240].includes(inputs[0].dims[2])) {\n          throw new Error("hidden state should be 2560, 5120 or 10240");\n        }\n        if (inputs[1].dims.length !== 1) {\n          throw new Error("bias is expected to have 1 dimensions");\n        }\n        if (inputs[0].dims[2] !== inputs[1].dims[0]) {\n          throw new Error("last dimension of input and bias are not the same");\n        }\n      };\n      createBiasSplitGeluProgramInfo = (inputs) => {\n        const outputShape = inputs[0].dims.slice();\n        outputShape[2] = outputShape[2] / 2;\n        const input = inputVariable("input", inputs[0].dataType, inputs[0].dims, 4);\n        const bias = inputVariable("bias", inputs[0].dataType, [inputs[0].dims[2]], 4);\n        const output = outputVariable("output", inputs[0].dataType, outputShape, 4);\n        const outputSize = ShapeUtil.size(outputShape) / 4;\n        const dataType = tensorTypeToWsglStorageType(inputs[0].dataType);\n        const getShaderSource = (shaderHelper) => `\n  const M_SQRT2 = sqrt(2.0);\n  const halfChannels = ${inputs[0].dims[2] / 4 / 2}u;\n\n  ${shaderHelper.declareVariables(input, bias, output)}\n\n  ${erfImpl(`vec4<${dataType}>`, dataType)}\n\n  ${shaderHelper.mainStart()}\n    ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes(outputSize)}\n    let biasIdx = global_idx % halfChannels;\n    let batchIndex = global_idx / halfChannels;\n    let inputOffset = biasIdx + batchIndex * halfChannels * 2;\n    let valueLeft = input[inputOffset] + bias[biasIdx];\n    let valueRight = input[inputOffset + halfChannels] + bias[biasIdx + halfChannels];\n    let geluRight = valueRight * 0.5 * (erf_vf32(valueRight / M_SQRT2) + 1);\n\n    ${output.setByOffset("global_idx", "valueLeft * geluRight")}\n  }`;\n        return {\n          name: "BiasSplitGelu",\n          getRunData: () => ({\n            outputs: [{ dims: outputShape, dataType: inputs[0].dataType }],\n            dispatchGroup: { x: Math.ceil(\n              outputSize / 64\n              /* workgroup size */\n            ) }\n          }),\n          getShaderSource\n        };\n      };\n      biasSplitGelu = (context) => {\n        validateInputs6(context.inputs);\n        context.compute(createBiasSplitGeluProgramInfo(context.inputs));\n      };\n    }\n  });\n\n  // web/lib/wasm/jsep/webgpu/ops/binary-op.ts\n  var createBinaryOpProgramShader, createBinaryOpProgramInfo, runBinaryOp, add, div, equal, mul, pow, sub, greater, less, greaterOrEqual, lessOrEqual;\n  var init_binary_op = __esm({\n    "web/lib/wasm/jsep/webgpu/ops/binary-op.ts"() {\n      "use strict";\n      init_wasm_common();\n      init_util();\n      init_common();\n      createBinaryOpProgramShader = (shaderHelper, dimsA, dimsB, dimsOutput, vectorize, doBroadcast, sharedDimensionDivisibleBy4, funcCall, typeA, typeB, typeOutput, useShapesUniforms, additionalImplementation) => {\n        let expressionScalar;\n        let expressionVector;\n        if (typeof funcCall === "string") {\n          expressionScalar = expressionVector = (a2, b2) => `${funcCall}((${a2}),(${b2}))`;\n        } else if (typeof funcCall === "function") {\n          expressionScalar = expressionVector = funcCall;\n        } else {\n          expressionScalar = funcCall.scalar;\n          expressionVector = funcCall.vector;\n        }\n        const inputAShapeOrRank = useShapesUniforms ? dimsA.length : dimsA;\n        const inputBShapeOrRank = useShapesUniforms ? dimsB.length : dimsB;\n        const outputShapeOrRank = useShapesUniforms ? dimsOutput.length : dimsOutput;\n        const output = outputVariable("outputData", typeOutput, outputShapeOrRank, 4);\n        const a = inputVariable("aData", typeA, inputAShapeOrRank, 4);\n        const b = inputVariable("bData", typeB, inputBShapeOrRank, 4);\n        let assignment;\n        if (vectorize) {\n          if (doBroadcast) {\n            const isAOneElement = ShapeUtil.size(dimsA) === 1;\n            const isBOneElement = ShapeUtil.size(dimsB) === 1;\n            const aLastDimDivisibleBy4 = dimsA.length > 0 && dimsA[dimsA.length - 1] % 4 === 0;\n            const bLastDimDivisibleBy4 = dimsB.length > 0 && dimsB[dimsB.length - 1] % 4 === 0;\n            if (isAOneElement || isBOneElement) {\n              assignment = output.setByOffset(\n                "global_idx",\n                expressionVector(\n                  isAOneElement ? `${a.type.value}(${a.getByOffset("0")}.x)` : a.getByOffset("global_idx"),\n                  isBOneElement ? `${b.type.value}(${b.getByOffset("0")}.x)` : b.getByOffset("global_idx")\n                )\n              );\n            } else {\n              assignment = `\n            let outputIndices = ${output.offsetToIndices("global_idx * 4u")};\n            let offsetA = ${a.broadcastedIndicesToOffset("outputIndices", output)};\n            let offsetB = ${b.broadcastedIndicesToOffset("outputIndices", output)};\n            ${output.setByOffset(\n                "global_idx",\n                expressionVector(\n                  sharedDimensionDivisibleBy4 || aLastDimDivisibleBy4 ? a.getByOffset("offsetA / 4u") : `${a.type.value}(${a.getByOffset("offsetA / 4u")}[offsetA % 4u])`,\n                  sharedDimensionDivisibleBy4 || bLastDimDivisibleBy4 ? b.getByOffset("offsetB / 4u") : `${b.type.value}(${b.getByOffset("offsetB / 4u")}[offsetB % 4u])`\n                )\n              )}\n          `;\n            }\n          } else {\n            assignment = output.setByOffset(\n              "global_idx",\n              expressionVector(a.getByOffset("global_idx"), b.getByOffset("global_idx"))\n            );\n          }\n        } else {\n          if (!doBroadcast) {\n            throw new Error("no necessary to use scalar implementation for element-wise binary op implementation.");\n          }\n          const singleAssignment = (resStr, x, typeCast = "") => {\n            const expressionA = `aData[indexA${x}][componentA${x}]`;\n            const expressionB = `bData[indexB${x}][componentB${x}]`;\n            return `\n            let outputIndices${x} = ${output.offsetToIndices(`global_idx * 4u + ${x}u`)};\n            let offsetA${x} = ${a.broadcastedIndicesToOffset(`outputIndices${x}`, output)};\n            let offsetB${x} = ${b.broadcastedIndicesToOffset(`outputIndices${x}`, output)};\n            let indexA${x} = offsetA${x} / 4u;\n            let indexB${x} = offsetB${x} / 4u;\n            let componentA${x} = offsetA${x} % 4u;\n            let componentB${x} = offsetB${x} % 4u;\n            ${resStr}[${x}] = ${typeCast}(${expressionScalar(expressionA, expressionB)});\n          `;\n          };\n          if (typeOutput === 9 /* bool */) {\n            assignment = `\n            var data = vec4<u32>(0);\n            ${singleAssignment("data", 0, "u32")}\n            ${singleAssignment("data", 1, "u32")}\n            ${singleAssignment("data", 2, "u32")}\n            ${singleAssignment("data", 3, "u32")}\n            outputData[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`;\n          } else {\n            assignment = `\n            ${singleAssignment("outputData[global_idx]", 0)}\n            ${singleAssignment("outputData[global_idx]", 1)}\n            ${singleAssignment("outputData[global_idx]", 2)}\n            ${singleAssignment("outputData[global_idx]", 3)}\n          `;\n          }\n        }\n        return `\n        ${shaderHelper.registerUniform("vec_size", "u32").declareVariables(a, b, output)}\n\n        ${additionalImplementation ?? ""}\n\n        ${shaderHelper.mainStart()}\n        ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}\n        ${assignment}\n      }`;\n      };\n      createBinaryOpProgramInfo = (name, cacheKey, a, b, funcCall, additionalImplementation, outputDataType = a.dataType) => {\n        const isBroadcast = !ShapeUtil.areEqual(a.dims, b.dims);\n        let outputShape = a.dims;\n        let outputSize = ShapeUtil.size(a.dims);\n        let vectorize = false;\n        let sharedDimensionDivisibleBy4 = false;\n        const cacheKeyAux = [isBroadcast];\n        if (isBroadcast) {\n          const calculatedShape = BroadcastUtil.calcShape(a.dims, b.dims, false);\n          if (!calculatedShape) {\n            throw new Error("Can\'t perform binary op on the given tensors");\n          }\n          outputShape = calculatedShape;\n          outputSize = ShapeUtil.size(outputShape);\n          const isAOneElement = ShapeUtil.size(a.dims) === 1;\n          const isBOneElement = ShapeUtil.size(b.dims) === 1;\n          const aLastDimDivisibleBy4 = a.dims.length > 0 && a.dims[a.dims.length - 1] % 4 === 0;\n          const bLastDimDivisibleBy4 = b.dims.length > 0 && b.dims[b.dims.length - 1] % 4 === 0;\n          cacheKeyAux.push(isAOneElement);\n          cacheKeyAux.push(isBOneElement);\n          cacheKeyAux.push(aLastDimDivisibleBy4);\n          cacheKeyAux.push(bLastDimDivisibleBy4);\n          let sharedDimension = 1;\n          for (let i = 1; i < outputShape.length; i++) {\n            const dimA = a.dims[a.dims.length - i] ?? 1;\n            const dimB = b.dims[b.dims.length - i] ?? 1;\n            if (dimA === dimB) {\n              sharedDimension *= dimA;\n            } else {\n              break;\n            }\n          }\n          if (sharedDimension % 4 === 0) {\n            sharedDimensionDivisibleBy4 = true;\n            vectorize = true;\n          } else if (isAOneElement || isBOneElement || aLastDimDivisibleBy4 || bLastDimDivisibleBy4) {\n            vectorize = true;\n          }\n        } else {\n          vectorize = true;\n        }\n        cacheKeyAux.push(vectorize);\n        const useShapesUniforms = enableShapesUniforms(a.dims.length) && enableShapesUniforms(b.dims.length) && enableShapesUniforms(outputShape.length);\n        return {\n          name,\n          shaderCache: {\n            hint: cacheKey + cacheKeyAux.map((x) => x.toString()).join("_"),\n            inputDependencies: useShapesUniforms ? ["rank", "rank"] : ["dims", "dims"]\n          },\n          getShaderSource: (shaderHelper) => createBinaryOpProgramShader(\n            shaderHelper,\n            a.dims,\n            b.dims,\n            outputShape,\n            vectorize,\n            isBroadcast,\n            sharedDimensionDivisibleBy4,\n            funcCall,\n            a.dataType,\n            b.dataType,\n            outputDataType,\n            useShapesUniforms,\n            additionalImplementation\n          ),\n          getRunData: () => ({\n            outputs: [{ dims: outputShape, dataType: outputDataType }],\n            dispatchGroup: { x: Math.ceil(\n              outputSize / 64 / 4\n              /* component size */\n            ) },\n            programUniforms: useShapesUniforms ? [\n              { type: "uint32", data: Math.ceil(ShapeUtil.size(outputShape) / 4) },\n              ...createTensorShapeVariables(a.dims),\n              ...createTensorShapeVariables(b.dims),\n              ...createTensorShapeVariables(outputShape)\n            ] : [\n              { type: "uint32", data: Math.ceil(ShapeUtil.size(outputShape) / 4) }\n            ]\n          })\n        };\n      };\n      runBinaryOp = (context, name, funcCall, additionalImplementation, cacheKey, outputDataType) => {\n        context.compute(createBinaryOpProgramInfo(\n          name,\n          cacheKey ?? "",\n          context.inputs[0],\n          context.inputs[1],\n          funcCall,\n          additionalImplementation,\n          outputDataType\n        ));\n      };\n      add = (context) => {\n        runBinaryOp(context, "Add", (a, b) => `${a}+${b}`);\n      };\n      div = (context) => {\n        runBinaryOp(context, "Div", (a, b) => `${a}/${b}`);\n      };\n      equal = (context) => {\n        runBinaryOp(\n          context,\n          "Equal",\n          { scalar: (a, b) => `u32(${a}==${b})`, vector: (a, b) => `vec4<u32>(${a}==${b})` },\n          void 0,\n          void 0,\n          9 /* bool */\n        );\n      };\n      mul = (context) => {\n        runBinaryOp(context, "Mul", (a, b) => `${a}*${b}`);\n      };\n      pow = (context) => {\n        const type = inputVariable("input", context.inputs[0].dataType, context.inputs[0].dims).type.value;\n        const roundStr = type === "i32" ? "round" : "";\n        runBinaryOp(\n          context,\n          "Pow",\n          { scalar: (a, b) => `pow_custom(${a},${b})`, vector: (a, b) => `pow_vector_custom(${a},${b})` },\n          `\n    fn pow_custom(a : ${type}, b : ${type}) -> ${type} {\n      if (b == ${type}(0.0)) {\n        return ${type}(1.0);\n      } else if (a < ${type}(0.0) && f32(b) != floor(f32(b))) {\n        return ${type}(pow(f32(a), f32(b))); // NaN\n      }\n      return select(sign(a), ${type}(1.0), round(f32(abs(b) % ${type}(2.0))) != 1.0) * ${type}(${roundStr}(pow(f32(abs(a)), f32(b))));\n    }\n    fn pow_vector_custom(a : vec4<${type}>, b : vec4<${type}>) -> vec4<${type}> {\n      // TODO: implement vectorized pow\n      return vec4<${type}>(pow_custom(a.x, b.x), pow_custom(a.y, b.y), pow_custom(a.z, b.z), pow_custom(a.w, b.w));\n    }\n      `\n        );\n      };\n      sub = (context) => {\n        runBinaryOp(context, "Sub", (a, b) => `${a}-${b}`);\n      };\n      greater = (context) => {\n        runBinaryOp(\n          context,\n          "Greater",\n          { scalar: (a, b) => `u32(${a}>${b})`, vector: (a, b) => `vec4<u32>(${a}>${b})` },\n          void 0,\n          void 0,\n          9 /* bool */\n        );\n      };\n      less = (context) => {\n        runBinaryOp(\n          context,\n          "Less",\n          { scalar: (a, b) => `u32(${a}<${b})`, vector: (a, b) => `vec4<u32>(${a}<${b})` },\n          void 0,\n          void 0,\n          9 /* bool */\n        );\n      };\n      greaterOrEqual = (context) => {\n        runBinaryOp(\n          context,\n          "GreaterOrEqual",\n          { scalar: (a, b) => `u32(${a}>=${b})`, vector: (a, b) => `vec4<u32>(${a}>=${b})` },\n          void 0,\n          void 0,\n          9 /* bool */\n        );\n      };\n      lessOrEqual = (context) => {\n        runBinaryOp(\n          context,\n          "LessOrEqual",\n          { scalar: (a, b) => `u32(${a}<=${b})`, vector: (a, b) => `vec4<u32>(${a}<=${b})` },\n          void 0,\n          void 0,\n          9 /* bool */\n        );\n      };\n    }\n  });\n\n  // web/lib/wasm/jsep/webgpu/ops/concat.ts\n  var validateInputs7, calculateInputIndexImpl, assignOutputData, createConcatProgramInfo, concat, parseConcatAttributes;\n  var init_concat = __esm({\n    "web/lib/wasm/jsep/webgpu/ops/concat.ts"() {\n      "use strict";\n      init_util();\n      init_attribute_with_cache_key();\n      init_common();\n      validateInputs7 = (inputs) => {\n        if (!inputs || inputs.length < 1) {\n          throw new Error("too few inputs");\n        }\n        const inputType = inputs[0].dataType;\n        const inputDimensionality = inputs[0].dims.length;\n        for (const input of inputs) {\n          if (input.dataType !== inputType) {\n            throw new Error("input tensors should be one type");\n          }\n          if (input.dims.length !== inputDimensionality) {\n            throw new Error("input tensors should have the same shape");\n          }\n        }\n      };\n      calculateInputIndexImpl = (numberOfTensors, sizeInConcatAxisStr) => `\n  fn calculateInputIndex(index: u32) -> u32 {\n    let sizeInConcatAxis = array<u32, ${numberOfTensors}u>(${sizeInConcatAxisStr});\n    for (var i: u32 = 0u; i < ${numberOfTensors}; i += 1u ) {\n      if (index < sizeInConcatAxis[i]) {\n        return i;\n      }\n    }\n    return ${numberOfTensors}u;\n  }`;\n      assignOutputData = (inputs, output) => {\n        const numberOfTensors = inputs.length;\n        const codeLines = [];\n        for (let i = 0; i < numberOfTensors; ++i) {\n          const returnSnippet = output.setByOffset("global_idx", inputs[i].getByIndices("indices"));\n          if (numberOfTensors === 1) {\n            codeLines.push(returnSnippet);\n          } else if (i === 0) {\n            codeLines.push(`if (inputIndex == ${i}u) { ${returnSnippet} }`);\n          } else if (i === numberOfTensors - 1) {\n            codeLines.push(`else { ${returnSnippet} }`);\n          } else {\n            codeLines.push(`else if (inputIndex == ${i}) { ${returnSnippet} }`);\n          }\n        }\n        return codeLines.join("\\n");\n      };\n      createConcatProgramInfo = (inputs, axis) => {\n        const inputShape = inputs[0].dims.slice();\n        if (axis >= inputShape.length || axis < -1 * inputShape.length) {\n          throw new Error("axis specified for concat doesn\'t match input dimensionality");\n        }\n        const adjustedAxis = axis < 0 ? inputShape.length + axis : axis;\n        const outputShape = inputShape.slice(0);\n        for (let i = 1; i < inputs.length; i++) {\n          const dataNShape = inputs[i].dims.slice();\n          for (let axisIndex = 0; axisIndex < inputShape.length; axisIndex++) {\n            if (axisIndex === adjustedAxis) {\n              outputShape[adjustedAxis] += dataNShape[axisIndex];\n            } else if (inputShape[axisIndex] !== dataNShape[axisIndex]) {\n              throw new Error("non concat dimensions must match");\n            }\n          }\n        }\n        const outputSize = ShapeUtil.size(outputShape);\n        const sizeInConcatAxis = new Array(inputs.length);\n        const inputVars = new Array(inputs.length);\n        const dataType = inputs[0].dataType;\n        let previousSum = 0;\n        const inputDependencies = [];\n        const inputShapeOrRanks = [];\n        const enableInputShapesUniforms = [];\n        const programUniforms = [{ type: "uint32", data: outputSize }];\n        for (let i = 0; i < inputs.length; ++i) {\n          previousSum += inputs[i].dims[adjustedAxis];\n          sizeInConcatAxis[i] = previousSum;\n          enableInputShapesUniforms.push(enableShapesUniforms(inputs[i].dims.length));\n          inputShapeOrRanks.push(enableInputShapesUniforms[i] ? inputs[i].dims.length : inputs[i].dims);\n          inputVars[i] = inputVariable(`input${i}`, dataType, inputShapeOrRanks[i]);\n          inputDependencies.push(enableInputShapesUniforms[i] ? "rank" : "dims");\n          programUniforms.push({ type: "uint32", data: sizeInConcatAxis[i] });\n        }\n        for (let i = 0; i < inputs.length; ++i) {\n          if (enableInputShapesUniforms[i]) {\n            programUniforms.push(...createTensorShapeVariables(inputs[i].dims));\n          }\n        }\n        const enableOutputShapesUniforms = enableShapesUniforms(outputShape.length);\n        if (enableOutputShapesUniforms) {\n          programUniforms.push(...createTensorShapeVariables(outputShape));\n        }\n        const outputShapeOrRank = enableOutputShapesUniforms ? outputShape.length : outputShape;\n        const output = outputVariable("output", dataType, outputShapeOrRank);\n        const indicesAxis = output.indicesGet("indices", adjustedAxis);\n        const sizeInConcatAxisStr = Array.from(Array(sizeInConcatAxis.length).keys()).map((i) => `uniforms.sizeInConcatAxis${i}`).join(",");\n        const getShaderSource = (shaderHelper) => `\n\n  ${(() => {\n          shaderHelper.registerUniform("outputSize", "u32");\n          for (let i = 0; i < inputs.length; i++) {\n            shaderHelper.registerUniform(`sizeInConcatAxis${i}`, "u32");\n          }\n          return shaderHelper.declareVariables(...inputVars, output);\n        })()}\n\n  ${calculateInputIndexImpl(sizeInConcatAxis.length, sizeInConcatAxisStr)}\n\n  ${shaderHelper.mainStart()}\n    ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n\n    var indices = ${output.offsetToIndices("global_idx")};\n\n    let inputIndex = calculateInputIndex(${indicesAxis});\n    if (inputIndex != 0u) {\n      let sizeInConcatAxis = array<u32, ${sizeInConcatAxis.length}u>(${sizeInConcatAxisStr});\n      ${indicesAxis} -= sizeInConcatAxis[inputIndex - 1u];\n    }\n\n    ${assignOutputData(inputVars, output)}\n  }`;\n        return {\n          name: "Concat",\n          shaderCache: { hint: `${axis}`, inputDependencies },\n          getRunData: () => ({\n            outputs: [{ dims: outputShape, dataType: inputs[0].dataType }],\n            dispatchGroup: { x: Math.ceil(\n              outputSize / 64\n              /* workgroup size */\n            ) },\n            programUniforms\n          }),\n          getShaderSource\n        };\n      };\n      concat = (context, attributes) => {\n        validateInputs7(context.inputs);\n        context.compute(createConcatProgramInfo(context.inputs, attributes.axis));\n      };\n      parseConcatAttributes = (attributes) => createAttributeWithCacheKey({ axis: attributes.axis });\n    }\n  });\n\n  // web/lib/wasm/jsep/webgpu/ops/fuse-utils.ts\n  var getActivationSnippet, parseInternalActivationAttributes;\n  var init_fuse_utils = __esm({\n    "web/lib/wasm/jsep/webgpu/ops/fuse-utils.ts"() {\n      "use strict";\n      init_util();\n      getActivationSnippet = (attributes, valueType) => {\n        switch (attributes.activation) {\n          case "Relu":\n            return { activationFunction: "", applyActivation: `value = max(value, ${valueType}(0.0));` };\n          case "Sigmoid":\n            return {\n              activationFunction: "",\n              applyActivation: `value = (${valueType}(1.0) / (${valueType}(1.0) + exp(-value)));`\n            };\n          case "Clip":\n            return {\n              activationFunction: `const clip_min_=${valueType}(${attributes.clipMin});const clip_max_=${valueType}(${attributes.clipMax});`,\n              applyActivation: "value = clamp(value, clip_min_, clip_max_);"\n            };\n          default:\n            return { activationFunction: "", applyActivation: "" };\n        }\n      };\n      parseInternalActivationAttributes = (attributes) => {\n        const activation = attributes?.activation || "";\n        if (activation === "Clip") {\n          const [clipMin, clipMax] = attributes?.activation_params || [MIN_CLIP, MAX_CLIP];\n          return { activation, clipMax, clipMin, activationCacheKey: `${activation}:${clipMin},${clipMax}` };\n        }\n        return { activation, activationCacheKey: activation };\n      };\n    }\n  });\n\n  // web/lib/wasm/jsep/webgpu/ops/3rd-party/activation_util.ts\n  var typeSnippet, biasSnippet;\n  var init_activation_util = __esm({\n    "web/lib/wasm/jsep/webgpu/ops/3rd-party/activation_util.ts"() {\n      "use strict";\n      typeSnippet = (component, dataType) => {\n        switch (component) {\n          case 1:\n            return dataType;\n          case 2:\n            return `vec2<${dataType}>`;\n          case 3:\n            return `vec3<${dataType}>`;\n          case 4:\n            return `vec4<${dataType}>`;\n          default:\n            throw new Error(`${component}-component is not supported.`);\n        }\n      };\n      biasSnippet = (hasBias) => `\n      ${hasBias ? "value = value + getBiasByOutputCoords(coords);" : ""}\n      `;\n    }\n  });\n\n  // web/lib/wasm/jsep/webgpu/ops/3rd-party/conv_util.ts\n  var utilFunctions;\n  var init_conv_util = __esm({\n    "web/lib/wasm/jsep/webgpu/ops/3rd-party/conv_util.ts"() {\n      "use strict";\n      utilFunctions = (strideStr) => `\nfn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {\n  return dot(coords, vec4<i32>(\n      shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));\n}\nfn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {\n  return dot(coords, vec4<i32>(\n    i32(${strideStr}.x), i32(${strideStr}.y), i32(${strideStr}.z), 1));\n}\n`;\n    }\n  });\n\n  // web/lib/wasm/jsep/webgpu/ops/3rd-party/matmul_packed_webgpu.ts\n  var writeDataToSubAVec4Snippet, calculateResultSnippet, makeMatMulPackedVec4Source, writeDataToSubASnippet, readDataFromSubASnippet, makeMatMulPackedSource, matMulReadWriteFnSource, createMatmulProgramInfo;\n  var init_matmul_packed_webgpu = __esm({\n    "web/lib/wasm/jsep/webgpu/ops/3rd-party/matmul_packed_webgpu.ts"() {\n      "use strict";\n      init_util();\n      init_common();\n      init_fuse_utils();\n      init_activation_util();\n      writeDataToSubAVec4Snippet = (transpose2, batchDims) => {\n        if (transpose2) {\n          return `\n        mm_Asub[inputRow][inputCol] = mm_readA(batch,\n          kStart + inputRow,\n          globalRowStart / innerElementSize + inputCol${batchDims ? ", batchIndices" : ""});\n        `;\n        } else {\n          return `\n        mm_Asub[inputRow][inputCol] = mm_readA(batch,\n          globalRow + innerRow,\n          kStart / innerElementSize + inputCol${batchDims ? ", batchIndices" : ""});\n        `;\n        }\n      };\n      calculateResultSnippet = (transposeA, innerElementSize) => {\n        if (transposeA) {\n          return `\n        let ACached0 = mm_Asub[k * innerElementSize][localRow];\n        let ACached1 = mm_Asub[k * innerElementSize + 1][localRow];\n        let ACached2 = mm_Asub[k * innerElementSize + 2][localRow];\n        ${innerElementSize === 3 ? "" : "let ACached3 = mm_Asub[k * innerElementSize + 3][localRow];"}\n        for (var i = 0; i < rowPerThread; i = i + 1) {\n          acc[i] = BCached0 * ACached0[i] + acc[i];\n          acc[i] = BCached1 * ACached1[i] + acc[i];\n          acc[i] = BCached2 * ACached2[i] + acc[i];\n          ${innerElementSize === 3 ? "" : "acc[i] = BCached3 * ACached3[i] + acc[i];"}\n        }`;\n        } else {\n          return `\n        for (var i = 0; i < rowPerThread; i = i + 1) {\n          let ACached = mm_Asub[tileRow + i][k];\n          acc[i] = BCached0 * ACached.x + acc[i];\n          acc[i] = BCached1 * ACached.y + acc[i];\n          acc[i] = BCached2 * ACached.z + acc[i];\n          ${innerElementSize === 3 ? "" : "acc[i] = BCached3 * ACached.w + acc[i];"}\n        }`;\n        }\n      };\n      makeMatMulPackedVec4Source = (workPerThread, workgroupSize, type = "f32", batchDims, transposeA = false, tileInner = 32, splitK = false, splitedDimInner = 32) => {\n        const tileAOuter = workgroupSize[1] * workPerThread[1];\n        const tileBOuter = workgroupSize[0] * workPerThread[0];\n        const tileAWidth = transposeA ? tileAOuter : tileInner;\n        const tileAHight = transposeA ? tileInner : tileAOuter;\n        const innerElementSize = tileAWidth / workgroupSize[0];\n        const rowPerThreadB = tileInner / workgroupSize[1];\n        if (!((transposeA && innerElementSize === 4 && workPerThread[1] === 4 || !transposeA && (innerElementSize === 3 || innerElementSize === 4)) && tileAWidth % workgroupSize[0] === 0 && tileInner % workgroupSize[1] === 0 && workPerThread[0] === 4)) {\n          throw new Error(`If transposeA ${transposeA} is true, innerElementSize ${innerElementSize} and workPerThread[1] ${workPerThread[1]} must be 4.\n      Otherwise, innerElementSize ${innerElementSize} must be 3 or 4.\n  tileAWidth ${tileAWidth} must be divisible by workgroupSize[0]${workgroupSize[0]}. tileInner ${tileInner} must be divisible by workgroupSize[1] ${workgroupSize[1]}. colPerThread ${workPerThread[0]} must be 4.`);\n        }\n        return `\nvar<workgroup> mm_Asub: array<array<vec${innerElementSize}<${type}>, ${tileAWidth / innerElementSize}>, ${tileAHight}>;\nvar<workgroup> mm_Bsub: array<array<vec4<${type}>, ${tileBOuter / workPerThread[0]}>, ${tileInner}>;\n\nconst rowPerThread = ${workPerThread[1]};\nconst colPerThread = ${workPerThread[0]};\nconst innerElementSize = ${innerElementSize};\nconst tileInner = ${tileInner};\n\n@compute @workgroup_size(${workgroupSize[0]}, ${workgroupSize[1]}, ${workgroupSize[2]})\nfn main(@builtin(local_invocation_id) localId : vec3<u32>,\n        @builtin(global_invocation_id) globalId : vec3<u32>,\n        @builtin(workgroup_id) workgroupId : vec3<u32>) {\n  let localRow = i32(localId.y);\n  let tileRow = localRow * rowPerThread;\n  let tileCol = i32(localId.x);\n\n  let globalRow =i32(globalId.y) * rowPerThread;\n  let globalCol = i32(globalId.x);\n  let batch = ${splitK ? "0" : "i32(globalId.z)"};\n  ${batchDims ? `let batchIndices = ${batchDims.offsetToIndices("u32(batch)")};` : ""}\n  let globalRowStart = i32(workgroupId.y) * ${tileAOuter};\n\n  let numTiles = ${splitK ? `${Math.ceil(splitedDimInner / tileInner)}` : "(uniforms.dimInner - 1) / tileInner + 1"};\n  var kStart = ${splitK ? `i32(globalId.z) * ${splitedDimInner}` : "0"};\n\n  var acc: array<vec4<${type}>, rowPerThread>;\n\n  // Loop over shared dimension.\n  let tileRowB = localRow * ${rowPerThreadB};\n  for (var t = 0; t < numTiles; t = t + 1) {\n      // Load one tile of A into local memory.\n      for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n          let inputRow = tileRow + innerRow;\n          let inputCol = tileCol;\n          ${writeDataToSubAVec4Snippet(transposeA, batchDims)}\n      }\n\n      // Load one tile of B into local memory.\n      for (var innerRow = 0; innerRow < ${rowPerThreadB}; innerRow = innerRow + 1) {\n          let inputRow = tileRowB + innerRow;\n          let inputCol = tileCol;\n          mm_Bsub[inputRow][inputCol] = mm_readB(batch, kStart + inputRow, globalCol${batchDims ? ", batchIndices" : ""});\n      }\n      kStart = kStart + tileInner;\n      workgroupBarrier();\n\n      // Compute acc values for a single thread.\n      for (var k = 0; k < tileInner / innerElementSize; k = k + 1) {\n          let BCached0 = mm_Bsub[k * innerElementSize][tileCol];\n          let BCached1 = mm_Bsub[k * innerElementSize + 1][tileCol];\n          let BCached2 = mm_Bsub[k * innerElementSize + 2][tileCol];\n          ${innerElementSize === 3 ? "" : "let BCached3 = mm_Bsub[k * innerElementSize + 3][tileCol];"}\n\n          ${calculateResultSnippet(transposeA, innerElementSize)}\n      }\n\n      workgroupBarrier();\n  }\n\n  for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n      mm_write(batch, globalRow + innerRow, globalCol, acc[innerRow]);\n  }\n}`;\n      };\n      writeDataToSubASnippet = (transpose2, batchDims) => {\n        if (transpose2) {\n          return `\n            mm_Asub[inputRow][inputCol] = mm_readA(batch,\n              kStart + inputRow,\n              globalRowStart + inputCol${batchDims ? ", batchIndices" : ""});\n            `;\n        } else {\n          return `\n            mm_Asub[inputRow][inputCol] = mm_readA(batch,\n              globalRowStart + inputRow,\n              kStart + inputCol${batchDims ? ", batchIndices" : ""});\n            `;\n        }\n      };\n      readDataFromSubASnippet = (transposeA) => transposeA ? "let ACached = mm_Asub[k][tileRow + innerRow];" : "let ACached = mm_Asub[tileRow + innerRow][k];";\n      makeMatMulPackedSource = (workPerThread, workgroupSize, type = "f32", batchDims, transposeA = false, tileInner = 32, splitK = false, splitedDimInner = 32, sequentialAccessByThreads = false) => {\n        const tileAOuter = workPerThread[1] * workgroupSize[1];\n        const tileBOuter = workPerThread[0] * workgroupSize[0];\n        const tileAWidth = transposeA ? tileAOuter : tileInner;\n        const tileAHight = transposeA ? tileInner : tileAOuter;\n        if (!(tileAHight % workgroupSize[1] === 0 && tileAWidth % workgroupSize[0] === 0 && tileInner % workgroupSize[1] === 0)) {\n          throw new Error(`tileAHight ${tileAHight} must be divisible by workgroupSize[1]${workgroupSize[1]}, tileAWidth ${tileAWidth} must be divisible by workgroupSize[0]${workgroupSize[0]}, tileInner ${tileInner} must be divisible by workgroupSize[1]${workgroupSize[1]}`);\n        }\n        const rowPerThreadA = tileAHight / workgroupSize[1];\n        const colPerThreadA = tileAWidth / workgroupSize[0];\n        const rowPerThreadB = tileInner / workgroupSize[1];\n        const matmulSnippet = sequentialAccessByThreads ? `\n    let localRow = i32(localId.y);\n    let localCol = i32(localId.x);\n    let globalRowStart = i32(workgroupId.y) * ${tileAOuter};\n    let globalColStart = i32(workgroupId.x) * ${tileBOuter};\n\n    // Loop over shared dimension.\n    for (var t = 0; t < numTiles; t = t + 1) {\n      // Load one tile of A into local memory.\n      for (var inputRow = localRow; inputRow < ${tileAHight}; inputRow = inputRow + ${workgroupSize[1]}) {\n        for (var inputCol = localCol; inputCol < ${tileAWidth}; inputCol = inputCol + ${workgroupSize[0]}) {\n          ${writeDataToSubASnippet(transposeA, batchDims)}\n        }\n      }\n      // Load one tile of B into local memory.\n      for (var inputRow = localRow; inputRow < ${tileInner}; inputRow = inputRow + ${workgroupSize[1]}) {\n            for (var inputCol = localCol; inputCol < ${tileBOuter}; inputCol = inputCol + ${workgroupSize[0]}) {\n          mm_Bsub[inputRow][inputCol] = mm_readB(batch,\n            kStart + inputRow,\n            globalColStart + inputCol${batchDims ? ", batchIndices" : ""});\n        }\n      }\n      kStart = kStart + tileInner;\n      workgroupBarrier();\n\n      // Compute acc values for a single thread.\n      var BCached : array<${type}, colPerThread>;\n      for (var k = 0; k < tileInner; k = k + 1) {\n        for (var inner = 0; inner < colPerThread; inner = inner + 1) {\n          BCached[inner] = mm_Bsub[k][localCol + inner * ${workgroupSize[0]}];\n        }\n        for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n          let ACached = ${transposeA ? `mm_Asub[k][localRow + innerRow * ${workgroupSize[1]}];` : `mm_Asub[localRow + innerRow * ${workgroupSize[1]}][k];`}\n          for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n            acc[innerRow][innerCol] = acc[innerRow][innerCol] +\n                ACached * BCached[innerCol];\n          }\n        }\n      }\n      workgroupBarrier();\n    }\n    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n      let gRow = globalRowStart + localRow + innerRow * ${workgroupSize[1]};\n      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n        let gCol = globalColStart + localCol + innerCol * ${workgroupSize[0]};\n        mm_write(batch, gRow, gCol, acc[innerRow][innerCol]);\n      }\n    }\n    ` : `\nlet tileRow = i32(localId.y) * rowPerThread;\nlet tileCol = i32(localId.x) * colPerThread;\n\nlet globalRow = i32(globalId.y) * rowPerThread;\nlet globalCol = i32(globalId.x) * colPerThread;\nlet globalRowStart = i32(workgroupId.y) * ${tileAOuter};\n\nlet tileRowA = i32(localId.y) * ${rowPerThreadA};\nlet tileColA = i32(localId.x) * ${colPerThreadA};\nlet tileRowB = i32(localId.y) * ${rowPerThreadB};\n// Loop over shared dimension.\nfor (var t = 0; t < numTiles; t = t + 1) {\n  // Load one tile of A into local memory.\n  for (var innerRow = 0; innerRow < ${rowPerThreadA}; innerRow = innerRow + 1) {\n    for (var innerCol = 0; innerCol < ${colPerThreadA}; innerCol = innerCol + 1) {\n      let inputRow = tileRowA + innerRow;\n      let inputCol = tileColA + innerCol;\n      ${writeDataToSubASnippet(transposeA, batchDims)}\n    }\n  }\n\n  // Load one tile of B into local memory.\n  for (var innerRow = 0; innerRow < ${rowPerThreadB}; innerRow = innerRow + 1) {\n    for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n      let inputRow = tileRowB + innerRow;\n      let inputCol = tileCol + innerCol;\n      mm_Bsub[inputRow][inputCol] = mm_readB(batch,\n        kStart + inputRow,\n        globalCol + innerCol${batchDims ? ", batchIndices" : ""});\n    }\n  }\n  kStart = kStart + tileInner;\n  workgroupBarrier();\n\n  // Compute acc values for a single thread.\n  var BCached : array<${type}, colPerThread>;\n  for (var k = 0; k < tileInner; k = k + 1) {\n    for (var inner = 0; inner < colPerThread; inner = inner + 1) {\n      BCached[inner] = mm_Bsub[k][tileCol + inner];\n    }\n\n    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n      ${readDataFromSubASnippet(transposeA)}\n      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n        acc[innerRow][innerCol] = acc[innerRow][innerCol] + ACached * BCached[innerCol];\n      }\n    }\n  }\n\n  workgroupBarrier();\n}\n\nfor (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n  for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n    mm_write(batch, globalRow + innerRow, globalCol + innerCol,\n        acc[innerRow][innerCol]);\n  }\n}\n`;\n        return `\n  var<workgroup> mm_Asub : array<array<${type}, ${tileAWidth}>, ${tileAHight}>;\n  var<workgroup> mm_Bsub : array<array<${type}, ${tileBOuter}>, ${tileInner}>;\n  const rowPerThread = ${workPerThread[1]};\n  const colPerThread = ${workPerThread[0]};\n  const tileInner = ${tileInner};\n\n@compute @workgroup_size(${workgroupSize[0]}, ${workgroupSize[1]}, ${workgroupSize[2]})\nfn main(@builtin(local_invocation_id) localId : vec3<u32>,\n        @builtin(global_invocation_id) globalId : vec3<u32>,\n        @builtin(workgroup_id) workgroupId : vec3<u32>) {\n    let batch = ${splitK ? "0" : "i32(globalId.z)"};\n    ${batchDims ? `let batchIndices = ${batchDims.offsetToIndices("u32(batch)")};` : ""}\n    let numTiles = ${splitK ? `${Math.ceil(splitedDimInner / tileInner)}` : "(uniforms.dimInner - 1) / tileInner + 1"};\n    var kStart = ${splitK ? `i32(globalId.z) * ${splitedDimInner}` : "0"};\n\n    var acc : array<array<${type}, colPerThread>, rowPerThread>;\n\n    // Without this initialization strange values show up in acc.\n    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n        acc[innerRow][innerCol] = 0.0;\n      }\n    }\n    ${matmulSnippet}\n  }\n`;\n      };\n      matMulReadWriteFnSource = (component, hasBias, applyActivation, variables, batchShapes, isChannelsLast = false) => {\n        const [batchAShape, batchBShape, batchShape] = batchShapes;\n        const [batchVariable, aVariable, bVariable, outputVariable2] = variables;\n        const broadCastADims = getBroadcastDims(batchAShape, batchShape);\n        const broadCastBDims = getBroadcastDims(batchBShape, batchShape);\n        const dataType = tensorTypeToWsglStorageType(variables[0].type.tensor);\n        const getAIndices = () => {\n          const aRank = aVariable.rank;\n          const batchRank = batchVariable.rank;\n          let resStr = `var aIndices: ${aVariable.type.indices};`;\n          for (let i = aRank - 2 - 1, j = batchRank - 1; i >= 0; i--, j--) {\n            resStr += `\naIndices[${i}] = ${batchRank > 1 ? `batchIndices[${j}]` : "batchIndices"};`;\n          }\n          broadCastADims.forEach((i) => {\n            resStr += `\naIndices[${i}] = 0;`;\n          });\n          resStr += `\naIndices[${aRank - 2}] = u32(row);\n                   aIndices[${aRank - 1}] = u32(colIn);`;\n          return resStr;\n        };\n        const getBIndices = () => {\n          const bRank = bVariable.rank;\n          const batchRank = batchVariable.rank;\n          let resStr = `var bIndices: ${bVariable.type.indices};`;\n          for (let i = bRank - 2 - 1, j = batchRank - 1; i >= 0; i--, j--) {\n            resStr += `\nbIndices[${i}] = ${batchRank > 1 ? `batchIndices[${j}]` : "batchIndices"};`;\n          }\n          broadCastBDims.forEach((i) => {\n            resStr += `\nbIndices[${i}] = 0;`;\n          });\n          resStr += `\nbIndices[${bRank - 2}] = u32(row);\n                   bIndices[${bRank - 1}] = u32(colIn);`;\n          return resStr;\n        };\n        const source = `\n    fn mm_readA(batch: i32, row: i32, colIn: i32, batchIndices: ${batchVariable.type.indices}) -> ${typeSnippet(component, dataType)} {\n      var value = ${typeSnippet(component, dataType)}(0.0);\n      let col = colIn * ${component};\n      if(row < uniforms.dimAOuter && col < uniforms.dimInner)\n      {\n        ${getAIndices()}\n        value = ${aVariable.getByIndices("aIndices")};\n      }\n      return value;\n    }\n\n    fn mm_readB(batch: i32, row: i32, colIn: i32, batchIndices: ${batchVariable.type.indices}) -> ${typeSnippet(component, dataType)} {\n      var value = ${typeSnippet(component, dataType)}(0.0);\n      let col = colIn * ${component};\n      if(row < uniforms.dimInner && col < uniforms.dimBOuter)\n      {\n        ${getBIndices()}\n        value = ${bVariable.getByIndices("bIndices")};\n      }\n      return value;\n    }\n\n    fn mm_write(batch: i32, row: i32, colIn: i32, valueIn: ${typeSnippet(component, dataType)}) {\n      let col = colIn * ${component};\n      if (row < uniforms.dimAOuter && col < uniforms.dimBOuter) {\n        var value = valueIn;\n        let coords = vec3<i32>(batch, row, colIn);\n        ${hasBias ? `value = value + ${isChannelsLast ? "bias[colIn]" : `${typeSnippet(component, dataType)}(bias[row])`};` : ""}\n        ${applyActivation}\n        ${outputVariable2.setByIndices("vec3<u32>(coords)", "value")}\n      }\n    }\n    `;\n        return source;\n      };\n      createMatmulProgramInfo = (inputs, activationAttributes, outputShape, reshapedOutputShape, isChannelsLast = false) => {\n        const aShape = inputs[0].dims;\n        const bShape = inputs[1].dims;\n        const outerDimsA = aShape.slice(0, -2);\n        const outerDimsB = bShape.slice(0, -2);\n        const outerDims = reshapedOutputShape ? reshapedOutputShape.slice(0, -2) : outputShape.slice(0, -2);\n        const enableBatchUniforms = enableShapesUniforms(outerDims.length);\n        const batchShapeOrRank = enableBatchUniforms ? outerDims.length : outerDims;\n        const batchDims = internalVariable("batchDims", inputs[0].dataType, batchShapeOrRank, 1);\n        const batchSize = ShapeUtil.size(outerDims);\n        const dimAOuter = aShape[aShape.length - 2];\n        const dimInner = aShape[aShape.length - 1];\n        const dimBOuter = bShape[bShape.length - 1];\n        const isVec4 = dimInner % 4 === 0 && dimBOuter % 4 === 0;\n        const elementsPerThread = dimAOuter <= 8 ? [4, 1, 1] : [4, 4, 1];\n        const workgroupSize = [8, 8, 1];\n        const dispatch = [\n          Math.ceil(dimBOuter / workgroupSize[0] / elementsPerThread[0]),\n          Math.ceil(dimAOuter / workgroupSize[1] / elementsPerThread[1]),\n          Math.ceil(batchSize / workgroupSize[2] / elementsPerThread[2])\n        ];\n        const dataType = tensorTypeToWsglStorageType(inputs[0].dataType);\n        const components = isVec4 ? 4 : 1;\n        const aShapeTemp = [...outerDimsA, dimAOuter, dimInner / components];\n        const enableAShapesUniforms = enableShapesUniforms(aShapeTemp.length);\n        const aShapeOrRank = enableAShapesUniforms ? aShapeTemp.length : aShapeTemp;\n        const bShapeTemp = [...outerDimsB, dimInner, dimBOuter / components];\n        const enableBShapesUniforms = enableShapesUniforms(bShapeTemp.length);\n        const bShapeOrRank = enableBShapesUniforms ? bShapeTemp.length : bShapeTemp;\n        const outputShapeTemp = [batchSize, dimAOuter, dimBOuter / components];\n        const A = inputVariable("a", inputs[0].dataType, aShapeOrRank, components);\n        const B = inputVariable("b", inputs[1].dataType, bShapeOrRank, components);\n        const output = outputVariable("result", inputs[0].dataType, outputShapeTemp.length, components);\n        const inputVariables = [A, B];\n        const programUniforms = [{ type: "int32", data: dimAOuter }, { type: "int32", data: dimBOuter }, { type: "int32", data: dimInner }];\n        if (enableBatchUniforms) {\n          programUniforms.push(...createTensorShapeVariables(outerDims));\n        }\n        if (enableAShapesUniforms) {\n          programUniforms.push(...createTensorShapeVariables(aShapeTemp));\n        }\n        if (enableBShapesUniforms) {\n          programUniforms.push(...createTensorShapeVariables(bShapeTemp));\n        }\n        const inputDependencies = [];\n        inputDependencies.push(enableAShapesUniforms ? "rank" : "dims");\n        inputDependencies.push(enableBShapesUniforms ? "rank" : "dims");\n        const hasBias = inputs.length > 2;\n        const { activationFunction, applyActivation } = getActivationSnippet(activationAttributes, output.type.value);\n        const declareFunctions = matMulReadWriteFnSource(\n          components,\n          hasBias,\n          applyActivation,\n          [batchDims, A, B, output],\n          [outerDimsA, outerDimsB, outerDims],\n          isChannelsLast\n        );\n        if (hasBias) {\n          const biasComponents = isChannelsLast ? components : 1;\n          inputVariables.push(inputVariable("bias", inputs[2].dataType, inputs[2].dims.length, biasComponents));\n          programUniforms.push(...createTensorShapeVariables(inputs[2].dims));\n          inputDependencies.push("rank");\n        }\n        programUniforms.push(...createTensorShapeVariables(outputShapeTemp));\n        const getShaderSource = (shaderHelper) => `\n  ${shaderHelper.registerUniform("dimAOuter", "i32").registerUniform("dimBOuter", "i32").registerUniform("dimInner", "i32").registerInternalVariables(batchDims).declareVariables(...inputVariables, output)}\n  ${activationFunction}\n  ${declareFunctions}\n  ${isVec4 ? makeMatMulPackedVec4Source(elementsPerThread, workgroupSize, dataType, batchDims) : makeMatMulPackedSource(elementsPerThread, workgroupSize, dataType, batchDims)}\n                   `;\n        return {\n          name: "MatMul",\n          shaderCache: {\n            hint: activationAttributes.activationCacheKey + `${elementsPerThread}${isVec4}${isChannelsLast}`,\n            inputDependencies\n          },\n          getRunData: () => ({\n            outputs: [{ dims: outputShape, dataType: inputs[0].dataType }],\n            dispatchGroup: { x: dispatch[0], y: dispatch[1], z: dispatch[2] },\n            programUniforms\n          }),\n          getShaderSource\n        };\n      };\n    }\n  });\n\n  // web/lib/wasm/jsep/webgpu/ops/3rd-party/conv2d_mm_webgpu.ts\n  var conv2dCommonSnippet, createConv2DMatMulProgramInfo;\n  var init_conv2d_mm_webgpu = __esm({\n    "web/lib/wasm/jsep/webgpu/ops/3rd-party/conv2d_mm_webgpu.ts"() {\n      "use strict";\n      init_log();\n      init_common();\n      init_fuse_utils();\n      init_activation_util();\n      init_conv_util();\n      init_matmul_packed_webgpu();\n      conv2dCommonSnippet = (isChannelsLast, fitAOuter, fitBOuter, fitInner, addBias = false, attributes, innerElementSizeX = 4, innerElementSizeW = 4, innerElementSize = 4, dataType = "f32") => {\n        const getXSnippet = (innerElementSize2) => {\n          switch (innerElementSize2) {\n            case 1:\n              return "resData = x[xIndex];";\n            case 3:\n              return `resData = vec3<${dataType}>(x[xIndex], x[xIndex + 1], x[xIndex + 2]);`;\n            case 4:\n              return "resData = x[xIndex / 4];";\n            default:\n              throw new Error(`innerElementSize ${innerElementSize2} is not supported.`);\n          }\n        };\n        const getWSnippet = (innerElementSize2) => {\n          switch (innerElementSize2) {\n            case 1:\n              return "return w[row * i32(uniforms.w_shape[3]) + colIn];";\n            case 4:\n              return "return w[row * i32(uniforms.w_shape[3]) / 4 + colIn];";\n            default:\n              throw new Error(`innerElementSize ${innerElementSize2} is not supported.`);\n          }\n        };\n        const coordASnippet = isChannelsLast ? `\n    let coord = vec4<i32>(batch, xRow, xCol, xCh);\n    ` : `\n    let coord = vec4<i32>(batch, xCh, xRow, xCol);\n    `;\n        const coordResSnippet = isChannelsLast ? `\n    let coords = vec4<i32>(\n      batch,\n      row / outWidth,\n      row % outWidth,\n      col);\n    ` : `\n    let coords = vec4<i32>(\n      batch,\n      row,\n      col / outWidth,\n      col % outWidth);\n    `;\n        const xHeight = isChannelsLast ? "i32(uniforms.x_shape[1])" : "i32(uniforms.x_shape[2])";\n        const xWidth = isChannelsLast ? "i32(uniforms.x_shape[2])" : "i32(uniforms.x_shape[3])";\n        const row = isChannelsLast ? "row" : "col";\n        const col = isChannelsLast ? "col" : "row";\n        const readXSnippet = `\n    let inChannels = i32(uniforms.w_shape[2]);\n    let outWidth = ${isChannelsLast ? "i32(uniforms.result_shape[2])" : "i32(uniforms.result_shape[3])"};\n    let outRow = ${row} / outWidth;\n    let outCol = ${row} % outWidth;\n\n    let WRow = ${col} / (filterDims[1] * inChannels);\n    let WCol = ${col} / inChannels % filterDims[1];\n    let xRow = outRow * stride[0] + dilation[0] * WRow - pad[0];\n    let xCol = outCol * stride[1] + dilation[1] * WCol - pad[1];\n    let xCh = ${col} % inChannels;\n    var resData = ${typeSnippet(innerElementSizeX, dataType)}(0.0);\n    // The bounds checking is always needed since we use it to pad zero for\n    // the \'same\' padding type.\n    if (xRow >= 0 && xRow < ${xHeight} && xCol >= 0 && xCol < ${xWidth}) {\n      ${coordASnippet}\n      let xIndex = getIndexFromCoords4D(coord, vec4<i32>(uniforms.x_shape));\n      ${getXSnippet(innerElementSizeX)}\n    }\n    return resData;`;\n        const sampleX = isChannelsLast ? fitAOuter && fitInner ? `\n    let col = colIn * ${innerElementSizeX};\n    ${readXSnippet}` : `\n    let col = colIn * ${innerElementSizeX};\n    if (row < uniforms.dimAOuter && col < uniforms.dimInner) {\n      ${readXSnippet}\n    }\n    return ${typeSnippet(innerElementSizeX, dataType)}(0.0);` : fitInner && fitBOuter ? `\n    let col = colIn * ${innerElementSizeX};\n    ${readXSnippet}` : `\n    let col = colIn * ${innerElementSizeX};\n    if (row < uniforms.dimInner && col < uniforms.dimBOuter) {\n      ${readXSnippet}\n    }\n    return ${typeSnippet(innerElementSizeX, dataType)}(0.0);`;\n        const sampleW = `${getWSnippet(innerElementSizeW)}`;\n        const resType = typeSnippet(innerElementSize, dataType);\n        const aType = isChannelsLast ? typeSnippet(innerElementSizeX, dataType) : typeSnippet(innerElementSizeW, dataType);\n        const bType = isChannelsLast ? typeSnippet(innerElementSizeW, dataType) : typeSnippet(innerElementSizeX, dataType);\n        const { activationFunction, applyActivation } = getActivationSnippet(attributes, resType);\n        const userCode = `\n    ${activationFunction}\n    fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${aType} {\n      ${isChannelsLast ? sampleX : sampleW}\n    }\n\n    fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${bType} {\n      ${isChannelsLast ? sampleW : sampleX}\n    }\n\n    fn mm_write(batch: i32, row : i32, colIn : i32, valueIn : ${resType}) {\n      let col = colIn * ${innerElementSize};\n      if (row < uniforms.dimAOuter && col < uniforms.dimBOuter)\n      {\n      var value = valueIn;\n      let outWidth = ${isChannelsLast ? "i32(uniforms.result_shape[2])" : "i32(uniforms.result_shape[3])"};\n      ${coordResSnippet}\n      ${biasSnippet(addBias)}\n      ${applyActivation}\n      setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);\n      }\n    }`;\n        return userCode;\n      };\n      createConv2DMatMulProgramInfo = (inputs, attributes, outputShape, dimAOuter, dimBOuter, dimInner, hasBias, sequentialAccessByThreads) => {\n        const isChannelsLast = attributes.format === "NHWC";\n        const inChannels = isChannelsLast ? inputs[0].dims[3] : inputs[0].dims[1];\n        const batchSize = outputShape[0];\n        const outWidth = isChannelsLast ? outputShape[2] : outputShape[3];\n        const outHeight = isChannelsLast ? outputShape[1] : outputShape[2];\n        const outChannels = isChannelsLast ? outputShape[3] : outputShape[1];\n        const isVec4 = isChannelsLast && (inChannels % 4 === 0 || inChannels % 3 === 0) && outChannels % 4 === 0;\n        const dispatchX = isChannelsLast ? outChannels : outWidth * outHeight;\n        const dispatchY = isChannelsLast ? outWidth * outHeight : outChannels;\n        const workGroupSize = [8, 8, 1];\n        const elementsPerThread = dimAOuter <= 8 ? [4, 1, 1] : [4, 4, 1];\n        const dispatch = [\n          Math.ceil(dispatchX / workGroupSize[0] / elementsPerThread[0]),\n          Math.ceil(dispatchY / workGroupSize[1] / elementsPerThread[1]),\n          Math.ceil(batchSize / workGroupSize[2] / elementsPerThread[2])\n        ];\n        LOG_DEBUG("verbose", () => `[conv2d_mm_webgpu] dispatch = ${dispatch}`);\n        const innerElementSize = isVec4 ? isChannelsLast && inChannels % 4 !== 0 ? 3 : 4 : 1;\n        const tileAOuter = workGroupSize[1] * elementsPerThread[1];\n        const tileBOuter = workGroupSize[0] * elementsPerThread[0];\n        const tileInner = Math.max(workGroupSize[0] * innerElementSize, workGroupSize[1]);\n        const fitAOuter = dimAOuter % tileAOuter === 0;\n        const fitBOuter = dimBOuter % tileBOuter === 0;\n        const fitInner = dimInner % tileInner === 0;\n        const elementsSize = isVec4 ? [innerElementSize, 4, 4] : [1, 1, 1];\n        const t = tensorTypeToWsglStorageType(inputs[0].dataType);\n        const components = isVec4 ? 4 : 1;\n        const programUniforms = [{ type: "int32", data: dimAOuter }, { type: "int32", data: dimBOuter }, { type: "int32", data: dimInner }];\n        const x = inputVariable("x", inputs[0].dataType, inputs[0].dims.length, innerElementSize === 3 ? 1 : innerElementSize);\n        const w = inputVariable("w", inputs[1].dataType, inputs[1].dims.length, components);\n        const inputVariables = [x, w];\n        programUniforms.push(...createTensorShapeVariables(inputs[0].dims));\n        programUniforms.push(...createTensorShapeVariables(inputs[1].dims));\n        let declareFunctions = `\n      fn setOutputAtIndex(flatIndex : i32, value : ${isVec4 ? `vec4<${t}>` : t}) {\n        result[flatIndex] = ${isVec4 ? `vec4<${t}>` : t}(value);\n      }\n      fn setOutputAtCoords(d0 : i32, d1 : i32, d2 : i32, d3 : i32, value : ${isVec4 ? `vec4<${t}>` : t}) {\n        let flatIndex = getOutputIndexFromCoords(vec4<i32>(d0, d1, d2, d3));\n        setOutputAtIndex(flatIndex ${isVec4 ? "/ 4" : ""}, value);\n      }`;\n        if (hasBias) {\n          const bias = inputVariable("bias", inputs[2].dataType, inputs[2].dims.length, components);\n          inputVariables.push(bias);\n          programUniforms.push(...createTensorShapeVariables(inputs[2].dims));\n          declareFunctions += `\n        fn getBiasByOutputCoords(coords : vec4<i32>) -> ${isVec4 ? `vec4<${t}>` : t} {\n          return bias[coords.${isChannelsLast ? "w" : "y"}${isVec4 ? "/ 4" : ""}];\n        }`;\n        }\n        const output = outputVariable("result", inputs[0].dataType, outputShape.length, components);\n        programUniforms.push(...createTensorShapeVariables(outputShape));\n        return {\n          name: "Conv2DMatMul",\n          shaderCache: { hint: attributes.cacheKey },\n          getRunData: () => ({\n            outputs: [{ dims: outputShape, dataType: inputs[0].dataType }],\n            dispatchGroup: { x: dispatch[0], y: dispatch[1], z: dispatch[2] },\n            programUniforms\n          }),\n          getShaderSource: (shaderHelper) => `\n        ${utilFunctions("uniforms.result_strides")}\n        //struct Uniforms { xShape : vec4<i32>, wShape : vec4<i32>, outShape : vec4<i32>,\n        //  outShapeStrides: vec3<i32>, filterDims : vec2<i32>, pad : vec2<i32>, stride : vec2<i32>,\n        //  dilation : vec2<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32 };\n        ${shaderHelper.registerUniform("dimAOuter", "i32").registerUniform("dimBOuter", "i32").registerUniform("dimInner", "i32").declareVariables(...inputVariables, output)}\n        const filterDims : vec2<i32> = vec2<i32>(${attributes.kernelShape[0]}, ${attributes.kernelShape[1]});\n        const pad : vec2<i32> = vec2<i32>(${attributes.pads[0]}, ${attributes.pads[1]});\n        const stride : vec2<i32> = vec2<i32>(${attributes.strides[0]}, ${attributes.strides[1]});\n        const dilation : vec2<i32> = vec2<i32>(${attributes.dilations[0]}, ${attributes.dilations[1]});\n        ${declareFunctions}\n        ${conv2dCommonSnippet(\n            isChannelsLast,\n            fitAOuter,\n            fitBOuter,\n            fitInner,\n            hasBias,\n            attributes,\n            elementsSize[0],\n            elementsSize[1],\n            elementsSize[2],\n            t\n          )}\n            ${isVec4 ? makeMatMulPackedVec4Source(elementsPerThread, workGroupSize, t, void 0, !isChannelsLast, tileInner) : makeMatMulPackedSource(\n            elementsPerThread,\n            workGroupSize,\n            t,\n            void 0,\n            !isChannelsLast,\n            tileInner,\n            false,\n            void 0,\n            sequentialAccessByThreads\n          )}`\n        };\n      };\n    }\n  });\n\n  // web/lib/wasm/jsep/webgpu/ops/conv-grouped.ts\n  var createGroupedConvProgramInfo, createGroupedConvVectorizeProgramInfo;\n  var init_conv_grouped = __esm({\n    "web/lib/wasm/jsep/webgpu/ops/conv-grouped.ts"() {\n      "use strict";\n      init_util();\n      init_common();\n      init_conv();\n      init_fuse_utils();\n      createGroupedConvProgramInfo = (inputs, attributes, squeezeOutputShapeFunction) => {\n        const hasBias = inputs.length > 2;\n        const processBias = hasBias ? "value += b[output_channel];" : "";\n        const xShape = inputs[0].dims;\n        const wShape = inputs[1].dims;\n        const outputChannelsPerGroup = wShape[0] / attributes.group;\n        const isChannelLast = attributes.format === "NHWC";\n        const outputShape = calculateOutputShape(\n          xShape,\n          wShape,\n          attributes.dilations,\n          attributes.pads,\n          attributes.strides,\n          isChannelLast\n        );\n        const outputSize = ShapeUtil.size(outputShape);\n        const output = outputVariable("output", inputs[0].dataType, outputShape);\n        const { activationFunction, applyActivation } = getActivationSnippet(attributes, output.type.value);\n        const x = inputVariable("x", inputs[0].dataType, xShape);\n        const w = inputVariable("w", inputs[1].dataType, wShape);\n        const inputVars = [x, w];\n        if (hasBias) {\n          inputVars.push(inputVariable("b", inputs[2].dataType, inputs[2].dims));\n        }\n        const getShaderSource = (shaderHelper) => `\n  const strides: vec2<u32> = vec2(${attributes.strides[0]}u, ${attributes.strides[1]}u);\n  const pads: vec2<u32> = vec2(${attributes.pads[0]}u, ${attributes.pads[1]}u);\n\n  ${shaderHelper.declareVariables(...inputVars, output)}\n\n  ${activationFunction}\n\n  ${shaderHelper.mainStart()}\n    ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes(outputSize)}\n\n    let outputIndices = ${output.offsetToIndices("global_idx")};\n    let batch: u32 = outputIndices[0];\n    let output_channel: u32 = outputIndices[${isChannelLast ? 3 : 1}];\n    let xRCCorner: vec2<u32> = vec2<u32>(outputIndices[${isChannelLast ? 1 : 2}], outputIndices[${isChannelLast ? 2 : 3}]) * strides - pads;\n    let group_id: u32 = output_channel / ${outputChannelsPerGroup}u;\n\n    var value: ${output.type.value} = ${output.type.value}(0);\n    for (var wInChannel: u32 = 0u; wInChannel < ${wShape[1]}u; wInChannel++) {\n      let input_channel = group_id * ${wShape[1]}u + wInChannel;\n      for (var wHeight: u32 = 0u; wHeight < ${wShape[2]}u; wHeight++) {\n        let xHeight = xRCCorner.x + wHeight * ${attributes.dilations[0]}u;\n\n        if (xHeight < 0u || xHeight >= ${xShape[isChannelLast ? 1 : 2]}u) {\n          continue;\n        }\n\n        for (var wWidth: u32 = 0u; wWidth < ${wShape[3]}u; wWidth++) {\n          let xWidth = xRCCorner.y + wWidth * ${attributes.dilations[1]}u;\n          if (xWidth < 0u || xWidth >= ${xShape[isChannelLast ? 2 : 3]}u) {\n            continue;\n          }\n\n          let xVal = ${isChannelLast ? x.get("batch", "xHeight", "xWidth", "input_channel") : x.get("batch", "input_channel", "xHeight", "xWidth")};\n          let wVal = ${w.get("output_channel", "wInChannel", "wHeight", "wWidth")};\n          value += xVal*wVal;\n        }\n      }\n    }\n    ${processBias}\n    ${applyActivation}\n    ${output.setByOffset("global_idx", "value")}\n  }`;\n        return {\n          name: "GroupedConv",\n          shaderCache: { hint: attributes.cacheKey },\n          getRunData: () => ({\n            outputs: [{\n              dims: squeezeOutputShapeFunction ? squeezeOutputShapeFunction(outputShape) : outputShape,\n              dataType: inputs[0].dataType\n            }],\n            dispatchGroup: { x: Math.ceil(\n              outputSize / 64\n              /* workgroup size */\n            ) }\n          }),\n          getShaderSource\n        };\n      };\n      createGroupedConvVectorizeProgramInfo = (inputs, attributes, outputShape) => {\n        const hasBias = inputs.length > 2;\n        const components = getMaxComponents(outputShape[3]);\n        const outputNumber = getMaxComponents(outputShape[2]);\n        const outputSize = ShapeUtil.size(outputShape) / components / outputNumber;\n        const xShape = [inputs[0].dims[0], inputs[0].dims[1], inputs[0].dims[2], inputs[0].dims[3] / components];\n        const wShape = [inputs[1].dims[0], inputs[1].dims[1], inputs[1].dims[2], inputs[1].dims[3] / components];\n        const outputShapeInShader = [outputShape[0], outputShape[1], outputShape[2], outputShape[3] / components];\n        const programUniforms = [\n          { type: "uint32", data: outputSize },\n          { type: "int32", data: attributes.strides },\n          { type: "int32", data: attributes.pads },\n          ...createTensorShapeVariables(xShape),\n          ...createTensorShapeVariables(wShape),\n          ...createTensorShapeVariables(outputShapeInShader)\n        ];\n        const xNumber = (outputNumber - 1) * attributes.strides[1] + wShape[1];\n        const getShaderSource = (shaderHelper) => {\n          const output = outputVariable("output", inputs[0].dataType, outputShapeInShader.length, components);\n          const { activationFunction, applyActivation } = getActivationSnippet(attributes, output.type.value);\n          const x = inputVariable("x", inputs[0].dataType, xShape.length, components);\n          const w = inputVariable("w", inputs[1].dataType, wShape.length, components);\n          const inputVars = [x, w];\n          if (hasBias) {\n            inputVars.push(inputVariable("b", inputs[2].dataType, inputs[2].dims, components));\n          }\n          const processBias = hasBias ? "value += b[output_channel];" : "";\n          return `\n  ${shaderHelper.registerUniform("output_size", "u32").registerUniform("strides", "i32", 2).registerUniform("pads", "i32", 2).declareVariables(...inputVars, output)}\n  ${activationFunction}\n  ${shaderHelper.mainStart()}\n    ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n    let width0 = uniforms.output_shape[3];\n    let output_channel = global_idx % width0;\n    var index1 = global_idx / width0;\n    let width1 = uniforms.output_shape[2] / ${outputNumber}u;\n    let col = (index1 % width1) * ${outputNumber}u;\n    index1 = index1 / width1;\n    let row = index1 % uniforms.output_shape[1];\n    let batch = index1 / uniforms.output_shape[1];\n\n    let x_corner = vec2<i32>(i32(row), i32(col)) * uniforms.strides - uniforms.pads;\n\n    var x_vals: array<${x.type.value}, ${xNumber}>;\n    var values: array<${output.type.value}, ${outputNumber}>;\n    let input_channel = output_channel;\n    // Use constant instead of uniform can give better performance for w\'s height/width.\n    for (var w_height: u32 = 0u; w_height < ${wShape[0]}; w_height++) {\n      let x_height = x_corner.x + i32(w_height);\n      if (x_height >= 0 || u32(x_height) < uniforms.x_shape[1]) {\n        for (var i = 0; i < ${xNumber}; i++) {\n          let x_width = x_corner.y + i;\n          if (x_width >= 0 && u32(x_width) < uniforms.x_shape[2]) {\n            x_vals[i] = ${x.get("batch", "u32(x_height)", "u32(x_width)", "input_channel")};\n          } else {\n            x_vals[i] = ${x.type.value}(0);\n          }\n        }\n        for (var w_width: u32 = 0u; w_width < ${wShape[1]}; w_width++) {\n          let w_val = ${w.get("w_height", "w_width", "0", "output_channel")};\n          for (var i = 0u; i < ${outputNumber}u; i++) {\n            values[i] = fma(x_vals[i * ${attributes.strides[1]}u + w_width], w_val, values[i]);\n          }\n        }\n      }\n    }\n\n    for (var i = 0u; i < ${outputNumber}u; i++) {\n      var value = values[i];\n      ${processBias}\n      ${applyActivation}\n      ${output.set("batch", "row", "col + i", "output_channel", "value")};\n    }\n  }`;\n        };\n        return {\n          name: "GroupedConv-Vectorize",\n          shaderCache: {\n            hint: `${attributes.activationCacheKey};${components};${outputNumber};${xNumber};${wShape[0]};${wShape[1]}`,\n            inputDependencies: hasBias ? ["rank", "rank", "type"] : ["rank", "rank"]\n          },\n          getRunData: () => ({\n            outputs: [{ dims: outputShape, dataType: inputs[0].dataType }],\n            dispatchGroup: { x: Math.ceil(\n              outputSize / 64\n              /* workgroup size */\n            ) },\n            programUniforms\n          }),\n          getShaderSource\n        };\n      };\n    }\n  });\n\n  // web/lib/wasm/jsep/webgpu/ops/matmul.ts\n  var createNaiveMatmulProgramInfo, validateInputs8, matMul;\n  var init_matmul = __esm({\n    "web/lib/wasm/jsep/webgpu/ops/matmul.ts"() {\n      "use strict";\n      init_util();\n      init_matmul_packed_webgpu();\n      init_common();\n      init_fuse_utils();\n      createNaiveMatmulProgramInfo = (inputs, activationAttributes, outputShape, reshapedOutputShape, isChannelsLast = false) => {\n        const aShape = inputs[0].dims;\n        const bShape = inputs[1].dims;\n        const M = aShape[aShape.length - 2];\n        const N = bShape[bShape.length - 1];\n        const K = aShape[aShape.length - 1];\n        const components = getMaxComponents(N);\n        const aComponents = getMaxComponents(K);\n        const outputNumber = getMaxComponents(M);\n        const outputSize = ShapeUtil.size(outputShape) / components / outputNumber;\n        const hasBias = inputs.length > 2;\n        const outerDims = reshapedOutputShape ? reshapedOutputShape.slice(0, -2) : outputShape.slice(0, -2);\n        const batchSize = ShapeUtil.size(outerDims);\n        const outputShapeInShader = [batchSize, M, N];\n        const programUniforms = [\n          { type: "uint32", data: outputSize },\n          { type: "uint32", data: M },\n          { type: "uint32", data: N },\n          { type: "uint32", data: K },\n          ...createTensorShapeVariables(outerDims),\n          ...createTensorShapeVariables(aShape),\n          ...createTensorShapeVariables(bShape)\n        ];\n        if (hasBias) {\n          programUniforms.push(...createTensorShapeVariables(inputs[2].dims));\n        }\n        programUniforms.push(...createTensorShapeVariables(outputShapeInShader));\n        const getShaderSource = (shaderHelper) => {\n          const batchDims = internalVariable("batch_dims", inputs[0].dataType, outerDims.length);\n          const a = inputVariable("a", inputs[0].dataType, aShape.length, aComponents);\n          const b = inputVariable("b", inputs[1].dataType, bShape.length, components);\n          const output = outputVariable("output", inputs[0].dataType, outputShapeInShader.length, components);\n          const { activationFunction, applyActivation } = getActivationSnippet(activationAttributes, output.type.value);\n          const inputVariables = [a, b];\n          let processBias = "";\n          if (hasBias) {\n            const biasComponents = isChannelsLast ? components : 1;\n            inputVariables.push(inputVariable("bias", inputs[2].dataType, inputs[2].dims.length, biasComponents));\n            processBias = `${isChannelsLast ? `value += bias[col / ${biasComponents}];` : `value += ${output.type.value}(bias[row + i]);`}`;\n          }\n          const outerDimsA = aShape.slice(0, -2);\n          const outerDimsB = bShape.slice(0, -2);\n          const broadCastADims = getBroadcastDims(outerDimsA, outerDims);\n          const broadCastBDims = getBroadcastDims(outerDimsB, outerDims);\n          const getIndices = (variable, broadCastDims) => {\n            const rank = variable.rank;\n            const name = variable.name;\n            if (rank === 2) {\n              return `var ${name}_indices = ${variable.type.indices}(0u, 0u);`;\n            }\n            const batchRank = batchDims.rank;\n            let resStr = `var ${name}_indices: ${variable.type.indices};`;\n            for (let i = rank - 2 - 1, j = batchRank - 1; i >= 0; i--, j--) {\n              resStr += `\n${name}_indices[${i}] = ${batchRank > 1 ? `batch_indices[${j}]` : "batch_indices"};`;\n            }\n            broadCastDims.forEach((i) => {\n              resStr += `\n${name}_indices[${i}] = 0;`;\n            });\n            resStr += `${name}_indices[${rank - 2}] = 0u;\n                     ${name}_indices[${rank - 1}] = 0u;`;\n            return resStr;\n          };\n          const calcResult = () => {\n            let calcStr = `var a_data: ${a.type.value};`;\n            for (let i = 0; i < aComponents; i++) {\n              calcStr += `\n              let b_data${i} = b[(b_offset + (k + ${i}) * uniforms.N + col) / ${components}];`;\n            }\n            for (let i = 0; i < outputNumber; i++) {\n              calcStr += `a_data = a[(a_offset + (row + ${i}) * uniforms.K + k) / ${aComponents}];`;\n              for (let j = 0; j < aComponents; j++) {\n                calcStr += `\n            values[${i}] = fma(${b.type.value}(a_data${aComponents === 1 ? "" : `[${j}]`}), b_data${j}, values[${i}]);\n`;\n              }\n            }\n            return calcStr;\n          };\n          return `\n  ${shaderHelper.registerUniform("outputSize", "u32").registerUniform("M", "u32").registerUniform("N", "u32").registerUniform("K", "u32").registerInternalVariables(batchDims).declareVariables(...inputVariables, output)}\n  ${activationFunction}\n  ${shaderHelper.mainStart()}\n    ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n    let col = (global_idx % (uniforms.N / ${components})) * ${components};\n    var index1 = global_idx / (uniforms.N / ${components});\n    let stride1 = uniforms.M / ${outputNumber};\n    let row = (index1 % stride1) * ${outputNumber};\n    let batch = index1 / stride1;\n\n    ${outputShape.length === 2 ? "" : `let batch_indices = ${batchDims.offsetToIndices("batch")};`}\n    ${getIndices(a, broadCastADims)}\n    let a_offset = ${a.indicesToOffset("a_indices")};\n    ${getIndices(b, broadCastBDims)}\n    let b_offset = ${b.indicesToOffset("b_indices")};\n    var values: array<${output.type.value}, ${outputNumber}>;\n    for (var k: u32 = 0u; k < uniforms.K; k = k + ${aComponents}) {\n      ${calcResult()}\n    }\n    for (var i = 0u; i < ${outputNumber}u; i++) {\n      var value = values[i];\n      ${processBias}\n      ${applyActivation}\n      let cur_indices = ${output.type.indices}(batch, row + i, col);\n      let offset = ${output.indicesToOffset("cur_indices")};\n      ${output.setByOffset(`offset / ${components}`, "value")};\n    }\n  }\n  `;\n        };\n        return {\n          name: "MatMulNaive",\n          shaderCache: {\n            hint: `${activationAttributes.activationCacheKey}_${components}_${aComponents}_${outputNumber}_${isChannelsLast}`,\n            inputDependencies: hasBias ? ["rank", "rank", "rank"] : ["rank", "rank"]\n          },\n          getRunData: () => ({\n            outputs: [{ dims: outputShape, dataType: inputs[0].dataType }],\n            dispatchGroup: { x: Math.ceil(\n              outputSize / 64\n              /* workgroup size */\n            ) },\n            programUniforms\n          }),\n          getShaderSource\n        };\n      };\n      validateInputs8 = (inputs) => {\n        if (!inputs || inputs.length !== 2) {\n          throw new Error("MatMul requires 2 inputs.");\n        }\n        if (inputs[0].dims[inputs[0].dims.length - 1] !== inputs[1].dims[inputs[1].dims.length - 2]) {\n          throw new Error("shared dimension does not match.");\n        }\n      };\n      matMul = (context) => {\n        validateInputs8(context.inputs);\n        const outputShape = BroadcastUtil.calcShape(context.inputs[0].dims, context.inputs[1].dims, true);\n        if (!outputShape) {\n          throw new Error("Can\'t use matmul on the given tensors");\n        }\n        const N = outputShape[outputShape.length - 1];\n        const K = context.inputs[0].dims[context.inputs[0].dims.length - 1];\n        if (N < 8 && K < 8) {\n          context.compute(\n            createNaiveMatmulProgramInfo(context.inputs, { activation: "", activationCacheKey: "" }, outputShape)\n          );\n        } else {\n          context.compute(createMatmulProgramInfo(context.inputs, { activation: "", activationCacheKey: "" }, outputShape));\n        }\n      };\n    }\n  });\n\n  // web/lib/wasm/jsep/webgpu/ops/conv.ts\n  var calculateOutputShape, weightTransposeAttribute, validateInputs9, getAdjustedConvAttributes, parseConvAttributes, conv2d, conv1d, conv;\n  var init_conv = __esm({\n    "web/lib/wasm/jsep/webgpu/ops/conv.ts"() {\n      "use strict";\n      init_util();\n      init_attribute_with_cache_key();\n      init_conv2d_mm_webgpu();\n      init_matmul_packed_webgpu();\n      init_conv_grouped();\n      init_fuse_utils();\n      init_matmul();\n      init_transpose();\n      calculateOutputShape = (inputShape, kernelShape, dilations, adjustPads, strides, isChannelLast) => {\n        const batchSize = inputShape[0];\n        const inputSpatialShape = inputShape.slice(isChannelLast ? 1 : 2, isChannelLast ? 3 : 4);\n        const spatialRank = inputSpatialShape.length;\n        const outChannels = kernelShape[0];\n        const kernelSpatialShape = kernelShape.slice(2);\n        const dilatedKernelShape = kernelSpatialShape.map((v, i) => v + (v - 1) * (dilations[i] - 1));\n        const inputSpatialShapeWithPad = inputSpatialShape.map((v, i) => v + adjustPads[i] + adjustPads[i + spatialRank]);\n        const outputShape = inputSpatialShapeWithPad.map((v, i) => Math.floor((v - dilatedKernelShape[i] + strides[i]) / strides[i]));\n        outputShape.splice(0, 0, batchSize);\n        outputShape.splice(isChannelLast ? 3 : 1, 0, outChannels);\n        return outputShape;\n      };\n      weightTransposeAttribute = [2, 3, 1, 0];\n      validateInputs9 = (inputs, attributes) => {\n        if (!inputs || inputs.length !== 2 && inputs.length !== 3) {\n          throw new Error("Conv requires 2 or 3 inputs");\n        }\n        if (inputs[0].dims.length !== 4 && inputs[0].dims.length !== 3) {\n          throw new Error("currently only support conv 1D and 2D");\n        }\n        if (inputs[0].dims.length !== inputs[1].dims.length) {\n          throw new Error("filter does not have same dimension as input");\n        }\n        const dataChannel = inputs[0].dims[attributes.format === "NHWC" ? inputs[0].dims.length - 1 : 1];\n        const filterInChannel = inputs[1].dims[1] * attributes.group;\n        if (dataChannel !== filterInChannel) {\n          throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");\n        }\n        if (inputs.length === 3 && (inputs[2].dims.length !== 1 || inputs[1].dims[0] !== inputs[2].dims[0])) {\n          throw new Error("invalid bias");\n        }\n        const spatialRank = inputs[0].dims.length - 2;\n        if (attributes.dilations.length !== spatialRank) {\n          throw new Error(`dilations should be ${spatialRank}D`);\n        }\n        if (attributes.strides.length !== spatialRank) {\n          throw new Error(`strides should be ${spatialRank}D`);\n        }\n        if (attributes.pads.length !== spatialRank * 2) {\n          throw new Error(`pads should be ${spatialRank * 2}D`);\n        }\n        if (attributes.kernelShape.length !== 0 && attributes.kernelShape.length !== inputs[1].dims.length - 2) {\n          throw new Error("invalid kernel shape");\n        }\n      };\n      getAdjustedConvAttributes = (attributes, inputs) => {\n        const kernelShape = attributes.kernelShape.slice();\n        for (let i = 2; i < inputs[1].dims.length; ++i) {\n          if (kernelShape[i - 2] === 0) {\n            kernelShape[i - 2] = inputs[1].dims[i];\n          }\n        }\n        const pads = attributes.pads.slice();\n        PoolConvUtil.adjustPadsBasedOnAutoPad(\n          inputs[0].dims,\n          attributes.strides,\n          attributes.dilations,\n          kernelShape,\n          pads,\n          attributes.format === "NHWC",\n          attributes.autoPad\n        );\n        const newAttributes = Object.assign({}, attributes);\n        Object.assign(newAttributes, { kernelShape, pads, cacheKey: attributes.cacheKey });\n        return newAttributes;\n      };\n      parseConvAttributes = (attributes) => {\n        const activationAttributes = parseInternalActivationAttributes(attributes);\n        const format = attributes.format;\n        const autoPad = ["NOTSET", "VALID", "SAME_UPPER", "SAME_LOWER"][attributes.auto_pad];\n        const dilations = attributes.dilations;\n        const group = attributes.group;\n        const kernelShape = attributes.kernel_shape;\n        const pads = attributes.pads;\n        const strides = attributes.strides;\n        const wIsConst = attributes.w_is_const();\n        return createAttributeWithCacheKey(\n          { autoPad, format, dilations, group, kernelShape, pads, strides, wIsConst, ...activationAttributes }\n        );\n      };\n      conv2d = (context, inputs, attributes) => {\n        const adjustedAttributes = getAdjustedConvAttributes(attributes, inputs);\n        const isChannelsLast = attributes.format === "NHWC";\n        if (attributes.group !== 1) {\n          const disableGroupedConvVectorize = true;\n          if (!disableGroupedConvVectorize && isChannelsLast && inputs[1].dims[0] === attributes.group && inputs[1].dims[1] === 1 && attributes.dilations[0] === 1 && attributes.dilations[1] === 1) {\n            const outputShape2 = calculateOutputShape(\n              inputs[0].dims,\n              inputs[1].dims,\n              attributes.dilations,\n              adjustedAttributes.pads,\n              attributes.strides,\n              isChannelsLast\n            );\n            const transposedWeight2 = context.kernelCustomData.wT ?? context.compute(\n              createTransposeProgramInfo(inputs[1], weightTransposeAttribute),\n              { inputs: [1], outputs: [attributes.wIsConst ? -2 : -1] }\n            )[0];\n            if (attributes.wIsConst && !context.kernelCustomData.wT) {\n              context.kernelCustomData.wT = transposedWeight2;\n            }\n            const convInputs2 = [inputs[0], transposedWeight2];\n            if (inputs.length === 3) {\n              convInputs2.push(inputs[2]);\n            }\n            context.compute(\n              createGroupedConvVectorizeProgramInfo(convInputs2, adjustedAttributes, outputShape2),\n              { inputs: convInputs2 }\n            );\n          } else {\n            context.compute(createGroupedConvProgramInfo(inputs, adjustedAttributes));\n          }\n          return;\n        }\n        const hasBias = inputs.length === 3;\n        const inputHeight = inputs[0].dims[isChannelsLast ? 1 : 2];\n        const inputWidth = inputs[0].dims[isChannelsLast ? 2 : 3];\n        const inputChannels = inputs[0].dims[isChannelsLast ? 3 : 1];\n        const weightHeight = inputs[1].dims[2];\n        const weightWidth = inputs[1].dims[3];\n        const outputShape = calculateOutputShape(\n          inputs[0].dims,\n          inputs[1].dims,\n          attributes.dilations,\n          adjustedAttributes.pads,\n          attributes.strides,\n          isChannelsLast\n        );\n        const outHeight = outputShape[isChannelsLast ? 1 : 2];\n        const outWidth = outputShape[isChannelsLast ? 2 : 3];\n        const outChannels = outputShape[isChannelsLast ? 3 : 1];\n        const sameSize = isChannelsLast && weightHeight === inputHeight && weightWidth === inputWidth && attributes.pads[0] === 0 && attributes.pads[1] === 0;\n        if (sameSize || weightHeight === 1 && weightWidth === 1 && attributes.dilations[0] === 1 && attributes.dilations[1] === 1 && attributes.strides[0] === 1 && attributes.strides[1] === 1 && attributes.pads[0] === 0 && attributes.pads[1] === 0) {\n          const batch = outputShape[0];\n          let xReshaped, wReshaped, matmulOutputShape;\n          const matmulInputs = [];\n          if (isChannelsLast) {\n            const transposedWeight2 = context.kernelCustomData.wT ?? context.compute(\n              createTransposeProgramInfo(inputs[1], weightTransposeAttribute),\n              { inputs: [1], outputs: [attributes.wIsConst ? -2 : -1] }\n            )[0];\n            if (attributes.wIsConst && !context.kernelCustomData.wT) {\n              context.kernelCustomData.wT = transposedWeight2;\n            }\n            if (sameSize) {\n              const sharedDim = inputHeight * inputWidth * inputChannels;\n              xReshaped = inputs[0].reshape([1, batch, sharedDim]);\n              wReshaped = transposedWeight2.reshape([1, sharedDim, outChannels]);\n              matmulOutputShape = [1, batch, outChannels];\n            } else {\n              xReshaped = inputs[0].reshape([batch, inputHeight * inputWidth, inputChannels]);\n              wReshaped = transposedWeight2.reshape([1, inputChannels, outChannels]);\n              matmulOutputShape = [batch, outHeight * outWidth, outChannels];\n            }\n            matmulInputs.push(xReshaped);\n            matmulInputs.push(wReshaped);\n          } else {\n            xReshaped = inputs[0].reshape([batch, inputChannels, inputHeight * inputWidth]);\n            wReshaped = inputs[1].reshape([1, outChannels, inputChannels]);\n            matmulOutputShape = [batch, outChannels, outHeight * outWidth];\n            matmulInputs.push(wReshaped);\n            matmulInputs.push(xReshaped);\n          }\n          if (hasBias) {\n            matmulInputs.push(inputs[2]);\n          }\n          const N = matmulOutputShape[2];\n          const K = matmulInputs[0].dims[matmulInputs[0].dims.length - 1];\n          if (N < 8 && K < 8) {\n            context.compute(\n              createNaiveMatmulProgramInfo(\n                matmulInputs,\n                adjustedAttributes,\n                outputShape,\n                matmulOutputShape,\n                isChannelsLast\n              ),\n              { inputs: matmulInputs }\n            );\n          } else {\n            context.compute(\n              createMatmulProgramInfo(matmulInputs, adjustedAttributes, outputShape, matmulOutputShape, isChannelsLast),\n              { inputs: matmulInputs }\n            );\n          }\n          return;\n        }\n        const sequentialAccessByThreads = (\n          /* backend.adapterInfo.isIntel() */\n          true\n        );\n        const transposedWeight = context.kernelCustomData.wT ?? context.compute(\n          createTransposeProgramInfo(inputs[1], weightTransposeAttribute),\n          { inputs: [1], outputs: [attributes.wIsConst ? -2 : -1] }\n        )[0];\n        if (attributes.wIsConst && !context.kernelCustomData.wT) {\n          context.kernelCustomData.wT = transposedWeight;\n        }\n        const convInputs = [inputs[0], transposedWeight];\n        if (hasBias) {\n          convInputs.push(inputs[2]);\n        }\n        const dimAOuter = isChannelsLast ? outHeight * outWidth : outChannels;\n        const dimBOuter = isChannelsLast ? outChannels : outHeight * outWidth;\n        const dimInner = weightHeight * weightWidth * inputChannels;\n        context.compute(\n          createConv2DMatMulProgramInfo(\n            convInputs,\n            adjustedAttributes,\n            outputShape,\n            dimAOuter,\n            dimBOuter,\n            dimInner,\n            hasBias,\n            sequentialAccessByThreads\n          ),\n          { inputs: convInputs }\n        );\n      };\n      conv1d = (context, attributes) => {\n        const isChannelLast = attributes.format === "NHWC";\n        const inputs = [\n          context.inputs[0].reshape(\n            isChannelLast ? (\n              // [N, W, C] -> [N, H=1, W, C]\n              [context.inputs[0].dims[0], 1, context.inputs[0].dims[1], context.inputs[0].dims[2]]\n            ) : (\n              // [N, C, W] -> [N, C, H=1, W]\n              [context.inputs[0].dims[0], context.inputs[0].dims[1], 1, context.inputs[0].dims[2]]\n            )\n          ),\n          //[FILTER_OUT_CHANNEL, FILTER_IN_CHANNEL, kW] -> [FILTER_OUT_CHANNEL, FILTER_IN_CHANNEL, kH=1, kW]\n          context.inputs[1].reshape([context.inputs[1].dims[0], context.inputs[1].dims[1], 1, context.inputs[1].dims[2]])\n        ];\n        if (context.inputs.length === 3) {\n          inputs.push(context.inputs[2]);\n        }\n        const pads = [0, attributes.pads[0], 0, attributes.pads[1]];\n        const strides = [1].concat(attributes.strides);\n        const dilations = [1].concat(attributes.dilations);\n        const kernelShape = [1].concat(attributes.kernelShape);\n        const adjustedAttributes = getAdjustedConvAttributes({ ...attributes, pads, strides, dilations, kernelShape }, inputs);\n        context.compute(createGroupedConvProgramInfo(\n          inputs,\n          adjustedAttributes,\n          (outputShape) => isChannelLast ? [outputShape[0], outputShape[2], outputShape[3]] : []\n        ));\n      };\n      conv = (context, attributes) => {\n        validateInputs9(context.inputs, attributes);\n        if (context.inputs[0].dims.length === 3) {\n          conv1d(context, attributes);\n        } else {\n          conv2d(context, context.inputs, attributes);\n        }\n      };\n    }\n  });\n\n  // web/lib/wasm/jsep/webgpu/ops/3rd-party/conv_backprop_mm_webgpu.ts\n  var conv2dTransposeCommonSnippet, createConv2DTransposeMatMulProgramInfo;\n  var init_conv_backprop_mm_webgpu = __esm({\n    "web/lib/wasm/jsep/webgpu/ops/3rd-party/conv_backprop_mm_webgpu.ts"() {\n      "use strict";\n      init_log();\n      init_common();\n      init_fuse_utils();\n      init_activation_util();\n      init_conv_util();\n      init_matmul_packed_webgpu();\n      conv2dTransposeCommonSnippet = (isChannelsLast, addBias = false, attributes, innerElementSize = 4) => {\n        const type = typeSnippet(innerElementSize, "f32");\n        const getWSnippet = (innerElementSize2) => {\n          switch (innerElementSize2) {\n            case 1:\n              return "return w[getIndexFromCoords4D(coord, vec4<i32>(uniforms.w_shape))];";\n            case 4:\n              return `\n            let coord1 = vec4<i32>(coordX, coordY, col + 1, rowInner);\n            let coord2 = vec4<i32>(coordX, coordY, col + 2, rowInner);\n            let coord3 = vec4<i32>(coordX, coordY, col + 3, rowInner);\n            let v0 = w[getIndexFromCoords4D(coord, vec4<i32>(uniforms.w_shape))];\n            let v1 = w[getIndexFromCoords4D(coord1, vec4<i32>(uniforms.w_shape))];\n            let v2 = w[getIndexFromCoords4D(coord2, vec4<i32>(uniforms.w_shape))];\n            let v3 = w[getIndexFromCoords4D(coord3, vec4<i32>(uniforms.w_shape))];\n            return vec4<f32>(v0, v1, v2, v3);\n            `;\n            default:\n              throw new Error(`innerElementSize ${innerElementSize2} is not supported.`);\n          }\n        };\n        const coordASnippet = isChannelsLast ? `\n      let coord = vec4<i32>(batch, iXR, iXC, xCh);\n      ` : `\n      let coord = vec4<i32>(batch, xCh, iXR, iXC);\n      `;\n        const coordResSnippet = isChannelsLast ? `\n    let coords = vec4<i32>(\n      batch,\n      row / outWidth,\n      row % outWidth,\n      col);\n    ` : `\n    let coords = vec4<i32>(\n      batch,\n      row,\n      col / outWidth,\n      col % outWidth);\n    `;\n        const xHeight = isChannelsLast ? "outBackprop[1]" : "outBackprop[2]";\n        const xWidth = isChannelsLast ? "outBackprop[2]" : "outBackprop[3]";\n        const row = isChannelsLast ? "row" : "col";\n        const col = isChannelsLast ? "col" : "row";\n        const readASnippet = `\n      let inChannels = ${isChannelsLast ? "outBackprop[3]" : "outBackprop[1]"};\n      let outWidth = ${isChannelsLast ? "i32(uniforms.result_shape[2])" : "i32(uniforms.result_shape[3])"};\n      let outRow = ${row} / outWidth;\n      let outCol = ${row} % outWidth;\n\n      let WRow = ${col} / (filterDims[1] * inChannels);\n      let WCol = ${col} / inChannels % filterDims[1];\n      let xR = f32(outRow - pads[0] + dilation[0] * WRow) / f32(strides[0]);\n      let xC = f32(outCol - pads[1] + dilation[1] * WCol) / f32(strides[1]);\n      if (xR < 0.0 || xR >= f32(${xHeight}) || fract(xR) > 0.0) {\n        return ${type}(0.0);\n      }\n      if (xC < 0.0 || xC >= f32(${xWidth}) || fract(xC) > 0.0) {\n        return ${type}(0.0);\n      }\n      let iXR = i32(xR);\n      let iXC = i32(xC);\n      let xCh = ${col} % inChannels;\n      ${coordASnippet}\n      return x[getIndexFromCoords4D(coord, vec4<i32>(uniforms.x_shape))/${innerElementSize}];`;\n        const sampleA = isChannelsLast ? `\n      let col = colIn * ${innerElementSize};\n      if (row < uniforms.dimAOuter && col < uniforms.dimInner) {\n        ${readASnippet}\n      }\n      return ${type}(0.0);` : `\n      let col = colIn * ${innerElementSize};\n      if (row < uniforms.dimInner && col < uniforms.dimBOuter) {\n        ${readASnippet}\n      }\n      return ${type}(0.0);`;\n        const sampleW = `\n      let col = colIn * ${innerElementSize};\n      let inChannels = ${isChannelsLast ? "outBackprop[3]" : "outBackprop[1]"};\n      let coordX = filterDims.x - 1 - row / (filterDims[1] * inChannels);\n      let coordY = filterDims.y - 1 - (row / inChannels) % filterDims[1];\n      if (${isChannelsLast ? "row < uniforms.dimInner && col < uniforms.dimBOuter" : "row < uniforms.dimInner && col < uniforms.dimAOuter"}  && coordX >= 0 && coordY >= 0) {\n        let rowInner = row % inChannels;\n        let coord = vec4<i32>(coordX, coordY, col, rowInner);\n        ${getWSnippet(innerElementSize)}\n      }\n      return ${type}(0.0);\n      `;\n        const { activationFunction, applyActivation } = getActivationSnippet(attributes, type);\n        const userCode = `\n      ${activationFunction}\n  fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${type} {\n    ${isChannelsLast ? sampleA : sampleW}\n  }\n\n  fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${type} {\n    ${isChannelsLast ? sampleW : sampleA}\n  }\n\n  fn mm_write(batch: i32, row : i32, colIn : i32, valueInput : ${type}) {\n    let col = colIn * ${innerElementSize};\n    if (row < uniforms.dimAOuter && col < uniforms.dimBOuter) {\n      var value = valueInput;\n      let outWidth = ${isChannelsLast ? "i32(uniforms.result_shape[2])" : "i32(uniforms.result_shape[3])"};\n      ${coordResSnippet}\n      ${biasSnippet(addBias)}\n      ${applyActivation}\n      result[getIndexFromCoords4D(coords, vec4<i32>(uniforms.result_shape))/${innerElementSize}] = value;\n    }\n  }`;\n        return userCode;\n      };\n      createConv2DTransposeMatMulProgramInfo = (inputs, attributes, outputShape, dimAOuter, dimBOuter, dimInner, hasBias, sequentialAccessByThreads) => {\n        const isChannelsLast = attributes.format === "NHWC";\n        const inChannels = isChannelsLast ? inputs[0].dims[3] : inputs[0].dims[1];\n        const batchSize = outputShape[0];\n        const outWidth = isChannelsLast ? outputShape[2] : outputShape[3];\n        const outHeight = isChannelsLast ? outputShape[1] : outputShape[2];\n        const outChannels = isChannelsLast ? outputShape[3] : outputShape[1];\n        const isVec4 = isChannelsLast ? inChannels % 4 === 0 && outChannels % 4 === 0 : outWidth % 4 === 0 && outChannels % 4 === 0;\n        const dispatchX = isChannelsLast ? outChannels : outWidth * outHeight;\n        const dispatchY = isChannelsLast ? outWidth * outHeight : outChannels;\n        const workGroupSize = isVec4 ? [8, 8, 1] : [dispatchX <= 4 || dispatchY <= 4 ? 4 : 16, dispatchX > 4 && dispatchY <= 4 ? 4 : 16, 1];\n        const elementsPerThread = isVec4 ? [4, 4, 1] : [dispatchX <= 4 ? 1 : 4, dispatchX > 4 && dispatchY <= 4 ? 1 : 4, 1];\n        const dispatch = [\n          Math.ceil(dispatchX / workGroupSize[0] / elementsPerThread[0]),\n          Math.ceil(dispatchY / workGroupSize[1] / elementsPerThread[1]),\n          Math.ceil(batchSize / workGroupSize[2] / elementsPerThread[2])\n        ];\n        LOG_DEBUG("verbose", () => `[conv_backprop_mm_webgpu] dispatch = ${dispatch}`);\n        const innerElementSize = isVec4 ? 4 : 1;\n        const tileInner = Math.max(workGroupSize[0] * innerElementSize, workGroupSize[1]);\n        const components = isVec4 ? 4 : 1;\n        const programUniforms = [{ type: "int32", data: dimAOuter }, { type: "int32", data: dimBOuter }, { type: "int32", data: dimInner }];\n        const x = inputVariable("x", inputs[0].dataType, inputs[0].dims.length, components);\n        const w = inputVariable("w", inputs[1].dataType, inputs[1].dims.length, 1);\n        const output = outputVariable("result", inputs[0].dataType, outputShape.length, components);\n        const inputVariables = [x, w];\n        programUniforms.push(...createTensorShapeVariables(inputs[0].dims));\n        programUniforms.push(...createTensorShapeVariables(inputs[1].dims));\n        let declareFunctions = "";\n        if (hasBias) {\n          const bias = inputVariable("bias", inputs[2].dataType, inputs[2].dims.length, components);\n          inputVariables.push(bias);\n          programUniforms.push(...createTensorShapeVariables(inputs[2].dims));\n          declareFunctions += `\n        fn getBiasByOutputCoords(coords : vec4<i32>) -> ${isVec4 ? "vec4<f32>" : "f32"} {\n          return bias[coords.${isChannelsLast ? "w" : "y"}${isVec4 ? "/ 4" : ""}];\n        }`;\n        }\n        programUniforms.push(...createTensorShapeVariables(outputShape));\n        return {\n          name: "Conv2DTransposeMatMul",\n          shaderCache: { hint: attributes.cacheKey },\n          getRunData: () => ({\n            outputs: [{ dims: outputShape, dataType: inputs[0].dataType }],\n            dispatchGroup: { x: dispatch[0], y: dispatch[1], z: dispatch[2] },\n            programUniforms\n          }),\n          getShaderSource: (shaderHelper) => `\n        ${utilFunctions("uniforms.result_strides")}\n        ${shaderHelper.registerUniform("dimAOuter", "i32").registerUniform("dimBOuter", "i32").registerUniform("dimInner", "i32").declareVariables(...inputVariables, output)};\n        const outBackprop : vec4<i32> = vec4<i32>(${inputs[0].dims.join(",")});\n        const filterDims : vec2<i32> = vec2<i32>(${attributes.kernelShape[isChannelsLast ? 1 : 2]}, ${attributes.kernelShape[isChannelsLast ? 2 : 3]});\n        const effectiveFilterDims : vec2<i32> = filterDims + vec2<i32>(\n              ${attributes.dilations[0] <= 1 ? 0 : (attributes.kernelShape[isChannelsLast ? 1 : 2] - 1) * (attributes.dilations[0] - 1)},\n              ${attributes.dilations[1] <= 1 ? 0 : (attributes.kernelShape[isChannelsLast ? 2 : 3] - 1) * (attributes.dilations[1] - 1)});\n        const pads : vec2<i32> = vec2<i32>(i32(effectiveFilterDims[0]) - 1 - (${attributes.pads[0] + attributes.pads[2]})/2,\n                                         i32(effectiveFilterDims[1]) - 1 - (${attributes.pads[1] + attributes.pads[3]})/2);\n        const strides : vec2<i32> = vec2<i32>(${attributes.strides[0]}, ${attributes.strides[1]});\n        const dilation : vec2<i32> = vec2<i32>(${attributes.dilations[0]}, ${attributes.dilations[1]});\n        const dimAOuter : i32 = ${dimAOuter};\n        const dimBOuter : i32 = ${dimBOuter};\n        const dimInner : i32 = ${dimInner};\n        ${declareFunctions}\n        ${conv2dTransposeCommonSnippet(isChannelsLast, hasBias, attributes, innerElementSize)}\n        ${isVec4 ? makeMatMulPackedVec4Source(\n            elementsPerThread,\n            workGroupSize,\n            "f32",\n            void 0,\n            !isChannelsLast,\n            tileInner\n          ) : makeMatMulPackedSource(\n            elementsPerThread,\n            workGroupSize,\n            "f32",\n            void 0,\n            !isChannelsLast,\n            tileInner,\n            false,\n            void 0,\n            sequentialAccessByThreads\n          )}`\n        };\n      };\n    }\n  });\n\n  // web/lib/wasm/jsep/webgpu/ops/3rd-party/conv_backprop_webgpu.ts\n  var createConvTranspose2DOpProgramShaderSource, createConvTranspose2DProgramInfo;\n  var init_conv_backprop_webgpu = __esm({\n    "web/lib/wasm/jsep/webgpu/ops/3rd-party/conv_backprop_webgpu.ts"() {\n      "use strict";\n      init_log();\n      init_util();\n      init_common();\n      createConvTranspose2DOpProgramShaderSource = (shaderHelper, inputs, attributes, outputShape, hasBias, is1DimensionDispatch, isVec4 = false, dataType) => {\n        const isChannelsLast = attributes.format === "NHWC";\n        const rowDim = isChannelsLast ? 1 : 2;\n        const colDim = isChannelsLast ? 2 : 3;\n        const channelDim = isChannelsLast ? 3 : 1;\n        const outputSize = ShapeUtil.size(outputShape);\n        const workPerThread = isVec4 ? 2 : 1;\n        const group = attributes.group;\n        const wShape = inputs[1].dims;\n        const inputChannelsPerGroup = wShape[0] / group;\n        const outputChannelsPerGroup = wShape[1];\n        let declareFunctions = `\n  fn setOutputAtIndex(flatIndex : u32, value : ${isVec4 ? `vec4<${dataType}>` : dataType}) {\n    result[flatIndex] = ${isVec4 ? `vec4<${dataType}>` : dataType}(value);\n  }`;\n        if (hasBias) {\n          declareFunctions += `\n    fn getBiasByOutputCoords(coords : vec4<u32>) -> ${isVec4 ? `vec4<${dataType}>` : dataType} {\n      return bias[coords.${isChannelsLast ? "w" : "y"}${isVec4 ? "/ 4" : ""}];\n    }`;\n        }\n        const components = isVec4 ? 4 : 1;\n        const w = inputVariable("W", inputs[1].dataType, inputs[1].dims, components);\n        const dy = inputVariable("Dy", inputs[0].dataType, inputs[0].dims, components);\n        const inputVariables = [dy, w];\n        if (hasBias) {\n          inputVariables.push(inputVariable("bias", inputs[2].dataType, [outputShape[channelDim]], components));\n        }\n        const output = outputVariable("result", inputs[0].dataType, outputShape, components);\n        const codeSnippet4 = `{\n        let batch: u32 = ${is1DimensionDispatch ? "global_id.z" : "workgroup_id.z"} / outShape[1];\n        let r = ${is1DimensionDispatch ? "global_id.z" : "workgroup_id.z"} % outShape[1];\n        let c = ${is1DimensionDispatch ? "global_id.y" : "workgroup_id.y"} * ${workPerThread};\n        let d1: u32 = ${is1DimensionDispatch ? "global_id.x" : "workgroup_id.x"} * 4;\n\n        let dyCorner = vec2<i32>(i32(r), i32(c)) - vec2<i32>(pads);\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        var dotProd: array<vec4<${dataType}>, ${workPerThread}>;\n        for (var i = 0; i < ${workPerThread}; i++) {\n          dotProd[i] = vec4<${dataType}>(0.0);\n        }\n        for (var wR: u32 = 0; wR < filterDims[0]; wR = wR + 1) {\n          var dyR = (${dataType}(dyCorner.x) + ${dataType}(wR)) / ${dataType}(strides.x);\n          let wRPerm = filterDims[0] - 1 - wR;\n          if (dyR < 0.0 || dyR >= ${dataType}(outBackprop[1]) ||\n              fract(dyR) > 0.0 || wRPerm < 0) {\n            continue;\n          }\n          let idyR: u32 = u32(dyR);\n\n          for (var wC: u32 = 0; wC < filterDims[1]; wC = wC + 1) {\n            let dyC = (${dataType}(dyCorner.y) + ${dataType}(wC)) / ${dataType}(strides.y);\n            let dyC2 = (${dataType}(dyCorner.y) + 1.0 + ${dataType}(wC)) / ${dataType}(strides.y);\n            let wCPerm = filterDims[1] - 1 - wC;\n            if (wCPerm < 0) {\n              continue;\n            }\n            var bDyCVal = true;\n            var bDyCVal2 = true;\n            if (dyC < 0.0 || dyC >= ${dataType}(outBackprop[2]) ||\n                fract(dyC) > 0.0) {\n              bDyCVal = false;\n            }\n            if (dyC2 < 0.0 || dyC2 >= ${dataType}(outBackprop[2]) ||\n                fract(dyC2) > 0.0) {\n              bDyCVal2 = false;\n            }\n\n            let idyC: u32 = u32(dyC);\n            let idyC2: u32 = u32(dyC2);\n            if (bDyCVal && bDyCVal2) {\n              let d2Length = outBackprop[3];\n              for (var d2 :u32 = 0; d2 < d2Length; d2 = d2 + 4) {\n                let wValue0 = ${w.get("u32(wRPerm)", "u32(wCPerm)", "d1", "d2")};\n                let wValue1 = ${w.get("u32(wRPerm)", "u32(wCPerm)", "d1 + 1", "d2")};\n                let wValue2 = ${w.get("u32(wRPerm)", "u32(wCPerm)", "d1 + 2", "d2")};\n                let wValue3 = ${w.get("u32(wRPerm)", "u32(wCPerm)", "d1 + 3", "d2")};\n\n                var xValue = ${dy.get("batch", "idyR", "idyC", "d2")};\n                let tmpval = vec4<${dataType}>(dot(xValue, wValue0),\n                                      dot(xValue, wValue1),\n                                      dot(xValue, wValue2),\n                                      dot(xValue, wValue3));\n                dotProd[0] = dotProd[0] + tmpval;\n\n                xValue =  ${dy.get("batch", "idyR", "idyC2", "d2")};\n\n                dotProd[1] = dotProd[1] + vec4<${dataType}>(dot(xValue, wValue0),\n                                                    dot(xValue, wValue1),\n                                                    dot(xValue, wValue2),\n                                                    dot(xValue, wValue3));\n              }\n            } else if (bDyCVal) {\n              let d2Length = outBackprop[${channelDim}];\n              for (var d2: u32 = 0; d2 < d2Length; d2 = d2 + 4) {\n                let wValue0 = ${w.get("u32(wRPerm)", "u32(wCPerm)", "d1", "d2")};\n                let wValue1 = ${w.get("u32(wRPerm)", "u32(wCPerm)", "d1 + 1", "d2")};\n                let wValue2 = ${w.get("u32(wRPerm)", "u32(wCPerm)", "d1 + 2", "d2")};\n                let wValue3 = ${w.get("u32(wRPerm)", "u32(wCPerm)", "d1 + 3", "d2")};\n\n                var xValue = ${dy.get("batch", "idyR", "idyC", "d2")};\n                let tmpval = vec4<${dataType}>(dot(xValue, wValue0),\n                                      dot(xValue, wValue1),\n                                      dot(xValue, wValue2),\n                                      dot(xValue, wValue3));\n                dotProd[0] = dotProd[0] + tmpval;\n              }\n            } else if (bDyCVal2) {\n              let d2Length = outBackprop[3];\n              for (var d2: u32 = 0; d2 < d2Length; d2 = d2 + 4) {\n                let wValue0 = ${w.get("u32(wRPerm)", "u32(wCPerm)", "d1", "d2")};\n                let wValue1 = ${w.get("u32(wRPerm)", "u32(wCPerm)", "d1 + 1", "d2")};\n                let wValue2 = ${w.get("u32(wRPerm)", "u32(wCPerm)", "d1 + 2", "d2")};\n                let wValue3 = ${w.get("u32(wRPerm)", "u32(wCPerm)", "d1 + 3", "d2")};\n\n                var xValue = ${dy.get("batch", "idyR", "idyC2", "d2")};\n                let tmpval = vec4<${dataType}>(dot(xValue, wValue0),\n                                      dot(xValue, wValue1),\n                                      dot(xValue, wValue2),\n                                      dot(xValue, wValue3));\n                dotProd[1] = dotProd[1] + tmpval;\n              }\n            }\n          }\n        }\n\n        for (var i: u32 = 0; i < ${workPerThread}; i = i + 1) {\n          let value = dotProd[i] + ${hasBias ? "bias[c+i]" : `vec4<${dataType}>(0.0)`};\n          ${output.set("batch", "r", "c + i", "d1", "value")};\n        }\n      }`;\n        const codeSnippet = `\n          let outputIndices = ${output.offsetToIndices("global_idx")};\n          let batch = ${output.indicesGet("outputIndices", 0)};\n          let d1 = ${output.indicesGet("outputIndices", channelDim)};\n          let r = ${output.indicesGet("outputIndices", rowDim)};\n          let c = ${output.indicesGet("outputIndices", colDim)};\n          let dyCorner = vec2<i32>(i32(r), i32(c)) - pads;\n          let dyRCorner = dyCorner.x;\n          let dyCCorner = dyCorner.y;\n          let groupId = d1 / ${outputChannelsPerGroup};\n          let wOutChannel = d1 - groupId * ${outputChannelsPerGroup};\n          // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n          // ? = to be determined. : = across all values in that axis.\n          var dotProd = ${dataType}(0.0);\n          for (var wR: u32 = 0; wR < effectiveFilterDims.x; wR = wR + 1) {\n            if (wR % dilations.x != 0) {\n              continue;\n            }\n            let dyR = (${dataType}(dyRCorner) + ${dataType}(wR)) / ${dataType}(strides[0]);\n            let wRPerm = filterDims.x - 1 - wR / dilations.x;\n            if (dyR < 0.0 || dyR >= ${dataType}(outBackprop[${rowDim}]) || fract(dyR) > 0.0 ||\n                wRPerm < 0) {\n              continue;\n            }\n            let idyR: u32 = u32(dyR);\n\n            for (var wC: u32 = 0; wC < effectiveFilterDims.y; wC = wC + 1) {\n              if (wC % dilations.y != 0) {\n                continue;\n              }\n              let dyC = (${dataType}(dyCCorner) + ${dataType}(wC)) / ${dataType}(strides.y);\n              let wCPerm = filterDims.y - 1 - wC / dilations.y;\n              if (dyC < 0.0 || dyC >= ${dataType}(outBackprop[${colDim}]) ||\n                  fract(dyC) > 0.0 || wCPerm < 0) {\n                continue;\n              }\n              let idyC: u32 = u32(dyC);\n              var inputChannel = groupId * ${inputChannelsPerGroup};\n              for (var d2: u32 = 0; d2 < ${inputChannelsPerGroup}; d2 = d2 + 1) {\n                let xValue = ${isChannelsLast ? dy.get("batch", "idyR", "idyC", "inputChannel") : dy.get("batch", "inputChannel", "idyR", "idyC")};\n                let wValue = ${w.get("inputChannel", "wOutChannel", "u32(wRPerm)", "u32(wCPerm)")};\n                dotProd = dotProd + xValue * wValue;\n                inputChannel = inputChannel + 1;\n              }\n            }\n          }\n          let value = dotProd + ${hasBias ? "bias[d1]" : `${dataType}(0.0)`};\n          ${output.setByOffset("global_idx", "value")};\n        `;\n        return `\n  ${shaderHelper.declareVariables(...inputVariables, output)}\n  ${declareFunctions}\n  const outShape : vec4<u32> = vec4<u32>(${outputShape.join(",")});\n  const outBackprop : vec4<u32> = vec4<u32>(${inputs[0].dims.join(",")});\n  const strides : vec2<u32> = vec2<u32>(${attributes.strides[0]}, ${attributes.strides[1]});\n  const filterDims : vec2<u32> = vec2<u32>(${attributes.kernelShape[isChannelsLast ? 1 : 2]}, ${attributes.kernelShape[isChannelsLast ? 2 : 3]});\n  const dilations : vec2<u32> = vec2<u32>(${attributes.dilations[0]}, ${attributes.dilations[1]});\n  const effectiveFilterDims : vec2<u32> = filterDims + vec2<u32>(\n          ${attributes.dilations[0] <= 1 ? 0 : (attributes.kernelShape[isChannelsLast ? 1 : 2] - 1) * (attributes.dilations[0] - 1)},\n          ${attributes.dilations[1] <= 1 ? 0 : (attributes.kernelShape[isChannelsLast ? 2 : 3] - 1) * (attributes.dilations[1] - 1)});\n  const pads : vec2<i32> = vec2<i32>(i32(effectiveFilterDims[0]) - 1 - (${attributes.pads[0] + attributes.pads[2]})/2,\n                                     i32(effectiveFilterDims[1]) - 1 - (${attributes.pads[1] + attributes.pads[3]})/2);\n    ${shaderHelper.mainStart()}\n    ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes(outputSize)};\n  ${isVec4 ? codeSnippet4 : codeSnippet}}`;\n      };\n      createConvTranspose2DProgramInfo = (inputs, attributes, squeezeOutputShapeFunction) => {\n        const hasBias = inputs.length > 2;\n        const outputShape = attributes.outputShape;\n        const outputSize = ShapeUtil.size(outputShape);\n        const dispatch = [\n          Math.ceil(outputSize / 64),\n          1,\n          1\n        ];\n        LOG_DEBUG("verbose", () => `[conv2d_backprop_webgpu] dispatch = ${dispatch}`);\n        const dataType = tensorTypeToWsglStorageType(inputs[0].dataType);\n        return {\n          name: "ConvTranspose2D",\n          shaderCache: { hint: attributes.cacheKey },\n          getRunData: () => ({\n            dispatchGroup: { x: dispatch[0], y: dispatch[1], z: dispatch[2] },\n            outputs: [{\n              dims: squeezeOutputShapeFunction ? squeezeOutputShapeFunction(outputShape) : outputShape,\n              dataType: inputs[0].dataType\n            }]\n          }),\n          getShaderSource: (shaderHelper) => createConvTranspose2DOpProgramShaderSource(\n            shaderHelper,\n            inputs,\n            attributes,\n            outputShape,\n            hasBias,\n            dispatch[1] === 1 && dispatch[2] === 1,\n            false,\n            dataType\n          )\n        };\n      };\n    }\n  });\n\n  // web/lib/wasm/jsep/webgpu/ops/conv-transpose.ts\n  var computeTotalPad, distributePadding, calculateOutputShapeAndPads, getAdjustedConvTransposeAttributes, parseConvTransposeAttributes, validateInputs10, weightTransposePerm, convTranspose2d, convTranspose1d, convTranspose;\n  var init_conv_transpose = __esm({\n    "web/lib/wasm/jsep/webgpu/ops/conv-transpose.ts"() {\n      "use strict";\n      init_attribute_with_cache_key();\n      init_conv_backprop_mm_webgpu();\n      init_conv_backprop_webgpu();\n      init_fuse_utils();\n      init_transpose();\n      computeTotalPad = (inDim, stride, adj, kernel, dilation, outSize) => (inDim - 1) * stride + adj + (kernel - 1) * dilation + 1 - outSize;\n      distributePadding = (totalPad, autoPad, pads, head, tail) => {\n        const smallPad = Math.floor(totalPad / 2);\n        if (autoPad === "SAME_UPPER") {\n          pads[head] = smallPad;\n          pads[tail] = totalPad - smallPad;\n        } else if (autoPad === "SAME_LOWER") {\n          pads[head] = totalPad - smallPad;\n          pads[tail] = smallPad;\n        }\n      };\n      calculateOutputShapeAndPads = (inputShape, kernelShape, dilations, autoPad, group, pads, strides, isChannelLast, outputPadding, outputShape) => {\n        const spatialRank = inputShape.length - 2;\n        const updateOutputShape = outputShape.length === 0;\n        if (outputPadding.length === 0) {\n          for (let i = 0; i < spatialRank; ++i) {\n            outputPadding.push(0);\n          }\n        }\n        const batchSize = inputShape[0];\n        const outChannels = kernelShape[isChannelLast ? 3 : 1] * group;\n        for (let i = 0, j = inputShape.length - spatialRank - (isChannelLast ? 1 : 0); i < spatialRank; ++i, ++j) {\n          const inSize = inputShape[j];\n          const outSize = updateOutputShape ? inSize * strides[i] : outputShape[i];\n          const totalPad = computeTotalPad(inSize, strides[i], pads[i], kernelShape[j], dilations[i], outSize);\n          distributePadding(totalPad, autoPad, pads, i, i + spatialRank);\n          if (updateOutputShape) {\n            outputShape.push(\n              strides[i] * (inSize - 1) + outputPadding[i] + (kernelShape[j] - 1) * dilations[i] + 1 - pads[i] - pads[i + spatialRank]\n            );\n          }\n        }\n        outputShape.splice(0, 0, batchSize);\n        outputShape.splice(isChannelLast ? 3 : 1, 0, outChannels);\n      };\n      getAdjustedConvTransposeAttributes = (attributes, inputs) => {\n        const kernelShape = attributes.kernelShape.slice();\n        if (attributes.kernelShape.length === 0 || attributes.kernelShape.reduce((a, b) => a * b, 1) === 0) {\n          kernelShape.length = 0;\n          for (let i = 2; i < inputs[1].dims.length; ++i) {\n            kernelShape.push(inputs[1].dims[i]);\n          }\n        }\n        const isChannelsLast = attributes.format === "NHWC";\n        kernelShape.splice(0, 0, inputs[1].dims[0]);\n        kernelShape.splice(isChannelsLast ? 3 : 1, 0, inputs[1].dims[1]);\n        const pads = attributes.pads.slice();\n        const outputShape = attributes.outputShape.slice();\n        const outputPadding = attributes.outputPadding.slice();\n        const inputShape = inputs[0].dims;\n        let dilations = attributes.dilations.slice();\n        if (dilations.reduce((a, b) => a + b, 0) === 0) {\n          const spatialRank = inputs[0].dims.length - 2;\n          dilations = new Array(spatialRank).fill(1);\n        }\n        let strides = attributes.strides.slice();\n        if (strides.reduce((a, b) => a + b, 0) === 0) {\n          const spatialRank = inputs[0].dims.length - 2;\n          strides = new Array(spatialRank).fill(1);\n        }\n        calculateOutputShapeAndPads(\n          inputShape,\n          kernelShape,\n          dilations,\n          attributes.autoPad,\n          attributes.group,\n          pads,\n          strides,\n          isChannelsLast,\n          outputPadding,\n          outputShape\n        );\n        const newAttributes = Object.assign({}, attributes);\n        const cacheKey = attributes.cacheKey + [\n          kernelShape.join("n,"),\n          pads.join(","),\n          strides.join(","),\n          outputPadding.join(","),\n          outputShape.join(","),\n          dilations.join(",")\n        ].join("_");\n        Object.assign(newAttributes, { kernelShape, pads, outputPadding, outputShape, dilations, strides, cacheKey });\n        return newAttributes;\n      };\n      parseConvTransposeAttributes = (attributes) => {\n        const activationAttributes = parseInternalActivationAttributes(attributes);\n        const format = attributes.format;\n        const autoPad = [\n          "NOTSET",\n          "VALID",\n          "SAME_UPPER",\n          "SAME_LOWER"\n        ][typeof attributes.autoPad == "undefined" ? 0 : attributes.autoPad];\n        const dilations = attributes.dilations;\n        const group = attributes.group;\n        const kernelShape = attributes.kernelShape;\n        const pads = attributes.pads;\n        const strides = attributes.strides;\n        const wIsConst = attributes.wIsConst();\n        const outputPadding = attributes.outputPadding;\n        const outputShape = attributes.outputShape;\n        return createAttributeWithCacheKey({\n          autoPad,\n          format,\n          dilations,\n          group,\n          kernelShape,\n          outputPadding,\n          outputShape,\n          pads,\n          strides,\n          wIsConst,\n          ...activationAttributes\n        });\n      };\n      validateInputs10 = (inputs, attributes) => {\n        if (!inputs || inputs.length !== 2 && inputs.length !== 3) {\n          throw new Error("Conv requires 2 or 3 inputs");\n        }\n        if (inputs[0].dims.length !== 4 && inputs[0].dims.length !== 3) {\n          throw new Error("currently only support 2-dimensional conv");\n        }\n        if (inputs[0].dims.length !== inputs[1].dims.length) {\n          throw new Error("filter does not have same dimension as input");\n        }\n        const dataChannel = inputs[0].dims[attributes.format === "NHWC" ? inputs[0].dims.length - 1 : 1];\n        const filterInChannel = inputs[1].dims[0];\n        if (dataChannel !== filterInChannel) {\n          throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");\n        }\n        const featureMaps = inputs[1].dims[1] * attributes.group;\n        if (inputs.length === 3 && (inputs[2].dims.length !== 1 || inputs[2].dims[0] !== featureMaps)) {\n          throw new Error("invalid bias");\n        }\n        const spatialRank = inputs[0].dims.length - 2;\n        const dilationsSet = attributes.dilations.reduce((a, b) => a + b, 0) > 0;\n        if (dilationsSet && attributes.dilations.length !== spatialRank) {\n          throw new Error(`dilations should be ${spatialRank}D`);\n        }\n        const stridesSet = attributes.strides.reduce((a, b) => a + b, 0) > 0;\n        if (stridesSet && attributes.strides.length !== spatialRank) {\n          throw new Error(`strides should be ${spatialRank}D`);\n        }\n        const padsSet = attributes.pads.reduce((a, b) => a + b, 0) > 0;\n        if (padsSet && attributes.pads.length !== spatialRank * 2) {\n          throw new Error(`pads should be ${spatialRank * 2}D`);\n        }\n        if (attributes.outputPadding.length !== spatialRank && attributes.outputPadding.length !== 0) {\n          throw new Error(`output_padding should be ${spatialRank}D`);\n        }\n        const kernelShapeSet = attributes.kernelShape.reduce((a, b) => a + b, 0) > 0;\n        if (kernelShapeSet && attributes.kernelShape.length !== 0 && attributes.kernelShape.length !== inputs[1].dims.length - 2) {\n          throw new Error("invalid kernel shape");\n        }\n        if (attributes.outputShape.length !== 0 && attributes.outputShape.length !== inputs[0].dims.length - 2) {\n          throw new Error("invalid output shape");\n        }\n      };\n      weightTransposePerm = [2, 3, 1, 0];\n      convTranspose2d = (context, inputs, attributes) => {\n        const adjustedAttributes = getAdjustedConvTransposeAttributes(attributes, inputs);\n        const isChannelsLast = attributes.format === "NHWC";\n        const outputShape = adjustedAttributes.outputShape;\n        const outChannels = outputShape[isChannelsLast ? 3 : 1];\n        const inputChannels = inputs[0].dims[isChannelsLast ? 3 : 1];\n        if (adjustedAttributes.group !== 1 || outChannels === 1 && inputChannels === 1) {\n          context.compute(createConvTranspose2DProgramInfo(inputs, adjustedAttributes));\n          return;\n        }\n        const outHeight = outputShape[isChannelsLast ? 1 : 2];\n        const outWidth = outputShape[isChannelsLast ? 2 : 3];\n        const weightHeight = inputs[1].dims[2];\n        const weightWidth = inputs[1].dims[3];\n        const dimAOuter = isChannelsLast ? outHeight * outWidth : outChannels;\n        const dimBOuter = isChannelsLast ? outChannels : outHeight * outWidth;\n        const dimInner = weightHeight * weightWidth * inputChannels;\n        const sequentialAccessByThreads = (\n          /* backend.adapterInfo.isIntel() */\n          true\n        );\n        const transposedWeight = context.kernelCustomData.wT ?? context.compute(\n          createTransposeProgramInfo(inputs[1], weightTransposePerm),\n          { inputs: [1], outputs: [attributes.wIsConst ? -2 : -1] }\n        )[0];\n        if (attributes.wIsConst && !context.kernelCustomData.wT) {\n          context.kernelCustomData.wT = transposedWeight;\n        }\n        const convTransposeInputs = [inputs[0], transposedWeight];\n        const hasBias = inputs.length === 3;\n        if (hasBias) {\n          if (!isChannelsLast && inputs[2].dims.length === 1) {\n            convTransposeInputs.push(inputs[2].reshape([inputs[2].dims[0], 1, 1]));\n          } else {\n            convTransposeInputs.push(inputs[2]);\n          }\n        }\n        context.compute(\n          createConv2DTransposeMatMulProgramInfo(\n            convTransposeInputs,\n            adjustedAttributes,\n            outputShape,\n            dimAOuter,\n            dimBOuter,\n            dimInner,\n            hasBias,\n            sequentialAccessByThreads\n          ),\n          { inputs: convTransposeInputs }\n        );\n      };\n      convTranspose1d = (context, attributes) => {\n        const isChannelLast = attributes.format === "NHWC";\n        const inputs = [\n          context.inputs[0].reshape(\n            isChannelLast ? (\n              // [N, W, C] -> [N, H=1, W, C]\n              [context.inputs[0].dims[0], 1, context.inputs[0].dims[1], context.inputs[0].dims[2]]\n            ) : (\n              // [N, C, W] -> [N, C, H=1, W]\n              [context.inputs[0].dims[0], context.inputs[0].dims[1], 1, context.inputs[0].dims[2]]\n            )\n          ),\n          //[FILTER_OUT_CHANNEL, FILTER_IN_CHANNEL, kW] -> [FILTER_OUT_CHANNEL, FILTER_IN_CHANNEL, kH=1, kW]\n          context.inputs[1].reshape([context.inputs[1].dims[0], context.inputs[1].dims[1], 1, context.inputs[1].dims[2]])\n        ];\n        if (inputs.length === 3) {\n          inputs.push(context.inputs[2]);\n        }\n        let kernelShape = attributes.kernelShape;\n        if (kernelShape.length === 0 || kernelShape[0] === 0) {\n          kernelShape = [context.inputs[1].dims[2]];\n        }\n        let dilations = attributes.dilations;\n        if (dilations.length === 0 || dilations[0] === 0) {\n          dilations = [1];\n        }\n        let strides = attributes.strides;\n        if (strides.length === 0 || strides[0] === 0) {\n          strides = [1];\n        }\n        let pads = attributes.pads;\n        if (pads.length === 0) {\n          pads = [0, 0];\n        }\n        pads = [0, pads[0], 0, pads[1]];\n        strides = [1].concat(strides);\n        dilations = [1].concat(dilations);\n        kernelShape = [1].concat(kernelShape);\n        const adjustedAttributes = getAdjustedConvTransposeAttributes({ ...attributes, pads, strides, dilations, kernelShape }, inputs);\n        context.compute(createConvTranspose2DProgramInfo(\n          inputs,\n          adjustedAttributes,\n          (outputShape) => isChannelLast ? [outputShape[0], outputShape[2], outputShape[3]] : [outputShape[0], outputShape[1], outputShape[3]]\n        ));\n      };\n      convTranspose = (context, attributes) => {\n        validateInputs10(context.inputs, attributes);\n        if (context.inputs[0].dims.length === 3) {\n          convTranspose1d(context, attributes);\n        } else {\n          convTranspose2d(context, context.inputs, attributes);\n        }\n      };\n    }\n  });\n\n  // web/lib/wasm/jsep/webgpu/ops/cumsum.ts\n  var createCumsumProgramInfo, cumsum, parseCumSumAttributes;\n  var init_cumsum = __esm({\n    "web/lib/wasm/jsep/webgpu/ops/cumsum.ts"() {\n      "use strict";\n      init_wasm_common();\n      init_util();\n      init_attribute_with_cache_key();\n      init_common();\n      createCumsumProgramInfo = (inputType, inputShape, axisInput, attributes) => {\n        const outputSize = ShapeUtil.size(inputShape);\n        const rank = inputShape.length;\n        const input = inputVariable("input", inputType, rank);\n        const output = outputVariable("output", inputType, rank);\n        const axisValue = axisInput.dataType === 6 /* int32 */ ? axisInput.getInt32Array()[0] : Number(axisInput.getBigInt64Array()[0]);\n        const axis = ShapeUtil.normalizeAxis(axisValue, rank);\n        const getShaderSource = (shaderHelper) => {\n          const index = ` i32(${input.indicesGet("inputIndices", "uniforms.axis")}) `;\n          const max = getElementAt("uniforms.input_shape", "uniforms.axis", rank);\n          const lowerLimit = attributes.reverse ? index + (attributes.exclusive ? " + 1" : "") : "0";\n          const upperLimit = attributes.reverse ? max : index + (attributes.exclusive ? "" : " + 1");\n          return `\n                ${shaderHelper.registerUniform("outputSize", "u32").registerUniform("axis", "u32").declareVariables(input, output)}\n                ${shaderHelper.mainStart()}\n                  ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n                  var inputIndices = ${output.offsetToIndices("global_idx")};\n                  var sum = ${output.type.value}(0);\n                  let first : i32 = ${lowerLimit};\n                  let last : i32 = ${upperLimit};\n                  for (var i : i32 = first; i < last; i++) {\n                    ${input.indicesSet("inputIndices", "uniforms.axis", "u32(i)")};\n                    sum = sum + ${input.getByIndices("inputIndices")};\n                  }\n                  ${output.setByOffset("global_idx", "sum")};\n                }`;\n        };\n        return {\n          name: "CumSum",\n          shaderCache: { hint: attributes.cacheKey, inputDependencies: ["rank"] },\n          getRunData: () => ({\n            outputs: [{ dims: inputShape, dataType: inputType }],\n            dispatchGroup: { x: Math.ceil(\n              outputSize / 64\n              /* workgroup size */\n            ) },\n            programUniforms: [\n              { type: "uint32", data: outputSize },\n              { type: "int32", data: axis },\n              ...createTensorShapeVariables(inputShape),\n              ...createTensorShapeVariables(inputShape)\n            ]\n          }),\n          getShaderSource\n        };\n      };\n      cumsum = (context, attributes) => {\n        const inputShape = context.inputs[0].dims;\n        const inputType = context.inputs[0].dataType;\n        const axis = context.inputs[1];\n        context.compute(createCumsumProgramInfo(inputType, inputShape, axis, attributes), { inputs: [0] });\n      };\n      parseCumSumAttributes = (attributes) => {\n        const exclusive = attributes.exclusive === 1;\n        const reverse = attributes.reverse === 1;\n        return createAttributeWithCacheKey({ exclusive, reverse });\n      };\n    }\n  });\n\n  // web/lib/wasm/jsep/webgpu/ops/einsum.ts\n  var symbolPattern, termPattern, termPatternOnly, lhsPattern, lhsPatternOnly, EinsumTerm, EinsumEquation, appendMax, createEinsumProgramInfo, einsum, parseEinsumAttributes;\n  var init_einsum = __esm({\n    "web/lib/wasm/jsep/webgpu/ops/einsum.ts"() {\n      "use strict";\n      init_util();\n      init_attribute_with_cache_key();\n      init_common();\n      symbolPattern = "[a-zA-Z]|\\\\.\\\\.\\\\.";\n      termPattern = "(" + symbolPattern + ")+";\n      termPatternOnly = "^" + termPattern + "$";\n      lhsPattern = "(" + termPattern + ",)*" + termPattern;\n      lhsPatternOnly = "^" + lhsPattern + "$";\n      EinsumTerm = class {\n        constructor(inputIndex = -1) {\n          this.symbolToIndices = /* @__PURE__ */ new Map();\n          this.inputIndex = inputIndex;\n        }\n        // Add a symbol to the term\n        addSymbol(symbol, index) {\n          let value = this.symbolToIndices.get(symbol);\n          if (value === void 0) {\n            value = [index];\n          } else {\n            value.push(index);\n          }\n          this.symbolToIndices.set(symbol, value);\n        }\n        // -1 for output and 0, 1, 2, ... for inputs\n      };\n      EinsumEquation = class {\n        constructor(inputs, equation) {\n          this.equation = equation;\n          this.hasEllipsis = false;\n          this.symbolToInfo = /* @__PURE__ */ new Map();\n          this.lhs = new Array();\n          this.outputDims = [];\n          let [lhs, rhs] = equation.includes("->") ? equation.split("->", 2) : [equation, ""];\n          if (!lhs.match(RegExp(lhsPatternOnly))) {\n            throw new Error("Invalid LHS term");\n          }\n          const inputTerms = lhs.split(",");\n          inputTerms.forEach((inputTerm, index) => {\n            const dims = inputs[index].dims.slice();\n            if (!inputTerm.match(RegExp(termPatternOnly))) {\n              throw new Error("Invalid LHS term");\n            }\n            const einsumTerm = this.processTerm(inputTerm, true, dims, index);\n            this.lhs.push(einsumTerm);\n          });\n          if (rhs === "") {\n            rhs += [...this.symbolToInfo.entries()].filter(([sym, info]) => info.count === 1 || sym === "...").map(([sym]) => sym).join("");\n          } else {\n            if (!rhs.match(RegExp(termPattern))) {\n              throw new Error("Invalid RHS");\n            }\n          }\n          const rhsSymbols = rhs.match(RegExp(symbolPattern, "g"));\n          rhsSymbols?.forEach((symbol) => {\n            if (symbol === "...") {\n              this.outputDims = this.outputDims.concat(this.ellipsisDims);\n            } else {\n              const info = this.symbolToInfo.get(symbol);\n              if (info === void 0) {\n                throw new Error("Invalid RHS symbol");\n              }\n              this.outputDims.push(info.dimValue);\n            }\n          });\n          this.rhs = this.processTerm(rhs, false, this.outputDims);\n        }\n        // End of EinsumEqation constructor\n        // Add a symbol to the equation\n        addSymbol(symbol, dimValue, inputIndex) {\n          let info = this.symbolToInfo.get(symbol);\n          if (info !== void 0) {\n            if (info.dimValue !== dimValue && info.count !== 1) {\n              throw new Error("Dimension mismatch");\n            } else {\n              info.count++;\n              info.inputIndices.push(inputIndex);\n            }\n          } else {\n            info = { count: 1, dimValue, inputIndices: [inputIndex] };\n          }\n          this.symbolToInfo.set(symbol, info);\n        }\n        // Process one input/output term\n        processTerm(term, isInput, dims, index = -1) {\n          const rank = dims.length;\n          let ellipsis = false;\n          let ellipsisDims = [];\n          let nextDim = 0;\n          if (!term.match(RegExp(termPatternOnly)) && (!isInput && term !== "")) {\n            throw new Error("Invalid LHS term");\n          }\n          const indexSymbols = term.match(RegExp(symbolPattern, "g"));\n          const einsumTerm = new EinsumTerm(index);\n          indexSymbols?.forEach((symbol, i) => {\n            if (symbol === "...") {\n              if (ellipsis) {\n                throw new Error("Only one ellipsis is allowed per input term");\n              }\n              ellipsis = true;\n              const ellipsisDimLength = rank - indexSymbols.length + 1;\n              if (ellipsisDimLength < 0) {\n                throw new Error("Ellipsis out of bounds");\n              }\n              ellipsisDims = dims.slice(nextDim, nextDim + ellipsisDimLength);\n              if (this.hasEllipsis) {\n                if (this.ellipsisDims.length !== ellipsisDims.length || this.ellipsisDims.toString() !== ellipsisDims.toString()) {\n                  throw new Error("Ellipsis dimensions mismatch");\n                }\n              } else if (isInput) {\n                this.hasEllipsis = true;\n                this.ellipsisDims = ellipsisDims;\n              } else {\n                throw new Error("Ellipsis must be specified in the LHS");\n              }\n              for (let j = 0; j < ellipsisDims.length; j++) {\n                const symbol2 = String.fromCharCode("0".charCodeAt(0) + j);\n                einsumTerm.addSymbol(symbol2, i + j);\n                this.addSymbol(symbol2, dims[nextDim++], index);\n              }\n            } else {\n              einsumTerm.addSymbol(symbol, i + (this.hasEllipsis ? this.ellipsisDims.length - 1 : 0));\n              this.addSymbol(symbol, dims[nextDim++], index);\n            }\n          });\n          return einsumTerm;\n        }\n        // Output dimensions of the equation\n      };\n      appendMax = (name) => name + "_max";\n      createEinsumProgramInfo = (enableInputShapesUniforms, inputShapes, dataType, einsumEquation, outputShape) => {\n        const shapeOrRanks = inputShapes.map((dims, index) => enableInputShapesUniforms[index] ? dims.length : dims);\n        const inputVars = shapeOrRanks.map((shapeOrRank, index) => inputVariable(`input${index}`, dataType, shapeOrRank));\n        const outputSize = ShapeUtil.size(outputShape);\n        const enableOutputShapesUniforms = enableShapesUniforms(outputShape.length);\n        const outputShapeOrRank = enableOutputShapesUniforms ? outputShape.length : outputShape;\n        const output = outputVariable("output", dataType, outputShapeOrRank);\n        const uniformsSymbols = [...einsumEquation.symbolToInfo.keys()].filter((symbol) => !einsumEquation.rhs.symbolToIndices.has(symbol));\n        const getShaderSource = (shaderHelper) => {\n          const idxCopy = [];\n          const initProd = "var prod = 1.0;";\n          const initSum = "var sum = 0.0;";\n          const updateSum = "sum += prod;";\n          const reduceOpsSetIndices = [];\n          const reduceOpsLoopHeaders = [];\n          const reduceOpsLoopFooters = [];\n          const reduceOpCompute = [];\n          const isReduceOpsWithoutLoop = einsumEquation.symbolToInfo.size === einsumEquation.rhs.symbolToIndices.size;\n          einsumEquation.symbolToInfo.forEach((info, symbol) => {\n            if (einsumEquation.rhs.symbolToIndices.has(symbol)) {\n              const outputIndex = einsumEquation.rhs.symbolToIndices.get(symbol)?.[0];\n              if (outputIndex !== void 0) {\n                einsumEquation.lhs.forEach((term, i) => {\n                  if (info.inputIndices.includes(i)) {\n                    const indices = term.symbolToIndices.get(symbol);\n                    if (indices === void 0) {\n                      throw new Error("Invalid symbol error");\n                    }\n                    indices.forEach((index) => {\n                      idxCopy.push(`${inputVars[i].indicesSet(\n                        `input${i}Indices`,\n                        index,\n                        output.indicesGet("outputIndices", outputIndex)\n                      )}`);\n                    });\n                  }\n                });\n              }\n            } else {\n              einsumEquation.lhs.forEach((term, i) => {\n                if (info.inputIndices.includes(i)) {\n                  const indices = term.symbolToIndices.get(symbol);\n                  if (indices === void 0) {\n                    throw new Error("Invalid symbol error");\n                  }\n                  indices.forEach((index) => {\n                    reduceOpsSetIndices.push(`${inputVars[i].indicesSet(`input${i}Indices`, index, `${symbol}`)}`);\n                  });\n                  reduceOpCompute.push(`prod *= ${inputVars[i].getByIndices(`input${i}Indices`)};`);\n                }\n              });\n              reduceOpsLoopHeaders.push(\n                `for(var ${symbol}: u32 = 0; ${symbol} < uniforms.${appendMax(symbol)}; ${symbol}++) {`\n              );\n              reduceOpsLoopFooters.push("}");\n            }\n          });\n          const reduceOps2 = isReduceOpsWithoutLoop ? [\n            ...idxCopy,\n            `let sum = ${inputVars.map((inputVar, i) => inputVar.getByIndices(`input${i}Indices`)).join(" * ")};`\n          ] : [\n            ...idxCopy,\n            initSum,\n            ...reduceOpsLoopHeaders,\n            ...reduceOpsSetIndices,\n            initProd,\n            ...reduceOpCompute,\n            updateSum,\n            ...reduceOpsLoopFooters\n          ];\n          return `\n            ${shaderHelper.registerUniforms(uniformsSymbols.map((symbol) => ({ name: `${appendMax(symbol)}`, type: "u32" }))).registerUniform("outputSize", "u32").declareVariables(...inputVars, output)}\n\n            ${shaderHelper.mainStart()}\n            ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n            var outputIndices = ${output.offsetToIndices("global_idx")};\n            ${inputVars.map((_var, i) => `var input${i}Indices: ${inputVars[i].type.indices};`).join("\\n")}\n            ${reduceOps2.join("\\n")};\n            ${output.setByOffset("global_idx", "sum")};\n          }`;\n        };\n        return {\n          name: "Einsum",\n          shaderCache: {\n            hint: einsumEquation.equation,\n            inputDependencies: enableInputShapesUniforms.map((enableShapeUniform) => enableShapeUniform ? "rank" : "dims")\n          },\n          getRunData: () => {\n            const programUniformsInit = uniformsSymbols.filter((symbol) => einsumEquation.symbolToInfo.has(symbol)).map((symbol) => ({ type: "uint32", data: einsumEquation.symbolToInfo.get(symbol)?.dimValue || 0 }));\n            programUniformsInit.push({ type: "uint32", data: outputSize });\n            const programUniforms = inputShapes.filter((_, index) => enableInputShapesUniforms[index]).map((dims, _) => [...createTensorShapeVariables(dims)]).reduce((acc, inputProgramUniforms) => acc.concat(inputProgramUniforms), programUniformsInit);\n            if (enableOutputShapesUniforms) {\n              programUniforms.push(...createTensorShapeVariables(outputShape));\n            }\n            return {\n              outputs: [{ dims: outputShape, dataType }],\n              dispatchGroup: { x: Math.ceil(\n                outputSize / 64\n                /* workgroup size */\n              ) },\n              programUniforms\n            };\n          },\n          getShaderSource\n        };\n      };\n      einsum = (context, attributes) => {\n        const einsumEquation = new EinsumEquation(context.inputs, attributes.equation);\n        const enableInputShapesUniforms = context.inputs.map((input, _) => enableShapesUniforms(input.dims.length));\n        const outputShape = einsumEquation.outputDims;\n        const inputShapes = context.inputs.map((input, _) => input.dims);\n        context.compute(createEinsumProgramInfo(\n          enableInputShapesUniforms,\n          inputShapes,\n          context.inputs[0].dataType,\n          einsumEquation,\n          outputShape\n        ));\n      };\n      parseEinsumAttributes = (attributes) => {\n        const equation = attributes.equation.replace(/\\s+/g, "");\n        return createAttributeWithCacheKey({ equation });\n      };\n    }\n  });\n\n  // web/lib/wasm/jsep/webgpu/ops/expand.ts\n  var validateInputs11, getAdjustedShape, calculateOutputShape2, createExpandProgramInfo, expand;\n  var init_expand = __esm({\n    "web/lib/wasm/jsep/webgpu/ops/expand.ts"() {\n      "use strict";\n      init_wasm_common();\n      init_util();\n      init_common();\n      validateInputs11 = (inputs) => {\n        if (!inputs || inputs.length !== 2) {\n          throw new Error("Expand requires 2 input.");\n        }\n        const inputShape = inputs[0].dims;\n        const shape = Array.from(inputs[1].getBigInt64Array(), Number);\n        let shapeIndex = shape.length < inputShape.length ? 0 : shape.length - inputShape.length;\n        let inputShapeIndex = inputShape.length < shape.length ? 0 : inputShape.length - shape.length;\n        for (; shapeIndex < shape.length && inputShapeIndex < inputShape.length; ++shapeIndex, ++inputShapeIndex) {\n          if (shape[shapeIndex] !== inputShape[inputShapeIndex] && shape[shapeIndex] !== 1 && inputShape[inputShapeIndex] !== 1) {\n            throw new Error("Expand requires shape to be broadcastable to input");\n          }\n        }\n      };\n      getAdjustedShape = (shape1, shape2) => {\n        const diff = shape1.length - shape2.length;\n        const shape = [];\n        for (let i = 0; i < diff; ++i) {\n          shape.push(shape1[i]);\n        }\n        for (let i = 0; i < shape2.length; ++i) {\n          shape.push(shape2[i] === 1 ? shape1[i + diff] : shape2[i]);\n        }\n        return shape;\n      };\n      calculateOutputShape2 = (inputShape, shape) => inputShape.length > shape.length ? getAdjustedShape(inputShape, shape) : getAdjustedShape(shape, inputShape);\n      createExpandProgramInfo = (inputs) => {\n        const inputShape = inputs[0].dims;\n        const shape = Array.from(inputs[1].getBigInt64Array(), Number);\n        const outputShape = calculateOutputShape2(inputShape, shape);\n        const dataType = inputs[0].dataType;\n        const components = dataType === 9 /* bool */ ? 4 : 1;\n        const outputSize = Math.ceil(ShapeUtil.size(outputShape) / components);\n        const enableInputShapeUniform = enableShapesUniforms(inputShape.length);\n        const enableOutputShapeUniform = enableShapesUniforms(outputShape.length);\n        const getShaderSource = (shaderHelper) => {\n          const inputShapeOrRank = enableInputShapeUniform ? inputShape.length : inputShape;\n          const outputShapeOrRank = enableOutputShapeUniform ? outputShape.length : outputShape;\n          const input = inputVariable("input", dataType, inputShapeOrRank, components);\n          const output = outputVariable("output", dataType, outputShapeOrRank, components);\n          let assignment;\n          if (dataType === 9 /* bool */) {\n            const singleAssignment = (resStr, x, typeCast = "") => `\n          let outputIndices${x} = ${output.offsetToIndices(`outputOffset + ${x}u`)};\n          let offset${x} = ${input.broadcastedIndicesToOffset(`outputIndices${x}`, output)};\n          let index${x} = offset${x} / 4u;\n          let component${x} = offset${x} % 4u;\n          ${resStr}[${x}] = ${typeCast}(${input.getByOffset(`index${x}`)}[component${x}]);\n        `;\n            assignment = `\n        let outputOffset = global_idx * ${components};\n        var data = vec4<u32>(0);\n        ${singleAssignment("data", 0, "u32")}\n        ${singleAssignment("data", 1, "u32")}\n        ${singleAssignment("data", 2, "u32")}\n        ${singleAssignment("data", 3, "u32")}\n        ${output.setByOffset("global_idx", "data")}\n      }`;\n          } else {\n            assignment = `\n        let outputIndices = ${output.offsetToIndices("global_idx")};\n        let inputOffset = ${input.broadcastedIndicesToOffset("outputIndices", output)};\n        ${output.setByOffset("global_idx", input.getByOffset("inputOffset"))}\n      }`;\n          }\n          return `\n    ${shaderHelper.registerUniform("vec_size", "u32").declareVariables(input, output)}\n    ${shaderHelper.mainStart()}\n    ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}\n    ${assignment}`;\n        };\n        const programUniforms = [{ type: "uint32", data: outputSize }];\n        if (enableInputShapeUniform) {\n          programUniforms.push(...createTensorShapeVariables(inputShape));\n        }\n        if (enableOutputShapeUniform) {\n          programUniforms.push(...createTensorShapeVariables(outputShape));\n        }\n        return {\n          name: "Expand",\n          shaderCache: { hint: `${outputShape.length}`, inputDependencies: [enableInputShapeUniform ? "rank" : "dims"] },\n          getShaderSource,\n          getRunData: () => ({\n            outputs: [{ dims: outputShape, dataType: inputs[0].dataType }],\n            dispatchGroup: { x: Math.ceil(\n              outputSize / 64\n              /* workgroup size */\n            ) },\n            programUniforms\n          })\n        };\n      };\n      expand = (context) => {\n        validateInputs11(context.inputs);\n        context.compute(createExpandProgramInfo(context.inputs), { inputs: [0] });\n      };\n    }\n  });\n\n  // web/lib/wasm/jsep/webgpu/ops/gather.ts\n  var validateInputs12, createGatherProgramInfo, parseGatherAttributes, gather;\n  var init_gather = __esm({\n    "web/lib/wasm/jsep/webgpu/ops/gather.ts"() {\n      "use strict";\n      init_wasm_common();\n      init_util();\n      init_attribute_with_cache_key();\n      init_common();\n      validateInputs12 = (inputs) => {\n        if (!inputs || inputs.length !== 2) {\n          throw new Error("Gather requires 2 inputs.");\n        }\n      };\n      createGatherProgramInfo = (inputs, attributes) => {\n        const inputShape = inputs[0].dims;\n        const indicesShape = inputs[1].dims;\n        const inputRank = inputShape.length;\n        const axis = ShapeUtil.normalizeAxis(attributes.axis, inputRank);\n        const outputShape = inputShape.slice(0);\n        outputShape.splice(axis, 1, ...indicesShape);\n        const axisDimLimit = inputShape[axis];\n        const components = inputs[0].dataType === 9 /* bool */ ? 4 : 1;\n        const outputSize = Math.ceil(ShapeUtil.size(outputShape) / components);\n        const enableInputShapesUniforms = enableShapesUniforms(inputs[0].dims.length);\n        const inputShapeOrRank = enableInputShapesUniforms ? inputs[0].dims.length : inputs[0].dims;\n        const enableIndicesShapesUniforms = enableShapesUniforms(inputs[1].dims.length);\n        const indicesShapeOrRank = enableIndicesShapesUniforms ? inputs[1].dims.length : inputs[1].dims;\n        const enableOutputShapesUniforms = enableShapesUniforms(outputShape.length);\n        const outputShapeOrRank = enableOutputShapesUniforms ? outputShape.length : outputShape;\n        const programUniforms = [{ type: "uint32", data: outputSize }, { type: "int32", data: axisDimLimit }, { type: "uint32", data: axis }];\n        if (enableInputShapesUniforms) {\n          programUniforms.push(...createTensorShapeVariables(inputs[0].dims));\n        }\n        if (enableIndicesShapesUniforms) {\n          programUniforms.push(...createTensorShapeVariables(inputs[1].dims));\n        }\n        if (enableOutputShapesUniforms) {\n          programUniforms.push(...createTensorShapeVariables(outputShape));\n        }\n        const inputDependencies = [];\n        inputDependencies.push(enableInputShapesUniforms ? "rank" : "dims");\n        inputDependencies.push(enableIndicesShapesUniforms ? "rank" : "dims");\n        const getShaderSource = (shaderHelper) => {\n          const data = inputVariable("data", inputs[0].dataType, inputShapeOrRank, components);\n          const indices = inputVariable("inputIndices", inputs[1].dataType, indicesShapeOrRank);\n          const output = outputVariable("output", inputs[0].dataType, outputShapeOrRank, components);\n          const calcDataIndices = (x) => {\n            const indicesRank = indicesShape.length;\n            let calcStr = `var indicesIndices${x}  = ${indices.type.indices}(0);`;\n            for (let i = 0; i < indicesRank; i++) {\n              calcStr += `${indicesRank > 1 ? `indicesIndices${x}[${i}]` : `indicesIndices${x}`} = ${outputShape.length > 1 ? `outputIndices${x}[uniforms.axis + ${i}]` : `outputIndices${x}`};`;\n            }\n            calcStr += `\n          var idx${x} = ${indices.getByIndices(`indicesIndices${x}`)};\n          if (idx${x} < 0) {\n            idx${x} = idx${x} + uniforms.axisDimLimit;\n          }\n          var dataIndices${x} = ${data.type.indices}(0);\n        `;\n            for (let i = 0, j = 0; i < inputRank; i++) {\n              if (i === axis) {\n                calcStr += `${inputRank > 1 ? `dataIndices${x}[${i}]` : `dataIndices${x}`} = u32(idx${x});`;\n                j += indicesRank;\n              } else {\n                calcStr += `${inputRank > 1 ? `dataIndices${x}[${i}]` : `dataIndices${x}`} = ${outputShape.length > 1 ? `outputIndices${x}[${j}]` : `outputIndices${x}`};`;\n                j++;\n              }\n            }\n            return calcStr;\n          };\n          let assignment;\n          if (inputs[0].dataType === 9 /* bool */) {\n            const singleAssignment = (resStr, x, typeCast = "") => `\n          let outputIndices${x} = ${output.offsetToIndices(`outputOffset + ${x}u`)};\n          ${calcDataIndices(x)};\n          let offset${x} = ${data.indicesToOffset(`dataIndices${x}`)};\n          let index${x} = offset${x} / 4u;\n          let component${x} = offset${x} % 4u;\n          ${resStr}[${x}] = ${typeCast}(${data.getByOffset(`index${x}`)}[component${x}]);\n        `;\n            assignment = `\n        let outputOffset = global_idx * ${components};\n        var value = vec4<u32>(0);\n        ${singleAssignment("value", 0, "u32")}\n        ${singleAssignment("value", 1, "u32")}\n        ${singleAssignment("value", 2, "u32")}\n        ${singleAssignment("value", 3, "u32")}\n        ${output.setByOffset("global_idx", "value")}\n      `;\n          } else {\n            assignment = `\n      let outputIndices = ${output.offsetToIndices("global_idx")};\n      ${calcDataIndices("")};\n      let value = ${data.getByIndices("dataIndices")};\n      ${output.setByOffset("global_idx", "value")};\n      `;\n          }\n          return `\n      ${shaderHelper.registerUniform("outputSize", "u32").registerUniform("axisDimLimit", "i32").registerUniform("axis", "u32").declareVariables(data, indices, output)}\n      ${shaderHelper.mainStart()}\n        ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n        ${assignment}\n      }`;\n        };\n        return {\n          name: "Gather",\n          shaderCache: { hint: attributes.cacheKey, inputDependencies },\n          getRunData: () => ({\n            outputs: [\n              { dims: outputShape, dataType: inputs[0].dataType }\n            ],\n            dispatchGroup: { x: Math.ceil(\n              outputSize / 64\n              /* workgroup size */\n            ) },\n            programUniforms\n          }),\n          getShaderSource\n        };\n      };\n      parseGatherAttributes = (attributes) => createAttributeWithCacheKey({ axis: attributes.axis });\n      gather = (context, attributes) => {\n        const inputs = context.inputs;\n        validateInputs12(inputs);\n        context.compute(createGatherProgramInfo(context.inputs, attributes));\n      };\n    }\n  });\n\n  // web/lib/wasm/jsep/webgpu/ops/gather-elements.ts\n  var validateInputs13, createGatherElementsProgramInfo, parseGatherElementsAttributes, gatherElements;\n  var init_gather_elements = __esm({\n    "web/lib/wasm/jsep/webgpu/ops/gather-elements.ts"() {\n      "use strict";\n      init_util();\n      init_attribute_with_cache_key();\n      init_common();\n      validateInputs13 = (inputs) => {\n        if (!inputs || inputs.length !== 2) {\n          throw new Error("GatherElements requires 2 inputs.");\n        }\n        if (inputs[0].dims.length < 1) {\n          throw new Error("GatherElements requires that the data input be rank >= 1.");\n        }\n        if (inputs[0].dims.length !== inputs[1].dims.length) {\n          throw new Error(`GatherElements requires that the data input and\n                     indices input tensors be of same rank.`);\n        }\n      };\n      createGatherElementsProgramInfo = (inputs, attributes) => {\n        const inputShape = inputs[0].dims;\n        const inputOutputDataType = inputs[0].dataType;\n        const inputRank = inputShape.length;\n        const indicesShape = inputs[1].dims;\n        const indicesDataType = inputs[1].dataType;\n        const axis = ShapeUtil.normalizeAxis(attributes.axis, inputRank);\n        const axisDimLimit = inputShape[axis];\n        const outputShape = indicesShape.slice(0);\n        const outputSize = ShapeUtil.size(outputShape);\n        const input = inputVariable("input", inputOutputDataType, inputRank);\n        const indices = inputVariable("indicesInput", indicesDataType, indicesShape.length);\n        const output = outputVariable("output", inputOutputDataType, outputShape.length);\n        const programUniforms = [{ type: "uint32", data: outputSize }, { type: "int32", data: axisDimLimit }, { type: "uint32", data: axis }];\n        programUniforms.push(...createTensorShapeVariables(inputShape));\n        programUniforms.push(...createTensorShapeVariables(indicesShape));\n        programUniforms.push(...createTensorShapeVariables(outputShape));\n        const inputDependencies = ["rank", "rank"];\n        const getShaderSource = (shaderHelper) => `\n      ${shaderHelper.registerUniform("outputSize", "u32").registerUniform("axisDimLimit", "i32").registerUniform("axis", "u32").declareVariables(input, indices, output)}\n      ${shaderHelper.mainStart()}\n      ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n\n      let outputIndices = ${output.offsetToIndices("global_idx")};\n\n      var idx = ${indices.getByOffset("global_idx")};\n      if (idx < 0) {\n        idx = idx + uniforms.axisDimLimit;\n      }\n      var inputIndices = ${input.type.indices}(outputIndices);\n      ${input.indicesSet("inputIndices", "uniforms.axis", "u32(idx)")};\n      let value = ${input.getByIndices("inputIndices")};\n\n      ${output.setByOffset("global_idx", "value")};\n  }`;\n        return {\n          name: "GatherElements",\n          shaderCache: { inputDependencies },\n          getRunData: () => ({\n            outputs: [{ dims: outputShape, dataType: inputs[0].dataType }],\n            dispatchGroup: { x: Math.ceil(\n              outputSize / 64\n              /* workgroup size */\n            ) },\n            programUniforms\n          }),\n          getShaderSource\n        };\n      };\n      parseGatherElementsAttributes = (attributes) => createAttributeWithCacheKey({ axis: attributes.axis });\n      gatherElements = (context, attributes) => {\n        const inputs = context.inputs;\n        validateInputs13(inputs);\n        context.compute(createGatherElementsProgramInfo(context.inputs, attributes));\n      };\n    }\n  });\n\n  // web/lib/wasm/jsep/webgpu/ops/gemm.ts\n  var validateInputs14, createGemmProgramInfo, parseGemmAttributes, gemm;\n  var init_gemm = __esm({\n    "web/lib/wasm/jsep/webgpu/ops/gemm.ts"() {\n      "use strict";\n      init_util();\n      init_common();\n      validateInputs14 = (inputs) => {\n        if (!inputs) {\n          throw new Error("Input is missing");\n        }\n        if (inputs.length < 2 || inputs.length > 3) {\n          throw new Error("Invaid input number.");\n        }\n        if (inputs.length === 3 && inputs[2].dims.length > 2) {\n          throw new Error("Invalid input shape of C");\n        }\n        if (inputs[0].dataType !== inputs[1].dataType || inputs.length === 3 && inputs[0].dataType !== inputs[2].dataType) {\n          throw new Error("Input types are mismatched");\n        }\n      };\n      createGemmProgramInfo = (inputs, attributes) => {\n        const aShape = inputs[0].dims.slice();\n        const bShape = inputs[1].dims.slice();\n        const [M, N, K] = GemmUtil.getShapeOfGemmResult(\n          aShape,\n          attributes.transA,\n          bShape,\n          attributes.transB,\n          inputs.length === 3 ? inputs[2].dims : void 0\n        );\n        const outputShape = [M, N];\n        if (!outputShape) {\n          throw new Error("Can\'t use gemm on the given tensors");\n        }\n        const outputSize = ShapeUtil.size(outputShape);\n        const programUniforms = [\n          { type: "uint32", data: outputSize },\n          { type: "uint32", data: M },\n          { type: "uint32", data: N },\n          { type: "uint32", data: K },\n          { type: "float32", data: attributes.alpha },\n          { type: "float32", data: attributes.beta }\n        ];\n        const inputDependencies = ["type", "type"];\n        if (inputs.length === 3) {\n          programUniforms.push(...createTensorShapeVariables(inputs[2].dims));\n          inputDependencies.push("rank");\n        }\n        programUniforms.push(...createTensorShapeVariables(outputShape));\n        const getShaderSource = (shaderHelper) => {\n          let line = "";\n          if (attributes.transA && attributes.transB) {\n            line = "value += a[k * uniforms.M + m] * b[n * uniforms.K + k];";\n          } else if (attributes.transA && !attributes.transB) {\n            line = "value += a[k * uniforms.M + m] * b[k * uniforms.N + n];";\n          } else if (!attributes.transA && attributes.transB) {\n            line = "value += a[m * uniforms.K + k] * b[n * uniforms.K + k];";\n          } else if (!attributes.transA && !attributes.transB) {\n            line = "value += a[m * uniforms.K + k] * b[k * uniforms.N + n];";\n          }\n          const calculateAlpha = attributes.alpha === 1 ? "" : "value *= uniforms.alpha;";\n          const a = inputVariable("a", inputs[0].dataType, inputs[0].dims);\n          const b = inputVariable("b", inputs[1].dataType, inputs[1].dims);\n          const dataType = a.type.value;\n          let c = null;\n          const variables = [a, b];\n          if (inputs.length === 3) {\n            c = inputVariable("c", inputs[2].dataType, inputs[2].dims.length);\n            variables.push(c);\n          }\n          const output = outputVariable("output", inputs[0].dataType, outputShape.length);\n          variables.push(output);\n          const uniforms = [\n            { name: "output_size", type: "u32" },\n            { name: "M", type: "u32" },\n            { name: "N", type: "u32" },\n            { name: "K", type: "u32" },\n            { name: "alpha", type: "f32" },\n            { name: "beta", type: "f32" }\n          ];\n          return `\n  ${shaderHelper.registerUniforms(uniforms).declareVariables(...variables)}\n\n  ${shaderHelper.mainStart()}\n    ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n\n    let m = global_idx / uniforms.N;\n    let n = global_idx % uniforms.N;\n\n    var value = ${dataType}(0);\n    for (var k: u32 = 0u; k < uniforms.K; k++) {\n      ${line}\n    }\n\n    ${calculateAlpha}\n    ${(() => {\n            if (c != null) {\n              return `let cOffset = ${c.broadcastedIndicesToOffset("vec2(m, n)", output)}; value += ${dataType}(uniforms.beta) * ${c.getByOffset("cOffset")};`;\n            }\n            return "";\n          })()}\n    output[global_idx] = value;\n  }`;\n        };\n        return {\n          name: "Gemm",\n          shaderCache: { hint: `${attributes.cacheKey}`, inputDependencies },\n          getRunData: () => ({\n            outputs: [{ dims: outputShape, dataType: inputs[0].dataType }],\n            dispatchGroup: { x: Math.ceil(\n              outputSize / 64\n              /* workgroup size */\n            ) },\n            programUniforms\n          }),\n          getShaderSource\n        };\n      };\n      parseGemmAttributes = (attributes) => {\n        const transA = attributes.transA;\n        const transB = attributes.transB;\n        const alpha = attributes.alpha;\n        const beta = attributes.beta;\n        return { transA, transB, alpha, beta, cacheKey: `${attributes.transA};${attributes.transB};${attributes.alpha === 1}` };\n      };\n      gemm = (context, attributes) => {\n        validateInputs14(context.inputs);\n        context.compute(createGemmProgramInfo(context.inputs, attributes));\n      };\n    }\n  });\n\n  // web/lib/wasm/jsep/webgpu/ops/instance-norm.ts\n  var createInstanceNormProgramInfo, computeMean, createInstanceNormNHWCProgramInfo, instanceNorm;\n  var init_instance_norm = __esm({\n    "web/lib/wasm/jsep/webgpu/ops/instance-norm.ts"() {\n      "use strict";\n      init_wasm_common();\n      init_util();\n      init_common();\n      createInstanceNormProgramInfo = (inputs, attributes) => {\n        const xShape = inputs[0].dims;\n        const outputShape = xShape;\n        const axis = 2;\n        const normCount = ShapeUtil.sizeToDimension(xShape, axis);\n        const normSize = ShapeUtil.sizeFromDimension(xShape, axis);\n        const components = getMaxComponents(normSize);\n        const normPackedSize = normSize / components;\n        const inputShape = [xShape[0], xShape[1], normPackedSize];\n        const inputDependencies = ["rank", "type", "type"];\n        const programUniforms = [{ type: "uint32", data: normSize }, { type: "uint32", data: normPackedSize }];\n        programUniforms.push(...createTensorShapeVariables(inputShape), ...createTensorShapeVariables(inputShape));\n        const getShaderSource = (shaderHelper) => {\n          const x = inputVariable("x", inputs[0].dataType, inputShape.length, components);\n          const scale = inputVariable("scale", inputs[1].dataType, inputs[1].dims);\n          const bias = inputVariable("bias", inputs[2].dataType, inputs[2].dims);\n          const output = outputVariable("output", inputs[0].dataType, inputShape.length, components);\n          const variables = [x, scale, bias, output];\n          const dataType = x.type.value;\n          const f32Type = components === 1 ? "f32" : `vec${components}<f32>`;\n          const workgroupSize = 64;\n          const uniforms = [{ name: "normSize", type: "u32" }, { name: "normPackedSize", type: "u32" }];\n          return `\n  var<workgroup> meanShared : f32;\n  var<workgroup> squaredNormShared : f32;\n  var<workgroup> workgroupShared : array<${f32Type}, ${workgroupSize}>;\n  const workgroupSize = ${workgroupSize}u;\n  ${shaderHelper.registerUniforms(uniforms).declareVariables(...variables)}\n  ${shaderHelper.mainStart(workgroupSize)}\n    let norm = global_idx / workgroupSize;\n    let batch = norm / uniforms.x_shape[1];\n    let channel = norm % uniforms.x_shape[1];\n    let localIndex = local_id.x;\n\n    // initialize workgroup memory\n    var initial = ${f32Type}(0);\n    for (var h = localIndex; h < uniforms.normPackedSize; h += workgroupSize) {\n      initial = initial + ${f32Type}(${x.get("batch", "channel", "h")});\n    }\n    workgroupShared[localIndex] = initial;\n    workgroupBarrier();\n\n    // Calculate the mean of current channel data.\n    for (var currSize = workgroupSize >> 1;  currSize > 0; currSize = currSize >> 1) {\n      if (localIndex < currSize) {\n        workgroupShared[localIndex] = workgroupShared[localIndex] + workgroupShared[localIndex + currSize];\n      }\n      workgroupBarrier();\n    }\n    if (localIndex == 0) {\n      meanShared = ${sumVector("workgroupShared[0]", components)} / f32(uniforms.normSize);\n    }\n    workgroupBarrier();\n\n    // reinitialize workgroup memory.\n    initial = ${f32Type}(0);\n    for (var h = localIndex; h < uniforms.normPackedSize; h += workgroupSize) {\n      let deviation =  ${f32Type}(${x.get("batch", "channel", "h")}) - ${f32Type}(meanShared);\n      initial = initial + deviation * deviation;\n    }\n    workgroupShared[localIndex] = initial;\n    workgroupBarrier();\n\n    // Calculate the sum of square of deviation of current channel data.\n    for (var currSize = workgroupSize >> 1;  currSize > 0; currSize = currSize >> 1) {\n      if (localIndex < currSize) {\n        workgroupShared[localIndex] = workgroupShared[localIndex] + workgroupShared[localIndex + currSize];\n      }\n      workgroupBarrier();\n    }\n    if (localIndex == 0) {\n      squaredNormShared = ${sumVector("workgroupShared[0]", components)};\n    }\n    workgroupBarrier();\n\n    let invStdDev = inverseSqrt(squaredNormShared / f32(uniforms.normSize) + f32(${attributes.epsilon}));\n    let channelScale = invStdDev * f32(${scale.getByOffset("channel")});\n    let channelShift = f32(${bias.getByOffset("channel")}) - meanShared * channelScale;\n    for (var h = localIndex; h < uniforms.normPackedSize; h += workgroupSize) {\n      let value = ${x.get("batch", "channel", "h")} * ${dataType}(${f32Type}(channelScale)) + ${dataType}(${f32Type}(channelShift));\n      ${output.set("batch", "channel", "h", "value")};\n    }\n  }`;\n        };\n        return {\n          ...{ name: "InstanceNormalization" },\n          // TODO: use epsilon as uniform. Currently epsilon as uniform fails test_instancenorm_epsilon.\n          shaderCache: { hint: `${attributes.epsilon};${components}`, inputDependencies },\n          getRunData: () => ({\n            outputs: [\n              { dims: outputShape, dataType: inputs[0].dataType }\n            ],\n            dispatchGroup: { x: normCount },\n            programUniforms\n          }),\n          getShaderSource\n        };\n      };\n      computeMean = (context, input, scale, bias, n, h, c, epsilon) => {\n        const components = getMaxComponents(c);\n        const WG = 64;\n        const outputType = components === 1 ? "vec2f" : `mat2x${components}f`;\n        const sumCastType = components === 1 ? "f32" : `vec${components}f`;\n        const setOutputValue = (var1, var2) => `${outputType}(${var1}, ${var2})`;\n        const unitsOfWork = n * c / components;\n        const wgSize = Math.ceil(h / WG);\n        const meanInputDependencies = ["type"];\n        const meanProgramUniforms = [\n          { type: "uint32", data: wgSize },\n          { type: "uint32", data: h },\n          { type: "uint32", data: Math.floor(c / components) },\n          { type: "uint32", data: Math.floor(h * c / components) }\n        ];\n        const getMeanShaderSource = (shaderHelper) => {\n          const inputHelper = inputVariable("input", input.dataType, input.dims, components);\n          return `\n  ${shaderHelper.declareVariables(inputHelper)}\n  @group(0) @binding(1) var<storage, read_write> output : array<${outputType}>;\n  struct Uniforms {wg_size:u32, H:u32, C:u32, image_size:u32};\n  @group(0) @binding(2) var<uniform> uniforms: Uniforms;\n\n  ${shaderHelper.mainStart(WG)}\n    let currentImageNumber = global_idx / ${WG} / uniforms.C;\n    let currentChannelNumber = (global_idx / ${WG}) % uniforms.C;\n    let wgId = global_idx % ${WG};\n    let wgOffset = wgId * uniforms.wg_size;\n    if (wgOffset >= uniforms.H) {\n        return;\n    }\n    let wgMax = min(wgOffset + uniforms.wg_size, uniforms.H);\n\n    let offset = currentImageNumber * uniforms.image_size + currentChannelNumber;\n    var sum = ${fillVector("f32", components)};\n    var squaredSum = ${fillVector("f32", components)};\n    for (var i: u32 = wgOffset; i < wgMax; i++) {\n        let value = ${sumCastType}(input[offset + i * uniforms.C]);\n        sum += value;\n        squaredSum += value * value;\n    }\n    output[global_idx] = ${setOutputValue("sum", "squaredSum")};\n  }`;\n        };\n        const meanValues = context.compute(\n          {\n            name: "InstanceNormComputeMean",\n            shaderCache: { hint: `${components}`, inputDependencies: meanInputDependencies },\n            getRunData: () => ({\n              outputs: [\n                { dims: [n, c, WG, 2], dataType: 1 /* float */ }\n              ],\n              dispatchGroup: { x: n * c / components },\n              programUniforms: meanProgramUniforms\n            }),\n            getShaderSource: getMeanShaderSource\n          },\n          { inputs: [input], outputs: [-1] }\n        )[0];\n        const programUniforms = [\n          { type: "uint32", data: unitsOfWork },\n          { type: "uint32", data: h },\n          { type: "uint32", data: Math.floor(c / components) },\n          { type: "uint32", data: Math.floor(WG * c / components) }\n        ];\n        const inputDependencies = ["type", "type", "type"];\n        const getShaderSource = (shaderHelper) => {\n          const scaleHelper = inputVariable("scale", scale.dataType, scale.dims, components);\n          const biasHelper = inputVariable("bias", bias.dataType, bias.dims, components);\n          return `\n  @group(0) @binding(0) var<storage, read> input : array<${outputType}>;\n  @group(0) @binding(1) var<storage, read> scale : array<${scaleHelper.type.storage}>;\n  @group(0) @binding(2) var<storage, read> bias : array<${biasHelper.type.storage}>;\n  @group(0) @binding(3) var<storage, read_write> output : array<${outputType}>;\n  struct Uniforms {units_of_work : u32, H: u32, C : u32, image_size : u32};\n  @group(0) @binding(4) var<uniform> uniforms: Uniforms;\n\n  ${shaderHelper.mainStart()}\n    ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.units_of_work")}\n    let currentImageNumber = global_idx / uniforms.C;\n    let currentChannelNumber = global_idx % uniforms.C;\n\n    let offset = currentImageNumber * uniforms.image_size;\n    var sum = ${fillVector("f32", components)};\n    var squaredSum = ${fillVector("f32", components)};\n    for (var i: u32 = 0; i < ${WG}; i++) {\n        let value = input[offset + i + currentChannelNumber * ${WG}];\n        sum += value[0];\n        squaredSum += value[1];\n    }\n    sum = sum / f32(uniforms.H);\n    squaredSum = squaredSum / f32(uniforms.H);\n    let invStdDev = inverseSqrt(squaredSum - sum * sum + f32(${epsilon}));\n    let channelScale = invStdDev * ${sumCastType}(scale[currentChannelNumber]);\n    let channelShift = ${sumCastType}(bias[currentChannelNumber]) - sum * channelScale;\n\n    output[global_idx] = ${setOutputValue("channelScale", "channelShift")};\n  }`;\n        };\n        return context.compute(\n          {\n            name: "InstanceNormComputeChannelScaleShift",\n            // TODO: use epsilon as uniform. Currently epsilon as uniform fails test_instancenorm_epsilon.\n            shaderCache: { hint: `${components};${epsilon}`, inputDependencies },\n            getRunData: () => ({\n              outputs: [\n                { dims: [n, c, 2], dataType: 1 /* float */ }\n              ],\n              dispatchGroup: { x: Math.ceil(\n                unitsOfWork / 64\n                /* workgroup size */\n              ) },\n              programUniforms\n            }),\n            getShaderSource\n          },\n          { inputs: [meanValues, scale, bias], outputs: [-1] }\n        )[0];\n      };\n      createInstanceNormNHWCProgramInfo = (context, inputs, attributes) => {\n        const xShape = inputs[0].dims;\n        const outputShape = xShape;\n        const N = xShape[0];\n        const C = xShape[xShape.length - 1];\n        const H = ShapeUtil.sizeFromDimension(xShape, 1) / C;\n        const components = getMaxComponents(C);\n        const outputSize = ShapeUtil.size(outputShape) / components;\n        const programUniforms = [{ type: "uint32", data: H }, { type: "uint32", data: Math.floor(C / components) }];\n        const inputDependencies = ["type", "type"];\n        const channelScaleShift = computeMean(context, inputs[0], inputs[1], inputs[2], N, H, C, attributes.epsilon);\n        const getShaderSource = (shaderHelper) => {\n          const dataType = tensorTypeToWsglStorageType(inputs[0].dataType);\n          const scaleType = components === 1 ? "vec2f" : `mat2x${components}f`;\n          const scaleCastType = components === 1 ? dataType : `vec${components}<${dataType}>`;\n          const inputHelper = inputVariable("input", inputs[0].dataType, inputs[0].dims, components);\n          const outputHelper = outputVariable("output", inputs[0].dataType, outputShape, components);\n          return `\n  @group(0) @binding(0) var<storage, read> input : array<${inputHelper.type.storage}>;\n  @group(0) @binding(1) var<storage, read> scaleInput : array<${scaleType}>;\n  @group(0) @binding(2) var<storage, read_write> output : array<${outputHelper.type.storage}>;\n  struct Uniforms {H: u32, C : u32};\n  @group(0) @binding(3) var<uniform> uniforms: Uniforms;\n\n  ${shaderHelper.mainStart()}\n    let currentImageNumber = global_idx / (uniforms.C * uniforms.H);\n    let currentChannelNumber = global_idx % uniforms.C;\n\n    let scaleOffset = currentImageNumber * uniforms.C + currentChannelNumber;\n    let scale = scaleInput[scaleOffset];\n    output[global_idx] = fma(input[global_idx], ${scaleCastType}(scale[0]), ${scaleCastType}(scale[1]));\n  }`;\n        };\n        context.compute(\n          {\n            name: "InstanceNormalizationNHWC",\n            shaderCache: { hint: `${components}`, inputDependencies },\n            getRunData: () => ({\n              outputs: [{ dims: outputShape, dataType: inputs[0].dataType }],\n              dispatchGroup: { x: Math.ceil(\n                outputSize / 64\n                /* workgroup size */\n              ) },\n              programUniforms\n            }),\n            getShaderSource\n          },\n          { inputs: [inputs[0], channelScaleShift] }\n        );\n      };\n      instanceNorm = (context, attributes) => {\n        if (attributes.format === "NHWC") {\n          createInstanceNormNHWCProgramInfo(context, context.inputs, attributes);\n        } else {\n          context.compute(createInstanceNormProgramInfo(context.inputs, attributes));\n        }\n      };\n    }\n  });\n\n  // web/lib/wasm/jsep/webgpu/ops/layer-norm.ts\n  var validateInputs15, createLayerNormProgramInfo, layerNorm;\n  var init_layer_norm = __esm({\n    "web/lib/wasm/jsep/webgpu/ops/layer-norm.ts"() {\n      "use strict";\n      init_wasm_common();\n      init_util();\n      init_common();\n      validateInputs15 = (inputs) => {\n        if (!inputs || inputs.length < 2) {\n          throw new Error("layerNorm requires at least 2 inputs.");\n        }\n      };\n      createLayerNormProgramInfo = (inputs, attributes, outputCount) => {\n        const xShape = inputs[0].dims;\n        const scale = inputs[1];\n        const bias = inputs[2];\n        const outputShape = xShape;\n        const axis = ShapeUtil.normalizeAxis(attributes.axis, xShape.length);\n        const normCount = ShapeUtil.sizeToDimension(xShape, axis);\n        const normSize = ShapeUtil.sizeFromDimension(xShape, axis);\n        const scaleSize = ShapeUtil.size(scale.dims);\n        const biasSize = bias ? ShapeUtil.size(bias.dims) : 0;\n        if (scaleSize !== normSize || bias && biasSize !== normSize) {\n          throw new Error(`Size of X.shape()[axis:] == ${normSize}.\n       Size of scale and bias (if provided) must match this.\n       Got scale size of ${scaleSize} and bias size of ${biasSize}`);\n        }\n        const meanInvStdDevDim = [];\n        for (let i = 0; i < xShape.length; ++i) {\n          if (i < axis) {\n            meanInvStdDevDim.push(xShape[i]);\n          } else {\n            meanInvStdDevDim.push(1);\n          }\n        }\n        const components = getMaxComponents(normSize);\n        const inputDependencies = ["type", "type"];\n        const programUniforms = [\n          { type: "uint32", data: normCount },\n          { type: "float32", data: normSize },\n          { type: "uint32", data: Math.floor(normSize / components) },\n          { type: "float32", data: attributes.epsilon }\n        ];\n        if (bias) {\n          inputDependencies.push("type");\n        }\n        const hasMeanDataOutput = outputCount > 1;\n        const hasInvStdOutput = outputCount > 2;\n        const getShaderSource = (shaderHelper) => {\n          const dataType = tensorTypeToWsglStorageType(inputs[0].dataType);\n          const variables = [\n            inputVariable("x", inputs[0].dataType, inputs[0].dims, components),\n            inputVariable("scale", scale.dataType, scale.dims, components)\n          ];\n          if (bias) {\n            variables.push(inputVariable("bias", bias.dataType, bias.dims, components));\n          }\n          variables.push(outputVariable("output", inputs[0].dataType, outputShape, components));\n          if (hasMeanDataOutput) {\n            variables.push(outputVariable("mean_data_output", 1 /* float */, meanInvStdDevDim));\n          }\n          if (hasInvStdOutput) {\n            variables.push(outputVariable("inv_std_output", 1 /* float */, meanInvStdDevDim));\n          }\n          const uniforms = [\n            { name: "norm_count", type: "u32" },\n            { name: "norm_size", type: "f32" },\n            { name: "norm_size_vectorized", type: "u32" },\n            { name: "epsilon", type: "f32" }\n          ];\n          return `\n  ${shaderHelper.registerUniforms(uniforms).declareVariables(...variables)}\n  ${shaderHelper.mainStart()}\n    ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.norm_count")}\n    let offset = global_idx * uniforms.norm_size_vectorized;\n    var meanVector = ${fillVector("f32", components)};\n    var meanSquareVector = ${fillVector("f32", components)};\n\n    for (var h: u32 = 0u; h < uniforms.norm_size_vectorized; h++) {\n      let value = ${castToF32(dataType, components, "x[h + offset]")};\n      meanVector += value;\n      meanSquareVector += value * value;\n    }\n    let mean = ${sumVector("meanVector", components)} / uniforms.norm_size;\n    let invStdDev =\n        inverseSqrt(${sumVector("meanSquareVector", components)} / uniforms.norm_size - mean * mean + uniforms.epsilon);\n\n    for (var j: u32 = 0; j < uniforms.norm_size_vectorized; j++) {\n      let f32input = ${castToF32(dataType, components, "x[j + offset]")};\n      let f32scale = ${castToF32(dataType, components, "scale[j]")};\n      output[j + offset] = ${variables[0].type.value}((f32input - mean) * invStdDev * f32scale\n        ${bias ? `+ ${castToF32(dataType, components, "bias[j]")}` : ""}\n      );\n    }\n\n    ${hasMeanDataOutput ? "mean_data_output[global_idx] = mean" : ""};\n    ${hasInvStdOutput ? "inv_std_output[global_idx] = invStdDev" : ""};\n  }`;\n        };\n        const outputs = [{ dims: outputShape, dataType: inputs[0].dataType }];\n        if (hasMeanDataOutput) {\n          outputs.push({ dims: meanInvStdDevDim, dataType: 1 /* float */ });\n        }\n        if (hasInvStdOutput) {\n          outputs.push({ dims: meanInvStdDevDim, dataType: 1 /* float */ });\n        }\n        return {\n          name: "LayerNormalization",\n          shaderCache: { hint: `${components};${outputCount}`, inputDependencies },\n          getRunData: () => ({ outputs, dispatchGroup: { x: Math.ceil(\n            normCount / 64\n            /* workgroup size */\n          ) }, programUniforms }),\n          getShaderSource\n        };\n      };\n      layerNorm = (context, attributes) => {\n        validateInputs15(context.inputs);\n        context.compute(createLayerNormProgramInfo(context.inputs, attributes, context.outputCount));\n      };\n    }\n  });\n\n  // web/lib/wasm/jsep/webgpu/ops/multi-head-attentiion.ts\n  var validateInputs16, parseMultiHeadAttentionAttributes, weightTransposeAttribute2, addBiasTranspose, maybeTransposeToBNSHAndAddBias, multiHeadAttention;\n  var init_multi_head_attentiion = __esm({\n    "web/lib/wasm/jsep/webgpu/ops/multi-head-attentiion.ts"() {\n      "use strict";\n      init_util();\n      init_attribute_with_cache_key();\n      init_types();\n      init_attention();\n      init_common();\n      init_transpose();\n      validateInputs16 = (inputs, attributes) => {\n        const query = inputs[0];\n        const key = inputs[1];\n        const value = inputs[2];\n        const bias = inputs[3];\n        const keyPaddingMask = inputs[4];\n        const relativePositionBias = inputs[5];\n        const pastKey = inputs[6];\n        const pastValue = inputs[7];\n        if (query.dims.length !== 3 && query.dims.length !== 5) {\n          throw new Error("Input query is expected to have 3 or 5 dimensions");\n        }\n        const dmmhaPacking = false;\n        const batchSize = query.dims[0];\n        const sequenceLength = query.dims[1];\n        const hiddenSize = query.dims.length === 3 ? dmmhaPacking ? query.dims[2] / 3 : query.dims[2] : attributes.numHeads * query.dims[4];\n        let kvSequenceLength = sequenceLength;\n        let pastSequenceLength = 0;\n        let maxSequenceLength = 0;\n        const headSize = Math.floor(hiddenSize / attributes.numHeads);\n        if (pastKey && pastValue) {\n          if (pastKey.dims.length !== 4) {\n            throw new Error(\'Input "past_key" is expected to have 4 dimensions\');\n          }\n          if (pastValue.dims.length !== 4) {\n            throw new Error(\'Input "past_value" is expected to have 4 dimensions\');\n          }\n          pastSequenceLength = pastKey.dims[2];\n          maxSequenceLength = pastKey.dims[2];\n        } else if (pastKey || pastValue) {\n          throw new Error(\'Input "past_key" and "past_value" shall be both present or both absent\');\n        }\n        let qkvFormat;\n        if (key) {\n          if (query.dims.length !== 3) {\n            throw new Error(\'Input "query" is expected to have 3 dimensions when key is given\');\n          }\n          if (key.dims.length < 3 || key.dims.length > 5) {\n            throw new Error(\'Input "key" is expected to have 3, 4, or 5 dimensions\');\n          }\n          if (query.dims[0] !== key.dims[0]) {\n            throw new Error(\'Input "query" and "key" shall have same dim 0 (batch size)\');\n          }\n          if (key.dims.length === 3) {\n            if (key.dims[2] !== query.dims[2]) {\n              throw new Error(\'Input "query" and "key" shall have same dim 2 (hidden_size)\');\n            }\n            qkvFormat = 2 /* qkvBSNH */;\n            kvSequenceLength = key.dims[1];\n          } else if (key.dims.length === 5) {\n            if (key.dims[2] !== attributes.numHeads || key.dims[3] !== 2 || key.dims[4] !== headSize) {\n              throw new Error(\'Expect "key" shape (batch_size, kv_sequence_length, num_heads, 2, head_size) for packed kv\');\n            }\n            if (value) {\n              throw new Error(\'Expect "value" be none when "key" has packed kv format.\');\n            }\n            qkvFormat = 5 /* qKvBSNHxBSN2H */;\n            kvSequenceLength = key.dims[1];\n          } else {\n            if (key.dims[1] !== attributes.numHeads || key.dims[3] !== headSize) {\n              throw new Error(\'Expect "key" shape (batch_size, num_heads, kv_sequence_length, head_size) for past_key\');\n            }\n            qkvFormat = 0 /* unknown */;\n            kvSequenceLength = key.dims[2];\n          }\n        } else {\n          if (query.dims.length !== 3 && query.dims.length !== 5) {\n            throw new Error(\'Input "query" is expected to have 3 or 5 dimensions when key is empty\');\n          }\n          if (query.dims.length === 5 && (query.dims[2] !== attributes.numHeads || query.dims[3] !== 3)) {\n            throw new Error(\'Expect "query" shape (batch_size, kv_sequence_length, num_heads, 3, head_size) for packed kv\');\n          }\n          qkvFormat = 3 /* qkvBSN3H */;\n        }\n        if (bias) {\n          if (bias.dims.length !== 1) {\n            throw new Error(\'Input "bias" is expected to have 1 dimension\');\n          }\n          if (value) {\n            if (query.dims.length === 5 && query.dims[3] === 2) {\n              throw new Error("bias is not allowed for packed kv.");\n            }\n          }\n        }\n        let maskType = 0 /* none */;\n        if (keyPaddingMask) {\n          maskType = 8 /* maskUnknown */;\n          const maskDims = keyPaddingMask.dims;\n          if (maskDims.length === 1) {\n            if (maskDims[0] === batchSize) {\n              maskType = 1 /* mask1dKeySeqLen */;\n            } else if (maskDims[0] === 3 * batchSize + 2) {\n              maskType = 3 /* mask1DKeySeqLenStart */;\n            }\n          } else if (maskDims.length === 2 && maskDims[0] === batchSize && maskDims[1] === kvSequenceLength) {\n            maskType = 5 /* mask2dKeyPadding */;\n          }\n          if (maskType === 8 /* maskUnknown */) {\n            throw new Error(\'Input "key_padding_mask" shape shall be (batch_size) or (batch_size, kv_sequence_length)\');\n          }\n          throw new Error("Mask not supported");\n        }\n        let passPastInKv = false;\n        let vHiddenSize = hiddenSize;\n        if (value) {\n          if (value.dims.length !== 3 && value.dims.length !== 4) {\n            throw new Error(\'Input "value" is expected to have 3 or 4 dimensions\');\n          }\n          if (query.dims[0] !== value.dims[0]) {\n            throw new Error(\'Input "query" and "value" shall have same dim 0 (batch_size)\');\n          }\n          if (value.dims.length === 3) {\n            if (kvSequenceLength !== value.dims[1]) {\n              throw new Error(\'Input "key" and "value" shall have the same dim 1 (kv_sequence_length)\');\n            }\n            vHiddenSize = value.dims[2];\n          } else {\n            if (kvSequenceLength !== value.dims[2]) {\n              throw new Error(\'Input "past_key" and "past_value" shall have the same dim 2 (kv_sequence_length)\');\n            }\n            vHiddenSize = value.dims[1] * value.dims[3];\n            passPastInKv = true;\n          }\n        }\n        const totalSequenceLength = pastSequenceLength + kvSequenceLength;\n        const broadcastResPosBias = false;\n        if (keyPaddingMask) {\n          throw new Error("Key padding mask is not supported");\n        }\n        if (relativePositionBias) {\n          throw new Error("extraAddQk is not supported");\n        }\n        if (pastKey) {\n          throw new Error("pastKey is not supported");\n        }\n        if (pastValue) {\n          throw new Error("pastValue is not supported");\n        }\n        return {\n          batchSize,\n          sequenceLength,\n          pastSequenceLength,\n          kvSequenceLength,\n          totalSequenceLength,\n          maxSequenceLength,\n          inputHiddenSize: 0,\n          hiddenSize,\n          vHiddenSize,\n          headSize,\n          vHeadSize: Math.floor(vHiddenSize / attributes.numHeads),\n          numHeads: attributes.numHeads,\n          isUnidirectional: false,\n          pastPresentShareBuffer: false,\n          maskFilterValue: attributes.maskFilterValue,\n          maskType,\n          scale: attributes.scale,\n          broadcastResPosBias,\n          passPastInKv,\n          qkvFormat\n        };\n      };\n      parseMultiHeadAttentionAttributes = (attributes) => createAttributeWithCacheKey({ ...attributes });\n      weightTransposeAttribute2 = createAttributeWithCacheKey({ perm: [0, 2, 1, 3] });\n      addBiasTranspose = (context, qkv, bias, batchSize, sequenceLength, hiddenSize, biasOffset) => {\n        const outputShape = [batchSize, sequenceLength, hiddenSize];\n        const outputSize = ShapeUtil.size(outputShape);\n        const programUniforms = [{ type: "uint32", data: outputSize }, { type: "uint32", data: biasOffset }, { type: "uint32", data: hiddenSize }];\n        const getShaderSource = (shaderHelper) => {\n          const output = outputVariable("qkv_with_bias", qkv.dataType, outputShape);\n          const qkvInput = inputVariable("qkv", qkv.dataType, outputShape);\n          const biasInput = inputVariable("bias", bias.dataType, outputShape);\n          const uniforms = [\n            { name: "output_size", type: "u32" },\n            { name: "bias_offset", type: "u32" },\n            { name: "hidden_size", type: "u32" }\n          ];\n          return `\n  ${shaderHelper.registerUniforms(uniforms).declareVariables(qkvInput, biasInput, output)}\n  ${shaderHelper.mainStart()}\n    ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n    let bias_offset_idx = (global_idx % uniforms.hidden_size) + uniforms.bias_offset;\n\n    qkv_with_bias[global_idx] = qkv[global_idx] + bias[bias_offset_idx];\n  }`;\n        };\n        return context.compute(\n          {\n            name: "MultiHeadAttentionAddBias",\n            shaderCache: { inputDependencies: ["type", "type"] },\n            getRunData: () => ({\n              outputs: [{ dims: outputShape, dataType: qkv.dataType, gpuDataType: 0 /* default */ }],\n              dispatchGroup: { x: Math.ceil(\n                outputSize / 64\n                /* workgroup size */\n              ) },\n              programUniforms\n            }),\n            getShaderSource\n          },\n          { inputs: [qkv, bias], outputs: [-1] }\n        )[0];\n      };\n      maybeTransposeToBNSHAndAddBias = (context, batchSize, numHeads, sequenceLength, headSize, input, bias, biasOffset) => {\n        let reshapedInput = input;\n        if (!bias) {\n          if (input.dims.length === 3) {\n            reshapedInput = input.reshape([batchSize, sequenceLength, numHeads, headSize]);\n          }\n          return context.compute(\n            createTransposeProgramInfo(reshapedInput, weightTransposeAttribute2.perm),\n            { inputs: [reshapedInput], outputs: [-1] }\n          )[0];\n        } else {\n          if (sequenceLength === 1) {\n            throw new Error("AddBiasReshape is not implemented. Please export your model with packed QKV or KV");\n          } else {\n            reshapedInput = addBiasTranspose(context, input, bias, batchSize, sequenceLength, numHeads * headSize, biasOffset);\n            reshapedInput = reshapedInput.reshape([batchSize, sequenceLength, numHeads, headSize]);\n            return context.compute(\n              createTransposeProgramInfo(reshapedInput, weightTransposeAttribute2.perm),\n              { inputs: [reshapedInput], outputs: [-1] }\n            )[0];\n          }\n        }\n      };\n      multiHeadAttention = (context, attributes) => {\n        const params = validateInputs16(context.inputs, attributes);\n        if (context.inputs[0].dims.length === 5) {\n          throw new Error("Packed QKV is not implemented");\n        }\n        if (context.inputs[1]?.dims.length === 5) {\n          throw new Error("Packed KV is not implemented");\n        }\n        const kvBNSH = context.inputs[1] && context.inputs[2] && context.inputs[1].dims.length === 4 && context.inputs[2].dims.length === 4;\n        const Q = maybeTransposeToBNSHAndAddBias(\n          context,\n          params.batchSize,\n          params.numHeads,\n          params.sequenceLength,\n          params.headSize,\n          context.inputs[0],\n          context.inputs[3],\n          0\n        );\n        if (kvBNSH) {\n          return applyAttention(\n            context,\n            Q,\n            context.inputs[1],\n            context.inputs[2],\n            context.inputs[4],\n            void 0,\n            void 0,\n            void 0,\n            context.inputs[5],\n            params,\n            attributes\n          );\n        }\n        const K = maybeTransposeToBNSHAndAddBias(\n          context,\n          params.batchSize,\n          params.numHeads,\n          params.kvSequenceLength,\n          params.headSize,\n          context.inputs[1],\n          context.inputs[3],\n          params.hiddenSize\n        );\n        const V = maybeTransposeToBNSHAndAddBias(\n          context,\n          params.batchSize,\n          params.numHeads,\n          params.kvSequenceLength,\n          params.vHeadSize,\n          context.inputs[2],\n          context.inputs[3],\n          2 * params.hiddenSize\n        );\n        applyAttention(\n          context,\n          Q,\n          K,\n          V,\n          context.inputs[4],\n          void 0,\n          context.inputs[6],\n          context.inputs[7],\n          context.inputs[5],\n          params,\n          attributes\n        );\n      };\n    }\n  });\n\n  // web/lib/wasm/jsep/webgpu/ops/pad.ts\n  var validateInputs17, getPadConstant, getPadReflect, getPadEdge, getPadWrap, getPadSnippet, createPadProgramInfo, createPadAttributesFromInputs, pad;\n  var init_pad = __esm({\n    "web/lib/wasm/jsep/webgpu/ops/pad.ts"() {\n      "use strict";\n      init_wasm_common();\n      init_util();\n      init_common();\n      validateInputs17 = (inputs) => {\n        if (!inputs || inputs.length < 1) {\n          throw new Error("Too few inputs");\n        }\n        if (inputs[0].dataType !== 1 /* float */) {\n          throw new Error("Input type must be float.");\n        }\n        if (inputs.length >= 2) {\n          let validPads = inputs[0].dims.length * 2 === inputs[1].dims[0];\n          if (inputs.length === 4) {\n            validPads = inputs[3].dims[0] * 2 === inputs[1].dims[0];\n          }\n          if (!validPads) {\n            throw new Error("The pads should be a 1D tensor of shape [2 * input_rank] or [2 * num_axes].");\n          }\n        }\n      };\n      getPadConstant = (output, inputRank, padsLength) => {\n        let block = "";\n        for (let i = inputRank - 1; i >= 0; --i) {\n          block += `\n            k = i32(${output.indicesGet("indices", i)}) - ${getElementAt("uniforms.pads", i, padsLength)};\n            if (k < 0) {\n              break;\n            }\n            if (k >= i32(${getElementAt("uniforms.x_shape", i, inputRank)})) {\n              break;\n            }\n            offset += k * i32(${getElementAt("uniforms.x_strides", i, inputRank)});\n        `;\n        }\n        return `\n          value = ${output.type.value}(uniforms.constant_value);\n          for (var i = 0; i < 1; i++) {\n            var offset = 0;\n            var k = 0;\n            ${block}\n            value = x[offset];\n          }\n      `;\n      };\n      getPadReflect = (output, inputRank, padsLength) => {\n        let block = "";\n        for (let i = inputRank - 1; i >= 0; --i) {\n          block += `\n                k = i32(${output.indicesGet("indices", i)}) - ${getElementAt("uniforms.pads", i, padsLength)};\n                if (k < 0) {\n                  k = -k;\n                }\n                {\n                  let _2n_1 = 2 * (i32(${getElementAt("uniforms.x_shape", i, inputRank)}) - 1);\n                  k = k % _2n_1;\n                  if(k >= i32(${getElementAt("uniforms.x_shape", i, inputRank)})) {\n                    k = _2n_1 - k;\n                  }\n                }\n                offset += k * i32(${getElementAt("uniforms.x_strides", i, inputRank)});\n            `;\n        }\n        return `\n              var offset = 0;\n              var k = 0;\n              ${block}\n              value = x[offset];\n          `;\n      };\n      getPadEdge = (output, inputRank, padsLength) => {\n        let block = "";\n        for (let i = inputRank - 1; i >= 0; --i) {\n          block += `\n                k = i32(${output.indicesGet("indices", i)}) - ${getElementAt("uniforms.pads", i, padsLength)};\n                if (k < 0) {\n                  k = 0;\n                }\n                if (k >= i32(${getElementAt("uniforms.x_shape", i, inputRank)})) {\n                  k = i32(${getElementAt("uniforms.x_shape", i, inputRank)}) - 1;\n                }\n                offset += k * i32(${getElementAt("uniforms.x_strides", i, inputRank)});\n            `;\n        }\n        return `\n              var offset = 0;\n              var k = 0;\n              ${block}\n              value = x[offset];\n          `;\n      };\n      getPadWrap = (output, inputRank, padsLength) => {\n        let block = "";\n        for (let i = inputRank - 1; i >= 0; --i) {\n          block += `\n                k = i32(${output.indicesGet("indices", i)}) - ${getElementAt("uniforms.pads", i, padsLength)};\n                if (k < 0)  {\n                  k += i32(${getElementAt("uniforms.x_shape", i, inputRank)}]);\n                }\n                if (k >= i32(${getElementAt("uniforms.x_shape", i, inputRank)})) {\n                  k -= i32(${getElementAt("uniforms.x_shape", i, inputRank)});\n                }\n                offset += k * i32(${getElementAt("uniforms.x_strides", i, inputRank)});\n            `;\n        }\n        return `\n              var offset = 0;\n              var k = 0;\n              ${block}\n              value = x[offset];\n          `;\n      };\n      getPadSnippet = (output, inputRank, attributes) => {\n        switch (attributes.mode) {\n          case 0:\n            return getPadConstant(output, inputRank, attributes.pads.length);\n          case 1:\n            return getPadReflect(output, inputRank, attributes.pads.length);\n          case 2:\n            return getPadEdge(output, inputRank, attributes.pads.length);\n          case 3:\n            return getPadWrap(output, inputRank, attributes.pads.length);\n          default:\n            throw new Error("Invalid mode");\n        }\n      };\n      createPadProgramInfo = (inputs, attributes) => {\n        const outputShape = ShapeUtil.padShape(inputs[0].dims.slice(), attributes.pads);\n        const inputDims = inputs[0].dims;\n        const outputSize = ShapeUtil.size(outputShape);\n        const programUniforms = [{ type: "uint32", data: outputSize }, { type: "uint32", data: attributes.pads }];\n        if (attributes.mode === 0) {\n          const tensorDataType = tensorDataTypeEnumToString(inputs[0].dataType);\n          programUniforms.push({ type: tensorDataType, data: attributes.value });\n        }\n        programUniforms.push(...createTensorShapeVariables(inputs[0].dims), ...createTensorShapeVariables(outputShape));\n        const inputDependencies = ["rank"];\n        const getShaderSource = (shaderHelper) => {\n          const output = outputVariable("output", inputs[0].dataType, outputShape.length);\n          const input = inputVariable("x", inputs[0].dataType, inputDims.length);\n          const dataType = input.type.value;\n          const padSnippet = getPadSnippet(output, inputDims.length, attributes);\n          const uniforms = [{ name: "output_size", type: "u32" }, { name: "pads", type: "i32", length: attributes.pads.length }];\n          if (attributes.mode === 0) {\n            uniforms.push({ name: "constant_value", type: dataType });\n          }\n          return `\n            ${shaderHelper.registerUniforms(uniforms).declareVariables(input, output)}\n            ${shaderHelper.mainStart()}\n            ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n\n            let indices = ${output.offsetToIndices("global_idx")};\n\n            var value = ${dataType}(0);\n            ${padSnippet}\n            output[global_idx] = value;\n        }`;\n        };\n        return {\n          name: "Pad",\n          shaderCache: { hint: `${attributes.mode}`, inputDependencies },\n          getRunData: () => ({\n            outputs: [{ dims: outputShape, dataType: inputs[0].dataType }],\n            dispatchGroup: { x: Math.ceil(\n              ShapeUtil.size(outputShape) / 64\n              /* workgroup size */\n            ) },\n            programUniforms\n          }),\n          getShaderSource\n        };\n      };\n      createPadAttributesFromInputs = (inputs, attributes) => {\n        if (inputs.length > 1) {\n          const bigInt64Pads = inputs[1].getBigInt64Array();\n          const value = inputs.length >= 3 && inputs[2].data ? inputs[2].getFloat32Array()[0] : 0;\n          const inputRank = inputs[0].dims.length;\n          const updatePads = new Int32Array(2 * inputRank).fill(0);\n          if (inputs.length >= 4) {\n            const axes = inputs[3].getBigInt64Array();\n            for (let i = 0; i < axes.length; i++) {\n              updatePads[Number(axes[i])] = Number(bigInt64Pads[i]);\n              updatePads[Number(axes[i]) + inputRank] = Number(bigInt64Pads[i + axes.length]);\n            }\n          } else {\n            bigInt64Pads.forEach((v, i) => updatePads[Number(i)] = Number(v));\n          }\n          const pads = [];\n          updatePads.forEach((v) => pads.push(v));\n          return { mode: attributes.mode, value, pads };\n        } else {\n          return attributes;\n        }\n      };\n      pad = (context, attributes) => {\n        validateInputs17(context.inputs);\n        const updatedAttributes = createPadAttributesFromInputs(context.inputs, attributes);\n        context.compute(createPadProgramInfo(context.inputs, updatedAttributes), { inputs: [0] });\n      };\n    }\n  });\n\n  // web/lib/wasm/jsep/webgpu/ops/pool.ts\n  var validateInputs18, getAdjustedPoolAttributesAndOutputShape, getUniformAndPadInfo, generatePoolingCode, createShaderKeyFromAttributes, createAveragePoolShaderKeyFromAttributes, createMaxPoolShaderKeyFromAttributes, parsePoolCommonAttributes, createAveragePoolProgramInfo, parseAveragePoolAttributes, averagePool, globalPoolAttributes, parseGlobalAveragePoolAttributes, globalAveragePool, createMaxPoolProgramInfo, maxPool, parseMaxPoolAttributes, parseGlobalMaxPoolAttributes, globalMaxPool;\n  var init_pool = __esm({\n    "web/lib/wasm/jsep/webgpu/ops/pool.ts"() {\n      "use strict";\n      init_esm();\n      init_util();\n      init_common();\n      validateInputs18 = (inputs) => {\n        if (env2.webgpu.validateInputContent && (!inputs || inputs.length !== 1)) {\n          throw new Error("Pool ops requires 1 input.");\n        }\n      };\n      getAdjustedPoolAttributesAndOutputShape = (input, attributes, isGlobalOperator) => {\n        const isChannelsLast = attributes.format === "NHWC";\n        const inputShapeAsChannelFirst = input.dims.slice();\n        if (isChannelsLast) {\n          inputShapeAsChannelFirst.splice(1, 0, inputShapeAsChannelFirst.pop());\n        }\n        const hasDilations = Object.hasOwnProperty.call(attributes, "dilations");\n        const kernelShape = attributes.kernelShape.slice();\n        const strides = attributes.strides.slice();\n        const dilations = hasDilations ? attributes.dilations.slice() : [];\n        const pads = attributes.pads.slice();\n        PoolConvUtil.adjustPoolAttributes(isGlobalOperator, inputShapeAsChannelFirst, kernelShape, strides, dilations, pads);\n        const outputShapeAsChannelFirst = PoolConvUtil.computePoolOutputShape(\n          isGlobalOperator,\n          inputShapeAsChannelFirst,\n          strides,\n          dilations,\n          kernelShape,\n          pads,\n          attributes.autoPad\n        );\n        const newAttributes = Object.assign({}, attributes);\n        if (hasDilations) {\n          Object.assign(newAttributes, { kernelShape, strides, pads, dilations, cacheKey: attributes.cacheKey });\n        } else {\n          Object.assign(newAttributes, { kernelShape, strides, pads, cacheKey: attributes.cacheKey });\n        }\n        const outputShapeAsChannelLast = outputShapeAsChannelFirst.slice();\n        outputShapeAsChannelLast.push(outputShapeAsChannelLast.splice(1, 1)[0]);\n        return [newAttributes, isChannelsLast ? outputShapeAsChannelLast : outputShapeAsChannelFirst];\n      };\n      getUniformAndPadInfo = (outputShape, attributes) => {\n        const isChannelsLast = attributes.format === "NHWC";\n        const outputSize = ShapeUtil.size(outputShape);\n        const kernelSize = ShapeUtil.size(attributes.kernelShape);\n        const programUniforms = [{ type: "uint32", data: outputSize }, { type: "uint32", data: kernelSize }];\n        const uniforms = [{ name: "outputSize", type: "u32" }, { name: "kernelSize", type: "u32" }];\n        if (attributes.kernelShape.length <= 2) {\n          const kw = attributes.kernelShape[attributes.kernelShape.length - 1];\n          const sw = attributes.strides[attributes.strides.length - 1];\n          const pwStart = attributes.pads[attributes.pads.length / 2 - 1];\n          const pwEnd = attributes.pads[attributes.pads.length - 1];\n          const pwStartEndNotZero = !!(pwStart + pwEnd);\n          programUniforms.push(\n            { type: "uint32", data: kw },\n            { type: "uint32", data: sw },\n            { type: "uint32", data: pwStart },\n            { type: "uint32", data: pwEnd }\n          );\n          uniforms.push(\n            { name: "kw", type: "u32" },\n            { name: "sw", type: "u32" },\n            { name: "pwStart", type: "u32" },\n            { name: "pwEnd", type: "u32" }\n          );\n          let phStartEndNotZero = false;\n          if (attributes.kernelShape.length === 2) {\n            const kh = attributes.kernelShape[attributes.kernelShape.length - 2];\n            const sh = attributes.strides[attributes.strides.length - 2];\n            const phStart = attributes.pads[attributes.pads.length / 2 - 2];\n            const phEnd = attributes.pads[attributes.pads.length - 2];\n            phStartEndNotZero = !!(phStart + phEnd);\n            programUniforms.push(\n              { type: "uint32", data: kh },\n              { type: "uint32", data: sh },\n              { type: "uint32", data: phStart },\n              { type: "uint32", data: phEnd }\n            );\n            uniforms.push(\n              { name: "kh", type: "u32" },\n              { name: "sh", type: "u32" },\n              { name: "phStart", type: "u32" },\n              { name: "phEnd", type: "u32" }\n            );\n          }\n          return [programUniforms, uniforms, true, pwStartEndNotZero, phStartEndNotZero];\n        } else {\n          if (isChannelsLast) {\n            throw new Error("Pooling with kernelShape.length > 2 is not supported for NHWC format.");\n          }\n          const kernelStrides = ShapeUtil.computeStrides(attributes.kernelShape);\n          programUniforms.push(\n            { type: "uint32", data: kernelStrides },\n            { type: "uint32", data: attributes.pads },\n            { type: "uint32", data: attributes.strides }\n          );\n          uniforms.push(\n            { name: "kernelStrides", type: "u32", length: kernelStrides.length },\n            { name: "pads", type: "u32", length: attributes.pads.length },\n            { name: "strides", type: "u32", length: attributes.strides.length }\n          );\n          const hasPads = attributes.pads.reduce((sum, cur) => sum + cur);\n          return [programUniforms, uniforms, !!hasPads, false, false];\n        }\n      };\n      generatePoolingCode = (shaderHelper, x, rank, outputShapeRank, attributes, op1, op2, start, uniforms, hasPads, pwStartEndNotZero, phStartEndNotZero) => {\n        const isChannelsLast = attributes.format === "NHWC";\n        const dataType = x.type.value;\n        const output = outputVariable("output", x.type.tensor, outputShapeRank);\n        if (attributes.kernelShape.length <= 2) {\n          let codeW = "";\n          let codeH = "";\n          let codeHEnd = "";\n          const dimIdxW = rank - (isChannelsLast ? 2 : 1);\n          if (pwStartEndNotZero) {\n            codeW = `\n                for (var i: u32 = 0u; i < uniforms.kw; i++) {\n                  xIndices[${dimIdxW}] = indices[${dimIdxW}] * uniforms.sw - uniforms.pwStart + i;\n                  if (xIndices[${dimIdxW}] < 0 || xIndices[${dimIdxW}]\n                      >= uniforms.x_shape[${dimIdxW}]) {\n                    pad++;\n                    continue;\n                  }\n                  let x_val = x[${x.indicesToOffset("xIndices")}];\n                  ${op1}\n                }`;\n          } else {\n            codeW = `\n                for (var i: u32 = 0u; i < uniforms.kw; i++) {\n                  xIndices[${dimIdxW}] = indices[${dimIdxW}] * uniforms.sw - uniforms.pwStart + i;\n                  let x_val = x[${x.indicesToOffset("xIndices")}];\n                  ${op1}\n                }`;\n          }\n          if (attributes.kernelShape.length === 2) {\n            const dimIdxH = rank - (isChannelsLast ? 3 : 2);\n            if (phStartEndNotZero) {\n              codeH = `\n                for (var j: u32 = 0u; j < uniforms.kh; j++) {\n                  xIndices[${dimIdxH}] = indices[${dimIdxH}] * uniforms.sh - uniforms.phStart + j;\n                  if (xIndices[${dimIdxH}] < 0 || xIndices[${dimIdxH}] >= uniforms.x_shape[${dimIdxH}]) {\n                    pad += i32(uniforms.kw);\n                    continue;\n                  }\n              `;\n            } else {\n              codeH = `\n                for (var j: u32 = 0u; j < uniforms.kh; j++) {\n                  xIndices[${dimIdxH}] = indices[${dimIdxH}] * uniforms.sh - uniforms.phStart + j;\n                `;\n            }\n            codeHEnd = `\n              }\n            `;\n          }\n          const poolingCode = `\n            ${shaderHelper.registerUniforms(uniforms).declareVariables(x, output)}\n\n            ${shaderHelper.mainStart()}\n              ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n\n              let indices = ${output.offsetToIndices("global_idx")};\n              var xIndices = ${output.offsetToIndices("global_idx")};\n\n              var value = ${dataType}(${start});\n              var pad = 0;\n              ${codeH}\n              ${codeW}\n              ${codeHEnd}\n              ${op2}\n\n              output[global_idx] = value;\n            }`;\n          return poolingCode;\n        } else {\n          if (isChannelsLast) {\n            throw new Error("Pooling with kernelShape.length > 2 is not supported for NHWC format.");\n          }\n          const stridesRank = attributes.kernelShape.length;\n          const padsRank = attributes.pads.length;\n          let padCode = "";\n          if (hasPads) {\n            padCode = `\n                if (xIndices[j] >= uniforms.x_shape[j]) {\n                  pad++;\n                  isPad = true;\n                  break;\n                }\n              }\n              if (!isPad) {\n                let x_val = x[${x.indicesToOffset("xIndices")}];\n                ${op1}\n              }`;\n          } else {\n            padCode = `\n              }\n              let x_val = x[${x.indicesToOffset("xIndices")}];\n              ${op1}\n            `;\n          }\n          const poolingCode = `\n            ${shaderHelper.registerUniforms(uniforms).declareVariables(x, output)}\n\n            ${shaderHelper.mainStart()}\n              ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n              let indices = ${output.offsetToIndices("global_idx")};\n              var xIndices = ${output.offsetToIndices("global_idx")};\n\n              var offsets: array<u32, ${stridesRank}>;\n\n              var value = ${dataType}(${start});\n              var pad = 0;\n              var isPad = false;\n\n              for (var i: u32 = 0u; i < uniforms.kernelSize; i++) {\n                var offset = i;\n                for (var j = 0u; j < ${stridesRank - 1}u; j++) {\n                  offsets[j] = offset / ${getElementAt("uniforms.kernelStrides", "j", stridesRank)};\n                  offset -= offsets[j] * ${getElementAt("uniforms.kernelStrides", "j", stridesRank)};\n                }\n                offsets[${stridesRank - 1}] = offset;\n\n                isPad = false;\n                for (var j = ${rank - stridesRank}u; j < ${rank}u; j++) {\n                  xIndices[j] = indices[j] * ${getElementAt("uniforms.strides", `j - ${rank - stridesRank}u`, stridesRank)}\n                    + offsets[j - ${rank - stridesRank}u] - ${getElementAt("uniforms.pads", "j - 2u", padsRank)};\n                  ${padCode}\n              }\n              ${op2}\n\n              output[global_idx] = value;\n            }`;\n          return poolingCode;\n        }\n      };\n      createShaderKeyFromAttributes = (attributes) => `${attributes.format};${attributes.ceilMode};${attributes.autoPad};${attributes.kernelShape.length}`;\n      createAveragePoolShaderKeyFromAttributes = (attributes) => `${createShaderKeyFromAttributes(attributes)};${attributes.countIncludePad}`;\n      createMaxPoolShaderKeyFromAttributes = (attributes) => `${createShaderKeyFromAttributes(attributes)};${attributes.storageOrder};${attributes.dilations}`;\n      parsePoolCommonAttributes = (attributes) => ({\n        format: attributes.format,\n        autoPad: ["NOTSET", "VALID", "SAME_UPPER", "SAME_LOWER"][attributes.auto_pad],\n        ceilMode: attributes.ceil_mode,\n        kernelShape: attributes.kernel_shape,\n        strides: attributes.strides,\n        pads: attributes.pads\n      });\n      createAveragePoolProgramInfo = (name, input, isGlobalOperator, attributes) => {\n        const [adjustedAttributes, outputShape] = getAdjustedPoolAttributesAndOutputShape(input, attributes, isGlobalOperator);\n        const x = inputVariable("x", input.dataType, input.dims.length);\n        const dataType = x.type.value;\n        const op1 = "value += x_val;";\n        let op2 = "";\n        if (adjustedAttributes.countIncludePad) {\n          op2 += `value /= ${dataType}(uniforms.kernelSize);`;\n        } else {\n          op2 += `value /= ${dataType}(i32(uniforms.kernelSize) - pad);`;\n        }\n        const [programUniforms, uniforms, hasPads, pwStartEndNotZero, phStartEndNotZero] = getUniformAndPadInfo(outputShape, adjustedAttributes);\n        programUniforms.push(...createTensorShapeVariables(input.dims), ...createTensorShapeVariables(outputShape));\n        const inputDependencies = ["rank"];\n        return {\n          name,\n          shaderCache: { hint: `${attributes.cacheKey};${hasPads};${pwStartEndNotZero};${phStartEndNotZero}`, inputDependencies },\n          getRunData: () => ({\n            outputs: [{ dims: outputShape, dataType: input.dataType }],\n            dispatchGroup: { x: Math.ceil(\n              ShapeUtil.size(outputShape) / 64\n              /* workgroup size */\n            ) },\n            programUniforms\n          }),\n          getShaderSource: (shaderHelper) => generatePoolingCode(\n            shaderHelper,\n            x,\n            input.dims.length,\n            outputShape.length,\n            adjustedAttributes,\n            op1,\n            op2,\n            0,\n            uniforms,\n            hasPads,\n            pwStartEndNotZero,\n            phStartEndNotZero\n          )\n        };\n      };\n      parseAveragePoolAttributes = (attributes) => {\n        const countIncludePad = attributes.count_include_pad === 0 ? false : true;\n        const attr = parsePoolCommonAttributes(attributes);\n        if (attr.ceilMode !== 0) {\n          throw new Error("using ceil() in shape computation is not yet supported for AveragePool");\n        }\n        const averagePoolAttributes = { countIncludePad, ...attr, cacheKey: "" };\n        return { ...averagePoolAttributes, cacheKey: createAveragePoolShaderKeyFromAttributes(averagePoolAttributes) };\n      };\n      averagePool = (context, attributes) => {\n        validateInputs18(context.inputs);\n        context.compute(createAveragePoolProgramInfo("AveragePool", context.inputs[0], false, attributes));\n      };\n      globalPoolAttributes = {\n        autoPad: "",\n        ceilMode: 0,\n        countIncludePad: false,\n        kernelShape: [],\n        strides: [],\n        pads: [],\n        storageOrder: 0,\n        dilations: []\n      };\n      parseGlobalAveragePoolAttributes = (attributes) => {\n        const format = attributes.format;\n        return { format, ...globalPoolAttributes, cacheKey: format };\n      };\n      globalAveragePool = (context, attributes) => {\n        validateInputs18(context.inputs);\n        context.compute(createAveragePoolProgramInfo("GlobalAveragePool", context.inputs[0], true, attributes));\n      };\n      createMaxPoolProgramInfo = (name, input, isGlobalOperator, attributes) => {\n        const [adjustedAttributes, outputShape] = getAdjustedPoolAttributesAndOutputShape(input, attributes, isGlobalOperator);\n        const op1 = `\n      value = max(x_val, value);\n    `;\n        const op2 = "";\n        const x = inputVariable("x", input.dataType, input.dims.length);\n        const inputDependencies = ["rank"];\n        const [programUniforms, uniforms, hasPads, pwStartEndNotZero, phStartEndNotZero] = getUniformAndPadInfo(outputShape, adjustedAttributes);\n        programUniforms.push(...createTensorShapeVariables(input.dims), ...createTensorShapeVariables(outputShape));\n        return {\n          name,\n          shaderCache: { hint: `${attributes.cacheKey};${hasPads};${pwStartEndNotZero};${phStartEndNotZero}`, inputDependencies },\n          getRunData: () => ({\n            outputs: [{ dims: outputShape, dataType: input.dataType }],\n            dispatchGroup: { x: Math.ceil(\n              ShapeUtil.size(outputShape) / 64\n              /* workgroup size */\n            ) },\n            programUniforms\n          }),\n          getShaderSource: (shaderHelper) => generatePoolingCode(\n            shaderHelper,\n            x,\n            input.dims.length,\n            outputShape.length,\n            adjustedAttributes,\n            op1,\n            op2,\n            -1e5,\n            uniforms,\n            hasPads,\n            pwStartEndNotZero,\n            phStartEndNotZero\n          )\n        };\n      };\n      maxPool = (context, attributes) => {\n        validateInputs18(context.inputs);\n        context.compute(createMaxPoolProgramInfo("MaxPool", context.inputs[0], false, attributes));\n      };\n      parseMaxPoolAttributes = (attributes) => {\n        const storageOrder = attributes.storage_order;\n        const dilations = attributes.dilations;\n        const attr = parsePoolCommonAttributes(attributes);\n        if (storageOrder !== 0) {\n          throw new Error("column major storage order is not yet supported for MaxPool");\n        }\n        if (attr.ceilMode !== 0) {\n          throw new Error("using ceil() in shape computation is not yet supported for MaxPool");\n        }\n        const maxPoolAttributes = { storageOrder, dilations, ...attr, cacheKey: "" };\n        return { ...maxPoolAttributes, cacheKey: createMaxPoolShaderKeyFromAttributes(maxPoolAttributes) };\n      };\n      parseGlobalMaxPoolAttributes = (attributes) => {\n        const format = attributes.format;\n        return { format, ...globalPoolAttributes, cacheKey: format };\n      };\n      globalMaxPool = (context, attributes) => {\n        validateInputs18(context.inputs);\n        context.compute(createMaxPoolProgramInfo("GlobalMaxPool", context.inputs[0], true, attributes));\n      };\n    }\n  });\n\n  // web/lib/wasm/jsep/webgpu/ops/range.ts\n  var validateInputsContent, createRangeProgramInfo, range;\n  var init_range = __esm({\n    "web/lib/wasm/jsep/webgpu/ops/range.ts"() {\n      "use strict";\n      init_esm();\n      init_wasm_common();\n      init_common();\n      validateInputsContent = (start, limit, delta) => {\n        const sameStartLimit = start === limit;\n        const increasingRangeNegativeStep = start < limit && delta < 0;\n        const decreasingRangePositiveStep = start > limit && delta > 0;\n        if (sameStartLimit || increasingRangeNegativeStep || decreasingRangePositiveStep) {\n          throw new Error("Range these inputs\' contents are invalid.");\n        }\n      };\n      createRangeProgramInfo = (start, limit, delta, dataType) => {\n        const numElements = Math.abs(Math.ceil((limit - start) / delta));\n        const outputShape = [numElements];\n        const outputSize = numElements;\n        const tensorDataType = tensorDataTypeEnumToString(dataType);\n        const programUniforms = [\n          { type: "uint32", data: outputSize },\n          { type: tensorDataType, data: start },\n          { type: tensorDataType, data: delta },\n          ...createTensorShapeVariables(outputShape)\n        ];\n        const getShaderSource = (shaderHelper) => {\n          const output = outputVariable("output", dataType, outputShape.length);\n          const wgslType = output.type.value;\n          const uniforms = [\n            { name: "outputSize", type: "u32" },\n            { name: "start", type: wgslType },\n            { name: "delta", type: wgslType }\n          ];\n          return `\n        ${shaderHelper.registerUniforms(uniforms).declareVariables(output)}\n        ${shaderHelper.mainStart()}\n        ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n        output[global_idx] = uniforms.start + ${wgslType}(global_idx) * uniforms.delta;\n      }`;\n        };\n        return {\n          name: "Range",\n          shaderCache: { hint: `${dataType}` },\n          getShaderSource,\n          getRunData: () => ({\n            outputs: [{ dims: outputShape, dataType }],\n            dispatchGroup: { x: Math.ceil(\n              outputSize / 64\n              /* workgroup size */\n            ) },\n            programUniforms\n          })\n        };\n      };\n      range = (context) => {\n        let start = 0;\n        let limit = 0;\n        let delta = 0;\n        if (context.inputs[0].dataType === 6 /* int32 */) {\n          start = context.inputs[0].getInt32Array()[0];\n          limit = context.inputs[1].getInt32Array()[0];\n          delta = context.inputs[2].getInt32Array()[0];\n        } else if (context.inputs[0].dataType === 1 /* float */) {\n          start = context.inputs[0].getFloat32Array()[0];\n          limit = context.inputs[1].getFloat32Array()[0];\n          delta = context.inputs[2].getFloat32Array()[0];\n        }\n        if (env2.webgpu.validateInputContent) {\n          validateInputsContent(start, limit, delta);\n        }\n        context.compute(createRangeProgramInfo(start, limit, delta, context.inputs[0].dataType), { inputs: [] });\n      };\n    }\n  });\n\n  // web/lib/wasm/jsep/webgpu/ops/resize.ts\n  var validateScales, updateScales, validateInputs19, getOriginalCoordinateFromResizedCoordinate, getNearestPixelFromOriginal, updateRoI, initOutputShape, adjustOutputShape, calculateOriginalIndicesFromOutputIndices, calculateInputIndicesFromOutputIndices, checkInputIndices, setChannelAndBatchIndices, bilinearInterpolation, bicubicInterpolation, trilinearInterpolation, createResizeProgramInfo, getOpsetVersionFromCustomDataBuffer, resize, parseResizeAttributes;\n  var init_resize = __esm({\n    "web/lib/wasm/jsep/webgpu/ops/resize.ts"() {\n      "use strict";\n      init_util();\n      init_attribute_with_cache_key();\n      init_common();\n      validateScales = (scales, attributes) => {\n        scales.every((value) => value > 0 || (() => {\n          throw new Error("Resize requires scales input values to be positive");\n        }));\n        if (scales.length > 0) {\n          if (attributes.mode === "linear") {\n            if (!(scales.length === 2 || scales.length === 3 || scales.length === 4 && scales[0] === 1 && scales[1] === 1 || scales.length === 4 && scales[0] === 1 && scales[3] === 1 || scales.length === 5 && scales[0] === 1 && scales[1] === 1)) {\n              throw new Error(\n                `For linear mode, Resize requires scales to be 2D, 3D, 4D with either two outermost or one innermost and\n            one outermost scale values equal to 1, or 5D with two outermost scale values equal to 1`\n              );\n            }\n          } else if (attributes.mode === "cubic") {\n            if (!(scales.length === 2 || scales.length === 4 && scales[0] === 1 && scales[1] === 1 || scales.length === 4 && scales[0] === 1 && scales[3] === 1)) {\n              throw new Error("Resize requires scales input size to be 2 or 4 for cubic mode");\n            }\n          }\n        }\n      };\n      updateScales = (scales, axes, rank) => {\n        axes.every((value) => value >= 0 && value < rank || (() => {\n          throw new Error("Resize requires axes input values to be positive and less than rank");\n        }));\n        const newScales = new Array(rank).fill(1);\n        axes.forEach((value, index) => newScales[value] = scales[index]);\n        return newScales;\n      };\n      validateInputs19 = (inputs, attributes, opsetVersion, scales, sizes, roi) => {\n        const [roiInputIndex, scalesInputIndex, sizesInputIndex] = opsetVersion > 10 ? [1, 2, 3] : [-1, inputs.length > 1 ? 1 : -1, -1];\n        const rank = inputs[0].dims.length;\n        if (roiInputIndex > 0 && inputs.length > roiInputIndex && inputs[roiInputIndex].dims.length > 0) {\n          inputs[roiInputIndex].getFloat32Array().forEach((value) => roi.push(value));\n        } else if (attributes.coordinateTransformMode === "tf_crop_and_resize") {\n          throw new Error("Resize requires RoI input to be specified when coordinateTransformMode is tfCropAndResize");\n        }\n        if (scalesInputIndex > 0 && inputs.length > scalesInputIndex && inputs[scalesInputIndex].dims.length > 0) {\n          inputs[scalesInputIndex].getFloat32Array().forEach((value) => scales.push(value));\n          if (scales.length !== 0 && (scales.length !== rank && (opsetVersion >= 18 && scales.length !== attributes.axes.length))) {\n            throw new Error(\n              "Resize requires scales input size to be same as input rank or axes size for opset 18 and up"\n            );\n          }\n          validateScales(scales, attributes);\n          if (attributes.axes.length > 0) {\n            updateScales(scales, attributes.axes, rank).forEach((value, index) => scales[index] = value);\n          }\n        }\n        if (sizesInputIndex > 0 && inputs.length > sizesInputIndex) {\n          inputs[sizesInputIndex].getBigInt64Array().forEach((value) => sizes.push(Number(value)));\n          if (sizes.length !== rank || opsetVersion >= 18 && sizes.length === attributes.axes.length) {\n            throw new Error("Resize requires sizes input size to be same as input rank or axes size for opset 18 and up");\n          }\n        }\n        if (attributes.axes.length > 0) {\n          if (scales.length !== attributes.axes.length) {\n            throw new Error(\'Resize requires "scales" input size to be of axes rank when axes attributes is specified\');\n          }\n          if (sizes.length !== attributes.axes.length) {\n            throw new Error(\n              \'Resize requires "sizes" input size to be of rank axes rank when axes attributes is specified\'\n            );\n          }\n        }\n        if (typeof scales !== "undefined" && typeof sizes !== "undefined" && scales.length > 0 && sizes.length > rank) {\n          throw new Error("Resize requires only of scales or sizes to be specified");\n        }\n      };\n      getOriginalCoordinateFromResizedCoordinate = (coordinateTransferMode, dType) => `fn getOriginalCoordinateFromResizedCoordinate(xResized: u32, xScale: f32, lengthResized: u32,\n     lengthOriginal: u32, roiStart: f32, roiEnd: f32) -> ${dType} { ` + (() => {\n        switch (coordinateTransferMode) {\n          case "asymmetric":\n            return `return ${dType}(xResized) / ${dType}(xScale);`;\n          case "pytorch_half_pixel":\n            return `if (lengthResized > 1) {\n                    return (${dType}(xResized) + 0.5) / ${dType}(xScale) - 0.5;\n                  } else {\n                    return 0.0;\n                  }`;\n          case "tf_half_pixel_for_nn":\n            return `return (${dType}(xResized) + 0.5) / ${dType}(xScale);`;\n          case "align_corners":\n            return `if (lengthResized == 1) {\n                    return 0.0;\n                  } else {\n                    // The whole part and the fractional part are calculated separately due to inaccuracy of floating\n                    // point division. As an example, f32(21) / f32(7) may evaluate to 2.99... instead of 3, causing an\n                    // offset-by-one error later in floor().\n                    let whole = ${dType}(xResized * (lengthOriginal - 1) / (lengthResized - 1));\n                    let fract =\n                        ${dType}(xResized * (lengthOriginal - 1) % (lengthResized - 1)) / ${dType}(lengthResized - 1);\n                    return whole + fract;\n                  }`;\n          case "tf_crop_and_resize":\n            return `if (lengthResized > 1) {\n                    return ${dType}(roiStart) * ${dType}(lengthOriginal - 1) +\n                        (${dType}(xResized) * ${dType}(roiEnd - roiStart) * ${dType}(lengthOriginal - 1)) /\n                        ${dType}(lengthResized - 1);\n                  } else {\n                    return 0.5 * ${dType}(roiStart + roiEnd) * ${dType}(lengthOriginal - 1);\n                  }`;\n          case "half_pixel_symmetric":\n            return `const outputWidth = ${dType}xScale * ${dType}(lengthResized);\n                  const adjustment = ${dType}(lengthResized) / outputWidth;\n                  const center = ${dType}(lengthOriginal) / 2;\n                  const offset = center * (1 - adjustment);\n                  return offset + ((${dType}(xResized) + 0.5) / ${dType}(xScale)) - 0.5;`;\n          case "half_pixel":\n            return `return ((${dType}(xResized) + 0.5) / ${dType}(xScale)) - 0.5;`;\n          default:\n            throw new Error(`Coordinate transform mode ${coordinateTransferMode} is not supported`);\n        }\n      })() + "}";\n      getNearestPixelFromOriginal = (nearestMode, opsetVersion, dType) => `fn getNearestPixelFromOriginal(xOriginal: ${dType}, isDownSample: bool) -> ${dType} {` + (() => {\n        switch (nearestMode) {\n          case "round_prefer_ceil":\n            return "if (fract(xOriginal) == 0.5) {             return ceil(xOriginal);           } else {             return round(xOriginal);           }";\n          case "floor":\n            return "return floor(xOriginal);";\n          case "ceil":\n            return "return ceil(xOriginal);";\n          case "round_prefer_floor":\n            return "if (fract(xOriginal) == 0.5) {                     return floor(xOriginal);                   } else {                     return round(xOriginal);                   }";\n          case "simple":\n          default:\n            if (opsetVersion < 11) {\n              return "if (isDownSample)                     {                       return ceil(xOriginal);                     } else {                       return xOriginal;                     }";\n            }\n            throw new Error(`Nearest mode ${nearestMode} is not supported`);\n        }\n      })() + "}";\n      updateRoI = (roi, axes, rank) => {\n        const roiTmp = new Array(rank).fill(0).concat(new Array(rank).fill(1));\n        const roiLocal = roi.length === 0 ? roiTmp : roi.slice();\n        if (axes.length > 0) {\n          axes.forEach((v, i) => {\n            roiTmp[v] = roiLocal[i];\n            roiTmp[i + rank] = roiLocal[axes.length + i];\n          });\n          return roiTmp;\n        }\n        return roiLocal;\n      };\n      initOutputShape = (inputShape, scales, sizes, axes) => {\n        let outputShape = [];\n        if (sizes.length > 0) {\n          if (axes.length > 0) {\n            inputShape.forEach((v) => outputShape.push(v));\n            if (Math.max(...axes) > inputShape.length) {\n              throw new Error("axes is out of bound");\n            }\n            axes.forEach((v, i) => outputShape[v] = sizes[i]);\n          } else {\n            sizes.forEach((v) => outputShape.push(v));\n          }\n        } else {\n          if (scales.length === 0) {\n            throw new Error("Resize requires either scales or sizes.");\n          } else {\n            outputShape = inputShape.map((value, index) => Math.round(value * scales[index]));\n          }\n        }\n        return outputShape;\n      };\n      adjustOutputShape = (inputShape, scales, attributes) => {\n        const scaleInPolicy = (() => {\n          switch (attributes.keepAspectRatioPolicy) {\n            case "not_larger":\n              return attributes.axes.length > 0 ? Math.min(...attributes.axes.map((i) => scales[i]), Number.MAX_VALUE) : Math.min(...scales, Number.MAX_VALUE);\n            case "not_smaller":\n              return attributes.axes.length > 0 ? Math.max(...attributes.axes.map((i) => scales[i]), Number.MIN_VALUE) : Math.max(...scales, Number.MIN_VALUE);\n            default:\n              throw new Error(`Keep aspect ratio policy ${attributes.keepAspectRatioPolicy} is not supported`);\n          }\n        })();\n        scales.fill(1, 0, scales.length);\n        const adjustedOutputShape = inputShape.slice();\n        if (attributes.axes.length > 0) {\n          attributes.axes.forEach((v) => scales[v] = scaleInPolicy);\n          attributes.axes.forEach((v) => adjustedOutputShape[v] = Math.round(inputShape[v] * scales[v]));\n        } else {\n          scales.fill(scaleInPolicy, 0, scales.length);\n          adjustedOutputShape.forEach((v, i) => adjustedOutputShape[i] = Math.round(v * scales[i]));\n        }\n        return adjustedOutputShape;\n      };\n      calculateOriginalIndicesFromOutputIndices = (output, inputShape, outputShape, scalesLength, roiLength) => `\n    fn calculateOriginalIndicesFromOutputIndices(output_indices: ${output.type.indices}) -> array<${output.type.value}, ${outputShape.length}> {\n      var original_indices: array<${output.type.value}, ${outputShape.length}>;\n      for (var i:u32 = 0; i < ${outputShape.length}; i++) {\n        var output_index = ${output.indicesGet("output_indices", "i")};\n        var scale = ${getElementAt("uniforms.scales", "i", scalesLength)};\n        var roi_low = ${getElementAt("uniforms.roi", "i", roiLength)};\n        var roi_hi = ${getElementAt("uniforms.roi", `i + ${inputShape.length}`, roiLength)};\n        if (scale == 1.0) {\n          original_indices[i] = ${output.type.value}(output_index);\n        } else {\n          var input_shape_i = ${getElementAt("uniforms.input_shape", "i", inputShape.length)};\n          var output_shape_i = ${getElementAt("uniforms.output_shape", "i", outputShape.length)};\n          original_indices[i] = getOriginalCoordinateFromResizedCoordinate(output_index, scale, output_shape_i,\n                                                                           input_shape_i, roi_low, roi_hi);\n        }\n      }\n      return original_indices;\n    }`;\n      calculateInputIndicesFromOutputIndices = (input, output, inputShape, outputShape, scalesLength, roiLength, useExtrapolation) => `\n    fn calculateInputIndicesFromOutputIndices(output_indices: ${output.type.indices}) -> ${input.type.indices} {\n      var input_indices: ${input.type.indices};\n      for (var i:u32 = 0; i < ${outputShape.length}; i++) {\n        var output_index = ${output.indicesGet("output_indices", "i")};\n        var input_index: u32;\n        var scale = ${getElementAt("uniforms.scales", "i", scalesLength)};\n        if (scale == 1.0) {\n          input_index = output_index;\n        } else {\n          var roi_low = ${getElementAt("uniforms.roi", "i", roiLength)};\n          var roi_hi = ${getElementAt("uniforms.roi", `i + ${inputShape.length}`, roiLength)};\n          var input_shape_i = ${getElementAt("uniforms.input_shape", "i", inputShape.length)};\n          var output_shape_i = ${getElementAt("uniforms.output_shape", "i", outputShape.length)};\n          var original_idx = getOriginalCoordinateFromResizedCoordinate(output_index, scale, output_shape_i,\n                                                                        input_shape_i, roi_low, roi_hi);\n          if (!${useExtrapolation} || (original_idx >= 0 && original_idx < ${output.type.value}(input_shape_i))) {\n            if (original_idx < 0) {\n              input_index = 0;\n            } else if (original_idx > ${output.type.value}(input_shape_i - 1)) {\n              input_index = input_shape_i - 1;\n            } else {\n              input_index = u32(getNearestPixelFromOriginal(original_idx, scale < 1));\n            }\n          } else {\n            input_index = u32(original_idx);\n          }\n        }\n        ${input.indicesSet("input_indices", "i", " input_index")}\n      }\n      return input_indices;\n    }`;\n      checkInputIndices = (input, inputShape) => `\n    fn checkInputIndices(input_indices: ${input.type.indices}) -> bool {\n      for (var i:u32 = 0; i < ${inputShape.length}; i++) {\n        var input_index = ${input.indicesGet("input_indices", "i")};\n        if (input_index < 0 || input_index >= ${getElementAt("uniforms.input_shape", "i", inputShape.length)}) {\n          return false;\n        }\n      }\n      return true;\n    }`;\n      setChannelAndBatchIndices = (input, channelIdx, batchIdx, spacialDims) => input.rank > spacialDims ? `\n    ${input.indicesSet("input_indices", channelIdx, "channel")};\n    ${input.indicesSet("input_indices", batchIdx, "batch")};\n` : "";\n      bilinearInterpolation = (input, output, inputShape, useExtrapolation, extrapolationValue) => {\n        const isNchw = true;\n        const [batchIdx, heightIdx, widthIdx, channelIdx] = inputShape.length === 2 ? [-1, 0, 1, -1] : isNchw ? [0, 2, 3, 1] : [0, 1, 2, 3];\n        const dType = input.type.value;\n        return `\n    fn getInputValue(batch: u32, channel: u32, row: u32, col: u32) -> ${dType} {\n      var input_indices: ${input.type.indices};\n      ${input.indicesSet("input_indices", heightIdx, `max(0, min(row, ${inputShape[heightIdx]} - 1))`)};\n      ${input.indicesSet("input_indices", widthIdx, `max(0, min(col, ${inputShape[widthIdx]} - 1))`)};\n      ${setChannelAndBatchIndices(input, channelIdx, batchIdx, 2)}\n      return ${input.getByIndices("input_indices")};\n    }\n\n    fn bilinearInterpolation(output_indices: ${output.type.indices}) -> ${dType} {\n      var originalIndices = calculateOriginalIndicesFromOutputIndices(output_indices);\n      var row:${dType} = originalIndices[${heightIdx}];\n      var col:${dType} = originalIndices[${widthIdx}];\n      ${useExtrapolation ? `if (row < 0 || row > (${inputShape[heightIdx]} - 1) || col < 0 || col > (${inputShape[widthIdx]} - 1)) {\n        return ${extrapolationValue};\n      }` : ""};\n      row = max(0, min(row, ${inputShape[heightIdx]} - 1));\n      col = max(0, min(col, ${inputShape[widthIdx]} - 1));\n      var row1: u32 = u32(row);\n      var col1: u32 = u32(col);\n      var row2: u32 = u32(row + 1);\n      var col2: u32 = u32(col + 1);\n      var channel: u32 = ${inputShape.length > 2 ? `u32(originalIndices[${channelIdx}])` : "0"};\n      var batch: u32 =  ${inputShape.length > 2 ? `u32(originalIndices[${batchIdx}])` : "0"};\n      var x11: ${dType} = getInputValue(batch, channel, row1, col1);\n      var x12: ${dType} = getInputValue(batch, channel, row1, col2);\n      var x21: ${dType} = getInputValue(batch, channel, row2, col1);\n      var x22: ${dType} = getInputValue(batch, channel, row2, col2);\n      var dx1: ${dType} = abs(row - ${dType}(row1));\n      var dx2: ${dType} = abs(${dType}(row2) - row);\n      var dy1: ${dType} = abs(col - ${dType}(col1));\n      var dy2: ${dType} = abs(${dType}(col2) - col);\n      if (row1 == row2) {\n        dx1 = 0.5;\n        dx2 = 0.5;\n      }\n      if (col1 == col2) {\n        dy1 = 0.5;\n        dy2 = 0.5;\n      }\n      return (x11 * dx2 * dy2 + x12 * dx2 * dy1 + x21 * dx1 * dy2 + x22 * dx1 * dy1);\n    }`;\n      };\n      bicubicInterpolation = (input, output, inputShape, outputShape, scales, roi, cubicCoeffA, useExtrapolation, extrapolationValue, excludeOutside) => {\n        const is2D = inputShape.length === 2;\n        const isNchw = true;\n        const [heightIdx, widthIdx] = is2D ? [0, 1] : isNchw ? [2, 3] : [1, 2];\n        const dType = input.type.value;\n        const createCubicInterpolationFunction = (idx) => {\n          const direction = idx === heightIdx ? "row" : "col";\n          return `\n      fn ${direction}CubicInterpolation(input_indices: ${input.type.indices}, output_indices: ${output.type.indices}) -> ${dType} {\n        var output_index = ${output.indicesGet("output_indices", idx)};\n        var originalIdx: ${dType} = getOriginalCoordinateFromResizedCoordinate(output_index, ${scales[idx]},\n        ${outputShape[idx]}, ${inputShape[idx]}, ${roi[idx]}, ${roi[idx]} + ${inputShape.length});\n        var fractOriginalIdx: ${dType} = originalIdx - floor(originalIdx);\n        var coefs = getCubicInterpolationCoefs(fractOriginalIdx);\n\n        if (${useExtrapolation} && (originalIdx < 0 || originalIdx > (${inputShape[idx]} - 1))) {\n          return ${extrapolationValue};\n        }\n        var data: array<${dType}, 4> = array<${dType}, 4>(0.0, 0.0, 0.0, 0.0);\n        for (var i: i32 = -1; i < 3; i++) {\n          var ${direction}: ${dType} = originalIdx + ${dType}(i);\n          if (${direction} < 0 || ${direction} >= ${inputShape[idx]}) {\n            ${(() => {\n            if (excludeOutside) {\n              return `coefs[i + 1] = 0.0;\n                        continue;`;\n            } else if (useExtrapolation) {\n              return `return ${extrapolationValue};`;\n            } else {\n              return `${direction} = max(0, min(${direction}, ${inputShape[idx]} - 1));`;\n            }\n          })()};\n          }\n        var input_indices_copy: ${input.type.indices} = input_indices;\n          ${input.indicesSet("input_indices_copy", idx, `u32(${direction})`)};\n          data[i + 1] = ${idx === heightIdx ? input.getByIndices("input_indices_copy") : "rowCubicInterpolation(input_indices_copy, output_indices)"};\n        }\n        return cubicInterpolation1D(data, coefs);\n      }`;\n        };\n        return `\n    ${createCubicInterpolationFunction(heightIdx)};\n    ${createCubicInterpolationFunction(widthIdx)};\n  fn getCubicInterpolationCoefs(s: ${dType}) -> array<${dType}, 4> {\n    var absS = abs(s);\n    var coeffs: array<${dType}, 4> = array<${dType}, 4>(0.0, 0.0, 0.0, 0.0);\n    var oneMinusAbsS: ${dType} = 1.0 - absS;\n    var twoMinusAbsS: ${dType} = 2.0 - absS;\n    var onePlusAbsS: ${dType} = 1.0 + absS;\n    coeffs[0] = ((${cubicCoeffA} * onePlusAbsS - 5 * ${cubicCoeffA}) * onePlusAbsS + 8 * ${cubicCoeffA}) * onePlusAbsS - 4 * ${cubicCoeffA};\n    coeffs[1] = ((${cubicCoeffA} + 2) * absS - (${cubicCoeffA} + 3)) * absS * absS + 1;\n    coeffs[2] = ((${cubicCoeffA} + 2) * oneMinusAbsS - (${cubicCoeffA} + 3)) * oneMinusAbsS * oneMinusAbsS + 1;\n    coeffs[3] = ((${cubicCoeffA} * twoMinusAbsS - 5 * ${cubicCoeffA}) * twoMinusAbsS + 8 * ${cubicCoeffA}) * twoMinusAbsS - 4 * ${cubicCoeffA};\n    return coeffs;\n  }\n\n  fn cubicInterpolation1D(x: array<${dType}, 4>, coefs: array<${dType}, 4>) -> ${dType} {\n    var coefsSum: ${dType} = coefs[0] + coefs[1] + coefs[2] + coefs[3];\n    return (x[0] * coefs[0] + x[1] * coefs[1]+ x[2] * coefs[2]+ x[3] * coefs[3]) / coefsSum;\n  }\n\n  fn bicubicInterpolation(output_indices: ${output.type.indices}) -> ${dType} {\n    var input_indices: ${input.type.indices} = output_indices;\n    return colCubicInterpolation(input_indices, output_indices);\n  }\n    `;\n      };\n      trilinearInterpolation = (input, output, inputShape, useExtrapolation, extrapolationValue) => {\n        const isNchw = true;\n        const [batchIdx, depthIdx, heightIdx, widthIdx, channelIdx] = inputShape.length === 3 ? [-1, 0, 1, 2, -1] : isNchw ? [0, 2, 3, 4, 1] : [0, 1, 2, 3, 4];\n        const dType = input.type.value;\n        return `\n    fn getInputValue(batch: u32, channel: u32, depth:u32, height: u32, width: u32) -> ${dType} {\n      var input_indices: ${input.type.indices};\n      ${input.indicesSet("input_indices", depthIdx, `max(0, min(depth, ${inputShape[depthIdx]} - 1))`)};\n      ${input.indicesSet("input_indices", heightIdx, `max(0, min(height, ${inputShape[heightIdx]} - 1))`)};\n      ${input.indicesSet("input_indices", widthIdx, `max(0, min(width, ${inputShape[widthIdx]} - 1))`)};\n      ${setChannelAndBatchIndices(input, channelIdx, batchIdx, 3)}\n      return ${input.getByIndices("input_indices")};\n    }\n\n    fn trilinearInterpolation(output_indices: ${output.type.indices}) -> ${dType} {\n      var originalIndices = calculateOriginalIndicesFromOutputIndices(output_indices);\n      var depth:${dType} = originalIndices[${depthIdx}];\n      var height:${dType} = originalIndices[${heightIdx}];\n      var width:${dType} = originalIndices[${widthIdx}];\n      ${useExtrapolation ? `if (depth < 0 || depth > (${inputShape[depthIdx]} - 1) || height < 0 || height > (${inputShape[heightIdx]} - 1) || width < 0 || (width > ${inputShape[widthIdx]} - 1)) {\n      return ${extrapolationValue};\n        }` : ""};\n\n    depth = max(0, min(depth, ${inputShape[depthIdx]} - 1));\n      height = max(0, min(height, ${inputShape[heightIdx]} - 1));\n      width = max(0, min(width, ${inputShape[widthIdx]} - 1));\n      var depth1: u32 = u32(depth);\n      var height1: u32 = u32(height);\n      var width1: u32 = u32(width);\n      var depth2: u32 = u32(depth + 1);\n      var height2: u32 = u32(height + 1);\n      var width2: u32 = u32(width + 1);\n      var channel: u32 = ${inputShape.length > 3 ? `u32(originalIndices[${channelIdx}])` : "0"};\n      var batch: u32 =  ${inputShape.length > 3 ? `u32(originalIndices[${batchIdx}])` : "0"};\n\n      var x111: ${dType} = getInputValue(batch, channel, depth1, height1, width1);\n      var x112: ${dType} = getInputValue(batch, channel, depth1, height1, width2);\n      var x121: ${dType} = getInputValue(batch, channel, depth1, height2, width1);\n      var x122: ${dType} = getInputValue(batch, channel, depth1, height2, width2);\n      var x211: ${dType} = getInputValue(batch, channel, depth2, height1, width1);\n      var x212: ${dType} = getInputValue(batch, channel, depth2, height1, width2);\n      var x221: ${dType} = getInputValue(batch, channel, depth2, height2, width1);\n      var x222: ${dType} = getInputValue(batch, channel, depth2, height2, width2);\n      var dx1: ${dType} = abs(depth - ${dType}(depth1));\n      var dx2: ${dType} = abs(${dType}(depth2) - depth);\n      var dy1: ${dType} = abs(height - ${dType}(height1));\n      var dy2: ${dType} = abs(${dType}(height2) - height);\n      var dz1: ${dType} = abs(width - ${dType}(width1));\n      var dz2: ${dType} = abs(${dType}(width2) - width);\n      if (depth1 == depth2) {\n        dx1 = 0.5;\n        dx2 = 0.5;\n      }\n      if (height1 == height2) {\n        dy1 = 0.5;\n        dy2 = 0.5;\n      }\n      if (width1 == width2) {\n        dz1 = 0.5;\n        dz2 = 0.5;\n      }\n      return (x111 * dx2 * dy2 * dz2 + x112 * dx2 * dy2 * dz1 + x121 * dx2 * dy1 *dz2 + x122 * dx2 * dy1 * dz1 +\n              x211 * dx1 * dy2 * dz2 + x212 * dx1 * dy2 * dz1 + x221 * dx1 * dy1 *dz2 + x222 * dx1 * dy1 * dz1);\n    }`;\n      };\n      createResizeProgramInfo = (inputTensor, attributes, opsetVersion, scalesInput, sizes, roiInput) => {\n        const inputShape = inputTensor.dims;\n        const roi = updateRoI(roiInput, attributes.axes, inputShape.length);\n        let outputShape = initOutputShape(inputShape, scalesInput, sizes, attributes.axes);\n        let scales = scalesInput.slice();\n        if (scalesInput.length === 0) {\n          scales = inputShape.map((value, index) => value === 0 ? 1 : outputShape[index] / value);\n          if (attributes.keepAspectRatioPolicy !== "stretch") {\n            outputShape = adjustOutputShape(inputShape, scales, attributes);\n          }\n        }\n        const output = outputVariable("output", inputTensor.dataType, outputShape.length);\n        const input = inputVariable("input", inputTensor.dataType, inputShape.length);\n        const outputSize = ShapeUtil.size(outputShape);\n        const noScale = inputShape.length === outputShape.length && inputShape.every((d, i) => d === outputShape[i]);\n        const useExtrapolation = attributes.coordinateTransformMode === "tf_crop_and_resize";\n        const extrapolationValue = attributes.extrapolationValue;\n        const dataType = input.type.value;\n        const getShaderSource = (shaderHelper) => `\n      ${noScale ? "" : `\n      ${getOriginalCoordinateFromResizedCoordinate(attributes.coordinateTransformMode, dataType)};\n      ${(() => {\n          switch (attributes.mode) {\n            case "nearest":\n              return `\n              ${checkInputIndices(input, inputShape)};\n              ${getNearestPixelFromOriginal(attributes.nearestMode, opsetVersion, dataType)};\n              ${calculateInputIndicesFromOutputIndices(\n                input,\n                output,\n                inputShape,\n                outputShape,\n                scales.length,\n                roi.length,\n                useExtrapolation\n              )};\n              `;\n            case "linear":\n              return `\n              ${calculateOriginalIndicesFromOutputIndices(output, inputShape, outputShape, scales.length, roi.length)};\n              ${(() => {\n                if (inputShape.length === 2 || inputShape.length === 4) {\n                  return `${bilinearInterpolation(input, output, inputShape, useExtrapolation, extrapolationValue)}`;\n                } else if (inputShape.length === 3 || inputShape.length === 5) {\n                  return `${trilinearInterpolation(input, output, inputShape, useExtrapolation, extrapolationValue)}`;\n                } else {\n                  throw Error("Linear mode only supports input dims 2, 3, 4 and 5 are supported in linear mode.");\n                }\n              })()};\n            `;\n            case "cubic":\n              return `\n            ${(() => {\n                if (inputShape.length === 2 || inputShape.length === 4) {\n                  return `${bicubicInterpolation(\n                    input,\n                    output,\n                    inputShape,\n                    outputShape,\n                    scales,\n                    roi,\n                    attributes.cubicCoeffA,\n                    useExtrapolation,\n                    attributes.extrapolationValue,\n                    attributes.excludeOutside\n                  )}`;\n                } else {\n                  throw Error("Cubic mode only supports input dims 2 and 4 are supported in linear mode.");\n                }\n              })()};\n            `;\n            default:\n              throw Error("Invalid resize mode");\n          }\n        })()};\n      `}\n      ${shaderHelper.registerUniform("output_size", "u32").registerUniform("scales", "f32", scales.length).registerUniform("roi", "f32", roi.length).declareVariables(input, output)}\n      ${shaderHelper.mainStart()}\n        ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n        ${noScale ? "output[global_idx] = input[global_idx];" : `\n        let output_indices = ${output.offsetToIndices("global_idx")};\n        var input_indices: ${input.type.indices};\n        ${(() => {\n          switch (attributes.mode) {\n            case "nearest":\n              return `input_indices = calculateInputIndicesFromOutputIndices(output_indices);\n                if (checkInputIndices(input_indices)) {\n                  output[global_idx] = ${input.getByIndices("input_indices")};\n                } else {\n                  output[global_idx] = ${attributes.extrapolationValue};\n                }`;\n            case "linear":\n              return `output[global_idx] = ${inputShape.length === 2 || inputShape.length === 4 ? "bilinearInterpolation" : "trilinearInterpolation"}(output_indices);`;\n            case "cubic":\n              return "output[global_idx] = bicubicInterpolation(output_indices);";\n            default:\n              throw Error(`Unsupported resize mode: ${attributes.mode}`);\n          }\n        })()};\n`}\n      }`;\n        return {\n          name: "Resize",\n          shaderCache: {\n            hint: `${attributes.cacheKey}|${opsetVersion}|${scales.length > 0 ? scales : ""}|${sizes.length > 0 ? sizes : ""}|${roi.length > 0 ? roi : ""}|${noScale}|${inputShape}`,\n            inputDependencies: ["rank"]\n          },\n          getShaderSource,\n          getRunData: () => ({\n            outputs: [{ dims: outputShape, dataType: inputTensor.dataType }],\n            dispatchGroup: { x: Math.ceil(\n              outputSize / 64\n              /* workgroup size */\n            ) },\n            programUniforms: [\n              { type: "uint32", data: outputSize },\n              { type: "float32", data: scales },\n              { type: "float32", data: roi },\n              ...createTensorShapeVariables(inputShape),\n              ...createTensorShapeVariables(outputShape)\n            ]\n          })\n        };\n      };\n      getOpsetVersionFromCustomDataBuffer = (context) => {\n        const customDataBuffer = context.customDataBuffer;\n        const customDataBuffer32 = new Uint32Array(customDataBuffer, customDataBuffer.byteOffset, 1);\n        const opsetVersion = customDataBuffer32[0];\n        return opsetVersion;\n      };\n      resize = (context, attributes) => {\n        const scales = [];\n        const sizes = [];\n        const roi = [];\n        const opsetVersion = getOpsetVersionFromCustomDataBuffer(context);\n        if (attributes.antialias !== 0) {\n          throw Error("Only default value (0) for Antialias attribute is supported");\n        }\n        validateInputs19(context.inputs, attributes, opsetVersion, scales, sizes, roi);\n        context.compute(\n          createResizeProgramInfo(context.inputs[0], attributes, opsetVersion, scales, sizes, roi),\n          { inputs: [0] }\n        );\n      };\n      parseResizeAttributes = (attributes) => {\n        const antialias = attributes.antialias;\n        const axes = attributes.axes;\n        const coordinateTransformMode = attributes.coordinateTransformMode;\n        const cubicCoeffA = attributes.cubicCoeffA;\n        const excludeOutside = attributes.excludeOutside !== 0;\n        const extrapolationValue = attributes.extrapolationValue;\n        const keepAspectRatioPolicy = attributes.keepAspectRatioPolicy;\n        const mode = attributes.mode;\n        const nearestMode = attributes.nearestMode === "" ? "simple" : attributes.nearestMode;\n        return createAttributeWithCacheKey({\n          antialias,\n          axes,\n          coordinateTransformMode,\n          cubicCoeffA,\n          excludeOutside,\n          extrapolationValue,\n          keepAspectRatioPolicy,\n          mode,\n          nearestMode\n        });\n      };\n    }\n  });\n\n  // web/lib/wasm/jsep/webgpu/ops/skip-layer-norm.ts\n  var validateInputs20, createSkipLayerNormProgramInfo, skipLayerNorm, parseSkipLayerNormAttributes;\n  var init_skip_layer_norm = __esm({\n    "web/lib/wasm/jsep/webgpu/ops/skip-layer-norm.ts"() {\n      "use strict";\n      init_wasm_common();\n      init_util();\n      init_attribute_with_cache_key();\n      init_common();\n      validateInputs20 = (inputs) => {\n        if (!inputs || inputs.length < 3) {\n          throw new Error("layerNorm requires at least 3 inputs.");\n        }\n        const input = inputs[0];\n        const skip = inputs[1];\n        const gamma = inputs[2];\n        if (input.dataType !== skip.dataType || input.dataType !== gamma.dataType) {\n          throw new Error("All inputs must have the same data type");\n        }\n        if (input.dims.length !== 3 && input.dims.length !== 2) {\n          throw new Error("Input must be 2D or 3D");\n        }\n        if (skip.dims.length !== 3 && skip.dims.length !== 2) {\n          throw new Error("Skip must be 2D or 3D");\n        }\n        const hiddenSize = input.dims[input.dims.length - 1];\n        const sequenceLength = input.dims[input.dims.length - 2];\n        if (skip.dims[skip.dims.length - 1] !== hiddenSize) {\n          throw new Error("Skip must have the same hidden size as input");\n        }\n        if (skip.dims[skip.dims.length - 2] !== sequenceLength) {\n          throw new Error("Skip must have the same sequence length as input");\n        }\n        if (gamma.dims.length !== 1) {\n          throw new Error("Gamma must be 1D");\n        }\n        if (gamma.dims[gamma.dims.length - 1] !== hiddenSize) {\n          throw new Error("Gamma must have the same hidden size as input");\n        }\n        if (inputs.length > 3) {\n          const beta = inputs[3];\n          if (beta.dims.length !== 1) {\n            throw new Error("Beta must be 1D");\n          }\n          if (beta.dims[beta.dims.length - 1] !== hiddenSize) {\n            throw new Error("Beta must have the same hidden size as input");\n          }\n        }\n        if (inputs.length > 4) {\n          const bias = inputs[4];\n          if (bias.dims.length !== 1) {\n            throw new Error("Bias must be 1D");\n          }\n          if (bias.dims[bias.dims.length - 1] !== hiddenSize) {\n            throw new Error("Bias must have the same hidden size as input");\n          }\n        }\n      };\n      createSkipLayerNormProgramInfo = (inputs, attributes, outputCount, isTraining) => {\n        const inputShape = inputs[0].dims;\n        const inputSize = ShapeUtil.size(inputShape);\n        const outputShape = inputShape;\n        const outputSize = inputSize;\n        const hiddenSize = inputShape.slice(-1)[0];\n        const meanInvStdDevDim = isTraining ? inputShape.slice(0, -1).concat(1) : [];\n        const hasBetaInput = inputs.length > 3;\n        const hasBiasInput = inputs.length > 4;\n        const hasMeanOutput = isTraining && outputCount > 1;\n        const hasInvStdDevOutput = isTraining && outputCount > 2;\n        const hasInputSkipBiasSumOutput = outputCount > 3;\n        const components = getMaxComponents(hiddenSize);\n        const variables = [\n          inputVariable("x", inputs[0].dataType, inputs[0].dims, components),\n          inputVariable("skip", inputs[1].dataType, inputs[1].dims, components),\n          inputVariable("gamma", inputs[2].dataType, inputs[2].dims, components)\n        ];\n        if (hasBetaInput) {\n          variables.push(inputVariable("beta", inputs[3].dataType, inputs[3].dims, components));\n        }\n        if (hasBiasInput) {\n          variables.push(inputVariable("bias", inputs[4].dataType, inputs[4].dims, components));\n        }\n        variables.push(outputVariable("output", inputs[0].dataType, outputShape, components));\n        if (hasMeanOutput) {\n          variables.push(outputVariable("meanOutput", 1 /* float */, meanInvStdDevDim));\n        }\n        if (hasInvStdDevOutput) {\n          variables.push(outputVariable("invStdOutput", 1 /* float */, meanInvStdDevDim));\n        }\n        if (hasInputSkipBiasSumOutput) {\n          variables.push(outputVariable("inputSkipBiasSum", inputs[0].dataType, outputShape, components));\n        }\n        const dataType = tensorTypeToWsglStorageType(inputs[0].dataType);\n        const getShaderSource = (shaderHelper) => `\n      const hiddenSize: f32 = ${hiddenSize};\n      const hiddenSizeVectorized: u32 = ${hiddenSize / components};\n      const epsilon: f32 = ${attributes.epsilon};\n\n      ${shaderHelper.declareVariables(...variables)}\n\n      ${shaderHelper.mainStart()}\n        ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes(outputSize / hiddenSize)}\n        let offset = global_idx * hiddenSizeVectorized;\n        var sum = ${fillVector("f32", components)};\n        var squareSum = ${fillVector("f32", components)};\n        for (var i: u32 = 0; i < hiddenSizeVectorized; i++) {\n          let skipValue = skip[offset + i];\n          let biasValue = ${hasBiasInput ? "bias[i]" : "0.0"};\n          let inputValue = x[offset + i];\n          let value = inputValue + skipValue + biasValue;\n          ${hasInputSkipBiasSumOutput ? "inputSkipBiasSum[offset + i] = value;" : ""}\n          output[offset + i] = value;\n          let f32Value = ${castToF32(dataType, components, "value")};\n          sum += f32Value;\n          squareSum += f32Value * f32Value;\n        }\n        let mean = ${sumVector("sum", components)} / hiddenSize;\n        let invStdDev = inverseSqrt(${sumVector("squareSum", components)} / hiddenSize - mean * mean + epsilon);\n        ${hasMeanOutput ? "meanOutput[global_idx] = mean;" : ""}\n        ${hasInvStdDevOutput ? "invStdOutput[global_idx] = invStdDev;" : ""}\n        for (var i: u32 = 0; i < hiddenSizeVectorized; i++) {\n          output[offset + i] = (output[offset + i] - ${dataType}(mean)) * ${dataType}(invStdDev) * gamma[i]\n           + ${hasBetaInput ? "beta[i]" : "0.0"};\n        }\n      }`;\n        const outputs = [{ dims: outputShape, dataType: inputs[0].dataType }];\n        if (outputCount > 1) {\n          outputs.push({ dims: meanInvStdDevDim, dataType: 1 /* float */ });\n        }\n        if (outputCount > 2) {\n          outputs.push({ dims: meanInvStdDevDim, dataType: 1 /* float */ });\n        }\n        if (outputCount > 3) {\n          outputs.push({ dims: inputShape, dataType: inputs[0].dataType });\n        }\n        return {\n          name: "SkipLayerNormalization",\n          shaderCache: { hint: attributes.cacheKey },\n          getShaderSource,\n          getRunData: () => ({ outputs, dispatchGroup: { x: Math.ceil(outputSize / hiddenSize / 64) } })\n        };\n      };\n      skipLayerNorm = (context, attributes) => {\n        const isTraining = false;\n        validateInputs20(context.inputs);\n        const outputs = [0];\n        if (context.outputCount > 1) {\n          outputs.push(isTraining ? 1 : -3);\n        }\n        if (context.outputCount > 2) {\n          outputs.push(isTraining ? 2 : -3);\n        }\n        if (context.outputCount > 3) {\n          outputs.push(3);\n        }\n        context.compute(\n          createSkipLayerNormProgramInfo(context.inputs, attributes, context.outputCount, isTraining),\n          { outputs }\n        );\n      };\n      parseSkipLayerNormAttributes = (attributes) => {\n        const epsilon = attributes.epsilon;\n        return createAttributeWithCacheKey({ epsilon });\n      };\n    }\n  });\n\n  // web/lib/wasm/jsep/webgpu/ops/slice.ts\n  var validateInputs21, readInput, createSliceAttributesFromInputs, fixStartEndValues, calculateInputIndicesImpl, createSliceProgramInfo, slice, parseSliceAttributes;\n  var init_slice = __esm({\n    "web/lib/wasm/jsep/webgpu/ops/slice.ts"() {\n      "use strict";\n      init_wasm_common();\n      init_util();\n      init_attribute_with_cache_key();\n      init_common();\n      validateInputs21 = (inputs, attributes) => {\n        if (!inputs || inputs.length < 1) {\n          throw new Error("too few inputs");\n        }\n        if (attributes.axes.length !== 0) {\n          if (attributes.axes.length !== attributes.starts.length || attributes.axes.length !== attributes.ends.length) {\n            throw new Error("axes, starts and ends must have the same length");\n          }\n        } else if (attributes.starts.length !== attributes.ends.length) {\n          throw new Error("starts and ends must have the same length");\n        }\n        inputs.slice(1).forEach((_, idx) => {\n          if (inputs[idx + 1].dataType !== 6 /* int32 */ && inputs[idx + 1].dataType !== 7 /* int64 */) {\n            throw new Error(`Input ${idx} must be an array of int32 or int64`);\n          }\n        });\n      };\n      readInput = (inputs, idx) => {\n        const input = [];\n        if (inputs.length > idx) {\n          if (inputs[idx].dataType === 7 /* int64 */) {\n            inputs[idx].getBigInt64Array().forEach((v) => input.push(Number(v)));\n          } else if (inputs[idx].dataType === 6 /* int32 */) {\n            inputs[idx].getInt32Array().forEach((v) => input.push(Number(v)));\n          } else {\n            throw new Error(`Input ${idx} must be an array of int32 or int64`);\n          }\n        }\n        return input;\n      };\n      createSliceAttributesFromInputs = (inputs, attributes) => {\n        if (inputs.length > 1) {\n          const starts = readInput(inputs, 1);\n          const ends = readInput(inputs, 2);\n          let axes = readInput(inputs, 3);\n          if (axes.length === 0) {\n            axes = [...Array(inputs[0].dims.length).keys()];\n          }\n          return createAttributeWithCacheKey({ starts, ends, axes });\n        } else {\n          return attributes;\n        }\n      };\n      fixStartEndValues = (value, index, inputShape, axes, steps) => {\n        let newValue = value;\n        if (value < 0) {\n          newValue += inputShape[axes[index]];\n        }\n        if (steps[index] < 0) {\n          return Math.max(0, Math.min(newValue, inputShape[axes[index]] - 1));\n        } else {\n          return Math.max(0, Math.min(newValue, inputShape[axes[index]]));\n        }\n      };\n      calculateInputIndicesImpl = (input, output, inputShape) => `fn calculateInputIndices(output_indices: ${output.type.indices}) -> ${input.type.indices} {\n          var input_indices: ${input.type.indices};\n          var carry = 0u;\n          for (var i = ${inputShape.length}; i >= 0; i--) {\n            let input_shape_i = ${getElementAt("uniforms.input_shape", "i", inputShape.length)};\n            let steps_i = ${getElementAt("uniforms.steps", "i", inputShape.length)};\n            let signs_i = ${getElementAt("uniforms.signs", "i", inputShape.length)};\n            let starts_i = ${getElementAt("uniforms.starts", "i", inputShape.length)};\n            var output_index = ${output.indicesGet("output_indices", "i")};\n            var input_index = output_index * steps_i + starts_i + carry;\n            carry = input_index / input_shape_i;\n            input_index = input_index % input_shape_i;\n            if (signs_i < 0) {\n              input_index = input_shape_i - input_index - 1u + starts_i;\n            }\n            ${input.indicesSet("input_indices", "i", "input_index")};\n          }\n          return input_indices;\n      }`;\n      createSliceProgramInfo = (inputs, attributes) => {\n        const inputShape = inputs[0].dims;\n        const inputSize = ShapeUtil.size(inputShape);\n        const axes = attributes.axes.length > 0 ? ShapeUtil.normalizeAxes(attributes.axes, inputShape.length) : [...Array(inputShape.length).keys()];\n        let steps = readInput(inputs, 4);\n        steps.forEach((step) => step !== 0 || (() => {\n          throw new Error("step cannot be 0");\n        }));\n        if (steps.length === 0) {\n          steps = Array(axes.length).fill(1);\n        }\n        const starts = attributes.starts.map((start, i) => fixStartEndValues(start, i, inputShape, axes, steps));\n        const ends = attributes.ends.map((end, i) => fixStartEndValues(end, i, inputShape, axes, steps));\n        if (axes.length !== starts.length || axes.length !== ends.length) {\n          throw new Error("start, ends and axes should have the same number of elements");\n        }\n        if (axes.length !== inputShape.length) {\n          for (let i = 0; i < inputShape.length; ++i) {\n            if (!axes.includes(i)) {\n              starts.splice(i, 0, 0);\n              ends.splice(i, 0, inputShape[i]);\n              steps.splice(i, 0, 1);\n            }\n          }\n        }\n        const signs = steps.map((step) => Math.sign(step));\n        steps.forEach((step, i, array) => {\n          if (step < 0) {\n            const numSteps = (ends[i] - starts[i]) / step;\n            const newEnd = starts[i];\n            const newStart = newEnd + numSteps * steps[i];\n            starts[i] = newStart;\n            ends[i] = newEnd;\n            array[i] = -step;\n          }\n        });\n        const outputShape = inputShape.slice(0);\n        axes.forEach((axis, _) => {\n          outputShape[axis] = Math.ceil((ends[axis] - starts[axis]) / steps[axis]);\n        });\n        const outputTensorInfo = { dims: outputShape, dataType: inputs[0].dataType };\n        const output = outputVariable("output", inputs[0].dataType, outputShape.length);\n        const input = inputVariable("input", inputs[0].dataType, inputs[0].dims.length);\n        const outputSize = ShapeUtil.size(outputShape);\n        const uniforms = [\n          { name: "outputSize", type: "u32" },\n          { name: "starts", type: "u32", length: starts.length },\n          { name: "signs", type: "i32", length: signs.length },\n          { name: "steps", type: "u32", length: steps.length }\n        ];\n        const programUniforms = [\n          { type: "uint32", data: outputSize },\n          { type: "uint32", data: starts },\n          { type: "int32", data: signs },\n          { type: "uint32", data: steps },\n          ...createTensorShapeVariables(inputs[0].dims),\n          ...createTensorShapeVariables(outputShape)\n        ];\n        const getShaderSource = (shaderHelper) => `\n      ${shaderHelper.registerUniforms(uniforms).declareVariables(input, output)}\n        ${calculateInputIndicesImpl(input, output, inputShape)}\n        ${shaderHelper.mainStart()}\n          ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n          let output_indices = ${output.offsetToIndices("global_idx")};\n          let input_indices = calculateInputIndices(output_indices);\n          ${output.setByOffset("global_idx", input.getByIndices("input_indices"))}\n      }`;\n        return {\n          name: "Slice",\n          shaderCache: { hint: `${signs.length}_${starts.length}_${steps.length}`, inputDependencies: ["rank"] },\n          getShaderSource,\n          getRunData: () => ({\n            outputs: [outputTensorInfo],\n            dispatchGroup: { x: Math.ceil(\n              inputSize / 64\n              /* workgroup size */\n            ) },\n            programUniforms\n          })\n        };\n      };\n      slice = (context, attributes) => {\n        validateInputs21(context.inputs, attributes);\n        const updatedAttributes = createSliceAttributesFromInputs(context.inputs, attributes);\n        context.compute(createSliceProgramInfo(context.inputs, updatedAttributes), { inputs: [0] });\n      };\n      parseSliceAttributes = (attributes) => {\n        const starts = attributes.starts;\n        const ends = attributes.ends;\n        const axes = attributes.axes;\n        return createAttributeWithCacheKey({ starts, ends, axes });\n      };\n    }\n  });\n\n  // web/lib/wasm/jsep/webgpu/ops/softmax.ts\n  var validateInputs22, createSoftmaxProgramInfo, softmax, parseSoftmaxAttributes;\n  var init_softmax = __esm({\n    "web/lib/wasm/jsep/webgpu/ops/softmax.ts"() {\n      "use strict";\n      init_util();\n      init_attribute_with_cache_key();\n      init_common();\n      validateInputs22 = (inputs) => {\n        if (!inputs || inputs.length !== 1) {\n          throw new Error("Softmax op requires 1 input.");\n        }\n      };\n      createSoftmaxProgramInfo = (input, attributes) => {\n        const shape = input.dims;\n        const outputSize = ShapeUtil.size(shape);\n        const WG = 64;\n        let axis = attributes.axis;\n        if (axis < 0) {\n          axis = shape.length + axis;\n        }\n        if (axis < shape.length - 1) {\n          throw new Error("softmax only supports last axis for now.");\n        }\n        const cols = shape[axis];\n        const rows = outputSize / cols;\n        const components = getMaxComponents(cols);\n        const packedCols = cols / components;\n        const maxVector = (name, components2) => {\n          if (components2 === 4) {\n            return `max(max(${name}.x, ${name}.y), max(${name}.z, ${name}.w))`;\n          } else if (components2 === 2) {\n            return `max(${name}.x, ${name}.y)`;\n          } else if (components2 === 3) {\n            return `max(max(${name}.x, ${name}.y), ${name}.z)`;\n          }\n          return name;\n        };\n        const x = inputVariable("x", input.dataType, input.dims, components);\n        const output = outputVariable("result", input.dataType, input.dims, components);\n        const valueType = x.type.value;\n        const threadMaxDecl = tensorTypeToWsglStorageType(input.dataType) === "f32" ? `var threadMax = ${valueType}(-3.402823e+38f);` : `var threadMax = ${valueType}(-65504.0h);`;\n        const getShaderSource = (shaderHelper) => `\n      var<workgroup> rowMaxShared : ${valueType};\n      var<workgroup> rowSumShared : ${valueType};\n      var<workgroup> threadShared : array<${valueType}, ${WG}>;\n\n      fn getValue(row: i32, col: i32, row_stride: i32) -> ${valueType} {\n        let index = row * row_stride + col;\n        return x[index];\n      }\n\n      fn setValue(row: i32, col: i32, row_stride: i32, value: ${valueType}) {\n        let index = row * row_stride + col;\n        result[index] = value;\n      }\n      ${shaderHelper.registerUniform("packedCols", "i32").declareVariables(x, output)}\n      ${shaderHelper.mainStart()}\n        let gindex = i32(global_idx);\n        let lindex = i32(local_idx);\n        const wg = ${WG};\n        let row = gindex / wg;\n        let cols = uniforms.packedCols;\n        let row_stride : i32 = uniforms.packedCols;\n\n        // find the rows max\n        ${threadMaxDecl}\n        for (var col = lindex; col < cols; col += wg) {\n          let value = getValue(row, col, row_stride);\n          threadMax = max(threadMax, value);\n        }\n        if (lindex < cols) {\n          threadShared[lindex] = threadMax;\n        }\n        workgroupBarrier();\n\n        var reduceSize = min(cols, wg);\n        for (var currSize = reduceSize >> 1;  currSize > 0; currSize = reduceSize >> 1) {\n          reduceSize = currSize + (reduceSize & 1);\n          if (lindex < currSize) {\n            threadShared[lindex] = max(threadShared[lindex], threadShared[lindex + reduceSize]);\n          }\n          workgroupBarrier();\n        }\n        if (lindex == 0) {\n          rowMaxShared = ${valueType}(${maxVector("threadShared[0]", components)});\n        }\n        workgroupBarrier();\n\n        // find the rows sum\n        var threadSum = ${valueType}(0.0);\n        for (var col = lindex; col < cols; col += wg) {\n          let subExp = exp(getValue(row, col, row_stride) - rowMaxShared);\n          threadSum += subExp;\n        }\n        threadShared[lindex] = threadSum;\n        workgroupBarrier();\n\n        for (var currSize = wg >> 1;  currSize > 0; currSize = currSize >> 1) {\n          if (lindex < currSize) {\n            threadShared[lindex] = threadShared[lindex] + threadShared[lindex + currSize];\n          }\n          workgroupBarrier();\n        }\n        if (lindex == 0) {\n          rowSumShared = ${valueType}(${sumVector("threadShared[0]", components)});\n        }\n        workgroupBarrier();\n\n        // calculate final value for each element in the row\n        for (var col = lindex; col < cols; col += wg) {\n          let value = exp(getValue(row, col, row_stride) - rowMaxShared) / rowSumShared;\n          setValue(row, col, row_stride, value);\n        }\n      }`;\n        return {\n          name: "Softmax",\n          shaderCache: { hint: `${components}`, inputDependencies: ["type"] },\n          getRunData: () => ({\n            outputs: [{ dims: shape, dataType: input.dataType }],\n            dispatchGroup: { x: rows },\n            programUniforms: [{ type: "uint32", data: packedCols }]\n          }),\n          getShaderSource\n        };\n      };\n      softmax = (context, attributes) => {\n        validateInputs22(context.inputs);\n        context.compute(createSoftmaxProgramInfo(context.inputs[0], attributes));\n      };\n      parseSoftmaxAttributes = (attributes) => createAttributeWithCacheKey({ axis: attributes.axis });\n    }\n  });\n\n  // web/lib/wasm/jsep/webgpu/ops/split.ts\n  var validateInputs23, createSplitAttributesFromInputs, calculateOutputIndexImpl, writeBufferDataImpl, createSplitProgramInfo, split, parseSplitAttributes;\n  var init_split = __esm({\n    "web/lib/wasm/jsep/webgpu/ops/split.ts"() {\n      "use strict";\n      init_util();\n      init_attribute_with_cache_key();\n      init_common();\n      validateInputs23 = (inputs) => {\n        if (!inputs || inputs.length < 1) {\n          throw new Error("too few inputs");\n        }\n      };\n      createSplitAttributesFromInputs = (inputs, attributes) => {\n        const splitSizes = [];\n        let numOutputs = attributes.numOutputs;\n        if (inputs[1].dims[0] > 0) {\n          inputs[1].getBigInt64Array().forEach((v) => splitSizes.push(Number(v)));\n          numOutputs = splitSizes.length;\n        }\n        return createAttributeWithCacheKey({ numOutputs, axis: attributes.axis, splitSizes });\n      };\n      calculateOutputIndexImpl = (numberOfTensors) => `\nfn calculateOutputIndex(index: u32) -> u32 {\n    for (var i: u32 = 0u; i < ${numberOfTensors}u; i += 1u ) {\n    if (index < ${getElementAt("uniforms.size_in_split_axis", "i", numberOfTensors)}) {\n        return i;\n    }\n    }\n    return ${numberOfTensors}u;\n}`;\n      writeBufferDataImpl = (outputs) => {\n        const numberOfTensors = outputs.length;\n        const codeLines = [];\n        for (let i = 0; i < numberOfTensors; ++i) {\n          const returnSnippet = outputs[i].setByIndices("indices", "input[global_idx]");\n          if (numberOfTensors === 1) {\n            codeLines.push(returnSnippet);\n          } else if (i === 0) {\n            codeLines.push(`if (output_number == ${i}u) { ${returnSnippet} }`);\n          } else if (i === numberOfTensors - 1) {\n            codeLines.push(`else { ${returnSnippet} }`);\n          } else {\n            codeLines.push(`else if (output_number == ${i}) { ${returnSnippet} }`);\n          }\n        }\n        return `\n      fn writeBufferData(output_number: u32, indices: ${outputs[0].type.indices}, global_idx: u32) {\n        ${codeLines.join("\\n")}\n      }`;\n      };\n      createSplitProgramInfo = (inputs, attributes) => {\n        const inputShape = inputs[0].dims;\n        const inputSize = ShapeUtil.size(inputShape);\n        const dataType = inputs[0].dataType;\n        const axis = ShapeUtil.normalizeAxis(attributes.axis, inputShape.length);\n        const outputs = new Array(attributes.numOutputs);\n        const input = inputVariable("input", dataType, inputShape);\n        const sizeInSplitAxis = new Array(attributes.numOutputs);\n        const outputsTensorInfo = [];\n        const outputShapes = [];\n        let previousSum = 0;\n        const programUniforms = [{ type: "uint32", data: inputSize }];\n        for (let i = 0; i < attributes.numOutputs; i++) {\n          previousSum += attributes.splitSizes[i];\n          sizeInSplitAxis[i] = previousSum;\n          const outputShape = inputShape.slice();\n          outputShape[attributes.axis] = attributes.splitSizes[i];\n          outputShapes.push(outputShape);\n          outputs[i] = outputVariable(`output${i}`, dataType, outputShape);\n          outputsTensorInfo.push({ dims: outputShapes[i], dataType: inputs[0].dataType });\n        }\n        programUniforms.push({ type: "uint32", data: sizeInSplitAxis });\n        programUniforms.push(...createTensorShapeVariables(inputShape));\n        outputShapes.forEach((outputShape) => programUniforms.push(...createTensorShapeVariables(outputShape)));\n        const getShaderSource = (shaderHelper) => `\n  ${shaderHelper.registerUniform("input_size", "u32").registerUniform("size_in_split_axis", "u32", sizeInSplitAxis.length).declareVariables(input, ...outputs)}\n  ${calculateOutputIndexImpl(sizeInSplitAxis.length)}\n  ${writeBufferDataImpl(outputs)}\n\n  ${shaderHelper.mainStart()}\n    ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.input_size")}\n\n    var indices = ${input.offsetToIndices("global_idx")};\n    var index = ${input.indicesGet("indices", axis)};\n    let output_number = calculateOutputIndex(index);\n    if (output_number != 0) {\n      index -= ${getElementAt("uniforms.size_in_split_axis", "output_number - 1u", sizeInSplitAxis.length)};\n      ${input.indicesSet("indices", axis, "index")};\n    }\n    writeBufferData(output_number, indices, global_idx);\n  }`;\n        return {\n          name: "Split",\n          shaderCache: { hint: attributes.cacheKey, inputDependencies: ["rank"] },\n          getShaderSource,\n          getRunData: () => ({\n            outputs: outputsTensorInfo,\n            dispatchGroup: { x: Math.ceil(\n              inputSize / 64\n              /* workgroup size */\n            ) },\n            programUniforms\n          })\n        };\n      };\n      split = (context, attributes) => {\n        validateInputs23(context.inputs);\n        const updatedAttributes = context.inputs.length === 1 ? attributes : createSplitAttributesFromInputs(context.inputs, attributes);\n        context.compute(createSplitProgramInfo(context.inputs, updatedAttributes), { inputs: [0] });\n      };\n      parseSplitAttributes = (attributes) => {\n        const axis = attributes.axis;\n        const splitSizes = attributes.splitSizes;\n        const numOutputs = attributes.numOutputs < 0 ? splitSizes.length : attributes.numOutputs;\n        if (numOutputs !== splitSizes.length) {\n          throw new Error("numOutputs and splitSizes lengh must be equal");\n        }\n        return createAttributeWithCacheKey({ axis, numOutputs, splitSizes });\n      };\n    }\n  });\n\n  // web/lib/wasm/jsep/webgpu/ops/tile.ts\n  var getRepeats, validateInputs24, getOutputShape2, createTileProgramInfo, tile;\n  var init_tile = __esm({\n    "web/lib/wasm/jsep/webgpu/ops/tile.ts"() {\n      "use strict";\n      init_wasm_common();\n      init_util();\n      init_common();\n      getRepeats = (repeatsTensorView) => Array.from(repeatsTensorView.getBigInt64Array(), Number);\n      validateInputs24 = (inputs) => {\n        if (!inputs || inputs.length !== 2) {\n          throw new Error("Tile requires 2 inputs.");\n        }\n        if (inputs[0].dataType !== 1 /* float */ && inputs[0].dataType !== 6 /* int32 */ && inputs[0].dataType !== 12 /* uint32 */) {\n          throw new Error("Tile only support float, int32, and uint32 data types");\n        }\n        if (inputs[1].dataType !== 7 /* int64 */) {\n          throw new Error("Tile `repeats` input should be of int64 data type");\n        }\n        if (inputs[1].dims.length !== 1) {\n          throw new Error("Tile `repeats` input should be 1-D");\n        }\n        const repeats = getRepeats(inputs[1]);\n        if (repeats.length !== inputs[0].dims.length) {\n          throw new Error("Tile `repeats` input should have same number of elements as rank of input data tensor");\n        }\n      };\n      getOutputShape2 = (inputShape, repeats) => {\n        const outputShape = [];\n        for (let i = 0; i < inputShape.length; ++i) {\n          outputShape.push(inputShape[i] * repeats[i]);\n        }\n        return outputShape;\n      };\n      createTileProgramInfo = (inputs) => {\n        const inputShape = inputs[0].dims;\n        const repeats = getRepeats(inputs[1]);\n        const outputShape = getOutputShape2(inputShape, repeats);\n        const outputSize = ShapeUtil.size(outputShape);\n        const dataType = inputs[0].dataType;\n        const input = inputVariable("input", dataType, inputShape.length);\n        const output = outputVariable("output", dataType, outputShape.length);\n        const getShaderSource = (shaderHelper) => `\n      const inputShape = ${input.indices(...inputShape)};\n      ${shaderHelper.registerUniform("output_size", "u32").declareVariables(input, output)}\n      ${shaderHelper.mainStart()}\n      ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n      let output_indices = ${output.offsetToIndices("global_idx")};\n      var input_indices: ${input.type.indices};\n      for (var i = 0; i < ${inputShape.length}; i++) {\n        let input_dim_i = ${input.indicesGet("uniforms.input_shape", "i")};\n        let input_dim_value = ${output.indicesGet("output_indices", "i")}  % input_dim_i;\n\n        ${input.indicesSet("input_indices", "i", "input_dim_value")}\n      }\n      ${output.setByOffset("global_idx", input.getByIndices("input_indices"))}\n    }`;\n        return {\n          name: "Tile",\n          shaderCache: { hint: `${repeats}`, inputDependencies: ["rank"] },\n          getRunData: () => ({\n            outputs: [{ dims: outputShape, dataType: inputs[0].dataType }],\n            dispatchGroup: { x: Math.ceil(\n              outputSize / 64\n              /* workgroup size */\n            ) },\n            programUniforms: [\n              { type: "uint32", data: outputSize },\n              ...createTensorShapeVariables(inputs[0].dims),\n              ...createTensorShapeVariables(outputShape)\n            ]\n          }),\n          getShaderSource\n        };\n      };\n      tile = (context) => {\n        validateInputs24(context.inputs);\n        context.compute(createTileProgramInfo(context.inputs), { inputs: [0] });\n      };\n    }\n  });\n\n  // web/lib/wasm/jsep/webgpu/ops/where.ts\n  var createWhereOpProgramShader, createWhereOpProgramInfo, where;\n  var init_where = __esm({\n    "web/lib/wasm/jsep/webgpu/ops/where.ts"() {\n      "use strict";\n      init_wasm_common();\n      init_util();\n      init_common();\n      createWhereOpProgramShader = (shaderHelper, inputs, dimsOutput, isBroadcast, typeOutput) => {\n        const output = outputVariable("output_data", typeOutput, dimsOutput.length, 4);\n        const a = inputVariable("a_data", inputs[1].dataType, inputs[1].dims.length, 4);\n        const b = inputVariable("b_data", inputs[2].dataType, inputs[2].dims.length, 4);\n        const c = inputVariable("c_data", inputs[0].dataType, inputs[0].dims.length, 4);\n        let assignment;\n        const expression = (a2, b2, c2) => `select(${b2}, ${a2}, ${c2})`;\n        if (!isBroadcast) {\n          assignment = output.setByOffset(\n            "global_idx",\n            expression(a.getByOffset("global_idx"), b.getByOffset("global_idx"), c.getByOffset("global_idx"))\n          );\n        } else {\n          const singleAssignment = (resStr, x, typeCast = "") => {\n            const expressionA = `a_data[index_a${x}][component_a${x}]`;\n            const expressionB = `b_data[index_b${x}][component_b${x}]`;\n            const expressionC = `bool(c_data[index_c${x}] & ${4278190080 >>> (3 - x) * 8}u)`;\n            return `\n            let output_indices${x} = ${output.offsetToIndices(`global_idx * 4u + ${x}u`)};\n            let offset_a${x} = ${a.broadcastedIndicesToOffset(`output_indices${x}`, output)};\n            let offset_b${x} = ${b.broadcastedIndicesToOffset(`output_indices${x}`, output)};\n            let offset_c${x} = ${c.broadcastedIndicesToOffset(`output_indices${x}`, output)};\n            let index_a${x} = offset_a${x} / 4u;\n            let index_b${x} = offset_b${x} / 4u;\n            let index_c${x} = offset_c${x} / 4u;\n            let component_a${x} = offset_a${x} % 4u;\n            let component_b${x} = offset_b${x} % 4u;\n            ${resStr}[${x}] = ${typeCast}(${expression(expressionA, expressionB, expressionC)});\n          `;\n          };\n          if (typeOutput === 9 /* bool */) {\n            assignment = `\n            var data = vec4<u32>(0);\n            ${singleAssignment("data", 0, "u32")}\n            ${singleAssignment("data", 1, "u32")}\n            ${singleAssignment("data", 2, "u32")}\n            ${singleAssignment("data", 3, "u32")}\n            output_data[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`;\n          } else {\n            assignment = `\n            ${singleAssignment("output_data[global_idx]", 0)}\n            ${singleAssignment("output_data[global_idx]", 1)}\n            ${singleAssignment("output_data[global_idx]", 2)}\n            ${singleAssignment("output_data[global_idx]", 3)}\n          `;\n          }\n        }\n        return `\n        ${shaderHelper.registerUniform("vec_size", "u32").declareVariables(c, a, b, output)}\n        ${shaderHelper.mainStart()}\n        ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}\n        ${assignment}\n      }`;\n      };\n      createWhereOpProgramInfo = (inputs) => {\n        const dimsA = inputs[1].dims;\n        const dimsB = inputs[2].dims;\n        const dimsC = inputs[0].dims;\n        const outputDataType = inputs[1].dataType;\n        const isBroadcast = !(ShapeUtil.areEqual(dimsA, dimsB) && ShapeUtil.areEqual(dimsB, dimsC));\n        let outputShape = dimsA;\n        let outputSize = ShapeUtil.size(dimsA);\n        if (isBroadcast) {\n          const calculatedShape = BroadcastUtil.calcShape(BroadcastUtil.calcShape(dimsA, dimsB, false), dimsC, false);\n          if (!calculatedShape) {\n            throw new Error("Can\'t perform where op on the given tensors");\n          }\n          outputShape = calculatedShape;\n          outputSize = ShapeUtil.size(outputShape);\n        }\n        const vecSize = Math.ceil(outputSize / 4);\n        return {\n          name: "Where",\n          shaderCache: { inputDependencies: ["rank", "rank", "rank"] },\n          getShaderSource: (shaderHelper) => createWhereOpProgramShader(shaderHelper, inputs, outputShape, isBroadcast, outputDataType),\n          getRunData: () => ({\n            outputs: [{ dims: outputShape, dataType: outputDataType }],\n            dispatchGroup: { x: Math.ceil(\n              outputSize / 64 / 4\n              /* vec size */\n            ) },\n            programUniforms: [\n              { type: "uint32", data: vecSize },\n              ...createTensorShapeVariables(dimsC),\n              ...createTensorShapeVariables(dimsA),\n              ...createTensorShapeVariables(dimsB),\n              ...createTensorShapeVariables(outputShape)\n            ]\n          })\n        };\n      };\n      where = (context) => {\n        context.compute(createWhereOpProgramInfo(context.inputs));\n      };\n    }\n  });\n\n  // web/lib/wasm/jsep/webgpu/op-resolve-rules.ts\n  var WEBGPU_OP_RESOLVE_RULES;\n  var init_op_resolve_rules = __esm({\n    "web/lib/wasm/jsep/webgpu/op-resolve-rules.ts"() {\n      "use strict";\n      init_argminmax();\n      init_attention();\n      init_batch_norm();\n      init_bias_add();\n      init_bias_split_gelu();\n      init_binary_op();\n      init_concat();\n      init_conv();\n      init_conv_transpose();\n      init_cumsum();\n      init_einsum();\n      init_expand();\n      init_gather();\n      init_gather_elements();\n      init_gemm();\n      init_instance_norm();\n      init_layer_norm();\n      init_matmul();\n      init_multi_head_attentiion();\n      init_pad();\n      init_pool();\n      init_range();\n      init_reduce();\n      init_resize();\n      init_skip_layer_norm();\n      init_slice();\n      init_softmax();\n      init_split();\n      init_tile();\n      init_transpose();\n      init_unary_op();\n      init_where();\n      WEBGPU_OP_RESOLVE_RULES = /* @__PURE__ */ new Map([\n        ["Abs", [abs]],\n        ["Acos", [acos]],\n        ["Acosh", [acosh]],\n        ["Add", [add]],\n        ["ArgMax", [argMax, parseArgMinMaxAttributes]],\n        ["ArgMin", [argMin, parseArgMinMaxAttributes]],\n        ["Asin", [asin]],\n        ["Asinh", [asinh]],\n        ["Atan", [atan]],\n        ["Atanh", [atanh]],\n        ["Attention", [attention]],\n        // TODO: support new attributes for AveragePool-10\n        ["AveragePool", [averagePool, parseAveragePoolAttributes]],\n        ["BatchNormalization", [batchNorm]],\n        ["BiasAdd", [biasAdd]],\n        ["BiasSplitGelu", [biasSplitGelu]],\n        ["Cast", [cast, parseCastAttributes]],\n        ["Ceil", [ceil]],\n        ["Clip", [clip]],\n        ["Concat", [concat, parseConcatAttributes]],\n        ["Conv", [conv, parseConvAttributes]],\n        ["ConvTranspose", [convTranspose, parseConvTransposeAttributes]],\n        ["Cos", [cos]],\n        ["Cosh", [cosh]],\n        ["CumSum", [cumsum, parseCumSumAttributes]],\n        ["Div", [div]],\n        ["Einsum", [einsum, parseEinsumAttributes]],\n        ["Elu", [elu, parseAlphaAttributes]],\n        ["Equal", [equal]],\n        ["Erf", [erf]],\n        ["Exp", [exp]],\n        ["Expand", [expand]],\n        ["Floor", [floor]],\n        ["FusedConv", [conv, parseConvAttributes]],\n        ["Gather", [gather, parseGatherAttributes]],\n        ["GatherElements", [gatherElements, parseGatherElementsAttributes]],\n        ["Gelu", [gelu]],\n        ["Gemm", [gemm, parseGemmAttributes]],\n        ["GlobalAveragePool", [globalAveragePool, parseGlobalAveragePoolAttributes]],\n        ["GlobalMaxPool", [globalMaxPool, parseGlobalMaxPoolAttributes]],\n        ["Greater", [greater]],\n        ["GreaterOrEqual", [greaterOrEqual]],\n        ["InstanceNormalization", [instanceNorm]],\n        ["LayerNormalization", [layerNorm]],\n        ["LeakyRelu", [leakyRelu, parseAlphaAttributes]],\n        ["Less", [less]],\n        ["LessOrEqual", [lessOrEqual]],\n        ["Log", [log]],\n        ["MatMul", [matMul]],\n        // TODO: support new attributes for MaxPool-8 and MaxPool-10\n        ["MaxPool", [maxPool, parseMaxPoolAttributes]],\n        ["Mul", [mul]],\n        ["MultiHeadAttention", [multiHeadAttention, parseMultiHeadAttentionAttributes]],\n        ["Neg", [neg]],\n        ["Not", [not]],\n        ["Pad", [pad]],\n        ["Pow", [pow]],\n        ["Range", [range]],\n        ["Reciprocal", [reciprocal]],\n        ["ReduceMin", [reduceMin]],\n        ["ReduceMean", [reduceMean]],\n        ["ReduceMax", [reduceMax]],\n        ["ReduceSum", [reduceSum]],\n        ["ReduceProd", [reduceProd]],\n        ["ReduceL1", [reduceL1]],\n        ["ReduceL2", [reduceL2]],\n        ["ReduceLogSum", [reduceLogSum]],\n        ["ReduceLogSumExp", [reduceLogSumExp]],\n        ["ReduceSumSquare", [reduceSumSquare]],\n        ["Relu", [relu]],\n        ["Resize", [resize, parseResizeAttributes]],\n        ["Sigmoid", [sigmoid]],\n        ["Sin", [sin]],\n        ["Sinh", [sinh]],\n        ["Slice", [slice, parseSliceAttributes]],\n        ["SkipLayerNormalization", [skipLayerNorm, parseSkipLayerNormAttributes]],\n        ["Split", [split, parseSplitAttributes]],\n        ["Sqrt", [sqrt]],\n        ["Softmax", [softmax, parseSoftmaxAttributes]],\n        ["Sub", [sub]],\n        ["Tan", [tan]],\n        ["Tanh", [tanh]],\n        ["ThresholdedRelu", [thresholdedRelu, parseAlphaAttributes]],\n        ["Tile", [tile]],\n        ["Transpose", [transpose, parseTransposeAttributes]],\n        ["Where", [where]]\n      ]);\n    }\n  });\n\n  // web/lib/wasm/jsep/webgpu/program-manager.ts\n  var ProgramManager;\n  var init_program_manager = __esm({\n    "web/lib/wasm/jsep/webgpu/program-manager.ts"() {\n      "use strict";\n      init_esm();\n      init_log();\n      init_common();\n      ProgramManager = class {\n        constructor(backend) {\n          this.backend = backend;\n          this.repo = /* @__PURE__ */ new Map();\n          this.attributesBound = false;\n        }\n        getArtifact(key) {\n          return this.repo.get(key);\n        }\n        setArtifact(key, artifact) {\n          this.repo.set(key, artifact);\n        }\n        run(buildArtifact, inputs, outputs, dispatchGroup, uniformBufferBinding) {\n          TRACE_FUNC_BEGIN(buildArtifact.programInfo.name);\n          const device = this.backend.device;\n          const computePassEncoder = this.backend.getComputePassEncoder();\n          this.backend.writeTimestamp(this.backend.pendingDispatchNumber * 2);\n          computePassEncoder.setPipeline(buildArtifact.computePipeline);\n          const entries = [];\n          for (const input of inputs) {\n            entries.push({ binding: entries.length, resource: { buffer: input.buffer } });\n          }\n          for (const output of outputs) {\n            entries.push({ binding: entries.length, resource: { buffer: output.buffer } });\n          }\n          if (uniformBufferBinding) {\n            entries.push({ binding: entries.length, resource: uniformBufferBinding });\n          }\n          const bindGroup = device.createBindGroup(\n            { layout: buildArtifact.computePipeline.getBindGroupLayout(0), entries, label: buildArtifact.programInfo.name }\n          );\n          computePassEncoder.setBindGroup(0, bindGroup);\n          computePassEncoder.dispatchWorkgroups(...dispatchGroup);\n          this.backend.writeTimestamp(this.backend.pendingDispatchNumber * 2 + 1);\n          this.backend.pendingDispatchNumber++;\n          if (this.backend.pendingDispatchNumber >= this.backend.maxDispatchNumber || this.backend.queryType === "at-passes") {\n            this.backend.endComputePass();\n          }\n          if (this.backend.pendingDispatchNumber >= this.backend.maxDispatchNumber) {\n            this.backend.flush();\n          }\n          TRACE_FUNC_END(buildArtifact.programInfo.name);\n        }\n        dispose() {\n        }\n        build(programInfo, normalizedDispatchGroupSize) {\n          TRACE_FUNC_BEGIN(programInfo.name);\n          const device = this.backend.device;\n          const extensions = [];\n          if (device.features.has("shader-f16")) {\n            extensions.push("enable f16;");\n          }\n          const shaderHelper = createShaderHelper(normalizedDispatchGroupSize);\n          const userCode = programInfo.getShaderSource(shaderHelper);\n          const code = `${extensions.join("\\n")}\n${shaderHelper.additionalImplementations}\n${userCode}`;\n          const shaderModule = device.createShaderModule({ code, label: programInfo.name });\n          LOG_DEBUG("verbose", () => `[WebGPU] ${programInfo.name} shader code: ${code}`);\n          const computePipeline = device.createComputePipeline(\n            { compute: { module: shaderModule, entryPoint: "main" }, layout: "auto", label: programInfo.name }\n          );\n          TRACE_FUNC_END(programInfo.name);\n          return { programInfo, computePipeline };\n        }\n        normalizeDispatchGroupSize(dispatchGroup) {\n          const x = typeof dispatchGroup === "number" ? dispatchGroup : dispatchGroup.x;\n          const y = typeof dispatchGroup === "number" ? 1 : dispatchGroup.y || 1;\n          const z = typeof dispatchGroup === "number" ? 1 : dispatchGroup.z || 1;\n          const limitPerDimension = this.backend.device.limits.maxComputeWorkgroupsPerDimension;\n          if (x <= limitPerDimension && y <= limitPerDimension && z <= limitPerDimension) {\n            return [x, y, z];\n          }\n          const size = x * y * z;\n          let dispatchAverage = Math.ceil(Math.sqrt(size));\n          if (dispatchAverage > limitPerDimension) {\n            dispatchAverage = Math.ceil(Math.cbrt(size));\n            if (dispatchAverage > limitPerDimension) {\n              throw new Error("Total dispatch size exceeds WebGPU maximum.");\n            }\n            return [dispatchAverage, dispatchAverage, dispatchAverage];\n          } else {\n            return [dispatchAverage, dispatchAverage, 1];\n          }\n        }\n      };\n    }\n  });\n\n  // web/lib/wasm/jsep/backend-webgpu.ts\n  var getProgramInputTensorInfoDependencyKey, getProgramInfoUniqueKey, WebGpuBackend;\n  var init_backend_webgpu = __esm({\n    "web/lib/wasm/jsep/backend-webgpu.ts"() {\n      "use strict";\n      init_esm();\n      init_wasm_common();\n      init_log();\n      init_tensor_view();\n      init_gpu_data_manager();\n      init_op_resolve_rules();\n      init_program_manager();\n      getProgramInputTensorInfoDependencyKey = (inputTensors, inputDependencies) => {\n        if (inputDependencies.length !== inputTensors.length) {\n          throw new Error(`inputDependencies length ${inputDependencies.length} is not equal to inputTensors length ${inputTensors.length}.`);\n        }\n        const inputInfos = [];\n        for (let i = 0; i < inputTensors.length; ++i) {\n          const type = inputTensors[i].dataType;\n          switch (inputDependencies[i]) {\n            case "none": {\n              inputInfos.push("");\n              break;\n            }\n            case "type": {\n              inputInfos.push(`${type}`);\n              break;\n            }\n            case "rank": {\n              const rank = inputTensors[i].dims.length;\n              inputInfos.push(`${type};${rank}`);\n              break;\n            }\n            case "dims": {\n              const dims = inputTensors[i].dims.join(",");\n              inputInfos.push(`${type};${dims}`);\n              break;\n            }\n            default:\n              throw new Error(`unsupported input dependency: ${inputDependencies[i]}`);\n          }\n        }\n        return inputInfos.join("|");\n      };\n      getProgramInfoUniqueKey = (programInfo, inputTensors, is1DimensionDispatch) => {\n        let key = programInfo.name;\n        if (programInfo.shaderCache?.hint) {\n          key += "[" + programInfo.shaderCache.hint + "]";\n        }\n        key += ":" + is1DimensionDispatch + `:${getProgramInputTensorInfoDependencyKey(\n          inputTensors,\n          programInfo.shaderCache?.inputDependencies ?? new Array(inputTensors.length).fill("dims")\n        )}`;\n        return key;\n      };\n      WebGpuBackend = class {\n        constructor() {\n          /**\n           * representing the kernel ID of which is currently being computed (CPU code perspective).\n           * `null` means no kernel is being computed.\n           * only one kernel can be computed at a moment.\n           */\n          this.currentKernelId = null;\n          this.commandEncoder = null;\n          this.computePassEncoder = null;\n          this.maxDispatchNumber = 16;\n          this.pendingDispatchNumber = 0;\n          // info of kernels pending submission for a single batch\n          this.pendingKernels = [];\n          // queryReadBuffer -> pendingKernels mapping for all the batches\n          this.pendingQueries = /* @__PURE__ */ new Map();\n          /**\n           * a SessionID -> a Map of (InputOutputIndex -> [ID, GPUBuffer]) mapping.\n           */\n          this.sessionExternalDataMapping = /* @__PURE__ */ new Map();\n        }\n        /**\n         * get the custom data of the current kernel\n         */\n        get currentKernelCustomData() {\n          if (this.currentKernelId === null) {\n            throw new Error("currentKernelCustomData(): currentKernelId is null. (should not happen)");\n          }\n          let data = this.kernelCustomData.get(this.currentKernelId);\n          if (!data) {\n            data = {};\n            this.kernelCustomData.set(this.currentKernelId, data);\n          }\n          return data;\n        }\n        async initialize(env3, adapter) {\n          this.env = env3;\n          const requiredFeatures = [];\n          const deviceDescriptor = {\n            requiredLimits: {\n              maxComputeWorkgroupStorageSize: adapter.limits.maxComputeWorkgroupStorageSize,\n              maxComputeWorkgroupsPerDimension: adapter.limits.maxComputeWorkgroupsPerDimension,\n              maxStorageBufferBindingSize: adapter.limits.maxStorageBufferBindingSize,\n              maxBufferSize: adapter.limits.maxBufferSize,\n              maxComputeInvocationsPerWorkgroup: adapter.limits.maxComputeInvocationsPerWorkgroup,\n              maxComputeWorkgroupSizeX: adapter.limits.maxComputeWorkgroupSizeX,\n              maxComputeWorkgroupSizeY: adapter.limits.maxComputeWorkgroupSizeY,\n              maxComputeWorkgroupSizeZ: adapter.limits.maxComputeWorkgroupSizeZ\n            },\n            requiredFeatures\n          };\n          if (adapter.features.has("chromium-experimental-timestamp-query-inside-passes")) {\n            requiredFeatures.push("chromium-experimental-timestamp-query-inside-passes");\n          } else if (adapter.features.has("timestamp-query")) {\n            requiredFeatures.push("timestamp-query");\n          }\n          if (adapter.features.has("shader-f16")) {\n            requiredFeatures.push("shader-f16");\n          }\n          this.device = await adapter.requestDevice(deviceDescriptor);\n          this.gpuDataManager = createGpuDataManager(this);\n          this.programManager = new ProgramManager(this);\n          this.kernels = /* @__PURE__ */ new Map();\n          this.kernelPersistentData = /* @__PURE__ */ new Map();\n          this.kernelCustomData = /* @__PURE__ */ new Map();\n          configureLogger(env3.logLevel, !!env3.debug);\n          this.device.onuncapturederror = (ev) => {\n            if (ev.error instanceof GPUValidationError) {\n              console.error(`An uncaught WebGPU validation error was raised: ${ev.error.message}`);\n            }\n          };\n          Object.defineProperty(this.env.webgpu, "device", { value: this.device });\n          this.setQueryType();\n        }\n        dispose() {\n          if (typeof this.querySet !== "undefined") {\n            this.querySet.destroy();\n          }\n          this.gpuDataManager.dispose();\n        }\n        getCommandEncoder() {\n          if (!this.commandEncoder) {\n            this.commandEncoder = this.device.createCommandEncoder();\n            this.setQueryType();\n            if (this.queryType !== "none" && typeof this.querySet === "undefined") {\n              this.querySet = this.device.createQuerySet({\n                type: "timestamp",\n                count: this.maxDispatchNumber * 2\n              });\n              this.queryResolveBuffer = this.device.createBuffer(\n                // eslint-disable-next-line no-bitwise\n                { size: this.maxDispatchNumber * 2 * 8, usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.QUERY_RESOLVE }\n              );\n            }\n          }\n          return this.commandEncoder;\n        }\n        getComputePassEncoder() {\n          if (!this.computePassEncoder) {\n            const computePassDescriptor = {};\n            if (this.queryType === "at-passes") {\n              computePassDescriptor.timestampWrites = {\n                querySet: this.querySet,\n                beginningOfPassWriteIndex: this.pendingDispatchNumber * 2,\n                endOfPassWriteIndex: this.pendingDispatchNumber * 2 + 1\n              };\n            }\n            this.computePassEncoder = this.getCommandEncoder().beginComputePass(computePassDescriptor);\n          }\n          return this.computePassEncoder;\n        }\n        endComputePass() {\n          if (this.computePassEncoder) {\n            this.computePassEncoder.end();\n            this.computePassEncoder = null;\n          }\n        }\n        flush() {\n          if (!this.commandEncoder) {\n            return;\n          }\n          TRACE_FUNC_BEGIN();\n          this.endComputePass();\n          let queryReadBuffer;\n          if (this.queryType !== "none") {\n            this.commandEncoder.resolveQuerySet(\n              this.querySet,\n              0,\n              this.pendingDispatchNumber * 2,\n              this.queryResolveBuffer,\n              0\n            );\n            queryReadBuffer = this.device.createBuffer(\n              // eslint-disable-next-line no-bitwise\n              { size: this.pendingDispatchNumber * 2 * 8, usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST }\n            );\n            this.pendingQueries.set(queryReadBuffer, this.pendingKernels);\n            this.pendingKernels = [];\n            this.commandEncoder.copyBufferToBuffer(\n              this.queryResolveBuffer,\n              0,\n              queryReadBuffer,\n              0,\n              this.pendingDispatchNumber * 2 * 8\n            );\n          }\n          this.device.queue.submit([this.commandEncoder.finish()]);\n          this.gpuDataManager.refreshPendingBuffers();\n          this.commandEncoder = null;\n          this.pendingDispatchNumber = 0;\n          if (this.queryType !== "none") {\n            void queryReadBuffer.mapAsync(GPUMapMode.READ).then(() => {\n              const mappedData = new BigUint64Array(queryReadBuffer.getMappedRange());\n              const pendingKernels = this.pendingQueries.get(queryReadBuffer);\n              for (let i = 0; i < mappedData.length / 2; i++) {\n                const pendingKernelInfo = pendingKernels[i];\n                const kernelId = pendingKernelInfo.kernelId;\n                const kernelInfo = this.kernels.get(kernelId);\n                const kernelType = kernelInfo.kernelType;\n                const kernelName = kernelInfo.kernelName;\n                const programName = pendingKernelInfo.programName;\n                const inputTensorViews = pendingKernelInfo.inputTensorViews;\n                const outputTensorViews = pendingKernelInfo.outputTensorViews;\n                const startTimeU64 = mappedData[i * 2];\n                const endTimeU64 = mappedData[i * 2 + 1];\n                if (typeof this.queryTimeBase === "undefined") {\n                  this.queryTimeBase = startTimeU64;\n                }\n                const startTime = Number(startTimeU64 - this.queryTimeBase);\n                const endTime = Number(endTimeU64 - this.queryTimeBase);\n                if (!Number.isSafeInteger(startTime) || !Number.isSafeInteger(endTime)) {\n                  throw new RangeError("incorrect timestamp range");\n                }\n                if (this.env.webgpu.profiling?.ondata) {\n                  this.env.webgpu.profiling.ondata({\n                    version: 1,\n                    inputsMetadata: inputTensorViews.map(\n                      (value) => ({ dims: value.dims, dataType: tensorDataTypeEnumToString(value.dataType) })\n                    ),\n                    outputsMetadata: outputTensorViews.map(\n                      (value) => ({ dims: value.dims, dataType: tensorDataTypeEnumToString(value.dataType) })\n                    ),\n                    kernelId,\n                    kernelType,\n                    kernelName,\n                    programName,\n                    startTime,\n                    endTime\n                  });\n                } else {\n                  let inputShapes = "";\n                  inputTensorViews.forEach((value, i2) => {\n                    inputShapes += `input[${i2}]: [${value.dims}] | ${tensorDataTypeEnumToString(value.dataType)}, `;\n                  });\n                  let outputShapes = "";\n                  outputTensorViews.forEach((value, i2) => {\n                    outputShapes += `output[${i2}]: [${value.dims}] | ${tensorDataTypeEnumToString(value.dataType)}, `;\n                  });\n                  console.log(`[profiling] kernel "${kernelId}|${kernelType}|${kernelName}|${programName}" ${inputShapes}${outputShapes}execution time: ${endTime - startTime} ns`);\n                }\n                TRACE("GPU", `${programName}::${startTimeU64}::${endTimeU64}`);\n              }\n              queryReadBuffer.unmap();\n              this.pendingQueries.delete(queryReadBuffer);\n            });\n          }\n          TRACE_FUNC_END();\n        }\n        /**\n         * run a WebGPU program.\n         * @param program a ProgramInfo instance\n         * @param inputTensorViews a TensorView array. each element represents a value already exists in GPU.\n         * @param outputIndices an indices array. each element can be either -1 (temporary data), -2 (persistent data) or an\n         * index to the kernel\'s output.\n         * @param createKernelOutput a callback function that create a value to kernel\'s output with the given index\n         * @param createIntermediateOutput a callback function that create a value as a intermediate value, either temporary\n         * or persistent (owned by the current kernel)\n         * @returns a TensorView array representing the result.\n         */\n        run(program, inputTensorViews, outputIndices, createKernelOutput, createIntermediateOutput) {\n          TRACE_FUNC_BEGIN(program.name);\n          const inputDatas = [];\n          for (let i = 0; i < inputTensorViews.length; ++i) {\n            const gpuData = this.gpuDataManager.get(inputTensorViews[i].data);\n            if (!gpuData) {\n              throw new Error(`no GPU data for input: ${inputTensorViews[i].data}`);\n            }\n            inputDatas[i] = gpuData;\n          }\n          const { outputs, dispatchGroup, programUniforms } = program.getRunData(inputTensorViews);\n          const validatedOutputIndices = outputIndices.length === 0 ? outputs.map((_, i) => i) : outputIndices;\n          if (validatedOutputIndices.length !== outputs.length) {\n            throw new Error(`Output size ${validatedOutputIndices.length} must be equal to ${outputs.length}.`);\n          }\n          const outputTensorViews = [];\n          const outputDatas = [];\n          for (let i = 0; i < outputs.length; ++i) {\n            if (!Number.isInteger(validatedOutputIndices[i]) || validatedOutputIndices[i] < -3 || validatedOutputIndices[i] >= outputs.length) {\n              throw new Error(`Invalid output index: ${validatedOutputIndices[i]}`);\n            }\n            if (validatedOutputIndices[i] === -3) {\n              continue;\n            }\n            const isTemporary = validatedOutputIndices[i] === -1;\n            const isPersistent = validatedOutputIndices[i] === -2;\n            const tensorView = isTemporary || isPersistent ? createIntermediateOutput(outputs[i].dataType, outputs[i].dims) : createKernelOutput(validatedOutputIndices[i], outputs[i].dataType, outputs[i].dims);\n            const gpuData = this.gpuDataManager.get(tensorView.data);\n            if (!gpuData) {\n              throw new Error(`no GPU data for output: ${tensorView.data}`);\n            }\n            if (isTemporary) {\n              this.temporaryData.push(gpuData);\n            }\n            if (isPersistent) {\n              let persistentData = this.kernelPersistentData.get(this.currentKernelId);\n              if (!persistentData) {\n                persistentData = [];\n                this.kernelPersistentData.set(this.currentKernelId, persistentData);\n              }\n              persistentData.push(gpuData);\n            }\n            outputTensorViews.push(tensorView);\n            outputDatas.push(gpuData);\n          }\n          let uniformBufferBinding;\n          if (programUniforms) {\n            let currentOffset = 0;\n            const offsets = [];\n            programUniforms.forEach((v) => {\n              const data = typeof v.data === "number" ? [v.data] : v.data;\n              if (data.length === 0) {\n                return;\n              }\n              const baseAlignment = data.length <= 2 ? data.length * 4 : 16;\n              currentOffset = Math.ceil(currentOffset / baseAlignment) * baseAlignment;\n              offsets.push(currentOffset);\n              currentOffset += data.length > 4 ? Math.ceil(data.length / 4) * 16 : data.length * 4;\n            });\n            const maxAlignmentOfField = 16;\n            currentOffset = Math.ceil(currentOffset / maxAlignmentOfField) * maxAlignmentOfField;\n            const arrayBuffer = new ArrayBuffer(currentOffset);\n            programUniforms.forEach((v, i) => {\n              const offset = offsets[i];\n              const data = typeof v.data === "number" ? [v.data] : v.data;\n              if (v.type === "int32") {\n                new Int32Array(arrayBuffer, offset, data.length).set(data);\n              } else if (v.type === "uint32") {\n                new Uint32Array(arrayBuffer, offset, data.length).set(data);\n              } else {\n                new Float32Array(arrayBuffer, offset, data.length).set(data);\n              }\n            });\n            const uniformBufferData = (\n              // eslint-disable-next-line no-bitwise\n              this.gpuDataManager.create(currentOffset, GPUBufferUsage.COPY_DST | GPUBufferUsage.UNIFORM)\n            );\n            this.device.queue.writeBuffer(uniformBufferData.buffer, 0, arrayBuffer, 0, currentOffset);\n            this.gpuDataManager.release(uniformBufferData.id);\n            uniformBufferBinding = { offset: 0, size: currentOffset, buffer: uniformBufferData.buffer };\n          }\n          const normalizedDispatchGroup = this.programManager.normalizeDispatchGroupSize(dispatchGroup);\n          const is1DimensionDispatch = normalizedDispatchGroup[1] === 1 && normalizedDispatchGroup[2] === 1;\n          const key = getProgramInfoUniqueKey(program, inputTensorViews, is1DimensionDispatch);\n          let artifact = this.programManager.getArtifact(key);\n          if (!artifact) {\n            artifact = this.programManager.build(program, normalizedDispatchGroup);\n            this.programManager.setArtifact(key, artifact);\n            LOG_DEBUG("info", () => `[artifact] key: ${key}, programName: ${program.name}`);\n          }\n          LOG_DEBUG(\n            "info",\n            () => `[ProgramManager] run "${program.name}" (key=${key}) with ${normalizedDispatchGroup[0]}x${normalizedDispatchGroup[1]}x${normalizedDispatchGroup[2]}`\n          );\n          if (this.queryType !== "none") {\n            const pendingKernelInfo = {\n              kernelId: this.currentKernelId,\n              programName: artifact.programInfo.name,\n              inputTensorViews,\n              outputTensorViews\n            };\n            this.pendingKernels.push(pendingKernelInfo);\n          }\n          this.programManager.run(artifact, inputDatas, outputDatas, normalizedDispatchGroup, uniformBufferBinding);\n          TRACE_FUNC_END(program.name);\n          return outputTensorViews;\n        }\n        upload(gpuDataId, data) {\n          this.gpuDataManager.upload(gpuDataId, data);\n        }\n        memcpy(src, dst) {\n          this.gpuDataManager.memcpy(src, dst);\n        }\n        async download(gpuDataId, getTargetBuffer) {\n          await this.gpuDataManager.download(gpuDataId, getTargetBuffer);\n        }\n        alloc(size) {\n          return this.gpuDataManager.create(size).id;\n        }\n        free(ptr) {\n          return this.gpuDataManager.release(ptr);\n        }\n        createKernel(kernelType, kernelId, attribute, kernelName) {\n          const op = WEBGPU_OP_RESOLVE_RULES.get(kernelType);\n          if (!op) {\n            throw new Error(`kernel not implemented: ${kernelType}`);\n          }\n          const kernelInfo = {\n            kernelType,\n            kernelName,\n            kernelEntry: op[0],\n            attributes: [op[1], attribute]\n          };\n          this.kernels.set(kernelId, kernelInfo);\n        }\n        releaseKernel(kernelId) {\n          const persistentData = this.kernelPersistentData.get(kernelId);\n          if (persistentData) {\n            for (const data of persistentData) {\n              this.gpuDataManager.release(data.id);\n            }\n            this.kernelPersistentData.delete(kernelId);\n          }\n          this.kernelCustomData.delete(kernelId);\n          this.kernels.delete(kernelId);\n        }\n        computeKernel(kernelId, context, errors) {\n          const kernel = this.kernels.get(kernelId);\n          if (!kernel) {\n            throw new Error(`kernel not created: ${kernelId}`);\n          }\n          const kernelType = kernel.kernelType;\n          const kernelName = kernel.kernelName;\n          const kernelEntry = kernel.kernelEntry;\n          const attributes = kernel.attributes;\n          if (this.currentKernelId !== null) {\n            throw new Error(`kernel "[${kernelType}] ${kernelName}" is not allowed to be called recursively`);\n          }\n          this.currentKernelId = kernelId;\n          if (attributes[0]) {\n            attributes[1] = attributes[0](attributes[1]);\n            attributes[0] = void 0;\n          }\n          LOG_DEBUG("info", () => `[WebGPU] Start to run kernel "[${kernelType}] ${kernelName}"...`);\n          const useErrorScope = this.env.debug;\n          this.temporaryData = [];\n          try {\n            if (useErrorScope) {\n              this.device.pushErrorScope("validation");\n            }\n            kernelEntry(context, attributes[1]);\n            return 0;\n          } catch (e) {\n            errors.push(Promise.resolve(`[WebGPU] Kernel "[${kernelType}] ${kernelName}" failed. ${e}`));\n            return 1;\n          } finally {\n            if (useErrorScope) {\n              errors.push(this.device.popErrorScope().then(\n                (err) => err ? `GPU validation error for kernel "[${kernelType}] ${kernelName}": ${err.message}` : null\n              ));\n            }\n            for (const data of this.temporaryData) {\n              this.gpuDataManager.release(data.id);\n            }\n            this.temporaryData = [];\n            this.currentKernelId = null;\n          }\n        }\n        // #region external buffer\n        registerBuffer(sessionId, index, buffer, size) {\n          let sessionInputOutputMapping = this.sessionExternalDataMapping.get(sessionId);\n          if (!sessionInputOutputMapping) {\n            sessionInputOutputMapping = /* @__PURE__ */ new Map();\n            this.sessionExternalDataMapping.set(sessionId, sessionInputOutputMapping);\n          }\n          const previousBuffer = sessionInputOutputMapping.get(index);\n          const id = this.gpuDataManager.registerExternalBuffer(buffer, size, previousBuffer?.[1]);\n          sessionInputOutputMapping.set(index, [id, buffer]);\n          return id;\n        }\n        unregisterBuffers(sessionId) {\n          const sessionInputOutputMapping = this.sessionExternalDataMapping.get(sessionId);\n          if (sessionInputOutputMapping) {\n            sessionInputOutputMapping.forEach((bufferInfo) => this.gpuDataManager.unregisterExternalBuffer(bufferInfo[1]));\n            this.sessionExternalDataMapping.delete(sessionId);\n          }\n        }\n        getBuffer(gpuDataId) {\n          const gpuData = this.gpuDataManager.get(gpuDataId);\n          if (!gpuData) {\n            throw new Error(`no GPU data for buffer: ${gpuDataId}`);\n          }\n          return gpuData.buffer;\n        }\n        createDownloader(gpuBuffer, size, type) {\n          return async () => {\n            const data = await downloadGpuData(this, gpuBuffer, size);\n            return createView(data.buffer, type);\n          };\n        }\n        writeTimestamp(index) {\n          if (this.queryType !== "inside-passes") {\n            return;\n          }\n          this.computePassEncoder.writeTimestamp(this.querySet, index);\n        }\n        setQueryType() {\n          this.queryType = "none";\n          if (this.env.webgpu.profiling?.mode === "default" || this.env.wasm.trace) {\n            if (this.device.features.has("chromium-experimental-timestamp-query-inside-passes")) {\n              this.queryType = "inside-passes";\n            } else if (this.device.features.has("timestamp-query")) {\n              this.queryType = "at-passes";\n            }\n          }\n        }\n        // #endregion\n      };\n    }\n  });\n\n  // web/lib/wasm/jsep/init.ts\n  var init_exports = {};\n  __export(init_exports, {\n    init: () => init\n  });\n  var TensorViewImpl, ComputeContextImpl, init;\n  var init_init = __esm({\n    "web/lib/wasm/jsep/init.ts"() {\n      "use strict";\n      init_wasm_common();\n      init_backend_webgpu();\n      init_log();\n      init_util();\n      TensorViewImpl = class _TensorViewImpl {\n        constructor(module, dataType, data, dims) {\n          this.module = module;\n          this.dataType = dataType;\n          this.data = data;\n          this.dims = dims;\n        }\n        getFloat32Array() {\n          if (this.dataType !== 1 /* float */) {\n            throw new Error("Invalid data type");\n          }\n          const elementCount = ShapeUtil.size(this.dims);\n          return elementCount === 0 ? new Float32Array() : new Float32Array(this.module.HEAP8.buffer, this.data, elementCount);\n        }\n        getBigInt64Array() {\n          if (this.dataType !== 7 /* int64 */) {\n            throw new Error("Invalid data type");\n          }\n          const elementCount = ShapeUtil.size(this.dims);\n          return elementCount === 0 ? new BigInt64Array() : new BigInt64Array(this.module.HEAP8.buffer, this.data, elementCount);\n        }\n        getInt32Array() {\n          if (this.dataType !== 6 /* int32 */) {\n            throw new Error("Invalid data type");\n          }\n          const elementCount = ShapeUtil.size(this.dims);\n          return elementCount === 0 ? new Int32Array() : new Int32Array(this.module.HEAP8.buffer, this.data, elementCount);\n        }\n        reshape(newDims) {\n          if (ShapeUtil.size(newDims) !== ShapeUtil.size(this.dims)) {\n            throw new Error("Invalid new shape");\n          }\n          return new _TensorViewImpl(this.module, this.dataType, this.data, newDims);\n        }\n      };\n      ComputeContextImpl = class {\n        constructor(module, backend, contextDataOffset) {\n          this.module = module;\n          this.backend = backend;\n          this.customDataOffset = 0;\n          this.customDataSize = 0;\n          const heapU32 = module.HEAPU32;\n          let dataIndex = contextDataOffset >>> 2;\n          this.opKernelContext = heapU32[dataIndex++];\n          const inputCount = heapU32[dataIndex++];\n          this.outputCount = heapU32[dataIndex++];\n          this.customDataOffset = heapU32[dataIndex++];\n          this.customDataSize = heapU32[dataIndex++];\n          const inputs = [];\n          for (let i = 0; i < inputCount; i++) {\n            const dataType = heapU32[dataIndex++];\n            const data = heapU32[dataIndex++];\n            const dim = heapU32[dataIndex++];\n            const dims = [];\n            for (let d = 0; d < dim; d++) {\n              dims.push(heapU32[dataIndex++]);\n            }\n            inputs.push(new TensorViewImpl(module, dataType, data, dims));\n          }\n          this.inputs = inputs;\n        }\n        get kernelCustomData() {\n          return this.backend.currentKernelCustomData;\n        }\n        get customDataBuffer() {\n          return this.module.HEAPU8.subarray(this.customDataOffset, this.customDataOffset + this.customDataSize);\n        }\n        compute(program, inputsOutputsMapping) {\n          const mappedInputs = inputsOutputsMapping?.inputs?.map((i) => typeof i === "number" ? this.inputs[i] : i) ?? this.inputs;\n          const outputIndices = inputsOutputsMapping?.outputs ?? [];\n          const createKernelOutput = (index, dataType, dims) => new TensorViewImpl(this.module, dataType, this.output(index, dims), dims);\n          const createTemporaryOutput = (dataType, dims) => {\n            const elementSize = getTensorElementSize(dataType);\n            if (!elementSize) {\n              throw new Error(`Unsupported data type: ${dataType}`);\n            }\n            const bufferSize = elementSize * ShapeUtil.size(dims);\n            return new TensorViewImpl(this.module, dataType, this.backend.gpuDataManager.create(bufferSize).id, dims);\n          };\n          return this.backend.run(program, mappedInputs, outputIndices, createKernelOutput, createTemporaryOutput);\n        }\n        output(index, dims) {\n          const stack = this.module.stackSave();\n          try {\n            const data = this.module.stackAlloc(\n              (1 + dims.length) * 4\n              /* sizeof(size_t) */\n            );\n            let offset = data >> 2;\n            this.module.HEAPU32[offset++] = dims.length;\n            for (let i = 0; i < dims.length; i++) {\n              this.module.HEAPU32[offset++] = dims[i];\n            }\n            return this.module._JsepOutput(this.opKernelContext, index, data);\n          } catch (e) {\n            throw new Error(\n              `Failed to generate kernel\'s output[${index}] with dims [${dims}]. If you are running with pre-allocated output, please make sure the output type/dims are correct. Error: ${e}`\n            );\n          } finally {\n            this.module.stackRestore(stack);\n          }\n        }\n      };\n      init = async (module, env3, gpuAdapter) => {\n        const jsepInit = module.jsepInit;\n        if (!jsepInit) {\n          throw new Error("Failed to initialize JSEP. The WebAssembly module is not built with JSEP support.");\n        }\n        const backend = new WebGpuBackend();\n        await backend.initialize(env3, gpuAdapter);\n        jsepInit(\n          // backend\n          backend,\n          // jsepAlloc()\n          (size) => backend.alloc(size),\n          // jsepFree()\n          (ptr) => backend.free(ptr),\n          // jsepCopy(src, dst, size, isSourceGpu)\n          (src, dst, size, isSourceGpu = false) => {\n            if (isSourceGpu) {\n              LOG_DEBUG("verbose", () => `[WebGPU] jsepCopyGpuToGpu: src=${src}, dst=${dst}, size=${size}`);\n              backend.memcpy(src, dst);\n            } else {\n              LOG_DEBUG("verbose", () => `[WebGPU] jsepCopyCpuToGpu: dataOffset=${src}, gpuDataId=${dst}, size=${size}`);\n              const data = module.HEAPU8.subarray(src >>> 0, (src >>> 0) + size);\n              backend.upload(dst, data);\n            }\n          },\n          // jsepCopyAsync(src, dst, size)\n          async (gpuDataId, dataOffset, size) => {\n            LOG_DEBUG(\n              "verbose",\n              () => `[WebGPU] jsepCopyGpuToCpu: gpuDataId=${gpuDataId}, dataOffset=${dataOffset}, size=${size}`\n            );\n            await backend.download(\n              gpuDataId,\n              () => module.HEAPU8.subarray(dataOffset >>> 0, (dataOffset >>> 0) + size)\n            );\n          },\n          // jsepCreateKernel\n          (kernelType, kernelId, attribute) => backend.createKernel(kernelType, kernelId, attribute, module.UTF8ToString(module._JsepGetNodeName(kernelId))),\n          // jsepReleaseKernel\n          (kernel) => backend.releaseKernel(kernel),\n          // jsepRun\n          (kernel, contextDataOffset, sessionHandle, errors) => {\n            LOG_DEBUG(\n              "verbose",\n              () => `[WebGPU] jsepRun: sessionHandle=${sessionHandle}, kernel=${kernel}, contextDataOffset=${contextDataOffset}`\n            );\n            const context = new ComputeContextImpl(module, backend, contextDataOffset);\n            return backend.computeKernel(kernel, context, errors);\n          }\n        );\n      };\n    }\n  });\n\n  // nodejs-ignore:node:path\n  var join = void 0;\n\n  // web/lib/wasm/wasm-factory.ts\n  var ortWasmFactory;\n  if (false) {\n    ortWasmFactory = null;\n  } else {\n    ortWasmFactory = false ? null : require_ort_wasm_simd_jsep();\n  }\n  var ortWasmFactoryThreaded = true ? false ? null : require_ort_wasm_simd_threaded_jsep() : ortWasmFactory;\n  var wasm;\n  var initialized = false;\n  var initializing = false;\n  var aborted = false;\n  var isMultiThreadSupported = (numThreads) => {\n    if (numThreads === 1) {\n      return false;\n    }\n    if (typeof SharedArrayBuffer === "undefined") {\n      if (typeof self !== "undefined" && !self.crossOriginIsolated) {\n        console.warn(\n          "env.wasm.numThreads is set to " + numThreads + ", but this will not work unless you enable crossOriginIsolated mode. See https://web.dev/cross-origin-isolation-guide/ for more info."\n        );\n      }\n      return false;\n    }\n    if (typeof process !== "undefined" && process.versions && process.versions.node) {\n      console.warn(\n        "env.wasm.numThreads is set to " + numThreads + ", however, currently onnxruntime-web does not support multi-threads in Node.js. Please consider using onnxruntime-node for performance critical scenarios."\n      );\n    }\n    try {\n      if (typeof MessageChannel !== "undefined") {\n        new MessageChannel().port1.postMessage(new SharedArrayBuffer(1));\n      }\n      return WebAssembly.validate(new Uint8Array([\n        0,\n        97,\n        115,\n        109,\n        1,\n        0,\n        0,\n        0,\n        1,\n        4,\n        1,\n        96,\n        0,\n        0,\n        3,\n        2,\n        1,\n        0,\n        5,\n        4,\n        1,\n        3,\n        1,\n        1,\n        10,\n        11,\n        1,\n        9,\n        0,\n        65,\n        0,\n        254,\n        16,\n        2,\n        0,\n        26,\n        11\n      ]));\n    } catch (e) {\n      return false;\n    }\n  };\n  var isSimdSupported = () => {\n    try {\n      return WebAssembly.validate(new Uint8Array([\n        0,\n        97,\n        115,\n        109,\n        1,\n        0,\n        0,\n        0,\n        1,\n        4,\n        1,\n        96,\n        0,\n        0,\n        3,\n        2,\n        1,\n        0,\n        10,\n        30,\n        1,\n        28,\n        0,\n        65,\n        0,\n        253,\n        15,\n        253,\n        12,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        253,\n        186,\n        1,\n        26,\n        11\n      ]));\n    } catch (e) {\n      return false;\n    }\n  };\n  var getWasmFileName = (useSimd, useThreads) => {\n    if (useSimd) {\n      if (false) {\n        return "ort-training-wasm-simd.wasm";\n      }\n      return useThreads ? "ort-wasm-simd-threaded.wasm" : "ort-wasm-simd.wasm";\n    } else {\n      return useThreads ? "ort-wasm-threaded.wasm" : "ort-wasm.wasm";\n    }\n  };\n  var initializeWebAssembly = async (flags) => {\n    if (initialized) {\n      return Promise.resolve();\n    }\n    if (initializing) {\n      throw new Error("multiple calls to \'initializeWebAssembly()\' detected.");\n    }\n    if (aborted) {\n      throw new Error("previous call to \'initializeWebAssembly()\' failed.");\n    }\n    initializing = true;\n    const timeout = flags.initTimeout;\n    const numThreads = flags.numThreads;\n    const simd = flags.simd;\n    const useThreads = isMultiThreadSupported(numThreads);\n    const useSimd = simd && isSimdSupported();\n    const wasmPaths = flags.wasmPaths;\n    const wasmPrefixOverride = typeof wasmPaths === "string" ? wasmPaths : void 0;\n    const wasmFileName = getWasmFileName(useSimd, useThreads);\n    const wasmPathOverride = typeof wasmPaths === "object" ? wasmPaths[wasmFileName] : void 0;\n    let isTimeout = false;\n    const tasks = [];\n    if (timeout > 0) {\n      tasks.push(new Promise((resolve) => {\n        setTimeout(() => {\n          isTimeout = true;\n          resolve();\n        }, timeout);\n      }));\n    }\n    tasks.push(new Promise((resolve, reject) => {\n      const factory = useThreads ? ortWasmFactoryThreaded : ortWasmFactory;\n      const config = {\n        locateFile: (fileName, scriptDirectory) => {\n          if (useThreads && fileName.endsWith(".worker.js") && typeof Blob !== "undefined") {\n            return URL.createObjectURL(new Blob(\n              [\n                // This require() function is handled by esbuild plugin to load file content as string.\n                // eslint-disable-next-line @typescript-eslint/no-require-imports\n                require_ort_wasm_threaded_worker()\n              ],\n              { type: "text/javascript" }\n            ));\n          }\n          if (fileName.endsWith(".wasm")) {\n            if (wasmPathOverride) {\n              return wasmPathOverride;\n            }\n            const prefix = wasmPrefixOverride ?? scriptDirectory;\n            if (true) {\n              if (wasmFileName === "ort-wasm-simd.wasm") {\n                return prefix + "ort-wasm-simd.jsep.wasm";\n              } else if (wasmFileName === "ort-wasm-simd-threaded.wasm") {\n                return prefix + "ort-wasm-simd-threaded.jsep.wasm";\n              }\n            }\n            return prefix + wasmFileName;\n          }\n          return scriptDirectory + fileName;\n        }\n      };\n      if (useThreads) {\n        config.numThreads = numThreads;\n        if (typeof Blob === "undefined") {\n          config.mainScriptUrlOrBlob = join(__dirname, "ort-wasm-threaded.js");\n        } else {\n          const scriptSourceCode = `var ortWasmThreaded=${factory.toString()};`;\n          config.mainScriptUrlOrBlob = new Blob([scriptSourceCode], { type: "text/javascript" });\n        }\n      }\n      factory(config).then(\n        // wasm module initialized successfully\n        (module) => {\n          initializing = false;\n          initialized = true;\n          wasm = module;\n          resolve();\n        },\n        // wasm module failed to initialize\n        (what) => {\n          initializing = false;\n          aborted = true;\n          reject(what);\n        }\n      );\n    }));\n    await Promise.race(tasks);\n    if (isTimeout) {\n      throw new Error(`WebAssembly backend initializing failed due to timeout: ${timeout}ms`);\n    }\n  };\n  var getInstance = () => {\n    if (initialized && wasm) {\n      return wasm;\n    }\n    throw new Error("WebAssembly is not initialized yet.");\n  };\n\n  // web/lib/wasm/wasm-utils.ts\n  var allocWasmString = (data, allocs) => {\n    const wasm2 = getInstance();\n    const dataLength = wasm2.lengthBytesUTF8(data) + 1;\n    const dataOffset = wasm2._malloc(dataLength);\n    wasm2.stringToUTF8(data, dataOffset, dataLength);\n    allocs.push(dataOffset);\n    return dataOffset;\n  };\n  var iterateExtraOptions = (options, prefix, seen, handler) => {\n    if (typeof options == "object" && options !== null) {\n      if (seen.has(options)) {\n        throw new Error("Circular reference in options");\n      } else {\n        seen.add(options);\n      }\n    }\n    Object.entries(options).forEach(([key, value]) => {\n      const name = prefix ? prefix + key : key;\n      if (typeof value === "object") {\n        iterateExtraOptions(value, name + ".", seen, handler);\n      } else if (typeof value === "string" || typeof value === "number") {\n        handler(name, value.toString());\n      } else if (typeof value === "boolean") {\n        handler(name, value ? "1" : "0");\n      } else {\n        throw new Error(`Can\'t handle extra config type: ${typeof value}`);\n      }\n    });\n  };\n  var checkLastError = (message) => {\n    const wasm2 = getInstance();\n    const stack = wasm2.stackSave();\n    try {\n      const paramsOffset = wasm2.stackAlloc(8);\n      wasm2._OrtGetLastError(paramsOffset, paramsOffset + 4);\n      const errorCode = wasm2.HEAP32[paramsOffset / 4];\n      const errorMessagePointer = wasm2.HEAPU32[paramsOffset / 4 + 1];\n      const errorMessage = errorMessagePointer ? wasm2.UTF8ToString(errorMessagePointer) : "";\n      throw new Error(`${message} ERROR_CODE: ${errorCode}, ERROR_MESSAGE: ${errorMessage}`);\n    } finally {\n      wasm2.stackRestore(stack);\n    }\n  };\n\n  // web/lib/wasm/run-options.ts\n  var setRunOptions = (options) => {\n    const wasm2 = getInstance();\n    let runOptionsHandle = 0;\n    const allocs = [];\n    const runOptions = options || {};\n    try {\n      if (options?.logSeverityLevel === void 0) {\n        runOptions.logSeverityLevel = 2;\n      } else if (typeof options.logSeverityLevel !== "number" || !Number.isInteger(options.logSeverityLevel) || options.logSeverityLevel < 0 || options.logSeverityLevel > 4) {\n        throw new Error(`log serverity level is not valid: ${options.logSeverityLevel}`);\n      }\n      if (options?.logVerbosityLevel === void 0) {\n        runOptions.logVerbosityLevel = 0;\n      } else if (typeof options.logVerbosityLevel !== "number" || !Number.isInteger(options.logVerbosityLevel)) {\n        throw new Error(`log verbosity level is not valid: ${options.logVerbosityLevel}`);\n      }\n      if (options?.terminate === void 0) {\n        runOptions.terminate = false;\n      }\n      let tagDataOffset = 0;\n      if (options?.tag !== void 0) {\n        tagDataOffset = allocWasmString(options.tag, allocs);\n      }\n      runOptionsHandle = wasm2._OrtCreateRunOptions(\n        runOptions.logSeverityLevel,\n        runOptions.logVerbosityLevel,\n        !!runOptions.terminate,\n        tagDataOffset\n      );\n      if (runOptionsHandle === 0) {\n        checkLastError("Can\'t create run options.");\n      }\n      if (options?.extra !== void 0) {\n        iterateExtraOptions(options.extra, "", /* @__PURE__ */ new WeakSet(), (key, value) => {\n          const keyDataOffset = allocWasmString(key, allocs);\n          const valueDataOffset = allocWasmString(value, allocs);\n          if (wasm2._OrtAddRunConfigEntry(runOptionsHandle, keyDataOffset, valueDataOffset) !== 0) {\n            checkLastError(`Can\'t set a run config entry: ${key} - ${value}.`);\n          }\n        });\n      }\n      return [runOptionsHandle, allocs];\n    } catch (e) {\n      if (runOptionsHandle !== 0) {\n        wasm2._OrtReleaseRunOptions(runOptionsHandle);\n      }\n      allocs.forEach((alloc) => wasm2._free(alloc));\n      throw e;\n    }\n  };\n\n  // web/lib/wasm/session-options.ts\n  var getGraphOptimzationLevel = (graphOptimizationLevel) => {\n    switch (graphOptimizationLevel) {\n      case "disabled":\n        return 0;\n      case "basic":\n        return 1;\n      case "extended":\n        return 2;\n      case "all":\n        return 99;\n      default:\n        throw new Error(`unsupported graph optimization level: ${graphOptimizationLevel}`);\n    }\n  };\n  var getExecutionMode = (executionMode) => {\n    switch (executionMode) {\n      case "sequential":\n        return 0;\n      case "parallel":\n        return 1;\n      default:\n        throw new Error(`unsupported execution mode: ${executionMode}`);\n    }\n  };\n  var appendDefaultOptions = (options) => {\n    if (!options.extra) {\n      options.extra = {};\n    }\n    if (!options.extra.session) {\n      options.extra.session = {};\n    }\n    const session = options.extra.session;\n    if (!session.use_ort_model_bytes_directly) {\n      session.use_ort_model_bytes_directly = "1";\n    }\n    if (options.executionProviders && options.executionProviders.some((ep) => (typeof ep === "string" ? ep : ep.name) === "webgpu")) {\n      options.enableMemPattern = false;\n    }\n  };\n  var setExecutionProviders = (sessionOptionsHandle, executionProviders, allocs) => {\n    for (const ep of executionProviders) {\n      let epName = typeof ep === "string" ? ep : ep.name;\n      switch (epName) {\n        case "webnn":\n          epName = "WEBNN";\n          if (typeof ep !== "string") {\n            const webnnOptions = ep;\n            if (webnnOptions?.deviceType) {\n              const keyDataOffset = allocWasmString("deviceType", allocs);\n              const valueDataOffset = allocWasmString(webnnOptions.deviceType, allocs);\n              if (getInstance()._OrtAddSessionConfigEntry(sessionOptionsHandle, keyDataOffset, valueDataOffset) !== 0) {\n                checkLastError(`Can\'t set a session config entry: \'deviceType\' - ${webnnOptions.deviceType}.`);\n              }\n            }\n            if (webnnOptions?.numThreads) {\n              let numThreads = webnnOptions.numThreads;\n              if (typeof numThreads != "number" || !Number.isInteger(numThreads) || numThreads < 0) {\n                numThreads = 0;\n              }\n              const keyDataOffset = allocWasmString("numThreads", allocs);\n              const valueDataOffset = allocWasmString(numThreads.toString(), allocs);\n              if (getInstance()._OrtAddSessionConfigEntry(sessionOptionsHandle, keyDataOffset, valueDataOffset) !== 0) {\n                checkLastError(`Can\'t set a session config entry: \'numThreads\' - ${webnnOptions.numThreads}.`);\n              }\n            }\n            if (webnnOptions?.powerPreference) {\n              const keyDataOffset = allocWasmString("powerPreference", allocs);\n              const valueDataOffset = allocWasmString(webnnOptions.powerPreference, allocs);\n              if (getInstance()._OrtAddSessionConfigEntry(sessionOptionsHandle, keyDataOffset, valueDataOffset) !== 0) {\n                checkLastError(\n                  `Can\'t set a session config entry: \'powerPreference\' - ${webnnOptions.powerPreference}.`\n                );\n              }\n            }\n          }\n          break;\n        case "webgpu":\n          epName = "JS";\n          if (typeof ep !== "string") {\n            const webgpuOptions = ep;\n            if (webgpuOptions?.preferredLayout) {\n              if (webgpuOptions.preferredLayout !== "NCHW" && webgpuOptions.preferredLayout !== "NHWC") {\n                throw new Error(`preferredLayout must be either \'NCHW\' or \'NHWC\': ${webgpuOptions.preferredLayout}`);\n              }\n              const keyDataOffset = allocWasmString("preferredLayout", allocs);\n              const valueDataOffset = allocWasmString(webgpuOptions.preferredLayout, allocs);\n              if (getInstance()._OrtAddSessionConfigEntry(sessionOptionsHandle, keyDataOffset, valueDataOffset) !== 0) {\n                checkLastError(\n                  `Can\'t set a session config entry: \'preferredLayout\' - ${webgpuOptions.preferredLayout}.`\n                );\n              }\n            }\n          }\n          break;\n        case "wasm":\n        case "cpu":\n          continue;\n        default:\n          throw new Error(`not supported execution provider: ${epName}`);\n      }\n      const epNameDataOffset = allocWasmString(epName, allocs);\n      if (getInstance()._OrtAppendExecutionProvider(sessionOptionsHandle, epNameDataOffset) !== 0) {\n        checkLastError(`Can\'t append execution provider: ${epName}.`);\n      }\n    }\n  };\n  var setSessionOptions = (options) => {\n    const wasm2 = getInstance();\n    let sessionOptionsHandle = 0;\n    const allocs = [];\n    const sessionOptions = options || {};\n    appendDefaultOptions(sessionOptions);\n    try {\n      const graphOptimizationLevel = getGraphOptimzationLevel(sessionOptions.graphOptimizationLevel ?? "all");\n      const executionMode = getExecutionMode(sessionOptions.executionMode ?? "sequential");\n      const logIdDataOffset = typeof sessionOptions.logId === "string" ? allocWasmString(sessionOptions.logId, allocs) : 0;\n      const logSeverityLevel = sessionOptions.logSeverityLevel ?? 2;\n      if (!Number.isInteger(logSeverityLevel) || logSeverityLevel < 0 || logSeverityLevel > 4) {\n        throw new Error(`log serverity level is not valid: ${logSeverityLevel}`);\n      }\n      const logVerbosityLevel = sessionOptions.logVerbosityLevel ?? 0;\n      if (!Number.isInteger(logVerbosityLevel) || logVerbosityLevel < 0 || logVerbosityLevel > 4) {\n        throw new Error(`log verbosity level is not valid: ${logVerbosityLevel}`);\n      }\n      const optimizedModelFilePathOffset = typeof sessionOptions.optimizedModelFilePath === "string" ? allocWasmString(sessionOptions.optimizedModelFilePath, allocs) : 0;\n      sessionOptionsHandle = wasm2._OrtCreateSessionOptions(\n        graphOptimizationLevel,\n        !!sessionOptions.enableCpuMemArena,\n        !!sessionOptions.enableMemPattern,\n        executionMode,\n        !!sessionOptions.enableProfiling,\n        0,\n        logIdDataOffset,\n        logSeverityLevel,\n        logVerbosityLevel,\n        optimizedModelFilePathOffset\n      );\n      if (sessionOptionsHandle === 0) {\n        checkLastError("Can\'t create session options.");\n      }\n      if (sessionOptions.executionProviders) {\n        setExecutionProviders(sessionOptionsHandle, sessionOptions.executionProviders, allocs);\n      }\n      if (sessionOptions.freeDimensionOverrides) {\n        for (const [name, value] of Object.entries(sessionOptions.freeDimensionOverrides)) {\n          if (typeof name !== "string") {\n            throw new Error(`free dimension override name must be a string: ${name}`);\n          }\n          if (typeof value !== "number" || !Number.isInteger(value) || value < 0) {\n            throw new Error(`free dimension override value must be a non-negative integer: ${value}`);\n          }\n          const nameOffset = allocWasmString(name, allocs);\n          if (wasm2._OrtAddFreeDimensionOverride(sessionOptionsHandle, nameOffset, value) !== 0) {\n            checkLastError(`Can\'t set a free dimension override: ${name} - ${value}.`);\n          }\n        }\n      }\n      if (sessionOptions.extra !== void 0) {\n        iterateExtraOptions(sessionOptions.extra, "", /* @__PURE__ */ new WeakSet(), (key, value) => {\n          const keyDataOffset = allocWasmString(key, allocs);\n          const valueDataOffset = allocWasmString(value, allocs);\n          if (wasm2._OrtAddSessionConfigEntry(sessionOptionsHandle, keyDataOffset, valueDataOffset) !== 0) {\n            checkLastError(`Can\'t set a session config entry: ${key} - ${value}.`);\n          }\n        });\n      }\n      return [sessionOptionsHandle, allocs];\n    } catch (e) {\n      if (sessionOptionsHandle !== 0) {\n        wasm2._OrtReleaseSessionOptions(sessionOptionsHandle);\n      }\n      allocs.forEach((alloc) => wasm2._free(alloc));\n      throw e;\n    }\n  };\n\n  // web/lib/wasm/wasm-core-impl.ts\n  init_wasm_common();\n\n  // web/lib/wasm/wasm-utils-load-file.ts\n  init_fs();\n\n  // nodejs-ignore:node:fs/promises\n  var readFile2 = void 0;\n\n  // web/lib/wasm/wasm-utils-load-file.ts\n  var loadFile = async (file) => {\n    if (typeof file === "string") {\n      if (typeof process !== "undefined" && process.versions && process.versions.node) {\n        try {\n          return new Uint8Array(await readFile2(file));\n        } catch (e) {\n          if (e.code === "ERR_FS_FILE_TOO_LARGE") {\n            const stream = createReadStream(file);\n            const chunks = [];\n            for await (const chunk of stream) {\n              chunks.push(chunk);\n            }\n            return new Uint8Array(Buffer.concat(chunks));\n          }\n          throw e;\n        }\n      } else {\n        const response = await fetch(file);\n        if (!response.ok) {\n          throw new Error(`failed to load external data file: ${file}`);\n        }\n        const contentLengthHeader = response.headers.get("Content-Length");\n        const fileSize = contentLengthHeader ? parseInt(contentLengthHeader, 10) : 0;\n        if (fileSize < 1073741824) {\n          return new Uint8Array(await response.arrayBuffer());\n        } else {\n          if (!response.body) {\n            throw new Error(`failed to load external data file: ${file}, no response body.`);\n          }\n          const reader = response.body.getReader();\n          let buffer;\n          try {\n            buffer = new ArrayBuffer(fileSize);\n          } catch (e) {\n            if (e instanceof RangeError) {\n              const pages = Math.ceil(fileSize / 65536);\n              buffer = new WebAssembly.Memory({ initial: pages, maximum: pages }).buffer;\n            } else {\n              throw e;\n            }\n          }\n          let offset = 0;\n          while (true) {\n            const { done, value } = await reader.read();\n            if (done) {\n              break;\n            }\n            const chunkSize = value.byteLength;\n            const chunk = new Uint8Array(buffer, offset, chunkSize);\n            chunk.set(value);\n            offset += chunkSize;\n          }\n          return new Uint8Array(buffer, 0, fileSize);\n        }\n      }\n    } else if (file instanceof Blob) {\n      return new Uint8Array(await file.arrayBuffer());\n    } else if (file instanceof Uint8Array) {\n      return file;\n    } else {\n      return new Uint8Array(file);\n    }\n  };\n\n  // web/lib/wasm/wasm-core-impl.ts\n  var initOrt = (numThreads, loggingLevel) => {\n    const errorCode = getInstance()._OrtInit(numThreads, loggingLevel);\n    if (errorCode !== 0) {\n      checkLastError("Can\'t initialize onnxruntime.");\n    }\n  };\n  var initRuntime = async (env3) => {\n    initOrt(env3.wasm.numThreads, logLevelStringToEnum(env3.logLevel));\n  };\n  var initEp = async (env3, epName) => {\n    if (epName === "webgpu") {\n      if (typeof navigator === "undefined" || !navigator.gpu) {\n        throw new Error("WebGPU is not supported in current environment");\n      }\n      const adapter = await navigator.gpu.requestAdapter();\n      if (!adapter) {\n        throw new Error(\n          \'Failed to get GPU adapter. You may need to enable flag "--enable-unsafe-webgpu" if you are using Chrome.\'\n        );\n      }\n      if (!env3.wasm.simd) {\n        throw new Error(\n          "Not supported for WebGPU=ON and SIMD=OFF. Please set `env.wasm.simd` to true when using `webgpu` EP"\n        );\n      }\n      const initJsep = (init_init(), __toCommonJS(init_exports)).init;\n      await initJsep(getInstance(), env3, adapter);\n    }\n  };\n  var activeSessions = /* @__PURE__ */ new Map();\n  var getSessionInputOutputCount = (sessionHandle) => {\n    const wasm2 = getInstance();\n    const stack = wasm2.stackSave();\n    try {\n      const dataOffset = wasm2.stackAlloc(8);\n      const errorCode = wasm2._OrtGetInputOutputCount(sessionHandle, dataOffset, dataOffset + 4);\n      if (errorCode !== 0) {\n        checkLastError("Can\'t get session input/output count.");\n      }\n      return [wasm2.HEAP32[dataOffset / 4], wasm2.HEAP32[dataOffset / 4 + 1]];\n    } finally {\n      wasm2.stackRestore(stack);\n    }\n  };\n  var copyFromExternalBuffer = (model) => {\n    const wasm2 = getInstance();\n    const modelDataOffset = wasm2._malloc(model.byteLength);\n    if (modelDataOffset === 0) {\n      throw new Error(`Can\'t create a session. failed to allocate a buffer of size ${model.byteLength}.`);\n    }\n    wasm2.HEAPU8.set(model, modelDataOffset);\n    return [modelDataOffset, model.byteLength];\n  };\n  var createSession = async (modelData, options) => {\n    let modelDataOffset, modelDataLength;\n    const wasm2 = getInstance();\n    if (Array.isArray(modelData)) {\n      [modelDataOffset, modelDataLength] = modelData;\n    } else if (modelData.buffer === wasm2.HEAPU8.buffer) {\n      [modelDataOffset, modelDataLength] = [modelData.byteOffset, modelData.byteLength];\n    } else {\n      [modelDataOffset, modelDataLength] = copyFromExternalBuffer(modelData);\n    }\n    let sessionHandle = 0;\n    let sessionOptionsHandle = 0;\n    let ioBindingHandle = 0;\n    let allocs = [];\n    const inputNamesUTF8Encoded = [];\n    const outputNamesUTF8Encoded = [];\n    try {\n      [sessionOptionsHandle, allocs] = setSessionOptions(options);\n      if (options?.externalData && wasm2.mountExternalData) {\n        const loadingPromises = [];\n        for (const file of options.externalData) {\n          const path = typeof file === "string" ? file : file.path;\n          loadingPromises.push(loadFile(typeof file === "string" ? file : file.data).then((data) => {\n            wasm2.mountExternalData(path, data);\n          }));\n        }\n        await Promise.all(loadingPromises);\n      }\n      sessionHandle = wasm2._OrtCreateSession(modelDataOffset, modelDataLength, sessionOptionsHandle);\n      if (sessionHandle === 0) {\n        checkLastError("Can\'t create a session.");\n      }\n      const [inputCount, outputCount] = getSessionInputOutputCount(sessionHandle);\n      const inputNames = [];\n      const outputNames = [];\n      const outputPreferredLocations = [];\n      for (let i = 0; i < inputCount; i++) {\n        const name = wasm2._OrtGetInputName(sessionHandle, i);\n        if (name === 0) {\n          checkLastError("Can\'t get an input name.");\n        }\n        inputNamesUTF8Encoded.push(name);\n        inputNames.push(wasm2.UTF8ToString(name));\n      }\n      for (let i = 0; i < outputCount; i++) {\n        const name = wasm2._OrtGetOutputName(sessionHandle, i);\n        if (name === 0) {\n          checkLastError("Can\'t get an output name.");\n        }\n        outputNamesUTF8Encoded.push(name);\n        const nameString = wasm2.UTF8ToString(name);\n        outputNames.push(nameString);\n        if (true) {\n          const location = typeof options?.preferredOutputLocation === "string" ? options.preferredOutputLocation : options?.preferredOutputLocation?.[nameString] ?? "cpu";\n          if (location !== "cpu" && location !== "cpu-pinned" && location !== "gpu-buffer") {\n            throw new Error(`Not supported preferred output location: ${location}.`);\n          }\n          outputPreferredLocations.push(location);\n        }\n      }\n      let bindingState = null;\n      if (outputPreferredLocations.some((l) => l === "gpu-buffer")) {\n        ioBindingHandle = wasm2._OrtCreateBinding(sessionHandle);\n        if (ioBindingHandle === 0) {\n          checkLastError("Can\'t create IO binding.");\n        }\n        bindingState = {\n          handle: ioBindingHandle,\n          outputPreferredLocations,\n          outputPreferredLocationsEncoded: outputPreferredLocations.map((l) => dataLocationStringToEnum(l))\n        };\n      }\n      activeSessions.set(sessionHandle, [sessionHandle, inputNamesUTF8Encoded, outputNamesUTF8Encoded, bindingState]);\n      return [sessionHandle, inputNames, outputNames];\n    } catch (e) {\n      inputNamesUTF8Encoded.forEach((buf) => wasm2._OrtFree(buf));\n      outputNamesUTF8Encoded.forEach((buf) => wasm2._OrtFree(buf));\n      if (ioBindingHandle !== 0) {\n        wasm2._OrtReleaseBinding(ioBindingHandle);\n      }\n      if (sessionHandle !== 0) {\n        wasm2._OrtReleaseSession(sessionHandle);\n      }\n      throw e;\n    } finally {\n      wasm2._free(modelDataOffset);\n      if (sessionOptionsHandle !== 0) {\n        wasm2._OrtReleaseSessionOptions(sessionOptionsHandle);\n      }\n      allocs.forEach((alloc) => wasm2._free(alloc));\n      wasm2.unmountExternalData?.();\n    }\n  };\n  var releaseSession = (sessionId) => {\n    const wasm2 = getInstance();\n    const session = activeSessions.get(sessionId);\n    if (!session) {\n      throw new Error(`cannot release session. invalid session id: ${sessionId}`);\n    }\n    const [sessionHandle, inputNamesUTF8Encoded, outputNamesUTF8Encoded, ioBindingState] = session;\n    if (ioBindingState) {\n      wasm2._OrtReleaseBinding(ioBindingState.handle);\n    }\n    wasm2.jsepUnregisterBuffers?.(sessionId);\n    inputNamesUTF8Encoded.forEach((buf) => wasm2._OrtFree(buf));\n    outputNamesUTF8Encoded.forEach((buf) => wasm2._OrtFree(buf));\n    wasm2._OrtReleaseSession(sessionHandle);\n    activeSessions.delete(sessionId);\n  };\n  var prepareInputOutputTensor = (tensor, tensorHandles, allocs, sessionId, index) => {\n    if (!tensor) {\n      tensorHandles.push(0);\n      return;\n    }\n    const wasm2 = getInstance();\n    const dataType = tensor[0];\n    const dims = tensor[1];\n    const location = tensor[3];\n    let rawData;\n    let dataByteLength;\n    if (dataType === "string" && location === "gpu-buffer") {\n      throw new Error("String tensor is not supported on GPU.");\n    }\n    if (location === "gpu-buffer") {\n      const gpuBuffer = tensor[2].gpuBuffer;\n      const elementSizeInBytes = getTensorElementSize(tensorDataTypeStringToEnum(dataType));\n      dataByteLength = dims.reduce((a, b) => a * b, 1) * elementSizeInBytes;\n      rawData = wasm2.jsepRegisterBuffer(sessionId, index, gpuBuffer, dataByteLength);\n    } else {\n      const data = tensor[2];\n      if (Array.isArray(data)) {\n        dataByteLength = 4 * data.length;\n        rawData = wasm2._malloc(dataByteLength);\n        allocs.push(rawData);\n        let dataIndex = rawData / 4;\n        for (let i = 0; i < data.length; i++) {\n          if (typeof data[i] !== "string") {\n            throw new TypeError(`tensor data at index ${i} is not a string`);\n          }\n          wasm2.HEAPU32[dataIndex++] = allocWasmString(data[i], allocs);\n        }\n      } else {\n        dataByteLength = data.byteLength;\n        rawData = wasm2._malloc(dataByteLength);\n        allocs.push(rawData);\n        wasm2.HEAPU8.set(new Uint8Array(data.buffer, data.byteOffset, dataByteLength), rawData);\n      }\n    }\n    const stack = wasm2.stackSave();\n    const dimsOffset = wasm2.stackAlloc(4 * dims.length);\n    try {\n      let dimIndex = dimsOffset / 4;\n      dims.forEach((d) => wasm2.HEAP32[dimIndex++] = d);\n      const tensor2 = wasm2._OrtCreateTensor(\n        tensorDataTypeStringToEnum(dataType),\n        rawData,\n        dataByteLength,\n        dimsOffset,\n        dims.length,\n        dataLocationStringToEnum(location)\n      );\n      if (tensor2 === 0) {\n        checkLastError(`Can\'t create tensor for input/output. session=${sessionId}, index=${index}.`);\n      }\n      tensorHandles.push(tensor2);\n    } finally {\n      wasm2.stackRestore(stack);\n    }\n  };\n  var run = async (sessionId, inputIndices, inputTensors, outputIndices, outputTensors, options) => {\n    const wasm2 = getInstance();\n    const session = activeSessions.get(sessionId);\n    if (!session) {\n      throw new Error(`cannot run inference. invalid session id: ${sessionId}`);\n    }\n    const [sessionHandle, inputNamesUTF8Encoded, outputNamesUTF8Encoded, ioBindingState] = session;\n    const inputCount = inputIndices.length;\n    const outputCount = outputIndices.length;\n    let runOptionsHandle = 0;\n    let runOptionsAllocs = [];\n    const inputTensorHandles = [];\n    const outputTensorHandles = [];\n    const inputOutputAllocs = [];\n    const beforeRunStack = wasm2.stackSave();\n    const inputValuesOffset = wasm2.stackAlloc(inputCount * 4);\n    const inputNamesOffset = wasm2.stackAlloc(inputCount * 4);\n    const outputValuesOffset = wasm2.stackAlloc(outputCount * 4);\n    const outputNamesOffset = wasm2.stackAlloc(outputCount * 4);\n    try {\n      [runOptionsHandle, runOptionsAllocs] = setRunOptions(options);\n      for (let i = 0; i < inputCount; i++) {\n        prepareInputOutputTensor(inputTensors[i], inputTensorHandles, inputOutputAllocs, sessionId, inputIndices[i]);\n      }\n      for (let i = 0; i < outputCount; i++) {\n        prepareInputOutputTensor(\n          outputTensors[i],\n          outputTensorHandles,\n          inputOutputAllocs,\n          sessionId,\n          inputCount + outputIndices[i]\n        );\n      }\n      let inputValuesIndex = inputValuesOffset / 4;\n      let inputNamesIndex = inputNamesOffset / 4;\n      let outputValuesIndex = outputValuesOffset / 4;\n      let outputNamesIndex = outputNamesOffset / 4;\n      for (let i = 0; i < inputCount; i++) {\n        wasm2.HEAPU32[inputValuesIndex++] = inputTensorHandles[i];\n        wasm2.HEAPU32[inputNamesIndex++] = inputNamesUTF8Encoded[inputIndices[i]];\n      }\n      for (let i = 0; i < outputCount; i++) {\n        wasm2.HEAPU32[outputValuesIndex++] = outputTensorHandles[i];\n        wasm2.HEAPU32[outputNamesIndex++] = outputNamesUTF8Encoded[outputIndices[i]];\n      }\n      if (ioBindingState) {\n        const { handle, outputPreferredLocations, outputPreferredLocationsEncoded } = ioBindingState;\n        if (inputNamesUTF8Encoded.length !== inputCount) {\n          throw new Error(`input count from feeds (${inputCount}) is expected to be always equal to model\'s input count (${inputNamesUTF8Encoded.length}).`);\n        }\n        for (let i = 0; i < inputCount; i++) {\n          const index = inputIndices[i];\n          const errorCode2 = await wasm2._OrtBindInput(handle, inputNamesUTF8Encoded[index], inputTensorHandles[i]);\n          if (errorCode2 !== 0) {\n            checkLastError(`Can\'t bind input[${i}] for session=${sessionId}.`);\n          }\n        }\n        for (let i = 0; i < outputCount; i++) {\n          const index = outputIndices[i];\n          const location = outputTensors[i]?.[3];\n          if (location) {\n            const errorCode2 = wasm2._OrtBindOutput(handle, outputNamesUTF8Encoded[index], outputTensorHandles[i], 0);\n            if (errorCode2 !== 0) {\n              checkLastError(`Can\'t bind pre-allocated output[${i}] for session=${sessionId}.`);\n            }\n          } else {\n            const errorCode2 = wasm2._OrtBindOutput(handle, outputNamesUTF8Encoded[index], 0, outputPreferredLocationsEncoded[index]);\n            if (errorCode2 !== 0) {\n              checkLastError(`Can\'t bind output[${i}] to ${outputPreferredLocations[i]} for session=${sessionId}.`);\n            }\n          }\n        }\n      }\n      let errorCode;\n      if (ioBindingState) {\n        errorCode = await wasm2._OrtRunWithBinding(\n          sessionHandle,\n          ioBindingState.handle,\n          outputCount,\n          outputValuesOffset,\n          runOptionsHandle\n        );\n      } else {\n        errorCode = await wasm2._OrtRun(\n          sessionHandle,\n          inputNamesOffset,\n          inputValuesOffset,\n          inputCount,\n          outputNamesOffset,\n          outputCount,\n          outputValuesOffset,\n          runOptionsHandle\n        );\n      }\n      if (errorCode !== 0) {\n        checkLastError("failed to call OrtRun().");\n      }\n      const output = [];\n      for (let i = 0; i < outputCount; i++) {\n        const tensor = wasm2.HEAPU32[outputValuesOffset / 4 + i];\n        if (tensor === outputTensorHandles[i]) {\n          output.push(outputTensors[i]);\n          continue;\n        }\n        const beforeGetTensorDataStack = wasm2.stackSave();\n        const tensorDataOffset = wasm2.stackAlloc(4 * 4);\n        let keepOutputTensor = false;\n        let type, dataOffset = 0;\n        try {\n          const errorCode2 = wasm2._OrtGetTensorData(\n            tensor,\n            tensorDataOffset,\n            tensorDataOffset + 4,\n            tensorDataOffset + 8,\n            tensorDataOffset + 12\n          );\n          if (errorCode2 !== 0) {\n            checkLastError(`Can\'t access output tensor data on index ${i}.`);\n          }\n          let tensorDataIndex = tensorDataOffset / 4;\n          const dataType = wasm2.HEAPU32[tensorDataIndex++];\n          dataOffset = wasm2.HEAPU32[tensorDataIndex++];\n          const dimsOffset = wasm2.HEAPU32[tensorDataIndex++];\n          const dimsLength = wasm2.HEAPU32[tensorDataIndex++];\n          const dims = [];\n          for (let i2 = 0; i2 < dimsLength; i2++) {\n            dims.push(wasm2.HEAPU32[dimsOffset / 4 + i2]);\n          }\n          wasm2._OrtFree(dimsOffset);\n          const size = dims.reduce((a, b) => a * b, 1);\n          type = tensorDataTypeEnumToString(dataType);\n          const preferredLocation = ioBindingState?.outputPreferredLocations[outputIndices[i]];\n          if (type === "string") {\n            if (preferredLocation === "gpu-buffer") {\n              throw new Error("String tensor is not supported on GPU.");\n            }\n            const stringData = [];\n            let dataIndex = dataOffset / 4;\n            for (let i2 = 0; i2 < size; i2++) {\n              const offset = wasm2.HEAPU32[dataIndex++];\n              const maxBytesToRead = i2 === size - 1 ? void 0 : wasm2.HEAPU32[dataIndex] - offset;\n              stringData.push(wasm2.UTF8ToString(offset, maxBytesToRead));\n            }\n            output.push([type, dims, stringData, "cpu"]);\n          } else {\n            if (preferredLocation === "gpu-buffer" && size > 0) {\n              const gpuBuffer = wasm2.jsepGetBuffer(dataOffset);\n              const elementSize = getTensorElementSize(dataType);\n              if (elementSize === void 0 || !isGpuBufferSupportedType(type)) {\n                throw new Error(`Unsupported data type: ${type}`);\n              }\n              keepOutputTensor = true;\n              output.push([\n                type,\n                dims,\n                {\n                  gpuBuffer,\n                  download: wasm2.jsepCreateDownloader(gpuBuffer, size * elementSize, type),\n                  dispose: () => {\n                    wasm2._OrtReleaseTensor(tensor);\n                  }\n                },\n                "gpu-buffer"\n              ]);\n            } else {\n              const typedArrayConstructor = tensorTypeToTypedArrayConstructor(type);\n              const data = new typedArrayConstructor(size);\n              new Uint8Array(data.buffer, data.byteOffset, data.byteLength).set(wasm2.HEAPU8.subarray(dataOffset, dataOffset + data.byteLength));\n              output.push([type, dims, data, "cpu"]);\n            }\n          }\n        } finally {\n          wasm2.stackRestore(beforeGetTensorDataStack);\n          if (type === "string" && dataOffset) {\n            wasm2._free(dataOffset);\n          }\n          if (!keepOutputTensor) {\n            wasm2._OrtReleaseTensor(tensor);\n          }\n        }\n      }\n      if (ioBindingState) {\n        wasm2._OrtClearBoundOutputs(ioBindingState.handle);\n      }\n      return output;\n    } finally {\n      wasm2.stackRestore(beforeRunStack);\n      inputTensorHandles.forEach((v) => wasm2._OrtReleaseTensor(v));\n      outputTensorHandles.forEach((v) => wasm2._OrtReleaseTensor(v));\n      inputOutputAllocs.forEach((p) => wasm2._free(p));\n      if (runOptionsHandle !== 0) {\n        wasm2._OrtReleaseRunOptions(runOptionsHandle);\n      }\n      runOptionsAllocs.forEach((p) => wasm2._free(p));\n    }\n  };\n  var endProfiling = (sessionId) => {\n    const wasm2 = getInstance();\n    const session = activeSessions.get(sessionId);\n    if (!session) {\n      throw new Error("invalid session id");\n    }\n    const sessionHandle = session[0];\n    const profileFileName = wasm2._OrtEndProfiling(sessionHandle);\n    if (profileFileName === 0) {\n      checkLastError("Can\'t get an profile file name.");\n    }\n    wasm2._OrtFree(profileFileName);\n  };\n  var extractTransferableBuffers = (tensors) => {\n    const buffers = [];\n    for (const tensor of tensors) {\n      const data = tensor[2];\n      if (!Array.isArray(data) && "buffer" in data) {\n        buffers.push(data.buffer);\n      }\n    }\n    return buffers;\n  };\n\n  // web/lib/wasm/proxy-worker/main.ts\n  self.onmessage = (ev) => {\n    const { type, in: message } = ev.data;\n    try {\n      switch (type) {\n        case "init-wasm":\n          initializeWebAssembly(message.wasm).then(\n            () => {\n              initRuntime(message).then(\n                () => {\n                  postMessage({ type });\n                },\n                (err) => {\n                  postMessage({ type, err });\n                }\n              );\n            },\n            (err) => {\n              postMessage({ type, err });\n            }\n          );\n          break;\n        case "init-ep": {\n          const { epName, env: env3 } = message;\n          initEp(env3, epName).then(\n            () => {\n              postMessage({ type });\n            },\n            (err) => {\n              postMessage({ type, err });\n            }\n          );\n          break;\n        }\n        case "copy-from": {\n          const { buffer } = message;\n          const bufferData = copyFromExternalBuffer(buffer);\n          postMessage({ type, out: bufferData });\n          break;\n        }\n        case "create": {\n          const { model, options } = message;\n          createSession(model, options).then(\n            (sessionMetadata) => {\n              postMessage({ type, out: sessionMetadata });\n            },\n            (err) => {\n              postMessage({ type, err });\n            }\n          );\n          break;\n        }\n        case "release":\n          releaseSession(message);\n          postMessage({ type });\n          break;\n        case "run": {\n          const { sessionId, inputIndices, inputs, outputIndices, options } = message;\n          run(sessionId, inputIndices, inputs, outputIndices, new Array(outputIndices.length).fill(null), options).then(\n            (outputs) => {\n              if (outputs.some((o) => o[3] !== "cpu")) {\n                postMessage({ type, err: "Proxy does not support non-cpu tensor location." });\n              } else {\n                postMessage(\n                  { type, out: outputs },\n                  extractTransferableBuffers(outputs)\n                );\n              }\n            },\n            (err) => {\n              postMessage({ type, err });\n            }\n          );\n          break;\n        }\n        case "end-profiling":\n          endProfiling(message);\n          postMessage({ type });\n          break;\n        default:\n      }\n    } catch (err) {\n      postMessage({ type, err });\n    }\n  };\n})();\n/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsibm9kZWpzLWlnbm9yZTpmcyIsICJub2RlanMtaWdub3JlOnBhdGgiLCAiLi4vbGliL3dhc20vYmluZGluZy9vcnQtd2FzbS1zaW1kLmpzZXAuanMiLCAibm9kZWpzLWlnbm9yZTp3b3JrZXJfdGhyZWFkcyIsICJub2RlanMtaWdub3JlOnBlcmZfaG9va3MiLCAibm9kZWpzLWlnbm9yZTpvcyIsICIuLi9saWIvd2FzbS9iaW5kaW5nL29ydC13YXNtLXNpbWQtdGhyZWFkZWQuanNlcC5qcyIsICIuLi9saWIvd2FzbS9iaW5kaW5nL29ydC13YXNtLXRocmVhZGVkLndvcmtlci5qcyIsICIuLi9saWIvd2FzbS93YXNtLWNvbW1vbi50cyIsICIuLi8uLi9jb21tb24vbGliL2JhY2tlbmQtaW1wbC50cyIsICIuLi8uLi9jb21tb24vbGliL2JhY2tlbmQudHMiLCAiLi4vLi4vY29tbW9uL2xpYi92ZXJzaW9uLnRzIiwgIi4uLy4uL2NvbW1vbi9saWIvZW52LWltcGwudHMiLCAiLi4vLi4vY29tbW9uL2xpYi9lbnYudHMiLCAiLi4vLi4vY29tbW9uL2xpYi90ZW5zb3ItY29udmVyc2lvbi1pbXBsLnRzIiwgIi4uLy4uL2NvbW1vbi9saWIvdGVuc29yLWZhY3RvcnktaW1wbC50cyIsICIuLi8uLi9jb21tb24vbGliL3RlbnNvci1pbXBsLXR5cGUtbWFwcGluZy50cyIsICIuLi8uLi9jb21tb24vbGliL3RlbnNvci11dGlscy1pbXBsLnRzIiwgIi4uLy4uL2NvbW1vbi9saWIvdGVuc29yLWltcGwudHMiLCAiLi4vLi4vY29tbW9uL2xpYi90ZW5zb3IudHMiLCAiLi4vLi4vY29tbW9uL2xpYi90cmFjZS50cyIsICIuLi8uLi9jb21tb24vbGliL2luZmVyZW5jZS1zZXNzaW9uLWltcGwudHMiLCAiLi4vLi4vY29tbW9uL2xpYi9pbmZlcmVuY2Utc2Vzc2lvbi50cyIsICIuLi8uLi9jb21tb24vbGliL29ubngtdmFsdWUudHMiLCAiLi4vLi4vY29tbW9uL2xpYi90cmFpbmluZy1zZXNzaW9uLWltcGwudHMiLCAiLi4vLi4vY29tbW9uL2xpYi90cmFpbmluZy1zZXNzaW9uLnRzIiwgIi4uLy4uL2NvbW1vbi9saWIvaW5kZXgudHMiLCAiLi4vbGliL3dhc20vanNlcC9sb2cudHMiLCAiLi4vbGliL3dhc20vanNlcC90ZW5zb3Itdmlldy50cyIsICIuLi9saWIvd2FzbS9qc2VwL3dlYmdwdS90eXBlcy50cyIsICIuLi9saWIvd2FzbS9qc2VwL3dlYmdwdS9ncHUtZGF0YS1tYW5hZ2VyLnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvd2ViZ3B1L2F0dHJpYnV0ZS13aXRoLWNhY2hlLWtleS50cyIsICIuLi9saWIvd2FzbS9qc2VwL3V0aWwudHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvb3BzL2NvbW1vbi50cyIsICIuLi9saWIvd2FzbS9qc2VwL3dlYmdwdS9vcHMvdHJhbnNwb3NlLnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvd2ViZ3B1L29wcy9yZWR1Y2Utc2hhcmVkLnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvd2ViZ3B1L29wcy9yZWR1Y2UudHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvb3BzL2FyZ21pbm1heC50cyIsICIuLi9saWIvd2FzbS9qc2VwL3dlYmdwdS9vcHMvYXR0ZW50aW9uLnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvd2ViZ3B1L29wcy9iYXRjaC1ub3JtLnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvd2ViZ3B1L29wcy9iaWFzLWFkZC50cyIsICIuLi9saWIvd2FzbS9qc2VwL3dlYmdwdS9vcHMvdW5hcnktb3AudHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvb3BzL2JpYXMtc3BsaXQtZ2VsdS50cyIsICIuLi9saWIvd2FzbS9qc2VwL3dlYmdwdS9vcHMvYmluYXJ5LW9wLnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvd2ViZ3B1L29wcy9jb25jYXQudHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvb3BzL2Z1c2UtdXRpbHMudHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvb3BzLzNyZC1wYXJ0eS9hY3RpdmF0aW9uX3V0aWwudHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvb3BzLzNyZC1wYXJ0eS9jb252X3V0aWwudHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvb3BzLzNyZC1wYXJ0eS9tYXRtdWxfcGFja2VkX3dlYmdwdS50cyIsICIuLi9saWIvd2FzbS9qc2VwL3dlYmdwdS9vcHMvM3JkLXBhcnR5L2NvbnYyZF9tbV93ZWJncHUudHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvb3BzL2NvbnYtZ3JvdXBlZC50cyIsICIuLi9saWIvd2FzbS9qc2VwL3dlYmdwdS9vcHMvbWF0bXVsLnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvd2ViZ3B1L29wcy9jb252LnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvd2ViZ3B1L29wcy8zcmQtcGFydHkvY29udl9iYWNrcHJvcF9tbV93ZWJncHUudHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvb3BzLzNyZC1wYXJ0eS9jb252X2JhY2twcm9wX3dlYmdwdS50cyIsICIuLi9saWIvd2FzbS9qc2VwL3dlYmdwdS9vcHMvY29udi10cmFuc3Bvc2UudHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvb3BzL2N1bXN1bS50cyIsICIuLi9saWIvd2FzbS9qc2VwL3dlYmdwdS9vcHMvZWluc3VtLnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvd2ViZ3B1L29wcy9leHBhbmQudHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvb3BzL2dhdGhlci50cyIsICIuLi9saWIvd2FzbS9qc2VwL3dlYmdwdS9vcHMvZ2F0aGVyLWVsZW1lbnRzLnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvd2ViZ3B1L29wcy9nZW1tLnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvd2ViZ3B1L29wcy9pbnN0YW5jZS1ub3JtLnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvd2ViZ3B1L29wcy9sYXllci1ub3JtLnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvd2ViZ3B1L29wcy9tdWx0aS1oZWFkLWF0dGVudGlpb24udHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvb3BzL3BhZC50cyIsICIuLi9saWIvd2FzbS9qc2VwL3dlYmdwdS9vcHMvcG9vbC50cyIsICIuLi9saWIvd2FzbS9qc2VwL3dlYmdwdS9vcHMvcmFuZ2UudHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvb3BzL3Jlc2l6ZS50cyIsICIuLi9saWIvd2FzbS9qc2VwL3dlYmdwdS9vcHMvc2tpcC1sYXllci1ub3JtLnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvd2ViZ3B1L29wcy9zbGljZS50cyIsICIuLi9saWIvd2FzbS9qc2VwL3dlYmdwdS9vcHMvc29mdG1heC50cyIsICIuLi9saWIvd2FzbS9qc2VwL3dlYmdwdS9vcHMvc3BsaXQudHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvb3BzL3RpbGUudHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvb3BzL3doZXJlLnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvd2ViZ3B1L29wLXJlc29sdmUtcnVsZXMudHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvcHJvZ3JhbS1tYW5hZ2VyLnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvYmFja2VuZC13ZWJncHUudHMiLCAiLi4vbGliL3dhc20vanNlcC9pbml0LnRzIiwgIm5vZGVqcy1pZ25vcmU6bm9kZTpwYXRoIiwgIi4uL2xpYi93YXNtL3dhc20tZmFjdG9yeS50cyIsICIuLi9saWIvd2FzbS93YXNtLXV0aWxzLnRzIiwgIi4uL2xpYi93YXNtL3J1bi1vcHRpb25zLnRzIiwgIi4uL2xpYi93YXNtL3Nlc3Npb24tb3B0aW9ucy50cyIsICIuLi9saWIvd2FzbS93YXNtLWNvcmUtaW1wbC50cyIsICIuLi9saWIvd2FzbS93YXNtLXV0aWxzLWxvYWQtZmlsZS50cyIsICJub2RlanMtaWdub3JlOm5vZGU6ZnMvcHJvbWlzZXMiLCAiLi4vbGliL3dhc20vcHJveHktd29ya2VyL21haW4udHMiXSwKICAic291cmNlc0NvbnRlbnQiOiBbImV4cG9ydCBjb25zdCByZWFkRmlsZSA9IHVuZGVmaW5lZDtleHBvcnQgY29uc3QgcmVhZEZpbGVTeW5jID0gdW5kZWZpbmVkO2V4cG9ydCBjb25zdCBjcmVhdGVSZWFkU3RyZWFtID0gdW5kZWZpbmVkOyIsICJleHBvcnQgY29uc3Qgam9pbiA9IHVuZGVmaW5lZDsiLCAiXG52YXIgb3J0V2FzbSA9ICgoKSA9PiB7XG4gIHZhciBfc2NyaXB0RGlyID0gdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiBkb2N1bWVudC5jdXJyZW50U2NyaXB0ID8gZG9jdW1lbnQuY3VycmVudFNjcmlwdC5zcmMgOiB1bmRlZmluZWQ7XG4gIGlmICh0eXBlb2YgX19maWxlbmFtZSAhPT0gJ3VuZGVmaW5lZCcpIF9zY3JpcHREaXIgPSBfc2NyaXB0RGlyIHx8IF9fZmlsZW5hbWU7XG4gIHJldHVybiAoXG5mdW5jdGlvbihtb2R1bGVBcmcgPSB7fSkge1xuXG52YXIgZD1tb2R1bGVBcmcsYWEsaztkLnJlYWR5PW5ldyBQcm9taXNlKChhLGIpPT57YWE9YTtrPWJ9KTtcInVzZSBzdHJpY3RcIjtkLm1vdW50RXh0ZXJuYWxEYXRhPShhLGIpPT57KGQuRmF8fChkLkZhPW5ldyBNYXApKS5zZXQoYSxiKX07ZC51bm1vdW50RXh0ZXJuYWxEYXRhPSgpPT57ZGVsZXRlIGQuRmF9O1xuZC5qc2VwSW5pdD0oYSxiLGMsZSxnLGgsbCx0KT0+e2QuYWI9YTtkLlFhPWI7ZC5TYT1jO2QuTGE9ZTtkLlJhPWc7ZC5zYT1oO2QuVGE9bDtkLlVhPXQ7Yj0obSxuLHEpPT4oLi4udSk9Pntjb25zdCB3PXAsZj1uPy4oKTt1PW0oLi4udSk7Y29uc3Qgcj1uPy4oKTtmIT09ciYmKG09cixxKGYpLG49cT1udWxsKTtyZXR1cm4gcCE9dz9iYSgpOnV9O2M9bT0+YXN5bmMoLi4ubik9Pnt0cnl7aWYoZC5FYSl0aHJvdyBFcnJvcihcIlNlc3Npb24gYWxyZWFkeSBzdGFydGVkXCIpO2NvbnN0IHE9ZC5FYT17VmE6blswXSxlcnJvcnM6W119LHU9YXdhaXQgbSguLi5uKTtpZihkLkVhIT09cSl0aHJvdyBFcnJvcihcIlNlc3Npb24gbWlzbWF0Y2hcIik7YS5mbHVzaCgpO2NvbnN0IHc9cS5lcnJvcnM7aWYoMDx3Lmxlbmd0aCl7bGV0IGY9YXdhaXQgUHJvbWlzZS5hbGwodyk7Zj1mLmZpbHRlcihyPT5yKTtpZigwPGYubGVuZ3RoKXRocm93IEVycm9yKGYuam9pbihcIlxcblwiKSk7fXJldHVybiB1fWZpbmFsbHl7ZC5FYT1cbm51bGx9fTtkLl9PcnRSdW49YyhiKGQuX09ydFJ1biwoKT0+ZC5fT3J0UnVuLG09PmQuX09ydFJ1bj1tKSk7ZC5fT3J0UnVuV2l0aEJpbmRpbmc9YyhiKGQuX09ydFJ1bldpdGhCaW5kaW5nLCgpPT5kLl9PcnRSdW5XaXRoQmluZGluZyxtPT5kLl9PcnRSdW5XaXRoQmluZGluZz1tKSk7ZC5fT3J0QmluZElucHV0PWIoZC5fT3J0QmluZElucHV0LCgpPT5kLl9PcnRCaW5kSW5wdXQsbT0+ZC5fT3J0QmluZElucHV0PW0pO2QuanNlcFJlZ2lzdGVyQnVmZmVyPShtLG4scSx1KT0+YS5yZWdpc3RlckJ1ZmZlcihtLG4scSx1KTtkLmpzZXBVbnJlZ2lzdGVyQnVmZmVycz1tPT57YS51bnJlZ2lzdGVyQnVmZmVycyhtKX07ZC5qc2VwR2V0QnVmZmVyPW09PmEuZ2V0QnVmZmVyKG0pO2QuanNlcENyZWF0ZURvd25sb2FkZXI9KG0sbixxKT0+YS5jcmVhdGVEb3dubG9hZGVyKG0sbixxKX07XG52YXIgY2E9T2JqZWN0LmFzc2lnbih7fSxkKSxkYT1cIi4vdGhpcy5wcm9ncmFtXCIseD0oYSxiKT0+e3Rocm93IGI7fSxlYT1cIm9iamVjdFwiPT10eXBlb2Ygd2luZG93LHk9XCJmdW5jdGlvblwiPT10eXBlb2YgaW1wb3J0U2NyaXB0cyxmYT1cIm9iamVjdFwiPT10eXBlb2YgcHJvY2VzcyYmXCJvYmplY3RcIj09dHlwZW9mIHByb2Nlc3MudmVyc2lvbnMmJlwic3RyaW5nXCI9PXR5cGVvZiBwcm9jZXNzLnZlcnNpb25zLm5vZGUsej1cIlwiLEEsQixDO1xuaWYoZmEpe3ZhciBmcz1yZXF1aXJlKFwiZnNcIiksRD1yZXF1aXJlKFwicGF0aFwiKTt6PXk/RC5kaXJuYW1lKHopK1wiL1wiOl9fZGlybmFtZStcIi9cIjtBPShhLGIpPT57YT1FKGEpP25ldyBVUkwoYSk6RC5ub3JtYWxpemUoYSk7cmV0dXJuIGZzLnJlYWRGaWxlU3luYyhhLGI/dm9pZCAwOlwidXRmOFwiKX07Qz1hPT57YT1BKGEsITApO2EuYnVmZmVyfHwoYT1uZXcgVWludDhBcnJheShhKSk7cmV0dXJuIGF9O0I9KGEsYixjLGU9ITApPT57YT1FKGEpP25ldyBVUkwoYSk6RC5ub3JtYWxpemUoYSk7ZnMucmVhZEZpbGUoYSxlP3ZvaWQgMDpcInV0ZjhcIiwoZyxoKT0+e2c/YyhnKTpiKGU/aC5idWZmZXI6aCl9KX07IWQudGhpc1Byb2dyYW0mJjE8cHJvY2Vzcy5hcmd2Lmxlbmd0aCYmKGRhPXByb2Nlc3MuYXJndlsxXS5yZXBsYWNlKC9cXFxcL2csXCIvXCIpKTtwcm9jZXNzLmFyZ3Yuc2xpY2UoMik7eD0oYSxiKT0+e3Byb2Nlc3MuZXhpdENvZGU9YTt0aHJvdyBiO307ZC5pbnNwZWN0PSgpPT5cIltFbXNjcmlwdGVuIE1vZHVsZSBvYmplY3RdXCJ9ZWxzZSBpZihlYXx8XG55KXk/ej1zZWxmLmxvY2F0aW9uLmhyZWY6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGRvY3VtZW50JiZkb2N1bWVudC5jdXJyZW50U2NyaXB0JiYoej1kb2N1bWVudC5jdXJyZW50U2NyaXB0LnNyYyksX3NjcmlwdERpciYmKHo9X3NjcmlwdERpciksMCE9PXouaW5kZXhPZihcImJsb2I6XCIpP3o9ei5zdWJzdHIoMCx6LnJlcGxhY2UoL1s/I10uKi8sXCJcIikubGFzdEluZGV4T2YoXCIvXCIpKzEpOno9XCJcIixBPWE9Pnt2YXIgYj1uZXcgWE1MSHR0cFJlcXVlc3Q7Yi5vcGVuKFwiR0VUXCIsYSwhMSk7Yi5zZW5kKG51bGwpO3JldHVybiBiLnJlc3BvbnNlVGV4dH0seSYmKEM9YT0+e3ZhciBiPW5ldyBYTUxIdHRwUmVxdWVzdDtiLm9wZW4oXCJHRVRcIixhLCExKTtiLnJlc3BvbnNlVHlwZT1cImFycmF5YnVmZmVyXCI7Yi5zZW5kKG51bGwpO3JldHVybiBuZXcgVWludDhBcnJheShiLnJlc3BvbnNlKX0pLEI9KGEsYixjKT0+e3ZhciBlPW5ldyBYTUxIdHRwUmVxdWVzdDtlLm9wZW4oXCJHRVRcIixhLCEwKTtlLnJlc3BvbnNlVHlwZT1cblwiYXJyYXlidWZmZXJcIjtlLm9ubG9hZD0oKT0+ezIwMD09ZS5zdGF0dXN8fDA9PWUuc3RhdHVzJiZlLnJlc3BvbnNlP2IoZS5yZXNwb25zZSk6YygpfTtlLm9uZXJyb3I9YztlLnNlbmQobnVsbCl9O3ZhciBoYT1jb25zb2xlLmxvZy5iaW5kKGNvbnNvbGUpLEc9Y29uc29sZS5lcnJvci5iaW5kKGNvbnNvbGUpO09iamVjdC5hc3NpZ24oZCxjYSk7Y2E9bnVsbDtcIm9iamVjdFwiIT10eXBlb2YgV2ViQXNzZW1ibHkmJkgoXCJubyBuYXRpdmUgd2FzbSBzdXBwb3J0IGRldGVjdGVkXCIpO3ZhciBJLEo9ITEsSyxMLE0sTixPLGlhLGphO1xuZnVuY3Rpb24ga2EoKXt2YXIgYT1JLmJ1ZmZlcjtkLkhFQVA4PUw9bmV3IEludDhBcnJheShhKTtkLkhFQVAxNj1uZXcgSW50MTZBcnJheShhKTtkLkhFQVBVOD1NPW5ldyBVaW50OEFycmF5KGEpO2QuSEVBUFUxNj1uZXcgVWludDE2QXJyYXkoYSk7ZC5IRUFQMzI9Tj1uZXcgSW50MzJBcnJheShhKTtkLkhFQVBVMzI9Tz1uZXcgVWludDMyQXJyYXkoYSk7ZC5IRUFQRjMyPWlhPW5ldyBGbG9hdDMyQXJyYXkoYSk7ZC5IRUFQRjY0PWphPW5ldyBGbG9hdDY0QXJyYXkoYSl9dmFyIGxhPVtdLG1hPVtdLG5hPVtdLFA9MCxvYT1udWxsLFE9bnVsbDtmdW5jdGlvbiBIKGEpe2E9XCJBYm9ydGVkKFwiK2ErXCIpXCI7RyhhKTtKPSEwO0s9MTthPW5ldyBXZWJBc3NlbWJseS5SdW50aW1lRXJyb3IoYStcIi4gQnVpbGQgd2l0aCAtc0FTU0VSVElPTlMgZm9yIG1vcmUgaW5mby5cIik7ayhhKTt0aHJvdyBhO31cbnZhciBwYT1hPT5hLnN0YXJ0c1dpdGgoXCJkYXRhOmFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbTtiYXNlNjQsXCIpLEU9YT0+YS5zdGFydHNXaXRoKFwiZmlsZTovL1wiKSxSO1I9XCJvcnQtd2FzbS1zaW1kLndhc21cIjtpZighcGEoUikpe3ZhciBxYT1SO1I9ZC5sb2NhdGVGaWxlP2QubG9jYXRlRmlsZShxYSx6KTp6K3FhfWZ1bmN0aW9uIHJhKGEpe2lmKEMpcmV0dXJuIEMoYSk7dGhyb3dcImJvdGggYXN5bmMgYW5kIHN5bmMgZmV0Y2hpbmcgb2YgdGhlIHdhc20gZmFpbGVkXCI7fVxuZnVuY3Rpb24gc2EoYSl7aWYoZWF8fHkpe2lmKFwiZnVuY3Rpb25cIj09dHlwZW9mIGZldGNoJiYhRShhKSlyZXR1cm4gZmV0Y2goYSx7Y3JlZGVudGlhbHM6XCJzYW1lLW9yaWdpblwifSkudGhlbihiPT57aWYoIWIub2spdGhyb3dcImZhaWxlZCB0byBsb2FkIHdhc20gYmluYXJ5IGZpbGUgYXQgJ1wiK2ErXCInXCI7cmV0dXJuIGIuYXJyYXlCdWZmZXIoKX0pLmNhdGNoKCgpPT5yYShhKSk7aWYoQilyZXR1cm4gbmV3IFByb21pc2UoKGIsYyk9PntCKGEsZT0+YihuZXcgVWludDhBcnJheShlKSksYyl9KX1yZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKT0+cmEoYSkpfWZ1bmN0aW9uIHRhKGEsYixjKXtyZXR1cm4gc2EoYSkudGhlbihlPT5XZWJBc3NlbWJseS5pbnN0YW50aWF0ZShlLGIpKS50aGVuKGU9PmUpLnRoZW4oYyxlPT57RyhgZmFpbGVkIHRvIGFzeW5jaHJvbm91c2x5IHByZXBhcmUgd2FzbTogJHtlfWApO0goZSl9KX1cbmZ1bmN0aW9uIHVhKGEsYil7dmFyIGM9UjtyZXR1cm5cImZ1bmN0aW9uXCIhPXR5cGVvZiBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZVN0cmVhbWluZ3x8cGEoYyl8fEUoYyl8fGZhfHxcImZ1bmN0aW9uXCIhPXR5cGVvZiBmZXRjaD90YShjLGEsYik6ZmV0Y2goYyx7Y3JlZGVudGlhbHM6XCJzYW1lLW9yaWdpblwifSkudGhlbihlPT5XZWJBc3NlbWJseS5pbnN0YW50aWF0ZVN0cmVhbWluZyhlLGEpLnRoZW4oYixmdW5jdGlvbihnKXtHKGB3YXNtIHN0cmVhbWluZyBjb21waWxlIGZhaWxlZDogJHtnfWApO0coXCJmYWxsaW5nIGJhY2sgdG8gQXJyYXlCdWZmZXIgaW5zdGFudGlhdGlvblwiKTtyZXR1cm4gdGEoYyxhLGIpfSkpfVxudmFyIFMsdmE9ezkzMTA1NjooYSxiLGMsZSk9PntpZihcInVuZGVmaW5lZFwiPT10eXBlb2YgZHx8IWQuRmEpcmV0dXJuIDE7YT1UKGE+Pj4wKTthLnN0YXJ0c1dpdGgoXCIuL1wiKSYmKGE9YS5zdWJzdHJpbmcoMikpO2E9ZC5GYS5nZXQoYSk7aWYoIWEpcmV0dXJuIDI7Yj4+Pj0wO2M+Pj49MDtpZihiK2M+YS5ieXRlTGVuZ3RoKXJldHVybiAzO3RyeXtyZXR1cm4gTS5zZXQoYS5zdWJhcnJheShiLGIrYyksZT4+PjA+Pj4wKSwwfWNhdGNoe3JldHVybiA0fX0sOTMxNTU3OmE9PmQuUWEoYSksOTMxNTkwOmE9PmQuU2EoYSksOTMxNjIyOihhLGIsYyk9PntkLkxhKGEsYixjLCEwKX0sOTMxNjYxOihhLGIsYyk9PntkLkxhKGEsYixjKX0sOTMxNjk0OmE9PntkLnNhKFwiQWJzXCIsYSx2b2lkIDApfSw5MzE3NDU6YT0+e2Quc2EoXCJOZWdcIixhLHZvaWQgMCl9LDkzMTc5NjphPT57ZC5zYShcIkZsb29yXCIsYSx2b2lkIDApfSw5MzE4NDk6YT0+e2Quc2EoXCJDZWlsXCIsYSx2b2lkIDApfSw5MzE5MDE6YT0+XG57ZC5zYShcIlJlY2lwcm9jYWxcIixhLHZvaWQgMCl9LDkzMTk1OTphPT57ZC5zYShcIlNxcnRcIixhLHZvaWQgMCl9LDkzMjAxMTphPT57ZC5zYShcIkV4cFwiLGEsdm9pZCAwKX0sOTMyMDYyOmE9PntkLnNhKFwiRXJmXCIsYSx2b2lkIDApfSw5MzIxMTM6YT0+e2Quc2EoXCJTaWdtb2lkXCIsYSx2b2lkIDApfSw5MzIxNjg6YT0+e2Quc2EoXCJMb2dcIixhLHZvaWQgMCl9LDkzMjIxOTphPT57ZC5zYShcIlNpblwiLGEsdm9pZCAwKX0sOTMyMjcwOmE9PntkLnNhKFwiQ29zXCIsYSx2b2lkIDApfSw5MzIzMjE6YT0+e2Quc2EoXCJUYW5cIixhLHZvaWQgMCl9LDkzMjM3MjphPT57ZC5zYShcIkFzaW5cIixhLHZvaWQgMCl9LDkzMjQyNDphPT57ZC5zYShcIkFjb3NcIixhLHZvaWQgMCl9LDkzMjQ3NjphPT57ZC5zYShcIkF0YW5cIixhLHZvaWQgMCl9LDkzMjUyODphPT57ZC5zYShcIlNpbmhcIixhLHZvaWQgMCl9LDkzMjU4MDphPT57ZC5zYShcIkNvc2hcIixhLHZvaWQgMCl9LDkzMjYzMjphPT57ZC5zYShcIkFzaW5oXCIsYSx2b2lkIDApfSxcbjkzMjY4NTphPT57ZC5zYShcIkFjb3NoXCIsYSx2b2lkIDApfSw5MzI3Mzg6YT0+e2Quc2EoXCJBdGFuaFwiLGEsdm9pZCAwKX0sOTMyNzkxOmE9PntkLnNhKFwiVGFuaFwiLGEsdm9pZCAwKX0sOTMyODQzOmE9PntkLnNhKFwiTm90XCIsYSx2b2lkIDApfSw5MzI4OTQ6KGEsYixjKT0+e2Quc2EoXCJDbGlwXCIsYSx7bWluOmIsbWF4OmN9KX0sOTMyOTYzOmE9PntkLnNhKFwiQ2xpcFwiLGEsdm9pZCAwKX0sOTMzMDE1OihhLGIpPT57ZC5zYShcIkVsdVwiLGEse2FscGhhOmJ9KX0sOTMzMDczOmE9PntkLnNhKFwiUmVsdVwiLGEsdm9pZCAwKX0sOTMzMTI1OihhLGIpPT57ZC5zYShcIkxlYWt5UmVsdVwiLGEse2FscGhhOmJ9KX0sOTMzMTg5OihhLGIpPT57ZC5zYShcIlRocmVzaG9sZGVkUmVsdVwiLGEse2FscGhhOmJ9KX0sOTMzMjU5OihhLGIpPT57ZC5zYShcIkNhc3RcIixhLHt0bzpifSl9LDkzMzMxNzphPT57ZC5zYShcIkFkZFwiLGEsdm9pZCAwKX0sOTMzMzY4OmE9PntkLnNhKFwiU3ViXCIsYSx2b2lkIDApfSw5MzM0MTk6YT0+XG57ZC5zYShcIk11bFwiLGEsdm9pZCAwKX0sOTMzNDcwOmE9PntkLnNhKFwiRGl2XCIsYSx2b2lkIDApfSw5MzM1MjE6YT0+e2Quc2EoXCJQb3dcIixhLHZvaWQgMCl9LDkzMzU3MjphPT57ZC5zYShcIkVxdWFsXCIsYSx2b2lkIDApfSw5MzM2MjU6YT0+e2Quc2EoXCJHcmVhdGVyXCIsYSx2b2lkIDApfSw5MzM2ODA6YT0+e2Quc2EoXCJHcmVhdGVyT3JFcXVhbFwiLGEsdm9pZCAwKX0sOTMzNzQyOmE9PntkLnNhKFwiTGVzc1wiLGEsdm9pZCAwKX0sOTMzNzk0OmE9PntkLnNhKFwiTGVzc09yRXF1YWxcIixhLHZvaWQgMCl9LDkzMzg1MzooYSxiLGMsZSxnKT0+e2Quc2EoXCJSZWR1Y2VNZWFuXCIsYSx7a2VlcERpbXM6ISFiLG5vb3BXaXRoRW1wdHlBeGVzOiEhYyxheGVzOmU/QXJyYXkuZnJvbShOLnN1YmFycmF5KGU+Pj4wLGc+Pj4wKSk6W119KX0sOTM0MDEyOihhLGIsYyxlLGcpPT57ZC5zYShcIlJlZHVjZU1heFwiLGEse2tlZXBEaW1zOiEhYixub29wV2l0aEVtcHR5QXhlczohIWMsYXhlczplP0FycmF5LmZyb20oTi5zdWJhcnJheShlPj4+XG4wLGc+Pj4wKSk6W119KX0sOTM0MTcwOihhLGIsYyxlLGcpPT57ZC5zYShcIlJlZHVjZU1pblwiLGEse2tlZXBEaW1zOiEhYixub29wV2l0aEVtcHR5QXhlczohIWMsYXhlczplP0FycmF5LmZyb20oTi5zdWJhcnJheShlPj4+MCxnPj4+MCkpOltdfSl9LDkzNDMyODooYSxiLGMsZSxnKT0+e2Quc2EoXCJSZWR1Y2VQcm9kXCIsYSx7a2VlcERpbXM6ISFiLG5vb3BXaXRoRW1wdHlBeGVzOiEhYyxheGVzOmU/QXJyYXkuZnJvbShOLnN1YmFycmF5KGU+Pj4wLGc+Pj4wKSk6W119KX0sOTM0NDg3OihhLGIsYyxlLGcpPT57ZC5zYShcIlJlZHVjZVN1bVwiLGEse2tlZXBEaW1zOiEhYixub29wV2l0aEVtcHR5QXhlczohIWMsYXhlczplP0FycmF5LmZyb20oTi5zdWJhcnJheShlPj4+MCxnPj4+MCkpOltdfSl9LDkzNDY0NTooYSxiLGMsZSxnKT0+e2Quc2EoXCJSZWR1Y2VMMVwiLGEse2tlZXBEaW1zOiEhYixub29wV2l0aEVtcHR5QXhlczohIWMsYXhlczplP0FycmF5LmZyb20oTi5zdWJhcnJheShlPj4+MCxcbmc+Pj4wKSk6W119KX0sOTM0ODAyOihhLGIsYyxlLGcpPT57ZC5zYShcIlJlZHVjZUwyXCIsYSx7a2VlcERpbXM6ISFiLG5vb3BXaXRoRW1wdHlBeGVzOiEhYyxheGVzOmU/QXJyYXkuZnJvbShOLnN1YmFycmF5KGU+Pj4wLGc+Pj4wKSk6W119KX0sOTM0OTU5OihhLGIsYyxlLGcpPT57ZC5zYShcIlJlZHVjZUxvZ1N1bVwiLGEse2tlZXBEaW1zOiEhYixub29wV2l0aEVtcHR5QXhlczohIWMsYXhlczplP0FycmF5LmZyb20oTi5zdWJhcnJheShlPj4+MCxnPj4+MCkpOltdfSl9LDkzNTEyMDooYSxiLGMsZSxnKT0+e2Quc2EoXCJSZWR1Y2VTdW1TcXVhcmVcIixhLHtrZWVwRGltczohIWIsbm9vcFdpdGhFbXB0eUF4ZXM6ISFjLGF4ZXM6ZT9BcnJheS5mcm9tKE4uc3ViYXJyYXkoZT4+PjAsZz4+PjApKTpbXX0pfSw5MzUyODQ6KGEsYixjLGUsZyk9PntkLnNhKFwiUmVkdWNlTG9nU3VtRXhwXCIsYSx7a2VlcERpbXM6ISFiLG5vb3BXaXRoRW1wdHlBeGVzOiEhYyxheGVzOmU/QXJyYXkuZnJvbShOLnN1YmFycmF5KGU+Pj5cbjAsZz4+PjApKTpbXX0pfSw5MzU0NDg6YT0+e2Quc2EoXCJXaGVyZVwiLGEsdm9pZCAwKX0sOTM1NTAxOihhLGIsYyk9PntkLnNhKFwiVHJhbnNwb3NlXCIsYSx7cGVybTpiP0FycmF5LmZyb20oTi5zdWJhcnJheShiPj4+MCxjPj4+MCkpOltdfSl9LDkzNTYwOTooYSxiLGMsZSxnLGgsbCx0LG0sbixxLHUsdyxmLHIpPT57ZC5zYShcIkNvbnZUcmFuc3Bvc2VcIixhLHtmb3JtYXQ6bT9cIk5IV0NcIjpcIk5DSFdcIixhdXRvUGFkOmIsZGlsYXRpb25zOltjXSxncm91cDplLGtlcm5lbF9zaGFwZTpbZ10scGFkczpbaCxsXSxzdHJpZGVzOlt0XSx3SXNDb25zdDooKT0+ISFMW24+Pj4wXSxvdXRwdXRQYWRkaW5nOnE/QXJyYXkuZnJvbShOLnN1YmFycmF5KHE+Pj4wLHU+Pj4wKSk6W10sb3V0cHV0U2hhcGU6dz9BcnJheS5mcm9tKE4uc3ViYXJyYXkodz4+PjAsZj4+PjApKTpbXSxhY3RpdmF0aW9uOlQocil9KX0sOTM2MDExOihhLGIsYyxlLGcsaCxsLHQsbSxuLHEsdSx3LGYpPT57ZC5zYShcIkNvbnZUcmFuc3Bvc2VcIixcbmEse2Zvcm1hdDp0P1wiTkhXQ1wiOlwiTkNIV1wiLGF1dG9QYWQ6YixkaWxhdGlvbnM6QXJyYXkuZnJvbShOLnN1YmFycmF5KGM+Pj4wLChjPj4+MCkrMj4+PjApKSxncm91cDplLGtlcm5lbFNoYXBlOkFycmF5LmZyb20oTi5zdWJhcnJheShnPj4+MCwoZz4+PjApKzI+Pj4wKSkscGFkczpBcnJheS5mcm9tKE4uc3ViYXJyYXkoaD4+PjAsKGg+Pj4wKSs0Pj4+MCkpLHN0cmlkZXM6QXJyYXkuZnJvbShOLnN1YmFycmF5KGw+Pj4wLChsPj4+MCkrMj4+PjApKSx3SXNDb25zdDooKT0+ISFMW20+Pj4wXSxvdXRwdXRQYWRkaW5nOm4/QXJyYXkuZnJvbShOLnN1YmFycmF5KG4+Pj4wLHE+Pj4wKSk6W10sb3V0cHV0U2hhcGU6dT9BcnJheS5mcm9tKE4uc3ViYXJyYXkodT4+PjAsdz4+PjApKTpbXSxhY3RpdmF0aW9uOlQoZil9KX0sOTM2NTc2OihhLGIsYyxlLGcsaCxsLHQsbSxuLHEsdSx3LGYscik9PntkLnNhKFwiQ29udlRyYW5zcG9zZVwiLGEse2Zvcm1hdDptP1wiTkhXQ1wiOlwiTkNIV1wiLGF1dG9QYWQ6YixcbmRpbGF0aW9uczpbY10sZ3JvdXA6ZSxrZXJuZWxfc2hhcGU6W2ddLHBhZHM6W2gsbF0sc3RyaWRlczpbdF0sd0lzQ29uc3Q6KCk9PiEhTFtuPj4+MF0sb3V0cHV0UGFkZGluZzpxP0FycmF5LmZyb20oTi5zdWJhcnJheShxPj4+MCx1Pj4+MCkpOltdLG91dHB1dFNoYXBlOnc/QXJyYXkuZnJvbShOLnN1YmFycmF5KHc+Pj4wLGY+Pj4wKSk6W10sYWN0aXZhdGlvbjpUKHIpfSl9LDkzNjk3ODooYSxiLGMsZSxnLGgsbCx0LG0sbixxLHUsdyxmKT0+e2Quc2EoXCJDb252VHJhbnNwb3NlXCIsYSx7Zm9ybWF0OnQ/XCJOSFdDXCI6XCJOQ0hXXCIsYXV0b1BhZDpiLGRpbGF0aW9uczpBcnJheS5mcm9tKE4uc3ViYXJyYXkoYz4+PjAsKGM+Pj4wKSsyPj4+MCkpLGdyb3VwOmUsa2VybmVsU2hhcGU6QXJyYXkuZnJvbShOLnN1YmFycmF5KGc+Pj4wLChnPj4+MCkrMj4+PjApKSxwYWRzOkFycmF5LmZyb20oTi5zdWJhcnJheShoPj4+MCwoaD4+PjApKzQ+Pj4wKSksc3RyaWRlczpBcnJheS5mcm9tKE4uc3ViYXJyYXkobD4+PlxuMCwobD4+PjApKzI+Pj4wKSksd0lzQ29uc3Q6KCk9PiEhTFttPj4+MF0sb3V0cHV0UGFkZGluZzpuP0FycmF5LmZyb20oTi5zdWJhcnJheShuPj4+MCxxPj4+MCkpOltdLG91dHB1dFNoYXBlOnU/QXJyYXkuZnJvbShOLnN1YmFycmF5KHU+Pj4wLHc+Pj4wKSk6W10sYWN0aXZhdGlvbjpUKGYpfSl9LDkzNzU0MzooYSxiKT0+e2Quc2EoXCJHbG9iYWxBdmVyYWdlUG9vbFwiLGEse2Zvcm1hdDpiP1wiTkhXQ1wiOlwiTkNIV1wifSl9LDkzNzYzNDooYSxiLGMsZSxnLGgsbCx0LG0sbixxLHUsdyxmLHIsdik9PntkLnNhKFwiQXZlcmFnZVBvb2xcIixhLHtmb3JtYXQ6dj9cIk5IV0NcIjpcIk5DSFdcIixhdXRvX3BhZDpiLGNlaWxfbW9kZTpjLGNvdW50X2luY2x1ZGVfcGFkOmUsc3RvcmFnZV9vcmRlcjpnLGRpbGF0aW9uczpbaCxsXSxrZXJuZWxfc2hhcGU6W3QsbV0scGFkczpbbixxLHUsd10sc3RyaWRlczpbZixyXX0pfSw5Mzc5MTg6KGEsYik9PntkLnNhKFwiR2xvYmFsQXZlcmFnZVBvb2xcIixhLHtmb3JtYXQ6Yj9cblwiTkhXQ1wiOlwiTkNIV1wifSl9LDkzODAwOTooYSxiLGMsZSxnLGgsbCx0LG0sbixxLHUsdyxmLHIsdik9PntkLnNhKFwiQXZlcmFnZVBvb2xcIixhLHtmb3JtYXQ6dj9cIk5IV0NcIjpcIk5DSFdcIixhdXRvX3BhZDpiLGNlaWxfbW9kZTpjLGNvdW50X2luY2x1ZGVfcGFkOmUsc3RvcmFnZV9vcmRlcjpnLGRpbGF0aW9uczpbaCxsXSxrZXJuZWxfc2hhcGU6W3QsbV0scGFkczpbbixxLHUsd10sc3RyaWRlczpbZixyXX0pfSw5MzgyOTM6KGEsYik9PntkLnNhKFwiR2xvYmFsTWF4UG9vbFwiLGEse2Zvcm1hdDpiP1wiTkhXQ1wiOlwiTkNIV1wifSl9LDkzODM4MDooYSxiLGMsZSxnLGgsbCx0LG0sbixxLHUsdyxmLHIsdik9PntkLnNhKFwiTWF4UG9vbFwiLGEse2Zvcm1hdDp2P1wiTkhXQ1wiOlwiTkNIV1wiLGF1dG9fcGFkOmIsY2VpbF9tb2RlOmMsY291bnRfaW5jbHVkZV9wYWQ6ZSxzdG9yYWdlX29yZGVyOmcsZGlsYXRpb25zOltoLGxdLGtlcm5lbF9zaGFwZTpbdCxtXSxwYWRzOltuLHEsdSx3XSxzdHJpZGVzOltmLHJdfSl9LFxuOTM4NjYwOihhLGIpPT57ZC5zYShcIkdsb2JhbE1heFBvb2xcIixhLHtmb3JtYXQ6Yj9cIk5IV0NcIjpcIk5DSFdcIn0pfSw5Mzg3NDc6KGEsYixjLGUsZyxoLGwsdCxtLG4scSx1LHcsZixyLHYpPT57ZC5zYShcIk1heFBvb2xcIixhLHtmb3JtYXQ6dj9cIk5IV0NcIjpcIk5DSFdcIixhdXRvX3BhZDpiLGNlaWxfbW9kZTpjLGNvdW50X2luY2x1ZGVfcGFkOmUsc3RvcmFnZV9vcmRlcjpnLGRpbGF0aW9uczpbaCxsXSxrZXJuZWxfc2hhcGU6W3QsbV0scGFkczpbbixxLHUsd10sc3RyaWRlczpbZixyXX0pfSw5MzkwMjc6KGEsYixjLGUsZyk9PntkLnNhKFwiR2VtbVwiLGEse2FscGhhOmIsYmV0YTpjLHRyYW5zQTplLHRyYW5zQjpnfSl9LDkzOTEzMTphPT57ZC5zYShcIk1hdE11bFwiLGEsdm9pZCAwKX0sOTM5MTg1OihhLGIsYyxlKT0+e2Quc2EoXCJBcmdNYXhcIixhLHtrZWVwRGltczohIWIsc2VsZWN0TGFzdEluZGV4OiEhYyxheGlzOmV9KX0sOTM5MjkzOihhLGIsYyxlKT0+e2Quc2EoXCJBcmdNaW5cIixhLHtrZWVwRGltczohIWIsXG5zZWxlY3RMYXN0SW5kZXg6ISFjLGF4aXM6ZX0pfSw5Mzk0MDE6KGEsYik9PntkLnNhKFwiU29mdG1heFwiLGEse2F4aXM6Yn0pfSw5Mzk0NjQ6KGEsYik9PntkLnNhKFwiQ29uY2F0XCIsYSx7YXhpczpifSl9LDkzOTUyNDooYSxiLGMsZSxnKT0+e2Quc2EoXCJTcGxpdFwiLGEse2F4aXM6YixudW1PdXRwdXRzOmMsc3BsaXRTaXplczplP0FycmF5LmZyb20oTi5zdWJhcnJheShlPj4+MCxnPj4+MCkpOltdfSl9LDkzOTY2NDphPT57ZC5zYShcIkV4cGFuZFwiLGEsdm9pZCAwKX0sOTM5NzE4OihhLGIpPT57ZC5zYShcIkdhdGhlclwiLGEse2F4aXM6TnVtYmVyKGIpfSl9LDkzOTc4OTooYSxiKT0+e2Quc2EoXCJHYXRoZXJFbGVtZW50c1wiLGEse2F4aXM6TnVtYmVyKGIpfSl9LDkzOTg2ODooYSxiLGMsZSxnLGgsbCx0LG0sbixxKT0+e2Quc2EoXCJSZXNpemVcIixhLHthbnRpYWxpYXM6YixheGVzOmM/QXJyYXkuZnJvbShOLnN1YmFycmF5KGM+Pj4wLGU+Pj4wKSk6W10sY29vcmRpbmF0ZVRyYW5zZm9ybU1vZGU6VChnKSxcbmN1YmljQ29lZmZBOmgsZXhjbHVkZU91dHNpZGU6bCxleHRyYXBvbGF0aW9uVmFsdWU6dCxrZWVwQXNwZWN0UmF0aW9Qb2xpY3k6VChtKSxtb2RlOlQobiksbmVhcmVzdE1vZGU6VChxKX0pfSw5NDAyMTQ6KGEsYixjLGUsZyxoLGwpPT57ZC5zYShcIlNsaWNlXCIsYSx7c3RhcnRzOmI/QXJyYXkuZnJvbShOLnN1YmFycmF5KGI+Pj4wLGM+Pj4wKSk6W10sZW5kczplP0FycmF5LmZyb20oTi5zdWJhcnJheShlPj4+MCxnPj4+MCkpOltdLGF4ZXM6aD9BcnJheS5mcm9tKE4uc3ViYXJyYXkoaD4+PjAsbD4+PjApKTpbXX0pfSw5NDA0MzA6YT0+e2Quc2EoXCJUaWxlXCIsYSx2b2lkIDApfSw5NDA0ODI6KGEsYixjKT0+e2Quc2EoXCJMYXllck5vcm1hbGl6YXRpb25cIixhLHtheGlzOk51bWJlcihiKSxlcHNpbG9uOk51bWJlcihjKX0pfSw5NDA1ODk6KGEsYixjKT0+e2Quc2EoXCJJbnN0YW5jZU5vcm1hbGl6YXRpb25cIixhLHtlcHNpbG9uOmIsZm9ybWF0OmM/XCJOSFdDXCI6XCJOQ0hXXCJ9KX0sOTQwNzAzOihhLFxuYixjKT0+e2Quc2EoXCJJbnN0YW5jZU5vcm1hbGl6YXRpb25cIixhLHtlcHNpbG9uOmIsZm9ybWF0OmM/XCJOSFdDXCI6XCJOQ0hXXCJ9KX0sOTQwODE3OmE9PntkLnNhKFwiUmFuZ2VcIixhLHZvaWQgMCl9LDk0MDg3MDooYSxiKT0+e2Quc2EoXCJFaW5zdW1cIixhLHtlcXVhdGlvbjpUKGIpfSl9LDk0MDk1MTooYSxiLGMsZSxnKT0+e2Quc2EoXCJQYWRcIixhLHttb2RlOmIsdmFsdWU6YyxwYWRzOmU/QXJyYXkuZnJvbShOLnN1YmFycmF5KGU+Pj4wLGc+Pj4wKSk6W119KX0sOTQxMDc4OihhLGIsYyxlLGcsaCk9PntkLnNhKFwiQmF0Y2hOb3JtYWxpemF0aW9uXCIsYSx7ZXBzaWxvbjpiLG1vbWVudHVtOmMsc3BhdGlhbDohIWcsdHJhaW5pbmdNb2RlOiEhZSxmb3JtYXQ6aD9cIk5IV0NcIjpcIk5DSFdcIn0pfSw5NDEyNDc6KGEsYixjLGUsZyxoKT0+e2Quc2EoXCJCYXRjaE5vcm1hbGl6YXRpb25cIixhLHtlcHNpbG9uOmIsbW9tZW50dW06YyxzcGF0aWFsOiEhZyx0cmFpbmluZ01vZGU6ISFlLGZvcm1hdDpoP1wiTkhXQ1wiOlxuXCJOQ0hXXCJ9KX0sOTQxNDE2OihhLGIsYyk9PntkLnNhKFwiQ3VtU3VtXCIsYSx7ZXhjbHVzaXZlOk51bWJlcihiKSxyZXZlcnNlOk51bWJlcihjKX0pfSw5NDE1MTM6KGEsYixjLGUsZyxoLGwsdCxtKT0+e2Quc2EoXCJBdHRlbnRpb25cIixhLHtudW1IZWFkczpiLGlzVW5pZGlyZWN0aW9uYWw6YyxtYXNrRmlsdGVyVmFsdWU6ZSxzY2FsZTpnLGRvUm90YXJ5OmgscWt2SGlkZGVuU2l6ZXM6bD9BcnJheS5mcm9tKE4uc3ViYXJyYXkoTnVtYmVyKHQpPj4+MCxOdW1iZXIodCkrbD4+PjApKTpbXSxwYXN0UHJlc2VudFNoYXJlQnVmZmVyOiEhbX0pfSw5NDE3ODU6YT0+e2Quc2EoXCJHZWx1XCIsYSx2b2lkIDApfSw5NDE4Mzc6KGEsYixjLGUsZyxoKT0+e2Quc2EoXCJNdWx0aUhlYWRBdHRlbnRpb25cIixhLHtudW1IZWFkczpiLGlzVW5pZGlyZWN0aW9uYWw6YyxtYXNrRmlsdGVyVmFsdWU6ZSxzY2FsZTpnLGRvUm90YXJ5Omh9KX0sOTQxOTk2OmE9PntkLnNhKFwiQmlhc0FkZFwiLGEsdm9pZCAwKX0sOTQyMDUxOmE9Plxue2Quc2EoXCJCaWFzU3BsaXRHZWx1XCIsYSx2b2lkIDApfSw5NDIxMTI6KGEsYik9PntkLnNhKFwiU2tpcExheWVyTm9ybWFsaXphdGlvblwiLGEse2Vwc2lsb246Yn0pfSw5NDIxOTM6KGEsYixjLGUsZyxoLGwsdCxtLG4scSx1LHcpPT57ZC5zYShcIkNvbnZcIixhLHtmb3JtYXQ6bT9cIk5IV0NcIjpcIk5DSFdcIixhdXRvX3BhZDpiLGRpbGF0aW9uczpbY10sZ3JvdXA6ZSxrZXJuZWxfc2hhcGU6W2ddLHBhZHM6aD9BcnJheS5mcm9tKE4uc3ViYXJyYXkoaD4+PjAsbD4+PjApKTpbXSxzdHJpZGVzOlt0XSx3X2lzX2NvbnN0OigpPT4hIUxbbj4+PjBdLGFjdGl2YXRpb246VChxKSxhY3RpdmF0aW9uX3BhcmFtczp1P0FycmF5LmZyb20oaWEuc3ViYXJyYXkodT4+PjAsdz4+PjApKTpbXX0pfSw5NDI1NjM6KGEsYixjLGUsZyxoLGwsdCxtLG4scSx1LHcsZixyLHYpPT57ZC5zYShcIkNvbnZcIixhLHtmb3JtYXQ6dT9cIk5IV0NcIjpcIk5DSFdcIixhdXRvX3BhZDpiLGRpbGF0aW9uczpbYyxlXSxncm91cDpnLGtlcm5lbF9zaGFwZTpbaCxcbmxdLHBhZHM6dD9BcnJheS5mcm9tKE4uc3ViYXJyYXkodD4+PjAsbT4+PjApKTpbXSxzdHJpZGVzOltuLHFdLHdfaXNfY29uc3Q6KCk9PiEhTFt3Pj4+MF0sYWN0aXZhdGlvbjpUKGYpLGFjdGl2YXRpb25fcGFyYW1zOnI/QXJyYXkuZnJvbShpYS5zdWJhcnJheShyPj4+MCx2Pj4+MCkpOltdfSl9LDk0Mjk1NDphPT57ZC5UYShhKX0sOTQyOTg4OihhLGIpPT5kLlVhKGEsYixkLkVhLlZhLGQuRWEuZXJyb3JzKX07ZnVuY3Rpb24gd2EoYSl7dGhpcy5uYW1lPVwiRXhpdFN0YXR1c1wiO3RoaXMubWVzc2FnZT1gUHJvZ3JhbSB0ZXJtaW5hdGVkIHdpdGggZXhpdCgke2F9KWA7dGhpcy5zdGF0dXM9YX1cbmZ1bmN0aW9uIHhhKGEpe3RoaXMuSmE9YS0yNDt0aGlzLk9hPWZ1bmN0aW9uKGIpe09bdGhpcy5KYSs0Pj4+Mj4+PjBdPWJ9O3RoaXMuTmE9ZnVuY3Rpb24oYil7T1t0aGlzLkphKzg+Pj4yPj4+MF09Yn07dGhpcy4kYT1mdW5jdGlvbihiLGMpe3RoaXMuTWEoKTt0aGlzLk9hKGIpO3RoaXMuTmEoYyl9O3RoaXMuTWE9ZnVuY3Rpb24oKXtPW3RoaXMuSmErMTY+Pj4yPj4+MF09MH19XG52YXIgeWE9MCx6YT0wLEFhPVwidW5kZWZpbmVkXCIhPXR5cGVvZiBUZXh0RGVjb2Rlcj9uZXcgVGV4dERlY29kZXIoXCJ1dGY4XCIpOnZvaWQgMCxCYT0oYSxiLGMpPT57Yj4+Pj0wO3ZhciBlPWIrYztmb3IoYz1iO2FbY10mJiEoYz49ZSk7KSsrYztpZigxNjxjLWImJmEuYnVmZmVyJiZBYSlyZXR1cm4gQWEuZGVjb2RlKGEuc3ViYXJyYXkoYixjKSk7Zm9yKGU9XCJcIjtiPGM7KXt2YXIgZz1hW2IrK107aWYoZyYxMjgpe3ZhciBoPWFbYisrXSY2MztpZigxOTI9PShnJjIyNCkpZSs9U3RyaW5nLmZyb21DaGFyQ29kZSgoZyYzMSk8PDZ8aCk7ZWxzZXt2YXIgbD1hW2IrK10mNjM7Zz0yMjQ9PShnJjI0MCk/KGcmMTUpPDwxMnxoPDw2fGw6KGcmNyk8PDE4fGg8PDEyfGw8PDZ8YVtiKytdJjYzOzY1NTM2Pmc/ZSs9U3RyaW5nLmZyb21DaGFyQ29kZShnKTooZy09NjU1MzYsZSs9U3RyaW5nLmZyb21DaGFyQ29kZSg1NTI5NnxnPj4xMCw1NjMyMHxnJjEwMjMpKX19ZWxzZSBlKz1TdHJpbmcuZnJvbUNoYXJDb2RlKGcpfXJldHVybiBlfSxcblQ9KGEsYik9PihhPj4+PTApP0JhKE0sYSxiKTpcIlwiLENhPWE9Pntmb3IodmFyIGI9MCxjPTA7YzxhLmxlbmd0aDsrK2Mpe3ZhciBlPWEuY2hhckNvZGVBdChjKTsxMjc+PWU/YisrOjIwNDc+PWU/Yis9Mjo1NTI5Njw9ZSYmNTczNDM+PWU/KGIrPTQsKytjKTpiKz0zfXJldHVybiBifSxEYT0oYSxiLGMsZSk9PntjPj4+PTA7aWYoISgwPGUpKXJldHVybiAwO3ZhciBnPWM7ZT1jK2UtMTtmb3IodmFyIGg9MDtoPGEubGVuZ3RoOysraCl7dmFyIGw9YS5jaGFyQ29kZUF0KGgpO2lmKDU1Mjk2PD1sJiY1NzM0Mz49bCl7dmFyIHQ9YS5jaGFyQ29kZUF0KCsraCk7bD02NTUzNisoKGwmMTAyMyk8PDEwKXx0JjEwMjN9aWYoMTI3Pj1sKXtpZihjPj1lKWJyZWFrO2JbYysrPj4+MF09bH1lbHNle2lmKDIwNDc+PWwpe2lmKGMrMT49ZSlicmVhaztiW2MrKz4+PjBdPTE5MnxsPj42fWVsc2V7aWYoNjU1MzU+PWwpe2lmKGMrMj49ZSlicmVhaztiW2MrKz4+PjBdPTIyNHxsPj4xMn1lbHNle2lmKGMrXG4zPj1lKWJyZWFrO2JbYysrPj4+MF09MjQwfGw+PjE4O2JbYysrPj4+MF09MTI4fGw+PjEyJjYzfWJbYysrPj4+MF09MTI4fGw+PjYmNjN9YltjKys+Pj4wXT0xMjh8bCY2M319YltjPj4+MF09MDtyZXR1cm4gYy1nfSxVPWE9PjA9PT1hJTQmJigwIT09YSUxMDB8fDA9PT1hJTQwMCksRWE9WzAsMzEsNjAsOTEsMTIxLDE1MiwxODIsMjEzLDI0NCwyNzQsMzA1LDMzNV0sRmE9WzAsMzEsNTksOTAsMTIwLDE1MSwxODEsMjEyLDI0MywyNzMsMzA0LDMzNF0sSGE9YT0+e3ZhciBiPUNhKGEpKzEsYz1HYShiKTtjJiZEYShhLE0sYyxiKTtyZXR1cm4gY30sSWE9W10sSmE9KGEsYik9PntJYS5sZW5ndGg9MDtmb3IodmFyIGM7Yz1NW2ErKz4+PjBdOyl7dmFyIGU9MTA1IT1jO2UmPTExMiE9YztiKz1lJiZiJTg/NDowO0lhLnB1c2goMTEyPT1jP09bYj4+PjI+Pj4wXToxMDU9PWM/TltiPj4+Mj4+PjBdOmphW2I+Pj4zPj4+MF0pO2IrPWU/ODo0fXJldHVybiBJYX0sS2E9e30sTmE9KCk9PntpZighTWEpe3ZhciBhPVxue1VTRVI6XCJ3ZWJfdXNlclwiLExPR05BTUU6XCJ3ZWJfdXNlclwiLFBBVEg6XCIvXCIsUFdEOlwiL1wiLEhPTUU6XCIvaG9tZS93ZWJfdXNlclwiLExBTkc6KFwib2JqZWN0XCI9PXR5cGVvZiBuYXZpZ2F0b3ImJm5hdmlnYXRvci5sYW5ndWFnZXMmJm5hdmlnYXRvci5sYW5ndWFnZXNbMF18fFwiQ1wiKS5yZXBsYWNlKFwiLVwiLFwiX1wiKStcIi5VVEYtOFwiLF86ZGF8fFwiLi90aGlzLnByb2dyYW1cIn0sYjtmb3IoYiBpbiBLYSl2b2lkIDA9PT1LYVtiXT9kZWxldGUgYVtiXTphW2JdPUthW2JdO3ZhciBjPVtdO2ZvcihiIGluIGEpYy5wdXNoKGAke2J9PSR7YVtiXX1gKTtNYT1jfXJldHVybiBNYX0sTWEsT2E9W251bGwsW10sW11dLFBhPVszMSwyOSwzMSwzMCwzMSwzMCwzMSwzMSwzMCwzMSwzMCwzMV0sUWE9WzMxLDI4LDMxLDMwLDMxLDMwLDMxLDMxLDMwLDMxLDMwLDMxXTtmdW5jdGlvbiBSYShhKXt2YXIgYj1BcnJheShDYShhKSsxKTtEYShhLGIsMCxiLmxlbmd0aCk7cmV0dXJuIGJ9XG5mdW5jdGlvbiBTYShhLGIsYyxlKXtmdW5jdGlvbiBnKGYscix2KXtmb3IoZj1cIm51bWJlclwiPT10eXBlb2YgZj9mLnRvU3RyaW5nKCk6Znx8XCJcIjtmLmxlbmd0aDxyOylmPXZbMF0rZjtyZXR1cm4gZn1mdW5jdGlvbiBoKGYscil7cmV0dXJuIGcoZixyLFwiMFwiKX1mdW5jdGlvbiBsKGYscil7ZnVuY3Rpb24gdihMYSl7cmV0dXJuIDA+TGE/LTE6MDxMYT8xOjB9dmFyIEY7MD09PShGPXYoZi5nZXRGdWxsWWVhcigpLXIuZ2V0RnVsbFllYXIoKSkpJiYwPT09KEY9dihmLmdldE1vbnRoKCktci5nZXRNb250aCgpKSkmJihGPXYoZi5nZXREYXRlKCktci5nZXREYXRlKCkpKTtyZXR1cm4gRn1mdW5jdGlvbiB0KGYpe3N3aXRjaChmLmdldERheSgpKXtjYXNlIDA6cmV0dXJuIG5ldyBEYXRlKGYuZ2V0RnVsbFllYXIoKS0xLDExLDI5KTtjYXNlIDE6cmV0dXJuIGY7Y2FzZSAyOnJldHVybiBuZXcgRGF0ZShmLmdldEZ1bGxZZWFyKCksMCwzKTtjYXNlIDM6cmV0dXJuIG5ldyBEYXRlKGYuZ2V0RnVsbFllYXIoKSxcbjAsMik7Y2FzZSA0OnJldHVybiBuZXcgRGF0ZShmLmdldEZ1bGxZZWFyKCksMCwxKTtjYXNlIDU6cmV0dXJuIG5ldyBEYXRlKGYuZ2V0RnVsbFllYXIoKS0xLDExLDMxKTtjYXNlIDY6cmV0dXJuIG5ldyBEYXRlKGYuZ2V0RnVsbFllYXIoKS0xLDExLDMwKX19ZnVuY3Rpb24gbShmKXt2YXIgcj1mLkNhO2ZvcihmPW5ldyBEYXRlKChuZXcgRGF0ZShmLkRhKzE5MDAsMCwxKSkuZ2V0VGltZSgpKTswPHI7KXt2YXIgdj1mLmdldE1vbnRoKCksRj0oVShmLmdldEZ1bGxZZWFyKCkpP1BhOlFhKVt2XTtpZihyPkYtZi5nZXREYXRlKCkpci09Ri1mLmdldERhdGUoKSsxLGYuc2V0RGF0ZSgxKSwxMT52P2Yuc2V0TW9udGgodisxKTooZi5zZXRNb250aCgwKSxmLnNldEZ1bGxZZWFyKGYuZ2V0RnVsbFllYXIoKSsxKSk7ZWxzZXtmLnNldERhdGUoZi5nZXREYXRlKCkrcik7YnJlYWt9fXY9bmV3IERhdGUoZi5nZXRGdWxsWWVhcigpKzEsMCw0KTtyPXQobmV3IERhdGUoZi5nZXRGdWxsWWVhcigpLFxuMCw0KSk7dj10KHYpO3JldHVybiAwPj1sKHIsZik/MD49bCh2LGYpP2YuZ2V0RnVsbFllYXIoKSsxOmYuZ2V0RnVsbFllYXIoKTpmLmdldEZ1bGxZZWFyKCktMX1hPj4+PTA7Yj4+Pj0wO2M+Pj49MDtlPj4+PTA7dmFyIG49T1tlKzQwPj4+Mj4+PjBdO2U9e1lhOk5bZT4+PjI+Pj4wXSxYYTpOW2UrND4+PjI+Pj4wXSxHYTpOW2UrOD4+PjI+Pj4wXSxLYTpOW2UrMTI+Pj4yPj4+MF0sSGE6TltlKzE2Pj4+Mj4+PjBdLERhOk5bZSsyMD4+PjI+Pj4wXSx4YTpOW2UrMjQ+Pj4yPj4+MF0sQ2E6TltlKzI4Pj4+Mj4+PjBdLGJiOk5bZSszMj4+PjI+Pj4wXSxXYTpOW2UrMzY+Pj4yPj4+MF0sWmE6bj9UKG4pOlwiXCJ9O2M9VChjKTtuPXtcIiVjXCI6XCIlYSAlYiAlZCAlSDolTTolUyAlWVwiLFwiJURcIjpcIiVtLyVkLyV5XCIsXCIlRlwiOlwiJVktJW0tJWRcIixcIiVoXCI6XCIlYlwiLFwiJXJcIjpcIiVJOiVNOiVTICVwXCIsXCIlUlwiOlwiJUg6JU1cIixcIiVUXCI6XCIlSDolTTolU1wiLFwiJXhcIjpcIiVtLyVkLyV5XCIsXCIlWFwiOlwiJUg6JU06JVNcIixcblwiJUVjXCI6XCIlY1wiLFwiJUVDXCI6XCIlQ1wiLFwiJUV4XCI6XCIlbS8lZC8leVwiLFwiJUVYXCI6XCIlSDolTTolU1wiLFwiJUV5XCI6XCIleVwiLFwiJUVZXCI6XCIlWVwiLFwiJU9kXCI6XCIlZFwiLFwiJU9lXCI6XCIlZVwiLFwiJU9IXCI6XCIlSFwiLFwiJU9JXCI6XCIlSVwiLFwiJU9tXCI6XCIlbVwiLFwiJU9NXCI6XCIlTVwiLFwiJU9TXCI6XCIlU1wiLFwiJU91XCI6XCIldVwiLFwiJU9VXCI6XCIlVVwiLFwiJU9WXCI6XCIlVlwiLFwiJU93XCI6XCIld1wiLFwiJU9XXCI6XCIlV1wiLFwiJU95XCI6XCIleVwifTtmb3IodmFyIHEgaW4gbiljPWMucmVwbGFjZShuZXcgUmVnRXhwKHEsXCJnXCIpLG5bcV0pO3ZhciB1PVwiU3VuZGF5IE1vbmRheSBUdWVzZGF5IFdlZG5lc2RheSBUaHVyc2RheSBGcmlkYXkgU2F0dXJkYXlcIi5zcGxpdChcIiBcIiksdz1cIkphbnVhcnkgRmVicnVhcnkgTWFyY2ggQXByaWwgTWF5IEp1bmUgSnVseSBBdWd1c3QgU2VwdGVtYmVyIE9jdG9iZXIgTm92ZW1iZXIgRGVjZW1iZXJcIi5zcGxpdChcIiBcIik7bj17XCIlYVwiOmY9PnVbZi54YV0uc3Vic3RyaW5nKDAsMyksXCIlQVwiOmY9PnVbZi54YV0sXCIlYlwiOmY9Plxud1tmLkhhXS5zdWJzdHJpbmcoMCwzKSxcIiVCXCI6Zj0+d1tmLkhhXSxcIiVDXCI6Zj0+aCgoZi5EYSsxOTAwKS8xMDB8MCwyKSxcIiVkXCI6Zj0+aChmLkthLDIpLFwiJWVcIjpmPT5nKGYuS2EsMixcIiBcIiksXCIlZ1wiOmY9Pm0oZikudG9TdHJpbmcoKS5zdWJzdHJpbmcoMiksXCIlR1wiOmY9Pm0oZiksXCIlSFwiOmY9PmgoZi5HYSwyKSxcIiVJXCI6Zj0+e2Y9Zi5HYTswPT1mP2Y9MTI6MTI8ZiYmKGYtPTEyKTtyZXR1cm4gaChmLDIpfSxcIiVqXCI6Zj0+e2Zvcih2YXIgcj0wLHY9MDt2PD1mLkhhLTE7cis9KFUoZi5EYSsxOTAwKT9QYTpRYSlbdisrXSk7cmV0dXJuIGgoZi5LYStyLDMpfSxcIiVtXCI6Zj0+aChmLkhhKzEsMiksXCIlTVwiOmY9PmgoZi5YYSwyKSxcIiVuXCI6KCk9PlwiXFxuXCIsXCIlcFwiOmY9PjA8PWYuR2EmJjEyPmYuR2E/XCJBTVwiOlwiUE1cIixcIiVTXCI6Zj0+aChmLllhLDIpLFwiJXRcIjooKT0+XCJcXHRcIixcIiV1XCI6Zj0+Zi54YXx8NyxcIiVVXCI6Zj0+aChNYXRoLmZsb29yKChmLkNhKzctZi54YSkvNyksMiksXCIlVlwiOmY9Plxue3ZhciByPU1hdGguZmxvb3IoKGYuQ2ErNy0oZi54YSs2KSU3KS83KTsyPj0oZi54YSszNzEtZi5DYS0yKSU3JiZyKys7aWYocik1Mz09ciYmKHY9KGYueGErMzcxLWYuQ2EpJTcsND09dnx8Mz09diYmVShmLkRhKXx8KHI9MSkpO2Vsc2V7cj01Mjt2YXIgdj0oZi54YSs3LWYuQ2EtMSklNzsoND09dnx8NT09diYmVShmLkRhJTQwMC0xKSkmJnIrK31yZXR1cm4gaChyLDIpfSxcIiV3XCI6Zj0+Zi54YSxcIiVXXCI6Zj0+aChNYXRoLmZsb29yKChmLkNhKzctKGYueGErNiklNykvNyksMiksXCIleVwiOmY9PihmLkRhKzE5MDApLnRvU3RyaW5nKCkuc3Vic3RyaW5nKDIpLFwiJVlcIjpmPT5mLkRhKzE5MDAsXCIlelwiOmY9PntmPWYuV2E7dmFyIHI9MDw9ZjtmPU1hdGguYWJzKGYpLzYwO3JldHVybihyP1wiK1wiOlwiLVwiKStTdHJpbmcoXCIwMDAwXCIrKGYvNjAqMTAwK2YlNjApKS5zbGljZSgtNCl9LFwiJVpcIjpmPT5mLlphLFwiJSVcIjooKT0+XCIlXCJ9O2M9Yy5yZXBsYWNlKC8lJS9nLFwiXFx4MDBcXHgwMFwiKTtmb3IocSBpbiBuKWMuaW5jbHVkZXMocSkmJlxuKGM9Yy5yZXBsYWNlKG5ldyBSZWdFeHAocSxcImdcIiksbltxXShlKSkpO2M9Yy5yZXBsYWNlKC9cXDBcXDAvZyxcIiVcIik7cT1SYShjKTtpZihxLmxlbmd0aD5iKXJldHVybiAwO0wuc2V0KHEsYT4+PjApO3JldHVybiBxLmxlbmd0aC0xfXZhciBWPWE9Pnt0cnl7YSgpfWNhdGNoKGIpe0goYil9fTtmdW5jdGlvbiBUYSgpe3ZhciBhPVcsYj17fTtmb3IobGV0IFtjLGVdb2YgT2JqZWN0LmVudHJpZXMoYSkpYltjXT1cImZ1bmN0aW9uXCI9PXR5cGVvZiBlP2Z1bmN0aW9uKCl7WC5wdXNoKGMpO3RyeXtyZXR1cm4gZS5hcHBseShudWxsLGFyZ3VtZW50cyl9ZmluYWxseXtKfHwoWC5wb3AoKSxwJiYxPT09WSYmMD09PVgubGVuZ3RoJiYoWT0wLFYoVWEpLFwidW5kZWZpbmVkXCIhPXR5cGVvZiBGaWJlcnMmJkZpYmVycy5jYigpKSl9fTplO3JldHVybiBifXZhciBZPTAscD1udWxsLFZhPTAsWD1bXSxXYT17fSxYYT17fSxZYT0wLFphPW51bGwsJGE9W107XG5mdW5jdGlvbiBiYSgpe3JldHVybiBuZXcgUHJvbWlzZSgoYSxiKT0+e1phPXtyZXNvbHZlOmEscmVqZWN0OmJ9fSl9ZnVuY3Rpb24gYWIoKXt2YXIgYT1HYSg2NTU0OCksYj1hKzEyO09bYT4+PjI+Pj4wXT1iO09bYSs0Pj4+Mj4+PjBdPWIrNjU1MzY7Yj1YWzBdO3ZhciBjPVdhW2JdO3ZvaWQgMD09PWMmJihjPVlhKyssV2FbYl09YyxYYVtjXT1iKTtOW2ErOD4+PjI+Pj4wXT1jO3JldHVybiBhfVxuZnVuY3Rpb24gYmIoYSl7aWYoIUope2lmKDA9PT1ZKXt2YXIgYj0hMSxjPSExO2EoKGU9MCk9PntpZighSiYmKFZhPWUsYj0hMCxjKSl7WT0yO1YoKCk9PmNiKHApKTtcInVuZGVmaW5lZFwiIT10eXBlb2YgQnJvd3NlciYmQnJvd3Nlci5JYS5QYSYmQnJvd3Nlci5JYS5yZXN1bWUoKTtlPSExO3RyeXt2YXIgZz0oMCxXW1hhW05bcCs4Pj4+Mj4+PjBdXV0pKCl9Y2F0Y2godCl7Zz10LGU9ITB9dmFyIGg9ITE7aWYoIXApe3ZhciBsPVphO2wmJihaYT1udWxsLChlP2wucmVqZWN0OmwucmVzb2x2ZSkoZyksaD0hMCl9aWYoZSYmIWgpdGhyb3cgZzt9fSk7Yz0hMDtifHwoWT0xLHA9YWIoKSxcInVuZGVmaW5lZFwiIT10eXBlb2YgQnJvd3NlciYmQnJvd3Nlci5JYS5QYSYmQnJvd3Nlci5JYS5wYXVzZSgpLFYoKCk9PmRiKHApKSl9ZWxzZSAyPT09WT8oWT0wLFYoZWIpLGZiKHApLHA9bnVsbCwkYS5mb3JFYWNoKGU9PntpZighSil0cnl7ZSgpO3RyeXtLPUs9ZT1LLGQub25FeGl0Py4oZSksSj0hMCxcbngoZSxuZXcgd2EoZSkpfWNhdGNoKGcpe2cgaW5zdGFuY2VvZiB3YXx8XCJ1bndpbmRcIj09Z3x8eCgxLGcpfX1jYXRjaChnKXtnIGluc3RhbmNlb2Ygd2F8fFwidW53aW5kXCI9PWd8fHgoMSxnKX19KSk6SChgaW52YWxpZCBzdGF0ZTogJHtZfWApO3JldHVybiBWYX19ZnVuY3Rpb24gZ2IoYSl7cmV0dXJuIGJiKGI9PnthKCkudGhlbihiKX0pfVxudmFyIGpiPXtuOmZ1bmN0aW9uKGEsYixjKXtyZXR1cm4gZ2IoYXN5bmMoKT0+e2F3YWl0IGQuUmEoYSxiLGMpfSl9LGE6ZnVuY3Rpb24oYSxiLGMpe2E+Pj49MDsobmV3IHhhKGEpKS4kYShiPj4+MCxjPj4+MCk7eWE9YTt6YSsrO3Rocm93IHlhO30sZzpmdW5jdGlvbigpe3JldHVybiAwfSxKOmZ1bmN0aW9uKCl7fSxBOmZ1bmN0aW9uKCl7fSxDOmZ1bmN0aW9uKCl7fSxMOmZ1bmN0aW9uKCl7cmV0dXJuIDB9LEg6ZnVuY3Rpb24oKXt9LEQ6ZnVuY3Rpb24oKXt9LEc6ZnVuY3Rpb24oKXt9LGw6ZnVuY3Rpb24oKXt9LEI6ZnVuY3Rpb24oKXt9LHk6ZnVuY3Rpb24oKXt9LEk6ZnVuY3Rpb24oKXt9LHo6ZnVuY3Rpb24oKXt9LG06KCk9PjEscTpmdW5jdGlvbihhLGIsYyl7YT1iKzIwOTcxNTI+Pj4wPDQxOTQzMDUtISFhPyhhPj4+MCkrNDI5NDk2NzI5NipiOk5hTjtjPj4+PTA7YT1uZXcgRGF0ZSgxRTMqYSk7TltjPj4+Mj4+PjBdPWEuZ2V0VVRDU2Vjb25kcygpO05bYys0Pj4+Mj4+PjBdPVxuYS5nZXRVVENNaW51dGVzKCk7TltjKzg+Pj4yPj4+MF09YS5nZXRVVENIb3VycygpO05bYysxMj4+PjI+Pj4wXT1hLmdldFVUQ0RhdGUoKTtOW2MrMTY+Pj4yPj4+MF09YS5nZXRVVENNb250aCgpO05bYysyMD4+PjI+Pj4wXT1hLmdldFVUQ0Z1bGxZZWFyKCktMTkwMDtOW2MrMjQ+Pj4yPj4+MF09YS5nZXRVVENEYXkoKTtOW2MrMjg+Pj4yPj4+MF09KGEuZ2V0VGltZSgpLURhdGUuVVRDKGEuZ2V0VVRDRnVsbFllYXIoKSwwLDEsMCwwLDAsMCkpLzg2NEU1fDB9LHI6ZnVuY3Rpb24oYSxiLGMpe2E9YisyMDk3MTUyPj4+MDw0MTk0MzA1LSEhYT8oYT4+PjApKzQyOTQ5NjcyOTYqYjpOYU47Yz4+Pj0wO2E9bmV3IERhdGUoMUUzKmEpO05bYz4+PjI+Pj4wXT1hLmdldFNlY29uZHMoKTtOW2MrND4+PjI+Pj4wXT1hLmdldE1pbnV0ZXMoKTtOW2MrOD4+PjI+Pj4wXT1hLmdldEhvdXJzKCk7TltjKzEyPj4+Mj4+PjBdPWEuZ2V0RGF0ZSgpO05bYysxNj4+PjI+Pj4wXT1hLmdldE1vbnRoKCk7XG5OW2MrMjA+Pj4yPj4+MF09YS5nZXRGdWxsWWVhcigpLTE5MDA7TltjKzI0Pj4+Mj4+PjBdPWEuZ2V0RGF5KCk7TltjKzI4Pj4+Mj4+PjBdPShVKGEuZ2V0RnVsbFllYXIoKSk/RWE6RmEpW2EuZ2V0TW9udGgoKV0rYS5nZXREYXRlKCktMXwwO05bYyszNj4+PjI+Pj4wXT0tKDYwKmEuZ2V0VGltZXpvbmVPZmZzZXQoKSk7Yj0obmV3IERhdGUoYS5nZXRGdWxsWWVhcigpLDYsMSkpLmdldFRpbWV6b25lT2Zmc2V0KCk7dmFyIGU9KG5ldyBEYXRlKGEuZ2V0RnVsbFllYXIoKSwwLDEpKS5nZXRUaW1lem9uZU9mZnNldCgpO05bYyszMj4+PjI+Pj4wXT0oYiE9ZSYmYS5nZXRUaW1lem9uZU9mZnNldCgpPT1NYXRoLm1pbihlLGIpKXwwfSxzOmZ1bmN0aW9uKGEpe2E+Pj49MDt2YXIgYj1uZXcgRGF0ZShOW2ErMjA+Pj4yPj4+MF0rMTkwMCxOW2ErMTY+Pj4yPj4+MF0sTlthKzEyPj4+Mj4+PjBdLE5bYSs4Pj4+Mj4+PjBdLE5bYSs0Pj4+Mj4+PjBdLE5bYT4+PjI+Pj4wXSwwKSxjPU5bYSszMj4+PlxuMj4+PjBdLGU9Yi5nZXRUaW1lem9uZU9mZnNldCgpLGc9KG5ldyBEYXRlKGIuZ2V0RnVsbFllYXIoKSw2LDEpKS5nZXRUaW1lem9uZU9mZnNldCgpLGg9KG5ldyBEYXRlKGIuZ2V0RnVsbFllYXIoKSwwLDEpKS5nZXRUaW1lem9uZU9mZnNldCgpLGw9TWF0aC5taW4oaCxnKTswPmM/TlthKzMyPj4+Mj4+PjBdPU51bWJlcihnIT1oJiZsPT1lKTowPGMhPShsPT1lKSYmKGc9TWF0aC5tYXgoaCxnKSxiLnNldFRpbWUoYi5nZXRUaW1lKCkrNkU0KigoMDxjP2w6ZyktZSkpKTtOW2ErMjQ+Pj4yPj4+MF09Yi5nZXREYXkoKTtOW2ErMjg+Pj4yPj4+MF09KFUoYi5nZXRGdWxsWWVhcigpKT9FYTpGYSlbYi5nZXRNb250aCgpXStiLmdldERhdGUoKS0xfDA7TlthPj4+Mj4+PjBdPWIuZ2V0U2Vjb25kcygpO05bYSs0Pj4+Mj4+PjBdPWIuZ2V0TWludXRlcygpO05bYSs4Pj4+Mj4+PjBdPWIuZ2V0SG91cnMoKTtOW2ErMTI+Pj4yPj4+MF09Yi5nZXREYXRlKCk7TlthKzE2Pj4+Mj4+PjBdPWIuZ2V0TW9udGgoKTtcbk5bYSsyMD4+PjI+Pj4wXT1iLmdldFllYXIoKTthPWIuZ2V0VGltZSgpO2lzTmFOKGEpPyhOW2hiKCk+Pj4yPj4+MF09NjEsYT0tMSk6YS89MUUzO3JldHVybiBpYigoUz1hLDE8PStNYXRoLmFicyhTKT8wPFM/K01hdGguZmxvb3IoUy80Mjk0OTY3Mjk2KT4+PjA6fn4rTWF0aC5jZWlsKChTLSsofn5TPj4+MCkpLzQyOTQ5NjcyOTYpPj4+MDowKSksYT4+PjB9LG86ZnVuY3Rpb24oKXtyZXR1cm4tNTJ9LHA6ZnVuY3Rpb24oKXt9LHc6ZnVuY3Rpb24oYSxiLGMpe2Z1bmN0aW9uIGUobSl7cmV0dXJuKG09bS50b1RpbWVTdHJpbmcoKS5tYXRjaCgvXFwoKFtBLVphLXogXSspXFwpJC8pKT9tWzFdOlwiR01UXCJ9Yz4+Pj0wO3ZhciBnPShuZXcgRGF0ZSkuZ2V0RnVsbFllYXIoKSxoPW5ldyBEYXRlKGcsMCwxKSxsPW5ldyBEYXRlKGcsNiwxKTtnPWguZ2V0VGltZXpvbmVPZmZzZXQoKTt2YXIgdD1sLmdldFRpbWV6b25lT2Zmc2V0KCk7T1thPj4+MD4+PjI+Pj4wXT02MCpNYXRoLm1heChnLHQpO05bYj4+PlxuMD4+PjI+Pj4wXT1OdW1iZXIoZyE9dCk7YT1lKGgpO2I9ZShsKTthPUhhKGEpO2I9SGEoYik7dDxnPyhPW2M+Pj4yPj4+MF09YSxPW2MrND4+PjI+Pj4wXT1iKTooT1tjPj4+Mj4+PjBdPWIsT1tjKzQ+Pj4yPj4+MF09YSl9LGU6KCk9PntIKFwiXCIpfSxiOmZ1bmN0aW9uKGEsYixjKXthPj4+PTA7Yj1KYShiPj4+MCxjPj4+MCk7cmV0dXJuIHZhW2FdLmFwcGx5KG51bGwsYil9LGk6ZnVuY3Rpb24oYSxiLGMpe2E+Pj49MDtiPUphKGI+Pj4wLGM+Pj4wKTtyZXR1cm4gdmFbYV0uYXBwbHkobnVsbCxiKX0saDooKT0+RGF0ZS5ub3coKSx4OmZ1bmN0aW9uKCl7cmV0dXJuIDQyOTQ5MDE3NjB9LGM6KCk9PnBlcmZvcm1hbmNlLm5vdygpLEs6ZnVuY3Rpb24oYSxiLGMpe2I+Pj49MDtyZXR1cm4gTS5jb3B5V2l0aGluKGE+Pj4wPj4+MCxiPj4+MCxiKyhjPj4+MCk+Pj4wKX0sdTpmdW5jdGlvbihhKXthPj4+PTA7dmFyIGI9TS5sZW5ndGg7aWYoNDI5NDkwMTc2MDxhKXJldHVybiExO2Zvcih2YXIgYz1cbjE7ND49YztjKj0yKXt2YXIgZT1iKigxKy4yL2MpO2U9TWF0aC5taW4oZSxhKzEwMDY2MzI5Nik7dmFyIGc9TWF0aDtlPU1hdGgubWF4KGEsZSk7YTp7Zz0oZy5taW4uY2FsbChnLDQyOTQ5MDE3NjAsZSsoNjU1MzYtZSU2NTUzNiklNjU1MzYpLUkuYnVmZmVyLmJ5dGVMZW5ndGgrNjU1MzUpLzY1NTM2O3RyeXtJLmdyb3coZyk7a2EoKTt2YXIgaD0xO2JyZWFrIGF9Y2F0Y2gobCl7fWg9dm9pZCAwfWlmKGgpcmV0dXJuITB9cmV0dXJuITF9LEU6ZnVuY3Rpb24oYSxiKXthPj4+PTA7Yj4+Pj0wO3ZhciBjPTA7TmEoKS5mb3JFYWNoKChlLGcpPT57dmFyIGg9YitjO2c9T1thKzQqZz4+PjI+Pj4wXT1oO2ZvcihoPTA7aDxlLmxlbmd0aDsrK2gpTFtnKys+Pj4wPj4+MF09ZS5jaGFyQ29kZUF0KGgpO0xbZz4+PjA+Pj4wXT0wO2MrPWUubGVuZ3RoKzF9KTtyZXR1cm4gMH0sRjpmdW5jdGlvbihhLGIpe2E+Pj49MDtiPj4+PTA7dmFyIGM9TmEoKTtPW2E+Pj4yPj4+MF09Yy5sZW5ndGg7dmFyIGU9XG4wO2MuZm9yRWFjaChnPT5lKz1nLmxlbmd0aCsxKTtPW2I+Pj4yPj4+MF09ZTtyZXR1cm4gMH0sZjooKT0+NTIsazpmdW5jdGlvbigpe3JldHVybiA1Mn0sdDpmdW5jdGlvbigpe3JldHVybiA3MH0sajpmdW5jdGlvbihhLGIsYyxlKXtiPj4+PTA7Yz4+Pj0wO2U+Pj49MDtmb3IodmFyIGc9MCxoPTA7aDxjO2grKyl7dmFyIGw9T1tiPj4+Mj4+PjBdLHQ9T1tiKzQ+Pj4yPj4+MF07Yis9ODtmb3IodmFyIG09MDttPHQ7bSsrKXt2YXIgbj1NW2wrbT4+PjBdLHE9T2FbYV07MD09PW58fDEwPT09bj8oKDE9PT1hP2hhOkcpKEJhKHEsMCkpLHEubGVuZ3RoPTApOnEucHVzaChuKX1nKz10fU9bZT4+PjI+Pj4wXT1nO3JldHVybiAwfSx2OlNhLGQ6ZnVuY3Rpb24oYSxiLGMsZSl7cmV0dXJuIFNhKGE+Pj4wLGI+Pj4wLGM+Pj4wLGU+Pj4wKX19LFc9ZnVuY3Rpb24oKXtmdW5jdGlvbiBhKGMpe1c9Yy5leHBvcnRzO1c9VGEoKTtXPWtiKCk7ST1XLk07a2EoKTttYS51bnNoaWZ0KFcuTik7UC0tOzA9PVxuUCYmKG51bGwhPT1vYSYmKGNsZWFySW50ZXJ2YWwob2EpLG9hPW51bGwpLFEmJihjPVEsUT1udWxsLGMoKSkpO3JldHVybiBXfXZhciBiPXthOmpifTtQKys7aWYoZC5pbnN0YW50aWF0ZVdhc20pdHJ5e3JldHVybiBkLmluc3RhbnRpYXRlV2FzbShiLGEpfWNhdGNoKGMpe0coYE1vZHVsZS5pbnN0YW50aWF0ZVdhc20gY2FsbGJhY2sgZmFpbGVkIHdpdGggZXJyb3I6ICR7Y31gKSxrKGMpfXVhKGIsZnVuY3Rpb24oYyl7YShjLmluc3RhbmNlKX0pLmNhdGNoKGspO3JldHVybnt9fSgpO2QuX09ydEluaXQ9KGEsYik9PihkLl9PcnRJbml0PVcuTykoYSxiKTtkLl9PcnRHZXRMYXN0RXJyb3I9KGEsYik9PihkLl9PcnRHZXRMYXN0RXJyb3I9Vy5QKShhLGIpO2QuX09ydENyZWF0ZVNlc3Npb25PcHRpb25zPShhLGIsYyxlLGcsaCxsLHQsbSxuKT0+KGQuX09ydENyZWF0ZVNlc3Npb25PcHRpb25zPVcuUSkoYSxiLGMsZSxnLGgsbCx0LG0sbik7XG5kLl9PcnRBcHBlbmRFeGVjdXRpb25Qcm92aWRlcj0oYSxiKT0+KGQuX09ydEFwcGVuZEV4ZWN1dGlvblByb3ZpZGVyPVcuUikoYSxiKTtkLl9PcnRBZGRGcmVlRGltZW5zaW9uT3ZlcnJpZGU9KGEsYixjKT0+KGQuX09ydEFkZEZyZWVEaW1lbnNpb25PdmVycmlkZT1XLlMpKGEsYixjKTtkLl9PcnRBZGRTZXNzaW9uQ29uZmlnRW50cnk9KGEsYixjKT0+KGQuX09ydEFkZFNlc3Npb25Db25maWdFbnRyeT1XLlQpKGEsYixjKTtkLl9PcnRSZWxlYXNlU2Vzc2lvbk9wdGlvbnM9YT0+KGQuX09ydFJlbGVhc2VTZXNzaW9uT3B0aW9ucz1XLlUpKGEpO2QuX09ydENyZWF0ZVNlc3Npb249KGEsYixjKT0+KGQuX09ydENyZWF0ZVNlc3Npb249Vy5WKShhLGIsYyk7ZC5fT3J0UmVsZWFzZVNlc3Npb249YT0+KGQuX09ydFJlbGVhc2VTZXNzaW9uPVcuVykoYSk7ZC5fT3J0R2V0SW5wdXRPdXRwdXRDb3VudD0oYSxiLGMpPT4oZC5fT3J0R2V0SW5wdXRPdXRwdXRDb3VudD1XLlgpKGEsYixjKTtcbmQuX09ydEdldElucHV0TmFtZT0oYSxiKT0+KGQuX09ydEdldElucHV0TmFtZT1XLlkpKGEsYik7ZC5fT3J0R2V0T3V0cHV0TmFtZT0oYSxiKT0+KGQuX09ydEdldE91dHB1dE5hbWU9Vy5aKShhLGIpO2QuX09ydEZyZWU9YT0+KGQuX09ydEZyZWU9Vy5fKShhKTtkLl9PcnRDcmVhdGVUZW5zb3I9KGEsYixjLGUsZyxoKT0+KGQuX09ydENyZWF0ZVRlbnNvcj1XLiQpKGEsYixjLGUsZyxoKTtkLl9PcnRHZXRUZW5zb3JEYXRhPShhLGIsYyxlLGcpPT4oZC5fT3J0R2V0VGVuc29yRGF0YT1XLmFhKShhLGIsYyxlLGcpO2QuX09ydFJlbGVhc2VUZW5zb3I9YT0+KGQuX09ydFJlbGVhc2VUZW5zb3I9Vy5iYSkoYSk7ZC5fT3J0Q3JlYXRlUnVuT3B0aW9ucz0oYSxiLGMsZSk9PihkLl9PcnRDcmVhdGVSdW5PcHRpb25zPVcuY2EpKGEsYixjLGUpO2QuX09ydEFkZFJ1bkNvbmZpZ0VudHJ5PShhLGIsYyk9PihkLl9PcnRBZGRSdW5Db25maWdFbnRyeT1XLmRhKShhLGIsYyk7XG5kLl9PcnRSZWxlYXNlUnVuT3B0aW9ucz1hPT4oZC5fT3J0UmVsZWFzZVJ1bk9wdGlvbnM9Vy5lYSkoYSk7ZC5fT3J0Q3JlYXRlQmluZGluZz1hPT4oZC5fT3J0Q3JlYXRlQmluZGluZz1XLmZhKShhKTtkLl9PcnRCaW5kSW5wdXQ9KGEsYixjKT0+KGQuX09ydEJpbmRJbnB1dD1XLmdhKShhLGIsYyk7ZC5fT3J0QmluZE91dHB1dD0oYSxiLGMsZSk9PihkLl9PcnRCaW5kT3V0cHV0PVcuaGEpKGEsYixjLGUpO2QuX09ydENsZWFyQm91bmRPdXRwdXRzPWE9PihkLl9PcnRDbGVhckJvdW5kT3V0cHV0cz1XLmlhKShhKTtkLl9PcnRSZWxlYXNlQmluZGluZz1hPT4oZC5fT3J0UmVsZWFzZUJpbmRpbmc9Vy5qYSkoYSk7ZC5fT3J0UnVuV2l0aEJpbmRpbmc9KGEsYixjLGUsZyk9PihkLl9PcnRSdW5XaXRoQmluZGluZz1XLmthKShhLGIsYyxlLGcpO2QuX09ydFJ1bj0oYSxiLGMsZSxnLGgsbCx0KT0+KGQuX09ydFJ1bj1XLmxhKShhLGIsYyxlLGcsaCxsLHQpO1xuZC5fT3J0RW5kUHJvZmlsaW5nPWE9PihkLl9PcnRFbmRQcm9maWxpbmc9Vy5tYSkoYSk7ZC5fSnNlcE91dHB1dD0oYSxiLGMpPT4oZC5fSnNlcE91dHB1dD1XLm5hKShhLGIsYyk7ZC5fSnNlcEdldE5vZGVOYW1lPWE9PihkLl9Kc2VwR2V0Tm9kZU5hbWU9Vy5vYSkoYSk7dmFyIGhiPSgpPT4oaGI9Vy5wYSkoKSxHYT1kLl9tYWxsb2M9YT0+KEdhPWQuX21hbGxvYz1XLnFhKShhKSxmYj1kLl9mcmVlPWE9PihmYj1kLl9mcmVlPVcucmEpKGEpLGliPWE9PihpYj1XLnRhKShhKSxsYj0oKT0+KGxiPVcudWEpKCksbWI9YT0+KG1iPVcudmEpKGEpLG5iPWE9PihuYj1XLndhKShhKSxkYj1hPT4oZGI9Vy55YSkoYSksVWE9KCk9PihVYT1XLnphKSgpLGNiPWE9PihjYj1XLkFhKShhKSxlYj0oKT0+KGViPVcuQmEpKCk7ZC5fX19zdGFydF9lbV9qcz05NDMxMDA7ZC5fX19zdG9wX2VtX2pzPTk0MzI2MTtcbmZ1bmN0aW9uIGtiKCl7dmFyIGE9VzthPU9iamVjdC5hc3NpZ24oe30sYSk7dmFyIGI9ZT0+KCk9PmUoKT4+PjAsYz1lPT5nPT5lKGcpPj4+MDthLnBhPWIoYS5wYSk7YS5xYT1jKGEucWEpO2EudWE9YihhLnVhKTthLndhPWMoYS53YSk7cmV0dXJuIGF9ZC5zdGFja0FsbG9jPW5iO2Quc3RhY2tTYXZlPWxiO2Quc3RhY2tSZXN0b3JlPW1iO2QuVVRGOFRvU3RyaW5nPVQ7ZC5zdHJpbmdUb1VURjg9KGEsYixjKT0+RGEoYSxNLGIsYyk7ZC5sZW5ndGhCeXRlc1VURjg9Q2E7dmFyIFo7UT1mdW5jdGlvbiBvYigpe1p8fHBiKCk7Wnx8KFE9b2IpfTtcbmZ1bmN0aW9uIHBiKCl7aWYoISgwPFApKXtpZihkLnByZVJ1bilmb3IoXCJmdW5jdGlvblwiPT10eXBlb2YgZC5wcmVSdW4mJihkLnByZVJ1bj1bZC5wcmVSdW5dKTtkLnByZVJ1bi5sZW5ndGg7KXt2YXIgYT1kLnByZVJ1bi5zaGlmdCgpO2xhLnVuc2hpZnQoYSl9Zm9yKDswPGxhLmxlbmd0aDspbGEuc2hpZnQoKShkKTtpZighKDA8UHx8Wnx8KFo9ITAsZC5jYWxsZWRSdW49ITAsSikpKXtmb3IoOzA8bWEubGVuZ3RoOyltYS5zaGlmdCgpKGQpO2ZvcihhYShkKTswPG5hLmxlbmd0aDspbmEuc2hpZnQoKShkKX19fXBiKCk7XG5cblxuICByZXR1cm4gbW9kdWxlQXJnLnJlYWR5XG59XG4pO1xufSkoKTtcbjtcbmlmICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG4gIG1vZHVsZS5leHBvcnRzID0gb3J0V2FzbTtcbmVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lWydhbWQnXSlcbiAgZGVmaW5lKFtdLCAoKSA9PiBvcnRXYXNtKTtcbiIsICIiLCAiIiwgImV4cG9ydCBjb25zdCBjcHVzID0gdW5kZWZpbmVkOyIsICJcbnZhciBvcnRXYXNtVGhyZWFkZWQgPSAoKCkgPT4ge1xuICB2YXIgX3NjcmlwdERpciA9IHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgZG9jdW1lbnQuY3VycmVudFNjcmlwdCA/IGRvY3VtZW50LmN1cnJlbnRTY3JpcHQuc3JjIDogdW5kZWZpbmVkO1xuICBpZiAodHlwZW9mIF9fZmlsZW5hbWUgIT09ICd1bmRlZmluZWQnKSBfc2NyaXB0RGlyID0gX3NjcmlwdERpciB8fCBfX2ZpbGVuYW1lO1xuICByZXR1cm4gKFxuZnVuY3Rpb24obW9kdWxlQXJnID0ge30pIHtcblxuZnVuY3Rpb24gZCgpe2wuYnVmZmVyIT1tLmJ1ZmZlciYmdSgpO3JldHVybiBtfWZ1bmN0aW9uIHYoKXtsLmJ1ZmZlciE9bS5idWZmZXImJnUoKTtyZXR1cm4gYWF9ZnVuY3Rpb24geigpe2wuYnVmZmVyIT1tLmJ1ZmZlciYmdSgpO3JldHVybiBiYX1mdW5jdGlvbiBBKCl7bC5idWZmZXIhPW0uYnVmZmVyJiZ1KCk7cmV0dXJuIGNhfWZ1bmN0aW9uIGRhKCl7bC5idWZmZXIhPW0uYnVmZmVyJiZ1KCk7cmV0dXJuIGVhfWZ1bmN0aW9uIGZhKCl7bC5idWZmZXIhPW0uYnVmZmVyJiZ1KCk7cmV0dXJuIGhhfXZhciBCPW1vZHVsZUFyZyxpYSxDO0IucmVhZHk9bmV3IFByb21pc2UoKGEsYik9PntpYT1hO0M9Yn0pO1widXNlIHN0cmljdFwiO0IubW91bnRFeHRlcm5hbERhdGE9KGEsYik9PnsoQi5jYnx8KEIuY2I9bmV3IE1hcCkpLnNldChhLGIpfTtCLnVubW91bnRFeHRlcm5hbERhdGE9KCk9PntkZWxldGUgQi5jYn07XG5CLmpzZXBJbml0PShhLGIsYyxlLGYsaCxrLHEpPT57Qi5NYj1hO0Iud2I9YjtCLnliPWM7Qi5rYj1lO0IueGI9ZjtCLkVhPWg7Qi56Yj1rO0IuQWI9cTtiPShuLHAscik9PiguLi53KT0+e2NvbnN0IHk9RCxnPXA/LigpO3c9biguLi53KTtjb25zdCB0PXA/LigpO2chPT10JiYobj10LHIoZykscD1yPW51bGwpO3JldHVybiBEIT15P2phKCk6d307Yz1uPT5hc3luYyguLi5wKT0+e3RyeXtpZihCLmJiKXRocm93IEVycm9yKFwiU2Vzc2lvbiBhbHJlYWR5IHN0YXJ0ZWRcIik7Y29uc3Qgcj1CLmJiPXtDYjpwWzBdLGVycm9yczpbXX0sdz1hd2FpdCBuKC4uLnApO2lmKEIuYmIhPT1yKXRocm93IEVycm9yKFwiU2Vzc2lvbiBtaXNtYXRjaFwiKTthLmZsdXNoKCk7Y29uc3QgeT1yLmVycm9ycztpZigwPHkubGVuZ3RoKXtsZXQgZz1hd2FpdCBQcm9taXNlLmFsbCh5KTtnPWcuZmlsdGVyKHQ9PnQpO2lmKDA8Zy5sZW5ndGgpdGhyb3cgRXJyb3IoZy5qb2luKFwiXFxuXCIpKTt9cmV0dXJuIHd9ZmluYWxseXtCLmJiPVxubnVsbH19O0IuX09ydFJ1bj1jKGIoQi5fT3J0UnVuLCgpPT5CLl9PcnRSdW4sbj0+Qi5fT3J0UnVuPW4pKTtCLl9PcnRSdW5XaXRoQmluZGluZz1jKGIoQi5fT3J0UnVuV2l0aEJpbmRpbmcsKCk9PkIuX09ydFJ1bldpdGhCaW5kaW5nLG49PkIuX09ydFJ1bldpdGhCaW5kaW5nPW4pKTtCLl9PcnRCaW5kSW5wdXQ9YihCLl9PcnRCaW5kSW5wdXQsKCk9PkIuX09ydEJpbmRJbnB1dCxuPT5CLl9PcnRCaW5kSW5wdXQ9bik7Qi5qc2VwUmVnaXN0ZXJCdWZmZXI9KG4scCxyLHcpPT5hLnJlZ2lzdGVyQnVmZmVyKG4scCxyLHcpO0IuanNlcFVucmVnaXN0ZXJCdWZmZXJzPW49PnthLnVucmVnaXN0ZXJCdWZmZXJzKG4pfTtCLmpzZXBHZXRCdWZmZXI9bj0+YS5nZXRCdWZmZXIobik7Qi5qc2VwQ3JlYXRlRG93bmxvYWRlcj0obixwLHIpPT5hLmNyZWF0ZURvd25sb2FkZXIobixwLHIpfTtcbnZhciBrYT1PYmplY3QuYXNzaWduKHt9LEIpLGxhPVwiLi90aGlzLnByb2dyYW1cIixtYT0oYSxiKT0+e3Rocm93IGI7fSxuYT1cIm9iamVjdFwiPT10eXBlb2Ygd2luZG93LEU9XCJmdW5jdGlvblwiPT10eXBlb2YgaW1wb3J0U2NyaXB0cyxGPVwib2JqZWN0XCI9PXR5cGVvZiBwcm9jZXNzJiZcIm9iamVjdFwiPT10eXBlb2YgcHJvY2Vzcy52ZXJzaW9ucyYmXCJzdHJpbmdcIj09dHlwZW9mIHByb2Nlc3MudmVyc2lvbnMubm9kZSxHPUIuRU5WSVJPTk1FTlRfSVNfUFRIUkVBRHx8ITEsSD1cIlwiO2Z1bmN0aW9uIG9hKGEpe3JldHVybiBCLmxvY2F0ZUZpbGU/Qi5sb2NhdGVGaWxlKGEsSCk6SCthfXZhciBwYSxJLEo7XG5pZihGKXt2YXIgZnM9cmVxdWlyZShcImZzXCIpLHFhPXJlcXVpcmUoXCJwYXRoXCIpO0g9RT9xYS5kaXJuYW1lKEgpK1wiL1wiOl9fZGlybmFtZStcIi9cIjtwYT0oYixjKT0+e2I9cmEoYik/bmV3IFVSTChiKTpxYS5ub3JtYWxpemUoYik7cmV0dXJuIGZzLnJlYWRGaWxlU3luYyhiLGM/dm9pZCAwOlwidXRmOFwiKX07Sj1iPT57Yj1wYShiLCEwKTtiLmJ1ZmZlcnx8KGI9bmV3IFVpbnQ4QXJyYXkoYikpO3JldHVybiBifTtJPShiLGMsZSxmPSEwKT0+e2I9cmEoYik/bmV3IFVSTChiKTpxYS5ub3JtYWxpemUoYik7ZnMucmVhZEZpbGUoYixmP3ZvaWQgMDpcInV0ZjhcIiwoaCxrKT0+e2g/ZShoKTpjKGY/ay5idWZmZXI6ayl9KX07IUIudGhpc1Byb2dyYW0mJjE8cHJvY2Vzcy5hcmd2Lmxlbmd0aCYmKGxhPXByb2Nlc3MuYXJndlsxXS5yZXBsYWNlKC9cXFxcL2csXCIvXCIpKTtwcm9jZXNzLmFyZ3Yuc2xpY2UoMik7bWE9KGIsYyk9Pntwcm9jZXNzLmV4aXRDb2RlPWI7dGhyb3cgYzt9O0IuaW5zcGVjdD0oKT0+XG5cIltFbXNjcmlwdGVuIE1vZHVsZSBvYmplY3RdXCI7bGV0IGE7dHJ5e2E9cmVxdWlyZShcIndvcmtlcl90aHJlYWRzXCIpfWNhdGNoKGIpe3Rocm93IGNvbnNvbGUuZXJyb3IoJ1RoZSBcIndvcmtlcl90aHJlYWRzXCIgbW9kdWxlIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBub2RlLmpzIGJ1aWxkIC0gcGVyaGFwcyBhIG5ld2VyIHZlcnNpb24gaXMgbmVlZGVkPycpLGI7fWdsb2JhbC5Xb3JrZXI9YS5Xb3JrZXJ9ZWxzZSBpZihuYXx8RSlFP0g9c2VsZi5sb2NhdGlvbi5ocmVmOlwidW5kZWZpbmVkXCIhPXR5cGVvZiBkb2N1bWVudCYmZG9jdW1lbnQuY3VycmVudFNjcmlwdCYmKEg9ZG9jdW1lbnQuY3VycmVudFNjcmlwdC5zcmMpLCh0eXBlb2YgX3NjcmlwdERpciAhPT0gXCJ1bmRlZmluZWRcIiAmJiBfc2NyaXB0RGlyKSYmKEg9X3NjcmlwdERpciksMCE9PUguaW5kZXhPZihcImJsb2I6XCIpP0g9SC5zdWJzdHIoMCxILnJlcGxhY2UoL1s/I10uKi8sXCJcIikubGFzdEluZGV4T2YoXCIvXCIpKzEpOkg9XCJcIixGfHwocGE9YT0+e3ZhciBiPW5ldyBYTUxIdHRwUmVxdWVzdDtiLm9wZW4oXCJHRVRcIixcbmEsITEpO2Iuc2VuZChudWxsKTtyZXR1cm4gYi5yZXNwb25zZVRleHR9LEUmJihKPWE9Pnt2YXIgYj1uZXcgWE1MSHR0cFJlcXVlc3Q7Yi5vcGVuKFwiR0VUXCIsYSwhMSk7Yi5yZXNwb25zZVR5cGU9XCJhcnJheWJ1ZmZlclwiO2Iuc2VuZChudWxsKTtyZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYi5yZXNwb25zZSl9KSxJPShhLGIsYyk9Pnt2YXIgZT1uZXcgWE1MSHR0cFJlcXVlc3Q7ZS5vcGVuKFwiR0VUXCIsYSwhMCk7ZS5yZXNwb25zZVR5cGU9XCJhcnJheWJ1ZmZlclwiO2Uub25sb2FkPSgpPT57MjAwPT1lLnN0YXR1c3x8MD09ZS5zdGF0dXMmJmUucmVzcG9uc2U/YihlLnJlc3BvbnNlKTpjKCl9O2Uub25lcnJvcj1jO2Uuc2VuZChudWxsKX0pO0YmJlwidW5kZWZpbmVkXCI9PXR5cGVvZiBwZXJmb3JtYW5jZSYmKGdsb2JhbC5wZXJmb3JtYW5jZT1yZXF1aXJlKFwicGVyZl9ob29rc1wiKS5wZXJmb3JtYW5jZSk7dmFyIHNhPWNvbnNvbGUubG9nLmJpbmQoY29uc29sZSksdGE9Y29uc29sZS5lcnJvci5iaW5kKGNvbnNvbGUpO1xuRiYmKHNhPSguLi5hKT0+ZnMud3JpdGVTeW5jKDEsYS5qb2luKFwiIFwiKStcIlxcblwiKSx0YT0oLi4uYSk9PmZzLndyaXRlU3luYygyLGEuam9pbihcIiBcIikrXCJcXG5cIikpO3ZhciB1YT1zYSxLPXRhO09iamVjdC5hc3NpZ24oQixrYSk7a2E9bnVsbDtcIm9iamVjdFwiIT10eXBlb2YgV2ViQXNzZW1ibHkmJkwoXCJubyBuYXRpdmUgd2FzbSBzdXBwb3J0IGRldGVjdGVkXCIpO3ZhciBsLHZhLE09ITEsTyxtLGFhLGJhLGNhLGVhLGhhO1xuZnVuY3Rpb24gdSgpe3ZhciBhPWwuYnVmZmVyO0IuSEVBUDg9bT1uZXcgSW50OEFycmF5KGEpO0IuSEVBUDE2PW5ldyBJbnQxNkFycmF5KGEpO0IuSEVBUFU4PWFhPW5ldyBVaW50OEFycmF5KGEpO0IuSEVBUFUxNj1uZXcgVWludDE2QXJyYXkoYSk7Qi5IRUFQMzI9YmE9bmV3IEludDMyQXJyYXkoYSk7Qi5IRUFQVTMyPWNhPW5ldyBVaW50MzJBcnJheShhKTtCLkhFQVBGMzI9ZWE9bmV3IEZsb2F0MzJBcnJheShhKTtCLkhFQVBGNjQ9aGE9bmV3IEZsb2F0NjRBcnJheShhKX12YXIgd2E9MTY3NzcyMTY7XG5pZihHKWw9Qi53YXNtTWVtb3J5O2Vsc2UgaWYoQi53YXNtTWVtb3J5KWw9Qi53YXNtTWVtb3J5O2Vsc2UgaWYobD1uZXcgV2ViQXNzZW1ibHkuTWVtb3J5KHtpbml0aWFsOndhLzY1NTM2LG1heGltdW06NjU1MzYsc2hhcmVkOiEwfSksIShsLmJ1ZmZlciBpbnN0YW5jZW9mIFNoYXJlZEFycmF5QnVmZmVyKSl0aHJvdyBLKFwicmVxdWVzdGVkIGEgc2hhcmVkIFdlYkFzc2VtYmx5Lk1lbW9yeSBidXQgdGhlIHJldHVybmVkIGJ1ZmZlciBpcyBub3QgYSBTaGFyZWRBcnJheUJ1ZmZlciwgaW5kaWNhdGluZyB0aGF0IHdoaWxlIHRoZSBicm93c2VyIGhhcyBTaGFyZWRBcnJheUJ1ZmZlciBpdCBkb2VzIG5vdCBoYXZlIFdlYkFzc2VtYmx5IHRocmVhZHMgc3VwcG9ydCAtIHlvdSBtYXkgbmVlZCB0byBzZXQgYSBmbGFnXCIpLEYmJksoXCIob24gbm9kZSB5b3UgbWF5IG5lZWQ6IC0tZXhwZXJpbWVudGFsLXdhc20tdGhyZWFkcyAtLWV4cGVyaW1lbnRhbC13YXNtLWJ1bGstbWVtb3J5IGFuZC9vciByZWNlbnQgdmVyc2lvbilcIiksXG5FcnJvcihcImJhZCBtZW1vcnlcIik7dSgpO3dhPWwuYnVmZmVyLmJ5dGVMZW5ndGg7dmFyIHhhPVtdLHlhPVtdLHphPVtdLFA9MCxBYT1udWxsLFE9bnVsbDtmdW5jdGlvbiBCYSgpe1AtLTtpZigwPT1QJiYobnVsbCE9PUFhJiYoY2xlYXJJbnRlcnZhbChBYSksQWE9bnVsbCksUSkpe3ZhciBhPVE7UT1udWxsO2EoKX19ZnVuY3Rpb24gTChhKXthPVwiQWJvcnRlZChcIithK1wiKVwiO0soYSk7TT0hMDtPPTE7YT1uZXcgV2ViQXNzZW1ibHkuUnVudGltZUVycm9yKGErXCIuIEJ1aWxkIHdpdGggLXNBU1NFUlRJT05TIGZvciBtb3JlIGluZm8uXCIpO0MoYSk7dGhyb3cgYTt9dmFyIENhPWE9PmEuc3RhcnRzV2l0aChcImRhdGE6YXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtO2Jhc2U2NCxcIikscmE9YT0+YS5zdGFydHNXaXRoKFwiZmlsZTovL1wiKSxSO1I9XCJvcnQtd2FzbS1zaW1kLXRocmVhZGVkLndhc21cIjtDYShSKXx8KFI9b2EoUikpO1xuZnVuY3Rpb24gRGEoYSl7aWYoSilyZXR1cm4gSihhKTt0aHJvd1wiYm90aCBhc3luYyBhbmQgc3luYyBmZXRjaGluZyBvZiB0aGUgd2FzbSBmYWlsZWRcIjt9ZnVuY3Rpb24gRWEoYSl7aWYobmF8fEUpe2lmKFwiZnVuY3Rpb25cIj09dHlwZW9mIGZldGNoJiYhcmEoYSkpcmV0dXJuIGZldGNoKGEse2NyZWRlbnRpYWxzOlwic2FtZS1vcmlnaW5cIn0pLnRoZW4oYj0+e2lmKCFiLm9rKXRocm93XCJmYWlsZWQgdG8gbG9hZCB3YXNtIGJpbmFyeSBmaWxlIGF0ICdcIithK1wiJ1wiO3JldHVybiBiLmFycmF5QnVmZmVyKCl9KS5jYXRjaCgoKT0+RGEoYSkpO2lmKEkpcmV0dXJuIG5ldyBQcm9taXNlKChiLGMpPT57SShhLGU9PmIobmV3IFVpbnQ4QXJyYXkoZSkpLGMpfSl9cmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCk9PkRhKGEpKX1cbmZ1bmN0aW9uIEZhKGEsYixjKXtyZXR1cm4gRWEoYSkudGhlbihlPT5XZWJBc3NlbWJseS5pbnN0YW50aWF0ZShlLGIpKS50aGVuKGU9PmUpLnRoZW4oYyxlPT57SyhgZmFpbGVkIHRvIGFzeW5jaHJvbm91c2x5IHByZXBhcmUgd2FzbTogJHtlfWApO0woZSl9KX1mdW5jdGlvbiBHYShhLGIpe3ZhciBjPVI7cmV0dXJuXCJmdW5jdGlvblwiIT10eXBlb2YgV2ViQXNzZW1ibHkuaW5zdGFudGlhdGVTdHJlYW1pbmd8fENhKGMpfHxyYShjKXx8Rnx8XCJmdW5jdGlvblwiIT10eXBlb2YgZmV0Y2g/RmEoYyxhLGIpOmZldGNoKGMse2NyZWRlbnRpYWxzOlwic2FtZS1vcmlnaW5cIn0pLnRoZW4oZT0+V2ViQXNzZW1ibHkuaW5zdGFudGlhdGVTdHJlYW1pbmcoZSxhKS50aGVuKGIsZnVuY3Rpb24oZil7Syhgd2FzbSBzdHJlYW1pbmcgY29tcGlsZSBmYWlsZWQ6ICR7Zn1gKTtLKFwiZmFsbGluZyBiYWNrIHRvIEFycmF5QnVmZmVyIGluc3RhbnRpYXRpb25cIik7cmV0dXJuIEZhKGMsYSxiKX0pKX1cbnZhciBTLEhhPXs5MzI0Mjg6KGEsYixjLGUpPT57aWYoXCJ1bmRlZmluZWRcIj09dHlwZW9mIEJ8fCFCLmNiKXJldHVybiAxO2E9VChhPj4+MCk7YS5zdGFydHNXaXRoKFwiLi9cIikmJihhPWEuc3Vic3RyaW5nKDIpKTthPUIuY2IuZ2V0KGEpO2lmKCFhKXJldHVybiAyO2I+Pj49MDtjPj4+PTA7ZT4+Pj0wO2lmKGIrYz5hLmJ5dGVMZW5ndGgpcmV0dXJuIDM7dHJ5e3JldHVybiB2KCkuc2V0KGEuc3ViYXJyYXkoYixiK2MpLGU+Pj4wKSwwfWNhdGNoe3JldHVybiA0fX0sOTMyOTI5OmE9PkIud2IoYSksOTMyOTYyOmE9PkIueWIoYSksOTMyOTk0OihhLGIsYyk9PntCLmtiKGEsYixjLCEwKX0sOTMzMDMzOihhLGIsYyk9PntCLmtiKGEsYixjKX0sOTMzMDY2OmE9PntCLkVhKFwiQWJzXCIsYSx2b2lkIDApfSw5MzMxMTc6YT0+e0IuRWEoXCJOZWdcIixhLHZvaWQgMCl9LDkzMzE2ODphPT57Qi5FYShcIkZsb29yXCIsYSx2b2lkIDApfSw5MzMyMjE6YT0+e0IuRWEoXCJDZWlsXCIsYSx2b2lkIDApfSw5MzMyNzM6YT0+XG57Qi5FYShcIlJlY2lwcm9jYWxcIixhLHZvaWQgMCl9LDkzMzMzMTphPT57Qi5FYShcIlNxcnRcIixhLHZvaWQgMCl9LDkzMzM4MzphPT57Qi5FYShcIkV4cFwiLGEsdm9pZCAwKX0sOTMzNDM0OmE9PntCLkVhKFwiRXJmXCIsYSx2b2lkIDApfSw5MzM0ODU6YT0+e0IuRWEoXCJTaWdtb2lkXCIsYSx2b2lkIDApfSw5MzM1NDA6YT0+e0IuRWEoXCJMb2dcIixhLHZvaWQgMCl9LDkzMzU5MTphPT57Qi5FYShcIlNpblwiLGEsdm9pZCAwKX0sOTMzNjQyOmE9PntCLkVhKFwiQ29zXCIsYSx2b2lkIDApfSw5MzM2OTM6YT0+e0IuRWEoXCJUYW5cIixhLHZvaWQgMCl9LDkzMzc0NDphPT57Qi5FYShcIkFzaW5cIixhLHZvaWQgMCl9LDkzMzc5NjphPT57Qi5FYShcIkFjb3NcIixhLHZvaWQgMCl9LDkzMzg0ODphPT57Qi5FYShcIkF0YW5cIixhLHZvaWQgMCl9LDkzMzkwMDphPT57Qi5FYShcIlNpbmhcIixhLHZvaWQgMCl9LDkzMzk1MjphPT57Qi5FYShcIkNvc2hcIixhLHZvaWQgMCl9LDkzNDAwNDphPT57Qi5FYShcIkFzaW5oXCIsYSx2b2lkIDApfSxcbjkzNDA1NzphPT57Qi5FYShcIkFjb3NoXCIsYSx2b2lkIDApfSw5MzQxMTA6YT0+e0IuRWEoXCJBdGFuaFwiLGEsdm9pZCAwKX0sOTM0MTYzOmE9PntCLkVhKFwiVGFuaFwiLGEsdm9pZCAwKX0sOTM0MjE1OmE9PntCLkVhKFwiTm90XCIsYSx2b2lkIDApfSw5MzQyNjY6KGEsYixjKT0+e0IuRWEoXCJDbGlwXCIsYSx7bWluOmIsbWF4OmN9KX0sOTM0MzM1OmE9PntCLkVhKFwiQ2xpcFwiLGEsdm9pZCAwKX0sOTM0Mzg3OihhLGIpPT57Qi5FYShcIkVsdVwiLGEse2FscGhhOmJ9KX0sOTM0NDQ1OmE9PntCLkVhKFwiUmVsdVwiLGEsdm9pZCAwKX0sOTM0NDk3OihhLGIpPT57Qi5FYShcIkxlYWt5UmVsdVwiLGEse2FscGhhOmJ9KX0sOTM0NTYxOihhLGIpPT57Qi5FYShcIlRocmVzaG9sZGVkUmVsdVwiLGEse2FscGhhOmJ9KX0sOTM0NjMxOihhLGIpPT57Qi5FYShcIkNhc3RcIixhLHt0bzpifSl9LDkzNDY4OTphPT57Qi5FYShcIkFkZFwiLGEsdm9pZCAwKX0sOTM0NzQwOmE9PntCLkVhKFwiU3ViXCIsYSx2b2lkIDApfSw5MzQ3OTE6YT0+XG57Qi5FYShcIk11bFwiLGEsdm9pZCAwKX0sOTM0ODQyOmE9PntCLkVhKFwiRGl2XCIsYSx2b2lkIDApfSw5MzQ4OTM6YT0+e0IuRWEoXCJQb3dcIixhLHZvaWQgMCl9LDkzNDk0NDphPT57Qi5FYShcIkVxdWFsXCIsYSx2b2lkIDApfSw5MzQ5OTc6YT0+e0IuRWEoXCJHcmVhdGVyXCIsYSx2b2lkIDApfSw5MzUwNTI6YT0+e0IuRWEoXCJHcmVhdGVyT3JFcXVhbFwiLGEsdm9pZCAwKX0sOTM1MTE0OmE9PntCLkVhKFwiTGVzc1wiLGEsdm9pZCAwKX0sOTM1MTY2OmE9PntCLkVhKFwiTGVzc09yRXF1YWxcIixhLHZvaWQgMCl9LDkzNTIyNTooYSxiLGMsZSxmKT0+e0IuRWEoXCJSZWR1Y2VNZWFuXCIsYSx7a2VlcERpbXM6ISFiLG5vb3BXaXRoRW1wdHlBeGVzOiEhYyxheGVzOmU/QXJyYXkuZnJvbSh6KCkuc3ViYXJyYXkoZT4+PjAsZj4+PjApKTpbXX0pfSw5MzUzODQ6KGEsYixjLGUsZik9PntCLkVhKFwiUmVkdWNlTWF4XCIsYSx7a2VlcERpbXM6ISFiLG5vb3BXaXRoRW1wdHlBeGVzOiEhYyxheGVzOmU/QXJyYXkuZnJvbSh6KCkuc3ViYXJyYXkoZT4+PlxuMCxmPj4+MCkpOltdfSl9LDkzNTU0MjooYSxiLGMsZSxmKT0+e0IuRWEoXCJSZWR1Y2VNaW5cIixhLHtrZWVwRGltczohIWIsbm9vcFdpdGhFbXB0eUF4ZXM6ISFjLGF4ZXM6ZT9BcnJheS5mcm9tKHooKS5zdWJhcnJheShlPj4+MCxmPj4+MCkpOltdfSl9LDkzNTcwMDooYSxiLGMsZSxmKT0+e0IuRWEoXCJSZWR1Y2VQcm9kXCIsYSx7a2VlcERpbXM6ISFiLG5vb3BXaXRoRW1wdHlBeGVzOiEhYyxheGVzOmU/QXJyYXkuZnJvbSh6KCkuc3ViYXJyYXkoZT4+PjAsZj4+PjApKTpbXX0pfSw5MzU4NTk6KGEsYixjLGUsZik9PntCLkVhKFwiUmVkdWNlU3VtXCIsYSx7a2VlcERpbXM6ISFiLG5vb3BXaXRoRW1wdHlBeGVzOiEhYyxheGVzOmU/QXJyYXkuZnJvbSh6KCkuc3ViYXJyYXkoZT4+PjAsZj4+PjApKTpbXX0pfSw5MzYwMTc6KGEsYixjLGUsZik9PntCLkVhKFwiUmVkdWNlTDFcIixhLHtrZWVwRGltczohIWIsbm9vcFdpdGhFbXB0eUF4ZXM6ISFjLGF4ZXM6ZT9BcnJheS5mcm9tKHooKS5zdWJhcnJheShlPj4+XG4wLGY+Pj4wKSk6W119KX0sOTM2MTc0OihhLGIsYyxlLGYpPT57Qi5FYShcIlJlZHVjZUwyXCIsYSx7a2VlcERpbXM6ISFiLG5vb3BXaXRoRW1wdHlBeGVzOiEhYyxheGVzOmU/QXJyYXkuZnJvbSh6KCkuc3ViYXJyYXkoZT4+PjAsZj4+PjApKTpbXX0pfSw5MzYzMzE6KGEsYixjLGUsZik9PntCLkVhKFwiUmVkdWNlTG9nU3VtXCIsYSx7a2VlcERpbXM6ISFiLG5vb3BXaXRoRW1wdHlBeGVzOiEhYyxheGVzOmU/QXJyYXkuZnJvbSh6KCkuc3ViYXJyYXkoZT4+PjAsZj4+PjApKTpbXX0pfSw5MzY0OTI6KGEsYixjLGUsZik9PntCLkVhKFwiUmVkdWNlU3VtU3F1YXJlXCIsYSx7a2VlcERpbXM6ISFiLG5vb3BXaXRoRW1wdHlBeGVzOiEhYyxheGVzOmU/QXJyYXkuZnJvbSh6KCkuc3ViYXJyYXkoZT4+PjAsZj4+PjApKTpbXX0pfSw5MzY2NTY6KGEsYixjLGUsZik9PntCLkVhKFwiUmVkdWNlTG9nU3VtRXhwXCIsYSx7a2VlcERpbXM6ISFiLG5vb3BXaXRoRW1wdHlBeGVzOiEhYyxheGVzOmU/QXJyYXkuZnJvbSh6KCkuc3ViYXJyYXkoZT4+PlxuMCxmPj4+MCkpOltdfSl9LDkzNjgyMDphPT57Qi5FYShcIldoZXJlXCIsYSx2b2lkIDApfSw5MzY4NzM6KGEsYixjKT0+e0IuRWEoXCJUcmFuc3Bvc2VcIixhLHtwZXJtOmI/QXJyYXkuZnJvbSh6KCkuc3ViYXJyYXkoYj4+PjAsYz4+PjApKTpbXX0pfSw5MzY5ODE6KGEsYixjLGUsZixoLGsscSxuLHAscix3LHksZyx0KT0+e0IuRWEoXCJDb252VHJhbnNwb3NlXCIsYSx7Zm9ybWF0Om4/XCJOSFdDXCI6XCJOQ0hXXCIsYXV0b1BhZDpiLGRpbGF0aW9uczpbY10sZ3JvdXA6ZSxrZXJuZWxfc2hhcGU6W2ZdLHBhZHM6W2gsa10sc3RyaWRlczpbcV0sd0lzQ29uc3Q6KCk9PiEhZCgpW3A+Pj4wXSxvdXRwdXRQYWRkaW5nOnI/QXJyYXkuZnJvbSh6KCkuc3ViYXJyYXkocj4+PjAsdz4+PjApKTpbXSxvdXRwdXRTaGFwZTp5P0FycmF5LmZyb20oeigpLnN1YmFycmF5KHk+Pj4wLGc+Pj4wKSk6W10sYWN0aXZhdGlvbjpUKHQpfSl9LDkzNzM4MzooYSxiLGMsZSxmLGgsayxxLG4scCxyLHcseSxnKT0+e0IuRWEoXCJDb252VHJhbnNwb3NlXCIsXG5hLHtmb3JtYXQ6cT9cIk5IV0NcIjpcIk5DSFdcIixhdXRvUGFkOmIsZGlsYXRpb25zOkFycmF5LmZyb20oeigpLnN1YmFycmF5KGM+Pj4wLChjPj4+MCkrMj4+PjApKSxncm91cDplLGtlcm5lbFNoYXBlOkFycmF5LmZyb20oeigpLnN1YmFycmF5KGY+Pj4wLChmPj4+MCkrMj4+PjApKSxwYWRzOkFycmF5LmZyb20oeigpLnN1YmFycmF5KGg+Pj4wLChoPj4+MCkrND4+PjApKSxzdHJpZGVzOkFycmF5LmZyb20oeigpLnN1YmFycmF5KGs+Pj4wLChrPj4+MCkrMj4+PjApKSx3SXNDb25zdDooKT0+ISFkKClbbj4+PjBdLG91dHB1dFBhZGRpbmc6cD9BcnJheS5mcm9tKHooKS5zdWJhcnJheShwPj4+MCxyPj4+MCkpOltdLG91dHB1dFNoYXBlOnc/QXJyYXkuZnJvbSh6KCkuc3ViYXJyYXkodz4+PjAseT4+PjApKTpbXSxhY3RpdmF0aW9uOlQoZyl9KX0sOTM3OTQ4OihhLGIsYyxlLGYsaCxrLHEsbixwLHIsdyx5LGcsdCk9PntCLkVhKFwiQ29udlRyYW5zcG9zZVwiLGEse2Zvcm1hdDpuP1wiTkhXQ1wiOlxuXCJOQ0hXXCIsYXV0b1BhZDpiLGRpbGF0aW9uczpbY10sZ3JvdXA6ZSxrZXJuZWxfc2hhcGU6W2ZdLHBhZHM6W2gsa10sc3RyaWRlczpbcV0sd0lzQ29uc3Q6KCk9PiEhZCgpW3A+Pj4wXSxvdXRwdXRQYWRkaW5nOnI/QXJyYXkuZnJvbSh6KCkuc3ViYXJyYXkocj4+PjAsdz4+PjApKTpbXSxvdXRwdXRTaGFwZTp5P0FycmF5LmZyb20oeigpLnN1YmFycmF5KHk+Pj4wLGc+Pj4wKSk6W10sYWN0aXZhdGlvbjpUKHQpfSl9LDkzODM1MDooYSxiLGMsZSxmLGgsayxxLG4scCxyLHcseSxnKT0+e0IuRWEoXCJDb252VHJhbnNwb3NlXCIsYSx7Zm9ybWF0OnE/XCJOSFdDXCI6XCJOQ0hXXCIsYXV0b1BhZDpiLGRpbGF0aW9uczpBcnJheS5mcm9tKHooKS5zdWJhcnJheShjPj4+MCwoYz4+PjApKzI+Pj4wKSksZ3JvdXA6ZSxrZXJuZWxTaGFwZTpBcnJheS5mcm9tKHooKS5zdWJhcnJheShmPj4+MCwoZj4+PjApKzI+Pj4wKSkscGFkczpBcnJheS5mcm9tKHooKS5zdWJhcnJheShoPj4+MCwoaD4+PjApKzQ+Pj5cbjApKSxzdHJpZGVzOkFycmF5LmZyb20oeigpLnN1YmFycmF5KGs+Pj4wLChrPj4+MCkrMj4+PjApKSx3SXNDb25zdDooKT0+ISFkKClbbj4+PjBdLG91dHB1dFBhZGRpbmc6cD9BcnJheS5mcm9tKHooKS5zdWJhcnJheShwPj4+MCxyPj4+MCkpOltdLG91dHB1dFNoYXBlOnc/QXJyYXkuZnJvbSh6KCkuc3ViYXJyYXkodz4+PjAseT4+PjApKTpbXSxhY3RpdmF0aW9uOlQoZyl9KX0sOTM4OTE1OihhLGIpPT57Qi5FYShcIkdsb2JhbEF2ZXJhZ2VQb29sXCIsYSx7Zm9ybWF0OmI/XCJOSFdDXCI6XCJOQ0hXXCJ9KX0sOTM5MDA2OihhLGIsYyxlLGYsaCxrLHEsbixwLHIsdyx5LGcsdCx4KT0+e0IuRWEoXCJBdmVyYWdlUG9vbFwiLGEse2Zvcm1hdDp4P1wiTkhXQ1wiOlwiTkNIV1wiLGF1dG9fcGFkOmIsY2VpbF9tb2RlOmMsY291bnRfaW5jbHVkZV9wYWQ6ZSxzdG9yYWdlX29yZGVyOmYsZGlsYXRpb25zOltoLGtdLGtlcm5lbF9zaGFwZTpbcSxuXSxwYWRzOltwLHIsdyx5XSxzdHJpZGVzOltnLHRdfSl9LDkzOTI5MDooYSxcbmIpPT57Qi5FYShcIkdsb2JhbEF2ZXJhZ2VQb29sXCIsYSx7Zm9ybWF0OmI/XCJOSFdDXCI6XCJOQ0hXXCJ9KX0sOTM5MzgxOihhLGIsYyxlLGYsaCxrLHEsbixwLHIsdyx5LGcsdCx4KT0+e0IuRWEoXCJBdmVyYWdlUG9vbFwiLGEse2Zvcm1hdDp4P1wiTkhXQ1wiOlwiTkNIV1wiLGF1dG9fcGFkOmIsY2VpbF9tb2RlOmMsY291bnRfaW5jbHVkZV9wYWQ6ZSxzdG9yYWdlX29yZGVyOmYsZGlsYXRpb25zOltoLGtdLGtlcm5lbF9zaGFwZTpbcSxuXSxwYWRzOltwLHIsdyx5XSxzdHJpZGVzOltnLHRdfSl9LDkzOTY2NTooYSxiKT0+e0IuRWEoXCJHbG9iYWxNYXhQb29sXCIsYSx7Zm9ybWF0OmI/XCJOSFdDXCI6XCJOQ0hXXCJ9KX0sOTM5NzUyOihhLGIsYyxlLGYsaCxrLHEsbixwLHIsdyx5LGcsdCx4KT0+e0IuRWEoXCJNYXhQb29sXCIsYSx7Zm9ybWF0Ong/XCJOSFdDXCI6XCJOQ0hXXCIsYXV0b19wYWQ6YixjZWlsX21vZGU6Yyxjb3VudF9pbmNsdWRlX3BhZDplLHN0b3JhZ2Vfb3JkZXI6ZixkaWxhdGlvbnM6W2gsa10sa2VybmVsX3NoYXBlOltxLFxubl0scGFkczpbcCxyLHcseV0sc3RyaWRlczpbZyx0XX0pfSw5NDAwMzI6KGEsYik9PntCLkVhKFwiR2xvYmFsTWF4UG9vbFwiLGEse2Zvcm1hdDpiP1wiTkhXQ1wiOlwiTkNIV1wifSl9LDk0MDExOTooYSxiLGMsZSxmLGgsayxxLG4scCxyLHcseSxnLHQseCk9PntCLkVhKFwiTWF4UG9vbFwiLGEse2Zvcm1hdDp4P1wiTkhXQ1wiOlwiTkNIV1wiLGF1dG9fcGFkOmIsY2VpbF9tb2RlOmMsY291bnRfaW5jbHVkZV9wYWQ6ZSxzdG9yYWdlX29yZGVyOmYsZGlsYXRpb25zOltoLGtdLGtlcm5lbF9zaGFwZTpbcSxuXSxwYWRzOltwLHIsdyx5XSxzdHJpZGVzOltnLHRdfSl9LDk0MDM5OTooYSxiLGMsZSxmKT0+e0IuRWEoXCJHZW1tXCIsYSx7YWxwaGE6YixiZXRhOmMsdHJhbnNBOmUsdHJhbnNCOmZ9KX0sOTQwNTAzOmE9PntCLkVhKFwiTWF0TXVsXCIsYSx2b2lkIDApfSw5NDA1NTc6KGEsYixjLGUpPT57Qi5FYShcIkFyZ01heFwiLGEse2tlZXBEaW1zOiEhYixzZWxlY3RMYXN0SW5kZXg6ISFjLGF4aXM6ZX0pfSw5NDA2NjU6KGEsXG5iLGMsZSk9PntCLkVhKFwiQXJnTWluXCIsYSx7a2VlcERpbXM6ISFiLHNlbGVjdExhc3RJbmRleDohIWMsYXhpczplfSl9LDk0MDc3MzooYSxiKT0+e0IuRWEoXCJTb2Z0bWF4XCIsYSx7YXhpczpifSl9LDk0MDgzNjooYSxiKT0+e0IuRWEoXCJDb25jYXRcIixhLHtheGlzOmJ9KX0sOTQwODk2OihhLGIsYyxlLGYpPT57Qi5FYShcIlNwbGl0XCIsYSx7YXhpczpiLG51bU91dHB1dHM6YyxzcGxpdFNpemVzOmU/QXJyYXkuZnJvbSh6KCkuc3ViYXJyYXkoZT4+PjAsZj4+PjApKTpbXX0pfSw5NDEwMzY6YT0+e0IuRWEoXCJFeHBhbmRcIixhLHZvaWQgMCl9LDk0MTA5MDooYSxiKT0+e0IuRWEoXCJHYXRoZXJcIixhLHtheGlzOk51bWJlcihiKX0pfSw5NDExNjE6KGEsYik9PntCLkVhKFwiR2F0aGVyRWxlbWVudHNcIixhLHtheGlzOk51bWJlcihiKX0pfSw5NDEyNDA6KGEsYixjLGUsZixoLGsscSxuLHAscik9PntCLkVhKFwiUmVzaXplXCIsYSx7YW50aWFsaWFzOmIsYXhlczpjP0FycmF5LmZyb20oeigpLnN1YmFycmF5KGM+Pj5cbjAsZT4+PjApKTpbXSxjb29yZGluYXRlVHJhbnNmb3JtTW9kZTpUKGYpLGN1YmljQ29lZmZBOmgsZXhjbHVkZU91dHNpZGU6ayxleHRyYXBvbGF0aW9uVmFsdWU6cSxrZWVwQXNwZWN0UmF0aW9Qb2xpY3k6VChuKSxtb2RlOlQocCksbmVhcmVzdE1vZGU6VChyKX0pfSw5NDE1ODY6KGEsYixjLGUsZixoLGspPT57Qi5FYShcIlNsaWNlXCIsYSx7c3RhcnRzOmI/QXJyYXkuZnJvbSh6KCkuc3ViYXJyYXkoYj4+PjAsYz4+PjApKTpbXSxlbmRzOmU/QXJyYXkuZnJvbSh6KCkuc3ViYXJyYXkoZT4+PjAsZj4+PjApKTpbXSxheGVzOmg/QXJyYXkuZnJvbSh6KCkuc3ViYXJyYXkoaD4+PjAsaz4+PjApKTpbXX0pfSw5NDE4MDI6YT0+e0IuRWEoXCJUaWxlXCIsYSx2b2lkIDApfSw5NDE4NTQ6KGEsYixjKT0+e0IuRWEoXCJMYXllck5vcm1hbGl6YXRpb25cIixhLHtheGlzOk51bWJlcihiKSxlcHNpbG9uOk51bWJlcihjKX0pfSw5NDE5NjE6KGEsYixjKT0+e0IuRWEoXCJJbnN0YW5jZU5vcm1hbGl6YXRpb25cIixcbmEse2Vwc2lsb246Yixmb3JtYXQ6Yz9cIk5IV0NcIjpcIk5DSFdcIn0pfSw5NDIwNzU6KGEsYixjKT0+e0IuRWEoXCJJbnN0YW5jZU5vcm1hbGl6YXRpb25cIixhLHtlcHNpbG9uOmIsZm9ybWF0OmM/XCJOSFdDXCI6XCJOQ0hXXCJ9KX0sOTQyMTg5OmE9PntCLkVhKFwiUmFuZ2VcIixhLHZvaWQgMCl9LDk0MjI0MjooYSxiKT0+e0IuRWEoXCJFaW5zdW1cIixhLHtlcXVhdGlvbjpUKGIpfSl9LDk0MjMyMzooYSxiLGMsZSxmKT0+e0IuRWEoXCJQYWRcIixhLHttb2RlOmIsdmFsdWU6YyxwYWRzOmU/QXJyYXkuZnJvbSh6KCkuc3ViYXJyYXkoZT4+PjAsZj4+PjApKTpbXX0pfSw5NDI0NTA6KGEsYixjLGUsZixoKT0+e0IuRWEoXCJCYXRjaE5vcm1hbGl6YXRpb25cIixhLHtlcHNpbG9uOmIsbW9tZW50dW06YyxzcGF0aWFsOiEhZix0cmFpbmluZ01vZGU6ISFlLGZvcm1hdDpoP1wiTkhXQ1wiOlwiTkNIV1wifSl9LDk0MjYxOTooYSxiLGMsZSxmLGgpPT57Qi5FYShcIkJhdGNoTm9ybWFsaXphdGlvblwiLGEse2Vwc2lsb246Yixtb21lbnR1bTpjLFxuc3BhdGlhbDohIWYsdHJhaW5pbmdNb2RlOiEhZSxmb3JtYXQ6aD9cIk5IV0NcIjpcIk5DSFdcIn0pfSw5NDI3ODg6KGEsYixjKT0+e0IuRWEoXCJDdW1TdW1cIixhLHtleGNsdXNpdmU6TnVtYmVyKGIpLHJldmVyc2U6TnVtYmVyKGMpfSl9LDk0Mjg4NTooYSxiLGMsZSxmLGgsayxxLG4pPT57Qi5FYShcIkF0dGVudGlvblwiLGEse251bUhlYWRzOmIsaXNVbmlkaXJlY3Rpb25hbDpjLG1hc2tGaWx0ZXJWYWx1ZTplLHNjYWxlOmYsZG9Sb3Rhcnk6aCxxa3ZIaWRkZW5TaXplczprP0FycmF5LmZyb20oeigpLnN1YmFycmF5KE51bWJlcihxKT4+PjAsTnVtYmVyKHEpK2s+Pj4wKSk6W10scGFzdFByZXNlbnRTaGFyZUJ1ZmZlcjohIW59KX0sOTQzMTU3OmE9PntCLkVhKFwiR2VsdVwiLGEsdm9pZCAwKX0sOTQzMjA5OihhLGIsYyxlLGYsaCk9PntCLkVhKFwiTXVsdGlIZWFkQXR0ZW50aW9uXCIsYSx7bnVtSGVhZHM6Yixpc1VuaWRpcmVjdGlvbmFsOmMsbWFza0ZpbHRlclZhbHVlOmUsc2NhbGU6Zixkb1JvdGFyeTpofSl9LFxuOTQzMzY4OmE9PntCLkVhKFwiQmlhc0FkZFwiLGEsdm9pZCAwKX0sOTQzNDIzOmE9PntCLkVhKFwiQmlhc1NwbGl0R2VsdVwiLGEsdm9pZCAwKX0sOTQzNDg0OihhLGIpPT57Qi5FYShcIlNraXBMYXllck5vcm1hbGl6YXRpb25cIixhLHtlcHNpbG9uOmJ9KX0sOTQzNTY1OihhLGIsYyxlLGYsaCxrLHEsbixwLHIsdyx5KT0+e0IuRWEoXCJDb252XCIsYSx7Zm9ybWF0Om4/XCJOSFdDXCI6XCJOQ0hXXCIsYXV0b19wYWQ6YixkaWxhdGlvbnM6W2NdLGdyb3VwOmUsa2VybmVsX3NoYXBlOltmXSxwYWRzOmg/QXJyYXkuZnJvbSh6KCkuc3ViYXJyYXkoaD4+PjAsaz4+PjApKTpbXSxzdHJpZGVzOltxXSx3X2lzX2NvbnN0OigpPT4hIWQoKVtwPj4+MF0sYWN0aXZhdGlvbjpUKHIpLGFjdGl2YXRpb25fcGFyYW1zOnc/QXJyYXkuZnJvbShkYSgpLnN1YmFycmF5KHc+Pj4wLHk+Pj4wKSk6W119KX0sOTQzOTM1OihhLGIsYyxlLGYsaCxrLHEsbixwLHIsdyx5LGcsdCx4KT0+e0IuRWEoXCJDb252XCIsYSx7Zm9ybWF0Onc/XG5cIk5IV0NcIjpcIk5DSFdcIixhdXRvX3BhZDpiLGRpbGF0aW9uczpbYyxlXSxncm91cDpmLGtlcm5lbF9zaGFwZTpbaCxrXSxwYWRzOnE/QXJyYXkuZnJvbSh6KCkuc3ViYXJyYXkocT4+PjAsbj4+PjApKTpbXSxzdHJpZGVzOltwLHJdLHdfaXNfY29uc3Q6KCk9PiEhZCgpW3k+Pj4wXSxhY3RpdmF0aW9uOlQoZyksYWN0aXZhdGlvbl9wYXJhbXM6dD9BcnJheS5mcm9tKGRhKCkuc3ViYXJyYXkodD4+PjAseD4+PjApKTpbXX0pfSw5NDQzMjY6YT0+e0IuemIoYSl9LDk0NDM2MDooYSxiKT0+Qi5BYihhLGIsQi5iYi5DYixCLmJiLmVycm9ycyl9O2Z1bmN0aW9uIElhKGEpe3RoaXMubmFtZT1cIkV4aXRTdGF0dXNcIjt0aGlzLm1lc3NhZ2U9YFByb2dyYW0gdGVybWluYXRlZCB3aXRoIGV4aXQoJHthfSlgO3RoaXMuc3RhdHVzPWF9XG52YXIgSmE9YT0+e2EudGVybWluYXRlKCk7YS5vbm1lc3NhZ2U9KCk9Pnt9fSxMYT1hPT57MD09VS5ZYS5sZW5ndGgmJihLYSgpLFUubGIoVS5ZYVswXSkpO3ZhciBiPVUuWWEucG9wKCk7aWYoIWIpcmV0dXJuIDY7VS5aYS5wdXNoKGIpO1UuUWFbYS5YYV09YjtiLlhhPWEuWGE7dmFyIGM9e2NtZDpcInJ1blwiLHN0YXJ0X3JvdXRpbmU6YS5EYixhcmc6YS50YixwdGhyZWFkX3B0cjphLlhhfTtGJiZiLnVucmVmKCk7Yi5wb3N0TWVzc2FnZShjLGEuSmIpO3JldHVybiAwfSxWPTAsTWE9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIFRleHREZWNvZGVyP25ldyBUZXh0RGVjb2RlcihcInV0ZjhcIik6dm9pZCAwLE5hPShhLGIsYyk9PntiPj4+PTA7dmFyIGU9YitjO2ZvcihjPWI7YVtjXSYmIShjPj1lKTspKytjO2lmKDE2PGMtYiYmYS5idWZmZXImJk1hKXJldHVybiBNYS5kZWNvZGUoYS5idWZmZXIgaW5zdGFuY2VvZiBTaGFyZWRBcnJheUJ1ZmZlcj9hLnNsaWNlKGIsYyk6YS5zdWJhcnJheShiLGMpKTtcbmZvcihlPVwiXCI7YjxjOyl7dmFyIGY9YVtiKytdO2lmKGYmMTI4KXt2YXIgaD1hW2IrK10mNjM7aWYoMTkyPT0oZiYyMjQpKWUrPVN0cmluZy5mcm9tQ2hhckNvZGUoKGYmMzEpPDw2fGgpO2Vsc2V7dmFyIGs9YVtiKytdJjYzO2Y9MjI0PT0oZiYyNDApPyhmJjE1KTw8MTJ8aDw8NnxrOihmJjcpPDwxOHxoPDwxMnxrPDw2fGFbYisrXSY2Mzs2NTUzNj5mP2UrPVN0cmluZy5mcm9tQ2hhckNvZGUoZik6KGYtPTY1NTM2LGUrPVN0cmluZy5mcm9tQ2hhckNvZGUoNTUyOTZ8Zj4+MTAsNTYzMjB8ZiYxMDIzKSl9fWVsc2UgZSs9U3RyaW5nLmZyb21DaGFyQ29kZShmKX1yZXR1cm4gZX0sVD0oYSxiKT0+KGE+Pj49MCk/TmEodigpLGEsYik6XCJcIixRYT1hPT57dmFyIGI9T2EoKTthPWEoKTtQYShiKTtyZXR1cm4gYX07XG5mdW5jdGlvbiBXKGEsYil7dmFyIGM9YXJndW1lbnRzLmxlbmd0aC0yLGU9YXJndW1lbnRzO3JldHVybiBRYSgoKT0+e2Zvcih2YXIgZj1SYSg4KmMpLGg9Zj4+PjMsaz0wO2s8YztrKyspe3ZhciBxPWVbMitrXTtmYSgpW2graz4+PjBdPXF9cmV0dXJuIFNhKGEsYyxmLGIpfSl9ZnVuY3Rpb24gVGEoYSl7aWYoRylyZXR1cm4gVygwLDEsYSk7Tz1hOzA8Vnx8KFUuRWIoKSxCLm9uRXhpdD8uKGEpLE09ITApO21hKGEsbmV3IElhKGEpKX12YXIgVmE9YT0+e089YTtpZihHKXRocm93IFVhKGEpLFwidW53aW5kXCI7VGEoYSl9LFdhPWE9PnthIGluc3RhbmNlb2YgSWF8fFwidW53aW5kXCI9PWF8fG1hKDEsYSl9O2Z1bmN0aW9uIFhhKCl7Zm9yKHZhciBhPUIubnVtVGhyZWFkczthLS07KUthKCk7eGEudW5zaGlmdCgoKT0+e1ArKztZYSgoKT0+QmEoKSl9KX1cbmZ1bmN0aW9uIEthKCl7dmFyIGE9b2EoXCJvcnQtd2FzbS1zaW1kLXRocmVhZGVkLndvcmtlci5qc1wiKTthPW5ldyBXb3JrZXIoYSk7VS5ZYS5wdXNoKGEpfWZ1bmN0aW9uIFlhKGEpe0c/YSgpOlByb21pc2UuYWxsKFUuWWEubWFwKFUubGIpKS50aGVuKGEpfVxudmFyIFU9e1lhOltdLFphOltdLHBiOltdLFFhOnt9LGhiKCl7Rz8oVS5yZWNlaXZlT2JqZWN0VHJhbnNmZXI9VS5CYixVLnRocmVhZEluaXRUTFM9VS5vYixVLnNldEV4aXRTdGF0dXM9VS5uYik6WGEoKX0sbmI6YT0+Tz1hLE5iOltcIiR0ZXJtaW5hdGVXb3JrZXJcIl0sRWI6KCk9Pntmb3IodmFyIGEgb2YgVS5aYSlKYShhKTtmb3IoYSBvZiBVLllhKUphKGEpO1UuWWE9W107VS5aYT1bXTtVLlFhPVtdfSxtYjphPT57dmFyIGI9YS5YYTtkZWxldGUgVS5RYVtiXTtVLllhLnB1c2goYSk7VS5aYS5zcGxpY2UoVS5aYS5pbmRleE9mKGEpLDEpO2EuWGE9MDtaYShiKX0sQmIoKXt9LG9iKCl7VS5wYi5mb3JFYWNoKGE9PmEoKSl9LGxiOmE9Pm5ldyBQcm9taXNlKGI9PnthLm9ubWVzc2FnZT1oPT57aD1oLmRhdGE7dmFyIGs9aC5jbWQ7aWYoaC50YXJnZXRUaHJlYWQmJmgudGFyZ2V0VGhyZWFkIT0kYSgpKXt2YXIgcT1VLlFhW2gudGFyZ2V0VGhyZWFkXTtxP3EucG9zdE1lc3NhZ2UoaCxoLnRyYW5zZmVyTGlzdCk6XG5LKGBJbnRlcm5hbCBlcnJvciEgV29ya2VyIHNlbnQgYSBtZXNzYWdlIFwiJHtrfVwiIHRvIHRhcmdldCBwdGhyZWFkICR7aC50YXJnZXRUaHJlYWR9LCBidXQgdGhhdCB0aHJlYWQgbm8gbG9uZ2VyIGV4aXN0cyFgKX1lbHNlIGlmKFwiY2hlY2tNYWlsYm94XCI9PT1rKWFiKCk7ZWxzZSBpZihcInNwYXduVGhyZWFkXCI9PT1rKUxhKGgpO2Vsc2UgaWYoXCJjbGVhbnVwVGhyZWFkXCI9PT1rKVUubWIoVS5RYVtoLnRocmVhZF0pO2Vsc2UgaWYoXCJraWxsVGhyZWFkXCI9PT1rKWg9aC50aHJlYWQsaz1VLlFhW2hdLGRlbGV0ZSBVLlFhW2hdLEphKGspLFphKGgpLFUuWmEuc3BsaWNlKFUuWmEuaW5kZXhPZihrKSwxKSxrLlhhPTA7ZWxzZSBpZihcImNhbmNlbFRocmVhZFwiPT09aylVLlFhW2gudGhyZWFkXS5wb3N0TWVzc2FnZSh7Y21kOlwiY2FuY2VsXCJ9KTtlbHNlIGlmKFwibG9hZGVkXCI9PT1rKWEubG9hZGVkPSEwLEYmJiFhLlhhJiZhLnVucmVmKCksYihhKTtlbHNlIGlmKFwiYWxlcnRcIj09PWspYWxlcnQoYFRocmVhZCAke2gudGhyZWFkSWR9OiAke2gudGV4dH1gKTtcbmVsc2UgaWYoXCJzZXRpbW1lZGlhdGVcIj09PWgudGFyZ2V0KWEucG9zdE1lc3NhZ2UoaCk7ZWxzZSBpZihcImNhbGxIYW5kbGVyXCI9PT1rKUJbaC5oYW5kbGVyXSguLi5oLmFyZ3MpO2Vsc2UgayYmSyhgd29ya2VyIHNlbnQgYW4gdW5rbm93biBjb21tYW5kICR7a31gKX07YS5vbmVycm9yPWg9PntLKGAke1wid29ya2VyIHNlbnQgYW4gZXJyb3IhXCJ9ICR7aC5maWxlbmFtZX06JHtoLmxpbmVub306ICR7aC5tZXNzYWdlfWApO3Rocm93IGg7fTtGJiYoYS5vbihcIm1lc3NhZ2VcIixoPT5hLm9ubWVzc2FnZSh7ZGF0YTpofSkpLGEub24oXCJlcnJvclwiLGg9PmEub25lcnJvcihoKSkpO3ZhciBjPVtdLGU9W1wib25FeGl0XCJdLGY7Zm9yKGYgb2YgZSlCLmhhc093blByb3BlcnR5KGYpJiZjLnB1c2goZik7YS5wb3N0TWVzc2FnZSh7Y21kOlwibG9hZFwiLGhhbmRsZXJzOmMsdXJsT3JCbG9iOkIubWFpblNjcmlwdFVybE9yQmxvYnx8X3NjcmlwdERpcix3YXNtTWVtb3J5Omwsd2FzbU1vZHVsZTp2YX0pfSl9O1xuQi5QVGhyZWFkPVU7dmFyIGJiPWE9Pntmb3IoOzA8YS5sZW5ndGg7KWEuc2hpZnQoKShCKX07Qi5lc3RhYmxpc2hTdGFja1NwYWNlPSgpPT57dmFyIGE9JGEoKSxiPUEoKVthKzUyPj4+Mj4+PjBdO2E9QSgpW2ErNTY+Pj4yPj4+MF07Y2IoYixiLWEpO1BhKGIpfTtmdW5jdGlvbiBVYShhKXtpZihHKXJldHVybiBXKDEsMCxhKTtWYShhKX1CLmludm9rZUVudHJ5UG9pbnQ9KGEsYik9PnthPWRiLmFwcGx5KG51bGwsW2EsYl0pOzA8Vj9VLm5iKGEpOmViKGEpfTtmdW5jdGlvbiBmYihhKXt0aGlzLmdiPWEtMjQ7dGhpcy5zYj1mdW5jdGlvbihiKXtBKClbdGhpcy5nYis0Pj4+Mj4+PjBdPWJ9O3RoaXMucmI9ZnVuY3Rpb24oYil7QSgpW3RoaXMuZ2IrOD4+PjI+Pj4wXT1ifTt0aGlzLmhiPWZ1bmN0aW9uKGIsYyl7dGhpcy5xYigpO3RoaXMuc2IoYik7dGhpcy5yYihjKX07dGhpcy5xYj1mdW5jdGlvbigpe0EoKVt0aGlzLmdiKzE2Pj4+Mj4+PjBdPTB9fXZhciBnYj0wLGhiPTA7XG5mdW5jdGlvbiBpYihhLGIsYyxlKXtyZXR1cm4gRz9XKDIsMSxhLGIsYyxlKTpqYihhLGIsYyxlKX1mdW5jdGlvbiBqYihhLGIsYyxlKXthPj4+PTA7Yj4+Pj0wO2M+Pj49MDtlPj4+PTA7aWYoXCJ1bmRlZmluZWRcIj09dHlwZW9mIFNoYXJlZEFycmF5QnVmZmVyKXJldHVybiBLKFwiQ3VycmVudCBlbnZpcm9ubWVudCBkb2VzIG5vdCBzdXBwb3J0IFNoYXJlZEFycmF5QnVmZmVyLCBwdGhyZWFkcyBhcmUgbm90IGF2YWlsYWJsZSFcIiksNjt2YXIgZj1bXTtpZihHJiYwPT09Zi5sZW5ndGgpcmV0dXJuIGliKGEsYixjLGUpO2E9e0RiOmMsWGE6YSx0YjplLEpiOmZ9O3JldHVybiBHPyhhLkxiPVwic3Bhd25UaHJlYWRcIixwb3N0TWVzc2FnZShhLGYpLDApOkxhKGEpfWZ1bmN0aW9uIGtiKGEsYixjKXtyZXR1cm4gRz9XKDMsMSxhLGIsYyk6MH1mdW5jdGlvbiBsYihhLGIpe2lmKEcpcmV0dXJuIFcoNCwxLGEsYil9XG52YXIgbWI9YT0+e2Zvcih2YXIgYj0wLGM9MDtjPGEubGVuZ3RoOysrYyl7dmFyIGU9YS5jaGFyQ29kZUF0KGMpOzEyNz49ZT9iKys6MjA0Nz49ZT9iKz0yOjU1Mjk2PD1lJiY1NzM0Mz49ZT8oYis9NCwrK2MpOmIrPTN9cmV0dXJuIGJ9LG5iPShhLGIsYyxlKT0+e2M+Pj49MDtpZighKDA8ZSkpcmV0dXJuIDA7dmFyIGY9YztlPWMrZS0xO2Zvcih2YXIgaD0wO2g8YS5sZW5ndGg7KytoKXt2YXIgaz1hLmNoYXJDb2RlQXQoaCk7aWYoNTUyOTY8PWsmJjU3MzQzPj1rKXt2YXIgcT1hLmNoYXJDb2RlQXQoKytoKTtrPTY1NTM2KygoayYxMDIzKTw8MTApfHEmMTAyM31pZigxMjc+PWspe2lmKGM+PWUpYnJlYWs7YltjKys+Pj4wXT1rfWVsc2V7aWYoMjA0Nz49ayl7aWYoYysxPj1lKWJyZWFrO2JbYysrPj4+MF09MTkyfGs+PjZ9ZWxzZXtpZig2NTUzNT49ayl7aWYoYysyPj1lKWJyZWFrO2JbYysrPj4+MF09MjI0fGs+PjEyfWVsc2V7aWYoYyszPj1lKWJyZWFrO2JbYysrPj4+MF09MjQwfGs+PlxuMTg7YltjKys+Pj4wXT0xMjh8az4+MTImNjN9YltjKys+Pj4wXT0xMjh8az4+NiY2M31iW2MrKz4+PjBdPTEyOHxrJjYzfX1iW2M+Pj4wXT0wO3JldHVybiBjLWZ9LG9iPShhLGIsYyk9Pm5iKGEsdigpLGIsYyk7ZnVuY3Rpb24gcGIoYSxiKXtpZihHKXJldHVybiBXKDUsMSxhLGIpfWZ1bmN0aW9uIHFiKGEsYixjKXtpZihHKXJldHVybiBXKDYsMSxhLGIsYyl9ZnVuY3Rpb24gcmIoYSxiLGMpe3JldHVybiBHP1coNywxLGEsYixjKTowfWZ1bmN0aW9uIHNiKGEsYil7aWYoRylyZXR1cm4gVyg4LDEsYSxiKX1mdW5jdGlvbiB0YihhLGIsYyl7aWYoRylyZXR1cm4gVyg5LDEsYSxiLGMpfWZ1bmN0aW9uIHViKGEsYixjLGUpe2lmKEcpcmV0dXJuIFcoMTAsMSxhLGIsYyxlKX1mdW5jdGlvbiB2YihhLGIsYyxlKXtpZihHKXJldHVybiBXKDExLDEsYSxiLGMsZSl9ZnVuY3Rpb24gd2IoYSxiLGMsZSl7aWYoRylyZXR1cm4gVygxMiwxLGEsYixjLGUpfVxuZnVuY3Rpb24geGIoYSl7aWYoRylyZXR1cm4gVygxMywxLGEpfWZ1bmN0aW9uIHliKGEsYil7aWYoRylyZXR1cm4gVygxNCwxLGEsYil9ZnVuY3Rpb24gemIoYSxiLGMpe2lmKEcpcmV0dXJuIFcoMTUsMSxhLGIsYyl9dmFyIEFiPSgpPT57aWYoISgwPFYpKXRyeXtHP2ViKE8pOlZhKE8pfWNhdGNoKGEpe1dhKGEpfX07ZnVuY3Rpb24gQmIoYSl7YT4+Pj0wO1wiZnVuY3Rpb25cIj09PXR5cGVvZiBBdG9taWNzLktiJiYoQXRvbWljcy5LYih6KCksYT4+PjIsYSkudmFsdWUudGhlbihhYiksYSs9MTI4LEF0b21pY3Muc3RvcmUoeigpLGE+Pj4yLDEpKX1CLl9fZW1zY3JpcHRlbl90aHJlYWRfbWFpbGJveF9hd2FpdD1CYjt2YXIgYWI9KCk9Pnt2YXIgYT0kYSgpO2lmKGEmJihCYihhKSwhTSkpdHJ5e0NiKCksQWIoKX1jYXRjaChiKXtXYShiKX19O0IuY2hlY2tNYWlsYm94PWFiO1xudmFyIERiPVtdLFg9YT0+MD09PWElNCYmKDAhPT1hJTEwMHx8MD09PWElNDAwKSxFYj1bMCwzMSw2MCw5MSwxMjEsMTUyLDE4MiwyMTMsMjQ0LDI3NCwzMDUsMzM1XSxGYj1bMCwzMSw1OSw5MCwxMjAsMTUxLDE4MSwyMTIsMjQzLDI3MywzMDQsMzM0XTtmdW5jdGlvbiBHYihhLGIsYyxlLGYsaCxrLHEpe3JldHVybiBHP1coMTYsMSxhLGIsYyxlLGYsaCxrLHEpOi01Mn1mdW5jdGlvbiBIYihhLGIsYyxlLGYsaCxrKXtpZihHKXJldHVybiBXKDE3LDEsYSxiLGMsZSxmLGgsayl9XG52YXIgSmI9YT0+e3ZhciBiPW1iKGEpKzEsYz1JYihiKTtjJiZvYihhLGMsYik7cmV0dXJuIGN9LEtiPVtdLExiPShhLGIpPT57S2IubGVuZ3RoPTA7Zm9yKHZhciBjO2M9digpW2ErKz4+PjBdOyl7dmFyIGU9MTA1IT1jO2UmPTExMiE9YztiKz1lJiZiJTg/NDowO0tiLnB1c2goMTEyPT1jP0EoKVtiPj4+Mj4+PjBdOjEwNT09Yz96KClbYj4+PjI+Pj4wXTpmYSgpW2I+Pj4zPj4+MF0pO2IrPWU/ODo0fXJldHVybiBLYn0sTWI9e30sT2I9KCk9PntpZighTmIpe3ZhciBhPXtVU0VSOlwid2ViX3VzZXJcIixMT0dOQU1FOlwid2ViX3VzZXJcIixQQVRIOlwiL1wiLFBXRDpcIi9cIixIT01FOlwiL2hvbWUvd2ViX3VzZXJcIixMQU5HOihcIm9iamVjdFwiPT10eXBlb2YgbmF2aWdhdG9yJiZuYXZpZ2F0b3IubGFuZ3VhZ2VzJiZuYXZpZ2F0b3IubGFuZ3VhZ2VzWzBdfHxcIkNcIikucmVwbGFjZShcIi1cIixcIl9cIikrXCIuVVRGLThcIixfOmxhfHxcIi4vdGhpcy5wcm9ncmFtXCJ9LGI7Zm9yKGIgaW4gTWIpdm9pZCAwPT09TWJbYl0/XG5kZWxldGUgYVtiXTphW2JdPU1iW2JdO3ZhciBjPVtdO2ZvcihiIGluIGEpYy5wdXNoKGAke2J9PSR7YVtiXX1gKTtOYj1jfXJldHVybiBOYn0sTmI7ZnVuY3Rpb24gUGIoYSxiKXtpZihHKXJldHVybiBXKDE4LDEsYSxiKTthPj4+PTA7Yj4+Pj0wO3ZhciBjPTA7T2IoKS5mb3JFYWNoKChlLGYpPT57dmFyIGg9YitjO2Y9QSgpW2ErNCpmPj4+Mj4+PjBdPWg7Zm9yKGg9MDtoPGUubGVuZ3RoOysraClkKClbZisrPj4+MD4+PjBdPWUuY2hhckNvZGVBdChoKTtkKClbZj4+PjA+Pj4wXT0wO2MrPWUubGVuZ3RoKzF9KTtyZXR1cm4gMH1mdW5jdGlvbiBRYihhLGIpe2lmKEcpcmV0dXJuIFcoMTksMSxhLGIpO2E+Pj49MDtiPj4+PTA7dmFyIGM9T2IoKTtBKClbYT4+PjI+Pj4wXT1jLmxlbmd0aDt2YXIgZT0wO2MuZm9yRWFjaChmPT5lKz1mLmxlbmd0aCsxKTtBKClbYj4+PjI+Pj4wXT1lO3JldHVybiAwfWZ1bmN0aW9uIFJiKGEpe3JldHVybiBHP1coMjAsMSxhKTo1Mn1cbmZ1bmN0aW9uIFRiKGEsYixjLGUpe3JldHVybiBHP1coMjEsMSxhLGIsYyxlKTo1Mn1mdW5jdGlvbiBVYihhLGIsYyxlLGYpe3JldHVybiBHP1coMjIsMSxhLGIsYyxlLGYpOjcwfXZhciBWYj1bbnVsbCxbXSxbXV07ZnVuY3Rpb24gV2IoYSxiLGMsZSl7aWYoRylyZXR1cm4gVygyMywxLGEsYixjLGUpO2I+Pj49MDtjPj4+PTA7ZT4+Pj0wO2Zvcih2YXIgZj0wLGg9MDtoPGM7aCsrKXt2YXIgaz1BKClbYj4+PjI+Pj4wXSxxPUEoKVtiKzQ+Pj4yPj4+MF07Yis9ODtmb3IodmFyIG49MDtuPHE7bisrKXt2YXIgcD12KClbaytuPj4+MF0scj1WYlthXTswPT09cHx8MTA9PT1wPygoMT09PWE/dWE6SykoTmEociwwKSksci5sZW5ndGg9MCk6ci5wdXNoKHApfWYrPXF9QSgpW2U+Pj4yPj4+MF09ZjtyZXR1cm4gMH12YXIgWGI9WzMxLDI5LDMxLDMwLDMxLDMwLDMxLDMxLDMwLDMxLDMwLDMxXSxZYj1bMzEsMjgsMzEsMzAsMzEsMzAsMzEsMzEsMzAsMzEsMzAsMzFdO1xuZnVuY3Rpb24gWmIoYSl7dmFyIGI9QXJyYXkobWIoYSkrMSk7bmIoYSxiLDAsYi5sZW5ndGgpO3JldHVybiBifXZhciAkYj0oYSxiKT0+e2QoKS5zZXQoYSxiPj4+MCl9O1xuZnVuY3Rpb24gYWMoYSxiLGMsZSl7ZnVuY3Rpb24gZihnLHQseCl7Zm9yKGc9XCJudW1iZXJcIj09dHlwZW9mIGc/Zy50b1N0cmluZygpOmd8fFwiXCI7Zy5sZW5ndGg8dDspZz14WzBdK2c7cmV0dXJuIGd9ZnVuY3Rpb24gaChnLHQpe3JldHVybiBmKGcsdCxcIjBcIil9ZnVuY3Rpb24gayhnLHQpe2Z1bmN0aW9uIHgoU2Ipe3JldHVybiAwPlNiPy0xOjA8U2I/MTowfXZhciBOOzA9PT0oTj14KGcuZ2V0RnVsbFllYXIoKS10LmdldEZ1bGxZZWFyKCkpKSYmMD09PShOPXgoZy5nZXRNb250aCgpLXQuZ2V0TW9udGgoKSkpJiYoTj14KGcuZ2V0RGF0ZSgpLXQuZ2V0RGF0ZSgpKSk7cmV0dXJuIE59ZnVuY3Rpb24gcShnKXtzd2l0Y2goZy5nZXREYXkoKSl7Y2FzZSAwOnJldHVybiBuZXcgRGF0ZShnLmdldEZ1bGxZZWFyKCktMSwxMSwyOSk7Y2FzZSAxOnJldHVybiBnO2Nhc2UgMjpyZXR1cm4gbmV3IERhdGUoZy5nZXRGdWxsWWVhcigpLDAsMyk7Y2FzZSAzOnJldHVybiBuZXcgRGF0ZShnLmdldEZ1bGxZZWFyKCksXG4wLDIpO2Nhc2UgNDpyZXR1cm4gbmV3IERhdGUoZy5nZXRGdWxsWWVhcigpLDAsMSk7Y2FzZSA1OnJldHVybiBuZXcgRGF0ZShnLmdldEZ1bGxZZWFyKCktMSwxMSwzMSk7Y2FzZSA2OnJldHVybiBuZXcgRGF0ZShnLmdldEZ1bGxZZWFyKCktMSwxMSwzMCl9fWZ1bmN0aW9uIG4oZyl7dmFyIHQ9Zy4kYTtmb3IoZz1uZXcgRGF0ZSgobmV3IERhdGUoZy5hYisxOTAwLDAsMSkpLmdldFRpbWUoKSk7MDx0Oyl7dmFyIHg9Zy5nZXRNb250aCgpLE49KFgoZy5nZXRGdWxsWWVhcigpKT9YYjpZYilbeF07aWYodD5OLWcuZ2V0RGF0ZSgpKXQtPU4tZy5nZXREYXRlKCkrMSxnLnNldERhdGUoMSksMTE+eD9nLnNldE1vbnRoKHgrMSk6KGcuc2V0TW9udGgoMCksZy5zZXRGdWxsWWVhcihnLmdldEZ1bGxZZWFyKCkrMSkpO2Vsc2V7Zy5zZXREYXRlKGcuZ2V0RGF0ZSgpK3QpO2JyZWFrfX14PW5ldyBEYXRlKGcuZ2V0RnVsbFllYXIoKSsxLDAsNCk7dD1xKG5ldyBEYXRlKGcuZ2V0RnVsbFllYXIoKSxcbjAsNCkpO3g9cSh4KTtyZXR1cm4gMD49ayh0LGcpPzA+PWsoeCxnKT9nLmdldEZ1bGxZZWFyKCkrMTpnLmdldEZ1bGxZZWFyKCk6Zy5nZXRGdWxsWWVhcigpLTF9YT4+Pj0wO2I+Pj49MDtjPj4+PTA7ZT4+Pj0wO3ZhciBwPUEoKVtlKzQwPj4+Mj4+PjBdO2U9e0hiOnooKVtlPj4+Mj4+PjBdLEdiOnooKVtlKzQ+Pj4yPj4+MF0sZWI6eigpW2UrOD4+PjI+Pj4wXSxqYjp6KClbZSsxMj4+PjI+Pj4wXSxmYjp6KClbZSsxNj4+PjI+Pj4wXSxhYjp6KClbZSsyMD4+PjI+Pj4wXSxXYTp6KClbZSsyND4+PjI+Pj4wXSwkYTp6KClbZSsyOD4+PjI+Pj4wXSxPYjp6KClbZSszMj4+PjI+Pj4wXSxGYjp6KClbZSszNj4+PjI+Pj4wXSxJYjpwP1QocCk6XCJcIn07Yz1UKGMpO3A9e1wiJWNcIjpcIiVhICViICVkICVIOiVNOiVTICVZXCIsXCIlRFwiOlwiJW0vJWQvJXlcIixcIiVGXCI6XCIlWS0lbS0lZFwiLFwiJWhcIjpcIiViXCIsXCIlclwiOlwiJUk6JU06JVMgJXBcIixcIiVSXCI6XCIlSDolTVwiLFwiJVRcIjpcIiVIOiVNOiVTXCIsXCIleFwiOlwiJW0vJWQvJXlcIixcblwiJVhcIjpcIiVIOiVNOiVTXCIsXCIlRWNcIjpcIiVjXCIsXCIlRUNcIjpcIiVDXCIsXCIlRXhcIjpcIiVtLyVkLyV5XCIsXCIlRVhcIjpcIiVIOiVNOiVTXCIsXCIlRXlcIjpcIiV5XCIsXCIlRVlcIjpcIiVZXCIsXCIlT2RcIjpcIiVkXCIsXCIlT2VcIjpcIiVlXCIsXCIlT0hcIjpcIiVIXCIsXCIlT0lcIjpcIiVJXCIsXCIlT21cIjpcIiVtXCIsXCIlT01cIjpcIiVNXCIsXCIlT1NcIjpcIiVTXCIsXCIlT3VcIjpcIiV1XCIsXCIlT1VcIjpcIiVVXCIsXCIlT1ZcIjpcIiVWXCIsXCIlT3dcIjpcIiV3XCIsXCIlT1dcIjpcIiVXXCIsXCIlT3lcIjpcIiV5XCJ9O2Zvcih2YXIgciBpbiBwKWM9Yy5yZXBsYWNlKG5ldyBSZWdFeHAocixcImdcIikscFtyXSk7dmFyIHc9XCJTdW5kYXkgTW9uZGF5IFR1ZXNkYXkgV2VkbmVzZGF5IFRodXJzZGF5IEZyaWRheSBTYXR1cmRheVwiLnNwbGl0KFwiIFwiKSx5PVwiSmFudWFyeSBGZWJydWFyeSBNYXJjaCBBcHJpbCBNYXkgSnVuZSBKdWx5IEF1Z3VzdCBTZXB0ZW1iZXIgT2N0b2JlciBOb3ZlbWJlciBEZWNlbWJlclwiLnNwbGl0KFwiIFwiKTtwPXtcIiVhXCI6Zz0+d1tnLldhXS5zdWJzdHJpbmcoMCwzKSxcIiVBXCI6Zz0+XG53W2cuV2FdLFwiJWJcIjpnPT55W2cuZmJdLnN1YnN0cmluZygwLDMpLFwiJUJcIjpnPT55W2cuZmJdLFwiJUNcIjpnPT5oKChnLmFiKzE5MDApLzEwMHwwLDIpLFwiJWRcIjpnPT5oKGcuamIsMiksXCIlZVwiOmc9PmYoZy5qYiwyLFwiIFwiKSxcIiVnXCI6Zz0+bihnKS50b1N0cmluZygpLnN1YnN0cmluZygyKSxcIiVHXCI6Zz0+bihnKSxcIiVIXCI6Zz0+aChnLmViLDIpLFwiJUlcIjpnPT57Zz1nLmViOzA9PWc/Zz0xMjoxMjxnJiYoZy09MTIpO3JldHVybiBoKGcsMil9LFwiJWpcIjpnPT57Zm9yKHZhciB0PTAseD0wO3g8PWcuZmItMTt0Kz0oWChnLmFiKzE5MDApP1hiOlliKVt4KytdKTtyZXR1cm4gaChnLmpiK3QsMyl9LFwiJW1cIjpnPT5oKGcuZmIrMSwyKSxcIiVNXCI6Zz0+aChnLkdiLDIpLFwiJW5cIjooKT0+XCJcXG5cIixcIiVwXCI6Zz0+MDw9Zy5lYiYmMTI+Zy5lYj9cIkFNXCI6XCJQTVwiLFwiJVNcIjpnPT5oKGcuSGIsMiksXCIldFwiOigpPT5cIlxcdFwiLFwiJXVcIjpnPT5nLldhfHw3LFwiJVVcIjpnPT5oKE1hdGguZmxvb3IoKGcuJGErNy1nLldhKS9cbjcpLDIpLFwiJVZcIjpnPT57dmFyIHQ9TWF0aC5mbG9vcigoZy4kYSs3LShnLldhKzYpJTcpLzcpOzI+PShnLldhKzM3MS1nLiRhLTIpJTcmJnQrKztpZih0KTUzPT10JiYoeD0oZy5XYSszNzEtZy4kYSklNyw0PT14fHwzPT14JiZYKGcuYWIpfHwodD0xKSk7ZWxzZXt0PTUyO3ZhciB4PShnLldhKzctZy4kYS0xKSU3Oyg0PT14fHw1PT14JiZYKGcuYWIlNDAwLTEpKSYmdCsrfXJldHVybiBoKHQsMil9LFwiJXdcIjpnPT5nLldhLFwiJVdcIjpnPT5oKE1hdGguZmxvb3IoKGcuJGErNy0oZy5XYSs2KSU3KS83KSwyKSxcIiV5XCI6Zz0+KGcuYWIrMTkwMCkudG9TdHJpbmcoKS5zdWJzdHJpbmcoMiksXCIlWVwiOmc9PmcuYWIrMTkwMCxcIiV6XCI6Zz0+e2c9Zy5GYjt2YXIgdD0wPD1nO2c9TWF0aC5hYnMoZykvNjA7cmV0dXJuKHQ/XCIrXCI6XCItXCIpK1N0cmluZyhcIjAwMDBcIisoZy82MCoxMDArZyU2MCkpLnNsaWNlKC00KX0sXCIlWlwiOmc9PmcuSWIsXCIlJVwiOigpPT5cIiVcIn07Yz1jLnJlcGxhY2UoLyUlL2csXCJcXHgwMFxceDAwXCIpO1xuZm9yKHIgaW4gcCljLmluY2x1ZGVzKHIpJiYoYz1jLnJlcGxhY2UobmV3IFJlZ0V4cChyLFwiZ1wiKSxwW3JdKGUpKSk7Yz1jLnJlcGxhY2UoL1xcMFxcMC9nLFwiJVwiKTtyPVpiKGMpO2lmKHIubGVuZ3RoPmIpcmV0dXJuIDA7JGIocixhKTtyZXR1cm4gci5sZW5ndGgtMX12YXIgYmM9YT0+e3RyeXthKCl9Y2F0Y2goYil7TChiKX19O2Z1bmN0aW9uIGNjKCl7dmFyIGE9WSxiPXt9O2ZvcihsZXQgW2MsZV1vZiBPYmplY3QuZW50cmllcyhhKSliW2NdPVwiZnVuY3Rpb25cIj09dHlwZW9mIGU/ZnVuY3Rpb24oKXtkYy5wdXNoKGMpO3RyeXtyZXR1cm4gZS5hcHBseShudWxsLGFyZ3VtZW50cyl9ZmluYWxseXtNfHwoZGMucG9wKCksRCYmMT09PVomJjA9PT1kYy5sZW5ndGgmJihaPTAsVis9MSxiYyhlYyksXCJ1bmRlZmluZWRcIiE9dHlwZW9mIEZpYmVycyYmRmliZXJzLlBiKCkpKX19OmU7cmV0dXJuIGJ9dmFyIFo9MCxEPW51bGwsZmM9MCxkYz1bXSxnYz17fSxoYz17fSxpYz0wLGpjPW51bGwsa2M9W107XG5mdW5jdGlvbiBqYSgpe3JldHVybiBuZXcgUHJvbWlzZSgoYSxiKT0+e2pjPXtyZXNvbHZlOmEscmVqZWN0OmJ9fSl9ZnVuY3Rpb24gbGMoKXt2YXIgYT1JYig2NTU0OCksYj1hKzEyO0EoKVthPj4+Mj4+PjBdPWI7QSgpW2ErND4+PjI+Pj4wXT1iKzY1NTM2O2I9ZGNbMF07dmFyIGM9Z2NbYl07dm9pZCAwPT09YyYmKGM9aWMrKyxnY1tiXT1jLGhjW2NdPWIpO2I9Yzt6KClbYSs4Pj4+Mj4+PjBdPWI7cmV0dXJuIGF9ZnVuY3Rpb24gbWMoKXt2YXIgYT16KClbRCs4Pj4+Mj4+PjBdO2E9WVtoY1thXV07LS1WO3JldHVybiBhKCl9XG5mdW5jdGlvbiBuYyhhKXtpZighTSl7aWYoMD09PVope3ZhciBiPSExLGM9ITE7YSgoZT0wKT0+e2lmKCFNJiYoZmM9ZSxiPSEwLGMpKXtaPTI7YmMoKCk9Pm9jKEQpKTtcInVuZGVmaW5lZFwiIT10eXBlb2YgQnJvd3NlciYmQnJvd3Nlci5pYi52YiYmQnJvd3Nlci5pYi5yZXN1bWUoKTtlPSExO3RyeXt2YXIgZj1tYygpfWNhdGNoKHEpe2Y9cSxlPSEwfXZhciBoPSExO2lmKCFEKXt2YXIgaz1qYztrJiYoamM9bnVsbCwoZT9rLnJlamVjdDprLnJlc29sdmUpKGYpLGg9ITApfWlmKGUmJiFoKXRocm93IGY7fX0pO2M9ITA7Ynx8KFo9MSxEPWxjKCksXCJ1bmRlZmluZWRcIiE9dHlwZW9mIEJyb3dzZXImJkJyb3dzZXIuaWIudmImJkJyb3dzZXIuaWIucGF1c2UoKSxiYygoKT0+cGMoRCkpKX1lbHNlIDI9PT1aPyhaPTAsYmMocWMpLHJjKEQpLEQ9bnVsbCxrYy5mb3JFYWNoKGU9PntpZighTSl0cnl7ZSgpLEFiKCl9Y2F0Y2goZil7V2EoZil9fSkpOkwoYGludmFsaWQgc3RhdGU6ICR7Wn1gKTtyZXR1cm4gZmN9fVxuZnVuY3Rpb24gc2MoYSl7cmV0dXJuIG5jKGI9PnthKCkudGhlbihiKX0pfVUuaGIoKTtcbnZhciB0Yz1bVGEsVWEsaWIsa2IsbGIscGIscWIscmIsc2IsdGIsdWIsdmIsd2IseGIseWIsemIsR2IsSGIsUGIsUWIsUmIsVGIsVWIsV2JdLHhjPXtyOmZ1bmN0aW9uKGEsYixjKXtyZXR1cm4gc2MoYXN5bmMoKT0+e2F3YWl0IEIueGIoYSxiLGMpfSl9LGI6ZnVuY3Rpb24oYSxiLGMpe2E+Pj49MDsobmV3IGZiKGEpKS5oYihiPj4+MCxjPj4+MCk7Z2I9YTtoYisrO3Rocm93IGdiO30sTjpmdW5jdGlvbihhKXt1YyhhPj4+MCwhRSwxLCFuYSwxMzEwNzIsITEpO1Uub2IoKX0sbDpmdW5jdGlvbihhKXthPj4+PTA7Rz9wb3N0TWVzc2FnZSh7Y21kOlwiY2xlYW51cFRocmVhZFwiLHRocmVhZDphfSk6VS5tYihVLlFhW2FdKX0sSjpqYixpOmtiLFQ6bGIsRjpwYixIOnFiLFU6cmIsUjpzYixMOnRiLFE6dWIscDp2YixHOndiLEQ6eGIsUzp5YixFOnpiLHE6KCk9PjEsQjpmdW5jdGlvbihhLGIpe2E+Pj49MDthPT1iPj4+MD9zZXRUaW1lb3V0KCgpPT5hYigpKTpHP3Bvc3RNZXNzYWdlKHt0YXJnZXRUaHJlYWQ6YSxcbmNtZDpcImNoZWNrTWFpbGJveFwifSk6KGE9VS5RYVthXSkmJmEucG9zdE1lc3NhZ2Uoe2NtZDpcImNoZWNrTWFpbGJveFwifSl9LEs6ZnVuY3Rpb24oYSxiLGMsZSl7Yj4+Pj0wO0RiLmxlbmd0aD1jO2U9ZT4+PjA+Pj4zO2Zvcih2YXIgZj0wO2Y8YztmKyspRGJbZl09ZmEoKVtlK2Y+Pj4wXTthPTA+YT9IYVstYS0xXTp0Y1thXTtVLnViPWI7Yj1hLmFwcGx5KG51bGwsRGIpO1UudWI9MDtyZXR1cm4gYn0sTTpCYixXOmZ1bmN0aW9uKGEpe0YmJlUuUWFbYT4+PjBdLnJlZigpfSx1OmZ1bmN0aW9uKGEsYixjKXthPWIrMjA5NzE1Mj4+PjA8NDE5NDMwNS0hIWE/KGE+Pj4wKSs0Mjk0OTY3Mjk2KmI6TmFOO2M+Pj49MDthPW5ldyBEYXRlKDFFMyphKTt6KClbYz4+PjI+Pj4wXT1hLmdldFVUQ1NlY29uZHMoKTt6KClbYys0Pj4+Mj4+PjBdPWEuZ2V0VVRDTWludXRlcygpO3ooKVtjKzg+Pj4yPj4+MF09YS5nZXRVVENIb3VycygpO3ooKVtjKzEyPj4+Mj4+PjBdPWEuZ2V0VVRDRGF0ZSgpO3ooKVtjK1xuMTY+Pj4yPj4+MF09YS5nZXRVVENNb250aCgpO3ooKVtjKzIwPj4+Mj4+PjBdPWEuZ2V0VVRDRnVsbFllYXIoKS0xOTAwO3ooKVtjKzI0Pj4+Mj4+PjBdPWEuZ2V0VVRDRGF5KCk7YT0oYS5nZXRUaW1lKCktRGF0ZS5VVEMoYS5nZXRVVENGdWxsWWVhcigpLDAsMSwwLDAsMCwwKSkvODY0RTV8MDt6KClbYysyOD4+PjI+Pj4wXT1hfSx2OmZ1bmN0aW9uKGEsYixjKXthPWIrMjA5NzE1Mj4+PjA8NDE5NDMwNS0hIWE/KGE+Pj4wKSs0Mjk0OTY3Mjk2KmI6TmFOO2M+Pj49MDthPW5ldyBEYXRlKDFFMyphKTt6KClbYz4+PjI+Pj4wXT1hLmdldFNlY29uZHMoKTt6KClbYys0Pj4+Mj4+PjBdPWEuZ2V0TWludXRlcygpO3ooKVtjKzg+Pj4yPj4+MF09YS5nZXRIb3VycygpO3ooKVtjKzEyPj4+Mj4+PjBdPWEuZ2V0RGF0ZSgpO3ooKVtjKzE2Pj4+Mj4+PjBdPWEuZ2V0TW9udGgoKTt6KClbYysyMD4+PjI+Pj4wXT1hLmdldEZ1bGxZZWFyKCktMTkwMDt6KClbYysyND4+PjI+Pj4wXT1hLmdldERheSgpO1xuYj0oWChhLmdldEZ1bGxZZWFyKCkpP0ViOkZiKVthLmdldE1vbnRoKCldK2EuZ2V0RGF0ZSgpLTF8MDt6KClbYysyOD4+PjI+Pj4wXT1iO3ooKVtjKzM2Pj4+Mj4+PjBdPS0oNjAqYS5nZXRUaW1lem9uZU9mZnNldCgpKTtiPShuZXcgRGF0ZShhLmdldEZ1bGxZZWFyKCksNiwxKSkuZ2V0VGltZXpvbmVPZmZzZXQoKTt2YXIgZT0obmV3IERhdGUoYS5nZXRGdWxsWWVhcigpLDAsMSkpLmdldFRpbWV6b25lT2Zmc2V0KCk7YT0oYiE9ZSYmYS5nZXRUaW1lem9uZU9mZnNldCgpPT1NYXRoLm1pbihlLGIpKXwwO3ooKVtjKzMyPj4+Mj4+PjBdPWF9LHc6ZnVuY3Rpb24oYSl7YT4+Pj0wO3ZhciBiPW5ldyBEYXRlKHooKVthKzIwPj4+Mj4+PjBdKzE5MDAseigpW2ErMTY+Pj4yPj4+MF0seigpW2ErMTI+Pj4yPj4+MF0seigpW2ErOD4+PjI+Pj4wXSx6KClbYSs0Pj4+Mj4+PjBdLHooKVthPj4+Mj4+PjBdLDApLGM9eigpW2ErMzI+Pj4yPj4+MF0sZT1iLmdldFRpbWV6b25lT2Zmc2V0KCksZj0obmV3IERhdGUoYi5nZXRGdWxsWWVhcigpLFxuNiwxKSkuZ2V0VGltZXpvbmVPZmZzZXQoKSxoPShuZXcgRGF0ZShiLmdldEZ1bGxZZWFyKCksMCwxKSkuZ2V0VGltZXpvbmVPZmZzZXQoKSxrPU1hdGgubWluKGgsZik7MD5jP3ooKVthKzMyPj4+Mj4+PjBdPU51bWJlcihmIT1oJiZrPT1lKTowPGMhPShrPT1lKSYmKGY9TWF0aC5tYXgoaCxmKSxiLnNldFRpbWUoYi5nZXRUaW1lKCkrNkU0KigoMDxjP2s6ZiktZSkpKTt6KClbYSsyND4+PjI+Pj4wXT1iLmdldERheSgpO2M9KFgoYi5nZXRGdWxsWWVhcigpKT9FYjpGYilbYi5nZXRNb250aCgpXStiLmdldERhdGUoKS0xfDA7eigpW2ErMjg+Pj4yPj4+MF09Yzt6KClbYT4+PjI+Pj4wXT1iLmdldFNlY29uZHMoKTt6KClbYSs0Pj4+Mj4+PjBdPWIuZ2V0TWludXRlcygpO3ooKVthKzg+Pj4yPj4+MF09Yi5nZXRIb3VycygpO3ooKVthKzEyPj4+Mj4+PjBdPWIuZ2V0RGF0ZSgpO3ooKVthKzE2Pj4+Mj4+PjBdPWIuZ2V0TW9udGgoKTt6KClbYSsyMD4+PjI+Pj4wXT1iLmdldFllYXIoKTthPVxuYi5nZXRUaW1lKCk7aXNOYU4oYSk/KHooKVt2YygpPj4+Mj4+PjBdPTYxLGE9LTEpOmEvPTFFMztyZXR1cm4gd2MoKFM9YSwxPD0rTWF0aC5hYnMoUyk/MDxTPytNYXRoLmZsb29yKFMvNDI5NDk2NzI5Nik+Pj4wOn5+K01hdGguY2VpbCgoUy0rKH5+Uz4+PjApKS80Mjk0OTY3Mjk2KT4+PjA6MCkpLGE+Pj4wfSxzOkdiLHQ6SGIsQTpmdW5jdGlvbihhLGIsYyl7ZnVuY3Rpb24gZShwKXtyZXR1cm4ocD1wLnRvVGltZVN0cmluZygpLm1hdGNoKC9cXCgoW0EtWmEteiBdKylcXCkkLykpP3BbMV06XCJHTVRcIn1hPj4+PTA7Yj4+Pj0wO2M+Pj49MDt2YXIgZj0obmV3IERhdGUpLmdldEZ1bGxZZWFyKCksaD1uZXcgRGF0ZShmLDAsMSksaz1uZXcgRGF0ZShmLDYsMSk7Zj1oLmdldFRpbWV6b25lT2Zmc2V0KCk7dmFyIHE9ay5nZXRUaW1lem9uZU9mZnNldCgpLG49TWF0aC5tYXgoZixxKTtBKClbYT4+PjI+Pj4wXT02MCpuO3ooKVtiPj4+Mj4+PjBdPU51bWJlcihmIT1xKTthPWUoaCk7Yj1lKGspO1xuYT1KYihhKTtiPUpiKGIpO3E8Zj8oQSgpW2M+Pj4yPj4+MF09YSxBKClbYys0Pj4+Mj4+PjBdPWIpOihBKClbYz4+PjI+Pj4wXT1iLEEoKVtjKzQ+Pj4yPj4+MF09YSl9LGQ6KCk9PntMKFwiXCIpfSxjOmZ1bmN0aW9uKGEsYixjKXthPj4+PTA7Yj1MYihiPj4+MCxjPj4+MCk7cmV0dXJuIEhhW2FdLmFwcGx5KG51bGwsYil9LGs6ZnVuY3Rpb24oYSxiLGMpe2E+Pj49MDtiPUxiKGI+Pj4wLGM+Pj4wKTtyZXR1cm4gSGFbYV0uYXBwbHkobnVsbCxiKX0sbTooKT0+e30sajooKT0+RGF0ZS5ub3coKSxWOigpPT57Vis9MTt0aHJvd1widW53aW5kXCI7fSxDOmZ1bmN0aW9uKCl7cmV0dXJuIDQyOTQ5MDE3NjB9LGY6KCk9PnBlcmZvcm1hbmNlLnRpbWVPcmlnaW4rcGVyZm9ybWFuY2Uubm93KCksZzooKT0+Rj9yZXF1aXJlKFwib3NcIikuY3B1cygpLmxlbmd0aDpuYXZpZ2F0b3IuaGFyZHdhcmVDb25jdXJyZW5jeSx5OmZ1bmN0aW9uKGEpe2E+Pj49MDt2YXIgYj12KCkubGVuZ3RoO2lmKGE8PWJ8fDQyOTQ5MDE3NjA8XG5hKXJldHVybiExO2Zvcih2YXIgYz0xOzQ+PWM7Yyo9Mil7dmFyIGU9YiooMSsuMi9jKTtlPU1hdGgubWluKGUsYSsxMDA2NjMyOTYpO3ZhciBmPU1hdGg7ZT1NYXRoLm1heChhLGUpO2E6e2Y9KGYubWluLmNhbGwoZiw0Mjk0OTAxNzYwLGUrKDY1NTM2LWUlNjU1MzYpJTY1NTM2KS1sLmJ1ZmZlci5ieXRlTGVuZ3RoKzY1NTM1KS82NTUzNjt0cnl7bC5ncm93KGYpO3UoKTt2YXIgaD0xO2JyZWFrIGF9Y2F0Y2goayl7fWg9dm9pZCAwfWlmKGgpcmV0dXJuITB9cmV0dXJuITF9LE86UGIsUDpRYixJOlZhLGg6UmIsbzpUYix4OlViLG46V2IsYTpsfHxCLndhc21NZW1vcnksejphYyxlOmZ1bmN0aW9uKGEsYixjLGUpe3JldHVybiBhYyhhPj4+MCxiPj4+MCxjPj4+MCxlPj4+MCl9fSxZPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gYShjLGUpe1k9Yy5leHBvcnRzO1k9Y2MoKTtZPXljKCk7VS5wYi5wdXNoKFkuRGEpO3lhLnVuc2hpZnQoWS5YKTt2YT1lO0JhKCk7cmV0dXJuIFl9dmFyIGI9e2E6eGN9O1xuUCsrO2lmKEIuaW5zdGFudGlhdGVXYXNtKXRyeXtyZXR1cm4gQi5pbnN0YW50aWF0ZVdhc20oYixhKX1jYXRjaChjKXtLKGBNb2R1bGUuaW5zdGFudGlhdGVXYXNtIGNhbGxiYWNrIGZhaWxlZCB3aXRoIGVycm9yOiAke2N9YCksQyhjKX1HYShiLGZ1bmN0aW9uKGMpe2EoYy5pbnN0YW5jZSxjLm1vZHVsZSl9KS5jYXRjaChDKTtyZXR1cm57fX0oKTtCLl9PcnRJbml0PShhLGIpPT4oQi5fT3J0SW5pdD1ZLlkpKGEsYik7Qi5fT3J0R2V0TGFzdEVycm9yPShhLGIpPT4oQi5fT3J0R2V0TGFzdEVycm9yPVkuWikoYSxiKTtCLl9PcnRDcmVhdGVTZXNzaW9uT3B0aW9ucz0oYSxiLGMsZSxmLGgsayxxLG4scCk9PihCLl9PcnRDcmVhdGVTZXNzaW9uT3B0aW9ucz1ZLl8pKGEsYixjLGUsZixoLGsscSxuLHApO0IuX09ydEFwcGVuZEV4ZWN1dGlvblByb3ZpZGVyPShhLGIpPT4oQi5fT3J0QXBwZW5kRXhlY3V0aW9uUHJvdmlkZXI9WS4kKShhLGIpO1xuQi5fT3J0QWRkRnJlZURpbWVuc2lvbk92ZXJyaWRlPShhLGIsYyk9PihCLl9PcnRBZGRGcmVlRGltZW5zaW9uT3ZlcnJpZGU9WS5hYSkoYSxiLGMpO0IuX09ydEFkZFNlc3Npb25Db25maWdFbnRyeT0oYSxiLGMpPT4oQi5fT3J0QWRkU2Vzc2lvbkNvbmZpZ0VudHJ5PVkuYmEpKGEsYixjKTtCLl9PcnRSZWxlYXNlU2Vzc2lvbk9wdGlvbnM9YT0+KEIuX09ydFJlbGVhc2VTZXNzaW9uT3B0aW9ucz1ZLmNhKShhKTtCLl9PcnRDcmVhdGVTZXNzaW9uPShhLGIsYyk9PihCLl9PcnRDcmVhdGVTZXNzaW9uPVkuZGEpKGEsYixjKTtCLl9PcnRSZWxlYXNlU2Vzc2lvbj1hPT4oQi5fT3J0UmVsZWFzZVNlc3Npb249WS5lYSkoYSk7Qi5fT3J0R2V0SW5wdXRPdXRwdXRDb3VudD0oYSxiLGMpPT4oQi5fT3J0R2V0SW5wdXRPdXRwdXRDb3VudD1ZLmZhKShhLGIsYyk7Qi5fT3J0R2V0SW5wdXROYW1lPShhLGIpPT4oQi5fT3J0R2V0SW5wdXROYW1lPVkuZ2EpKGEsYik7XG5CLl9PcnRHZXRPdXRwdXROYW1lPShhLGIpPT4oQi5fT3J0R2V0T3V0cHV0TmFtZT1ZLmhhKShhLGIpO0IuX09ydEZyZWU9YT0+KEIuX09ydEZyZWU9WS5pYSkoYSk7Qi5fT3J0Q3JlYXRlVGVuc29yPShhLGIsYyxlLGYsaCk9PihCLl9PcnRDcmVhdGVUZW5zb3I9WS5qYSkoYSxiLGMsZSxmLGgpO0IuX09ydEdldFRlbnNvckRhdGE9KGEsYixjLGUsZik9PihCLl9PcnRHZXRUZW5zb3JEYXRhPVkua2EpKGEsYixjLGUsZik7Qi5fT3J0UmVsZWFzZVRlbnNvcj1hPT4oQi5fT3J0UmVsZWFzZVRlbnNvcj1ZLmxhKShhKTtCLl9PcnRDcmVhdGVSdW5PcHRpb25zPShhLGIsYyxlKT0+KEIuX09ydENyZWF0ZVJ1bk9wdGlvbnM9WS5tYSkoYSxiLGMsZSk7Qi5fT3J0QWRkUnVuQ29uZmlnRW50cnk9KGEsYixjKT0+KEIuX09ydEFkZFJ1bkNvbmZpZ0VudHJ5PVkubmEpKGEsYixjKTtCLl9PcnRSZWxlYXNlUnVuT3B0aW9ucz1hPT4oQi5fT3J0UmVsZWFzZVJ1bk9wdGlvbnM9WS5vYSkoYSk7XG5CLl9PcnRDcmVhdGVCaW5kaW5nPWE9PihCLl9PcnRDcmVhdGVCaW5kaW5nPVkucGEpKGEpO0IuX09ydEJpbmRJbnB1dD0oYSxiLGMpPT4oQi5fT3J0QmluZElucHV0PVkucWEpKGEsYixjKTtCLl9PcnRCaW5kT3V0cHV0PShhLGIsYyxlKT0+KEIuX09ydEJpbmRPdXRwdXQ9WS5yYSkoYSxiLGMsZSk7Qi5fT3J0Q2xlYXJCb3VuZE91dHB1dHM9YT0+KEIuX09ydENsZWFyQm91bmRPdXRwdXRzPVkuc2EpKGEpO0IuX09ydFJlbGVhc2VCaW5kaW5nPWE9PihCLl9PcnRSZWxlYXNlQmluZGluZz1ZLnRhKShhKTtCLl9PcnRSdW5XaXRoQmluZGluZz0oYSxiLGMsZSxmKT0+KEIuX09ydFJ1bldpdGhCaW5kaW5nPVkudWEpKGEsYixjLGUsZik7Qi5fT3J0UnVuPShhLGIsYyxlLGYsaCxrLHEpPT4oQi5fT3J0UnVuPVkudmEpKGEsYixjLGUsZixoLGsscSk7Qi5fT3J0RW5kUHJvZmlsaW5nPWE9PihCLl9PcnRFbmRQcm9maWxpbmc9WS53YSkoYSk7XG5CLl9Kc2VwT3V0cHV0PShhLGIsYyk9PihCLl9Kc2VwT3V0cHV0PVkueGEpKGEsYixjKTtCLl9Kc2VwR2V0Tm9kZU5hbWU9YT0+KEIuX0pzZXBHZXROb2RlTmFtZT1ZLnlhKShhKTt2YXIgdmM9KCk9Pih2Yz1ZLnphKSgpLCRhPUIuX3B0aHJlYWRfc2VsZj0oKT0+KCRhPUIuX3B0aHJlYWRfc2VsZj1ZLkFhKSgpLEliPUIuX21hbGxvYz1hPT4oSWI9Qi5fbWFsbG9jPVkuQmEpKGEpLHJjPUIuX2ZyZWU9YT0+KHJjPUIuX2ZyZWU9WS5DYSkoYSk7Qi5fX2Vtc2NyaXB0ZW5fdGxzX2luaXQ9KCk9PihCLl9fZW1zY3JpcHRlbl90bHNfaW5pdD1ZLkRhKSgpO3ZhciB1Yz1CLl9fZW1zY3JpcHRlbl90aHJlYWRfaW5pdD0oYSxiLGMsZSxmLGgpPT4odWM9Qi5fX2Vtc2NyaXB0ZW5fdGhyZWFkX2luaXQ9WS5GYSkoYSxiLGMsZSxmLGgpO0IuX19lbXNjcmlwdGVuX3RocmVhZF9jcmFzaGVkPSgpPT4oQi5fX2Vtc2NyaXB0ZW5fdGhyZWFkX2NyYXNoZWQ9WS5HYSkoKTtcbnZhciBTYT0oYSxiLGMsZSk9PihTYT1ZLkhhKShhLGIsYyxlKSxaYT1hPT4oWmE9WS5JYSkoYSksZWI9Qi5fX2Vtc2NyaXB0ZW5fdGhyZWFkX2V4aXQ9YT0+KGViPUIuX19lbXNjcmlwdGVuX3RocmVhZF9leGl0PVkuSmEpKGEpLENiPSgpPT4oQ2I9WS5LYSkoKSx3Yz1hPT4od2M9WS5MYSkoYSksY2I9KGEsYik9PihjYj1ZLk1hKShhLGIpLE9hPSgpPT4oT2E9WS5OYSkoKSxQYT1hPT4oUGE9WS5PYSkoYSksUmE9YT0+KFJhPVkuUGEpKGEpLGRiPUIuZHluQ2FsbF9paT0oYSxiKT0+KGRiPUIuZHluQ2FsbF9paT1ZLlJhKShhLGIpLHBjPWE9PihwYz1ZLlNhKShhKSxlYz0oKT0+KGVjPVkuVGEpKCksb2M9YT0+KG9jPVkuVWEpKGEpLHFjPSgpPT4ocWM9WS5WYSkoKTtCLl9fX3N0YXJ0X2VtX2pzPTk0NDQ3MjtCLl9fX3N0b3BfZW1fanM9OTQ0NjMzO1xuZnVuY3Rpb24geWMoKXt2YXIgYT1ZO2E9T2JqZWN0LmFzc2lnbih7fSxhKTt2YXIgYj1lPT4oKT0+ZSgpPj4+MCxjPWU9PmY9PmUoZik+Pj4wO2EuemE9YihhLnphKTthLkFhPWIoYS5BYSk7YS5CYT1jKGEuQmEpO2EuZW1zY3JpcHRlbl9tYWluX3J1bnRpbWVfdGhyZWFkX2lkPWIoYS5lbXNjcmlwdGVuX21haW5fcnVudGltZV90aHJlYWRfaWQpO2EuTmE9YihhLk5hKTthLlBhPWMoYS5QYSk7cmV0dXJuIGF9Qi53YXNtTWVtb3J5PWw7Qi5zdGFja0FsbG9jPVJhO0Iuc3RhY2tTYXZlPU9hO0Iuc3RhY2tSZXN0b3JlPVBhO0Iua2VlcFJ1bnRpbWVBbGl2ZT0oKT0+MDxWO0IuVVRGOFRvU3RyaW5nPVQ7Qi5zdHJpbmdUb1VURjg9b2I7Qi5sZW5ndGhCeXRlc1VURjg9bWI7Qi5FeGl0U3RhdHVzPUlhO0IuUFRocmVhZD1VO3ZhciB6YztRPWZ1bmN0aW9uIEFjKCl7emN8fEJjKCk7emN8fChRPUFjKX07XG5mdW5jdGlvbiBCYygpe2lmKCEoMDxQKSlpZihHKWlhKEIpLEd8fGJiKHlhKSxzdGFydFdvcmtlcihCKTtlbHNle2lmKEIucHJlUnVuKWZvcihcImZ1bmN0aW9uXCI9PXR5cGVvZiBCLnByZVJ1biYmKEIucHJlUnVuPVtCLnByZVJ1bl0pO0IucHJlUnVuLmxlbmd0aDspeGEudW5zaGlmdChCLnByZVJ1bi5zaGlmdCgpKTtiYih4YSk7MDxQfHx6Y3x8KHpjPSEwLEIuY2FsbGVkUnVuPSEwLE18fChHfHxiYih5YSksaWEoQiksR3x8YmIoemEpKSl9fUJjKCk7XG5cblxuICByZXR1cm4gbW9kdWxlQXJnLnJlYWR5XG59XG4pO1xufSkoKTtcbjtcbmlmICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG4gIG1vZHVsZS5leHBvcnRzID0gb3J0V2FzbVRocmVhZGVkO1xuZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmVbJ2FtZCddKVxuICBkZWZpbmUoW10sICgpID0+IG9ydFdhc21UaHJlYWRlZCk7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7dmFyIE1vZHVsZT17fTt2YXIgRU5WSVJPTk1FTlRfSVNfTk9ERT10eXBlb2YgcHJvY2Vzcz09XCJvYmplY3RcIiYmdHlwZW9mIHByb2Nlc3MudmVyc2lvbnM9PVwib2JqZWN0XCImJnR5cGVvZiBwcm9jZXNzLnZlcnNpb25zLm5vZGU9PVwic3RyaW5nXCI7aWYoRU5WSVJPTk1FTlRfSVNfTk9ERSl7dmFyIG5vZGVXb3JrZXJUaHJlYWRzPXJlcXVpcmUoXCJ3b3JrZXJfdGhyZWFkc1wiKTt2YXIgcGFyZW50UG9ydD1ub2RlV29ya2VyVGhyZWFkcy5wYXJlbnRQb3J0O3BhcmVudFBvcnQub24oXCJtZXNzYWdlXCIsZGF0YT0+b25tZXNzYWdlKHtkYXRhOmRhdGF9KSk7dmFyIGZzPXJlcXVpcmUoXCJmc1wiKTt2YXIgdm09cmVxdWlyZShcInZtXCIpO09iamVjdC5hc3NpZ24oZ2xvYmFsLHtzZWxmOmdsb2JhbCxyZXF1aXJlOnJlcXVpcmUsTW9kdWxlOk1vZHVsZSxsb2NhdGlvbjp7aHJlZjpfX2ZpbGVuYW1lfSxXb3JrZXI6bm9kZVdvcmtlclRocmVhZHMuV29ya2VyLGltcG9ydFNjcmlwdHM6Zj0+dm0ucnVuSW5UaGlzQ29udGV4dChmcy5yZWFkRmlsZVN5bmMoZixcInV0ZjhcIikse2ZpbGVuYW1lOmZ9KSxwb3N0TWVzc2FnZTptc2c9PnBhcmVudFBvcnQucG9zdE1lc3NhZ2UobXNnKSxwZXJmb3JtYW5jZTpnbG9iYWwucGVyZm9ybWFuY2V8fHtub3c6RGF0ZS5ub3d9fSl9dmFyIGluaXRpYWxpemVkSlM9ZmFsc2U7ZnVuY3Rpb24gdGhyZWFkUHJpbnRFcnIoKXt2YXIgdGV4dD1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpLmpvaW4oXCIgXCIpO2lmKEVOVklST05NRU5UX0lTX05PREUpe2ZzLndyaXRlU3luYygyLHRleHQrXCJcXG5cIik7cmV0dXJufWNvbnNvbGUuZXJyb3IodGV4dCl9ZnVuY3Rpb24gdGhyZWFkQWxlcnQoKXt2YXIgdGV4dD1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpLmpvaW4oXCIgXCIpO3Bvc3RNZXNzYWdlKHtjbWQ6XCJhbGVydFwiLHRleHQ6dGV4dCx0aHJlYWRJZDpNb2R1bGVbXCJfcHRocmVhZF9zZWxmXCJdKCl9KX12YXIgZXJyPXRocmVhZFByaW50RXJyO3NlbGYuYWxlcnQ9dGhyZWFkQWxlcnQ7TW9kdWxlW1wiaW5zdGFudGlhdGVXYXNtXCJdPShpbmZvLHJlY2VpdmVJbnN0YW5jZSk9Pnt2YXIgbW9kdWxlPU1vZHVsZVtcIndhc21Nb2R1bGVcIl07TW9kdWxlW1wid2FzbU1vZHVsZVwiXT1udWxsO3ZhciBpbnN0YW5jZT1uZXcgV2ViQXNzZW1ibHkuSW5zdGFuY2UobW9kdWxlLGluZm8pO3JldHVybiByZWNlaXZlSW5zdGFuY2UoaW5zdGFuY2UpfTtzZWxmLm9udW5oYW5kbGVkcmVqZWN0aW9uPWU9Pnt0aHJvdyBlLnJlYXNvbnx8ZX07ZnVuY3Rpb24gaGFuZGxlTWVzc2FnZShlKXt0cnl7aWYoZS5kYXRhLmNtZD09PVwibG9hZFwiKXtsZXQgbWVzc2FnZVF1ZXVlPVtdO3NlbGYub25tZXNzYWdlPWU9Pm1lc3NhZ2VRdWV1ZS5wdXNoKGUpO3NlbGYuc3RhcnRXb3JrZXI9aW5zdGFuY2U9PntNb2R1bGU9aW5zdGFuY2U7cG9zdE1lc3NhZ2Uoe1wiY21kXCI6XCJsb2FkZWRcIn0pO2ZvcihsZXQgbXNnIG9mIG1lc3NhZ2VRdWV1ZSl7aGFuZGxlTWVzc2FnZShtc2cpfXNlbGYub25tZXNzYWdlPWhhbmRsZU1lc3NhZ2V9O01vZHVsZVtcIndhc21Nb2R1bGVcIl09ZS5kYXRhLndhc21Nb2R1bGU7Zm9yKGNvbnN0IGhhbmRsZXIgb2YgZS5kYXRhLmhhbmRsZXJzKXtNb2R1bGVbaGFuZGxlcl09KC4uLmFyZ3MpPT57cG9zdE1lc3NhZ2Uoe2NtZDpcImNhbGxIYW5kbGVyXCIsaGFuZGxlcjpoYW5kbGVyLGFyZ3M6YXJnc30pfX1Nb2R1bGVbXCJ3YXNtTWVtb3J5XCJdPWUuZGF0YS53YXNtTWVtb3J5O01vZHVsZVtcImJ1ZmZlclwiXT1Nb2R1bGVbXCJ3YXNtTWVtb3J5XCJdLmJ1ZmZlcjtNb2R1bGVbXCJFTlZJUk9OTUVOVF9JU19QVEhSRUFEXCJdPXRydWU7aWYodHlwZW9mIGUuZGF0YS51cmxPckJsb2I9PVwic3RyaW5nXCIpe2ltcG9ydFNjcmlwdHMoZS5kYXRhLnVybE9yQmxvYil9ZWxzZXt2YXIgb2JqZWN0VXJsPVVSTC5jcmVhdGVPYmplY3RVUkwoZS5kYXRhLnVybE9yQmxvYik7aW1wb3J0U2NyaXB0cyhvYmplY3RVcmwpO1VSTC5yZXZva2VPYmplY3RVUkwob2JqZWN0VXJsKX1vcnRXYXNtVGhyZWFkZWQoTW9kdWxlKX1lbHNlIGlmKGUuZGF0YS5jbWQ9PT1cInJ1blwiKXtNb2R1bGVbXCJfX2Vtc2NyaXB0ZW5fdGhyZWFkX2luaXRcIl0oZS5kYXRhLnB0aHJlYWRfcHRyLC8qaXNfbWFpbj0qLzAsLyppc19ydW50aW1lPSovMCwvKmNhbl9ibG9jaz0qLzEpO01vZHVsZVtcIl9fZW1zY3JpcHRlbl90aHJlYWRfbWFpbGJveF9hd2FpdFwiXShlLmRhdGEucHRocmVhZF9wdHIpO01vZHVsZVtcImVzdGFibGlzaFN0YWNrU3BhY2VcIl0oKTtNb2R1bGVbXCJQVGhyZWFkXCJdLnJlY2VpdmVPYmplY3RUcmFuc2ZlcihlLmRhdGEpO01vZHVsZVtcIlBUaHJlYWRcIl0udGhyZWFkSW5pdFRMUygpO2lmKCFpbml0aWFsaXplZEpTKXtpbml0aWFsaXplZEpTPXRydWV9dHJ5e01vZHVsZVtcImludm9rZUVudHJ5UG9pbnRcIl0oZS5kYXRhLnN0YXJ0X3JvdXRpbmUsZS5kYXRhLmFyZyl9Y2F0Y2goZXgpe2lmKGV4IT1cInVud2luZFwiKXt0aHJvdyBleH19fWVsc2UgaWYoZS5kYXRhLmNtZD09PVwiY2FuY2VsXCIpe2lmKE1vZHVsZVtcIl9wdGhyZWFkX3NlbGZcIl0oKSl7TW9kdWxlW1wiX19lbXNjcmlwdGVuX3RocmVhZF9leGl0XCJdKC0xKX19ZWxzZSBpZihlLmRhdGEudGFyZ2V0PT09XCJzZXRpbW1lZGlhdGVcIil7fWVsc2UgaWYoZS5kYXRhLmNtZD09PVwiY2hlY2tNYWlsYm94XCIpe2lmKGluaXRpYWxpemVkSlMpe01vZHVsZVtcImNoZWNrTWFpbGJveFwiXSgpfX1lbHNlIGlmKGUuZGF0YS5jbWQpe2Vycihgd29ya2VyLmpzIHJlY2VpdmVkIHVua25vd24gY29tbWFuZCAke2UuZGF0YS5jbWR9YCk7ZXJyKGUuZGF0YSl9fWNhdGNoKGV4KXtNb2R1bGVbXCJfX2Vtc2NyaXB0ZW5fdGhyZWFkX2NyYXNoZWRcIl0/LigpO3Rocm93IGV4fX1zZWxmLm9ubWVzc2FnZT1oYW5kbGVNZXNzYWdlO1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge1RlbnNvcn0gZnJvbSAnb25ueHJ1bnRpbWUtY29tbW9uJztcblxuLy8gVGhpcyBmaWxlIGluY2x1ZGVzIGNvbW1vbiBkZWZpbml0aW9ucy4gVGhleSBkbyBOT1QgaGF2ZSBkZXBlbmRlbmN5IG9uIHRoZSBXZWJBc3NlbWJseSBpbnN0YW5jZS5cblxuLyoqXG4gKiBDb3BpZWQgZnJvbSBPTk5YIGRlZmluaXRpb24uIFVzZSB0aGlzIHRvIGRyb3AgZGVwZW5kZW5jeSAnb25ueF9wcm90bycgdG8gZGVjcmVhc2UgY29tcGlsZWQgLmpzIGZpbGUgc2l6ZS5cbiAqL1xuZXhwb3J0IGNvbnN0IGVudW0gRGF0YVR5cGUge1xuICB1bmRlZmluZWQgPSAwLFxuICBmbG9hdCA9IDEsXG4gIHVpbnQ4ID0gMixcbiAgaW50OCA9IDMsXG4gIHVpbnQxNiA9IDQsXG4gIGludDE2ID0gNSxcbiAgaW50MzIgPSA2LFxuICBpbnQ2NCA9IDcsXG4gIHN0cmluZyA9IDgsXG4gIGJvb2wgPSA5LFxuICBmbG9hdDE2ID0gMTAsXG4gIGRvdWJsZSA9IDExLFxuICB1aW50MzIgPSAxMixcbiAgdWludDY0ID0gMTMsXG4gIGNvbXBsZXg2NCA9IDE0LFxuICBjb21wbGV4MTI4ID0gMTUsXG4gIGJmbG9hdDE2ID0gMTZcbn1cblxuLyoqXG4gKiBNYXAgc3RyaW5nIHRlbnNvciBkYXRhIHRvIGVudW0gdmFsdWVcbiAqL1xuZXhwb3J0IGNvbnN0IHRlbnNvckRhdGFUeXBlU3RyaW5nVG9FbnVtID0gKHR5cGU6IHN0cmluZyk6IERhdGFUeXBlID0+IHtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAnaW50OCc6XG4gICAgICByZXR1cm4gRGF0YVR5cGUuaW50ODtcbiAgICBjYXNlICd1aW50OCc6XG4gICAgICByZXR1cm4gRGF0YVR5cGUudWludDg7XG4gICAgY2FzZSAnYm9vbCc6XG4gICAgICByZXR1cm4gRGF0YVR5cGUuYm9vbDtcbiAgICBjYXNlICdpbnQxNic6XG4gICAgICByZXR1cm4gRGF0YVR5cGUuaW50MTY7XG4gICAgY2FzZSAndWludDE2JzpcbiAgICAgIHJldHVybiBEYXRhVHlwZS51aW50MTY7XG4gICAgY2FzZSAnaW50MzInOlxuICAgICAgcmV0dXJuIERhdGFUeXBlLmludDMyO1xuICAgIGNhc2UgJ3VpbnQzMic6XG4gICAgICByZXR1cm4gRGF0YVR5cGUudWludDMyO1xuICAgIGNhc2UgJ2Zsb2F0MTYnOlxuICAgICAgcmV0dXJuIERhdGFUeXBlLmZsb2F0MTY7XG4gICAgY2FzZSAnZmxvYXQzMic6XG4gICAgICByZXR1cm4gRGF0YVR5cGUuZmxvYXQ7XG4gICAgY2FzZSAnZmxvYXQ2NCc6XG4gICAgICByZXR1cm4gRGF0YVR5cGUuZG91YmxlO1xuICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICByZXR1cm4gRGF0YVR5cGUuc3RyaW5nO1xuICAgIGNhc2UgJ2ludDY0JzpcbiAgICAgIHJldHVybiBEYXRhVHlwZS5pbnQ2NDtcbiAgICBjYXNlICd1aW50NjQnOlxuICAgICAgcmV0dXJuIERhdGFUeXBlLnVpbnQ2NDtcblxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIGRhdGEgdHlwZTogJHt0eXBlfWApO1xuICB9XG59O1xuXG4vKipcbiAqIE1hcCBlbnVtIHZhbHVlIHRvIHN0cmluZyB0ZW5zb3IgZGF0YVxuICovXG5leHBvcnQgY29uc3QgdGVuc29yRGF0YVR5cGVFbnVtVG9TdHJpbmcgPSAodHlwZVByb3RvOiBEYXRhVHlwZSk6IFRlbnNvci5UeXBlID0+IHtcbiAgc3dpdGNoICh0eXBlUHJvdG8pIHtcbiAgICBjYXNlIERhdGFUeXBlLmludDg6XG4gICAgICByZXR1cm4gJ2ludDgnO1xuICAgIGNhc2UgRGF0YVR5cGUudWludDg6XG4gICAgICByZXR1cm4gJ3VpbnQ4JztcbiAgICBjYXNlIERhdGFUeXBlLmJvb2w6XG4gICAgICByZXR1cm4gJ2Jvb2wnO1xuICAgIGNhc2UgRGF0YVR5cGUuaW50MTY6XG4gICAgICByZXR1cm4gJ2ludDE2JztcbiAgICBjYXNlIERhdGFUeXBlLnVpbnQxNjpcbiAgICAgIHJldHVybiAndWludDE2JztcbiAgICBjYXNlIERhdGFUeXBlLmludDMyOlxuICAgICAgcmV0dXJuICdpbnQzMic7XG4gICAgY2FzZSBEYXRhVHlwZS51aW50MzI6XG4gICAgICByZXR1cm4gJ3VpbnQzMic7XG4gICAgY2FzZSBEYXRhVHlwZS5mbG9hdDE2OlxuICAgICAgcmV0dXJuICdmbG9hdDE2JztcbiAgICBjYXNlIERhdGFUeXBlLmZsb2F0OlxuICAgICAgcmV0dXJuICdmbG9hdDMyJztcbiAgICBjYXNlIERhdGFUeXBlLmRvdWJsZTpcbiAgICAgIHJldHVybiAnZmxvYXQ2NCc7XG4gICAgY2FzZSBEYXRhVHlwZS5zdHJpbmc6XG4gICAgICByZXR1cm4gJ3N0cmluZyc7XG4gICAgY2FzZSBEYXRhVHlwZS5pbnQ2NDpcbiAgICAgIHJldHVybiAnaW50NjQnO1xuICAgIGNhc2UgRGF0YVR5cGUudWludDY0OlxuICAgICAgcmV0dXJuICd1aW50NjQnO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgZGF0YSB0eXBlOiAke3R5cGVQcm90b31gKTtcbiAgfVxufTtcblxuLyoqXG4gKiBnZXQgdGVuc29yIGVsZW1lbnQgc2l6ZSBpbiBieXRlcyBieSB0aGUgZ2l2ZW4gZGF0YSB0eXBlXG4gKiBAcmV0dXJucyBzaXplIGluIGludGVnZXIgb3IgdW5kZWZpbmVkIGlmIHRoZSBkYXRhIHR5cGUgaXMgbm90IHN1cHBvcnRlZFxuICovXG5leHBvcnQgY29uc3QgZ2V0VGVuc29yRWxlbWVudFNpemUgPSAoZGF0ZVR5cGU6IG51bWJlcik6IG51bWJlcnxcbiAgICB1bmRlZmluZWQgPT4gW3VuZGVmaW5lZCwgNCwgMSwgMSwgMiwgMiwgNCwgOCwgdW5kZWZpbmVkLCAxLCAyLCA4LCA0LCA4LCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkXVtkYXRlVHlwZV07XG5cbi8qKlxuICogZ2V0IHR5cGVkIGFycmF5IGNvbnN0cnVjdG9yIGJ5IHRoZSBnaXZlbiB0ZW5zb3IgdHlwZVxuICovXG5leHBvcnQgY29uc3QgdGVuc29yVHlwZVRvVHlwZWRBcnJheUNvbnN0cnVjdG9yID0gKHR5cGU6IFRlbnNvci5UeXBlKTogRmxvYXQzMkFycmF5Q29uc3RydWN0b3J8VWludDhBcnJheUNvbnN0cnVjdG9yfFxuICAgIEludDhBcnJheUNvbnN0cnVjdG9yfFVpbnQxNkFycmF5Q29uc3RydWN0b3J8SW50MTZBcnJheUNvbnN0cnVjdG9yfEludDMyQXJyYXlDb25zdHJ1Y3RvcnxCaWdJbnQ2NEFycmF5Q29uc3RydWN0b3J8XG4gICAgVWludDhBcnJheUNvbnN0cnVjdG9yfEZsb2F0NjRBcnJheUNvbnN0cnVjdG9yfFVpbnQzMkFycmF5Q29uc3RydWN0b3J8QmlnVWludDY0QXJyYXlDb25zdHJ1Y3RvciA9PiB7XG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSAnZmxvYXQxNic6XG4gICAgICAgICAgcmV0dXJuIFVpbnQxNkFycmF5O1xuICAgICAgICBjYXNlICdmbG9hdDMyJzpcbiAgICAgICAgICByZXR1cm4gRmxvYXQzMkFycmF5O1xuICAgICAgICBjYXNlICd1aW50OCc6XG4gICAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXk7XG4gICAgICAgIGNhc2UgJ2ludDgnOlxuICAgICAgICAgIHJldHVybiBJbnQ4QXJyYXk7XG4gICAgICAgIGNhc2UgJ3VpbnQxNic6XG4gICAgICAgICAgcmV0dXJuIFVpbnQxNkFycmF5O1xuICAgICAgICBjYXNlICdpbnQxNic6XG4gICAgICAgICAgcmV0dXJuIEludDE2QXJyYXk7XG4gICAgICAgIGNhc2UgJ2ludDMyJzpcbiAgICAgICAgICByZXR1cm4gSW50MzJBcnJheTtcbiAgICAgICAgY2FzZSAnYm9vbCc6XG4gICAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXk7XG4gICAgICAgIGNhc2UgJ2Zsb2F0NjQnOlxuICAgICAgICAgIHJldHVybiBGbG9hdDY0QXJyYXk7XG4gICAgICAgIGNhc2UgJ3VpbnQzMic6XG4gICAgICAgICAgcmV0dXJuIFVpbnQzMkFycmF5O1xuICAgICAgICBjYXNlICdpbnQ2NCc6XG4gICAgICAgICAgcmV0dXJuIEJpZ0ludDY0QXJyYXk7XG4gICAgICAgIGNhc2UgJ3VpbnQ2NCc6XG4gICAgICAgICAgcmV0dXJuIEJpZ1VpbnQ2NEFycmF5O1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgdHlwZTogJHt0eXBlfWApO1xuICAgICAgfVxuICAgIH07XG5cbi8qKlxuICogTWFwIHN0cmluZyBsb2cgbGV2ZWwgdG8gaW50ZWdlciB2YWx1ZVxuICovXG5leHBvcnQgY29uc3QgbG9nTGV2ZWxTdHJpbmdUb0VudW0gPSAobG9nTGV2ZWw/OiAndmVyYm9zZSd8J2luZm8nfCd3YXJuaW5nJ3wnZXJyb3InfCdmYXRhbCcpOiBudW1iZXIgPT4ge1xuICBzd2l0Y2ggKGxvZ0xldmVsKSB7XG4gICAgY2FzZSAndmVyYm9zZSc6XG4gICAgICByZXR1cm4gMDtcbiAgICBjYXNlICdpbmZvJzpcbiAgICAgIHJldHVybiAxO1xuICAgIGNhc2UgJ3dhcm5pbmcnOlxuICAgICAgcmV0dXJuIDI7XG4gICAgY2FzZSAnZXJyb3InOlxuICAgICAgcmV0dXJuIDM7XG4gICAgY2FzZSAnZmF0YWwnOlxuICAgICAgcmV0dXJuIDQ7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgbG9nZ2luZyBsZXZlbDogJHtsb2dMZXZlbH1gKTtcbiAgfVxufTtcblxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIHRoZSBnaXZlbiB0ZW5zb3IgdHlwZSBpcyBzdXBwb3J0ZWQgYnkgR1BVIGJ1ZmZlclxuICovXG5leHBvcnQgY29uc3QgaXNHcHVCdWZmZXJTdXBwb3J0ZWRUeXBlID0gKHR5cGU6IFRlbnNvci5UeXBlKTogdHlwZSBpcyBUZW5zb3IuR3B1QnVmZmVyRGF0YVR5cGVzID0+IHR5cGUgPT09ICdmbG9hdDMyJyB8fFxuICAgIHR5cGUgPT09ICdpbnQzMicgfHwgdHlwZSA9PT0gJ2ludDY0JyB8fCB0eXBlID09PSAnYm9vbCcgfHwgdHlwZSA9PT0gJ2Zsb2F0MTYnIHx8IHR5cGUgPT09ICd1aW50MzInO1xuXG4vKipcbiAqIE1hcCBzdHJpbmcgZGF0YSBsb2NhdGlvbiB0byBpbnRlZ2VyIHZhbHVlXG4gKi9cbmV4cG9ydCBjb25zdCBkYXRhTG9jYXRpb25TdHJpbmdUb0VudW0gPSAobG9jYXRpb246IFRlbnNvci5EYXRhTG9jYXRpb24pOiBudW1iZXIgPT4ge1xuICBzd2l0Y2ggKGxvY2F0aW9uKSB7XG4gICAgY2FzZSAnbm9uZSc6XG4gICAgICByZXR1cm4gMDtcbiAgICBjYXNlICdjcHUnOlxuICAgICAgcmV0dXJuIDE7XG4gICAgY2FzZSAnY3B1LXBpbm5lZCc6XG4gICAgICByZXR1cm4gMjtcbiAgICBjYXNlICd0ZXh0dXJlJzpcbiAgICAgIHJldHVybiAzO1xuICAgIGNhc2UgJ2dwdS1idWZmZXInOlxuICAgICAgcmV0dXJuIDQ7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgZGF0YSBsb2NhdGlvbjogJHtsb2NhdGlvbn1gKTtcbiAgfVxufTtcblxuLyoqXG4gKiBNYXAgaW50ZWdlciBkYXRhIGxvY2F0aW9uIHRvIHN0cmluZyB2YWx1ZVxuICovXG5leHBvcnQgY29uc3QgZGF0YUxvY2F0aW9uRW51bVRvU3RyaW5nID0gKGxvY2F0aW9uOiBudW1iZXIpOiBUZW5zb3IuRGF0YUxvY2F0aW9ufHVuZGVmaW5lZCA9PlxuICAgIChbJ25vbmUnLCAnY3B1JywgJ2NwdS1waW5uZWQnLCAndGV4dHVyZScsICdncHUtYnVmZmVyJ10gYXMgY29uc3QpW2xvY2F0aW9uXTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtCYWNrZW5kfSBmcm9tICcuL2JhY2tlbmQuanMnO1xuXG5pbnRlcmZhY2UgQmFja2VuZEluZm8ge1xuICBiYWNrZW5kOiBCYWNrZW5kO1xuICBwcmlvcml0eTogbnVtYmVyO1xuXG4gIGluaXRQcm9taXNlPzogUHJvbWlzZTx2b2lkPjtcbiAgaW5pdGlhbGl6ZWQ/OiBib29sZWFuO1xuICBhYm9ydGVkPzogYm9vbGVhbjtcbn1cblxuY29uc3QgYmFja2VuZHM6IE1hcDxzdHJpbmcsIEJhY2tlbmRJbmZvPiA9IG5ldyBNYXAoKTtcbmNvbnN0IGJhY2tlbmRzU29ydGVkQnlQcmlvcml0eTogc3RyaW5nW10gPSBbXTtcblxuLyoqXG4gKiBSZWdpc3RlciBhIGJhY2tlbmQuXG4gKlxuICogQHBhcmFtIG5hbWUgLSB0aGUgbmFtZSBhcyBhIGtleSB0byBsb29rdXAgYXMgYW4gZXhlY3V0aW9uIHByb3ZpZGVyLlxuICogQHBhcmFtIGJhY2tlbmQgLSB0aGUgYmFja2VuZCBvYmplY3QuXG4gKiBAcGFyYW0gcHJpb3JpdHkgLSBhbiBpbnRlZ2VyIGluZGljYXRpbmcgdGhlIHByaW9yaXR5IG9mIHRoZSBiYWNrZW5kLiBIaWdoZXIgbnVtYmVyIG1lYW5zIGhpZ2hlciBwcmlvcml0eS4gaWYgcHJpb3JpdHlcbiAqIDwgMCwgaXQgd2lsbCBiZSBjb25zaWRlcmVkIGFzIGEgJ2JldGEnIHZlcnNpb24gYW5kIHdpbGwgbm90IGJlIHVzZWQgYXMgYSBmYWxsYmFjayBiYWNrZW5kIGJ5IGRlZmF1bHQuXG4gKlxuICogQGlnbm9yZVxuICovXG5leHBvcnQgY29uc3QgcmVnaXN0ZXJCYWNrZW5kID0gKG5hbWU6IHN0cmluZywgYmFja2VuZDogQmFja2VuZCwgcHJpb3JpdHk6IG51bWJlcik6IHZvaWQgPT4ge1xuICBpZiAoYmFja2VuZCAmJiB0eXBlb2YgYmFja2VuZC5pbml0ID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBiYWNrZW5kLmNyZWF0ZUluZmVyZW5jZVNlc3Npb25IYW5kbGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY29uc3QgY3VycmVudEJhY2tlbmQgPSBiYWNrZW5kcy5nZXQobmFtZSk7XG4gICAgaWYgKGN1cnJlbnRCYWNrZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGJhY2tlbmRzLnNldChuYW1lLCB7YmFja2VuZCwgcHJpb3JpdHl9KTtcbiAgICB9IGVsc2UgaWYgKGN1cnJlbnRCYWNrZW5kLnByaW9yaXR5ID4gcHJpb3JpdHkpIHtcbiAgICAgIC8vIHNhbWUgbmFtZSBpcyBhbHJlYWR5IHJlZ2lzdGVyZWQgd2l0aCBhIGhpZ2hlciBwcmlvcml0eS4gc2tpcCByZWdpc3RlcmF0aW9uLlxuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSBpZiAoY3VycmVudEJhY2tlbmQucHJpb3JpdHkgPT09IHByaW9yaXR5KSB7XG4gICAgICBpZiAoY3VycmVudEJhY2tlbmQuYmFja2VuZCAhPT0gYmFja2VuZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGNhbm5vdCByZWdpc3RlciBiYWNrZW5kIFwiJHtuYW1lfVwiIHVzaW5nIHByaW9yaXR5ICR7cHJpb3JpdHl9YCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHByaW9yaXR5ID49IDApIHtcbiAgICAgIGNvbnN0IGkgPSBiYWNrZW5kc1NvcnRlZEJ5UHJpb3JpdHkuaW5kZXhPZihuYW1lKTtcbiAgICAgIGlmIChpICE9PSAtMSkge1xuICAgICAgICBiYWNrZW5kc1NvcnRlZEJ5UHJpb3JpdHkuc3BsaWNlKGksIDEpO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJhY2tlbmRzU29ydGVkQnlQcmlvcml0eS5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoYmFja2VuZHMuZ2V0KGJhY2tlbmRzU29ydGVkQnlQcmlvcml0eVtpXSkhLnByaW9yaXR5IDw9IHByaW9yaXR5KSB7XG4gICAgICAgICAgYmFja2VuZHNTb3J0ZWRCeVByaW9yaXR5LnNwbGljZShpLCAwLCBuYW1lKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJhY2tlbmRzU29ydGVkQnlQcmlvcml0eS5wdXNoKG5hbWUpO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCdub3QgYSB2YWxpZCBiYWNrZW5kJyk7XG59O1xuXG4vKipcbiAqIFJlc29sdmUgYmFja2VuZCBieSBzcGVjaWZpZWQgaGludHMuXG4gKlxuICogQHBhcmFtIGJhY2tlbmRIaW50cyAtIGEgbGlzdCBvZiBleGVjdXRpb24gcHJvdmlkZXIgbmFtZXMgdG8gbG9va3VwLiBJZiBvbWl0dGVkIHVzZSByZWdpc3RlcmVkIGJhY2tlbmRzIGFzIGxpc3QuXG4gKiBAcmV0dXJucyBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgYmFja2VuZC5cbiAqXG4gKiBAaWdub3JlXG4gKi9cbmV4cG9ydCBjb25zdCByZXNvbHZlQmFja2VuZCA9IGFzeW5jKGJhY2tlbmRIaW50czogcmVhZG9ubHkgc3RyaW5nW10pOiBQcm9taXNlPEJhY2tlbmQ+ID0+IHtcbiAgY29uc3QgYmFja2VuZE5hbWVzID0gYmFja2VuZEhpbnRzLmxlbmd0aCA9PT0gMCA/IGJhY2tlbmRzU29ydGVkQnlQcmlvcml0eSA6IGJhY2tlbmRIaW50cztcbiAgY29uc3QgZXJyb3JzID0gW107XG4gIGZvciAoY29uc3QgYmFja2VuZE5hbWUgb2YgYmFja2VuZE5hbWVzKSB7XG4gICAgY29uc3QgYmFja2VuZEluZm8gPSBiYWNrZW5kcy5nZXQoYmFja2VuZE5hbWUpO1xuICAgIGlmIChiYWNrZW5kSW5mbykge1xuICAgICAgaWYgKGJhY2tlbmRJbmZvLmluaXRpYWxpemVkKSB7XG4gICAgICAgIHJldHVybiBiYWNrZW5kSW5mby5iYWNrZW5kO1xuICAgICAgfSBlbHNlIGlmIChiYWNrZW5kSW5mby5hYm9ydGVkKSB7XG4gICAgICAgIGNvbnRpbnVlOyAgLy8gY3VycmVudCBiYWNrZW5kIGlzIHVuYXZhaWxhYmxlOyB0cnkgbmV4dFxuICAgICAgfVxuXG4gICAgICBjb25zdCBpc0luaXRpYWxpemluZyA9ICEhYmFja2VuZEluZm8uaW5pdFByb21pc2U7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoIWlzSW5pdGlhbGl6aW5nKSB7XG4gICAgICAgICAgYmFja2VuZEluZm8uaW5pdFByb21pc2UgPSBiYWNrZW5kSW5mby5iYWNrZW5kLmluaXQoYmFja2VuZE5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IGJhY2tlbmRJbmZvLmluaXRQcm9taXNlO1xuICAgICAgICBiYWNrZW5kSW5mby5pbml0aWFsaXplZCA9IHRydWU7XG4gICAgICAgIHJldHVybiBiYWNrZW5kSW5mby5iYWNrZW5kO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoIWlzSW5pdGlhbGl6aW5nKSB7XG4gICAgICAgICAgZXJyb3JzLnB1c2goe25hbWU6IGJhY2tlbmROYW1lLCBlcnI6IGV9KTtcbiAgICAgICAgfVxuICAgICAgICBiYWNrZW5kSW5mby5hYm9ydGVkID0gdHJ1ZTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGRlbGV0ZSBiYWNrZW5kSW5mby5pbml0UHJvbWlzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB0aHJvdyBuZXcgRXJyb3IoYG5vIGF2YWlsYWJsZSBiYWNrZW5kIGZvdW5kLiBFUlI6ICR7ZXJyb3JzLm1hcChlID0+IGBbJHtlLm5hbWV9XSAke2UuZXJyfWApLmpvaW4oJywgJyl9YCk7XG59O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge0luZmVyZW5jZVNlc3Npb259IGZyb20gJy4vaW5mZXJlbmNlLXNlc3Npb24uanMnO1xuaW1wb3J0IHtPbm54VmFsdWV9IGZyb20gJy4vb25ueC12YWx1ZS5qcyc7XG5pbXBvcnQge1RyYWluaW5nU2Vzc2lvbn0gZnJvbSAnLi90cmFpbmluZy1zZXNzaW9uLmpzJztcblxuLyoqXG4gKiBAaWdub3JlXG4gKi9cbmV4cG9ydCBkZWNsYXJlIG5hbWVzcGFjZSBTZXNzaW9uSGFuZGxlciB7XG4gIHR5cGUgRmVlZHNUeXBlID0ge1tuYW1lOiBzdHJpbmddOiBPbm54VmFsdWV9O1xuICB0eXBlIEZldGNoZXNUeXBlID0ge1tuYW1lOiBzdHJpbmddOiBPbm54VmFsdWUgfCBudWxsfTtcbiAgdHlwZSBSZXR1cm5UeXBlID0ge1tuYW1lOiBzdHJpbmddOiBPbm54VmFsdWV9O1xufVxuXG4vKipcbiAqIFJlcHJlc2VudHMgc2hhcmVkIFNlc3Npb25IYW5kbGVyIGZ1bmN0aW9uYWxpdHlcbiAqXG4gKiBAaWdub3JlXG4gKi9cbmludGVyZmFjZSBTZXNzaW9uSGFuZGxlciB7XG4gIGRpc3Bvc2UoKTogUHJvbWlzZTx2b2lkPjtcblxuICByZWFkb25seSBpbnB1dE5hbWVzOiByZWFkb25seSBzdHJpbmdbXTtcbiAgcmVhZG9ubHkgb3V0cHV0TmFtZXM6IHJlYWRvbmx5IHN0cmluZ1tdO1xufVxuXG4vKipcbiAqIFJlcHJlc2VudCBhIGhhbmRsZXIgaW5zdGFuY2Ugb2YgYW4gaW5mZXJlbmNlIHNlc3Npb24uXG4gKlxuICogQGlnbm9yZVxuICovXG5leHBvcnQgaW50ZXJmYWNlIEluZmVyZW5jZVNlc3Npb25IYW5kbGVyIGV4dGVuZHMgU2Vzc2lvbkhhbmRsZXIge1xuICBzdGFydFByb2ZpbGluZygpOiB2b2lkO1xuICBlbmRQcm9maWxpbmcoKTogdm9pZDtcblxuICBydW4oZmVlZHM6IFNlc3Npb25IYW5kbGVyLkZlZWRzVHlwZSwgZmV0Y2hlczogU2Vzc2lvbkhhbmRsZXIuRmV0Y2hlc1R5cGUsXG4gICAgICBvcHRpb25zOiBJbmZlcmVuY2VTZXNzaW9uLlJ1bk9wdGlvbnMpOiBQcm9taXNlPFNlc3Npb25IYW5kbGVyLlJldHVyblR5cGU+O1xufVxuXG4vKipcbiAqIFJlcHJlc2VudCBhIGhhbmRsZXIgaW5zdGFuY2Ugb2YgYSB0cmFpbmluZyBpbmZlcmVuY2Ugc2Vzc2lvbi5cbiAqXG4gKiBAaWdub3JlXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgVHJhaW5pbmdTZXNzaW9uSGFuZGxlciBleHRlbmRzIFNlc3Npb25IYW5kbGVyIHtcbiAgcmVhZG9ubHkgZXZhbElucHV0TmFtZXM6IHJlYWRvbmx5IHN0cmluZ1tdO1xuICByZWFkb25seSBldmFsT3V0cHV0TmFtZXM6IHJlYWRvbmx5IHN0cmluZ1tdO1xuXG4gIGxhenlSZXNldEdyYWQoKTogUHJvbWlzZTx2b2lkPjtcbiAgcnVuVHJhaW5TdGVwKFxuICAgICAgZmVlZHM6IFNlc3Npb25IYW5kbGVyLkZlZWRzVHlwZSwgZmV0Y2hlczogU2Vzc2lvbkhhbmRsZXIuRmV0Y2hlc1R5cGUsXG4gICAgICBvcHRpb25zOiBJbmZlcmVuY2VTZXNzaW9uLlJ1bk9wdGlvbnMpOiBQcm9taXNlPFNlc3Npb25IYW5kbGVyLlJldHVyblR5cGU+O1xuICBydW5PcHRpbWl6ZXJTdGVwKG9wdGlvbnM6IEluZmVyZW5jZVNlc3Npb24uUnVuT3B0aW9ucyk6IFByb21pc2U8dm9pZD47XG4gIHJ1bkV2YWxTdGVwKFxuICAgICAgZmVlZHM6IFNlc3Npb25IYW5kbGVyLkZlZWRzVHlwZSwgZmV0Y2hlczogU2Vzc2lvbkhhbmRsZXIuRmV0Y2hlc1R5cGUsXG4gICAgICBvcHRpb25zOiBJbmZlcmVuY2VTZXNzaW9uLlJ1bk9wdGlvbnMpOiBQcm9taXNlPFNlc3Npb25IYW5kbGVyLlJldHVyblR5cGU+O1xuXG4gIGdldFBhcmFtZXRlcnNTaXplKHRyYWluYWJsZU9ubHk6IGJvb2xlYW4pOiBQcm9taXNlPG51bWJlcj47XG4gIGxvYWRQYXJhbWV0ZXJzQnVmZmVyKGFycmF5OiBVaW50OEFycmF5LCB0cmFpbmFibGVPbmx5OiBib29sZWFuKTogUHJvbWlzZTx2b2lkPjtcbiAgZ2V0Q29udGlndW91c1BhcmFtZXRlcnModHJhaW5hYmxlT25seTogYm9vbGVhbik6IFByb21pc2U8T25ueFZhbHVlPjtcbn1cblxuLyoqXG4gKiBSZXByZXNlbnQgYSBiYWNrZW5kIHRoYXQgcHJvdmlkZXMgaW1wbGVtZW50YXRpb24gb2YgbW9kZWwgaW5mZXJlbmNpbmcuXG4gKlxuICogQGlnbm9yZVxuICovXG5leHBvcnQgaW50ZXJmYWNlIEJhY2tlbmQge1xuICAvKipcbiAgICogSW5pdGlhbGl6ZSB0aGUgYmFja2VuZCBhc3luY2hyb25vdXNseS4gU2hvdWxkIHRocm93IHdoZW4gZmFpbGVkLlxuICAgKi9cbiAgaW5pdChiYWNrZW5kTmFtZTogc3RyaW5nKTogUHJvbWlzZTx2b2lkPjtcblxuICBjcmVhdGVJbmZlcmVuY2VTZXNzaW9uSGFuZGxlcih1cmlPckJ1ZmZlcjogc3RyaW5nfFVpbnQ4QXJyYXksIG9wdGlvbnM/OiBJbmZlcmVuY2VTZXNzaW9uLlNlc3Npb25PcHRpb25zKTpcbiAgICAgIFByb21pc2U8SW5mZXJlbmNlU2Vzc2lvbkhhbmRsZXI+O1xuXG4gIGNyZWF0ZVRyYWluaW5nU2Vzc2lvbkhhbmRsZXI/XG4gICAgICAoY2hlY2twb2ludFN0YXRlVXJpT3JCdWZmZXI6IFRyYWluaW5nU2Vzc2lvbi5VUklvckJ1ZmZlciwgdHJhaW5Nb2RlbFVyaU9yQnVmZmVyOiBUcmFpbmluZ1Nlc3Npb24uVVJJb3JCdWZmZXIsXG4gICAgICAgZXZhbE1vZGVsVXJpT3JCdWZmZXI6IFRyYWluaW5nU2Vzc2lvbi5VUklvckJ1ZmZlciwgb3B0aW1pemVyTW9kZWxVcmlPckJ1ZmZlcjogVHJhaW5pbmdTZXNzaW9uLlVSSW9yQnVmZmVyLFxuICAgICAgIG9wdGlvbnM6IEluZmVyZW5jZVNlc3Npb24uU2Vzc2lvbk9wdGlvbnMpOiBQcm9taXNlPFRyYWluaW5nU2Vzc2lvbkhhbmRsZXI+O1xufVxuXG5leHBvcnQge3JlZ2lzdGVyQmFja2VuZH0gZnJvbSAnLi9iYWNrZW5kLWltcGwuanMnO1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG4vLyBUaGlzIGZpbGUgaXMgZ2VuZXJhdGVkIGJ5IC9qcy9zY3JpcHRzL3VwZGF0ZS12ZXJzaW9uLnRzXG4vLyBEbyBub3QgbW9kaWZ5IGZpbGUgY29udGVudCBtYW51YWxseS5cblxuZXhwb3J0IGNvbnN0IHZlcnNpb24gPSAnMS4xNy4xJztcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtFbnZ9IGZyb20gJy4vZW52LmpzJztcbmltcG9ydCB7dmVyc2lvbn0gZnJvbSAnLi92ZXJzaW9uLmpzJztcblxudHlwZSBMb2dMZXZlbFR5cGUgPSBFbnZbJ2xvZ0xldmVsJ107XG5cbmxldCBsb2dMZXZlbFZhbHVlOiBSZXF1aXJlZDxMb2dMZXZlbFR5cGU+ID0gJ3dhcm5pbmcnO1xuXG5leHBvcnQgY29uc3QgZW52OiBFbnYgPSB7XG4gIHdhc206IHt9IGFzIEVudi5XZWJBc3NlbWJseUZsYWdzLFxuICB3ZWJnbDoge30gYXMgRW52LldlYkdMRmxhZ3MsXG4gIHdlYmdwdToge30gYXMgRW52LldlYkdwdUZsYWdzLFxuICB2ZXJzaW9uczoge2NvbW1vbjogdmVyc2lvbn0sXG5cbiAgc2V0IGxvZ0xldmVsKHZhbHVlOiBMb2dMZXZlbFR5cGUpIHtcbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJyB8fCBbJ3ZlcmJvc2UnLCAnaW5mbycsICd3YXJuaW5nJywgJ2Vycm9yJywgJ2ZhdGFsJ10uaW5kZXhPZih2YWx1ZSkgPT09IC0xKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGxvZ2dpbmcgbGV2ZWw6ICR7dmFsdWV9YCk7XG4gICAgfVxuICAgIGxvZ0xldmVsVmFsdWUgPSB2YWx1ZTtcbiAgfSxcbiAgZ2V0IGxvZ0xldmVsKCk6IFJlcXVpcmVkPExvZ0xldmVsVHlwZT4ge1xuICAgIHJldHVybiBsb2dMZXZlbFZhbHVlO1xuICB9LFxufTtcblxuLy8gc2V0IHByb3BlcnR5ICdsb2dMZXZlbCcgc28gdGhhdCB0aGV5IGNhbiBiZSBjb3JyZWN0bHkgdHJhbnNmZXJyZWQgdG8gd29ya2VyIGJ5IGBwb3N0TWVzc2FnZSgpYC5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbnYsICdsb2dMZXZlbCcsIHtlbnVtZXJhYmxlOiB0cnVlfSk7XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7ZW52IGFzIGVudkltcGx9IGZyb20gJy4vZW52LWltcGwuanMnO1xuXG5leHBvcnQgZGVjbGFyZSBuYW1lc3BhY2UgRW52IHtcbiAgZXhwb3J0IHR5cGUgV2FzbVByZWZpeE9yRmlsZVBhdGhzID0gc3RyaW5nfHtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb24gKi9cbiAgICAnb3J0LXdhc20ud2FzbSc/OiBzdHJpbmc7XG4gICAgJ29ydC13YXNtLXRocmVhZGVkLndhc20nPzogc3RyaW5nO1xuICAgICdvcnQtd2FzbS1zaW1kLndhc20nPzogc3RyaW5nO1xuICAgICdvcnQtdHJhaW5pbmctd2FzbS1zaW1kLndhc20nPzogc3RyaW5nO1xuICAgICdvcnQtd2FzbS1zaW1kLXRocmVhZGVkLndhc20nPzogc3RyaW5nO1xuICAgIC8qIGVzbGludC1lbmFibGUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uICovXG4gIH07XG4gIGV4cG9ydCBpbnRlcmZhY2UgV2ViQXNzZW1ibHlGbGFncyB7XG4gICAgLyoqXG4gICAgICogc2V0IG9yIGdldCBudW1iZXIgb2YgdGhyZWFkKHMpLiBJZiBvbWl0dGVkIG9yIHNldCB0byAwLCBudW1iZXIgb2YgdGhyZWFkKHMpIHdpbGwgYmUgZGV0ZXJtaW5lZCBieSBzeXN0ZW0uIElmIHNldFxuICAgICAqIHRvIDEsIG5vIHdvcmtlciB0aHJlYWQgd2lsbCBiZSBzcGF3bmVkLlxuICAgICAqXG4gICAgICogVGhpcyBzZXR0aW5nIGlzIGF2YWlsYWJsZSBvbmx5IHdoZW4gV2ViQXNzZW1ibHkgbXVsdGl0aHJlYWQgZmVhdHVyZSBpcyBhdmFpbGFibGUgaW4gY3VycmVudCBjb250ZXh0LlxuICAgICAqXG4gICAgICogQGRlZmF1bHRWYWx1ZSBgMGBcbiAgICAgKi9cbiAgICBudW1UaHJlYWRzPzogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogc2V0IG9yIGdldCBhIGJvb2xlYW4gdmFsdWUgaW5kaWNhdGluZyB3aGV0aGVyIHRvIGVuYWJsZSBTSU1ELiBJZiBzZXQgdG8gZmFsc2UsIFNJTUQgd2lsbCBiZSBmb3JjZWx5IGRpc2FibGVkLlxuICAgICAqXG4gICAgICogVGhpcyBzZXR0aW5nIGlzIGF2YWlsYWJsZSBvbmx5IHdoZW4gV2ViQXNzZW1ibHkgU0lNRCBmZWF0dXJlIGlzIGF2YWlsYWJsZSBpbiBjdXJyZW50IGNvbnRleHQuXG4gICAgICpcbiAgICAgKiBAZGVmYXVsdFZhbHVlIGB0cnVlYFxuICAgICAqL1xuICAgIHNpbWQ/OiBib29sZWFuO1xuXG4gICAgLyoqXG4gICAgICogc2V0IG9yIGdldCBhIGJvb2xlYW4gdmFsdWUgaW5kaWNhdGluZyB3aGV0aGVyIHRvIGVuYWJsZSB0cmFjZS5cbiAgICAgKlxuICAgICAqIEBkZWZhdWx0VmFsdWUgYGZhbHNlYFxuICAgICAqL1xuICAgIHRyYWNlPzogYm9vbGVhbjtcblxuICAgIC8qKlxuICAgICAqIFNldCBvciBnZXQgYSBudW1iZXIgc3BlY2lmeWluZyB0aGUgdGltZW91dCBmb3IgaW5pdGlhbGl6YXRpb24gb2YgV2ViQXNzZW1ibHkgYmFja2VuZCwgaW4gbWlsbGlzZWNvbmRzLiBBIHplcm9cbiAgICAgKiB2YWx1ZSBpbmRpY2F0ZXMgbm8gdGltZW91dCBpcyBzZXQuXG4gICAgICpcbiAgICAgKiBAZGVmYXVsdFZhbHVlIGAwYFxuICAgICAqL1xuICAgIGluaXRUaW1lb3V0PzogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogU2V0IGEgY3VzdG9tIFVSTCBwcmVmaXggdG8gdGhlIC53YXNtIGZpbGVzIG9yIGEgc2V0IG9mIG92ZXJyaWRlcyBmb3IgZWFjaCAud2FzbSBmaWxlLiBUaGUgb3ZlcnJpZGUgcGF0aCBzaG91bGQgYmVcbiAgICAgKiBhbiBhYnNvbHV0ZSBwYXRoLlxuICAgICAqL1xuICAgIHdhc21QYXRocz86IFdhc21QcmVmaXhPckZpbGVQYXRocztcblxuICAgIC8qKlxuICAgICAqIFNldCBvciBnZXQgYSBib29sZWFuIHZhbHVlIGluZGljYXRpbmcgd2hldGhlciB0byBwcm94eSB0aGUgZXhlY3V0aW9uIG9mIG1haW4gdGhyZWFkIHRvIGEgd29ya2VyIHRocmVhZC5cbiAgICAgKlxuICAgICAqIEBkZWZhdWx0VmFsdWUgYGZhbHNlYFxuICAgICAqL1xuICAgIHByb3h5PzogYm9vbGVhbjtcbiAgfVxuXG4gIGV4cG9ydCBpbnRlcmZhY2UgV2ViR0xGbGFncyB7XG4gICAgLyoqXG4gICAgICogU2V0IG9yIGdldCB0aGUgV2ViR0wgQ29udGV4dCBJRCAod2ViZ2wgb3Igd2ViZ2wyKS5cbiAgICAgKlxuICAgICAqIEBkZWZhdWx0VmFsdWUgYCd3ZWJnbDInYFxuICAgICAqL1xuICAgIGNvbnRleHRJZD86ICd3ZWJnbCd8J3dlYmdsMic7XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBXZWJHTCByZW5kZXJpbmcgY29udGV4dC5cbiAgICAgKi9cbiAgICByZWFkb25seSBjb250ZXh0OiBXZWJHTFJlbmRlcmluZ0NvbnRleHQ7XG4gICAgLyoqXG4gICAgICogU2V0IG9yIGdldCB0aGUgbWF4aW11bSBiYXRjaCBzaXplIGZvciBtYXRtdWwuIDAgbWVhbnMgdG8gZGlzYWJsZSBiYXRjaGluZy5cbiAgICAgKlxuICAgICAqIEBkZXByZWNhdGVkXG4gICAgICovXG4gICAgbWF0bXVsTWF4QmF0Y2hTaXplPzogbnVtYmVyO1xuICAgIC8qKlxuICAgICAqIFNldCBvciBnZXQgdGhlIHRleHR1cmUgY2FjaGUgbW9kZS5cbiAgICAgKlxuICAgICAqIEBkZWZhdWx0VmFsdWUgYCdmdWxsJ2BcbiAgICAgKi9cbiAgICB0ZXh0dXJlQ2FjaGVNb2RlPzogJ2luaXRpYWxpemVyT25seSd8J2Z1bGwnO1xuICAgIC8qKlxuICAgICAqIFNldCBvciBnZXQgdGhlIHBhY2tlZCB0ZXh0dXJlIG1vZGVcbiAgICAgKlxuICAgICAqIEBkZWZhdWx0VmFsdWUgYGZhbHNlYFxuICAgICAqL1xuICAgIHBhY2s/OiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIFNldCBvciBnZXQgd2hldGhlciBlbmFibGUgYXN5bmMgZG93bmxvYWQuXG4gICAgICpcbiAgICAgKiBAZGVmYXVsdFZhbHVlIGBmYWxzZWBcbiAgICAgKi9cbiAgICBhc3luYz86IGJvb2xlYW47XG4gIH1cblxuICBleHBvcnQgaW50ZXJmYWNlIFdlYkdwdVByb2ZpbGluZ0RhdGFWMVRlbnNvck1ldGFkYXRhIHtcbiAgICBkaW1zOiByZWFkb25seSBudW1iZXJbXTtcbiAgICBkYXRhVHlwZTogc3RyaW5nO1xuICB9XG4gIGV4cG9ydCBpbnRlcmZhY2UgV2ViR3B1UHJvZmlsaW5nRGF0YVYxIHtcbiAgICB2ZXJzaW9uOiAxO1xuICAgIGlucHV0c01ldGFkYXRhOiByZWFkb25seSBXZWJHcHVQcm9maWxpbmdEYXRhVjFUZW5zb3JNZXRhZGF0YVtdO1xuICAgIG91dHB1dHNNZXRhZGF0YTogcmVhZG9ubHkgV2ViR3B1UHJvZmlsaW5nRGF0YVYxVGVuc29yTWV0YWRhdGFbXTtcbiAgICBrZXJuZWxJZDogbnVtYmVyO1xuICAgIGtlcm5lbFR5cGU6IHN0cmluZztcbiAgICBrZXJuZWxOYW1lOiBzdHJpbmc7XG4gICAgcHJvZ3JhbU5hbWU6IHN0cmluZztcbiAgICBzdGFydFRpbWU6IG51bWJlcjtcbiAgICBlbmRUaW1lOiBudW1iZXI7XG4gIH1cblxuICBleHBvcnQgdHlwZSBXZWJHcHVQcm9maWxpbmdEYXRhID0gV2ViR3B1UHJvZmlsaW5nRGF0YVYxO1xuXG4gIGV4cG9ydCBpbnRlcmZhY2UgV2ViR3B1RmxhZ3Mge1xuICAgIC8qKlxuICAgICAqIFNldCBvciBnZXQgdGhlIHByb2ZpbGluZyBtb2RlLlxuICAgICAqXG4gICAgICogQGRlcHJlY2F0ZWQgVXNlIGBlbnYud2ViZ3B1LnByb2ZpbGluZy5tb2RlYCBpbnN0ZWFkLiBJZiBgZW52LndlYmdwdS5wcm9maWxpbmcubW9kZWAgaXMgc2V0LCB0aGlzIHByb3BlcnR5IHdpbGwgYmVcbiAgICAgKiBpZ25vcmVkLlxuICAgICAqL1xuICAgIHByb2ZpbGluZ01vZGU/OiAnb2ZmJ3wnZGVmYXVsdCc7XG4gICAgLyoqXG4gICAgICogU2V0IG9yIGdldCB0aGUgcHJvZmlsaW5nIGNvbmZpZ3VyYXRpb24uXG4gICAgICovXG4gICAgcHJvZmlsaW5nPzoge1xuICAgICAgLyoqXG4gICAgICAgKiBTZXQgb3IgZ2V0IHRoZSBwcm9maWxpbmcgbW9kZS5cbiAgICAgICAqXG4gICAgICAgKiBAZGVmYXVsdFZhbHVlIGAnb2ZmJ2BcbiAgICAgICAqL1xuICAgICAgbW9kZT86ICdvZmYnfCdkZWZhdWx0JztcblxuICAgICAgLyoqXG4gICAgICAgKiBTZXQgb3IgZ2V0IGEgY2FsbGJhY2sgZnVuY3Rpb24gd2hlbiBhIHByb2ZpbGluZyBkYXRhIGlzIHJlY2VpdmVkLiBJZiBub3Qgc2V0LCB0aGUgcHJvZmlsaW5nIGRhdGEgd2lsbCBiZVxuICAgICAgICogcHJpbnRlZCB0byBjb25zb2xlLlxuICAgICAgICovXG4gICAgICBvbmRhdGE/OiAoZGF0YTogV2ViR3B1UHJvZmlsaW5nRGF0YSkgPT4gdm9pZDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldCB0aGUgZGV2aWNlIGZvciBXZWJHUFUuXG4gICAgICpcbiAgICAgKiBXaGVuIHVzZSB3aXRoIFR5cGVTY3JpcHQsIHRoZSB0eXBlIG9mIHRoaXMgcHJvcGVydHkgaXMgYEdQVURldmljZWAgZGVmaW5lZCBpbiBcIkB3ZWJncHUvdHlwZXNcIi5cbiAgICAgKiBVc2UgYGNvbnN0IGRldmljZSA9IGVudi53ZWJncHUuZGV2aWNlIGFzIEdQVURldmljZTtgIGluIFR5cGVTY3JpcHQgdG8gYWNjZXNzIHRoaXMgcHJvcGVydHkgd2l0aCBjb3JyZWN0IHR5cGUuXG4gICAgICpcbiAgICAgKiBzZWUgY29tbWVudHMgb24ge0BsaW5rIEdwdUJ1ZmZlclR5cGV9IGZvciBtb3JlIGRldGFpbHMgYWJvdXQgd2h5IG5vdCB1c2UgdHlwZXMgZGVmaW5lZCBpbiBcIkB3ZWJncHUvdHlwZXNcIi5cbiAgICAgKi9cbiAgICByZWFkb25seSBkZXZpY2U6IHVua25vd247XG4gICAgLyoqXG4gICAgICogU2V0IG9yIGdldCB3aGV0aGVyIHZhbGlkYXRlIGlucHV0IGNvbnRlbnQuXG4gICAgICpcbiAgICAgKiBAZGVmYXVsdFZhbHVlIGBmYWxzZWBcbiAgICAgKi9cbiAgICB2YWxpZGF0ZUlucHV0Q29udGVudD86IGJvb2xlYW47XG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBFbnYge1xuICAvKipcbiAgICogc2V0IHRoZSBzZXZlcml0eSBsZXZlbCBmb3IgbG9nZ2luZy5cbiAgICpcbiAgICogQGRlZmF1bHRWYWx1ZSBgJ3dhcm5pbmcnYFxuICAgKi9cbiAgbG9nTGV2ZWw/OiAndmVyYm9zZSd8J2luZm8nfCd3YXJuaW5nJ3wnZXJyb3InfCdmYXRhbCc7XG4gIC8qKlxuICAgKiBJbmRpY2F0ZSB3aGV0aGVyIHJ1biBpbiBkZWJ1ZyBtb2RlLlxuICAgKlxuICAgKiBAZGVmYXVsdFZhbHVlIGBmYWxzZWBcbiAgICovXG4gIGRlYnVnPzogYm9vbGVhbjtcblxuICAvKipcbiAgICogR2V0IHZlcnNpb24gb2YgdGhlIGN1cnJlbnQgcGFja2FnZS5cbiAgICovXG4gIHJlYWRvbmx5IHZlcnNpb25zOiB7XG4gICAgcmVhZG9ubHkgY29tbW9uOiBzdHJpbmc7XG4gICAgcmVhZG9ubHkgd2ViPzogc3RyaW5nO1xuICAgIHJlYWRvbmx5IG5vZGU/OiBzdHJpbmc7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvblxuICAgIHJlYWRvbmx5ICdyZWFjdC1uYXRpdmUnPzogc3RyaW5nO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXByZXNlbnQgYSBzZXQgb2YgZmxhZ3MgZm9yIFdlYkFzc2VtYmx5XG4gICAqL1xuICByZWFkb25seSB3YXNtOiBFbnYuV2ViQXNzZW1ibHlGbGFncztcblxuICAvKipcbiAgICogUmVwcmVzZW50IGEgc2V0IG9mIGZsYWdzIGZvciBXZWJHTFxuICAgKi9cbiAgcmVhZG9ubHkgd2ViZ2w6IEVudi5XZWJHTEZsYWdzO1xuXG4gIC8qKlxuICAgKiBSZXByZXNlbnQgYSBzZXQgb2YgZmxhZ3MgZm9yIFdlYkdQVVxuICAgKi9cbiAgcmVhZG9ubHkgd2ViZ3B1OiBFbnYuV2ViR3B1RmxhZ3M7XG5cbiAgW25hbWU6IHN0cmluZ106IHVua25vd247XG59XG5cbi8qKlxuICogUmVwcmVzZW50IGEgc2V0IG9mIGZsYWdzIGFzIGEgZ2xvYmFsIHNpbmdsZXRvbi5cbiAqL1xuZXhwb3J0IGNvbnN0IGVudjogRW52ID0gZW52SW1wbDtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtUZW5zb3JUb0RhdGFVcmxPcHRpb25zLCBUZW5zb3JUb0ltYWdlRGF0YU9wdGlvbnN9IGZyb20gJy4vdGVuc29yLWNvbnZlcnNpb24uanMnO1xuaW1wb3J0IHtUZW5zb3J9IGZyb20gJy4vdGVuc29yLmpzJztcblxuLyoqXG4gKiBpbXBsZW1lbnRhdGlvbiBvZiBUZW5zb3IudG9EYXRhVVJMKClcbiAqL1xuZXhwb3J0IGNvbnN0IHRlbnNvclRvRGF0YVVSTCA9ICh0ZW5zb3I6IFRlbnNvciwgb3B0aW9ucz86IFRlbnNvclRvRGF0YVVybE9wdGlvbnMpOiBzdHJpbmcgPT4ge1xuICBjb25zdCBjYW52YXMgPSB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnID8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJykgOiAobmV3IE9mZnNjcmVlbkNhbnZhcygxLCAxKSk7XG4gIGNhbnZhcy53aWR0aCA9IHRlbnNvci5kaW1zWzNdO1xuICBjYW52YXMuaGVpZ2h0ID0gdGVuc29yLmRpbXNbMl07XG4gIGNvbnN0IHBpeGVsczJEQ29udGV4dCA9XG4gICAgICBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKSBhcyAoQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEIHwgT2Zmc2NyZWVuQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEIHwgbnVsbCk7XG5cbiAgaWYgKHBpeGVsczJEQ29udGV4dCAhPSBudWxsKSB7XG4gICAgLy8gRGVmYXVsdCB2YWx1ZXMgZm9yIGhlaWdodCBhbmQgd2lkdGggJiBmb3JtYXRcbiAgICBsZXQgd2lkdGg6IG51bWJlcjtcbiAgICBsZXQgaGVpZ2h0OiBudW1iZXI7XG4gICAgaWYgKG9wdGlvbnM/LnRlbnNvckxheW91dCAhPT0gdW5kZWZpbmVkICYmIG9wdGlvbnMudGVuc29yTGF5b3V0ID09PSAnTkhXQycpIHtcbiAgICAgIHdpZHRoID0gdGVuc29yLmRpbXNbMl07XG4gICAgICBoZWlnaHQgPSB0ZW5zb3IuZGltc1szXTtcbiAgICB9IGVsc2UgeyAgLy8gRGVmYXVsdCBsYXlvdXQgaXMgTkNXSFxuICAgICAgd2lkdGggPSB0ZW5zb3IuZGltc1szXTtcbiAgICAgIGhlaWdodCA9IHRlbnNvci5kaW1zWzJdO1xuICAgIH1cblxuICAgIGNvbnN0IGlucHV0Zm9ybWF0ID0gb3B0aW9ucz8uZm9ybWF0ICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmZvcm1hdCA6ICdSR0InO1xuXG4gICAgY29uc3Qgbm9ybSA9IG9wdGlvbnM/Lm5vcm07XG4gICAgbGV0IG5vcm1NZWFuOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyXTtcbiAgICBsZXQgbm9ybUJpYXM6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXJdO1xuICAgIGlmIChub3JtID09PSB1bmRlZmluZWQgfHwgbm9ybS5tZWFuID09PSB1bmRlZmluZWQpIHtcbiAgICAgIG5vcm1NZWFuID0gWzI1NSwgMjU1LCAyNTUsIDI1NV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0eXBlb2YgKG5vcm0ubWVhbikgPT09ICdudW1iZXInKSB7XG4gICAgICAgIG5vcm1NZWFuID0gW25vcm0ubWVhbiwgbm9ybS5tZWFuLCBub3JtLm1lYW4sIG5vcm0ubWVhbl07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub3JtTWVhbiA9IFtub3JtLm1lYW5bMF0sIG5vcm0ubWVhblsxXSwgbm9ybS5tZWFuWzJdLCAwXTtcbiAgICAgICAgaWYgKG5vcm0ubWVhblszXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgbm9ybU1lYW5bM10gPSBub3JtLm1lYW5bM107XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG5vcm0gPT09IHVuZGVmaW5lZCB8fCBub3JtLmJpYXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgbm9ybUJpYXMgPSBbMCwgMCwgMCwgMF07XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0eXBlb2YgKG5vcm0uYmlhcykgPT09ICdudW1iZXInKSB7XG4gICAgICAgIG5vcm1CaWFzID0gW25vcm0uYmlhcywgbm9ybS5iaWFzLCBub3JtLmJpYXMsIG5vcm0uYmlhc107XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub3JtQmlhcyA9IFtub3JtLmJpYXNbMF0sIG5vcm0uYmlhc1sxXSwgbm9ybS5iaWFzWzJdLCAwXTtcbiAgICAgICAgaWYgKG5vcm0uYmlhc1szXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgbm9ybUJpYXNbM10gPSBub3JtLmJpYXNbM107XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBzdHJpZGUgPSBoZWlnaHQgKiB3aWR0aDtcbiAgICAvLyBEZWZhdWx0IHBvaW50ZXIgYXNzaWdubWVudHNcbiAgICBsZXQgclRlbnNvclBvaW50ZXIgPSAwLCBnVGVuc29yUG9pbnRlciA9IHN0cmlkZSwgYlRlbnNvclBvaW50ZXIgPSBzdHJpZGUgKiAyLCBhVGVuc29yUG9pbnRlciA9IC0xO1xuXG4gICAgLy8gVXBkYXRpbmcgdGhlIHBvaW50ZXIgYXNzaWdubWVudHMgYmFzZWQgb24gdGhlIGlucHV0IGltYWdlIGZvcm1hdFxuICAgIGlmIChpbnB1dGZvcm1hdCA9PT0gJ1JHQkEnKSB7XG4gICAgICByVGVuc29yUG9pbnRlciA9IDA7XG4gICAgICBnVGVuc29yUG9pbnRlciA9IHN0cmlkZTtcbiAgICAgIGJUZW5zb3JQb2ludGVyID0gc3RyaWRlICogMjtcbiAgICAgIGFUZW5zb3JQb2ludGVyID0gc3RyaWRlICogMztcbiAgICB9IGVsc2UgaWYgKGlucHV0Zm9ybWF0ID09PSAnUkdCJykge1xuICAgICAgclRlbnNvclBvaW50ZXIgPSAwO1xuICAgICAgZ1RlbnNvclBvaW50ZXIgPSBzdHJpZGU7XG4gICAgICBiVGVuc29yUG9pbnRlciA9IHN0cmlkZSAqIDI7XG4gICAgfSBlbHNlIGlmIChpbnB1dGZvcm1hdCA9PT0gJ1JCRycpIHtcbiAgICAgIHJUZW5zb3JQb2ludGVyID0gMDtcbiAgICAgIGJUZW5zb3JQb2ludGVyID0gc3RyaWRlO1xuICAgICAgZ1RlbnNvclBvaW50ZXIgPSBzdHJpZGUgKiAyO1xuICAgIH1cblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaGVpZ2h0OyBpKyspIHtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgd2lkdGg7IGorKykge1xuICAgICAgICBjb25zdCBSID0gKCh0ZW5zb3IuZGF0YVtyVGVuc29yUG9pbnRlcisrXSBhcyBudW1iZXIpIC0gbm9ybUJpYXNbMF0pICogbm9ybU1lYW5bMF07ICAvLyBSIHZhbHVlXG4gICAgICAgIGNvbnN0IEcgPSAoKHRlbnNvci5kYXRhW2dUZW5zb3JQb2ludGVyKytdIGFzIG51bWJlcikgLSBub3JtQmlhc1sxXSkgKiBub3JtTWVhblsxXTsgIC8vIEcgdmFsdWVcbiAgICAgICAgY29uc3QgQiA9ICgodGVuc29yLmRhdGFbYlRlbnNvclBvaW50ZXIrK10gYXMgbnVtYmVyKSAtIG5vcm1CaWFzWzJdKSAqIG5vcm1NZWFuWzJdOyAgLy8gQiB2YWx1ZVxuICAgICAgICBjb25zdCBBID0gYVRlbnNvclBvaW50ZXIgPT09IC0xID9cbiAgICAgICAgICAgIDI1NSA6XG4gICAgICAgICAgICAoKHRlbnNvci5kYXRhW2FUZW5zb3JQb2ludGVyKytdIGFzIG51bWJlcikgLSBub3JtQmlhc1szXSkgKiBub3JtTWVhblszXTsgIC8vIEEgdmFsdWVcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9yZXN0cmljdC1wbHVzLW9wZXJhbmRzXG4gICAgICAgIHBpeGVsczJEQ29udGV4dC5maWxsU3R5bGUgPSAncmdiYSgnICsgUiArICcsJyArIEcgKyAnLCcgKyBCICsgJywnICsgQSArICcpJztcbiAgICAgICAgcGl4ZWxzMkRDb250ZXh0LmZpbGxSZWN0KGosIGksIDEsIDEpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoJ3RvRGF0YVVSTCcgaW4gY2FudmFzKSB7XG4gICAgICByZXR1cm4gY2FudmFzLnRvRGF0YVVSTCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3RvRGF0YVVSTCBpcyBub3Qgc3VwcG9ydGVkJyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignQ2FuIG5vdCBhY2Nlc3MgaW1hZ2UgZGF0YScpO1xuICB9XG59O1xuXG4vKipcbiAqIGltcGxlbWVudGF0aW9uIG9mIFRlbnNvci50b0ltYWdlRGF0YSgpXG4gKi9cbmV4cG9ydCBjb25zdCB0ZW5zb3JUb0ltYWdlRGF0YSA9ICh0ZW5zb3I6IFRlbnNvciwgb3B0aW9ucz86IFRlbnNvclRvSW1hZ2VEYXRhT3B0aW9ucyk6IEltYWdlRGF0YSA9PiB7XG4gIGNvbnN0IHBpeGVsczJEQ29udGV4dCA9IHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgP1xuICAgICAgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJykuZ2V0Q29udGV4dCgnMmQnKSA6XG4gICAgICBuZXcgT2Zmc2NyZWVuQ2FudmFzKDEsIDEpLmdldENvbnRleHQoJzJkJykgYXMgT2Zmc2NyZWVuQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEO1xuICBsZXQgaW1hZ2U6IEltYWdlRGF0YTtcbiAgaWYgKHBpeGVsczJEQ29udGV4dCAhPSBudWxsKSB7XG4gICAgLy8gRGVmYXVsdCB2YWx1ZXMgZm9yIGhlaWdodCBhbmQgd2lkdGggJiBmb3JtYXRcbiAgICBsZXQgd2lkdGg6IG51bWJlcjtcbiAgICBsZXQgaGVpZ2h0OiBudW1iZXI7XG4gICAgbGV0IGNoYW5uZWxzOiBudW1iZXI7XG4gICAgaWYgKG9wdGlvbnM/LnRlbnNvckxheW91dCAhPT0gdW5kZWZpbmVkICYmIG9wdGlvbnMudGVuc29yTGF5b3V0ID09PSAnTkhXQycpIHtcbiAgICAgIHdpZHRoID0gdGVuc29yLmRpbXNbMl07XG4gICAgICBoZWlnaHQgPSB0ZW5zb3IuZGltc1sxXTtcbiAgICAgIGNoYW5uZWxzID0gdGVuc29yLmRpbXNbM107XG4gICAgfSBlbHNlIHsgIC8vIERlZmF1bHQgbGF5b3V0IGlzIE5DV0hcbiAgICAgIHdpZHRoID0gdGVuc29yLmRpbXNbM107XG4gICAgICBoZWlnaHQgPSB0ZW5zb3IuZGltc1syXTtcbiAgICAgIGNoYW5uZWxzID0gdGVuc29yLmRpbXNbMV07XG4gICAgfVxuICAgIGNvbnN0IGlucHV0Zm9ybWF0ID0gb3B0aW9ucyAhPT0gdW5kZWZpbmVkID8gKG9wdGlvbnMuZm9ybWF0ICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmZvcm1hdCA6ICdSR0InKSA6ICdSR0InO1xuXG4gICAgY29uc3Qgbm9ybSA9IG9wdGlvbnM/Lm5vcm07XG4gICAgbGV0IG5vcm1NZWFuOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyXTtcbiAgICBsZXQgbm9ybUJpYXM6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXJdO1xuICAgIGlmIChub3JtID09PSB1bmRlZmluZWQgfHwgbm9ybS5tZWFuID09PSB1bmRlZmluZWQpIHtcbiAgICAgIG5vcm1NZWFuID0gWzI1NSwgMjU1LCAyNTUsIDI1NV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0eXBlb2YgKG5vcm0ubWVhbikgPT09ICdudW1iZXInKSB7XG4gICAgICAgIG5vcm1NZWFuID0gW25vcm0ubWVhbiwgbm9ybS5tZWFuLCBub3JtLm1lYW4sIG5vcm0ubWVhbl07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub3JtTWVhbiA9IFtub3JtLm1lYW5bMF0sIG5vcm0ubWVhblsxXSwgbm9ybS5tZWFuWzJdLCAyNTVdO1xuICAgICAgICBpZiAobm9ybS5tZWFuWzNdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBub3JtTWVhblszXSA9IG5vcm0ubWVhblszXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAobm9ybSA9PT0gdW5kZWZpbmVkIHx8IG5vcm0uYmlhcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBub3JtQmlhcyA9IFswLCAwLCAwLCAwXTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHR5cGVvZiAobm9ybS5iaWFzKSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgbm9ybUJpYXMgPSBbbm9ybS5iaWFzLCBub3JtLmJpYXMsIG5vcm0uYmlhcywgbm9ybS5iaWFzXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vcm1CaWFzID0gW25vcm0uYmlhc1swXSwgbm9ybS5iaWFzWzFdLCBub3JtLmJpYXNbMl0sIDBdO1xuICAgICAgICBpZiAobm9ybS5iaWFzWzNdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBub3JtQmlhc1szXSA9IG5vcm0uYmlhc1szXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHN0cmlkZSA9IGhlaWdodCAqIHdpZHRoO1xuICAgIGlmIChvcHRpb25zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChvcHRpb25zLmZvcm1hdCAhPT0gdW5kZWZpbmVkICYmIChjaGFubmVscyA9PT0gNCAmJiBvcHRpb25zLmZvcm1hdCAhPT0gJ1JHQkEnKSB8fFxuICAgICAgICAgIChjaGFubmVscyA9PT0gMyAmJiAob3B0aW9ucy5mb3JtYXQgIT09ICdSR0InICYmIG9wdGlvbnMuZm9ybWF0ICE9PSAnQkdSJykpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVGVuc29yIGZvcm1hdCBkb2VzblxcJ3QgbWF0Y2ggaW5wdXQgdGVuc29yIGRpbXMnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBEZWZhdWx0IHBvaW50ZXIgYXNzaWdubWVudHNcbiAgICBjb25zdCBzdGVwID0gNDtcbiAgICBsZXQgckltYWdlUG9pbnRlciA9IDAsIGdJbWFnZVBvaW50ZXIgPSAxLCBiSW1hZ2VQb2ludGVyID0gMiwgYUltYWdlUG9pbnRlciA9IDM7XG4gICAgbGV0IHJUZW5zb3JQb2ludGVyID0gMCwgZ1RlbnNvclBvaW50ZXIgPSBzdHJpZGUsIGJUZW5zb3JQb2ludGVyID0gc3RyaWRlICogMiwgYVRlbnNvclBvaW50ZXIgPSAtMTtcblxuICAgIC8vIFVwZGF0aW5nIHRoZSBwb2ludGVyIGFzc2lnbm1lbnRzIGJhc2VkIG9uIHRoZSBpbnB1dCBpbWFnZSBmb3JtYXRcbiAgICBpZiAoaW5wdXRmb3JtYXQgPT09ICdSR0JBJykge1xuICAgICAgclRlbnNvclBvaW50ZXIgPSAwO1xuICAgICAgZ1RlbnNvclBvaW50ZXIgPSBzdHJpZGU7XG4gICAgICBiVGVuc29yUG9pbnRlciA9IHN0cmlkZSAqIDI7XG4gICAgICBhVGVuc29yUG9pbnRlciA9IHN0cmlkZSAqIDM7XG4gICAgfSBlbHNlIGlmIChpbnB1dGZvcm1hdCA9PT0gJ1JHQicpIHtcbiAgICAgIHJUZW5zb3JQb2ludGVyID0gMDtcbiAgICAgIGdUZW5zb3JQb2ludGVyID0gc3RyaWRlO1xuICAgICAgYlRlbnNvclBvaW50ZXIgPSBzdHJpZGUgKiAyO1xuICAgIH0gZWxzZSBpZiAoaW5wdXRmb3JtYXQgPT09ICdSQkcnKSB7XG4gICAgICByVGVuc29yUG9pbnRlciA9IDA7XG4gICAgICBiVGVuc29yUG9pbnRlciA9IHN0cmlkZTtcbiAgICAgIGdUZW5zb3JQb2ludGVyID0gc3RyaWRlICogMjtcbiAgICB9XG5cbiAgICBpbWFnZSA9IHBpeGVsczJEQ29udGV4dC5jcmVhdGVJbWFnZURhdGEod2lkdGgsIGhlaWdodCk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGhlaWdodCAqIHdpZHRoO1xuICAgICAgICAgckltYWdlUG9pbnRlciArPSBzdGVwLCBnSW1hZ2VQb2ludGVyICs9IHN0ZXAsIGJJbWFnZVBvaW50ZXIgKz0gc3RlcCwgYUltYWdlUG9pbnRlciArPSBzdGVwLCBpKyspIHtcbiAgICAgIGltYWdlLmRhdGFbckltYWdlUG9pbnRlcl0gPSAoKHRlbnNvci5kYXRhW3JUZW5zb3JQb2ludGVyKytdIGFzIG51bWJlcikgLSBub3JtQmlhc1swXSkgKiBub3JtTWVhblswXTsgIC8vIFIgdmFsdWVcbiAgICAgIGltYWdlLmRhdGFbZ0ltYWdlUG9pbnRlcl0gPSAoKHRlbnNvci5kYXRhW2dUZW5zb3JQb2ludGVyKytdIGFzIG51bWJlcikgLSBub3JtQmlhc1sxXSkgKiBub3JtTWVhblsxXTsgIC8vIEcgdmFsdWVcbiAgICAgIGltYWdlLmRhdGFbYkltYWdlUG9pbnRlcl0gPSAoKHRlbnNvci5kYXRhW2JUZW5zb3JQb2ludGVyKytdIGFzIG51bWJlcikgLSBub3JtQmlhc1syXSkgKiBub3JtTWVhblsyXTsgIC8vIEIgdmFsdWVcbiAgICAgIGltYWdlLmRhdGFbYUltYWdlUG9pbnRlcl0gPSBhVGVuc29yUG9pbnRlciA9PT0gLTEgP1xuICAgICAgICAgIDI1NSA6XG4gICAgICAgICAgKCh0ZW5zb3IuZGF0YVthVGVuc29yUG9pbnRlcisrXSBhcyBudW1iZXIpIC0gbm9ybUJpYXNbM10pICogbm9ybU1lYW5bM107ICAvLyBBIHZhbHVlXG4gICAgfVxuXG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDYW4gbm90IGFjY2VzcyBpbWFnZSBkYXRhJyk7XG4gIH1cbiAgcmV0dXJuIGltYWdlO1xufTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtPcHRpb25zRGltZW5zaW9ucywgT3B0aW9uc0Zvcm1hdCwgT3B0aW9uc05vcm1hbGl6YXRpb25QYXJhbWV0ZXJzLCBPcHRpb25zVGVuc29yRm9ybWF0LCBPcHRpb25zVGVuc29yTGF5b3V0LCBUZW5zb3JGcm9tR3B1QnVmZmVyT3B0aW9ucywgVGVuc29yRnJvbUltYWdlQml0bWFwT3B0aW9ucywgVGVuc29yRnJvbUltYWdlRGF0YU9wdGlvbnMsIFRlbnNvckZyb21JbWFnZUVsZW1lbnRPcHRpb25zLCBUZW5zb3JGcm9tVGV4dHVyZU9wdGlvbnMsIFRlbnNvckZyb21VcmxPcHRpb25zfSBmcm9tICcuL3RlbnNvci1mYWN0b3J5LmpzJztcbmltcG9ydCB7VGVuc29yfSBmcm9tICcuL3RlbnNvci1pbXBsLmpzJztcbmltcG9ydCB7VGVuc29yIGFzIFRlbnNvckludGVyZmFjZX0gZnJvbSAnLi90ZW5zb3IuanMnO1xuXG5pbnRlcmZhY2UgQnVmZmVyVG9UZW5zb3JPcHRpb25zIGV4dGVuZHMgT3B0aW9uc0RpbWVuc2lvbnMsIE9wdGlvbnNUZW5zb3JMYXlvdXQsIE9wdGlvbnNOb3JtYWxpemF0aW9uUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPcHRpb25zRm9ybWF0LCBPcHRpb25zVGVuc29yRm9ybWF0IHt9XG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IHRlbnNvciBvYmplY3QgZnJvbSBpbWFnZSBvYmplY3RcbiAqXG4gKiBAcGFyYW0gYnVmZmVyIC0gRXh0cmFjdGVkIGltYWdlIGJ1ZmZlciBkYXRhIC0gYXNzdW1pbmcgUkdCQSBmb3JtYXRcbiAqIEBwYXJhbSBpbWFnZUZvcm1hdCAtIGlucHV0IGltYWdlIGNvbmZpZ3VyYXRpb24gLSByZXF1aXJlZCBjb25maWd1cmF0aW9ucyBoZWlnaHQsIHdpZHRoLCBmb3JtYXRcbiAqIEBwYXJhbSB0ZW5zb3JGb3JtYXQgLSBvdXRwdXQgdGVuc29yIGNvbmZpZ3VyYXRpb24gLSBEZWZhdWx0IGlzIFJHQiBmb3JtYXRcbiAqL1xuZXhwb3J0IGNvbnN0IGJ1ZmZlclRvVGVuc29yID0gKGJ1ZmZlcjogVWludDhDbGFtcGVkQXJyYXl8dW5kZWZpbmVkLCBvcHRpb25zOiBCdWZmZXJUb1RlbnNvck9wdGlvbnMpOiBUZW5zb3IgPT4ge1xuICBpZiAoYnVmZmVyID09PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ltYWdlIGJ1ZmZlciBtdXN0IGJlIGRlZmluZWQnKTtcbiAgfVxuICBpZiAob3B0aW9ucy5oZWlnaHQgPT09IHVuZGVmaW5lZCB8fCBvcHRpb25zLndpZHRoID09PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ltYWdlIGhlaWdodCBhbmQgd2lkdGggbXVzdCBiZSBkZWZpbmVkJyk7XG4gIH1cbiAgaWYgKG9wdGlvbnMudGVuc29yTGF5b3V0ID09PSAnTkhXQycpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05IV0MgVGVuc29yIGxheW91dCBpcyBub3Qgc3VwcG9ydGVkIHlldCcpO1xuICB9XG5cbiAgY29uc3Qge2hlaWdodCwgd2lkdGh9ID0gb3B0aW9ucztcblxuICBjb25zdCBub3JtID0gb3B0aW9ucy5ub3JtID8/IHttZWFuOiAyNTUsIGJpYXM6IDB9O1xuICBsZXQgbm9ybU1lYW46IFtudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXJdO1xuICBsZXQgbm9ybUJpYXM6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXJdO1xuXG4gIGlmICh0eXBlb2YgKG5vcm0ubWVhbikgPT09ICdudW1iZXInKSB7XG4gICAgbm9ybU1lYW4gPSBbbm9ybS5tZWFuLCBub3JtLm1lYW4sIG5vcm0ubWVhbiwgbm9ybS5tZWFuXTtcbiAgfSBlbHNlIHtcbiAgICBub3JtTWVhbiA9IFtub3JtLm1lYW4hWzBdLCBub3JtLm1lYW4hWzFdLCBub3JtLm1lYW4hWzJdLCBub3JtLm1lYW4hWzNdID8/IDI1NV07XG4gIH1cblxuICBpZiAodHlwZW9mIChub3JtLmJpYXMpID09PSAnbnVtYmVyJykge1xuICAgIG5vcm1CaWFzID0gW25vcm0uYmlhcywgbm9ybS5iaWFzLCBub3JtLmJpYXMsIG5vcm0uYmlhc107XG4gIH0gZWxzZSB7XG4gICAgbm9ybUJpYXMgPSBbbm9ybS5iaWFzIVswXSwgbm9ybS5iaWFzIVsxXSwgbm9ybS5iaWFzIVsyXSwgbm9ybS5iaWFzIVszXSA/PyAwXTtcbiAgfVxuXG4gIGNvbnN0IGlucHV0Zm9ybWF0ID0gb3B0aW9ucy5mb3JtYXQgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuZm9ybWF0IDogJ1JHQkEnO1xuICAvLyBkZWZhdWx0IHZhbHVlIGlzIFJHQkEgc2luY2UgaW1hZ2VkYXRhIGFuZCBIVE1MSW1hZ2VFbGVtZW50IHVzZXMgaXRcblxuICBjb25zdCBvdXRwdXRmb3JtYXQgPVxuICAgICAgb3B0aW9ucy50ZW5zb3JGb3JtYXQgIT09IHVuZGVmaW5lZCA/IChvcHRpb25zLnRlbnNvckZvcm1hdCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy50ZW5zb3JGb3JtYXQgOiAnUkdCJykgOiAnUkdCJztcbiAgY29uc3Qgc3RyaWRlID0gaGVpZ2h0ICogd2lkdGg7XG4gIGNvbnN0IGZsb2F0MzJEYXRhID0gb3V0cHV0Zm9ybWF0ID09PSAnUkdCQScgPyBuZXcgRmxvYXQzMkFycmF5KHN0cmlkZSAqIDQpIDogbmV3IEZsb2F0MzJBcnJheShzdHJpZGUgKiAzKTtcblxuICAvLyBEZWZhdWx0IHBvaW50ZXIgYXNzaWdubWVudHNcbiAgbGV0IHN0ZXAgPSA0LCBySW1hZ2VQb2ludGVyID0gMCwgZ0ltYWdlUG9pbnRlciA9IDEsIGJJbWFnZVBvaW50ZXIgPSAyLCBhSW1hZ2VQb2ludGVyID0gMztcbiAgbGV0IHJUZW5zb3JQb2ludGVyID0gMCwgZ1RlbnNvclBvaW50ZXIgPSBzdHJpZGUsIGJUZW5zb3JQb2ludGVyID0gc3RyaWRlICogMiwgYVRlbnNvclBvaW50ZXIgPSAtMTtcblxuICAvLyBVcGRhdGluZyB0aGUgcG9pbnRlciBhc3NpZ25tZW50cyBiYXNlZCBvbiB0aGUgaW5wdXQgaW1hZ2UgZm9ybWF0XG4gIGlmIChpbnB1dGZvcm1hdCA9PT0gJ1JHQicpIHtcbiAgICBzdGVwID0gMztcbiAgICBySW1hZ2VQb2ludGVyID0gMDtcbiAgICBnSW1hZ2VQb2ludGVyID0gMTtcbiAgICBiSW1hZ2VQb2ludGVyID0gMjtcbiAgICBhSW1hZ2VQb2ludGVyID0gLTE7XG4gIH1cblxuICAvLyBVcGRhdGluZyB0aGUgcG9pbnRlciBhc3NpZ25tZW50cyBiYXNlZCBvbiB0aGUgb3V0cHV0IHRlbnNvciBmb3JtYXRcbiAgaWYgKG91dHB1dGZvcm1hdCA9PT0gJ1JHQkEnKSB7XG4gICAgYVRlbnNvclBvaW50ZXIgPSBzdHJpZGUgKiAzO1xuICB9IGVsc2UgaWYgKG91dHB1dGZvcm1hdCA9PT0gJ1JCRycpIHtcbiAgICByVGVuc29yUG9pbnRlciA9IDA7XG4gICAgYlRlbnNvclBvaW50ZXIgPSBzdHJpZGU7XG4gICAgZ1RlbnNvclBvaW50ZXIgPSBzdHJpZGUgKiAyO1xuICB9IGVsc2UgaWYgKG91dHB1dGZvcm1hdCA9PT0gJ0JHUicpIHtcbiAgICBiVGVuc29yUG9pbnRlciA9IDA7XG4gICAgZ1RlbnNvclBvaW50ZXIgPSBzdHJpZGU7XG4gICAgclRlbnNvclBvaW50ZXIgPSBzdHJpZGUgKiAyO1xuICB9XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHJpZGU7XG4gICAgICAgaSsrLCBySW1hZ2VQb2ludGVyICs9IHN0ZXAsIGJJbWFnZVBvaW50ZXIgKz0gc3RlcCwgZ0ltYWdlUG9pbnRlciArPSBzdGVwLCBhSW1hZ2VQb2ludGVyICs9IHN0ZXApIHtcbiAgICBmbG9hdDMyRGF0YVtyVGVuc29yUG9pbnRlcisrXSA9IChidWZmZXJbckltYWdlUG9pbnRlcl0gKyBub3JtQmlhc1swXSkgLyBub3JtTWVhblswXTtcbiAgICBmbG9hdDMyRGF0YVtnVGVuc29yUG9pbnRlcisrXSA9IChidWZmZXJbZ0ltYWdlUG9pbnRlcl0gKyBub3JtQmlhc1sxXSkgLyBub3JtTWVhblsxXTtcbiAgICBmbG9hdDMyRGF0YVtiVGVuc29yUG9pbnRlcisrXSA9IChidWZmZXJbYkltYWdlUG9pbnRlcl0gKyBub3JtQmlhc1syXSkgLyBub3JtTWVhblsyXTtcbiAgICBpZiAoYVRlbnNvclBvaW50ZXIgIT09IC0xICYmIGFJbWFnZVBvaW50ZXIgIT09IC0xKSB7XG4gICAgICBmbG9hdDMyRGF0YVthVGVuc29yUG9pbnRlcisrXSA9IChidWZmZXJbYUltYWdlUG9pbnRlcl0gKyBub3JtQmlhc1szXSkgLyBub3JtTWVhblszXTtcbiAgICB9XG4gIH1cblxuICAvLyBGbG9hdDMyQXJyYXkgLT4gb3J0LlRlbnNvclxuICBjb25zdCBvdXRwdXRUZW5zb3IgPSBvdXRwdXRmb3JtYXQgPT09ICdSR0JBJyA/IG5ldyBUZW5zb3IoJ2Zsb2F0MzInLCBmbG9hdDMyRGF0YSwgWzEsIDQsIGhlaWdodCwgd2lkdGhdKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3IFRlbnNvcignZmxvYXQzMicsIGZsb2F0MzJEYXRhLCBbMSwgMywgaGVpZ2h0LCB3aWR0aF0pO1xuICByZXR1cm4gb3V0cHV0VGVuc29yO1xufTtcblxuLyoqXG4gKiBpbXBsZW1lbnRhdGlvbiBvZiBUZW5zb3IuZnJvbUltYWdlKCkuXG4gKi9cbmV4cG9ydCBjb25zdCB0ZW5zb3JGcm9tSW1hZ2UgPSBhc3luYyhcbiAgICBpbWFnZTogSW1hZ2VEYXRhfEhUTUxJbWFnZUVsZW1lbnR8SW1hZ2VCaXRtYXB8c3RyaW5nLFxuICAgIG9wdGlvbnM/OiBUZW5zb3JGcm9tSW1hZ2VEYXRhT3B0aW9uc3xUZW5zb3JGcm9tSW1hZ2VFbGVtZW50T3B0aW9uc3xUZW5zb3JGcm9tSW1hZ2VCaXRtYXBPcHRpb25zfFxuICAgIFRlbnNvckZyb21VcmxPcHRpb25zKTogUHJvbWlzZTxUZW5zb3I+ID0+IHtcbiAgLy8gY2hlY2tpbmcgdGhlIHR5cGUgb2YgaW1hZ2Ugb2JqZWN0XG4gIGNvbnN0IGlzSFRNTEltYWdlRWxlID0gdHlwZW9mIChIVE1MSW1hZ2VFbGVtZW50KSAhPT0gJ3VuZGVmaW5lZCcgJiYgaW1hZ2UgaW5zdGFuY2VvZiBIVE1MSW1hZ2VFbGVtZW50O1xuICBjb25zdCBpc0ltYWdlRGF0YUVsZSA9IHR5cGVvZiAoSW1hZ2VEYXRhKSAhPT0gJ3VuZGVmaW5lZCcgJiYgaW1hZ2UgaW5zdGFuY2VvZiBJbWFnZURhdGE7XG4gIGNvbnN0IGlzSW1hZ2VCaXRtYXAgPSB0eXBlb2YgKEltYWdlQml0bWFwKSAhPT0gJ3VuZGVmaW5lZCcgJiYgaW1hZ2UgaW5zdGFuY2VvZiBJbWFnZUJpdG1hcDtcbiAgY29uc3QgaXNTdHJpbmcgPSB0eXBlb2YgaW1hZ2UgPT09ICdzdHJpbmcnO1xuXG4gIGxldCBkYXRhOiBVaW50OENsYW1wZWRBcnJheXx1bmRlZmluZWQ7XG4gIGxldCBidWZmZXJUb1RlbnNvck9wdGlvbnM6IEJ1ZmZlclRvVGVuc29yT3B0aW9ucyA9IG9wdGlvbnMgPz8ge307XG5cbiAgY29uc3QgY3JlYXRlQ2FudmFzID0gKCkgPT4ge1xuICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgT2Zmc2NyZWVuQ2FudmFzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuIG5ldyBPZmZzY3JlZW5DYW52YXMoMSwgMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2FudmFzIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IGNyZWF0ZUNhbnZhc0NvbnRleHQgPSAoY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudHxPZmZzY3JlZW5DYW52YXMpID0+IHtcbiAgICBpZiAoY2FudmFzIGluc3RhbmNlb2YgSFRNTENhbnZhc0VsZW1lbnQpIHtcbiAgICAgIHJldHVybiBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICB9IGVsc2UgaWYgKGNhbnZhcyBpbnN0YW5jZW9mIE9mZnNjcmVlbkNhbnZhcykge1xuICAgICAgcmV0dXJuIGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpIGFzIE9mZnNjcmVlbkNhbnZhc1JlbmRlcmluZ0NvbnRleHQyRDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9O1xuICAvLyBmaWxsaW5nIGFuZCBjaGVja2luZyBpbWFnZSBjb25maWd1cmF0aW9uIG9wdGlvbnNcbiAgaWYgKGlzSFRNTEltYWdlRWxlKSB7XG4gICAgLy8gSFRNTEltYWdlRWxlbWVudCAtIGltYWdlIG9iamVjdCAtIGZvcm1hdCBpcyBSR0JBIGJ5IGRlZmF1bHRcbiAgICBjb25zdCBjYW52YXMgPSBjcmVhdGVDYW52YXMoKTtcbiAgICBjYW52YXMud2lkdGggPSBpbWFnZS53aWR0aDtcbiAgICBjYW52YXMuaGVpZ2h0ID0gaW1hZ2UuaGVpZ2h0O1xuICAgIGNvbnN0IHBpeGVsczJEQ29udGV4dCA9IGNyZWF0ZUNhbnZhc0NvbnRleHQoY2FudmFzKTtcblxuICAgIGlmIChwaXhlbHMyRENvbnRleHQgIT0gbnVsbCkge1xuICAgICAgbGV0IGhlaWdodCA9IGltYWdlLmhlaWdodDtcbiAgICAgIGxldCB3aWR0aCA9IGltYWdlLndpZHRoO1xuICAgICAgaWYgKG9wdGlvbnMgIT09IHVuZGVmaW5lZCAmJiBvcHRpb25zLnJlc2l6ZWRIZWlnaHQgIT09IHVuZGVmaW5lZCAmJiBvcHRpb25zLnJlc2l6ZWRXaWR0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGhlaWdodCA9IG9wdGlvbnMucmVzaXplZEhlaWdodDtcbiAgICAgICAgd2lkdGggPSBvcHRpb25zLnJlc2l6ZWRXaWR0aDtcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBidWZmZXJUb1RlbnNvck9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICBpZiAob3B0aW9ucy50ZW5zb3JGb3JtYXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW1hZ2UgaW5wdXQgY29uZmlnIGZvcm1hdCBtdXN0IGJlIFJHQkEgZm9yIEhUTUxJbWFnZUVsZW1lbnQnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBidWZmZXJUb1RlbnNvck9wdGlvbnMudGVuc29yRm9ybWF0ID0gJ1JHQkEnO1xuICAgICAgICB9XG4gICAgICAgIGJ1ZmZlclRvVGVuc29yT3B0aW9ucy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIGJ1ZmZlclRvVGVuc29yT3B0aW9ucy53aWR0aCA9IHdpZHRoO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnVmZmVyVG9UZW5zb3JPcHRpb25zLnRlbnNvckZvcm1hdCA9ICdSR0JBJztcbiAgICAgICAgYnVmZmVyVG9UZW5zb3JPcHRpb25zLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgYnVmZmVyVG9UZW5zb3JPcHRpb25zLndpZHRoID0gd2lkdGg7XG4gICAgICB9XG5cbiAgICAgIHBpeGVsczJEQ29udGV4dC5kcmF3SW1hZ2UoaW1hZ2UsIDAsIDApO1xuICAgICAgZGF0YSA9IHBpeGVsczJEQ29udGV4dC5nZXRJbWFnZURhdGEoMCwgMCwgd2lkdGgsIGhlaWdodCkuZGF0YTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW4gbm90IGFjY2VzcyBpbWFnZSBkYXRhJyk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzSW1hZ2VEYXRhRWxlKSB7XG4gICAgbGV0IGhlaWdodDogbnVtYmVyO1xuICAgIGxldCB3aWR0aDogbnVtYmVyO1xuXG4gICAgaWYgKG9wdGlvbnMgIT09IHVuZGVmaW5lZCAmJiBvcHRpb25zLnJlc2l6ZWRXaWR0aCAhPT0gdW5kZWZpbmVkICYmIG9wdGlvbnMucmVzaXplZEhlaWdodCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBoZWlnaHQgPSBvcHRpb25zLnJlc2l6ZWRIZWlnaHQ7XG4gICAgICB3aWR0aCA9IG9wdGlvbnMucmVzaXplZFdpZHRoO1xuICAgIH0gZWxzZSB7XG4gICAgICBoZWlnaHQgPSBpbWFnZS5oZWlnaHQ7XG4gICAgICB3aWR0aCA9IGltYWdlLndpZHRoO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGJ1ZmZlclRvVGVuc29yT3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgfVxuICAgIGJ1ZmZlclRvVGVuc29yT3B0aW9ucy5mb3JtYXQgPSAnUkdCQSc7XG4gICAgYnVmZmVyVG9UZW5zb3JPcHRpb25zLmhlaWdodCA9IGhlaWdodDtcbiAgICBidWZmZXJUb1RlbnNvck9wdGlvbnMud2lkdGggPSB3aWR0aDtcblxuICAgIGlmIChvcHRpb25zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbnN0IHRlbXBDYW52YXMgPSBjcmVhdGVDYW52YXMoKTtcblxuICAgICAgdGVtcENhbnZhcy53aWR0aCA9IHdpZHRoO1xuICAgICAgdGVtcENhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG5cbiAgICAgIGNvbnN0IHBpeGVsczJEQ29udGV4dCA9IGNyZWF0ZUNhbnZhc0NvbnRleHQodGVtcENhbnZhcyk7XG5cbiAgICAgIGlmIChwaXhlbHMyRENvbnRleHQgIT0gbnVsbCkge1xuICAgICAgICBwaXhlbHMyRENvbnRleHQucHV0SW1hZ2VEYXRhKGltYWdlLCAwLCAwKTtcbiAgICAgICAgZGF0YSA9IHBpeGVsczJEQ29udGV4dC5nZXRJbWFnZURhdGEoMCwgMCwgd2lkdGgsIGhlaWdodCkuZGF0YTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2FuIG5vdCBhY2Nlc3MgaW1hZ2UgZGF0YScpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBkYXRhID0gaW1hZ2UuZGF0YTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNJbWFnZUJpdG1hcCkge1xuICAgIC8vIEltYWdlQml0bWFwIC0gaW1hZ2Ugb2JqZWN0IC0gZm9ybWF0IG11c3QgYmUgcHJvdmlkZWQgYnkgdXNlclxuICAgIGlmIChvcHRpb25zID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUGxlYXNlIHByb3ZpZGUgaW1hZ2UgY29uZmlnIHdpdGggZm9ybWF0IGZvciBJbWFnZWJpdG1hcCcpO1xuICAgIH1cblxuICAgIGNvbnN0IGNhbnZhcyA9IGNyZWF0ZUNhbnZhcygpO1xuICAgIGNhbnZhcy53aWR0aCA9IGltYWdlLndpZHRoO1xuICAgIGNhbnZhcy5oZWlnaHQgPSBpbWFnZS5oZWlnaHQ7XG4gICAgY29uc3QgcGl4ZWxzMkRDb250ZXh0ID0gY3JlYXRlQ2FudmFzQ29udGV4dChjYW52YXMpO1xuXG4gICAgaWYgKHBpeGVsczJEQ29udGV4dCAhPSBudWxsKSB7XG4gICAgICBjb25zdCBoZWlnaHQgPSBpbWFnZS5oZWlnaHQ7XG4gICAgICBjb25zdCB3aWR0aCA9IGltYWdlLndpZHRoO1xuICAgICAgcGl4ZWxzMkRDb250ZXh0LmRyYXdJbWFnZShpbWFnZSwgMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICBkYXRhID0gcGl4ZWxzMkRDb250ZXh0LmdldEltYWdlRGF0YSgwLCAwLCB3aWR0aCwgaGVpZ2h0KS5kYXRhO1xuICAgICAgYnVmZmVyVG9UZW5zb3JPcHRpb25zLmhlaWdodCA9IGhlaWdodDtcbiAgICAgIGJ1ZmZlclRvVGVuc29yT3B0aW9ucy53aWR0aCA9IHdpZHRoO1xuICAgICAgcmV0dXJuIGJ1ZmZlclRvVGVuc29yKGRhdGEsIGJ1ZmZlclRvVGVuc29yT3B0aW9ucyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2FuIG5vdCBhY2Nlc3MgaW1hZ2UgZGF0YScpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc1N0cmluZykge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjb25zdCBjYW52YXMgPSBjcmVhdGVDYW52YXMoKTtcbiAgICAgIGNvbnN0IGNvbnRleHQgPSBjcmVhdGVDYW52YXNDb250ZXh0KGNhbnZhcyk7XG4gICAgICBpZiAoIWltYWdlIHx8ICFjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiByZWplY3QoKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG5ld0ltYWdlID0gbmV3IEltYWdlKCk7XG4gICAgICBuZXdJbWFnZS5jcm9zc09yaWdpbiA9ICdBbm9ueW1vdXMnO1xuICAgICAgbmV3SW1hZ2Uuc3JjID0gaW1hZ2U7XG4gICAgICBuZXdJbWFnZS5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICAgIGNhbnZhcy53aWR0aCA9IG5ld0ltYWdlLndpZHRoO1xuICAgICAgICBjYW52YXMuaGVpZ2h0ID0gbmV3SW1hZ2UuaGVpZ2h0O1xuICAgICAgICBjb250ZXh0LmRyYXdJbWFnZShuZXdJbWFnZSwgMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICAgICAgY29uc3QgaW1nID0gY29udGV4dC5nZXRJbWFnZURhdGEoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcblxuICAgICAgICBidWZmZXJUb1RlbnNvck9wdGlvbnMuaGVpZ2h0ID0gY2FudmFzLmhlaWdodDtcbiAgICAgICAgYnVmZmVyVG9UZW5zb3JPcHRpb25zLndpZHRoID0gY2FudmFzLndpZHRoO1xuICAgICAgICByZXNvbHZlKGJ1ZmZlclRvVGVuc29yKGltZy5kYXRhLCBidWZmZXJUb1RlbnNvck9wdGlvbnMpKTtcbiAgICAgIH07XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBkYXRhIHByb3ZpZGVkIGlzIG5vdCBzdXBwb3J0ZWQgLSBhYm9ydGVkIHRlbnNvciBjcmVhdGlvbicpO1xuICB9XG5cbiAgaWYgKGRhdGEgIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBidWZmZXJUb1RlbnNvcihkYXRhLCBidWZmZXJUb1RlbnNvck9wdGlvbnMpO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgZGF0YSBwcm92aWRlZCBpcyBub3Qgc3VwcG9ydGVkIC0gYWJvcnRlZCB0ZW5zb3IgY3JlYXRpb24nKTtcbiAgfVxufTtcblxuLyoqXG4gKiBpbXBsZW1lbnRhdGlvbiBvZiBUZW5zb3IuZnJvbVRleHR1cmUoKS5cbiAqL1xuZXhwb3J0IGNvbnN0IHRlbnNvckZyb21UZXh0dXJlID0gPFQgZXh0ZW5kcyBUZW5zb3JJbnRlcmZhY2UuVGV4dHVyZURhdGFUeXBlcz4oXG4gICAgdGV4dHVyZTogVGVuc29ySW50ZXJmYWNlLlRleHR1cmVUeXBlLCBvcHRpb25zOiBUZW5zb3JGcm9tVGV4dHVyZU9wdGlvbnM8VD4pOiBUZW5zb3IgPT4ge1xuICBjb25zdCB7d2lkdGgsIGhlaWdodCwgZG93bmxvYWQsIGRpc3Bvc2V9ID0gb3B0aW9ucztcbiAgLy8gQWx3YXlzIGFzc3VtZSBSR0JBRjMyLiBUT0RPOiBzdXBwb3J0IGRpZmZlcmVudCB0ZXh0dXJlIGZvcm1hdFxuICBjb25zdCBkaW1zID0gWzEsIGhlaWdodCwgd2lkdGgsIDRdO1xuICByZXR1cm4gbmV3IFRlbnNvcih7bG9jYXRpb246ICd0ZXh0dXJlJywgdHlwZTogJ2Zsb2F0MzInLCB0ZXh0dXJlLCBkaW1zLCBkb3dubG9hZCwgZGlzcG9zZX0pO1xufTtcblxuLyoqXG4gKiBpbXBsZW1lbnRhdGlvbiBvZiBUZW5zb3IuZnJvbUdwdUJ1ZmZlcigpLlxuICovXG5leHBvcnQgY29uc3QgdGVuc29yRnJvbUdwdUJ1ZmZlciA9IDxUIGV4dGVuZHMgVGVuc29ySW50ZXJmYWNlLkdwdUJ1ZmZlckRhdGFUeXBlcz4oXG4gICAgZ3B1QnVmZmVyOiBUZW5zb3JJbnRlcmZhY2UuR3B1QnVmZmVyVHlwZSwgb3B0aW9uczogVGVuc29yRnJvbUdwdUJ1ZmZlck9wdGlvbnM8VD4pOiBUZW5zb3IgPT4ge1xuICBjb25zdCB7ZGF0YVR5cGUsIGRpbXMsIGRvd25sb2FkLCBkaXNwb3NlfSA9IG9wdGlvbnM7XG4gIHJldHVybiBuZXcgVGVuc29yKHtsb2NhdGlvbjogJ2dwdS1idWZmZXInLCB0eXBlOiBkYXRhVHlwZSA/PyAnZmxvYXQzMicsIGdwdUJ1ZmZlciwgZGltcywgZG93bmxvYWQsIGRpc3Bvc2V9KTtcbn07XG5cbi8qKlxuICogaW1wbGVtZW50YXRpb24gb2YgVGVuc29yLmZyb21QaW5uZWRCdWZmZXIoKS5cbiAqL1xuZXhwb3J0IGNvbnN0IHRlbnNvckZyb21QaW5uZWRCdWZmZXIgPSA8VCBleHRlbmRzIFRlbnNvckludGVyZmFjZS5DcHVQaW5uZWREYXRhVHlwZXM+KFxuICAgIHR5cGU6IFQsIGJ1ZmZlcjogVGVuc29ySW50ZXJmYWNlLkRhdGFUeXBlTWFwW1RdLCBkaW1zPzogcmVhZG9ubHkgbnVtYmVyW10pOiBUZW5zb3IgPT5cbiAgICBuZXcgVGVuc29yKHtsb2NhdGlvbjogJ2NwdS1waW5uZWQnLCB0eXBlLCBkYXRhOiBidWZmZXIsIGRpbXM6IGRpbXMgPz8gW2J1ZmZlci5sZW5ndGhdfSk7XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7VGVuc29yfSBmcm9tICcuL3RlbnNvci5qcyc7XG5cbmV4cG9ydCB0eXBlIFN1cHBvcnRlZFR5cGVkQXJyYXlDb25zdHJ1Y3RvcnMgPSBGbG9hdDMyQXJyYXlDb25zdHJ1Y3RvcnxVaW50OEFycmF5Q29uc3RydWN0b3J8SW50OEFycmF5Q29uc3RydWN0b3J8XG4gICAgVWludDE2QXJyYXlDb25zdHJ1Y3RvcnxJbnQxNkFycmF5Q29uc3RydWN0b3J8SW50MzJBcnJheUNvbnN0cnVjdG9yfEJpZ0ludDY0QXJyYXlDb25zdHJ1Y3RvcnxVaW50OEFycmF5Q29uc3RydWN0b3J8XG4gICAgRmxvYXQ2NEFycmF5Q29uc3RydWN0b3J8VWludDMyQXJyYXlDb25zdHJ1Y3RvcnxCaWdVaW50NjRBcnJheUNvbnN0cnVjdG9yO1xuZXhwb3J0IHR5cGUgU3VwcG9ydGVkVHlwZWRBcnJheSA9IEluc3RhbmNlVHlwZTxTdXBwb3J0ZWRUeXBlZEFycmF5Q29uc3RydWN0b3JzPjtcblxuLy8gYSBydW50aW1lIG1hcCB0aGF0IG1hcHMgdHlwZSBzdHJpbmcgdG8gVHlwZWRBcnJheSBjb25zdHJ1Y3Rvci4gU2hvdWxkIG1hdGNoIFRlbnNvci5EYXRhVHlwZU1hcC5cbmV4cG9ydCBjb25zdCBOVU1FUklDX1RFTlNPUl9UWVBFX1RPX1RZUEVEQVJSQVlfTUFQID0gbmV3IE1hcDxzdHJpbmcsIFN1cHBvcnRlZFR5cGVkQXJyYXlDb25zdHJ1Y3RvcnM+KFtcbiAgWydmbG9hdDMyJywgRmxvYXQzMkFycmF5XSxcbiAgWyd1aW50OCcsIFVpbnQ4QXJyYXldLFxuICBbJ2ludDgnLCBJbnQ4QXJyYXldLFxuICBbJ3VpbnQxNicsIFVpbnQxNkFycmF5XSxcbiAgWydmbG9hdDE2JywgVWludDE2QXJyYXldLFxuICBbJ2ludDE2JywgSW50MTZBcnJheV0sXG4gIFsnaW50MzInLCBJbnQzMkFycmF5XSxcbiAgWydib29sJywgVWludDhBcnJheV0sXG4gIFsnZmxvYXQ2NCcsIEZsb2F0NjRBcnJheV0sXG4gIFsndWludDMyJywgVWludDMyQXJyYXldLFxuXSk7XG5cbi8vIGEgcnVudGltZSBtYXAgdGhhdCBtYXBzIHR5cGUgc3RyaW5nIHRvIFR5cGVkQXJyYXkgY29uc3RydWN0b3IuIFNob3VsZCBtYXRjaCBUZW5zb3IuRGF0YVR5cGVNYXAuXG5leHBvcnQgY29uc3QgTlVNRVJJQ19URU5TT1JfVFlQRURBUlJBWV9UT19UWVBFX01BUCA9IG5ldyBNYXA8U3VwcG9ydGVkVHlwZWRBcnJheUNvbnN0cnVjdG9ycywgVGVuc29yLlR5cGU+KFtcbiAgW0Zsb2F0MzJBcnJheSwgJ2Zsb2F0MzInXSxcbiAgW1VpbnQ4QXJyYXksICd1aW50OCddLFxuICBbSW50OEFycmF5LCAnaW50OCddLFxuICBbVWludDE2QXJyYXksICd1aW50MTYnXSxcbiAgW0ludDE2QXJyYXksICdpbnQxNiddLFxuICBbSW50MzJBcnJheSwgJ2ludDMyJ10sXG4gIFtGbG9hdDY0QXJyYXksICdmbG9hdDY0J10sXG4gIFtVaW50MzJBcnJheSwgJ3VpbnQzMiddLFxuXSk7XG5cbi8vIHRoZSBmb2xsb3dpbmcgY29kZSBhbGxvd3MgZGVsYXlpbmcgZXhlY3V0aW9uIG9mIEJpZ0ludCBjaGVja2luZy4gVGhpcyBhbGxvd3MgbGF6eSBpbml0aWFsaXphdGlvbiBmb3Jcbi8vIE5VTUVSSUNfVEVOU09SX1RZUEVfVE9fVFlQRURBUlJBWV9NQVAgYW5kIE5VTUVSSUNfVEVOU09SX1RZUEVEQVJSQVlfVE9fVFlQRV9NQVAsIHdoaWNoIGFsbG93cyBCaWdJbnQgcG9seWZpbGxcbi8vIGlmIGF2YWlsYWJsZS5cbmxldCBpc0JpZ0ludENoZWNrZWQgPSBmYWxzZTtcbmV4cG9ydCBjb25zdCBjaGVja0JpZ0ludCA9ICgpID0+IHtcbiAgaWYgKCFpc0JpZ0ludENoZWNrZWQpIHtcbiAgICBpc0JpZ0ludENoZWNrZWQgPSB0cnVlO1xuICAgIGNvbnN0IGlzQmlnSW50NjRBcnJheUF2YWlsYWJsZSA9IHR5cGVvZiBCaWdJbnQ2NEFycmF5ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgQmlnSW50NjRBcnJheS5mcm9tID09PSAnZnVuY3Rpb24nO1xuICAgIGNvbnN0IGlzQmlnVWludDY0QXJyYXlBdmFpbGFibGUgPVxuICAgICAgICB0eXBlb2YgQmlnVWludDY0QXJyYXkgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBCaWdVaW50NjRBcnJheS5mcm9tID09PSAnZnVuY3Rpb24nO1xuXG4gICAgaWYgKGlzQmlnSW50NjRBcnJheUF2YWlsYWJsZSkge1xuICAgICAgTlVNRVJJQ19URU5TT1JfVFlQRV9UT19UWVBFREFSUkFZX01BUC5zZXQoJ2ludDY0JywgQmlnSW50NjRBcnJheSk7XG4gICAgICBOVU1FUklDX1RFTlNPUl9UWVBFREFSUkFZX1RPX1RZUEVfTUFQLnNldChCaWdJbnQ2NEFycmF5LCAnaW50NjQnKTtcbiAgICB9XG4gICAgaWYgKGlzQmlnVWludDY0QXJyYXlBdmFpbGFibGUpIHtcbiAgICAgIE5VTUVSSUNfVEVOU09SX1RZUEVfVE9fVFlQRURBUlJBWV9NQVAuc2V0KCd1aW50NjQnLCBCaWdVaW50NjRBcnJheSk7XG4gICAgICBOVU1FUklDX1RFTlNPUl9UWVBFREFSUkFZX1RPX1RZUEVfTUFQLnNldChCaWdVaW50NjRBcnJheSwgJ3VpbnQ2NCcpO1xuICAgIH1cbiAgfVxufTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtDcHVQaW5uZWRDb25zdHJ1Y3RvclBhcmFtZXRlcnMsIEdwdUJ1ZmZlckNvbnN0cnVjdG9yUGFyYW1ldGVycywgVGV4dHVyZUNvbnN0cnVjdG9yUGFyYW1ldGVyc30gZnJvbSAnLi90ZW5zb3ItZmFjdG9yeS5qcyc7XG5pbXBvcnQge1RlbnNvcn0gZnJvbSAnLi90ZW5zb3ItaW1wbC5qcyc7XG5cbi8qKlxuICogY2FsY3VsYXRlIHNpemUgZnJvbSBkaW1zLlxuICpcbiAqIEBwYXJhbSBkaW1zIHRoZSBkaW1zIGFycmF5LiBNYXkgYmUgYW4gaWxsZWdhbCBpbnB1dC5cbiAqL1xuZXhwb3J0IGNvbnN0IGNhbGN1bGF0ZVNpemUgPSAoZGltczogcmVhZG9ubHkgdW5rbm93bltdKTogbnVtYmVyID0+IHtcbiAgbGV0IHNpemUgPSAxO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGRpbXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBkaW0gPSBkaW1zW2ldO1xuICAgIGlmICh0eXBlb2YgZGltICE9PSAnbnVtYmVyJyB8fCAhTnVtYmVyLmlzU2FmZUludGVnZXIoZGltKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgZGltc1ske2l9XSBtdXN0IGJlIGFuIGludGVnZXIsIGdvdDogJHtkaW19YCk7XG4gICAgfVxuICAgIGlmIChkaW0gPCAwKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgZGltc1ske2l9XSBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIGludGVnZXIsIGdvdDogJHtkaW19YCk7XG4gICAgfVxuICAgIHNpemUgKj0gZGltO1xuICB9XG4gIHJldHVybiBzaXplO1xufTtcblxuLyoqXG4gKiBpbXBsZW1lbnRhdGlvbiBvZiBUZW5zb3IucmVzaGFwZSgpXG4gKi9cbmV4cG9ydCBjb25zdCB0ZW5zb3JSZXNoYXBlID0gKHRlbnNvcjogVGVuc29yLCBkaW1zOiByZWFkb25seSBudW1iZXJbXSk6IFRlbnNvciA9PiB7XG4gIHN3aXRjaCAodGVuc29yLmxvY2F0aW9uKSB7XG4gICAgY2FzZSAnY3B1JzpcbiAgICAgIHJldHVybiBuZXcgVGVuc29yKHRlbnNvci50eXBlLCB0ZW5zb3IuZGF0YSwgZGltcyk7XG4gICAgY2FzZSAnY3B1LXBpbm5lZCc6XG4gICAgICByZXR1cm4gbmV3IFRlbnNvcih7XG4gICAgICAgIGxvY2F0aW9uOiAnY3B1LXBpbm5lZCcsXG4gICAgICAgIGRhdGE6IHRlbnNvci5kYXRhIGFzIENwdVBpbm5lZENvbnN0cnVjdG9yUGFyYW1ldGVyc1snZGF0YSddLFxuICAgICAgICB0eXBlOiB0ZW5zb3IudHlwZSBhcyBDcHVQaW5uZWRDb25zdHJ1Y3RvclBhcmFtZXRlcnNbJ3R5cGUnXSxcbiAgICAgICAgZGltcyxcbiAgICAgIH0pO1xuICAgIGNhc2UgJ3RleHR1cmUnOlxuICAgICAgcmV0dXJuIG5ldyBUZW5zb3Ioe1xuICAgICAgICBsb2NhdGlvbjogJ3RleHR1cmUnLFxuICAgICAgICB0ZXh0dXJlOiB0ZW5zb3IudGV4dHVyZSxcbiAgICAgICAgdHlwZTogdGVuc29yLnR5cGUgYXMgVGV4dHVyZUNvbnN0cnVjdG9yUGFyYW1ldGVyc1sndHlwZSddLFxuICAgICAgICBkaW1zLFxuICAgICAgfSk7XG4gICAgY2FzZSAnZ3B1LWJ1ZmZlcic6XG4gICAgICByZXR1cm4gbmV3IFRlbnNvcih7XG4gICAgICAgIGxvY2F0aW9uOiAnZ3B1LWJ1ZmZlcicsXG4gICAgICAgIGdwdUJ1ZmZlcjogdGVuc29yLmdwdUJ1ZmZlcixcbiAgICAgICAgdHlwZTogdGVuc29yLnR5cGUgYXMgR3B1QnVmZmVyQ29uc3RydWN0b3JQYXJhbWV0ZXJzWyd0eXBlJ10sXG4gICAgICAgIGRpbXMsXG4gICAgICB9KTtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKGB0ZW5zb3JSZXNoYXBlOiB0ZW5zb3IgbG9jYXRpb24gJHt0ZW5zb3IubG9jYXRpb259IGlzIG5vdCBzdXBwb3J0ZWRgKTtcbiAgfVxufTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHt0ZW5zb3JUb0RhdGFVUkwsIHRlbnNvclRvSW1hZ2VEYXRhfSBmcm9tICcuL3RlbnNvci1jb252ZXJzaW9uLWltcGwuanMnO1xuaW1wb3J0IHtUZW5zb3JUb0RhdGFVcmxPcHRpb25zLCBUZW5zb3JUb0ltYWdlRGF0YU9wdGlvbnN9IGZyb20gJy4vdGVuc29yLWNvbnZlcnNpb24uanMnO1xuaW1wb3J0IHt0ZW5zb3JGcm9tR3B1QnVmZmVyLCB0ZW5zb3JGcm9tSW1hZ2UsIHRlbnNvckZyb21QaW5uZWRCdWZmZXIsIHRlbnNvckZyb21UZXh0dXJlfSBmcm9tICcuL3RlbnNvci1mYWN0b3J5LWltcGwuanMnO1xuaW1wb3J0IHtDcHVQaW5uZWRDb25zdHJ1Y3RvclBhcmFtZXRlcnMsIEdwdUJ1ZmZlckNvbnN0cnVjdG9yUGFyYW1ldGVycywgVGVuc29yRnJvbUdwdUJ1ZmZlck9wdGlvbnMsIFRlbnNvckZyb21JbWFnZUJpdG1hcE9wdGlvbnMsIFRlbnNvckZyb21JbWFnZURhdGFPcHRpb25zLCBUZW5zb3JGcm9tSW1hZ2VFbGVtZW50T3B0aW9ucywgVGVuc29yRnJvbVRleHR1cmVPcHRpb25zLCBUZW5zb3JGcm9tVXJsT3B0aW9ucywgVGV4dHVyZUNvbnN0cnVjdG9yUGFyYW1ldGVyc30gZnJvbSAnLi90ZW5zb3ItZmFjdG9yeS5qcyc7XG5pbXBvcnQge2NoZWNrQmlnSW50LCBOVU1FUklDX1RFTlNPUl9UWVBFX1RPX1RZUEVEQVJSQVlfTUFQLCBOVU1FUklDX1RFTlNPUl9UWVBFREFSUkFZX1RPX1RZUEVfTUFQLCBTdXBwb3J0ZWRUeXBlZEFycmF5LCBTdXBwb3J0ZWRUeXBlZEFycmF5Q29uc3RydWN0b3JzfSBmcm9tICcuL3RlbnNvci1pbXBsLXR5cGUtbWFwcGluZy5qcyc7XG5pbXBvcnQge2NhbGN1bGF0ZVNpemUsIHRlbnNvclJlc2hhcGV9IGZyb20gJy4vdGVuc29yLXV0aWxzLWltcGwuanMnO1xuaW1wb3J0IHtUZW5zb3IgYXMgVGVuc29ySW50ZXJmYWNlfSBmcm9tICcuL3RlbnNvci5qcyc7XG5cbi8vIHR5cGUgYWxpYXNlcyBmb3IgdGhvc2UgZXhwb3J0ZWQgZnJvbSBUZW5zb3IgaW50ZXJmYWNlXG5cbnR5cGUgVGVuc29yVHlwZSA9IFRlbnNvckludGVyZmFjZS5UeXBlO1xudHlwZSBUZW5zb3JEYXRhVHlwZSA9IFRlbnNvckludGVyZmFjZS5EYXRhVHlwZTtcbnR5cGUgVGVuc29yRGF0YUxvY2F0aW9uID0gVGVuc29ySW50ZXJmYWNlLkRhdGFMb2NhdGlvbjtcbnR5cGUgVGVuc29yVGV4dHVyZVR5cGUgPSBUZW5zb3JJbnRlcmZhY2UuVGV4dHVyZVR5cGU7XG50eXBlIFRlbnNvckdwdUJ1ZmZlclR5cGUgPSBUZW5zb3JJbnRlcmZhY2UuR3B1QnVmZmVyVHlwZTtcblxuLyoqXG4gKiB0aGUgaW1wbGVtZW50YXRpb24gb2YgVGVuc29yIGludGVyZmFjZS5cbiAqXG4gKiBAaWdub3JlXG4gKi9cbmV4cG9ydCBjbGFzcyBUZW5zb3IgaW1wbGVtZW50cyBUZW5zb3JJbnRlcmZhY2Uge1xuICAvLyAjcmVnaW9uIGNvbnN0cnVjdG9yc1xuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3QgYSBuZXcgQ1BVIHRlbnNvciBvYmplY3QgZnJvbSB0aGUgZ2l2ZW4gdHlwZSwgZGF0YSBhbmQgZGltcy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKFxuICAgICAgdHlwZTogVGVuc29yVHlwZSwgZGF0YTogVGVuc29yRGF0YVR5cGV8cmVhZG9ubHkgc3RyaW5nW118cmVhZG9ubHkgbnVtYmVyW118cmVhZG9ubHkgYm9vbGVhbltdLFxuICAgICAgZGltcz86IHJlYWRvbmx5IG51bWJlcltdKTtcbiAgLyoqXG4gICAqIENvbnN0cnVjdCBhIG5ldyBDUFUgdGVuc29yIG9iamVjdCBmcm9tIHRoZSBnaXZlbiBkYXRhIGFuZCBkaW1zLiBUeXBlIGlzIGluZmVycmVkIGZyb20gZGF0YS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGRhdGE6IFRlbnNvckRhdGFUeXBlfHJlYWRvbmx5IHN0cmluZ1tdfHJlYWRvbmx5IGJvb2xlYW5bXSwgZGltcz86IHJlYWRvbmx5IG51bWJlcltdKTtcbiAgLyoqXG4gICAqIENvbnN0cnVjdCBhIG5ldyB0ZW5zb3Igb2JqZWN0IGZyb20gdGhlIHBpbm5lZCBDUFUgZGF0YSB3aXRoIHRoZSBnaXZlbiB0eXBlIGFuZCBkaW1zLlxuICAgKlxuICAgKiBUZW5zb3IncyBsb2NhdGlvbiB3aWxsIGJlIHNldCB0byAnY3B1LXBpbm5lZCcuXG4gICAqXG4gICAqIEBwYXJhbSBwYXJhbXMgLSBTcGVjaWZ5IHRoZSBwYXJhbWV0ZXJzIHRvIGNvbnN0cnVjdCB0aGUgdGVuc29yLlxuICAgKi9cbiAgY29uc3RydWN0b3IocGFyYW1zOiBDcHVQaW5uZWRDb25zdHJ1Y3RvclBhcmFtZXRlcnMpO1xuICAvKipcbiAgICogQ29uc3RydWN0IGEgbmV3IHRlbnNvciBvYmplY3QgZnJvbSB0aGUgV2ViR0wgdGV4dHVyZSB3aXRoIHRoZSBnaXZlbiB0eXBlIGFuZCBkaW1zLlxuICAgKlxuICAgKiBUZW5zb3IncyBsb2NhdGlvbiB3aWxsIGJlIHNldCB0byAndGV4dHVyZScuXG4gICAqXG4gICAqIEBwYXJhbSBwYXJhbXMgLSBTcGVjaWZ5IHRoZSBwYXJhbWV0ZXJzIHRvIGNvbnN0cnVjdCB0aGUgdGVuc29yLlxuICAgKi9cbiAgY29uc3RydWN0b3IocGFyYW1zOiBUZXh0dXJlQ29uc3RydWN0b3JQYXJhbWV0ZXJzKTtcbiAgLyoqXG4gICAqIENvbnN0cnVjdCBhIG5ldyB0ZW5zb3Igb2JqZWN0IGZyb20gdGhlIFdlYkdQVSBidWZmZXIgd2l0aCB0aGUgZ2l2ZW4gdHlwZSBhbmQgZGltcy5cbiAgICpcbiAgICogVGVuc29yJ3MgbG9jYXRpb24gd2lsbCBiZSBzZXQgdG8gJ2dwdS1idWZmZXInLlxuICAgKlxuICAgKiBAcGFyYW0gcGFyYW1zIC0gU3BlY2lmeSB0aGUgcGFyYW1ldGVycyB0byBjb25zdHJ1Y3QgdGhlIHRlbnNvci5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHBhcmFtczogR3B1QnVmZmVyQ29uc3RydWN0b3JQYXJhbWV0ZXJzKTtcblxuICAvKipcbiAgICogaW1wbGVtZW50YXRpb24uXG4gICAqL1xuICBjb25zdHJ1Y3RvcihcbiAgICAgIGFyZzA6IFRlbnNvclR5cGV8VGVuc29yRGF0YVR5cGV8cmVhZG9ubHkgc3RyaW5nW118cmVhZG9ubHkgYm9vbGVhbltdfENwdVBpbm5lZENvbnN0cnVjdG9yUGFyYW1ldGVyc3xcbiAgICAgIFRleHR1cmVDb25zdHJ1Y3RvclBhcmFtZXRlcnN8R3B1QnVmZmVyQ29uc3RydWN0b3JQYXJhbWV0ZXJzLFxuICAgICAgYXJnMT86IFRlbnNvckRhdGFUeXBlfHJlYWRvbmx5IG51bWJlcltdfHJlYWRvbmx5IHN0cmluZ1tdfHJlYWRvbmx5IGJvb2xlYW5bXSwgYXJnMj86IHJlYWRvbmx5IG51bWJlcltdKSB7XG4gICAgLy8gcGVyZm9ybSBvbmUtdGltZSBjaGVjayBmb3IgQmlnSW50IHN1cHBvcnRcbiAgICBjaGVja0JpZ0ludCgpO1xuXG4gICAgbGV0IHR5cGU6IFRlbnNvclR5cGU7XG4gICAgbGV0IGRpbXM6IHJlYWRvbmx5IG51bWJlcltdO1xuXG4gICAgaWYgKHR5cGVvZiBhcmcwID09PSAnb2JqZWN0JyAmJiAnbG9jYXRpb24nIGluIGFyZzApIHtcbiAgICAgIC8vXG4gICAgICAvLyBjb25zdHJ1Y3RpbmcgdGVuc29yIGZyb20gc3BlY2lmaWMgbG9jYXRpb25cbiAgICAgIC8vXG4gICAgICB0aGlzLmRhdGFMb2NhdGlvbiA9IGFyZzAubG9jYXRpb247XG4gICAgICB0eXBlID0gYXJnMC50eXBlO1xuICAgICAgZGltcyA9IGFyZzAuZGltcztcbiAgICAgIHN3aXRjaCAoYXJnMC5sb2NhdGlvbikge1xuICAgICAgICBjYXNlICdjcHUtcGlubmVkJzoge1xuICAgICAgICAgIGNvbnN0IGV4cGVjdGVkVHlwZWRBcnJheUNvbnN0cnVjdG9yID0gTlVNRVJJQ19URU5TT1JfVFlQRV9UT19UWVBFREFSUkFZX01BUC5nZXQodHlwZSk7XG4gICAgICAgICAgaWYgKCFleHBlY3RlZFR5cGVkQXJyYXlDb25zdHJ1Y3Rvcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgdW5zdXBwb3J0ZWQgdHlwZSBcIiR7dHlwZX1cIiB0byBjcmVhdGUgdGVuc29yIGZyb20gcGlubmVkIGJ1ZmZlcmApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIShhcmcwLmRhdGEgaW5zdGFuY2VvZiBleHBlY3RlZFR5cGVkQXJyYXlDb25zdHJ1Y3RvcikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYGJ1ZmZlciBzaG91bGQgYmUgb2YgdHlwZSAke2V4cGVjdGVkVHlwZWRBcnJheUNvbnN0cnVjdG9yLm5hbWV9YCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuY3B1RGF0YSA9IGFyZzAuZGF0YTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlICd0ZXh0dXJlJzoge1xuICAgICAgICAgIGlmICh0eXBlICE9PSAnZmxvYXQzMicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYHVuc3VwcG9ydGVkIHR5cGUgXCIke3R5cGV9XCIgdG8gY3JlYXRlIHRlbnNvciBmcm9tIHRleHR1cmVgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5ncHVUZXh0dXJlRGF0YSA9IGFyZzAudGV4dHVyZTtcbiAgICAgICAgICB0aGlzLmRvd25sb2FkZXIgPSBhcmcwLmRvd25sb2FkO1xuICAgICAgICAgIHRoaXMuZGlzcG9zZXIgPSBhcmcwLmRpc3Bvc2U7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnZ3B1LWJ1ZmZlcic6IHtcbiAgICAgICAgICBpZiAoKHR5cGUgIT09ICdmbG9hdDMyJyAmJiB0eXBlICE9PSAnZmxvYXQxNicgJiYgdHlwZSAhPT0gJ2ludDMyJyAmJiB0eXBlICE9PSAnaW50NjQnICYmIHR5cGUgIT09ICd1aW50MzInICYmXG4gICAgICAgICAgICAgICB0eXBlICE9PSAnYm9vbCcpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGB1bnN1cHBvcnRlZCB0eXBlIFwiJHt0eXBlfVwiIHRvIGNyZWF0ZSB0ZW5zb3IgZnJvbSBncHUgYnVmZmVyYCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuZ3B1QnVmZmVyRGF0YSA9IGFyZzAuZ3B1QnVmZmVyO1xuICAgICAgICAgIHRoaXMuZG93bmxvYWRlciA9IGFyZzAuZG93bmxvYWQ7XG4gICAgICAgICAgdGhpcy5kaXNwb3NlciA9IGFyZzAuZGlzcG9zZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVGVuc29yIGNvbnN0cnVjdG9yOiB1bnN1cHBvcnRlZCBsb2NhdGlvbiAnJHt0aGlzLmRhdGFMb2NhdGlvbn0nYCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vXG4gICAgICAvLyBjb25zdHJ1Y3RpbmcgdGVuc29yIG9mIGxvY2F0aW9uICdjcHUnXG4gICAgICAvL1xuICAgICAgbGV0IGRhdGE6IFRlbnNvckRhdGFUeXBlO1xuICAgICAgbGV0IG1heWJlRGltczogdHlwZW9mIGFyZzF8dHlwZW9mIGFyZzI7XG4gICAgICAvLyBjaGVjayB3aGV0aGVyIGFyZzAgaXMgdHlwZSBvciBkYXRhXG4gICAgICBpZiAodHlwZW9mIGFyZzAgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIC8vXG4gICAgICAgIC8vIE92ZXJyaWRlOiBjb25zdHJ1Y3Rvcih0eXBlLCBkYXRhLCAuLi4pXG4gICAgICAgIC8vXG4gICAgICAgIHR5cGUgPSBhcmcwO1xuICAgICAgICBtYXliZURpbXMgPSBhcmcyO1xuICAgICAgICBpZiAoYXJnMCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAvLyBzdHJpbmcgdGVuc29yXG4gICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGFyZzEpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBIHN0cmluZyB0ZW5zb3JcXCdzIGRhdGEgbXVzdCBiZSBhIHN0cmluZyBhcnJheS4nKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gd2UgZG9uJ3QgY2hlY2sgd2hldGhlciBldmVyeSBlbGVtZW50IGluIHRoZSBhcnJheSBpcyBzdHJpbmc7IHRoaXMgaXMgdG9vIHNsb3cuIHdlIGFzc3VtZSBpdCdzIGNvcnJlY3QgYW5kXG4gICAgICAgICAgLy8gZXJyb3Igd2lsbCBiZSBwb3B1bGF0ZWQgYXQgaW5mZXJlbmNlXG4gICAgICAgICAgZGF0YSA9IGFyZzE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gbnVtZXJpYyB0ZW5zb3JcbiAgICAgICAgICBjb25zdCB0eXBlZEFycmF5Q29uc3RydWN0b3IgPSBOVU1FUklDX1RFTlNPUl9UWVBFX1RPX1RZUEVEQVJSQVlfTUFQLmdldChhcmcwKTtcbiAgICAgICAgICBpZiAodHlwZWRBcnJheUNvbnN0cnVjdG9yID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFVuc3VwcG9ydGVkIHRlbnNvciB0eXBlOiAke2FyZzB9LmApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhcmcxKSkge1xuICAgICAgICAgICAgaWYgKGFyZzAgPT09ICdmbG9hdDE2Jykge1xuICAgICAgICAgICAgICAvLyBUaHJvdyBlcnJvciBoZXJlIGJlY2F1c2Ugd2hlbiB1c2VyIHRyeSB0byB1c2UgbnVtYmVyIGFycmF5IGFzIGRhdGEsXG4gICAgICAgICAgICAgIC8vIGUuZy4gbmV3IFRlbnNvcignZmxvYXQxNicsIFsxLCAyLCAzLCA0XSwgZGltcykpLCBpdCB3aWxsIGFjdHVhbGx5IGNhbGxcbiAgICAgICAgICAgICAgLy8gVWludDE2QXJyYXkuZnJvbShhcmcxKSB3aGljaCBnZW5lcmF0ZXMgd3JvbmcgZGF0YS5cbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgICAgICAgICdDcmVhdGluZyBhIGZsb2F0MTYgdGVuc29yIGZyb20gbnVtYmVyIGFycmF5IGlzIG5vdCBzdXBwb3J0ZWQuIFBsZWFzZSB1c2UgVWludDE2QXJyYXkgYXMgZGF0YS4nKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYXJnMCA9PT0gJ3VpbnQ2NCcgfHwgYXJnMCA9PT0gJ2ludDY0Jykge1xuICAgICAgICAgICAgICAvLyB1c2UgJ2FzIGFueScgaGVyZSBiZWNhdXNlOlxuICAgICAgICAgICAgICAvLyAxLiBUeXBlU2NyaXB0J3MgY2hlY2sgb24gdHlwZSBvZiAnQXJyYXkuaXNBcnJheSgpJyBkb2VzIG5vdCB3b3JrIHdpdGggcmVhZG9ubHkgYXJyYXlzLlxuICAgICAgICAgICAgICAvLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL21pY3Jvc29mdC9UeXBlU2NyaXB0L2lzc3Vlcy8xNzAwMlxuICAgICAgICAgICAgICAvLyAyLiBUeXBlU2NyaXB0J3MgY2hlY2sgb24gdW5pb24gdHlwZSBvZiAnKEJpZ0ludDY0QXJyYXlDb25zdHJ1Y3RvcnxCaWdVaW50NjRBcnJheUNvbnN0cnVjdG9yKS5mcm9tKCknXG4gICAgICAgICAgICAgIC8vIGRvZXMgbm90IGFjY2VwdCBwYXJhbWV0ZXIgbWFwRm4uXG4gICAgICAgICAgICAgIC8vIDMuIHBhcmFtZXRlcnMgb2YgJ1N1cHBvcnRlZFR5cGVkQXJyYXlDb25zdHJ1Y3RvcnMuZnJvbSgpJyBkb2VzIG5vdCBtYXRjaCB0aGUgcmVxdWlyZW1lbnQgb2YgdGhlIHVuaW9uXG4gICAgICAgICAgICAgIC8vIHR5cGUuXG5cbiAgICAgICAgICAgICAgLy8gYXNzdW1lICdhcmcxJyBpcyBvZiB0eXBlIFwicmVhZG9ubHkgbnVtYmVyW118cmVhZG9ubHkgYmlnaW50W11cIiBoZXJlLlxuXG4gICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICAgIGRhdGEgPSAodHlwZWRBcnJheUNvbnN0cnVjdG9yIGFzIGFueSkuZnJvbShhcmcxLCBCaWdJbnQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gYXNzdW1lICdhcmcxJyBpcyBvZiB0eXBlIFwicmVhZG9ubHkgbnVtYmVyW11cIiBoZXJlLlxuICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgICBkYXRhID0gKHR5cGVkQXJyYXlDb25zdHJ1Y3RvciBhcyBhbnkpLmZyb20oYXJnMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChhcmcxIGluc3RhbmNlb2YgdHlwZWRBcnJheUNvbnN0cnVjdG9yKSB7XG4gICAgICAgICAgICBkYXRhID0gYXJnMTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgQSAke3R5cGV9IHRlbnNvcidzIGRhdGEgbXVzdCBiZSB0eXBlIG9mICR7dHlwZWRBcnJheUNvbnN0cnVjdG9yfWApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy9cbiAgICAgICAgLy8gT3ZlcnJpZGU6IGNvbnN0cnVjdG9yKGRhdGEsIC4uLilcbiAgICAgICAgLy9cbiAgICAgICAgbWF5YmVEaW1zID0gYXJnMTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYXJnMCkpIHtcbiAgICAgICAgICAvLyBvbmx5IGJvb2xlYW5bXSBhbmQgc3RyaW5nW10gaXMgc3VwcG9ydGVkXG4gICAgICAgICAgaWYgKGFyZzAubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUZW5zb3IgdHlwZSBjYW5ub3QgYmUgaW5mZXJyZWQgZnJvbSBhbiBlbXB0eSBhcnJheS4nKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgZmlyc3RFbGVtZW50VHlwZSA9IHR5cGVvZiBhcmcwWzBdO1xuICAgICAgICAgIGlmIChmaXJzdEVsZW1lbnRUeXBlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdHlwZSA9ICdzdHJpbmcnO1xuICAgICAgICAgICAgZGF0YSA9IGFyZzA7XG4gICAgICAgICAgfSBlbHNlIGlmIChmaXJzdEVsZW1lbnRUeXBlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgIHR5cGUgPSAnYm9vbCc7XG4gICAgICAgICAgICAvLyAnYXJnMCcgaXMgb2YgdHlwZSAnYm9vbGVhbltdJy4gVWludDhBcnJheS5mcm9tKGJvb2xlYW5bXSkgYWN0dWFsbHkgd29ya3MsIGJ1dCB0eXBlc2NyaXB0IHRoaW5rcyB0aGlzIGlzXG4gICAgICAgICAgICAvLyB3cm9uZyB0eXBlLiBXZSB1c2UgJ2FzIGFueScgdG8gbWFrZSBpdCBoYXBweS5cbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICBkYXRhID0gVWludDhBcnJheS5mcm9tKGFyZzAgYXMgYW55W10pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnZhbGlkIGVsZW1lbnQgdHlwZSBvZiBkYXRhIGFycmF5OiAke2ZpcnN0RWxlbWVudFR5cGV9LmApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBnZXQgdGVuc29yIHR5cGUgZnJvbSBUeXBlZEFycmF5XG4gICAgICAgICAgY29uc3QgbWFwcGVkVHlwZSA9XG4gICAgICAgICAgICAgIE5VTUVSSUNfVEVOU09SX1RZUEVEQVJSQVlfVE9fVFlQRV9NQVAuZ2V0KGFyZzAuY29uc3RydWN0b3IgYXMgU3VwcG9ydGVkVHlwZWRBcnJheUNvbnN0cnVjdG9ycyk7XG4gICAgICAgICAgaWYgKG1hcHBlZFR5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVW5zdXBwb3J0ZWQgdHlwZSBmb3IgdGVuc29yIGRhdGE6ICR7YXJnMC5jb25zdHJ1Y3Rvcn0uYCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHR5cGUgPSBtYXBwZWRUeXBlO1xuICAgICAgICAgIGRhdGEgPSBhcmcwIGFzIFN1cHBvcnRlZFR5cGVkQXJyYXk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gdHlwZSBhbmQgZGF0YSBpcyBwcm9jZXNzZWQsIG5vdyBwcm9jZXNzaW5nIGRpbXNcbiAgICAgIGlmIChtYXliZURpbXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBhc3N1bWUgMS1EIHRlbnNvciBpZiBkaW1zIG9taXR0ZWRcbiAgICAgICAgbWF5YmVEaW1zID0gW2RhdGEubGVuZ3RoXTtcbiAgICAgIH0gZWxzZSBpZiAoIUFycmF5LmlzQXJyYXkobWF5YmVEaW1zKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBIHRlbnNvclxcJ3MgZGltcyBtdXN0IGJlIGEgbnVtYmVyIGFycmF5Jyk7XG4gICAgICB9XG4gICAgICBkaW1zID0gbWF5YmVEaW1zIGFzIHJlYWRvbmx5IG51bWJlcltdO1xuXG4gICAgICB0aGlzLmNwdURhdGEgPSBkYXRhO1xuICAgICAgdGhpcy5kYXRhTG9jYXRpb24gPSAnY3B1JztcbiAgICB9XG5cbiAgICAvLyBwZXJmb3JtIGNoZWNrIG9uIGRpbXNcbiAgICBjb25zdCBzaXplID0gY2FsY3VsYXRlU2l6ZShkaW1zKTtcbiAgICAvLyBpZiBkYXRhIGlzIG9uIENQVSwgY2hlY2sgd2hldGhlciBkYXRhIGxlbmd0aCBtYXRjaGVzIHRlbnNvciBzaXplXG4gICAgaWYgKHRoaXMuY3B1RGF0YSAmJiBzaXplICE9PSB0aGlzLmNwdURhdGEubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFRlbnNvcidzIHNpemUoJHtzaXplfSkgZG9lcyBub3QgbWF0Y2ggZGF0YSBsZW5ndGgoJHt0aGlzLmNwdURhdGEubGVuZ3RofSkuYCk7XG4gICAgfVxuXG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB0aGlzLmRpbXMgPSBkaW1zO1xuICAgIHRoaXMuc2l6ZSA9IHNpemU7XG4gIH1cbiAgLy8gI2VuZHJlZ2lvblxuXG4gIC8vICNyZWdpb24gZmFjdG9yeVxuICBzdGF0aWMgYXN5bmMgZnJvbUltYWdlKFxuICAgICAgaW1hZ2U6IEltYWdlRGF0YXxIVE1MSW1hZ2VFbGVtZW50fEltYWdlQml0bWFwfHN0cmluZyxcbiAgICAgIG9wdGlvbnM/OiBUZW5zb3JGcm9tSW1hZ2VEYXRhT3B0aW9uc3xUZW5zb3JGcm9tSW1hZ2VFbGVtZW50T3B0aW9uc3xUZW5zb3JGcm9tSW1hZ2VCaXRtYXBPcHRpb25zfFxuICAgICAgVGVuc29yRnJvbVVybE9wdGlvbnMpOiBQcm9taXNlPFRlbnNvckludGVyZmFjZT4ge1xuICAgIHJldHVybiB0ZW5zb3JGcm9tSW1hZ2UoaW1hZ2UsIG9wdGlvbnMpO1xuICB9XG5cbiAgc3RhdGljIGZyb21UZXh0dXJlPFQgZXh0ZW5kcyBUZW5zb3JJbnRlcmZhY2UuVGV4dHVyZURhdGFUeXBlcz4oXG4gICAgICB0ZXh0dXJlOiBUZW5zb3JUZXh0dXJlVHlwZSwgb3B0aW9uczogVGVuc29yRnJvbVRleHR1cmVPcHRpb25zPFQ+KTogVGVuc29ySW50ZXJmYWNlIHtcbiAgICByZXR1cm4gdGVuc29yRnJvbVRleHR1cmUodGV4dHVyZSwgb3B0aW9ucyk7XG4gIH1cblxuICBzdGF0aWMgZnJvbUdwdUJ1ZmZlcjxUIGV4dGVuZHMgVGVuc29ySW50ZXJmYWNlLkdwdUJ1ZmZlckRhdGFUeXBlcz4oXG4gICAgICBncHVCdWZmZXI6IFRlbnNvckdwdUJ1ZmZlclR5cGUsIG9wdGlvbnM6IFRlbnNvckZyb21HcHVCdWZmZXJPcHRpb25zPFQ+KTogVGVuc29ySW50ZXJmYWNlIHtcbiAgICByZXR1cm4gdGVuc29yRnJvbUdwdUJ1ZmZlcihncHVCdWZmZXIsIG9wdGlvbnMpO1xuICB9XG5cbiAgc3RhdGljIGZyb21QaW5uZWRCdWZmZXI8VCBleHRlbmRzIFRlbnNvckludGVyZmFjZS5DcHVQaW5uZWREYXRhVHlwZXM+KFxuICAgICAgdHlwZTogVCwgYnVmZmVyOiBUZW5zb3JJbnRlcmZhY2UuRGF0YVR5cGVNYXBbVF0sIGRpbXM/OiByZWFkb25seSBudW1iZXJbXSk6IFRlbnNvciB7XG4gICAgcmV0dXJuIHRlbnNvckZyb21QaW5uZWRCdWZmZXIodHlwZSwgYnVmZmVyLCBkaW1zKTtcbiAgfVxuXG4gIC8vICNlbmRyZWdpb25cblxuICAvLyAjcmVnaW9uIGNvbnZlcnNpb25zXG4gIHRvRGF0YVVSTChvcHRpb25zPzogVGVuc29yVG9EYXRhVXJsT3B0aW9ucyk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRlbnNvclRvRGF0YVVSTCh0aGlzLCBvcHRpb25zKTtcbiAgfVxuXG4gIHRvSW1hZ2VEYXRhKG9wdGlvbnM/OiBUZW5zb3JUb0ltYWdlRGF0YU9wdGlvbnMpOiBJbWFnZURhdGEge1xuICAgIHJldHVybiB0ZW5zb3JUb0ltYWdlRGF0YSh0aGlzLCBvcHRpb25zKTtcbiAgfVxuICAvLyAjZW5kcmVnaW9uXG5cbiAgLy8gI3JlZ2lvbiBwdWJsaWMgZmllbGRzXG4gIHJlYWRvbmx5IGRpbXM6IHJlYWRvbmx5IG51bWJlcltdO1xuICByZWFkb25seSB0eXBlOiBUZW5zb3JUeXBlO1xuICByZWFkb25seSBzaXplOiBudW1iZXI7XG4gIC8vICNlbmRyZWdpb25cblxuICAvLyAjcmVnaW9uIHByaXZhdGUgZmllbGRzXG5cbiAgLyoqXG4gICAqIHN0b3JlcyB0aGUgbG9jYXRpb24gb2YgdGhlIGRhdGEuXG4gICAqL1xuICBwcml2YXRlIGRhdGFMb2NhdGlvbjogVGVuc29yRGF0YUxvY2F0aW9uO1xuXG4gIC8qKlxuICAgKiBzdG9yZXMgdGhlIGRhdGEgb24gQ1BVLCBpZiBsb2NhdGlvbiBpcyAnY3B1JyBvciAnY3B1LXBpbm5lZCcuIG90aGVyd2lzZSBlbXB0eS5cbiAgICovXG4gIHByaXZhdGUgY3B1RGF0YT86IFRlbnNvckRhdGFUeXBlO1xuXG4gIC8qKlxuICAgKiBzdG9yZXMgdGhlIHVuZGVybHlpbmcgdGV4dHVyZSB3aGVuIGxvY2F0aW9uIGlzICd0ZXh0dXJlJy4gb3RoZXJ3aXNlIGVtcHR5LlxuICAgKi9cbiAgcHJpdmF0ZSBncHVUZXh0dXJlRGF0YT86IFRlbnNvclRleHR1cmVUeXBlO1xuXG4gIC8qKlxuICAgKiBzdG9yZXMgdGhlIHVuZGVybHlpbmcgR1BVIGJ1ZmZlciB3aGVuIGxvY2F0aW9uIGlzICdncHUtYnVmZmVyJy4gb3RoZXJ3aXNlIGVtcHR5LlxuICAgKi9cbiAgcHJpdmF0ZSBncHVCdWZmZXJEYXRhPzogVGVuc29yR3B1QnVmZmVyVHlwZTtcblxuICAvKipcbiAgICogc3RvcmVzIGFuIG9wdGlvbmFsIGRvd25sb2FkZXIgZnVuY3Rpb24gdG8gZG93bmxvYWQgZGF0YSBmcm9tIEdQVSB0byBDUFUuXG4gICAqL1xuICBwcml2YXRlIGRvd25sb2FkZXI/KCk6IFByb21pc2U8VGVuc29yRGF0YVR5cGU+O1xuXG4gIC8qKlxuICAgKiBhIGZsYWcgaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBkYXRhIGlzIGJlaW5nIGRvd25sb2FkZWQgZnJvbSBHUFUgdG8gQ1BVLlxuICAgKi9cbiAgcHJpdmF0ZSBpc0Rvd25sb2FkaW5nPzogYm9vbGVhbjtcblxuICAvKipcbiAgICogc3RvcmVzIGFuIG9wdGlvbmFsIGRpc3Bvc2VyIGZ1bmN0aW9uIHRvIGRpc3Bvc2UgdGhlIHVuZGVybHlpbmcgZGF0YS5cbiAgICovXG4gIHByaXZhdGUgZGlzcG9zZXI/KCk6IHZvaWQ7XG4gIC8vICNlbmRyZWdpb25cblxuICAvLyAjcmVnaW9uIHByb3BlcnRpZXNcbiAgZ2V0IGRhdGEoKTogVGVuc29yRGF0YVR5cGUge1xuICAgIHRoaXMuZW5zdXJlVmFsaWQoKTtcbiAgICBpZiAoIXRoaXMuY3B1RGF0YSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICdUaGUgZGF0YSBpcyBub3Qgb24gQ1BVLiBVc2UgYGdldERhdGEoKWAgdG8gZG93bmxvYWQgR1BVIGRhdGEgdG8gQ1BVLCAnICtcbiAgICAgICAgICAnb3IgdXNlIGB0ZXh0dXJlYCBvciBgZ3B1QnVmZmVyYCBwcm9wZXJ0eSB0byBhY2Nlc3MgdGhlIEdQVSBkYXRhIGRpcmVjdGx5LicpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jcHVEYXRhO1xuICB9XG5cbiAgZ2V0IGxvY2F0aW9uKCk6IFRlbnNvckRhdGFMb2NhdGlvbiB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YUxvY2F0aW9uO1xuICB9XG5cbiAgZ2V0IHRleHR1cmUoKTogVGVuc29yVGV4dHVyZVR5cGUge1xuICAgIHRoaXMuZW5zdXJlVmFsaWQoKTtcbiAgICBpZiAoIXRoaXMuZ3B1VGV4dHVyZURhdGEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGRhdGEgaXMgbm90IHN0b3JlZCBhcyBhIFdlYkdMIHRleHR1cmUuJyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmdwdVRleHR1cmVEYXRhO1xuICB9XG5cbiAgZ2V0IGdwdUJ1ZmZlcigpOiBUZW5zb3JHcHVCdWZmZXJUeXBlIHtcbiAgICB0aGlzLmVuc3VyZVZhbGlkKCk7XG4gICAgaWYgKCF0aGlzLmdwdUJ1ZmZlckRhdGEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGRhdGEgaXMgbm90IHN0b3JlZCBhcyBhIFdlYkdQVSBidWZmZXIuJyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmdwdUJ1ZmZlckRhdGE7XG4gIH1cbiAgLy8gI2VuZHJlZ2lvblxuXG4gIC8vICNyZWdpb24gbWV0aG9kc1xuXG4gIGFzeW5jIGdldERhdGEocmVsZWFzZURhdGE/OiBib29sZWFuKTogUHJvbWlzZTxUZW5zb3JEYXRhVHlwZT4ge1xuICAgIHRoaXMuZW5zdXJlVmFsaWQoKTtcbiAgICBzd2l0Y2ggKHRoaXMuZGF0YUxvY2F0aW9uKSB7XG4gICAgICBjYXNlICdjcHUnOlxuICAgICAgY2FzZSAnY3B1LXBpbm5lZCc6XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGE7XG4gICAgICBjYXNlICd0ZXh0dXJlJzpcbiAgICAgIGNhc2UgJ2dwdS1idWZmZXInOiB7XG4gICAgICAgIGlmICghdGhpcy5kb3dubG9hZGVyKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgY3VycmVudCB0ZW5zb3IgaXMgbm90IGNyZWF0ZWQgd2l0aCBhIHNwZWNpZmllZCBkYXRhIGRvd25sb2FkZXIuJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaXNEb3dubG9hZGluZykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGN1cnJlbnQgdGVuc29yIGlzIGJlaW5nIGRvd25sb2FkZWQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0aGlzLmlzRG93bmxvYWRpbmcgPSB0cnVlO1xuICAgICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB0aGlzLmRvd25sb2FkZXIoKTtcbiAgICAgICAgICB0aGlzLmRvd25sb2FkZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgdGhpcy5kYXRhTG9jYXRpb24gPSAnY3B1JztcbiAgICAgICAgICB0aGlzLmNwdURhdGEgPSBkYXRhO1xuXG4gICAgICAgICAgaWYgKHJlbGVhc2VEYXRhICYmIHRoaXMuZGlzcG9zZXIpIHtcbiAgICAgICAgICAgIHRoaXMuZGlzcG9zZXIoKTtcbiAgICAgICAgICAgIHRoaXMuZGlzcG9zZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGRhdGE7XG5cbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICB0aGlzLmlzRG93bmxvYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjYW5ub3QgZ2V0IGRhdGEgZnJvbSBsb2NhdGlvbjogJHt0aGlzLmRhdGFMb2NhdGlvbn1gKTtcbiAgICB9XG4gIH1cblxuICBkaXNwb3NlKCk6IHZvaWQge1xuICAgIGlmICh0aGlzLmlzRG93bmxvYWRpbmcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGN1cnJlbnQgdGVuc29yIGlzIGJlaW5nIGRvd25sb2FkZWQuJyk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZGlzcG9zZXIpIHtcbiAgICAgIHRoaXMuZGlzcG9zZXIoKTtcbiAgICAgIHRoaXMuZGlzcG9zZXIgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHRoaXMuY3B1RGF0YSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmdwdVRleHR1cmVEYXRhID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuZ3B1QnVmZmVyRGF0YSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmRvd25sb2FkZXIgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5pc0Rvd25sb2FkaW5nID0gdW5kZWZpbmVkO1xuXG4gICAgdGhpcy5kYXRhTG9jYXRpb24gPSAnbm9uZSc7XG4gIH1cblxuICAvLyAjZW5kcmVnaW9uXG5cbiAgLy8gI3JlZ2lvbiB0ZW5zb3IgdXRpbGl0aWVzXG4gIHByaXZhdGUgZW5zdXJlVmFsaWQoKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuZGF0YUxvY2F0aW9uID09PSAnbm9uZScpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIHRlbnNvciBpcyBkaXNwb3NlZC4nKTtcbiAgICB9XG4gIH1cblxuICByZXNoYXBlKGRpbXM6IHJlYWRvbmx5IG51bWJlcltdKTogVGVuc29ySW50ZXJmYWNlIHtcbiAgICB0aGlzLmVuc3VyZVZhbGlkKCk7XG4gICAgaWYgKHRoaXMuZG93bmxvYWRlciB8fCB0aGlzLmRpc3Bvc2VyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCByZXNoYXBlIGEgdGVuc29yIHRoYXQgb3ducyBHUFUgcmVzb3VyY2UuJyk7XG4gICAgfVxuICAgIHJldHVybiB0ZW5zb3JSZXNoYXBlKHRoaXMsIGRpbXMpO1xuICB9XG4gIC8vICNlbmRyZWdpb25cbn1cbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtUZW5zb3JGYWN0b3J5fSBmcm9tICcuL3RlbnNvci1mYWN0b3J5LmpzJztcbmltcG9ydCB7VGVuc29yIGFzIFRlbnNvckltcGx9IGZyb20gJy4vdGVuc29yLWltcGwuanMnO1xuaW1wb3J0IHtUeXBlZFRlbnNvclV0aWxzfSBmcm9tICcuL3RlbnNvci11dGlscy5qcyc7XG5cbi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1yZWRlY2xhcmUgKi9cblxuLyoqXG4gKiByZXByZXNlbnQgYSBiYXNpYyB0ZW5zb3Igd2l0aCBzcGVjaWZpZWQgZGltZW5zaW9ucyBhbmQgZGF0YSB0eXBlLlxuICovXG5pbnRlcmZhY2UgVHlwZWRUZW5zb3JCYXNlPFQgZXh0ZW5kcyBUZW5zb3IuVHlwZT4ge1xuICAvKipcbiAgICogR2V0IHRoZSBkaW1lbnNpb25zIG9mIHRoZSB0ZW5zb3IuXG4gICAqL1xuICByZWFkb25seSBkaW1zOiByZWFkb25seSBudW1iZXJbXTtcbiAgLyoqXG4gICAqIEdldCB0aGUgZGF0YSB0eXBlIG9mIHRoZSB0ZW5zb3IuXG4gICAqL1xuICByZWFkb25seSB0eXBlOiBUO1xuICAvKipcbiAgICogR2V0IHRoZSBidWZmZXIgZGF0YSBvZiB0aGUgdGVuc29yLlxuICAgKlxuICAgKiBJZiB0aGUgZGF0YSBpcyBub3Qgb24gQ1BVIChlZy4gaXQncyBpbiB0aGUgZm9ybSBvZiBXZWJHTCB0ZXh0dXJlIG9yIFdlYkdQVSBidWZmZXIpLCB0aHJvdyBlcnJvci5cbiAgICovXG4gIHJlYWRvbmx5IGRhdGE6IFRlbnNvci5EYXRhVHlwZU1hcFtUXTtcbiAgLyoqXG4gICAqIEdldCB0aGUgbG9jYXRpb24gb2YgdGhlIGRhdGEuXG4gICAqL1xuICByZWFkb25seSBsb2NhdGlvbjogVGVuc29yLkRhdGFMb2NhdGlvbjtcbiAgLyoqXG4gICAqIEdldCB0aGUgV2ViR0wgdGV4dHVyZSB0aGF0IGhvbGRzIHRoZSB0ZW5zb3IgZGF0YS5cbiAgICpcbiAgICogSWYgdGhlIGRhdGEgaXMgbm90IG9uIEdQVSBhcyBXZWJHTCB0ZXh0dXJlLCB0aHJvdyBlcnJvci5cbiAgICovXG4gIHJlYWRvbmx5IHRleHR1cmU6IFRlbnNvci5UZXh0dXJlVHlwZTtcbiAgLyoqXG4gICAqIEdldCB0aGUgV2ViR1BVIGJ1ZmZlciB0aGF0IGhvbGRzIHRoZSB0ZW5zb3IgZGF0YS5cbiAgICpcbiAgICogSWYgdGhlIGRhdGEgaXMgbm90IG9uIEdQVSBhcyBXZWJHUFUgYnVmZmVyLCB0aHJvdyBlcnJvci5cbiAgICovXG4gIHJlYWRvbmx5IGdwdUJ1ZmZlcjogVGVuc29yLkdwdUJ1ZmZlclR5cGU7XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgYnVmZmVyIGRhdGEgb2YgdGhlIHRlbnNvci5cbiAgICpcbiAgICogSWYgdGhlIGRhdGEgaXMgb24gQ1BVLCByZXR1cm5zIHRoZSBkYXRhIGltbWVkaWF0ZWx5LlxuICAgKiBJZiB0aGUgZGF0YSBpcyBvbiBHUFUsIGRvd25sb2FkcyB0aGUgZGF0YSBhbmQgcmV0dXJucyB0aGUgcHJvbWlzZS5cbiAgICpcbiAgICogQHBhcmFtIHJlbGVhc2VEYXRhIC0gd2hldGhlciByZWxlYXNlIHRoZSBkYXRhIG9uIEdQVS4gSWdub3JlIGlmIGRhdGEgaXMgYWxyZWFkeSBvbiBDUFUuXG4gICAqL1xuICBnZXREYXRhKHJlbGVhc2VEYXRhPzogYm9vbGVhbik6IFByb21pc2U8VGVuc29yLkRhdGFUeXBlTWFwW1RdPjtcblxuICAvKipcbiAgICogRGlzcG9zZSB0aGUgdGVuc29yIGRhdGEuXG4gICAqXG4gICAqIElmIHRoZSBkYXRhIGlzIG9uIENQVSwgcmVtb3ZlIGl0cyBpbnRlcm5hbCByZWZlcmVuY2UgdG8gdGhlIHVuZGVybHlpbmcgZGF0YS5cbiAgICogSWYgdGhlIGRhdGEgaXMgb24gR1BVLCByZWxlYXNlIHRoZSBkYXRhIG9uIEdQVS5cbiAgICpcbiAgICogQWZ0ZXIgY2FsbGluZyB0aGlzIGZ1bmN0aW9uLCB0aGUgdGVuc29yIGlzIGNvbnNpZGVyZWQgbm8gbG9uZ2VyIHZhbGlkLiBJdHMgbG9jYXRpb24gd2lsbCBiZSBzZXQgdG8gJ25vbmUnLlxuICAgKi9cbiAgZGlzcG9zZSgpOiB2b2lkO1xufVxuXG5leHBvcnQgZGVjbGFyZSBuYW1lc3BhY2UgVGVuc29yIHtcbiAgaW50ZXJmYWNlIERhdGFUeXBlTWFwIHtcbiAgICBmbG9hdDMyOiBGbG9hdDMyQXJyYXk7XG4gICAgdWludDg6IFVpbnQ4QXJyYXk7XG4gICAgaW50ODogSW50OEFycmF5O1xuICAgIHVpbnQxNjogVWludDE2QXJyYXk7XG4gICAgaW50MTY6IEludDE2QXJyYXk7XG4gICAgaW50MzI6IEludDMyQXJyYXk7XG4gICAgaW50NjQ6IEJpZ0ludDY0QXJyYXk7XG4gICAgc3RyaW5nOiBzdHJpbmdbXTtcbiAgICBib29sOiBVaW50OEFycmF5O1xuICAgIGZsb2F0MTY6IFVpbnQxNkFycmF5OyAgLy8gS2VlcCB1c2luZyBVaW50MTZBcnJheSB1bnRpbCB3ZSBoYXZlIGEgY29uY3JldGUgc29sdXRpb24gZm9yIGZsb2F0IDE2LlxuICAgIGZsb2F0NjQ6IEZsb2F0NjRBcnJheTtcbiAgICB1aW50MzI6IFVpbnQzMkFycmF5O1xuICAgIHVpbnQ2NDogQmlnVWludDY0QXJyYXk7XG4gICAgLy8gY29tcGxleDY0OiBuZXZlcjtcbiAgICAvLyBjb21wbGV4MTI4OiBuZXZlcjtcbiAgICAvLyBiZmxvYXQxNjogbmV2ZXI7XG4gIH1cblxuICBpbnRlcmZhY2UgRWxlbWVudFR5cGVNYXAge1xuICAgIGZsb2F0MzI6IG51bWJlcjtcbiAgICB1aW50ODogbnVtYmVyO1xuICAgIGludDg6IG51bWJlcjtcbiAgICB1aW50MTY6IG51bWJlcjtcbiAgICBpbnQxNjogbnVtYmVyO1xuICAgIGludDMyOiBudW1iZXI7XG4gICAgaW50NjQ6IGJpZ2ludDtcbiAgICBzdHJpbmc6IHN0cmluZztcbiAgICBib29sOiBib29sZWFuO1xuICAgIGZsb2F0MTY6IG51bWJlcjsgIC8vIEtlZXAgdXNpbmcgVWludDE2QXJyYXkgdW50aWwgd2UgaGF2ZSBhIGNvbmNyZXRlIHNvbHV0aW9uIGZvciBmbG9hdCAxNi5cbiAgICBmbG9hdDY0OiBudW1iZXI7XG4gICAgdWludDMyOiBudW1iZXI7XG4gICAgdWludDY0OiBiaWdpbnQ7XG4gICAgLy8gY29tcGxleDY0OiBuZXZlcjtcbiAgICAvLyBjb21wbGV4MTI4OiBuZXZlcjtcbiAgICAvLyBiZmxvYXQxNjogbmV2ZXI7XG4gIH1cblxuICB0eXBlIERhdGFUeXBlID0gRGF0YVR5cGVNYXBbVHlwZV07XG4gIHR5cGUgRWxlbWVudFR5cGUgPSBFbGVtZW50VHlwZU1hcFtUeXBlXTtcblxuICAvKipcbiAgICogc3VwcG9ydGVkIGRhdGEgdHlwZXMgZm9yIGNvbnN0cnVjdGluZyBhIHRlbnNvciBmcm9tIGEgcGlubmVkIENQVSBidWZmZXJcbiAgICovXG4gIGV4cG9ydCB0eXBlIENwdVBpbm5lZERhdGFUeXBlcyA9IEV4Y2x1ZGU8VGVuc29yLlR5cGUsICdzdHJpbmcnPjtcblxuICAvKipcbiAgICogdHlwZSBhbGlhcyBmb3IgV2ViR0wgdGV4dHVyZVxuICAgKi9cbiAgZXhwb3J0IHR5cGUgVGV4dHVyZVR5cGUgPSBXZWJHTFRleHR1cmU7XG5cbiAgLyoqXG4gICAqIHN1cHBvcnRlZCBkYXRhIHR5cGVzIGZvciBjb25zdHJ1Y3RpbmcgYSB0ZW5zb3IgZnJvbSBhIFdlYkdMIHRleHR1cmVcbiAgICovXG4gIGV4cG9ydCB0eXBlIFRleHR1cmVEYXRhVHlwZXMgPSAnZmxvYXQzMic7XG5cbiAgLyoqXG4gICAqIHR5cGUgYWxpYXMgZm9yIFdlYkdQVSBidWZmZXJcbiAgICpcbiAgICogVGhlIHJlYXNvbiB3aHkgd2UgZG9uJ3QgdXNlIHR5cGUgXCJHUFVCdWZmZXJcIiBkZWZpbmVkIGluIHdlYmdwdS5kLnRzIGZyb20gQHdlYmdwdS90eXBlcyBpcyBiZWNhdXNlIFwiQHdlYmdwdS90eXBlc1wiXG4gICAqIHJlcXVpcmVzIFwiQHR5cGVzL2RvbS13ZWJjb2RlY3NcIiBhcyBwZWVyIGRlcGVuZGVuY3kgd2hlbiB1c2luZyBUeXBlU2NyaXB0IDwgdjUuMSBhbmQgaXRzIHZlcnNpb24gbmVlZCB0byBiZSBjaG9zZW5cbiAgICogY2FyZWZ1bGx5IGFjY29yZGluZyB0byB0aGUgVHlwZVNjcmlwdCB2ZXJzaW9uIGJlaW5nIHVzZWQuIFRoaXMgbWVhbnMgc28gZmFyIHRoZXJlIGlzIG5vdCBhIHdheSB0byBrZWVwIGV2ZXJ5XG4gICAqIFR5cGVTY3JpcHQgdmVyc2lvbiBoYXBweS4gSXQgdHVybnMgb3V0IHRoYXQgd2Ugd2lsbCBlYXNpbHkgYnJva2UgdXNlcnMgb24gc29tZSBUeXBlU2NyaXB0IHZlcnNpb24uXG4gICAqXG4gICAqIGZvciBtb3JlIGluZm8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9ncHV3ZWIvdHlwZXMvaXNzdWVzLzEyN1xuICAgKi9cbiAgZXhwb3J0IHR5cGUgR3B1QnVmZmVyVHlwZSA9IHtzaXplOiBudW1iZXI7IG1hcFN0YXRlOiAndW5tYXBwZWQnIHwgJ3BlbmRpbmcnIHwgJ21hcHBlZCd9O1xuXG4gIC8qKlxuICAgKiBzdXBwb3J0ZWQgZGF0YSB0eXBlcyBmb3IgY29uc3RydWN0aW5nIGEgdGVuc29yIGZyb20gYSBXZWJHUFUgYnVmZmVyXG4gICAqL1xuICBleHBvcnQgdHlwZSBHcHVCdWZmZXJEYXRhVHlwZXMgPSAnZmxvYXQzMid8J2Zsb2F0MTYnfCdpbnQzMid8J2ludDY0J3wndWludDMyJ3wnYm9vbCc7XG5cbiAgLyoqXG4gICAqIHJlcHJlc2VudCB3aGVyZSB0aGUgdGVuc29yIGRhdGEgaXMgc3RvcmVkXG4gICAqL1xuICBleHBvcnQgdHlwZSBEYXRhTG9jYXRpb24gPSAnbm9uZSd8J2NwdSd8J2NwdS1waW5uZWQnfCd0ZXh0dXJlJ3wnZ3B1LWJ1ZmZlcic7XG5cbiAgLyoqXG4gICAqIHJlcHJlc2VudCB0aGUgZGF0YSB0eXBlIG9mIGEgdGVuc29yXG4gICAqL1xuICBleHBvcnQgdHlwZSBUeXBlID0ga2V5b2YgRGF0YVR5cGVNYXA7XG59XG5cbi8qKlxuICogUmVwcmVzZW50IG11bHRpLWRpbWVuc2lvbmFsIGFycmF5cyB0byBmZWVkIHRvIG9yIGZldGNoIGZyb20gbW9kZWwgaW5mZXJlbmNpbmcuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgVHlwZWRUZW5zb3I8VCBleHRlbmRzIFRlbnNvci5UeXBlPiBleHRlbmRzIFR5cGVkVGVuc29yQmFzZTxUPiwgVHlwZWRUZW5zb3JVdGlsczxUPiB7fVxuLyoqXG4gKiBSZXByZXNlbnQgbXVsdGktZGltZW5zaW9uYWwgYXJyYXlzIHRvIGZlZWQgdG8gb3IgZmV0Y2ggZnJvbSBtb2RlbCBpbmZlcmVuY2luZy5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBUZW5zb3IgZXh0ZW5kcyBUeXBlZFRlbnNvckJhc2U8VGVuc29yLlR5cGU+LCBUeXBlZFRlbnNvclV0aWxzPFRlbnNvci5UeXBlPiB7fVxuXG4vKipcbiAqIHR5cGUgVGVuc29yQ29uc3RydWN0b3IgZGVmaW5lcyB0aGUgY29uc3RydWN0b3JzIG9mICdUZW5zb3InIHRvIGNyZWF0ZSBDUFUgdGVuc29yIGluc3RhbmNlcy5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBUZW5zb3JDb25zdHJ1Y3RvciB7XG4gIC8vICNyZWdpb24gQ1BVIHRlbnNvciAtIHNwZWNpZnkgZWxlbWVudCB0eXBlXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3QgYSBuZXcgc3RyaW5nIHRlbnNvciBvYmplY3QgZnJvbSB0aGUgZ2l2ZW4gdHlwZSwgZGF0YSBhbmQgZGltcy5cbiAgICpcbiAgICogQHBhcmFtIHR5cGUgLSBTcGVjaWZ5IHRoZSBlbGVtZW50IHR5cGUuXG4gICAqIEBwYXJhbSBkYXRhIC0gU3BlY2lmeSB0aGUgQ1BVIHRlbnNvciBkYXRhLlxuICAgKiBAcGFyYW0gZGltcyAtIFNwZWNpZnkgdGhlIGRpbWVuc2lvbiBvZiB0aGUgdGVuc29yLiBJZiBvbWl0dGVkLCBhIDEtRCB0ZW5zb3IgaXMgYXNzdW1lZC5cbiAgICovXG4gIG5ldyh0eXBlOiAnc3RyaW5nJywgZGF0YTogVGVuc29yLkRhdGFUeXBlTWFwWydzdHJpbmcnXXxyZWFkb25seSBzdHJpbmdbXSxcbiAgICAgIGRpbXM/OiByZWFkb25seSBudW1iZXJbXSk6IFR5cGVkVGVuc29yPCdzdHJpbmcnPjtcblxuICAvKipcbiAgICogQ29uc3RydWN0IGEgbmV3IGJvb2wgdGVuc29yIG9iamVjdCBmcm9tIHRoZSBnaXZlbiB0eXBlLCBkYXRhIGFuZCBkaW1zLlxuICAgKlxuICAgKiBAcGFyYW0gdHlwZSAtIFNwZWNpZnkgdGhlIGVsZW1lbnQgdHlwZS5cbiAgICogQHBhcmFtIGRhdGEgLSBTcGVjaWZ5IHRoZSBDUFUgdGVuc29yIGRhdGEuXG4gICAqIEBwYXJhbSBkaW1zIC0gU3BlY2lmeSB0aGUgZGltZW5zaW9uIG9mIHRoZSB0ZW5zb3IuIElmIG9taXR0ZWQsIGEgMS1EIHRlbnNvciBpcyBhc3N1bWVkLlxuICAgKi9cbiAgbmV3KHR5cGU6ICdib29sJywgZGF0YTogVGVuc29yLkRhdGFUeXBlTWFwWydib29sJ118cmVhZG9ubHkgYm9vbGVhbltdLCBkaW1zPzogcmVhZG9ubHkgbnVtYmVyW10pOiBUeXBlZFRlbnNvcjwnYm9vbCc+O1xuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3QgYSBuZXcgNjQtYml0IGludGVnZXIgdHlwZWQgdGVuc29yIG9iamVjdCBmcm9tIHRoZSBnaXZlbiB0eXBlLCBkYXRhIGFuZCBkaW1zLlxuICAgKlxuICAgKiBAcGFyYW0gdHlwZSAtIFNwZWNpZnkgdGhlIGVsZW1lbnQgdHlwZS5cbiAgICogQHBhcmFtIGRhdGEgLSBTcGVjaWZ5IHRoZSBDUFUgdGVuc29yIGRhdGEuXG4gICAqIEBwYXJhbSBkaW1zIC0gU3BlY2lmeSB0aGUgZGltZW5zaW9uIG9mIHRoZSB0ZW5zb3IuIElmIG9taXR0ZWQsIGEgMS1EIHRlbnNvciBpcyBhc3N1bWVkLlxuICAgKi9cbiAgbmV3PFQgZXh0ZW5kcyAndWludDY0J3wnaW50NjQnPihcbiAgICAgIHR5cGU6IFQsIGRhdGE6IFRlbnNvci5EYXRhVHlwZU1hcFtUXXxyZWFkb25seSBiaWdpbnRbXXxyZWFkb25seSBudW1iZXJbXSxcbiAgICAgIGRpbXM/OiByZWFkb25seSBudW1iZXJbXSk6IFR5cGVkVGVuc29yPFQ+O1xuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3QgYSBuZXcgbnVtZXJpYyB0ZW5zb3Igb2JqZWN0IGZyb20gdGhlIGdpdmVuIHR5cGUsIGRhdGEgYW5kIGRpbXMuXG4gICAqXG4gICAqIEBwYXJhbSB0eXBlIC0gU3BlY2lmeSB0aGUgZWxlbWVudCB0eXBlLlxuICAgKiBAcGFyYW0gZGF0YSAtIFNwZWNpZnkgdGhlIENQVSB0ZW5zb3IgZGF0YS5cbiAgICogQHBhcmFtIGRpbXMgLSBTcGVjaWZ5IHRoZSBkaW1lbnNpb24gb2YgdGhlIHRlbnNvci4gSWYgb21pdHRlZCwgYSAxLUQgdGVuc29yIGlzIGFzc3VtZWQuXG4gICAqL1xuICBuZXc8VCBleHRlbmRzIEV4Y2x1ZGU8VGVuc29yLlR5cGUsICdzdHJpbmcnfCdib29sJ3wndWludDY0J3wnaW50NjQnPj4oXG4gICAgICB0eXBlOiBULCBkYXRhOiBUZW5zb3IuRGF0YVR5cGVNYXBbVF18cmVhZG9ubHkgbnVtYmVyW10sIGRpbXM/OiByZWFkb25seSBudW1iZXJbXSk6IFR5cGVkVGVuc29yPFQ+O1xuICAvLyAjZW5kcmVnaW9uXG5cbiAgLy8gI3JlZ2lvbiBDUFUgdGVuc29yIC0gaW5mZXIgZWxlbWVudCB0eXBlc1xuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3QgYSBuZXcgZmxvYXQzMiB0ZW5zb3Igb2JqZWN0IGZyb20gdGhlIGdpdmVuIGRhdGEgYW5kIGRpbXMuXG4gICAqXG4gICAqIEBwYXJhbSBkYXRhIC0gU3BlY2lmeSB0aGUgQ1BVIHRlbnNvciBkYXRhLlxuICAgKiBAcGFyYW0gZGltcyAtIFNwZWNpZnkgdGhlIGRpbWVuc2lvbiBvZiB0aGUgdGVuc29yLiBJZiBvbWl0dGVkLCBhIDEtRCB0ZW5zb3IgaXMgYXNzdW1lZC5cbiAgICovXG4gIG5ldyhkYXRhOiBGbG9hdDMyQXJyYXksIGRpbXM/OiByZWFkb25seSBudW1iZXJbXSk6IFR5cGVkVGVuc29yPCdmbG9hdDMyJz47XG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdCBhIG5ldyBpbnQ4IHRlbnNvciBvYmplY3QgZnJvbSB0aGUgZ2l2ZW4gZGF0YSBhbmQgZGltcy5cbiAgICpcbiAgICogQHBhcmFtIGRhdGEgLSBTcGVjaWZ5IHRoZSBDUFUgdGVuc29yIGRhdGEuXG4gICAqIEBwYXJhbSBkaW1zIC0gU3BlY2lmeSB0aGUgZGltZW5zaW9uIG9mIHRoZSB0ZW5zb3IuIElmIG9taXR0ZWQsIGEgMS1EIHRlbnNvciBpcyBhc3N1bWVkLlxuICAgKi9cbiAgbmV3KGRhdGE6IEludDhBcnJheSwgZGltcz86IHJlYWRvbmx5IG51bWJlcltdKTogVHlwZWRUZW5zb3I8J2ludDgnPjtcblxuICAvKipcbiAgICogQ29uc3RydWN0IGEgbmV3IHVpbnQ4IHRlbnNvciBvYmplY3QgZnJvbSB0aGUgZ2l2ZW4gZGF0YSBhbmQgZGltcy5cbiAgICpcbiAgICogQHBhcmFtIGRhdGEgLSBTcGVjaWZ5IHRoZSBDUFUgdGVuc29yIGRhdGEuXG4gICAqIEBwYXJhbSBkaW1zIC0gU3BlY2lmeSB0aGUgZGltZW5zaW9uIG9mIHRoZSB0ZW5zb3IuIElmIG9taXR0ZWQsIGEgMS1EIHRlbnNvciBpcyBhc3N1bWVkLlxuICAgKi9cbiAgbmV3KGRhdGE6IFVpbnQ4QXJyYXksIGRpbXM/OiByZWFkb25seSBudW1iZXJbXSk6IFR5cGVkVGVuc29yPCd1aW50OCc+O1xuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3QgYSBuZXcgdWludDE2IHRlbnNvciBvYmplY3QgZnJvbSB0aGUgZ2l2ZW4gZGF0YSBhbmQgZGltcy5cbiAgICpcbiAgICogQHBhcmFtIGRhdGEgLSBTcGVjaWZ5IHRoZSBDUFUgdGVuc29yIGRhdGEuXG4gICAqIEBwYXJhbSBkaW1zIC0gU3BlY2lmeSB0aGUgZGltZW5zaW9uIG9mIHRoZSB0ZW5zb3IuIElmIG9taXR0ZWQsIGEgMS1EIHRlbnNvciBpcyBhc3N1bWVkLlxuICAgKi9cbiAgbmV3KGRhdGE6IFVpbnQxNkFycmF5LCBkaW1zPzogcmVhZG9ubHkgbnVtYmVyW10pOiBUeXBlZFRlbnNvcjwndWludDE2Jz47XG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdCBhIG5ldyBpbnQxNiB0ZW5zb3Igb2JqZWN0IGZyb20gdGhlIGdpdmVuIGRhdGEgYW5kIGRpbXMuXG4gICAqXG4gICAqIEBwYXJhbSBkYXRhIC0gU3BlY2lmeSB0aGUgQ1BVIHRlbnNvciBkYXRhLlxuICAgKiBAcGFyYW0gZGltcyAtIFNwZWNpZnkgdGhlIGRpbWVuc2lvbiBvZiB0aGUgdGVuc29yLiBJZiBvbWl0dGVkLCBhIDEtRCB0ZW5zb3IgaXMgYXNzdW1lZC5cbiAgICovXG4gIG5ldyhkYXRhOiBJbnQxNkFycmF5LCBkaW1zPzogcmVhZG9ubHkgbnVtYmVyW10pOiBUeXBlZFRlbnNvcjwnaW50MTYnPjtcblxuICAvKipcbiAgICogQ29uc3RydWN0IGEgbmV3IGludDMyIHRlbnNvciBvYmplY3QgZnJvbSB0aGUgZ2l2ZW4gZGF0YSBhbmQgZGltcy5cbiAgICpcbiAgICogQHBhcmFtIGRhdGEgLSBTcGVjaWZ5IHRoZSBDUFUgdGVuc29yIGRhdGEuXG4gICAqIEBwYXJhbSBkaW1zIC0gU3BlY2lmeSB0aGUgZGltZW5zaW9uIG9mIHRoZSB0ZW5zb3IuIElmIG9taXR0ZWQsIGEgMS1EIHRlbnNvciBpcyBhc3N1bWVkLlxuICAgKi9cbiAgbmV3KGRhdGE6IEludDMyQXJyYXksIGRpbXM/OiByZWFkb25seSBudW1iZXJbXSk6IFR5cGVkVGVuc29yPCdpbnQzMic+O1xuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3QgYSBuZXcgaW50NjQgdGVuc29yIG9iamVjdCBmcm9tIHRoZSBnaXZlbiBkYXRhIGFuZCBkaW1zLlxuICAgKlxuICAgKiBAcGFyYW0gZGF0YSAtIFNwZWNpZnkgdGhlIENQVSB0ZW5zb3IgZGF0YS5cbiAgICogQHBhcmFtIGRpbXMgLSBTcGVjaWZ5IHRoZSBkaW1lbnNpb24gb2YgdGhlIHRlbnNvci4gSWYgb21pdHRlZCwgYSAxLUQgdGVuc29yIGlzIGFzc3VtZWQuXG4gICAqL1xuICBuZXcoZGF0YTogQmlnSW50NjRBcnJheSwgZGltcz86IHJlYWRvbmx5IG51bWJlcltdKTogVHlwZWRUZW5zb3I8J2ludDY0Jz47XG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdCBhIG5ldyBzdHJpbmcgdGVuc29yIG9iamVjdCBmcm9tIHRoZSBnaXZlbiBkYXRhIGFuZCBkaW1zLlxuICAgKlxuICAgKiBAcGFyYW0gZGF0YSAtIFNwZWNpZnkgdGhlIENQVSB0ZW5zb3IgZGF0YS5cbiAgICogQHBhcmFtIGRpbXMgLSBTcGVjaWZ5IHRoZSBkaW1lbnNpb24gb2YgdGhlIHRlbnNvci4gSWYgb21pdHRlZCwgYSAxLUQgdGVuc29yIGlzIGFzc3VtZWQuXG4gICAqL1xuICBuZXcoZGF0YTogcmVhZG9ubHkgc3RyaW5nW10sIGRpbXM/OiByZWFkb25seSBudW1iZXJbXSk6IFR5cGVkVGVuc29yPCdzdHJpbmcnPjtcblxuICAvKipcbiAgICogQ29uc3RydWN0IGEgbmV3IGJvb2wgdGVuc29yIG9iamVjdCBmcm9tIHRoZSBnaXZlbiBkYXRhIGFuZCBkaW1zLlxuICAgKlxuICAgKiBAcGFyYW0gZGF0YSAtIFNwZWNpZnkgdGhlIENQVSB0ZW5zb3IgZGF0YS5cbiAgICogQHBhcmFtIGRpbXMgLSBTcGVjaWZ5IHRoZSBkaW1lbnNpb24gb2YgdGhlIHRlbnNvci4gSWYgb21pdHRlZCwgYSAxLUQgdGVuc29yIGlzIGFzc3VtZWQuXG4gICAqL1xuICBuZXcoZGF0YTogcmVhZG9ubHkgYm9vbGVhbltdLCBkaW1zPzogcmVhZG9ubHkgbnVtYmVyW10pOiBUeXBlZFRlbnNvcjwnYm9vbCc+O1xuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3QgYSBuZXcgZmxvYXQ2NCB0ZW5zb3Igb2JqZWN0IGZyb20gdGhlIGdpdmVuIGRhdGEgYW5kIGRpbXMuXG4gICAqXG4gICAqIEBwYXJhbSBkYXRhIC0gU3BlY2lmeSB0aGUgQ1BVIHRlbnNvciBkYXRhLlxuICAgKiBAcGFyYW0gZGltcyAtIFNwZWNpZnkgdGhlIGRpbWVuc2lvbiBvZiB0aGUgdGVuc29yLiBJZiBvbWl0dGVkLCBhIDEtRCB0ZW5zb3IgaXMgYXNzdW1lZC5cbiAgICovXG4gIG5ldyhkYXRhOiBGbG9hdDY0QXJyYXksIGRpbXM/OiByZWFkb25seSBudW1iZXJbXSk6IFR5cGVkVGVuc29yPCdmbG9hdDY0Jz47XG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdCBhIG5ldyB1aW50MzIgdGVuc29yIG9iamVjdCBmcm9tIHRoZSBnaXZlbiBkYXRhIGFuZCBkaW1zLlxuICAgKlxuICAgKiBAcGFyYW0gZGF0YSAtIFNwZWNpZnkgdGhlIENQVSB0ZW5zb3IgZGF0YS5cbiAgICogQHBhcmFtIGRpbXMgLSBTcGVjaWZ5IHRoZSBkaW1lbnNpb24gb2YgdGhlIHRlbnNvci4gSWYgb21pdHRlZCwgYSAxLUQgdGVuc29yIGlzIGFzc3VtZWQuXG4gICAqL1xuICBuZXcoZGF0YTogVWludDMyQXJyYXksIGRpbXM/OiByZWFkb25seSBudW1iZXJbXSk6IFR5cGVkVGVuc29yPCd1aW50MzInPjtcblxuICAvKipcbiAgICogQ29uc3RydWN0IGEgbmV3IHVpbnQ2NCB0ZW5zb3Igb2JqZWN0IGZyb20gdGhlIGdpdmVuIGRhdGEgYW5kIGRpbXMuXG4gICAqXG4gICAqIEBwYXJhbSBkYXRhIC0gU3BlY2lmeSB0aGUgQ1BVIHRlbnNvciBkYXRhLlxuICAgKiBAcGFyYW0gZGltcyAtIFNwZWNpZnkgdGhlIGRpbWVuc2lvbiBvZiB0aGUgdGVuc29yLiBJZiBvbWl0dGVkLCBhIDEtRCB0ZW5zb3IgaXMgYXNzdW1lZC5cbiAgICovXG4gIG5ldyhkYXRhOiBCaWdVaW50NjRBcnJheSwgZGltcz86IHJlYWRvbmx5IG51bWJlcltdKTogVHlwZWRUZW5zb3I8J3VpbnQ2NCc+O1xuXG4gIC8vICNlbmRyZWdpb25cblxuICAvLyAjcmVnaW9uIENQVSB0ZW5zb3IgLSBmYWxsIGJhY2sgdG8gbm9uLWdlbmVyaWMgdGVuc29yIHR5cGUgZGVjbGFyYXRpb25cblxuICAvKipcbiAgICogQ29uc3RydWN0IGEgbmV3IHRlbnNvciBvYmplY3QgZnJvbSB0aGUgZ2l2ZW4gdHlwZSwgZGF0YSBhbmQgZGltcy5cbiAgICpcbiAgICogQHBhcmFtIHR5cGUgLSBTcGVjaWZ5IHRoZSBlbGVtZW50IHR5cGUuXG4gICAqIEBwYXJhbSBkYXRhIC0gU3BlY2lmeSB0aGUgQ1BVIHRlbnNvciBkYXRhLlxuICAgKiBAcGFyYW0gZGltcyAtIFNwZWNpZnkgdGhlIGRpbWVuc2lvbiBvZiB0aGUgdGVuc29yLiBJZiBvbWl0dGVkLCBhIDEtRCB0ZW5zb3IgaXMgYXNzdW1lZC5cbiAgICovXG4gIG5ldyh0eXBlOiBUZW5zb3IuVHlwZSwgZGF0YTogVGVuc29yLkRhdGFUeXBlfHJlYWRvbmx5IG51bWJlcltdfHJlYWRvbmx5IHN0cmluZ1tdfHJlYWRvbmx5IGJpZ2ludFtdfHJlYWRvbmx5IGJvb2xlYW5bXSxcbiAgICAgIGRpbXM/OiByZWFkb25seSBudW1iZXJbXSk6IFRlbnNvcjtcblxuICAvKipcbiAgICogQ29uc3RydWN0IGEgbmV3IHRlbnNvciBvYmplY3QgZnJvbSB0aGUgZ2l2ZW4gZGF0YSBhbmQgZGltcy5cbiAgICpcbiAgICogQHBhcmFtIGRhdGEgLSBTcGVjaWZ5IHRoZSBDUFUgdGVuc29yIGRhdGEuXG4gICAqIEBwYXJhbSBkaW1zIC0gU3BlY2lmeSB0aGUgZGltZW5zaW9uIG9mIHRoZSB0ZW5zb3IuIElmIG9taXR0ZWQsIGEgMS1EIHRlbnNvciBpcyBhc3N1bWVkLlxuICAgKi9cbiAgbmV3KGRhdGE6IFRlbnNvci5EYXRhVHlwZSwgZGltcz86IHJlYWRvbmx5IG51bWJlcltdKTogVGVuc29yO1xuICAvLyAjZW5kcmVnaW9uXG59XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb25cbmV4cG9ydCBjb25zdCBUZW5zb3IgPSBUZW5zb3JJbXBsIGFzIChUZW5zb3JDb25zdHJ1Y3RvciAmIFRlbnNvckZhY3RvcnkpO1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge2Vudn0gZnJvbSAnLi9lbnYtaW1wbC5qcyc7XG5cbmV4cG9ydCBjb25zdCBUUkFDRSA9IChkZXZpY2VUeXBlOiBzdHJpbmcsIGxhYmVsOiBzdHJpbmcpID0+IHtcbiAgaWYgKCFlbnYud2FzbS50cmFjZSkge1xuICAgIHJldHVybjtcbiAgfVxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICBjb25zb2xlLnRpbWVTdGFtcChgJHtkZXZpY2VUeXBlfTo6T1JUOjoke2xhYmVsfWApO1xufTtcblxuY29uc3QgVFJBQ0VfRlVOQyA9IChtc2c6IHN0cmluZywgZXh0cmFNc2c/OiBzdHJpbmcpID0+IHtcbiAgY29uc3Qgc3RhY2sgPSBuZXcgRXJyb3IoKS5zdGFjaz8uc3BsaXQoL1xcclxcbnxcXHJ8XFxuL2cpIHx8IFtdO1xuICBsZXQgaGFzVHJhY2VGdW5jID0gZmFsc2U7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3RhY2subGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoaGFzVHJhY2VGdW5jICYmICFzdGFja1tpXS5pbmNsdWRlcygnVFJBQ0VfRlVOQycpKSB7XG4gICAgICBsZXQgbGFiZWwgPSBgRlVOQ18ke21zZ306OiR7c3RhY2tbaV0udHJpbSgpLnNwbGl0KCcgJylbMV19YDtcbiAgICAgIGlmIChleHRyYU1zZykge1xuICAgICAgICBsYWJlbCArPSBgOjoke2V4dHJhTXNnfWA7XG4gICAgICB9XG4gICAgICBUUkFDRSgnQ1BVJywgbGFiZWwpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoc3RhY2tbaV0uaW5jbHVkZXMoJ1RSQUNFX0ZVTkMnKSkge1xuICAgICAgaGFzVHJhY2VGdW5jID0gdHJ1ZTtcbiAgICB9XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCBUUkFDRV9GVU5DX0JFR0lOID0gKGV4dHJhTXNnPzogc3RyaW5nKSA9PiB7XG4gIGlmICghZW52Lndhc20udHJhY2UpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgVFJBQ0VfRlVOQygnQkVHSU4nLCBleHRyYU1zZyk7XG59O1xuXG5leHBvcnQgY29uc3QgVFJBQ0VfRlVOQ19FTkQgPSAoZXh0cmFNc2c/OiBzdHJpbmcpID0+IHtcbiAgaWYgKCFlbnYud2FzbS50cmFjZSkge1xuICAgIHJldHVybjtcbiAgfVxuICBUUkFDRV9GVU5DKCdFTkQnLCBleHRyYU1zZyk7XG59O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge3Jlc29sdmVCYWNrZW5kfSBmcm9tICcuL2JhY2tlbmQtaW1wbC5qcyc7XG5pbXBvcnQge0luZmVyZW5jZVNlc3Npb25IYW5kbGVyfSBmcm9tICcuL2JhY2tlbmQuanMnO1xuaW1wb3J0IHtJbmZlcmVuY2VTZXNzaW9uIGFzIEluZmVyZW5jZVNlc3Npb25JbnRlcmZhY2V9IGZyb20gJy4vaW5mZXJlbmNlLXNlc3Npb24uanMnO1xuaW1wb3J0IHtPbm54VmFsdWV9IGZyb20gJy4vb25ueC12YWx1ZS5qcyc7XG5pbXBvcnQge1RlbnNvcn0gZnJvbSAnLi90ZW5zb3IuanMnO1xuaW1wb3J0IHtUUkFDRV9GVU5DX0JFR0lOLCBUUkFDRV9GVU5DX0VORH0gZnJvbSAnLi90cmFjZS5qcyc7XG5cbnR5cGUgU2Vzc2lvbk9wdGlvbnMgPSBJbmZlcmVuY2VTZXNzaW9uSW50ZXJmYWNlLlNlc3Npb25PcHRpb25zO1xudHlwZSBSdW5PcHRpb25zID0gSW5mZXJlbmNlU2Vzc2lvbkludGVyZmFjZS5SdW5PcHRpb25zO1xudHlwZSBGZWVkc1R5cGUgPSBJbmZlcmVuY2VTZXNzaW9uSW50ZXJmYWNlLkZlZWRzVHlwZTtcbnR5cGUgRmV0Y2hlc1R5cGUgPSBJbmZlcmVuY2VTZXNzaW9uSW50ZXJmYWNlLkZldGNoZXNUeXBlO1xudHlwZSBSZXR1cm5UeXBlID0gSW5mZXJlbmNlU2Vzc2lvbkludGVyZmFjZS5SZXR1cm5UeXBlO1xuXG5leHBvcnQgY2xhc3MgSW5mZXJlbmNlU2Vzc2lvbiBpbXBsZW1lbnRzIEluZmVyZW5jZVNlc3Npb25JbnRlcmZhY2Uge1xuICBwcml2YXRlIGNvbnN0cnVjdG9yKGhhbmRsZXI6IEluZmVyZW5jZVNlc3Npb25IYW5kbGVyKSB7XG4gICAgdGhpcy5oYW5kbGVyID0gaGFuZGxlcjtcbiAgfVxuICBydW4oZmVlZHM6IEZlZWRzVHlwZSwgb3B0aW9ucz86IFJ1bk9wdGlvbnMpOiBQcm9taXNlPFJldHVyblR5cGU+O1xuICBydW4oZmVlZHM6IEZlZWRzVHlwZSwgZmV0Y2hlczogRmV0Y2hlc1R5cGUsIG9wdGlvbnM/OiBSdW5PcHRpb25zKTogUHJvbWlzZTxSZXR1cm5UeXBlPjtcbiAgYXN5bmMgcnVuKGZlZWRzOiBGZWVkc1R5cGUsIGFyZzE/OiBGZXRjaGVzVHlwZXxSdW5PcHRpb25zLCBhcmcyPzogUnVuT3B0aW9ucyk6IFByb21pc2U8UmV0dXJuVHlwZT4ge1xuICAgIFRSQUNFX0ZVTkNfQkVHSU4oKTtcbiAgICBjb25zdCBmZXRjaGVzOiB7W25hbWU6IHN0cmluZ106IE9ubnhWYWx1ZXxudWxsfSA9IHt9O1xuICAgIGxldCBvcHRpb25zOiBSdW5PcHRpb25zID0ge307XG4gICAgLy8gY2hlY2sgaW5wdXRzXG4gICAgaWYgKHR5cGVvZiBmZWVkcyAhPT0gJ29iamVjdCcgfHwgZmVlZHMgPT09IG51bGwgfHwgZmVlZHMgaW5zdGFuY2VvZiBUZW5zb3IgfHwgQXJyYXkuaXNBcnJheShmZWVkcykpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgJ1xcJ2ZlZWRzXFwnIG11c3QgYmUgYW4gb2JqZWN0IHRoYXQgdXNlIGlucHV0IG5hbWVzIGFzIGtleXMgYW5kIE9ubnhWYWx1ZSBhcyBjb3JyZXNwb25kaW5nIHZhbHVlcy4nKTtcbiAgICB9XG5cbiAgICBsZXQgaXNGZXRjaGVzRW1wdHkgPSB0cnVlO1xuICAgIC8vIGRldGVybWluZSB3aGljaCBvdmVycmlkZSBpcyBiZWluZyB1c2VkXG4gICAgaWYgKHR5cGVvZiBhcmcxID09PSAnb2JqZWN0Jykge1xuICAgICAgaWYgKGFyZzEgPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5leHBlY3RlZCBhcmd1bWVudFsxXTogY2Fubm90IGJlIG51bGwuJyk7XG4gICAgICB9XG4gICAgICBpZiAoYXJnMSBpbnN0YW5jZW9mIFRlbnNvcikge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcXCdmZXRjaGVzXFwnIGNhbm5vdCBiZSBhIFRlbnNvcicpO1xuICAgICAgfVxuXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShhcmcxKSkge1xuICAgICAgICBpZiAoYXJnMS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcXCdmZXRjaGVzXFwnIGNhbm5vdCBiZSBhbiBlbXB0eSBhcnJheS4nKTtcbiAgICAgICAgfVxuICAgICAgICBpc0ZldGNoZXNFbXB0eSA9IGZhbHNlO1xuICAgICAgICAvLyBvdXRwdXQgbmFtZXNcbiAgICAgICAgZm9yIChjb25zdCBuYW1lIG9mIGFyZzEpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIG5hbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcXCdmZXRjaGVzXFwnIG11c3QgYmUgYSBzdHJpbmcgYXJyYXkgb3IgYW4gb2JqZWN0LicpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodGhpcy5vdXRwdXROYW1lcy5pbmRleE9mKG5hbWUpID09PSAtMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYCdmZXRjaGVzJyBjb250YWlucyBpbnZhbGlkIG91dHB1dCBuYW1lOiAke25hbWV9LmApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmZXRjaGVzW25hbWVdID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgYXJnMiA9PT0gJ29iamVjdCcgJiYgYXJnMiAhPT0gbnVsbCkge1xuICAgICAgICAgIG9wdGlvbnMgPSBhcmcyO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBhcmcyICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1xcJ29wdGlvbnNcXCcgbXVzdCBiZSBhbiBvYmplY3QuJyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGRlY2lkZSB3aGV0aGVyIGFyZzEgaXMgZmV0Y2hlcyBvciBvcHRpb25zXG4gICAgICAgIC8vIGlmIGFueSBvdXRwdXQgbmFtZSBpcyBwcmVzZW50IGFuZCBpdHMgdmFsdWUgaXMgdmFsaWQgT25ueFZhbHVlLCB3ZSBjb25zaWRlciBpdCBmZXRjaGVzXG4gICAgICAgIGxldCBpc0ZldGNoZXMgPSBmYWxzZTtcbiAgICAgICAgY29uc3QgYXJnMUtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhhcmcxKTtcbiAgICAgICAgZm9yIChjb25zdCBuYW1lIG9mIHRoaXMub3V0cHV0TmFtZXMpIHtcbiAgICAgICAgICBpZiAoYXJnMUtleXMuaW5kZXhPZihuYW1lKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIGNvbnN0IHYgPSAoYXJnMSBhcyBJbmZlcmVuY2VTZXNzaW9uSW50ZXJmYWNlLk51bGxhYmxlT25ueFZhbHVlTWFwVHlwZSlbbmFtZV07XG4gICAgICAgICAgICBpZiAodiA9PT0gbnVsbCB8fCB2IGluc3RhbmNlb2YgVGVuc29yKSB7XG4gICAgICAgICAgICAgIGlzRmV0Y2hlcyA9IHRydWU7XG4gICAgICAgICAgICAgIGlzRmV0Y2hlc0VtcHR5ID0gZmFsc2U7XG4gICAgICAgICAgICAgIGZldGNoZXNbbmFtZV0gPSB2O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0ZldGNoZXMpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIGFyZzIgPT09ICdvYmplY3QnICYmIGFyZzIgIT09IG51bGwpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBhcmcyO1xuICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGFyZzIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcXCdvcHRpb25zXFwnIG11c3QgYmUgYW4gb2JqZWN0LicpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvcHRpb25zID0gYXJnMSBhcyBSdW5PcHRpb25zO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgYXJnMSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1VuZXhwZWN0ZWQgYXJndW1lbnRbMV06IG11c3QgYmUgXFwnZmV0Y2hlc1xcJyBvciBcXCdvcHRpb25zXFwnLicpO1xuICAgIH1cblxuICAgIC8vIGNoZWNrIGlmIGFsbCBpbnB1dHMgYXJlIGluIGZlZWRcbiAgICBmb3IgKGNvbnN0IG5hbWUgb2YgdGhpcy5pbnB1dE5hbWVzKSB7XG4gICAgICBpZiAodHlwZW9mIGZlZWRzW25hbWVdID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGlucHV0ICcke25hbWV9JyBpcyBtaXNzaW5nIGluICdmZWVkcycuYCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gaWYgbm8gZmV0Y2hlcyBpcyBzcGVjaWZpZWQsIHdlIHVzZSB0aGUgZnVsbCBvdXRwdXQgbmFtZXMgbGlzdFxuICAgIGlmIChpc0ZldGNoZXNFbXB0eSkge1xuICAgICAgZm9yIChjb25zdCBuYW1lIG9mIHRoaXMub3V0cHV0TmFtZXMpIHtcbiAgICAgICAgZmV0Y2hlc1tuYW1lXSA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gZmVlZHMsIGZldGNoZXMgYW5kIG9wdGlvbnMgYXJlIHByZXBhcmVkXG5cbiAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgdGhpcy5oYW5kbGVyLnJ1bihmZWVkcywgZmV0Y2hlcywgb3B0aW9ucyk7XG4gICAgY29uc3QgcmV0dXJuVmFsdWU6IHtbbmFtZTogc3RyaW5nXTogT25ueFZhbHVlfSA9IHt9O1xuICAgIGZvciAoY29uc3Qga2V5IGluIHJlc3VsdHMpIHtcbiAgICAgIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChyZXN1bHRzLCBrZXkpKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHJlc3VsdHNba2V5XTtcbiAgICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIFRlbnNvcikge1xuICAgICAgICAgIHJldHVyblZhbHVlW2tleV0gPSByZXN1bHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuVmFsdWVba2V5XSA9IG5ldyBUZW5zb3IocmVzdWx0LnR5cGUsIHJlc3VsdC5kYXRhLCByZXN1bHQuZGltcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgVFJBQ0VfRlVOQ19FTkQoKTtcbiAgICByZXR1cm4gcmV0dXJuVmFsdWU7XG4gIH1cblxuICBhc3luYyByZWxlYXNlKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIHJldHVybiB0aGlzLmhhbmRsZXIuZGlzcG9zZSgpO1xuICB9XG5cbiAgc3RhdGljIGNyZWF0ZShwYXRoOiBzdHJpbmcsIG9wdGlvbnM/OiBTZXNzaW9uT3B0aW9ucyk6IFByb21pc2U8SW5mZXJlbmNlU2Vzc2lvbkludGVyZmFjZT47XG4gIHN0YXRpYyBjcmVhdGUoYnVmZmVyOiBBcnJheUJ1ZmZlckxpa2UsIG9wdGlvbnM/OiBTZXNzaW9uT3B0aW9ucyk6IFByb21pc2U8SW5mZXJlbmNlU2Vzc2lvbkludGVyZmFjZT47XG4gIHN0YXRpYyBjcmVhdGUoYnVmZmVyOiBBcnJheUJ1ZmZlckxpa2UsIGJ5dGVPZmZzZXQ6IG51bWJlciwgYnl0ZUxlbmd0aD86IG51bWJlciwgb3B0aW9ucz86IFNlc3Npb25PcHRpb25zKTpcbiAgICAgIFByb21pc2U8SW5mZXJlbmNlU2Vzc2lvbkludGVyZmFjZT47XG4gIHN0YXRpYyBjcmVhdGUoYnVmZmVyOiBVaW50OEFycmF5LCBvcHRpb25zPzogU2Vzc2lvbk9wdGlvbnMpOiBQcm9taXNlPEluZmVyZW5jZVNlc3Npb25JbnRlcmZhY2U+O1xuICBzdGF0aWMgYXN5bmMgY3JlYXRlKFxuICAgICAgYXJnMDogc3RyaW5nfEFycmF5QnVmZmVyTGlrZXxVaW50OEFycmF5LCBhcmcxPzogU2Vzc2lvbk9wdGlvbnN8bnVtYmVyLCBhcmcyPzogbnVtYmVyLFxuICAgICAgYXJnMz86IFNlc3Npb25PcHRpb25zKTogUHJvbWlzZTxJbmZlcmVuY2VTZXNzaW9uSW50ZXJmYWNlPiB7XG4gICAgVFJBQ0VfRlVOQ19CRUdJTigpO1xuICAgIC8vIGVpdGhlciBsb2FkIGZyb20gYSBmaWxlIG9yIGJ1ZmZlclxuICAgIGxldCBmaWxlUGF0aE9yVWludDhBcnJheTogc3RyaW5nfFVpbnQ4QXJyYXk7XG4gICAgbGV0IG9wdGlvbnM6IFNlc3Npb25PcHRpb25zID0ge307XG5cbiAgICBpZiAodHlwZW9mIGFyZzAgPT09ICdzdHJpbmcnKSB7XG4gICAgICBmaWxlUGF0aE9yVWludDhBcnJheSA9IGFyZzA7XG4gICAgICBpZiAodHlwZW9mIGFyZzEgPT09ICdvYmplY3QnICYmIGFyZzEgIT09IG51bGwpIHtcbiAgICAgICAgb3B0aW9ucyA9IGFyZzE7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBhcmcxICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcXCdvcHRpb25zXFwnIG11c3QgYmUgYW4gb2JqZWN0LicpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoYXJnMCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgIGZpbGVQYXRoT3JVaW50OEFycmF5ID0gYXJnMDtcbiAgICAgIGlmICh0eXBlb2YgYXJnMSA9PT0gJ29iamVjdCcgJiYgYXJnMSAhPT0gbnVsbCkge1xuICAgICAgICBvcHRpb25zID0gYXJnMTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGFyZzEgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1xcJ29wdGlvbnNcXCcgbXVzdCBiZSBhbiBvYmplY3QuJyk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChcbiAgICAgICAgYXJnMCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyIHx8XG4gICAgICAgICh0eXBlb2YgU2hhcmVkQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIGFyZzAgaW5zdGFuY2VvZiBTaGFyZWRBcnJheUJ1ZmZlcikpIHtcbiAgICAgIGNvbnN0IGJ1ZmZlciA9IGFyZzA7XG4gICAgICBsZXQgYnl0ZU9mZnNldCA9IDA7XG4gICAgICBsZXQgYnl0ZUxlbmd0aCA9IGFyZzAuYnl0ZUxlbmd0aDtcbiAgICAgIGlmICh0eXBlb2YgYXJnMSA9PT0gJ29iamVjdCcgJiYgYXJnMSAhPT0gbnVsbCkge1xuICAgICAgICBvcHRpb25zID0gYXJnMTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGFyZzEgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGJ5dGVPZmZzZXQgPSBhcmcxO1xuICAgICAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKGJ5dGVPZmZzZXQpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1xcJ2J5dGVPZmZzZXRcXCcgbXVzdCBiZSBhbiBpbnRlZ2VyLicpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChieXRlT2Zmc2V0IDwgMCB8fCBieXRlT2Zmc2V0ID49IGJ1ZmZlci5ieXRlTGVuZ3RoKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYCdieXRlT2Zmc2V0JyBpcyBvdXQgb2YgcmFuZ2UgWzAsICR7YnVmZmVyLmJ5dGVMZW5ndGh9KS5gKTtcbiAgICAgICAgfVxuICAgICAgICBieXRlTGVuZ3RoID0gYXJnMC5ieXRlTGVuZ3RoIC0gYnl0ZU9mZnNldDtcbiAgICAgICAgaWYgKHR5cGVvZiBhcmcyID09PSAnbnVtYmVyJykge1xuICAgICAgICAgIGJ5dGVMZW5ndGggPSBhcmcyO1xuICAgICAgICAgIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIoYnl0ZUxlbmd0aCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcXCdieXRlTGVuZ3RoXFwnIG11c3QgYmUgYW4gaW50ZWdlci4nKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGJ5dGVMZW5ndGggPD0gMCB8fCBieXRlT2Zmc2V0ICsgYnl0ZUxlbmd0aCA+IGJ1ZmZlci5ieXRlTGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgJ2J5dGVMZW5ndGgnIGlzIG91dCBvZiByYW5nZSAoMCwgJHtidWZmZXIuYnl0ZUxlbmd0aCAtIGJ5dGVPZmZzZXR9XS5gKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHR5cGVvZiBhcmczID09PSAnb2JqZWN0JyAmJiBhcmczICE9PSBudWxsKSB7XG4gICAgICAgICAgICBvcHRpb25zID0gYXJnMztcbiAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBhcmczICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXFwnb3B0aW9uc1xcJyBtdXN0IGJlIGFuIG9iamVjdC4nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGFyZzIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXFwnYnl0ZUxlbmd0aFxcJyBtdXN0IGJlIGEgbnVtYmVyLicpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBhcmcxICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcXCdvcHRpb25zXFwnIG11c3QgYmUgYW4gb2JqZWN0LicpO1xuICAgICAgfVxuICAgICAgZmlsZVBhdGhPclVpbnQ4QXJyYXkgPSBuZXcgVWludDhBcnJheShidWZmZXIsIGJ5dGVPZmZzZXQsIGJ5dGVMZW5ndGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmV4cGVjdGVkIGFyZ3VtZW50WzBdOiBtdXN0IGJlIFxcJ3BhdGhcXCcgb3IgXFwnYnVmZmVyXFwnLicpO1xuICAgIH1cblxuICAgIC8vIGdldCBiYWNrZW5kIGhpbnRzXG4gICAgY29uc3QgZXBzID0gb3B0aW9ucy5leGVjdXRpb25Qcm92aWRlcnMgfHwgW107XG4gICAgY29uc3QgYmFja2VuZEhpbnRzID0gZXBzLm1hcChpID0+IHR5cGVvZiBpID09PSAnc3RyaW5nJyA/IGkgOiBpLm5hbWUpO1xuICAgIGNvbnN0IGJhY2tlbmQgPSBhd2FpdCByZXNvbHZlQmFja2VuZChiYWNrZW5kSGludHMpO1xuICAgIGNvbnN0IGhhbmRsZXIgPSBhd2FpdCBiYWNrZW5kLmNyZWF0ZUluZmVyZW5jZVNlc3Npb25IYW5kbGVyKGZpbGVQYXRoT3JVaW50OEFycmF5LCBvcHRpb25zKTtcbiAgICBUUkFDRV9GVU5DX0VORCgpO1xuICAgIHJldHVybiBuZXcgSW5mZXJlbmNlU2Vzc2lvbihoYW5kbGVyKTtcbiAgfVxuXG4gIHN0YXJ0UHJvZmlsaW5nKCk6IHZvaWQge1xuICAgIHRoaXMuaGFuZGxlci5zdGFydFByb2ZpbGluZygpO1xuICB9XG4gIGVuZFByb2ZpbGluZygpOiB2b2lkIHtcbiAgICB0aGlzLmhhbmRsZXIuZW5kUHJvZmlsaW5nKCk7XG4gIH1cblxuICBnZXQgaW5wdXROYW1lcygpOiByZWFkb25seSBzdHJpbmdbXSB7XG4gICAgcmV0dXJuIHRoaXMuaGFuZGxlci5pbnB1dE5hbWVzO1xuICB9XG4gIGdldCBvdXRwdXROYW1lcygpOiByZWFkb25seSBzdHJpbmdbXSB7XG4gICAgcmV0dXJuIHRoaXMuaGFuZGxlci5vdXRwdXROYW1lcztcbiAgfVxuXG4gIHByaXZhdGUgaGFuZGxlcjogSW5mZXJlbmNlU2Vzc2lvbkhhbmRsZXI7XG59XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7SW5mZXJlbmNlU2Vzc2lvbiBhcyBJbmZlcmVuY2VTZXNzaW9uSW1wbH0gZnJvbSAnLi9pbmZlcmVuY2Utc2Vzc2lvbi1pbXBsLmpzJztcbmltcG9ydCB7T25ueE1vZGVsT3B0aW9uc30gZnJvbSAnLi9vbm54LW1vZGVsLmpzJztcbmltcG9ydCB7T25ueFZhbHVlLCBPbm54VmFsdWVEYXRhTG9jYXRpb259IGZyb20gJy4vb25ueC12YWx1ZS5qcyc7XG5cbi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1yZWRlY2xhcmUgKi9cblxuZXhwb3J0IGRlY2xhcmUgbmFtZXNwYWNlIEluZmVyZW5jZVNlc3Npb24ge1xuICAvLyAjcmVnaW9uIGlucHV0L291dHB1dCB0eXBlc1xuXG4gIHR5cGUgT25ueFZhbHVlTWFwVHlwZSA9IHtyZWFkb25seSBbbmFtZTogc3RyaW5nXTogT25ueFZhbHVlfTtcbiAgdHlwZSBOdWxsYWJsZU9ubnhWYWx1ZU1hcFR5cGUgPSB7cmVhZG9ubHkgW25hbWU6IHN0cmluZ106IE9ubnhWYWx1ZSB8IG51bGx9O1xuXG4gIC8qKlxuICAgKiBBIGZlZWRzIChtb2RlbCBpbnB1dHMpIGlzIGFuIG9iamVjdCB0aGF0IHVzZXMgaW5wdXQgbmFtZXMgYXMga2V5cyBhbmQgT25ueFZhbHVlIGFzIGNvcnJlc3BvbmRpbmcgdmFsdWVzLlxuICAgKi9cbiAgdHlwZSBGZWVkc1R5cGUgPSBPbm54VmFsdWVNYXBUeXBlO1xuXG4gIC8qKlxuICAgKiBBIGZldGNoZXMgKG1vZGVsIG91dHB1dHMpIGNvdWxkIGJlIG9uZSBvZiB0aGUgZm9sbG93aW5nOlxuICAgKlxuICAgKiAtIE9taXR0ZWQuIFVzZSBtb2RlbCdzIG91dHB1dCBuYW1lcyBkZWZpbml0aW9uLlxuICAgKiAtIEFuIGFycmF5IG9mIHN0cmluZyBpbmRpY2F0aW5nIHRoZSBvdXRwdXQgbmFtZXMuXG4gICAqIC0gQW4gb2JqZWN0IHRoYXQgdXNlIG91dHB1dCBuYW1lcyBhcyBrZXlzIGFuZCBPbm54VmFsdWUgb3IgbnVsbCBhcyBjb3JyZXNwb25kaW5nIHZhbHVlcy5cbiAgICpcbiAgICogQHJlbWFya1xuICAgKiBkaWZmZXJlbnQgZnJvbSBpbnB1dCBhcmd1bWVudCwgaW4gb3V0cHV0LCBPbm54VmFsdWUgaXMgb3B0aW9uYWwuIElmIGFuIE9ubnhWYWx1ZSBpcyBwcmVzZW50IGl0IHdpbGwgYmVcbiAgICogdXNlZCBhcyBhIHByZS1hbGxvY2F0ZWQgdmFsdWUgYnkgdGhlIGluZmVyZW5jZSBlbmdpbmU7IGlmIG9taXR0ZWQsIGluZmVyZW5jZSBlbmdpbmUgd2lsbCBhbGxvY2F0ZSBidWZmZXJcbiAgICogaW50ZXJuYWxseS5cbiAgICovXG4gIHR5cGUgRmV0Y2hlc1R5cGUgPSByZWFkb25seSBzdHJpbmdbXXxOdWxsYWJsZU9ubnhWYWx1ZU1hcFR5cGU7XG5cbiAgLyoqXG4gICAqIEEgaW5mZXJlbmNpbmcgcmV0dXJuIHR5cGUgaXMgYW4gb2JqZWN0IHRoYXQgdXNlcyBvdXRwdXQgbmFtZXMgYXMga2V5cyBhbmQgT25ueFZhbHVlIGFzIGNvcnJlc3BvbmRpbmcgdmFsdWVzLlxuICAgKi9cbiAgdHlwZSBSZXR1cm5UeXBlID0gT25ueFZhbHVlTWFwVHlwZTtcblxuICAvLyAjZW5kcmVnaW9uXG5cbiAgLy8gI3JlZ2lvbiBzZXNzaW9uIG9wdGlvbnNcblxuICAvKipcbiAgICogQSBzZXQgb2YgY29uZmlndXJhdGlvbnMgZm9yIHNlc3Npb24gYmVoYXZpb3IuXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIFNlc3Npb25PcHRpb25zIGV4dGVuZHMgT25ueE1vZGVsT3B0aW9ucyB7XG4gICAgLyoqXG4gICAgICogQW4gYXJyYXkgb2YgZXhlY3V0aW9uIHByb3ZpZGVyIG9wdGlvbnMuXG4gICAgICpcbiAgICAgKiBBbiBleGVjdXRpb24gcHJvdmlkZXIgb3B0aW9uIGNhbiBiZSBhIHN0cmluZyBpbmRpY2F0aW5nIHRoZSBuYW1lIG9mIHRoZSBleGVjdXRpb24gcHJvdmlkZXIsXG4gICAgICogb3IgYW4gb2JqZWN0IG9mIGNvcnJlc3BvbmRpbmcgdHlwZS5cbiAgICAgKi9cbiAgICBleGVjdXRpb25Qcm92aWRlcnM/OiByZWFkb25seSBFeGVjdXRpb25Qcm92aWRlckNvbmZpZ1tdO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGludHJhIE9QIHRocmVhZHMgbnVtYmVyLlxuICAgICAqXG4gICAgICogVGhpcyBzZXR0aW5nIGlzIGF2YWlsYWJsZSBvbmx5IGluIE9OTlhSdW50aW1lIChOb2RlLmpzIGJpbmRpbmcgYW5kIHJlYWN0LW5hdGl2ZSkuXG4gICAgICovXG4gICAgaW50cmFPcE51bVRocmVhZHM/OiBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgaW50ZXIgT1AgdGhyZWFkcyBudW1iZXIuXG4gICAgICpcbiAgICAgKiBUaGlzIHNldHRpbmcgaXMgYXZhaWxhYmxlIG9ubHkgaW4gT05OWFJ1bnRpbWUgKE5vZGUuanMgYmluZGluZyBhbmQgcmVhY3QtbmF0aXZlKS5cbiAgICAgKi9cbiAgICBpbnRlck9wTnVtVGhyZWFkcz86IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIFRoZSBmcmVlIGRpbWVuc2lvbiBvdmVycmlkZS5cbiAgICAgKlxuICAgICAqIFRoaXMgc2V0dGluZyBpcyBhdmFpbGFibGUgb25seSBpbiBPTk5YUnVudGltZSAoTm9kZS5qcyBiaW5kaW5nIGFuZCByZWFjdC1uYXRpdmUpIG9yIFdlYkFzc2VtYmx5IGJhY2tlbmRcbiAgICAgKi9cbiAgICBmcmVlRGltZW5zaW9uT3ZlcnJpZGVzPzoge3JlYWRvbmx5IFtkaW1lbnNpb25OYW1lOiBzdHJpbmddOiBudW1iZXJ9O1xuXG4gICAgLyoqXG4gICAgICogVGhlIG9wdGltaXphdGlvbiBsZXZlbC5cbiAgICAgKlxuICAgICAqIFRoaXMgc2V0dGluZyBpcyBhdmFpbGFibGUgb25seSBpbiBPTk5YUnVudGltZSAoTm9kZS5qcyBiaW5kaW5nIGFuZCByZWFjdC1uYXRpdmUpIG9yIFdlYkFzc2VtYmx5IGJhY2tlbmRcbiAgICAgKi9cbiAgICBncmFwaE9wdGltaXphdGlvbkxldmVsPzogJ2Rpc2FibGVkJ3wnYmFzaWMnfCdleHRlbmRlZCd8J2FsbCc7XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIGVuYWJsZSBDUFUgbWVtb3J5IGFyZW5hLlxuICAgICAqXG4gICAgICogVGhpcyBzZXR0aW5nIGlzIGF2YWlsYWJsZSBvbmx5IGluIE9OTlhSdW50aW1lIChOb2RlLmpzIGJpbmRpbmcgYW5kIHJlYWN0LW5hdGl2ZSkgb3IgV2ViQXNzZW1ibHkgYmFja2VuZFxuICAgICAqL1xuICAgIGVuYWJsZUNwdU1lbUFyZW5hPzogYm9vbGVhbjtcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgZW5hYmxlIG1lbW9yeSBwYXR0ZXJuLlxuICAgICAqXG4gICAgICogVGhpcyBzZXR0aW5nIGlzIGF2YWlsYWJsZSBvbmx5IGluIE9OTlhSdW50aW1lIChOb2RlLmpzIGJpbmRpbmcgYW5kIHJlYWN0LW5hdGl2ZSkgb3IgV2ViQXNzZW1ibHkgYmFja2VuZFxuICAgICAqL1xuICAgIGVuYWJsZU1lbVBhdHRlcm4/OiBib29sZWFuO1xuXG4gICAgLyoqXG4gICAgICogRXhlY3V0aW9uIG1vZGUuXG4gICAgICpcbiAgICAgKiBUaGlzIHNldHRpbmcgaXMgYXZhaWxhYmxlIG9ubHkgaW4gT05OWFJ1bnRpbWUgKE5vZGUuanMgYmluZGluZyBhbmQgcmVhY3QtbmF0aXZlKSBvciBXZWJBc3NlbWJseSBiYWNrZW5kXG4gICAgICovXG4gICAgZXhlY3V0aW9uTW9kZT86ICdzZXF1ZW50aWFsJ3wncGFyYWxsZWwnO1xuXG4gICAgLyoqXG4gICAgICogT3B0aW1pemVkIG1vZGVsIGZpbGUgcGF0aC5cbiAgICAgKlxuICAgICAqIElmIHRoaXMgc2V0dGluZyBpcyBzcGVjaWZpZWQsIHRoZSBvcHRpbWl6ZWQgbW9kZWwgd2lsbCBiZSBkdW1wZWQuIEluIGJyb3dzZXIsIGEgYmxvYiB3aWxsIGJlIGNyZWF0ZWRcbiAgICAgKiB3aXRoIGEgcG9wLXVwIHdpbmRvdy5cbiAgICAgKi9cbiAgICBvcHRpbWl6ZWRNb2RlbEZpbGVQYXRoPzogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogV2V0aGVyIGVuYWJsZSBwcm9maWxpbmcuXG4gICAgICpcbiAgICAgKiBUaGlzIHNldHRpbmcgaXMgYSBwbGFjZWhvbGRlciBmb3IgYSBmdXR1cmUgdXNlLlxuICAgICAqL1xuICAgIGVuYWJsZVByb2ZpbGluZz86IGJvb2xlYW47XG5cbiAgICAvKipcbiAgICAgKiBGaWxlIHByZWZpeCBmb3IgcHJvZmlsaW5nLlxuICAgICAqXG4gICAgICogVGhpcyBzZXR0aW5nIGlzIGEgcGxhY2Vob2xkZXIgZm9yIGEgZnV0dXJlIHVzZS5cbiAgICAgKi9cbiAgICBwcm9maWxlRmlsZVByZWZpeD86IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIExvZyBJRC5cbiAgICAgKlxuICAgICAqIFRoaXMgc2V0dGluZyBpcyBhdmFpbGFibGUgb25seSBpbiBPTk5YUnVudGltZSAoTm9kZS5qcyBiaW5kaW5nIGFuZCByZWFjdC1uYXRpdmUpIG9yIFdlYkFzc2VtYmx5IGJhY2tlbmRcbiAgICAgKi9cbiAgICBsb2dJZD86IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIExvZyBzZXZlcml0eSBsZXZlbC4gU2VlXG4gICAgICogaHR0cHM6Ly9naXRodWIuY29tL21pY3Jvc29mdC9vbm54cnVudGltZS9ibG9iL21haW4vaW5jbHVkZS9vbm54cnVudGltZS9jb3JlL2NvbW1vbi9sb2dnaW5nL3NldmVyaXR5LmhcbiAgICAgKlxuICAgICAqIFRoaXMgc2V0dGluZyBpcyBhdmFpbGFibGUgb25seSBpbiBPTk5YUnVudGltZSAoTm9kZS5qcyBiaW5kaW5nIGFuZCByZWFjdC1uYXRpdmUpIG9yIFdlYkFzc2VtYmx5IGJhY2tlbmRcbiAgICAgKi9cbiAgICBsb2dTZXZlcml0eUxldmVsPzogMHwxfDJ8M3w0O1xuXG4gICAgLyoqXG4gICAgICogTG9nIHZlcmJvc2l0eSBsZXZlbC5cbiAgICAgKlxuICAgICAqIFRoaXMgc2V0dGluZyBpcyBhdmFpbGFibGUgb25seSBpbiBXZWJBc3NlbWJseSBiYWNrZW5kLiBXaWxsIHN1cHBvcnQgTm9kZS5qcyBiaW5kaW5nIGFuZCByZWFjdC1uYXRpdmUgbGF0ZXJcbiAgICAgKi9cbiAgICBsb2dWZXJib3NpdHlMZXZlbD86IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIFNwZWNpZnkgc3RyaW5nIGFzIGEgcHJlZmVycmVkIGRhdGEgbG9jYXRpb24gZm9yIGFsbCBvdXRwdXRzLCBvciBhbiBvYmplY3QgdGhhdCB1c2Ugb3V0cHV0IG5hbWVzIGFzIGtleXMgYW5kIGFcbiAgICAgKiBwcmVmZXJyZWQgZGF0YSBsb2NhdGlvbiBhcyBjb3JyZXNwb25kaW5nIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIFRoaXMgc2V0dGluZyBpcyBhdmFpbGFibGUgb25seSBpbiBPTk5YUnVudGltZSBXZWIgZm9yIFdlYkdMIGFuZCBXZWJHUFUgRVAuXG4gICAgICovXG4gICAgcHJlZmVycmVkT3V0cHV0TG9jYXRpb24/OiBPbm54VmFsdWVEYXRhTG9jYXRpb258e3JlYWRvbmx5IFtvdXRwdXROYW1lOiBzdHJpbmddOiBPbm54VmFsdWVEYXRhTG9jYXRpb259O1xuXG4gICAgLyoqXG4gICAgICogU3RvcmUgY29uZmlndXJhdGlvbnMgZm9yIGEgc2Vzc2lvbi4gU2VlXG4gICAgICogaHR0cHM6Ly9naXRodWIuY29tL21pY3Jvc29mdC9vbm54cnVudGltZS9ibG9iL21haW4vaW5jbHVkZS9vbm54cnVudGltZS9jb3JlL3Nlc3Npb24vXG4gICAgICogb25ueHJ1bnRpbWVfc2Vzc2lvbl9vcHRpb25zX2NvbmZpZ19rZXlzLmhcbiAgICAgKlxuICAgICAqIFRoaXMgc2V0dGluZyBpcyBhdmFpbGFibGUgb25seSBpbiBXZWJBc3NlbWJseSBiYWNrZW5kLiBXaWxsIHN1cHBvcnQgTm9kZS5qcyBiaW5kaW5nIGFuZCByZWFjdC1uYXRpdmUgbGF0ZXJcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBganNcbiAgICAgKiBleHRyYToge1xuICAgICAqICAgc2Vzc2lvbjoge1xuICAgICAqICAgICBzZXRfZGVub3JtYWxfYXNfemVybzogXCIxXCIsXG4gICAgICogICAgIGRpc2FibGVfcHJlcGFja2luZzogXCIxXCJcbiAgICAgKiAgIH0sXG4gICAgICogICBvcHRpbWl6YXRpb246IHtcbiAgICAgKiAgICAgZW5hYmxlX2dlbHVfYXBwcm94aW1hdGlvbjogXCIxXCJcbiAgICAgKiAgIH1cbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICovXG4gICAgZXh0cmE/OiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPjtcbiAgfVxuXG4gIC8vICNyZWdpb24gZXhlY3V0aW9uIHByb3ZpZGVyc1xuXG4gIC8vIEN1cnJlbnRseSwgd2UgaGF2ZSB0aGUgZm9sbG93aW5nIGJhY2tlbmRzIHRvIHN1cHBvcnQgZXhlY3V0aW9uIHByb3ZpZGVyczpcbiAgLy8gQmFja2VuZCBOb2RlLmpzIGJpbmRpbmc6IHN1cHBvcnRzICdjcHUnIGFuZCAnY3VkYScuXG4gIC8vIEJhY2tlbmQgV2ViQXNzZW1ibHk6IHN1cHBvcnRzICdjcHUnLCAnd2FzbScsICd3ZWJncHUnIGFuZCAnd2Vibm4nLlxuICAvLyBCYWNrZW5kIE9OTlguanM6IHN1cHBvcnRzICd3ZWJnbCcuXG4gIC8vIEJhY2tlbmQgUmVhY3QgTmF0aXZlOiBzdXBwb3J0cyAnY3B1JywgJ3hubnBhY2snLCAnY29yZW1sJyAoaU9TKSwgJ25uYXBpJyAoQW5kcm9pZCkuXG4gIGludGVyZmFjZSBFeGVjdXRpb25Qcm92aWRlck9wdGlvbk1hcCB7XG4gICAgY3B1OiBDcHVFeGVjdXRpb25Qcm92aWRlck9wdGlvbjtcbiAgICBjb3JlbWw6IENvcmVNbEV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uO1xuICAgIGN1ZGE6IEN1ZGFFeGVjdXRpb25Qcm92aWRlck9wdGlvbjtcbiAgICBkbWw6IERtbEV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uO1xuICAgIHRlbnNvcnJ0OiBUZW5zb3JSdEV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uO1xuICAgIHdhc206IFdlYkFzc2VtYmx5RXhlY3V0aW9uUHJvdmlkZXJPcHRpb247XG4gICAgd2ViZ2w6IFdlYkdMRXhlY3V0aW9uUHJvdmlkZXJPcHRpb247XG4gICAgeG5ucGFjazogWG5ucGFja0V4ZWN1dGlvblByb3ZpZGVyT3B0aW9uO1xuICAgIHdlYmdwdTogV2ViR3B1RXhlY3V0aW9uUHJvdmlkZXJPcHRpb247XG4gICAgd2Vibm46IFdlYk5ORXhlY3V0aW9uUHJvdmlkZXJPcHRpb247XG4gICAgbm5hcGk6IE5uYXBpRXhlY3V0aW9uUHJvdmlkZXJPcHRpb247XG4gIH1cblxuICB0eXBlIEV4ZWN1dGlvblByb3ZpZGVyTmFtZSA9IGtleW9mIEV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uTWFwO1xuICB0eXBlIEV4ZWN1dGlvblByb3ZpZGVyQ29uZmlnID1cbiAgICAgIEV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uTWFwW0V4ZWN1dGlvblByb3ZpZGVyTmFtZV18RXhlY3V0aW9uUHJvdmlkZXJPcHRpb258RXhlY3V0aW9uUHJvdmlkZXJOYW1lfHN0cmluZztcblxuICBleHBvcnQgaW50ZXJmYWNlIEV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uIHtcbiAgICByZWFkb25seSBuYW1lOiBzdHJpbmc7XG4gIH1cbiAgZXhwb3J0IGludGVyZmFjZSBDcHVFeGVjdXRpb25Qcm92aWRlck9wdGlvbiBleHRlbmRzIEV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uIHtcbiAgICByZWFkb25seSBuYW1lOiAnY3B1JztcbiAgICB1c2VBcmVuYT86IGJvb2xlYW47XG4gIH1cbiAgZXhwb3J0IGludGVyZmFjZSBDdWRhRXhlY3V0aW9uUHJvdmlkZXJPcHRpb24gZXh0ZW5kcyBFeGVjdXRpb25Qcm92aWRlck9wdGlvbiB7XG4gICAgcmVhZG9ubHkgbmFtZTogJ2N1ZGEnO1xuICAgIGRldmljZUlkPzogbnVtYmVyO1xuICB9XG4gIGV4cG9ydCBpbnRlcmZhY2UgQ29yZU1sRXhlY3V0aW9uUHJvdmlkZXJPcHRpb24gZXh0ZW5kcyBFeGVjdXRpb25Qcm92aWRlck9wdGlvbiB7XG4gICAgcmVhZG9ubHkgbmFtZTogJ2NvcmVtbCc7XG4gICAgY29yZU1sRmxhZ3M/OiBudW1iZXI7XG4gIH1cbiAgZXhwb3J0IGludGVyZmFjZSBEbWxFeGVjdXRpb25Qcm92aWRlck9wdGlvbiBleHRlbmRzIEV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uIHtcbiAgICByZWFkb25seSBuYW1lOiAnZG1sJztcbiAgICBkZXZpY2VJZD86IG51bWJlcjtcbiAgfVxuICBleHBvcnQgaW50ZXJmYWNlIFRlbnNvclJ0RXhlY3V0aW9uUHJvdmlkZXJPcHRpb24gZXh0ZW5kcyBFeGVjdXRpb25Qcm92aWRlck9wdGlvbiB7XG4gICAgcmVhZG9ubHkgbmFtZTogJ3RlbnNvcnJ0JztcbiAgICBkZXZpY2VJZD86IG51bWJlcjtcbiAgfVxuICBleHBvcnQgaW50ZXJmYWNlIFdlYkFzc2VtYmx5RXhlY3V0aW9uUHJvdmlkZXJPcHRpb24gZXh0ZW5kcyBFeGVjdXRpb25Qcm92aWRlck9wdGlvbiB7XG4gICAgcmVhZG9ubHkgbmFtZTogJ3dhc20nO1xuICB9XG4gIGV4cG9ydCBpbnRlcmZhY2UgV2ViR0xFeGVjdXRpb25Qcm92aWRlck9wdGlvbiBleHRlbmRzIEV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uIHtcbiAgICByZWFkb25seSBuYW1lOiAnd2ViZ2wnO1xuICAgIC8vIFRPRE86IGFkZCBmbGFnc1xuICB9XG4gIGV4cG9ydCBpbnRlcmZhY2UgWG5ucGFja0V4ZWN1dGlvblByb3ZpZGVyT3B0aW9uIGV4dGVuZHMgRXhlY3V0aW9uUHJvdmlkZXJPcHRpb24ge1xuICAgIHJlYWRvbmx5IG5hbWU6ICd4bm5wYWNrJztcbiAgfVxuICBleHBvcnQgaW50ZXJmYWNlIFdlYkdwdUV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uIGV4dGVuZHMgRXhlY3V0aW9uUHJvdmlkZXJPcHRpb24ge1xuICAgIHJlYWRvbmx5IG5hbWU6ICd3ZWJncHUnO1xuICAgIHByZWZlcnJlZExheW91dD86ICdOQ0hXJ3wnTkhXQyc7XG4gIH1cbiAgZXhwb3J0IGludGVyZmFjZSBXZWJOTkV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uIGV4dGVuZHMgRXhlY3V0aW9uUHJvdmlkZXJPcHRpb24ge1xuICAgIHJlYWRvbmx5IG5hbWU6ICd3ZWJubic7XG4gICAgZGV2aWNlVHlwZT86ICdjcHUnfCdncHUnO1xuICAgIG51bVRocmVhZHM/OiBudW1iZXI7XG4gICAgcG93ZXJQcmVmZXJlbmNlPzogJ2RlZmF1bHQnfCdsb3ctcG93ZXInfCdoaWdoLXBlcmZvcm1hbmNlJztcbiAgfVxuICBleHBvcnQgaW50ZXJmYWNlIENvcmVNTEV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uIGV4dGVuZHMgRXhlY3V0aW9uUHJvdmlkZXJPcHRpb24ge1xuICAgIHJlYWRvbmx5IG5hbWU6ICdjb3JlbWwnO1xuICAgIHVzZUNQVU9ubHk/OiBib29sZWFuO1xuICAgIGVuYWJsZU9uU3ViZ3JhcGg/OiBib29sZWFuO1xuICAgIG9ubHlFbmFibGVEZXZpY2VXaXRoQU5FPzogYm9vbGVhbjtcbiAgfVxuICBleHBvcnQgaW50ZXJmYWNlIE5uYXBpRXhlY3V0aW9uUHJvdmlkZXJPcHRpb24gZXh0ZW5kcyBFeGVjdXRpb25Qcm92aWRlck9wdGlvbiB7XG4gICAgcmVhZG9ubHkgbmFtZTogJ25uYXBpJztcbiAgICB1c2VGUDE2PzogYm9vbGVhbjtcbiAgICB1c2VOQ0hXPzogYm9vbGVhbjtcbiAgICBjcHVEaXNhYmxlZD86IGJvb2xlYW47XG4gICAgY3B1T25seT86IGJvb2xlYW47XG4gIH1cbiAgLy8gI2VuZHJlZ2lvblxuXG4gIC8vICNlbmRyZWdpb25cblxuICAvLyAjcmVnaW9uIHJ1biBvcHRpb25zXG5cbiAgLyoqXG4gICAqIEEgc2V0IG9mIGNvbmZpZ3VyYXRpb25zIGZvciBpbmZlcmVuY2UgcnVuIGJlaGF2aW9yXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIFJ1bk9wdGlvbnMge1xuICAgIC8qKlxuICAgICAqIExvZyBzZXZlcml0eSBsZXZlbC4gU2VlXG4gICAgICogaHR0cHM6Ly9naXRodWIuY29tL21pY3Jvc29mdC9vbm54cnVudGltZS9ibG9iL21haW4vaW5jbHVkZS9vbm54cnVudGltZS9jb3JlL2NvbW1vbi9sb2dnaW5nL3NldmVyaXR5LmhcbiAgICAgKlxuICAgICAqIFRoaXMgc2V0dGluZyBpcyBhdmFpbGFibGUgb25seSBpbiBPTk5YUnVudGltZSAoTm9kZS5qcyBiaW5kaW5nIGFuZCByZWFjdC1uYXRpdmUpIG9yIFdlYkFzc2VtYmx5IGJhY2tlbmRcbiAgICAgKi9cbiAgICBsb2dTZXZlcml0eUxldmVsPzogMHwxfDJ8M3w0O1xuXG4gICAgLyoqXG4gICAgICogTG9nIHZlcmJvc2l0eSBsZXZlbC5cbiAgICAgKlxuICAgICAqIFRoaXMgc2V0dGluZyBpcyBhdmFpbGFibGUgb25seSBpbiBXZWJBc3NlbWJseSBiYWNrZW5kLiBXaWxsIHN1cHBvcnQgTm9kZS5qcyBiaW5kaW5nIGFuZCByZWFjdC1uYXRpdmUgbGF0ZXJcbiAgICAgKi9cbiAgICBsb2dWZXJib3NpdHlMZXZlbD86IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIFRlcm1pbmF0ZSBhbGwgaW5jb21wbGV0ZSBPcnRSdW4gY2FsbHMgYXMgc29vbiBhcyBwb3NzaWJsZSBpZiB0cnVlXG4gICAgICpcbiAgICAgKiBUaGlzIHNldHRpbmcgaXMgYXZhaWxhYmxlIG9ubHkgaW4gV2ViQXNzZW1ibHkgYmFja2VuZC4gV2lsbCBzdXBwb3J0IE5vZGUuanMgYmluZGluZyBhbmQgcmVhY3QtbmF0aXZlIGxhdGVyXG4gICAgICovXG4gICAgdGVybWluYXRlPzogYm9vbGVhbjtcblxuICAgIC8qKlxuICAgICAqIEEgdGFnIGZvciB0aGUgUnVuKCkgY2FsbHMgdXNpbmcgdGhpc1xuICAgICAqXG4gICAgICogVGhpcyBzZXR0aW5nIGlzIGF2YWlsYWJsZSBvbmx5IGluIE9OTlhSdW50aW1lIChOb2RlLmpzIGJpbmRpbmcgYW5kIHJlYWN0LW5hdGl2ZSkgb3IgV2ViQXNzZW1ibHkgYmFja2VuZFxuICAgICAqL1xuICAgIHRhZz86IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIFNldCBhIHNpbmdsZSBydW4gY29uZmlndXJhdGlvbiBlbnRyeS4gU2VlXG4gICAgICogaHR0cHM6Ly9naXRodWIuY29tL21pY3Jvc29mdC9vbm54cnVudGltZS9ibG9iL21haW4vaW5jbHVkZS9vbm54cnVudGltZS9jb3JlL3Nlc3Npb24vXG4gICAgICogb25ueHJ1bnRpbWVfcnVuX29wdGlvbnNfY29uZmlnX2tleXMuaFxuICAgICAqXG4gICAgICogVGhpcyBzZXR0aW5nIGlzIGF2YWlsYWJsZSBvbmx5IGluIFdlYkFzc2VtYmx5IGJhY2tlbmQuIFdpbGwgc3VwcG9ydCBOb2RlLmpzIGJpbmRpbmcgYW5kIHJlYWN0LW5hdGl2ZSBsYXRlclxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGBgYGpzXG4gICAgICogZXh0cmE6IHtcbiAgICAgKiAgIG1lbW9yeToge1xuICAgICAqICAgICBlbmFibGVfbWVtb3J5X2FyZW5hX3Nocmlua2FnZTogXCIxXCIsXG4gICAgICogICB9XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGV4dHJhPzogUmVjb3JkPHN0cmluZywgdW5rbm93bj47XG4gIH1cblxuICAvLyAjZW5kcmVnaW9uXG5cbiAgLy8gI3JlZ2lvbiB2YWx1ZSBtZXRhZGF0YVxuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZW1wdHktaW50ZXJmYWNlXG4gIGludGVyZmFjZSBWYWx1ZU1ldGFkYXRhIHtcbiAgICAvLyBUQkRcbiAgfVxuXG4gIC8vICNlbmRyZWdpb25cbn1cblxuLyoqXG4gKiBSZXByZXNlbnQgYSBydW50aW1lIGluc3RhbmNlIG9mIGFuIE9OTlggbW9kZWwuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgSW5mZXJlbmNlU2Vzc2lvbiB7XG4gIC8vICNyZWdpb24gcnVuKClcblxuICAvKipcbiAgICogRXhlY3V0ZSB0aGUgbW9kZWwgYXN5bmNocm9ub3VzbHkgd2l0aCB0aGUgZ2l2ZW4gZmVlZHMgYW5kIG9wdGlvbnMuXG4gICAqXG4gICAqIEBwYXJhbSBmZWVkcyAtIFJlcHJlc2VudGF0aW9uIG9mIHRoZSBtb2RlbCBpbnB1dC4gU2VlIHR5cGUgZGVzY3JpcHRpb24gb2YgYEluZmVyZW5jZVNlc3Npb24uSW5wdXRUeXBlYCBmb3IgZGV0YWlsLlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbmFsLiBBIHNldCBvZiBvcHRpb25zIHRoYXQgY29udHJvbHMgdGhlIGJlaGF2aW9yIG9mIG1vZGVsIGluZmVyZW5jZS5cbiAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBtYXAsIHdoaWNoIHVzZXMgb3V0cHV0IG5hbWVzIGFzIGtleXMgYW5kIE9ubnhWYWx1ZSBhcyBjb3JyZXNwb25kaW5nIHZhbHVlcy5cbiAgICovXG4gIHJ1bihmZWVkczogSW5mZXJlbmNlU2Vzc2lvbi5GZWVkc1R5cGUsIG9wdGlvbnM/OiBJbmZlcmVuY2VTZXNzaW9uLlJ1bk9wdGlvbnMpOiBQcm9taXNlPEluZmVyZW5jZVNlc3Npb24uUmV0dXJuVHlwZT47XG5cbiAgLyoqXG4gICAqIEV4ZWN1dGUgdGhlIG1vZGVsIGFzeW5jaHJvbm91c2x5IHdpdGggdGhlIGdpdmVuIGZlZWRzLCBmZXRjaGVzIGFuZCBvcHRpb25zLlxuICAgKlxuICAgKiBAcGFyYW0gZmVlZHMgLSBSZXByZXNlbnRhdGlvbiBvZiB0aGUgbW9kZWwgaW5wdXQuIFNlZSB0eXBlIGRlc2NyaXB0aW9uIG9mIGBJbmZlcmVuY2VTZXNzaW9uLklucHV0VHlwZWAgZm9yIGRldGFpbC5cbiAgICogQHBhcmFtIGZldGNoZXMgLSBSZXByZXNlbnRhdGlvbiBvZiB0aGUgbW9kZWwgb3V0cHV0LiBTZWUgdHlwZSBkZXNjcmlwdGlvbiBvZiBgSW5mZXJlbmNlU2Vzc2lvbi5PdXRwdXRUeXBlYCBmb3JcbiAgICogZGV0YWlsLlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbmFsLiBBIHNldCBvZiBvcHRpb25zIHRoYXQgY29udHJvbHMgdGhlIGJlaGF2aW9yIG9mIG1vZGVsIGluZmVyZW5jZS5cbiAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBtYXAsIHdoaWNoIHVzZXMgb3V0cHV0IG5hbWVzIGFzIGtleXMgYW5kIE9ubnhWYWx1ZSBhcyBjb3JyZXNwb25kaW5nIHZhbHVlcy5cbiAgICovXG4gIHJ1bihmZWVkczogSW5mZXJlbmNlU2Vzc2lvbi5GZWVkc1R5cGUsIGZldGNoZXM6IEluZmVyZW5jZVNlc3Npb24uRmV0Y2hlc1R5cGUsXG4gICAgICBvcHRpb25zPzogSW5mZXJlbmNlU2Vzc2lvbi5SdW5PcHRpb25zKTogUHJvbWlzZTxJbmZlcmVuY2VTZXNzaW9uLlJldHVyblR5cGU+O1xuXG4gIC8vICNlbmRyZWdpb25cblxuICAvLyAjcmVnaW9uIHJlbGVhc2UoKVxuXG4gIC8qKlxuICAgKiBSZWxlYXNlIHRoZSBpbmZlcmVuY2Ugc2Vzc2lvbiBhbmQgdGhlIHVuZGVybHlpbmcgcmVzb3VyY2VzLlxuICAgKi9cbiAgcmVsZWFzZSgpOiBQcm9taXNlPHZvaWQ+O1xuXG4gIC8vICNlbmRyZWdpb25cblxuICAvLyAjcmVnaW9uIHByb2ZpbGluZ1xuXG4gIC8qKlxuICAgKiBTdGFydCBwcm9maWxpbmcuXG4gICAqL1xuICBzdGFydFByb2ZpbGluZygpOiB2b2lkO1xuXG4gIC8qKlxuICAgKiBFbmQgcHJvZmlsaW5nLlxuICAgKi9cbiAgZW5kUHJvZmlsaW5nKCk6IHZvaWQ7XG5cbiAgLy8gI2VuZHJlZ2lvblxuXG4gIC8vICNyZWdpb24gbWV0YWRhdGFcblxuICAvKipcbiAgICogR2V0IGlucHV0IG5hbWVzIG9mIHRoZSBsb2FkZWQgbW9kZWwuXG4gICAqL1xuICByZWFkb25seSBpbnB1dE5hbWVzOiByZWFkb25seSBzdHJpbmdbXTtcblxuICAvKipcbiAgICogR2V0IG91dHB1dCBuYW1lcyBvZiB0aGUgbG9hZGVkIG1vZGVsLlxuICAgKi9cbiAgcmVhZG9ubHkgb3V0cHV0TmFtZXM6IHJlYWRvbmx5IHN0cmluZ1tdO1xuXG4gIC8vIC8qKlxuICAvLyAgKiBHZXQgaW5wdXQgbWV0YWRhdGEgb2YgdGhlIGxvYWRlZCBtb2RlbC5cbiAgLy8gICovXG4gIC8vIHJlYWRvbmx5IGlucHV0TWV0YWRhdGE6IFJlYWRvbmx5QXJyYXk8UmVhZG9ubHk8SW5mZXJlbmNlU2Vzc2lvbi5WYWx1ZU1ldGFkYXRhPj47XG5cbiAgLy8gLyoqXG4gIC8vICAqIEdldCBvdXRwdXQgbWV0YWRhdGEgb2YgdGhlIGxvYWRlZCBtb2RlbC5cbiAgLy8gICovXG4gIC8vIHJlYWRvbmx5IG91dHB1dE1ldGFkYXRhOiBSZWFkb25seUFycmF5PFJlYWRvbmx5PEluZmVyZW5jZVNlc3Npb24uVmFsdWVNZXRhZGF0YT4+O1xuXG4gIC8vICNlbmRyZWdpb25cbn1cblxuZXhwb3J0IGludGVyZmFjZSBJbmZlcmVuY2VTZXNzaW9uRmFjdG9yeSB7XG4gIC8vICNyZWdpb24gY3JlYXRlKClcblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IGluZmVyZW5jZSBzZXNzaW9uIGFuZCBsb2FkIG1vZGVsIGFzeW5jaHJvbm91c2x5IGZyb20gYW4gT05OWCBtb2RlbCBmaWxlLlxuICAgKlxuICAgKiBAcGFyYW0gdXJpIC0gVGhlIFVSSSBvciBmaWxlIHBhdGggb2YgdGhlIG1vZGVsIHRvIGxvYWQuXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gc3BlY2lmeSBjb25maWd1cmF0aW9uIGZvciBjcmVhdGluZyBhIG5ldyBpbmZlcmVuY2Ugc2Vzc2lvbi5cbiAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYW4gSW5mZXJlbmNlU2Vzc2lvbiBvYmplY3QuXG4gICAqL1xuICBjcmVhdGUodXJpOiBzdHJpbmcsIG9wdGlvbnM/OiBJbmZlcmVuY2VTZXNzaW9uLlNlc3Npb25PcHRpb25zKTogUHJvbWlzZTxJbmZlcmVuY2VTZXNzaW9uPjtcblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IGluZmVyZW5jZSBzZXNzaW9uIGFuZCBsb2FkIG1vZGVsIGFzeW5jaHJvbm91c2x5IGZyb20gYW4gYXJyYXkgYnVmZXIuXG4gICAqXG4gICAqIEBwYXJhbSBidWZmZXIgLSBBbiBBcnJheUJ1ZmZlciByZXByZXNlbnRhdGlvbiBvZiBhbiBPTk5YIG1vZGVsLlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIHNwZWNpZnkgY29uZmlndXJhdGlvbiBmb3IgY3JlYXRpbmcgYSBuZXcgaW5mZXJlbmNlIHNlc3Npb24uXG4gICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGFuIEluZmVyZW5jZVNlc3Npb24gb2JqZWN0LlxuICAgKi9cbiAgY3JlYXRlKGJ1ZmZlcjogQXJyYXlCdWZmZXJMaWtlLCBvcHRpb25zPzogSW5mZXJlbmNlU2Vzc2lvbi5TZXNzaW9uT3B0aW9ucyk6IFByb21pc2U8SW5mZXJlbmNlU2Vzc2lvbj47XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBpbmZlcmVuY2Ugc2Vzc2lvbiBhbmQgbG9hZCBtb2RlbCBhc3luY2hyb25vdXNseSBmcm9tIHNlZ21lbnQgb2YgYW4gYXJyYXkgYnVmZXIuXG4gICAqXG4gICAqIEBwYXJhbSBidWZmZXIgLSBBbiBBcnJheUJ1ZmZlciByZXByZXNlbnRhdGlvbiBvZiBhbiBPTk5YIG1vZGVsLlxuICAgKiBAcGFyYW0gYnl0ZU9mZnNldCAtIFRoZSBiZWdpbm5pbmcgb2YgdGhlIHNwZWNpZmllZCBwb3J0aW9uIG9mIHRoZSBhcnJheSBidWZmZXIuXG4gICAqIEBwYXJhbSBieXRlTGVuZ3RoIC0gVGhlIGxlbmd0aCBpbiBieXRlcyBvZiB0aGUgYXJyYXkgYnVmZmVyLlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIHNwZWNpZnkgY29uZmlndXJhdGlvbiBmb3IgY3JlYXRpbmcgYSBuZXcgaW5mZXJlbmNlIHNlc3Npb24uXG4gICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGFuIEluZmVyZW5jZVNlc3Npb24gb2JqZWN0LlxuICAgKi9cbiAgY3JlYXRlKGJ1ZmZlcjogQXJyYXlCdWZmZXJMaWtlLCBieXRlT2Zmc2V0OiBudW1iZXIsIGJ5dGVMZW5ndGg/OiBudW1iZXIsIG9wdGlvbnM/OiBJbmZlcmVuY2VTZXNzaW9uLlNlc3Npb25PcHRpb25zKTpcbiAgICAgIFByb21pc2U8SW5mZXJlbmNlU2Vzc2lvbj47XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBpbmZlcmVuY2Ugc2Vzc2lvbiBhbmQgbG9hZCBtb2RlbCBhc3luY2hyb25vdXNseSBmcm9tIGEgVWludDhBcnJheS5cbiAgICpcbiAgICogQHBhcmFtIGJ1ZmZlciAtIEEgVWludDhBcnJheSByZXByZXNlbnRhdGlvbiBvZiBhbiBPTk5YIG1vZGVsLlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIHNwZWNpZnkgY29uZmlndXJhdGlvbiBmb3IgY3JlYXRpbmcgYSBuZXcgaW5mZXJlbmNlIHNlc3Npb24uXG4gICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGFuIEluZmVyZW5jZVNlc3Npb24gb2JqZWN0LlxuICAgKi9cbiAgY3JlYXRlKGJ1ZmZlcjogVWludDhBcnJheSwgb3B0aW9ucz86IEluZmVyZW5jZVNlc3Npb24uU2Vzc2lvbk9wdGlvbnMpOiBQcm9taXNlPEluZmVyZW5jZVNlc3Npb24+O1xuXG4gIC8vICNlbmRyZWdpb25cbn1cblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvblxuZXhwb3J0IGNvbnN0IEluZmVyZW5jZVNlc3Npb246IEluZmVyZW5jZVNlc3Npb25GYWN0b3J5ID0gSW5mZXJlbmNlU2Vzc2lvbkltcGw7XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7VGVuc29yfSBmcm9tICcuL3RlbnNvci5qcyc7XG5cbnR5cGUgTm9uVGVuc29yVHlwZSA9IG5ldmVyO1xuXG4vKipcbiAqIFR5cGUgT25ueFZhbHVlIFJlcHJlc2VudHMgYm90aCB0ZW5zb3JzIGFuZCBub24tdGVuc29ycyB2YWx1ZSBmb3IgbW9kZWwncyBpbnB1dHMvb3V0cHV0cy5cbiAqXG4gKiBOT1RFOiBjdXJyZW50bHkgbm90IHN1cHBvcnQgbm9uLXRlbnNvclxuICovXG5leHBvcnQgdHlwZSBPbm54VmFsdWUgPSBUZW5zb3J8Tm9uVGVuc29yVHlwZTtcblxuLyoqXG4gKiBUeXBlIE9ubnhWYWx1ZURhdGFMb2NhdGlvbiByZXByZXNlbnRzIHRoZSBsb2NhdGlvbiBvZiB0aGUgZGF0YSBvZiBhbiBPbm54VmFsdWUuXG4gKi9cbmV4cG9ydCB0eXBlIE9ubnhWYWx1ZURhdGFMb2NhdGlvbiA9IFRlbnNvci5EYXRhTG9jYXRpb247XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7cmVzb2x2ZUJhY2tlbmR9IGZyb20gJy4vYmFja2VuZC1pbXBsLmpzJztcbmltcG9ydCB7U2Vzc2lvbkhhbmRsZXIsIFRyYWluaW5nU2Vzc2lvbkhhbmRsZXJ9IGZyb20gJy4vYmFja2VuZC5qcyc7XG5pbXBvcnQge0luZmVyZW5jZVNlc3Npb24gYXMgSW5mZXJlbmNlU2Vzc2lvbn0gZnJvbSAnLi9pbmZlcmVuY2Utc2Vzc2lvbi5qcyc7XG5pbXBvcnQge09ubnhWYWx1ZX0gZnJvbSAnLi9vbm54LXZhbHVlLmpzJztcbmltcG9ydCB7VGVuc29yfSBmcm9tICcuL3RlbnNvci5qcyc7XG5pbXBvcnQge1RyYWluaW5nU2Vzc2lvbiBhcyBUcmFpbmluZ1Nlc3Npb25JbnRlcmZhY2UsIFRyYWluaW5nU2Vzc2lvbkNyZWF0ZU9wdGlvbnN9IGZyb20gJy4vdHJhaW5pbmctc2Vzc2lvbi5qcyc7XG5cbnR5cGUgU2Vzc2lvbk9wdGlvbnMgPSBJbmZlcmVuY2VTZXNzaW9uLlNlc3Npb25PcHRpb25zO1xudHlwZSBGZWVkc1R5cGUgPSBJbmZlcmVuY2VTZXNzaW9uLkZlZWRzVHlwZTtcbnR5cGUgRmV0Y2hlc1R5cGUgPSBJbmZlcmVuY2VTZXNzaW9uLkZldGNoZXNUeXBlO1xudHlwZSBSZXR1cm5UeXBlID0gSW5mZXJlbmNlU2Vzc2lvbi5SZXR1cm5UeXBlO1xudHlwZSBSdW5PcHRpb25zID0gSW5mZXJlbmNlU2Vzc2lvbi5SdW5PcHRpb25zO1xuXG5jb25zdCBub0JhY2tlbmRFcnJNc2c6IHN0cmluZyA9ICdUcmFpbmluZyBiYWNrZW5kIGNvdWxkIG5vdCBiZSByZXNvbHZlZC4gJyArXG4gICAgJ01ha2Ugc3VyZSB5b3VcXCdyZSB1c2luZyB0aGUgY29ycmVjdCBjb25maWd1cmF0aW9uICYgV2ViQXNzZW1ibHkgZmlsZXMuJztcblxuZXhwb3J0IGNsYXNzIFRyYWluaW5nU2Vzc2lvbiBpbXBsZW1lbnRzIFRyYWluaW5nU2Vzc2lvbkludGVyZmFjZSB7XG4gIHByaXZhdGUgY29uc3RydWN0b3IoaGFuZGxlcjogVHJhaW5pbmdTZXNzaW9uSGFuZGxlciwgaGFzT3B0aW1pemVyTW9kZWw6IGJvb2xlYW4sIGhhc0V2YWxNb2RlbDogYm9vbGVhbikge1xuICAgIHRoaXMuaGFuZGxlciA9IGhhbmRsZXI7XG4gICAgdGhpcy5oYXNPcHRpbWl6ZXJNb2RlbCA9IGhhc09wdGltaXplck1vZGVsO1xuICAgIHRoaXMuaGFzRXZhbE1vZGVsID0gaGFzRXZhbE1vZGVsO1xuICB9XG4gIHByaXZhdGUgaGFuZGxlcjogVHJhaW5pbmdTZXNzaW9uSGFuZGxlcjtcbiAgcHJpdmF0ZSBoYXNPcHRpbWl6ZXJNb2RlbDogYm9vbGVhbjtcbiAgcHJpdmF0ZSBoYXNFdmFsTW9kZWw6IGJvb2xlYW47XG5cbiAgZ2V0IHRyYWluaW5nSW5wdXROYW1lcygpOiByZWFkb25seSBzdHJpbmdbXSB7XG4gICAgcmV0dXJuIHRoaXMuaGFuZGxlci5pbnB1dE5hbWVzO1xuICB9XG4gIGdldCB0cmFpbmluZ091dHB1dE5hbWVzKCk6IHJlYWRvbmx5IHN0cmluZ1tdIHtcbiAgICByZXR1cm4gdGhpcy5oYW5kbGVyLm91dHB1dE5hbWVzO1xuICB9XG5cbiAgZ2V0IGV2YWxJbnB1dE5hbWVzKCk6IHJlYWRvbmx5IHN0cmluZ1tdIHtcbiAgICBpZiAodGhpcy5oYXNFdmFsTW9kZWwpIHtcbiAgICAgIHJldHVybiB0aGlzLmhhbmRsZXIuZXZhbElucHV0TmFtZXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyB0cmFpbmluZyBzZXNzaW9uIGhhcyBubyBldmFsTW9kZWwgbG9hZGVkLicpO1xuICAgIH1cbiAgfVxuICBnZXQgZXZhbE91dHB1dE5hbWVzKCk6IHJlYWRvbmx5IHN0cmluZ1tdIHtcbiAgICBpZiAodGhpcy5oYXNFdmFsTW9kZWwpIHtcbiAgICAgIHJldHVybiB0aGlzLmhhbmRsZXIuZXZhbE91dHB1dE5hbWVzO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgdHJhaW5pbmcgc2Vzc2lvbiBoYXMgbm8gZXZhbE1vZGVsIGxvYWRlZC4nKTtcbiAgICB9XG4gIH1cblxuICBzdGF0aWMgYXN5bmMgY3JlYXRlKHRyYWluaW5nT3B0aW9uczogVHJhaW5pbmdTZXNzaW9uQ3JlYXRlT3B0aW9ucywgc2Vzc2lvbk9wdGlvbnM/OiBTZXNzaW9uT3B0aW9ucyk6XG4gICAgICBQcm9taXNlPFRyYWluaW5nU2Vzc2lvbj4ge1xuICAgIGNvbnN0IGV2YWxNb2RlbDogc3RyaW5nfFVpbnQ4QXJyYXkgPSB0cmFpbmluZ09wdGlvbnMuZXZhbE1vZGVsIHx8ICcnO1xuICAgIGNvbnN0IG9wdGltaXplck1vZGVsOiBzdHJpbmd8VWludDhBcnJheSA9IHRyYWluaW5nT3B0aW9ucy5vcHRpbWl6ZXJNb2RlbCB8fCAnJztcbiAgICBjb25zdCBvcHRpb25zOiBTZXNzaW9uT3B0aW9ucyA9IHNlc3Npb25PcHRpb25zIHx8IHt9O1xuXG4gICAgLy8gZ2V0IGJhY2tlbmQgaGludHNcbiAgICBjb25zdCBlcHMgPSBvcHRpb25zLmV4ZWN1dGlvblByb3ZpZGVycyB8fCBbXTtcbiAgICBjb25zdCBiYWNrZW5kSGludHMgPSBlcHMubWFwKGkgPT4gdHlwZW9mIGkgPT09ICdzdHJpbmcnID8gaSA6IGkubmFtZSk7XG4gICAgY29uc3QgYmFja2VuZCA9IGF3YWl0IHJlc29sdmVCYWNrZW5kKGJhY2tlbmRIaW50cyk7XG4gICAgaWYgKGJhY2tlbmQuY3JlYXRlVHJhaW5pbmdTZXNzaW9uSGFuZGxlcikge1xuICAgICAgY29uc3QgaGFuZGxlciA9IGF3YWl0IGJhY2tlbmQuY3JlYXRlVHJhaW5pbmdTZXNzaW9uSGFuZGxlcihcbiAgICAgICAgICB0cmFpbmluZ09wdGlvbnMuY2hlY2twb2ludFN0YXRlLCB0cmFpbmluZ09wdGlvbnMudHJhaW5Nb2RlbCwgZXZhbE1vZGVsLCBvcHRpbWl6ZXJNb2RlbCwgb3B0aW9ucyk7XG4gICAgICByZXR1cm4gbmV3IFRyYWluaW5nU2Vzc2lvbihoYW5kbGVyLCAhIXRyYWluaW5nT3B0aW9ucy5vcHRpbWl6ZXJNb2RlbCwgISF0cmFpbmluZ09wdGlvbnMuZXZhbE1vZGVsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKG5vQmFja2VuZEVyck1zZyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEhlbHBlciBmdW5jdGlvbiBmb3IgcnVuVHJhaW5TdGVwIGFuZCBmdXR1cmUgcnVuU3RlcCBtZXRob2RzIHRoYXQgaGFuZGxlcyB0aGUgdHlwZS1uYXJyb3dpbmcgY29udmVyc2lvbiBmcm9tXG4gICAqIHRoZSBnaXZlbiBwYXJhbWV0ZXJzIHRvIFNlc3Npb25IYW5kbGVyLkZldGNoZXNUeXBlIGFuZCBSdW5PcHRpb25zLlxuICAgKlxuICAgKiBAcGFyYW0gaW5wdXROYW1lcyB0aGUgZmVlZHMgb2JqZWN0IGlzIGNoZWNrZWQgdGhhdCB0aGV5IGNvbnRhaW4gYWxsIGlucHV0IG5hbWVzIGluIHRoZSBwcm92aWRlZCBsaXN0IG9mIGlucHV0XG4gICAqIG5hbWVzLlxuICAgKiBAcGFyYW0gb3V0cHV0TmFtZXMgdGhlIGZldGNoZXMgb2JqZWN0IGlzIGNoZWNrZWQgdGhhdCB0aGVpciBrZXlzIG1hdGNoIHVwIHdpdGggdmFsaWQgbmFtZXMgaW4gdGhlIGxpc3Qgb2Ygb3V0cHV0XG4gICAqIG5hbWVzLlxuICAgKiBAcGFyYW0gZmVlZHMgdGhlIHJlcXVpcmVkIGlucHV0XG4gICAqIEBwYXJhbSBhcmcxIG5hcnJvd2VkICYgY29udmVydGVkIGludG8gdGhlIFNlc3Npb25IYW5kbGVyLkZldGNoZXNUeXBlIG9yIFJ1bk9wdGlvbnMgb2JqZWN0XG4gICAqIEBwYXJhbSBhcmcyIG9wdGlvbmFsIFJ1bk9wdGlvbnMgb2JqZWN0LlxuICAgKiBAcmV0dXJuc1xuICAgKi9cbiAgdHlwZU5hcnJvd2luZ0ZvclJ1blN0ZXAoXG4gICAgICBpbnB1dE5hbWVzOiByZWFkb25seSBzdHJpbmdbXSwgb3V0cHV0TmFtZXM6IHJlYWRvbmx5IHN0cmluZ1tdLCBmZWVkczogRmVlZHNUeXBlLCBhcmcxPzogRmV0Y2hlc1R5cGV8UnVuT3B0aW9ucyxcbiAgICAgIGFyZzI/OiBSdW5PcHRpb25zKTogW1Nlc3Npb25IYW5kbGVyLkZldGNoZXNUeXBlLCBSdW5PcHRpb25zXSB7XG4gICAgY29uc3QgZmV0Y2hlczoge1tuYW1lOiBzdHJpbmddOiBPbm54VmFsdWV8bnVsbH0gPSB7fTtcbiAgICBsZXQgb3B0aW9uczogUnVuT3B0aW9ucyA9IHt9O1xuICAgIC8vIGNoZWNrIGlucHV0c1xuICAgIGlmICh0eXBlb2YgZmVlZHMgIT09ICdvYmplY3QnIHx8IGZlZWRzID09PSBudWxsIHx8IGZlZWRzIGluc3RhbmNlb2YgVGVuc29yIHx8IEFycmF5LmlzQXJyYXkoZmVlZHMpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICdcXCdmZWVkc1xcJyBtdXN0IGJlIGFuIG9iamVjdCB0aGF0IHVzZSBpbnB1dCBuYW1lcyBhcyBrZXlzIGFuZCBPbm54VmFsdWUgYXMgY29ycmVzcG9uZGluZyB2YWx1ZXMuJyk7XG4gICAgfVxuXG4gICAgbGV0IGlzRmV0Y2hlc0VtcHR5ID0gdHJ1ZTtcbiAgICAvLyBkZXRlcm1pbmUgd2hpY2ggb3ZlcnJpZGUgaXMgYmVpbmcgdXNlZFxuICAgIGlmICh0eXBlb2YgYXJnMSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGlmIChhcmcxID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1VuZXhwZWN0ZWQgYXJndW1lbnRbMV06IGNhbm5vdCBiZSBudWxsLicpO1xuICAgICAgfVxuICAgICAgaWYgKGFyZzEgaW5zdGFuY2VvZiBUZW5zb3IpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXFwnZmV0Y2hlc1xcJyBjYW5ub3QgYmUgYSBUZW5zb3InKTtcbiAgICAgIH1cblxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYXJnMSkpIHtcbiAgICAgICAgaWYgKGFyZzEubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXFwnZmV0Y2hlc1xcJyBjYW5ub3QgYmUgYW4gZW1wdHkgYXJyYXkuJyk7XG4gICAgICAgIH1cbiAgICAgICAgaXNGZXRjaGVzRW1wdHkgPSBmYWxzZTtcbiAgICAgICAgLy8gb3V0cHV0IG5hbWVzXG4gICAgICAgIGZvciAoY29uc3QgbmFtZSBvZiBhcmcxKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBuYW1lICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXFwnZmV0Y2hlc1xcJyBtdXN0IGJlIGEgc3RyaW5nIGFycmF5IG9yIGFuIG9iamVjdC4nKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG91dHB1dE5hbWVzLmluZGV4T2YobmFtZSkgPT09IC0xKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgJ2ZldGNoZXMnIGNvbnRhaW5zIGludmFsaWQgb3V0cHV0IG5hbWU6ICR7bmFtZX0uYCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZldGNoZXNbbmFtZV0gPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBhcmcyID09PSAnb2JqZWN0JyAmJiBhcmcyICE9PSBudWxsKSB7XG4gICAgICAgICAgb3B0aW9ucyA9IGFyZzI7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGFyZzIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXFwnb3B0aW9uc1xcJyBtdXN0IGJlIGFuIG9iamVjdC4nKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZGVjaWRlIHdoZXRoZXIgYXJnMSBpcyBmZXRjaGVzIG9yIG9wdGlvbnNcbiAgICAgICAgLy8gaWYgYW55IG91dHB1dCBuYW1lIGlzIHByZXNlbnQgYW5kIGl0cyB2YWx1ZSBpcyB2YWxpZCBPbm54VmFsdWUsIHdlIGNvbnNpZGVyIGl0IGZldGNoZXNcbiAgICAgICAgbGV0IGlzRmV0Y2hlcyA9IGZhbHNlO1xuICAgICAgICBjb25zdCBhcmcxS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGFyZzEpO1xuICAgICAgICBmb3IgKGNvbnN0IG5hbWUgb2Ygb3V0cHV0TmFtZXMpIHtcbiAgICAgICAgICBpZiAoYXJnMUtleXMuaW5kZXhPZihuYW1lKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIGNvbnN0IHYgPSAoYXJnMSBhcyBJbmZlcmVuY2VTZXNzaW9uLk51bGxhYmxlT25ueFZhbHVlTWFwVHlwZSlbbmFtZV07XG4gICAgICAgICAgICBpZiAodiA9PT0gbnVsbCB8fCB2IGluc3RhbmNlb2YgVGVuc29yKSB7XG4gICAgICAgICAgICAgIGlzRmV0Y2hlcyA9IHRydWU7XG4gICAgICAgICAgICAgIGlzRmV0Y2hlc0VtcHR5ID0gZmFsc2U7XG4gICAgICAgICAgICAgIGZldGNoZXNbbmFtZV0gPSB2O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0ZldGNoZXMpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIGFyZzIgPT09ICdvYmplY3QnICYmIGFyZzIgIT09IG51bGwpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBhcmcyO1xuICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGFyZzIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcXCdvcHRpb25zXFwnIG11c3QgYmUgYW4gb2JqZWN0LicpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvcHRpb25zID0gYXJnMSBhcyBSdW5PcHRpb25zO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgYXJnMSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1VuZXhwZWN0ZWQgYXJndW1lbnRbMV06IG11c3QgYmUgXFwnZmV0Y2hlc1xcJyBvciBcXCdvcHRpb25zXFwnLicpO1xuICAgIH1cblxuICAgIC8vIGNoZWNrIGlmIGFsbCBpbnB1dHMgYXJlIGluIGZlZWRcbiAgICBmb3IgKGNvbnN0IG5hbWUgb2YgaW5wdXROYW1lcykge1xuICAgICAgaWYgKHR5cGVvZiBmZWVkc1tuYW1lXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnB1dCAnJHtuYW1lfScgaXMgbWlzc2luZyBpbiAnZmVlZHMnLmApO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGlmIG5vIGZldGNoZXMgaXMgc3BlY2lmaWVkLCB3ZSB1c2UgdGhlIGZ1bGwgb3V0cHV0IG5hbWVzIGxpc3RcbiAgICBpZiAoaXNGZXRjaGVzRW1wdHkpIHtcbiAgICAgIGZvciAoY29uc3QgbmFtZSBvZiBvdXRwdXROYW1lcykge1xuICAgICAgICBmZXRjaGVzW25hbWVdID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gW2ZldGNoZXMsIG9wdGlvbnNdO1xuICB9XG5cbiAgLyoqXG4gICAqIEhlbHBlciBtZXRob2QgZm9yIHJ1blRyYWluU3RlcCBhbmQgYW55IG90aGVyIHJ1blN0ZXAgbWV0aG9kcy4gVGFrZXMgdGhlIFJldHVyblR5cGUgcmVzdWx0IGZyb20gdGhlIFNlc3Npb25IYW5kbGVyXG4gICAqIGFuZCBjaGFuZ2VzIGl0IGludG8gYSBtYXAgb2YgVGVuc29ycy5cbiAgICpcbiAgICogQHBhcmFtIHJlc3VsdHNcbiAgICogQHJldHVybnNcbiAgICovXG4gIGNvbnZlcnRIYW5kbGVyUmV0dXJuVHlwZVRvTWFwT2ZUZW5zb3JzKHJlc3VsdHM6IFNlc3Npb25IYW5kbGVyLlJldHVyblR5cGUpOiBSZXR1cm5UeXBlIHtcbiAgICBjb25zdCByZXR1cm5WYWx1ZToge1tuYW1lOiBzdHJpbmddOiBPbm54VmFsdWV9ID0ge307XG4gICAgZm9yIChjb25zdCBrZXkgaW4gcmVzdWx0cykge1xuICAgICAgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKHJlc3VsdHMsIGtleSkpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gcmVzdWx0c1trZXldO1xuICAgICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgVGVuc29yKSB7XG4gICAgICAgICAgcmV0dXJuVmFsdWVba2V5XSA9IHJlc3VsdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm5WYWx1ZVtrZXldID0gbmV3IFRlbnNvcihyZXN1bHQudHlwZSwgcmVzdWx0LmRhdGEsIHJlc3VsdC5kaW1zKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmV0dXJuVmFsdWU7XG4gIH1cblxuICBhc3luYyBsYXp5UmVzZXRHcmFkKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIGF3YWl0IHRoaXMuaGFuZGxlci5sYXp5UmVzZXRHcmFkKCk7XG4gIH1cblxuICBydW5UcmFpblN0ZXAoZmVlZHM6IEZlZWRzVHlwZSwgb3B0aW9ucz86IFJ1bk9wdGlvbnMpOiBQcm9taXNlPFJldHVyblR5cGU+O1xuICBydW5UcmFpblN0ZXAoZmVlZHM6IEZlZWRzVHlwZSwgZmV0Y2hlczogRmV0Y2hlc1R5cGUsIG9wdGlvbnM/OiBSdW5PcHRpb25zKTogUHJvbWlzZTxSZXR1cm5UeXBlPjtcbiAgYXN5bmMgcnVuVHJhaW5TdGVwKGZlZWRzOiBGZWVkc1R5cGUsIGFyZzE/OiBGZXRjaGVzVHlwZXxSdW5PcHRpb25zLCBhcmcyPzogUnVuT3B0aW9ucyk6IFByb21pc2U8UmV0dXJuVHlwZT4ge1xuICAgIGNvbnN0IFtmZXRjaGVzLCBvcHRpb25zXSA9XG4gICAgICAgIHRoaXMudHlwZU5hcnJvd2luZ0ZvclJ1blN0ZXAodGhpcy50cmFpbmluZ0lucHV0TmFtZXMsIHRoaXMudHJhaW5pbmdPdXRwdXROYW1lcywgZmVlZHMsIGFyZzEsIGFyZzIpO1xuICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCB0aGlzLmhhbmRsZXIucnVuVHJhaW5TdGVwKGZlZWRzLCBmZXRjaGVzLCBvcHRpb25zKTtcbiAgICByZXR1cm4gdGhpcy5jb252ZXJ0SGFuZGxlclJldHVyblR5cGVUb01hcE9mVGVuc29ycyhyZXN1bHRzKTtcbiAgfVxuXG4gIGFzeW5jIHJ1bk9wdGltaXplclN0ZXAob3B0aW9ucz86IEluZmVyZW5jZVNlc3Npb24uUnVuT3B0aW9uc3x1bmRlZmluZWQpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBpZiAodGhpcy5oYXNPcHRpbWl6ZXJNb2RlbCkge1xuICAgICAgYXdhaXQgdGhpcy5oYW5kbGVyLnJ1bk9wdGltaXplclN0ZXAob3B0aW9ucyB8fCB7fSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyBUcmFpbmluZ1Nlc3Npb24gaGFzIG5vIE9wdGltaXplck1vZGVsIGxvYWRlZC4nKTtcbiAgICB9XG4gIH1cblxuICBydW5FdmFsU3RlcChmZWVkczogRmVlZHNUeXBlLCBvcHRpb25zPzogUnVuT3B0aW9uc3x1bmRlZmluZWQpOiBQcm9taXNlPFJldHVyblR5cGU+O1xuICBydW5FdmFsU3RlcChmZWVkczogRmVlZHNUeXBlLCBmZXRjaGVzOiBGZXRjaGVzVHlwZSwgb3B0aW9ucz86IFJ1bk9wdGlvbnN8dW5kZWZpbmVkKTogUHJvbWlzZTxSZXR1cm5UeXBlPjtcbiAgYXN5bmMgcnVuRXZhbFN0ZXAoZmVlZHM6IEZlZWRzVHlwZSwgYXJnMT86IEZldGNoZXNUeXBlfFJ1bk9wdGlvbnMsIGFyZzI/OiBSdW5PcHRpb25zKTogUHJvbWlzZTxSZXR1cm5UeXBlPiB7XG4gICAgaWYgKHRoaXMuaGFzRXZhbE1vZGVsKSB7XG4gICAgICBjb25zdCBbZmV0Y2hlcywgb3B0aW9uc10gPVxuICAgICAgICAgIHRoaXMudHlwZU5hcnJvd2luZ0ZvclJ1blN0ZXAodGhpcy5ldmFsSW5wdXROYW1lcywgdGhpcy5ldmFsT3V0cHV0TmFtZXMsIGZlZWRzLCBhcmcxLCBhcmcyKTtcbiAgICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCB0aGlzLmhhbmRsZXIucnVuRXZhbFN0ZXAoZmVlZHMsIGZldGNoZXMsIG9wdGlvbnMpO1xuICAgICAgcmV0dXJuIHRoaXMuY29udmVydEhhbmRsZXJSZXR1cm5UeXBlVG9NYXBPZlRlbnNvcnMocmVzdWx0cyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyBUcmFpbmluZ1Nlc3Npb24gaGFzIG5vIEV2YWxNb2RlbCBsb2FkZWQuJyk7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgZ2V0UGFyYW1ldGVyc1NpemUodHJhaW5hYmxlT25seSA9IHRydWUpOiBQcm9taXNlPG51bWJlcj4ge1xuICAgIHJldHVybiB0aGlzLmhhbmRsZXIuZ2V0UGFyYW1ldGVyc1NpemUodHJhaW5hYmxlT25seSk7XG4gIH1cblxuICBhc3luYyBsb2FkUGFyYW1ldGVyc0J1ZmZlcihhcnJheTogVWludDhBcnJheSwgdHJhaW5hYmxlT25seSA9IHRydWUpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCBwYXJhbXNTaXplID0gYXdhaXQgdGhpcy5nZXRQYXJhbWV0ZXJzU2l6ZSh0cmFpbmFibGVPbmx5KTtcbiAgICAvLyBjaGVja2luZyB0aGF0IHRoZSBzaXplIG9mIHRoZSBVaW50OEFycmF5IGlzIGVxdWl2YWxlbnQgdG8gdGhlIGJ5dGUgbGVuZ3RoIG9mIGEgRmxvYXQzMkFycmF5IG9mIHRoZSBudW1iZXJcbiAgICAvLyBvZiBwYXJhbWV0ZXJzXG4gICAgaWYgKGFycmF5Lmxlbmd0aCAhPT0gNCAqIHBhcmFtc1NpemUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAnU2l6ZSBvZiB0aGUgYnVmZmVyIHBhc3NlZCBpbnRvIGxvYWRQYXJhbWV0ZXJzQnVmZmVyIG11c3QgbWF0Y2ggdGhlIG51bWJlciBvZiBwYXJhbWV0ZXJzIGluICcgK1xuICAgICAgICAgICd0aGUgbW9kZWwuIFBsZWFzZSB1c2UgZ2V0UGFyYW1ldGVyc1NpemUgbWV0aG9kIHRvIGNoZWNrLicpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5oYW5kbGVyLmxvYWRQYXJhbWV0ZXJzQnVmZmVyKGFycmF5LCB0cmFpbmFibGVPbmx5KTtcbiAgfVxuXG4gIGFzeW5jIGdldENvbnRpZ3VvdXNQYXJhbWV0ZXJzKHRyYWluYWJsZU9ubHkgPSB0cnVlKTogUHJvbWlzZTxPbm54VmFsdWU+IHtcbiAgICByZXR1cm4gdGhpcy5oYW5kbGVyLmdldENvbnRpZ3VvdXNQYXJhbWV0ZXJzKHRyYWluYWJsZU9ubHkpO1xuICB9XG5cbiAgYXN5bmMgcmVsZWFzZSgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICByZXR1cm4gdGhpcy5oYW5kbGVyLmRpc3Bvc2UoKTtcbiAgfVxufVxuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge0luZmVyZW5jZVNlc3Npb259IGZyb20gJy4vaW5mZXJlbmNlLXNlc3Npb24uanMnO1xuaW1wb3J0IHtPbm54VmFsdWV9IGZyb20gJy4vb25ueC12YWx1ZS5qcyc7XG5pbXBvcnQge1RyYWluaW5nU2Vzc2lvbiBhcyBUcmFpbmluZ1Nlc3Npb25JbXBsfSBmcm9tICcuL3RyYWluaW5nLXNlc3Npb24taW1wbC5qcyc7XG5cbi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1yZWRlY2xhcmUgKi9cblxuZXhwb3J0IGRlY2xhcmUgbmFtZXNwYWNlIFRyYWluaW5nU2Vzc2lvbiB7XG4gIC8qKlxuICAgKiBFaXRoZXIgVVJJIGZpbGUgcGF0aCAoc3RyaW5nKSBvciBVaW50OEFycmF5IGNvbnRhaW5pbmcgbW9kZWwgb3IgY2hlY2twb2ludCBpbmZvcm1hdGlvbi5cbiAgICovXG4gIHR5cGUgVVJJb3JCdWZmZXIgPSBzdHJpbmd8VWludDhBcnJheTtcbn1cblxuLyoqXG4gKiBSZXByZXNlbnQgYSBydW50aW1lIGluc3RhbmNlIG9mIGFuIE9OTlggdHJhaW5pbmcgc2Vzc2lvbixcbiAqIHdoaWNoIGNvbnRhaW5zIGEgbW9kZWwgdGhhdCBjYW4gYmUgdHJhaW5lZCwgYW5kLCBvcHRpb25hbGx5LFxuICogYW4gZXZhbCBhbmQgb3B0aW1pemVyIG1vZGVsLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFRyYWluaW5nU2Vzc2lvbiB7XG4gIC8vICNyZWdpb24gcnVuKClcblxuICAvKipcbiAgICogTGF6aWx5IHJlc2V0cyB0aGUgZ3JhZGllbnRzIG9mIGFsbCB0cmFpbmFibGUgcGFyYW1ldGVycyB0byB6ZXJvLiBTaG91bGQgaGFwcGVuIGFmdGVyIHRoZSBpbnZvY2F0aW9uIG9mXG4gICAqIHJ1bk9wdGltaXplclN0ZXAuXG4gICAqL1xuICBsYXp5UmVzZXRHcmFkKCk6IFByb21pc2U8dm9pZD47XG5cbiAgLyoqXG4gICAqIFJ1biBUcmFpblN0ZXAgYXN5bmNocm9ub3VzbHkgd2l0aCB0aGUgZ2l2ZW4gZmVlZHMgYW5kIG9wdGlvbnMuXG4gICAqXG4gICAqIEBwYXJhbSBmZWVkcyAtIFJlcHJlc2VudGF0aW9uIG9mIHRoZSBtb2RlbCBpbnB1dC4gU2VlIHR5cGUgZGVzY3JpcHRpb24gb2YgYEluZmVyZW5jZVNlc3Npb24uSW5wdXRUeXBlYCBmb3JcbiAgIGRldGFpbC5cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25hbC4gQSBzZXQgb2Ygb3B0aW9ucyB0aGF0IGNvbnRyb2xzIHRoZSBiZWhhdmlvciBvZiBtb2RlbCB0cmFpbmluZy5cbiAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBtYXAsIHdoaWNoIHVzZXMgb3V0cHV0IG5hbWVzIGFzIGtleXMgYW5kIE9ubnhWYWx1ZSBhcyBjb3JyZXNwb25kaW5nIHZhbHVlcy5cbiAgICovXG4gIHJ1blRyYWluU3RlcChmZWVkczogSW5mZXJlbmNlU2Vzc2lvbi5GZWVkc1R5cGUsIG9wdGlvbnM/OiBJbmZlcmVuY2VTZXNzaW9uLlJ1bk9wdGlvbnMpOlxuICAgICAgUHJvbWlzZTxJbmZlcmVuY2VTZXNzaW9uLlJldHVyblR5cGU+O1xuXG4gIC8qKlxuICAgKiBSdW4gYSBzaW5nbGUgdHJhaW4gc3RlcCB3aXRoIHRoZSBnaXZlbiBpbnB1dHMgYW5kIG9wdGlvbnMuXG4gICAqXG4gICAqIEBwYXJhbSBmZWVkcyAtIFJlcHJlc2VudGF0aW9uIG9mIHRoZSBtb2RlbCBpbnB1dC5cbiAgICogQHBhcmFtIGZldGNoZXMgLSBSZXByZXNlbnRhdGlvbiBvZiB0aGUgbW9kZWwgb3V0cHV0LlxuICAgKiBkZXRhaWwuXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9uYWwuIEEgc2V0IG9mIG9wdGlvbnMgdGhhdCBjb250cm9scyB0aGUgYmVoYXZpb3Igb2YgbW9kZWwgdHJhaW5pbmcuXG4gICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgbWFwLCB3aGljaCB1c2VzIG91dHB1dCBuYW1lcyBhcyBrZXlzIGFuZCBPbm54VmFsdWUgYXMgY29ycmVzcG9uZGluZ1xuICAgdmFsdWVzLlxuICAgKi9cbiAgcnVuVHJhaW5TdGVwKFxuICAgICAgZmVlZHM6IEluZmVyZW5jZVNlc3Npb24uRmVlZHNUeXBlLCBmZXRjaGVzOiBJbmZlcmVuY2VTZXNzaW9uLkZldGNoZXNUeXBlLFxuICAgICAgb3B0aW9ucz86IEluZmVyZW5jZVNlc3Npb24uUnVuT3B0aW9ucyk6IFByb21pc2U8SW5mZXJlbmNlU2Vzc2lvbi5SZXR1cm5UeXBlPjtcblxuICAvKipcbiAgICogUnVucyBhIHNpbmdsZSBvcHRpbWl6ZXIgc3RlcCwgd2hpY2ggcGVyZm9ybXMgd2VpZ2h0IHVwZGF0ZXMgZm9yIHRoZSB0cmFpbmFibGUgcGFyYW1ldGVycyB1c2luZyB0aGUgb3B0aW1pemVyIG1vZGVsLlxuICAgKlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbmFsLiBBIHNldCBvZiBvcHRpb25zIHRoYXQgY29udHJvbHMgdGhlIGJlaGF2aW9yIG9mIG1vZGVsIG9wdGltaXppbmcuXG4gICAqL1xuICBydW5PcHRpbWl6ZXJTdGVwKG9wdGlvbnM/OiBJbmZlcmVuY2VTZXNzaW9uLlJ1bk9wdGlvbnMpOiBQcm9taXNlPHZvaWQ+O1xuXG4gIC8qKlxuICAgKiBSdW4gYSBzaW5nbGUgZXZhbCBzdGVwIHdpdGggdGhlIGdpdmVuIGlucHV0cyBhbmQgb3B0aW9ucyB1c2luZyB0aGUgZXZhbCBtb2RlbC5cbiAgICpcbiAgICogQHBhcmFtIGZlZWRzIC0gUmVwcmVzZW50YXRpb24gb2YgdGhlIG1vZGVsIGlucHV0LlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbmFsLiBBIHNldCBvZiBvcHRpb25zIHRoYXQgY29udHJvbHMgdGhlIGJlaGF2aW9yIG9mIG1vZGVsIGV2YWwgc3RlcC5cbiAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBtYXAsIHdoaWNoIHVzZXMgb3V0cHV0IG5hbWVzIGFzIGtleXMgYW5kIE9ubnhWYWx1ZSBhcyBjb3JyZXNwb25kaW5nXG4gICB2YWx1ZXMuXG4gICAqL1xuICBydW5FdmFsU3RlcChmZWVkczogSW5mZXJlbmNlU2Vzc2lvbi5GZWVkc1R5cGUsIG9wdGlvbnM/OiBJbmZlcmVuY2VTZXNzaW9uLlJ1bk9wdGlvbnMpOlxuICAgICAgUHJvbWlzZTxJbmZlcmVuY2VTZXNzaW9uLlJldHVyblR5cGU+O1xuXG4gIC8qKlxuICAgKiBSdW4gYSBzaW5nbGUgZXZhbCBzdGVwIHdpdGggdGhlIGdpdmVuIGlucHV0cyBhbmQgb3B0aW9ucyB1c2luZyB0aGUgZXZhbCBtb2RlbC5cbiAgICpcbiAgICogQHBhcmFtIGZlZWRzIC0gUmVwcmVzZW50YXRpb24gb2YgdGhlIG1vZGVsIGlucHV0LlxuICAgKiBAcGFyYW0gZmV0Y2hlcyAtIFJlcHJlc2VudGF0aW9uIG9mIHRoZSBtb2RlbCBvdXRwdXQuXG4gICAqIGRldGFpbC5cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25hbC4gQSBzZXQgb2Ygb3B0aW9ucyB0aGF0IGNvbnRyb2xzIHRoZSBiZWhhdmlvciBvZiBtb2RlbCBldmFsIHN0ZXAuXG4gICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgbWFwLCB3aGljaCB1c2VzIG91dHB1dCBuYW1lcyBhcyBrZXlzIGFuZCBPbm54VmFsdWUgYXMgY29ycmVzcG9uZGluZ1xuICAgdmFsdWVzLlxuICAgKi9cbiAgcnVuRXZhbFN0ZXAoXG4gICAgICBmZWVkczogSW5mZXJlbmNlU2Vzc2lvbi5GZWVkc1R5cGUsIGZldGNoZXM6IEluZmVyZW5jZVNlc3Npb24uRmV0Y2hlc1R5cGUsXG4gICAgICBvcHRpb25zPzogSW5mZXJlbmNlU2Vzc2lvbi5SdW5PcHRpb25zKTogUHJvbWlzZTxJbmZlcmVuY2VTZXNzaW9uLlJldHVyblR5cGU+O1xuXG4gIC8vICNlbmRyZWdpb25cblxuICAvLyAjcmVnaW9uIGNvcHkgcGFyYW1ldGVyc1xuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgdGhlIHNpemUgb2YgYWxsIHBhcmFtZXRlcnMgZm9yIHRoZSB0cmFpbmluZyBzdGF0ZS4gQ2FsY3VsYXRlcyB0aGUgdG90YWwgbnVtYmVyIG9mIHByaW1pdGl2ZSAoZGF0YXR5cGUgb2ZcbiAgICogdGhlIHBhcmFtZXRlcnMpIGVsZW1lbnRzIG9mIGFsbCB0aGUgcGFyYW1ldGVycyBpbiB0aGUgdHJhaW5pbmcgc3RhdGUuXG4gICAqXG4gICAqIEBwYXJhbSB0cmFpbmFibGVPbmx5IC0gV2hlbiBzZXQgdG8gdHJ1ZSwgdGhlIHNpemUgaXMgY2FsY3VsYXRlZCBmb3IgdHJhaW5hYmxlIHBhcmFtcyBvbmx5LiBEZWZhdWx0IHZhbHVlIGlzIHRydWUuXG4gICAqL1xuICBnZXRQYXJhbWV0ZXJzU2l6ZSh0cmFpbmFibGVPbmx5OiBib29sZWFuKTogUHJvbWlzZTxudW1iZXI+O1xuXG4gIC8qKlxuICAgKiBDb3BpZXMgcGFyYW1ldGVyIHZhbHVlcyBmcm9tIHRoZSBnaXZlbiBhcnJheSB0byB0aGUgdHJhaW5pbmcgc3RhdGUuIEN1cnJlbnRseSwgb25seSBzdXBwb3J0aW5nIG1vZGVscyB3aXRoXG4gICAqIHBhcmFtZXRlcnMgb2YgdHlwZSBGbG9hdDMyLlxuICAgKlxuICAgKiBAcGFyYW0gYnVmZmVyIC0gRmxvYXQzMiBidWZmZXIgY29udGFpbmluZyBwYXJhbWV0ZXJzIGNvbnZlcnRlZCB0byBhIFVpbnQ4QXJyYXkuXG4gICAqIEBwYXJhbSB0cmFpbmFibGVPbmx5IC0gVHJ1ZSBpZiB0cmFpbmFibGUgcGFyYW1ldGVycyBvbmx5IHRvIGJlIG1vZGlmaWVkLCBmYWxzZSBvdGhlcndpc2UuIERlZmF1bHQgdmFsdWUgaXMgdHJ1ZS5cbiAgICovXG4gIGxvYWRQYXJhbWV0ZXJzQnVmZmVyKGFycmF5OiBVaW50OEFycmF5LCB0cmFpbmFibGVPbmx5OiBib29sZWFuKTogUHJvbWlzZTx2b2lkPjtcblxuICAvKipcbiAgICogQ29waWVzIHRoZSBtb2RlbCBwYXJhbWV0ZXJzIHRvIGEgY29udGlndW91cyBidWZmZXIuIFVzdWFsbHkgdXNlZCBpbiB0aGUgY29udGV4dCBvZiBGZWRlcmF0ZWQgTGVhcm5pbmcuXG4gICAqIEN1cnJlbnRseSwgb25seSBzdXBwb3J0aW5nIG1vZGVscyB3aXRoIHBhcmFtZXRlcnMgb2YgdHlwZSBGbG9hdDMyLlxuICAgKlxuICAgKiBAcGFyYW0gdHJhaW5hYmxlT25seSAtIFdoZW4gc2V0IHRvIHRydWUsIG9ubHkgdHJhaW5hYmxlIHBhcmFtZXRlcnMgYXJlIGNvcGllZC4gVHJhaW5hYmxlIHBhcmFtZXRlcnMgYXJlIHBhcmFtZXRlcnNcbiAgICogZm9yIHdoaWNoIHJlcXVpcmVzX2dyYWQgaXMgc2V0IHRvIHRydWUuIERlZmF1bHQgdmFsdWUgaXMgdHJ1ZS5cbiAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBGbG9hdDMyIE9ubnhWYWx1ZSBvZiB0aGUgcmVxdWVzdGVkIHBhcmFtZXRlcnMuXG4gICAqL1xuICBnZXRDb250aWd1b3VzUGFyYW1ldGVycyh0cmFpbmFibGVPbmx5OiBib29sZWFuKTogUHJvbWlzZTxPbm54VmFsdWU+O1xuICAvLyAjZW5kcmVnaW9uXG5cbiAgLy8gI3JlZ2lvbiByZWxlYXNlKClcblxuICAvKipcbiAgICogUmVsZWFzZSB0aGUgaW5mZXJlbmNlIHNlc3Npb24gYW5kIHRoZSB1bmRlcmx5aW5nIHJlc291cmNlcy5cbiAgICovXG4gIHJlbGVhc2UoKTogUHJvbWlzZTx2b2lkPjtcbiAgLy8gI2VuZHJlZ2lvblxuXG4gIC8vICNyZWdpb24gbWV0YWRhdGFcblxuICAvKipcbiAgICogR2V0IGlucHV0IG5hbWVzIG9mIHRoZSBsb2FkZWQgdHJhaW5pbmcgbW9kZWwuXG4gICAqL1xuICByZWFkb25seSB0cmFpbmluZ0lucHV0TmFtZXM6IHJlYWRvbmx5IHN0cmluZ1tdO1xuXG4gIC8qKlxuICAgKiBHZXQgb3V0cHV0IG5hbWVzIG9mIHRoZSBsb2FkZWQgdHJhaW5pbmcgbW9kZWwuXG4gICAqL1xuICByZWFkb25seSB0cmFpbmluZ091dHB1dE5hbWVzOiByZWFkb25seSBzdHJpbmdbXTtcblxuICAvKipcbiAgICogR2V0IGlucHV0IG5hbWVzIG9mIHRoZSBsb2FkZWQgZXZhbCBtb2RlbC4gSXMgYW4gZW1wdHkgYXJyYXkgaWYgbm8gZXZhbCBtb2RlbCBpcyBsb2FkZWQuXG4gICAqL1xuICByZWFkb25seSBldmFsSW5wdXROYW1lczogcmVhZG9ubHkgc3RyaW5nW107XG5cbiAgLyoqXG4gICAqIEdldCBvdXRwdXQgbmFtZXMgb2YgdGhlIGxvYWRlZCBldmFsIG1vZGVsLiBJcyBhbiBlbXB0eSBhcnJheSBpZiBubyBldmFsIG1vZGVsIGlzIGxvYWRlZC5cbiAgICovXG4gIHJlYWRvbmx5IGV2YWxPdXRwdXROYW1lczogcmVhZG9ubHkgc3RyaW5nW107XG5cbiAgLy8gI2VuZHJlZ2lvblxufVxuXG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIG9wdGlvbmFsIHBhcmFtZXRlcnMgdGhhdCBjYW4gYmUgcGFzc2VkIGludG8gdGhlIFRyYWluaW5nU2Vzc2lvbkZhY3RvcnkuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgVHJhaW5pbmdTZXNzaW9uQ3JlYXRlT3B0aW9ucyB7XG4gIC8qKlxuICAgKiBVUkkgb3IgYnVmZmVyIGZvciBhIC5ja3B0IGZpbGUgdGhhdCBjb250YWlucyB0aGUgY2hlY2twb2ludCBmb3IgdGhlIHRyYWluaW5nIG1vZGVsLlxuICAgKi9cbiAgY2hlY2twb2ludFN0YXRlOiBUcmFpbmluZ1Nlc3Npb24uVVJJb3JCdWZmZXI7XG4gIC8qKlxuICAgKiBVUkkgb3IgYnVmZmVyIGZvciB0aGUgLm9ubnggdHJhaW5pbmcgZmlsZS5cbiAgICovXG4gIHRyYWluTW9kZWw6IFRyYWluaW5nU2Vzc2lvbi5VUklvckJ1ZmZlcjtcbiAgLyoqXG4gICAqIE9wdGlvbmFsLiBVUkkgb3IgYnVmZmVyIGZvciB0aGUgLm9ubnggb3B0aW1pemVyIG1vZGVsIGZpbGUuXG4gICAqL1xuICBvcHRpbWl6ZXJNb2RlbD86IFRyYWluaW5nU2Vzc2lvbi5VUklvckJ1ZmZlcjtcbiAgLyoqXG4gICAqIE9wdGlvbmFsLiBVUkkgb3IgYnVmZmVyIGZvciB0aGUgLm9ubnggZXZhbCBtb2RlbCBmaWxlLlxuICAgKi9cbiAgZXZhbE1vZGVsPzogVHJhaW5pbmdTZXNzaW9uLlVSSW9yQnVmZmVyO1xufVxuXG4vKipcbiAqIERlZmluZXMgbWV0aG9kIG92ZXJsb2FkIHBvc3NpYmlsaXRpZXMgZm9yIGNyZWF0aW5nIGEgVHJhaW5pbmdTZXNzaW9uLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFRyYWluaW5nU2Vzc2lvbkZhY3Rvcnkge1xuICAvLyAjcmVnaW9uIGNyZWF0ZSgpXG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgVHJhaW5pbmdTZXNzaW9uIGFuZCBhc3luY2hyb25vdXNseSBsb2FkcyBhbnkgbW9kZWxzIHBhc3NlZCBpbiB0aHJvdWdoIHRyYWluaW5nT3B0aW9uc1xuICAgKlxuICAgKiBAcGFyYW0gdHJhaW5pbmdPcHRpb25zIHNwZWNpZnkgbW9kZWxzIGFuZCBjaGVja3BvaW50cyB0byBsb2FkIGludG8gdGhlIFRyYWluaW5nIFNlc3Npb25cbiAgICogQHBhcmFtIHNlc3Npb25PcHRpb25zIHNwZWNpZnkgY29uZmlndXJhdGlvbiBmb3IgdHJhaW5pbmcgc2Vzc2lvbiBiZWhhdmlvclxuICAgKlxuICAgKiBAcmV0dXJucyBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBUcmFpbmluZ1Nlc3Npb24gb2JqZWN0XG4gICAqL1xuICBjcmVhdGUodHJhaW5pbmdPcHRpb25zOiBUcmFpbmluZ1Nlc3Npb25DcmVhdGVPcHRpb25zLCBzZXNzaW9uT3B0aW9ucz86IEluZmVyZW5jZVNlc3Npb24uU2Vzc2lvbk9wdGlvbnMpOlxuICAgICAgUHJvbWlzZTxUcmFpbmluZ1Nlc3Npb24+O1xuXG4gIC8vICNlbmRyZWdpb25cbn1cblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvblxuZXhwb3J0IGNvbnN0IFRyYWluaW5nU2Vzc2lvbjogVHJhaW5pbmdTZXNzaW9uRmFjdG9yeSA9IFRyYWluaW5nU2Vzc2lvbkltcGw7XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbi8qKlxuICogIyBPTk5YIFJ1bnRpbWUgSmF2YVNjcmlwdCBBUElcbiAqXG4gKiBPTk5YIFJ1bnRpbWUgSmF2YVNjcmlwdCBBUEkgaXMgYSB1bmlmaWVkIEFQSSBmb3IgYWxsIEphdmFTY3JpcHQgdXNhZ2VzLCBpbmNsdWRpbmcgdGhlIGZvbGxvd2luZyBOUE0gcGFja2FnZXM6XG4gKlxuICogLSBbb25ueHJ1bnRpbWUtbm9kZV0oaHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2Uvb25ueHJ1bnRpbWUtbm9kZSlcbiAqIC0gW29ubnhydW50aW1lLXdlYl0oaHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2Uvb25ueHJ1bnRpbWUtd2ViKVxuICogLSBbb25ueHJ1bnRpbWUtcmVhY3QtbmF0aXZlXShodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS9vbm54cnVudGltZS1yZWFjdC1uYXRpdmUpXG4gKlxuICogU2VlIGFsc286XG4gKiAtIFtHZXQgU3RhcnRlZF0oaHR0cHM6Ly9vbm54cnVudGltZS5haS9kb2NzL2dldC1zdGFydGVkL3dpdGgtamF2YXNjcmlwdC5odG1sKVxuICogLSBbSW5mZXJlbmNlIGV4YW1wbGVzXShodHRwczovL2dpdGh1Yi5jb20vbWljcm9zb2Z0L29ubnhydW50aW1lLWluZmVyZW5jZS1leGFtcGxlcy90cmVlL21haW4vanMpXG4gKlxuICogQHBhY2thZ2VEb2N1bWVudGF0aW9uXG4gKi9cblxuZXhwb3J0ICogZnJvbSAnLi9iYWNrZW5kLmpzJztcbmV4cG9ydCAqIGZyb20gJy4vZW52LmpzJztcbmV4cG9ydCAqIGZyb20gJy4vaW5mZXJlbmNlLXNlc3Npb24uanMnO1xuZXhwb3J0ICogZnJvbSAnLi90ZW5zb3IuanMnO1xuZXhwb3J0ICogZnJvbSAnLi90cmFjZS5qcyc7XG5leHBvcnQgKiBmcm9tICcuL29ubngtdmFsdWUuanMnO1xuZXhwb3J0ICogZnJvbSAnLi90cmFpbmluZy1zZXNzaW9uLmpzJztcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtFbnZ9IGZyb20gJ29ubnhydW50aW1lLWNvbW1vbic7XG5cbmltcG9ydCB7bG9nTGV2ZWxTdHJpbmdUb0VudW19IGZyb20gJy4uL3dhc20tY29tbW9uJztcblxudHlwZSBMb2dMZXZlbCA9IE5vbk51bGxhYmxlPEVudlsnbG9nTGV2ZWwnXT47XG50eXBlIE1lc3NhZ2VTdHJpbmcgPSBzdHJpbmc7XG50eXBlIE1lc3NhZ2VGdW5jdGlvbiA9ICgpID0+IHN0cmluZztcbnR5cGUgTWVzc2FnZSA9IE1lc3NhZ2VTdHJpbmd8TWVzc2FnZUZ1bmN0aW9uO1xuXG5jb25zdCBsb2dMZXZlbFByZWZpeCA9IFsnVicsICdJJywgJ1cnLCAnRScsICdGJ107XG5cbmNvbnN0IGRvTG9nID0gKGxldmVsOiBudW1iZXIsIG1lc3NhZ2U6IHN0cmluZyk6IHZvaWQgPT4ge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICBjb25zb2xlLmxvZyhgWyR7bG9nTGV2ZWxQcmVmaXhbbGV2ZWxdfSwke25ldyBEYXRlKCkudG9JU09TdHJpbmcoKX1dJHttZXNzYWdlfWApO1xufTtcblxubGV0IGNvbmZpZ0xvZ0xldmVsOiBMb2dMZXZlbHx1bmRlZmluZWQ7XG5sZXQgZGVidWc6IGJvb2xlYW58dW5kZWZpbmVkO1xuXG5leHBvcnQgY29uc3QgY29uZmlndXJlTG9nZ2VyID0gKCRjb25maWdMb2dMZXZlbDogTG9nTGV2ZWwsICRkZWJ1ZzogYm9vbGVhbik6IHZvaWQgPT4ge1xuICBjb25maWdMb2dMZXZlbCA9ICRjb25maWdMb2dMZXZlbDtcbiAgZGVidWcgPSAkZGVidWc7XG59O1xuXG4vKipcbiAqIEEgc2ltcGxlIGxvZ2dpbmcgdXRpbGl0eSB0byBsb2cgbWVzc2FnZXMgdG8gdGhlIGNvbnNvbGUuXG4gKi9cbmV4cG9ydCBjb25zdCBMT0cgPSAobG9nTGV2ZWw6IExvZ0xldmVsLCBtc2c6IE1lc3NhZ2UpOiB2b2lkID0+IHtcbiAgY29uc3QgbWVzc2FnZUxldmVsID0gbG9nTGV2ZWxTdHJpbmdUb0VudW0obG9nTGV2ZWwpO1xuICBjb25zdCBjb25maWdMZXZlbCA9IGxvZ0xldmVsU3RyaW5nVG9FbnVtKGNvbmZpZ0xvZ0xldmVsKTtcbiAgaWYgKG1lc3NhZ2VMZXZlbCA+PSBjb25maWdMZXZlbCkge1xuICAgIGRvTG9nKG1lc3NhZ2VMZXZlbCwgdHlwZW9mIG1zZyA9PT0gJ2Z1bmN0aW9uJyA/IG1zZygpIDogbXNnKTtcbiAgfVxufTtcblxuLyoqXG4gKiBBIHNpbXBsZSBsb2dnaW5nIHV0aWxpdHkgdG8gbG9nIG1lc3NhZ2VzIHRvIHRoZSBjb25zb2xlLiBPbmx5IGxvZ3Mgd2hlbiBkZWJ1ZyBpcyBlbmFibGVkLlxuICovXG5leHBvcnQgY29uc3QgTE9HX0RFQlVHOiB0eXBlb2YgTE9HID0gKC4uLmFyZ3M6IFBhcmFtZXRlcnM8dHlwZW9mIExPRz4pID0+IHtcbiAgaWYgKGRlYnVnKSB7XG4gICAgTE9HKC4uLmFyZ3MpO1xuICB9XG59O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge1RlbnNvcn0gZnJvbSAnb25ueHJ1bnRpbWUtY29tbW9uJztcblxuaW1wb3J0IHt0ZW5zb3JUeXBlVG9UeXBlZEFycmF5Q29uc3RydWN0b3J9IGZyb20gJy4uL3dhc20tY29tbW9uJztcblxuZXhwb3J0IGNvbnN0IGNyZWF0ZVZpZXcgPSAoZGF0YUJ1ZmZlcjogQXJyYXlCdWZmZXIsIHR5cGU6IFRlbnNvci5UeXBlKTogSW50MzJBcnJheXxVaW50MzJBcnJheXxCaWdJbnQ2NEFycmF5fFxuICAgIEJpZ1VpbnQ2NEFycmF5fFVpbnQ4QXJyYXl8RmxvYXQzMkFycmF5fEZsb2F0NjRBcnJheXxJbnQ4QXJyYXl8SW50MTZBcnJheXxVaW50MTZBcnJheSA9PlxuICAgICAgICBuZXcgKHRlbnNvclR5cGVUb1R5cGVkQXJyYXlDb25zdHJ1Y3Rvcih0eXBlKSkoZGF0YUJ1ZmZlcik7XG5cbi8qKlxuICogYSBUZW5zb3JWaWV3IGRvZXMgbm90IG93biB0aGUgZGF0YS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBUZW5zb3JWaWV3IHtcbiAgcmVhZG9ubHkgZGF0YTogbnVtYmVyO1xuICByZWFkb25seSBkYXRhVHlwZTogbnVtYmVyO1xuICByZWFkb25seSBkaW1zOiByZWFkb25seSBudW1iZXJbXTtcblxuICAvKipcbiAgICogZ2V0IGEgRmxvYXQzMkFycmF5IGRhdGEgdmlldyBvZiB0aGUgdGVuc29yIGRhdGEuIHRlbnNvciBkYXRhIG11c3QgYmUgb24gQ1BVLlxuICAgKi9cbiAgZ2V0RmxvYXQzMkFycmF5KCk6IEZsb2F0MzJBcnJheTtcblxuICAvKipcbiAgICogZ2V0IGEgQmlnSW50NjRBcnJheSBkYXRhIHZpZXcgb2YgdGhlIHRlbnNvciBkYXRhLiB0ZW5zb3IgZGF0YSBtdXN0IGJlIG9uIENQVS5cbiAgICovXG4gIGdldEJpZ0ludDY0QXJyYXkoKTogQmlnSW50NjRBcnJheTtcblxuICAvKipcbiAgICogZ2V0IGEgSW50MzJBcnJheSBkYXRhIHZpZXcgb2YgdGhlIHRlbnNvciBkYXRhLiB0ZW5zb3IgZGF0YSBtdXN0IGJlIG9uIENQVS5cbiAgICovXG4gIGdldEludDMyQXJyYXkoKTogSW50MzJBcnJheTtcblxuICAvKipcbiAgICogY3JlYXRlIGEgbmV3IHRlbnNvciB2aWV3IHdpdGggdGhlIHNhbWUgZGF0YSBidXQgZGlmZmVyZW50IGRpbWVuc2lvbnMuXG4gICAqL1xuICByZXNoYXBlKG5ld0RpbXM6IHJlYWRvbmx5IG51bWJlcltdKTogVGVuc29yVmlldztcbn1cbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtUZW5zb3JWaWV3fSBmcm9tICcuLi90ZW5zb3Itdmlldyc7XG5cbmltcG9ydCB7U2hhZGVySGVscGVyfSBmcm9tICcuL29wcy9jb21tb24nO1xuXG5leHBvcnQgZW51bSBHcHVEYXRhVHlwZSB7XG4gIGRlZmF1bHQgPSAwLFxuICB1cGxvYWQgPSAxLFxuICBwcm9maWxlID0gMlxufVxuZXhwb3J0IHR5cGUgR3B1RGF0YUlkID0gbnVtYmVyO1xuXG5leHBvcnQgaW50ZXJmYWNlIEdwdURhdGEge1xuICB0eXBlOiBHcHVEYXRhVHlwZTtcbiAgaWQ6IEdwdURhdGFJZDtcbiAgYnVmZmVyOiBHUFVCdWZmZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVGVuc29ySW5mbyB7XG4gIGRpbXM6IHJlYWRvbmx5IG51bWJlcltdO1xuICBkYXRhVHlwZTogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFByb2dyYW1Vbmlmb3JtIHtcbiAgdHlwZTogJ2ludDMyJ3wnZmxvYXQzMid8J3VpbnQzMic7XG4gIGRhdGE6IG51bWJlcnxyZWFkb25seSBudW1iZXJbXTtcbn1cblxuLyoqXG4gKiBSZXByZXNlbnQgdGhlIGRlcGVuZGVuY3kgb2YgYSBwcm9ncmFtIG9uIGEgc3BlY2lmaWMgaW5wdXQgdGVuc29yLlxuICpcbiAqIC0gJ25vbmUnOiB0aGUgc2hhZGVyL3VuaWZvcm0gZG9lcyBub3QgZGVwZW5kIG9uIHRoaXMgaW5wdXQncyBpbmZvXG4gKiAtICd0eXBlJzogdGhlIHNoYWRlci91bmlmb3JtIGRlcGVuZHMgb24gZGF0YSB0eXBlIG9mIHRoaXMgaW5wdXRcbiAqIC0gJ3JhbmsnOiB0aGUgc2hhZGVyL3VuaWZvcm0gZGVwZW5kcyBvbiBkYXRhIHR5cGUgYW5kIHRoZSByYW5rIG9mIHRoaXMgaW5wdXRcbiAqIC0gJ2RpbXMnOiB0aGUgc2hhZGVyL3VuaWZvcm0gZGVwZW5kcyBvbiBkYXRhIHR5cGUgYW5kIHRoZSBkaW1zIG9mIHRoaXMgaW5wdXRcbiAqIC0gJ2RhdGEnOiB0aGUgc2hhZGVyL3VuaWZvcm0gZGVwZW5kcyBvbiBkYXRhIHR5cGUsIHRoZSBkaW1zIGFuZCB0aGUgZGF0YSBvZiB0aGlzIGlucHV0XG4gKi9cbmV4cG9ydCB0eXBlIFByb2dyYW1JbnB1dFRlbnNvckluZm9EZXBlbmRlbmN5ID0gJ25vbmUnfCd0eXBlJ3wncmFuayd8J2RpbXMnfCdkYXRhJztcblxuLyoqXG4gKiBSZXByZXNlbnQgaW5mb3JtYXRpb24gYWJvdXQgYSBwcm9ncmFtJ3MgY2FjaGUgZm9yIHNoYWRlci5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBQcm9ncmFtU2hhZGVyQ2FjaGVJbmZvIHtcbiAgLyoqXG4gICAqIGFuIG9wdGlvbmFsIHN0cmluZyBhcyBhIGNhY2hlIGhpbnQgaW4gdGhlIGFydGlmYWN0IGNhY2hlLiBJZiB0aGlzIGlzIG5vdCBzcGVjaWZpZWQsIHRoZSBjYWNoZSBoaW50IHdpbGwgYmUgZW1wdHkuXG4gICAqXG4gICAqIFRoaXMgaGludCBzdHJpbmcgc2hvdWxkIG9ubHkgY29udGFpbnMgaW5pdGlhbGl6aW5nLXRpbWUgaW5mb3JtYXRpb24sIHN1Y2ggYXMgdGhlIGF0dHJpYnV0ZXMgb3IgYW55IGluZm9ybWF0aW9uIG9mXG4gICAqIGluaXRpYWxpemVycy4gSXQgc2hvdWxkIE5PVCBjb250YWluIGFueSBydW50aW1lIGluZm9ybWF0aW9uLCBzdWNoIGFzIHRoZSBzaGFwZSBvZiBpbnB1dHMuXG4gICAqL1xuICBoaW50Pzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBhbiBvcHRpb25hbCBsaXN0IG9mIGRlcGVuZGVuY2llcyBvZiB0aGUgcHJvZ3JhbSBvbiB0aGUgaW5wdXQgdGVuc29ycy4gSWYgdGhpcyBpcyBub3Qgc3BlY2lmaWVkLCB0aGUgcHJvZ3JhbSBkZXBlbmRzXG4gICAqIG9uICdkaW1zJyBvZiBhbGwgaW5wdXRzLlxuICAgKi9cbiAgaW5wdXREZXBlbmRlbmNpZXM/OiBQcm9ncmFtSW5wdXRUZW5zb3JJbmZvRGVwZW5kZW5jeVtdO1xufVxuXG4vKipcbiAqIFJlcHJlc2VudCBpbmZvcm1hdGlvbiBhYm91dCBhIHByb2dyYW0ncyBjYWNoZSBmb3IgdW5pZm9ybS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBQcm9ncmFtVW5pZm9ybUNhY2hlSW5mbyB7XG4gIC8qKlxuICAgKiBhbiBvcHRpb25hbCBzdHJpbmcgYXMgYSBjYWNoZSBoaW50IGluIHRoZSB1bmlmb3JtIGNhY2hlLiBJZiB0aGlzIGlzIG5vdCBzcGVjaWZpZWQsIHRoZSBjYWNoZSBoaW50IHdpbGwgYmUgZW1wdHkuXG4gICAqXG4gICAqIFRoaXMgaGludCBzdHJpbmcgc2hvdWxkIG9ubHkgY29udGFpbnMgcnVudGltZSBpbmZvcm1hdGlvbiwgc3VjaCBhcyB0aGUgc2hhcGUgb2YgaW5wdXRzLlxuICAgKi9cbiAgaGludD86IHN0cmluZztcblxuICAvKipcbiAgICogYW4gb3B0aW9uYWwgbGlzdCBvZiBkZXBlbmRlbmNpZXMgb2YgdGhlIHByb2dyYW0gb24gdGhlIGlucHV0IHRlbnNvcnMuIElmIHRoaXMgaXMgbm90IHNwZWNpZmllZCwgdGhlIHByb2dyYW0gZGVwZW5kc1xuICAgKiBvbiAnbm9uZScgb2YgYWxsIGlucHV0cy5cbiAgICovXG4gIGlucHV0RGVwZW5kZW5jaWVzPzogUHJvZ3JhbUlucHV0VGVuc29ySW5mb0RlcGVuZGVuY3lbXTtcbn1cblxuXG4vKipcbiAqIEEgc2V0IG9mIGRhdGEgdGhhdCByZXByZXNlbnQgYSBzaGFkZXIgcHJvZ3JhbVxuICovXG5leHBvcnQgaW50ZXJmYWNlIFByb2dyYW1JbmZvIHtcbiAgLyoqXG4gICAqIHRoZSBuYW1lIG9mIHRoZSBwcm9ncmFtLiB1c2VkIGZvciBkZWJ1Z2dpbmcgYW5kIHByb2ZpbGluZ1xuICAgKi9cbiAgbmFtZTogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBhbiBvcHRpb25hbCBvYmplY3QgZGVzY3JpYmluZyB0aGUgY2FjaGUgaW5mb3JtYXRpb24gb2YgdGhlIHByb2dyYW0gc2hhZGVyLlxuICAgKlxuICAgKiBJZiB0aGlzIGlzIG5vdCBzcGVjaWZpZWQsIGFzc3VtZSBoaW50IGlzIGVtcHR5IGFuZCBpbnB1dERlcGVuZGVuY2llcyBhcmUgWydkaW1zJ10gZm9yIGFsbCBpbnB1dHMuXG4gICAqL1xuICBzaGFkZXJDYWNoZT86IFByb2dyYW1TaGFkZXJDYWNoZUluZm87XG5cbiAgLyoqXG4gICAqIHRoZSBzaGFkZXIncyBwcm9jZXNzaW5nIHNvdXJjZSBjb2RlLlxuICAgKlxuICAgKiBUaGlzIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIHdoZW4gc2hhZGVyIGNhY2hlIG1pc3NlZC5cbiAgICovXG4gIGdldFNoYWRlclNvdXJjZTogKHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyKSA9PiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIEEgZnVuY3Rpb24gdG8gZ2V0IHJ1biBkYXRhIHJlcXVpcmVkIHRvIHJ1biB0aGUgcHJvZ3JhbS5cbiAgICpcbiAgICogVGhpcyBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCBldmVyeSB0aW1lIHRoZSBwcm9ncmFtIGlzIGV4ZWN1dGVkLiBTaG91bGQga2VlcCB0aGlzIGZ1bmN0aW9uIGFzIHNpbXBsZSBhcyBwb3NzaWJsZS5cbiAgICovXG4gIGdldFJ1bkRhdGE6IChpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSkgPT4ge1xuICAgIG91dHB1dHM6IHJlYWRvbmx5IFRlbnNvckluZm9bXTtcbiAgICBkaXNwYXRjaEdyb3VwOiB7eDogbnVtYmVyOyB5PzogbnVtYmVyOyB6PzogbnVtYmVyfTtcbiAgICBwcm9ncmFtVW5pZm9ybXM/OiByZWFkb25seSBQcm9ncmFtVW5pZm9ybVtdO1xuICB9O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEFydGlmYWN0IHtcbiAgcHJvZ3JhbUluZm86IFByb2dyYW1JbmZvO1xuICBjb21wdXRlUGlwZWxpbmU6IEdQVUNvbXB1dGVQaXBlbGluZTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBDb21wdXRlQ29udGV4dElucHV0c091dHB1dHNNYXBwaW5nIHtcbiAgLyoqXG4gICAqIHNwZWNpZnkgdGhlIG1hcHBpbmcgdG8gdGhlIHByb2dyYW0ncyBpbnB1dHMuIHRoZSB2YWx1ZSBjYW4gYmUgYSBudW1iZXIgb3IgYSB0ZW5zb3Igdmlldy5cbiAgICogLSBpZiBpdCdzIGEgbnVtYmVyLCBpdCdzIHRoZSBpbmRleCBvZiB0aGUga2VybmVsJ3MgaW5wdXRcbiAgICogLSBpZiBpdCdzIGEgdGVuc29yIHZpZXcsIGl0J3MgYW4gZXhpc3RpbmcgdGVuc29yIHZpZXcgdGhhdCB3aWxsIGJlIHVzZWQgYXMgdGhlIGlucHV0XG4gICAqXG4gICAqIGlmIGlucHV0cyBpcyBub3Qgc3BlY2lmaWVkLCB0aGUgbWFwcGluZyB3aWxsIGJlIHRoZSBrZXJuZWwncyBpbnB1dHMgaW4gb3JkZXIuXG4gICAqL1xuICByZWFkb25seSBpbnB1dHM/OiBSZWFkb25seUFycmF5PFRlbnNvclZpZXd8bnVtYmVyPjtcbiAgLyoqXG4gICAqIHNwZWNpZnkgdGhlIG1hcHBpbmcgdG8gdGhlIHByb2dyYW0ncyBvdXRwdXRzLiB0aGUgdmFsdWUgbXVzdCBiZSBhIG51bWJlci5cbiAgICogLSBpZiBpdCdzIGEgbm9uLW5lZ2F0aXZlIG51bWJlciwgaXQncyB0aGUgaW5kZXggb2YgdGhlIGtlcm5lbCdzIG91dHB1dFxuICAgKiAtIGlmIGl0J3MgLTEsIGl0J3MgYW4gb3V0cHV0IHRoYXQgd2lsbCBiZSBjcmVhdGVkIGFzIGEgdGVtcG9yYXJ5IHZhbHVlLiB0aGlzIHZhbHVlIHdpbGwgYmUgcmVsZWFzZWQgYWZ0ZXJcbiAgICogdGhlIGtlcm5lbCBpcyBleGVjdXRlZC5cbiAgICogLSBpZiBpdCdzIC0yLCBpdCdzIGFuIG91dHB1dCB0aGF0IHdpbGwgYmUgY3JlYXRlZCBhcyBhIHBlcnNpc3RlbnQgdmFsdWUuIHRoaXMgdmFsdWUgd2lsbCBiZSByZWxlYXNlZCB3aGVuIHRoZVxuICAgKiBrZXJuZWwgaXMgcmVsZWFzZWQuXG4gICAqXG4gICAqIGlmIG91dHB1dHMgaXMgbm90IHNwZWNpZmllZCwgdGhlIG1hcHBpbmcgd2lsbCBiZSB0aGUga2VybmVsJ3Mgb3V0cHV0cyBpbiBvcmRlci5cbiAgICovXG4gIHJlYWRvbmx5IG91dHB1dHM/OiByZWFkb25seSBudW1iZXJbXTtcbn1cblxuLyoqXG4gKiBBIENvbXB1dGVDb250ZXh0IGluc3RhbmNlIGNhcnJpZXMgdGhlIHN0YXRlcyB0aGF0IHJlcHJlc2VudGluZyB0aGUgY3VycmVudCBydW5uaW5nIG9mIGEga2VybmVsLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIENvbXB1dGVDb250ZXh0IHtcbiAgLyoqXG4gICAqIHN0b3JlcyB0aGUgcG9pbnRlciB0byBPcEtlcm5lbENvbnRleHRcbiAgICovXG4gIHJlYWRvbmx5IG9wS2VybmVsQ29udGV4dDogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBhIGxpc3Qgb2YgaW5wdXRzLCBlYWNoIGlucHV0IGlzIGFuIGluc3RhbmNlIG9mIFRlbnNvclZpZXdcbiAgICovXG4gIHJlYWRvbmx5IGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdO1xuXG4gIC8qKlxuICAgKiBhIGN1c3RvbSBkYXRhIG9iamVjdCB0aGF0IGNhbiBiZSB1c2VkIHRvIHN0b3JlIGFueSBkYXRhIHRoYXQgaXMgbmVlZGVkIGJ5IHRoZSBrZXJuZWxcbiAgICovXG4gIHJlYWRvbmx5IGtlcm5lbEN1c3RvbURhdGE6IHtba2V5OiBzdHJpbmddOiB1bmtub3dufTtcblxuICAvKipcbiAgICogYSBidWZmZXIgdGhhdCBjYW4gYmUgdXNlZCB0byBhY2Nlc3MgY3VzdG9tIGRhdGEgY3JlYXRlZCBlYWNoIHRpbWUgdGhlIGtlcm5lbCBpcyBleGVjdXRlZFxuICAgKi9cbiAgcmVhZG9ubHkgY3VzdG9tRGF0YUJ1ZmZlcjogVWludDhBcnJheTtcblxuICAvKipcbiAgICogYSBudW1iZXIgb2Ygb3V0cHV0cyBmb3IgdGhlIG5vZGVcbiAgICovXG4gIHJlYWRvbmx5IG91dHB1dENvdW50OiBudW1iZXI7XG5cbiAgY29tcHV0ZShwcm9ncmFtOiBQcm9ncmFtSW5mbywgaW5wdXRzT3V0cHV0c01hcHBpbmc/OiBDb21wdXRlQ29udGV4dElucHV0c091dHB1dHNNYXBwaW5nKTogVGVuc29yVmlld1tdO1xuICBvdXRwdXQoaW5kZXg6IG51bWJlciwgZGltczogcmVhZG9ubHkgbnVtYmVyW10pOiBudW1iZXI7XG59XG5cbmV4cG9ydCB0eXBlIFRpbWVzdGFtcFF1ZXJ5ID0gJ25vbmUnfCdpbnNpZGUtcGFzc2VzJ3wnYXQtcGFzc2VzJztcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtXZWJHcHVCYWNrZW5kfSBmcm9tICcuLi9iYWNrZW5kLXdlYmdwdSc7XG5pbXBvcnQge0xPR19ERUJVR30gZnJvbSAnLi4vbG9nJztcblxuaW1wb3J0IHtHcHVEYXRhLCBHcHVEYXRhSWQsIEdwdURhdGFUeXBlfSBmcm9tICcuL3R5cGVzJztcblxuLyoqXG4gKiBtYW5hZ2VzIEdwdURhdGFJZCAtPiBHcHVCdWZmZXJcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBHcHVEYXRhTWFuYWdlciB7XG4gIC8qKlxuICAgKiBjb3B5IGRhdGEgZnJvbSBDUFUgdG8gR1BVLlxuICAgKi9cbiAgdXBsb2FkKGlkOiBHcHVEYXRhSWQsIGRhdGE6IFVpbnQ4QXJyYXkpOiB2b2lkO1xuICAvKipcbiAgICogY29weSBkYXRhIGZyb20gR1BVIHRvIEdQVS5cbiAgICovXG4gIG1lbWNweShzb3VyY2VJZDogR3B1RGF0YUlkLCBkZXN0aW5hdGlvbklkOiBHcHVEYXRhSWQpOiB2b2lkO1xuICAvKipcbiAgICogY3JlYXRlIG5ldyBkYXRhIG9uIEdQVS5cbiAgICovXG4gIGNyZWF0ZShzaXplOiBudW1iZXIsIHVzYWdlPzogbnVtYmVyKTogR3B1RGF0YTtcbiAgLyoqXG4gICAqIGdldCBHUFUgZGF0YSBieSBJRC5cbiAgICovXG4gIGdldChpZDogR3B1RGF0YUlkKTogR3B1RGF0YXx1bmRlZmluZWQ7XG4gIC8qKlxuICAgKiByZWxlYXNlIHRoZSBkYXRhIG9uIEdQVSBieSBJRC5cbiAgICpcbiAgICogQHJldHVybiBzaXplIG9mIHRoZSBkYXRhIHJlbGVhc2VkXG4gICAqL1xuICByZWxlYXNlKGlkOiBHcHVEYXRhSWQpOiBudW1iZXI7XG4gIC8qKlxuICAgKiBjb3B5IGRhdGEgZnJvbSBHUFUgdG8gQ1BVLlxuICAgKi9cbiAgZG93bmxvYWQoaWQ6IEdwdURhdGFJZCwgZ2V0VGFyZ2V0QnVmZmVyOiAoKSA9PiBVaW50OEFycmF5KTogUHJvbWlzZTx2b2lkPjtcblxuICAvKipcbiAgICogcmVmcmVzaCB0aGUgYnVmZmVycyB0aGF0IG1hcmtlZCBmb3IgcmVsZWFzZS5cbiAgICpcbiAgICogd2hlbiByZWxlYXNlKCkgaXMgY2FsbGVkLCB0aGUgYnVmZmVyIGlzIG5vdCByZWxlYXNlZCBpbW1lZGlhdGVseS4gdGhpcyBpcyBiZWNhdXNlIHdlIG5lZWQgdG8gd2FpdCBmb3IgdGhlIGNvbW1hbmRzXG4gICAqIHRvIGJlIHN1Ym1pdHRlZCB0byB0aGUgR1BVLiB0aGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCBhZnRlciB0aGUgY29tbWFuZHMgYXJlIHN1Ym1pdHRlZCBzbyB0aGF0IHRoZSBidWZmZXJzIGNhbiBiZVxuICAgKiBhY3R1YWxseSByZWxlYXNlZC5cbiAgICovXG4gIHJlZnJlc2hQZW5kaW5nQnVmZmVycygpOiB2b2lkO1xuXG4gIC8qKlxuICAgKiByZWdpc3RlciBhbiBleHRlcm5hbCBidWZmZXIgZm9yIElPIEJpbmRpbmcuIElmIHRoZSBidWZmZXIgaXMgYWxyZWFkeSByZWdpc3RlcmVkLCByZXR1cm4gdGhlIGV4aXN0aW5nIEdQVSBkYXRhIElELlxuICAgKlxuICAgKiBHUFUgZGF0YSBtYW5hZ2VyIG9ubHkgbWFuYWdlcyBhIG1hcHBpbmcgYmV0d2VlbiB0aGUgYnVmZmVyIGFuZCB0aGUgR1BVIGRhdGEgSUQuIEl0IHdpbGwgbm90IG1hbmFnZSB0aGUgbGlmZWN5Y2xlIG9mXG4gICAqIHRoZSBleHRlcm5hbCBidWZmZXIuXG4gICAqL1xuICByZWdpc3RlckV4dGVybmFsQnVmZmVyKGJ1ZmZlcjogR1BVQnVmZmVyLCBvcmlnaW5hbFNpemU6IG51bWJlciwgcHJldmlvdXNCdWZmZXI/OiBHUFVCdWZmZXIpOiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIHVucmVnaXN0ZXIgYW4gZXh0ZXJuYWwgYnVmZmVyIGZvciBJTyBCaW5kaW5nLlxuICAgKi9cbiAgdW5yZWdpc3RlckV4dGVybmFsQnVmZmVyKGJ1ZmZlcjogR1BVQnVmZmVyKTogdm9pZDtcblxuICAvKipcbiAgICogZGVzdHJveSBhbGwgZ3B1IGJ1ZmZlcnMuIENhbGwgdGhpcyB3aGVuIHRoZSBzZXNzaW9uLnJlbGVhc2UgaXMgY2FsbGVkLlxuICAgKi9cbiAgZGlzcG9zZSgpOiB2b2lkO1xufVxuXG5pbnRlcmZhY2UgU3RvcmFnZUNhY2hlVmFsdWUge1xuICBncHVEYXRhOiBHcHVEYXRhO1xuICBvcmlnaW5hbFNpemU6IG51bWJlcjtcbn1cblxuLyoqXG4gKiBub3JtYWxpemUgdGhlIGJ1ZmZlciBzaXplIHNvIHRoYXQgaXQgZml0cyB0aGUgMTI4LWJpdHMgKDE2IGJ5dGVzKSBhbGlnbm1lbnQuXG4gKi9cbmNvbnN0IGNhbGNOb3JtYWxpemVkQnVmZmVyU2l6ZSA9IChzaXplOiBudW1iZXIpID0+IE1hdGguY2VpbChzaXplIC8gMTYpICogMTY7XG5cbmxldCBndWlkID0gMTtcbmNvbnN0IGNyZWF0ZU5ld0dwdURhdGFJZCA9ICgpID0+IGd1aWQrKztcblxuLyoqXG4gKiBleHBvcnRlZCBzdGFuZGFyZCBkb3dubG9hZCBmdW5jdGlvbi4gVGhpcyBmdW5jdGlvbiBpcyB1c2VkIGJ5IHRoZSBzZXNzaW9uIHRvIGRvd25sb2FkIHRoZSBkYXRhIGZyb20gR1BVLCBhbmQgYWxzbyBieVxuICogZmFjdG9yeSB0byBjcmVhdGUgR1BVIHRlbnNvcnMgd2l0aCB0aGUgY2FwYWNpdHkgb2YgZG93bmxvYWRpbmcgZGF0YSBmcm9tIEdQVS5cbiAqXG4gKiBAcGFyYW0gYmFja2VuZCAtIHRoZSBXZWJHUFUgYmFja2VuZFxuICogQHBhcmFtIGdwdUJ1ZmZlciAtIHRoZSBHUFUgYnVmZmVyIHRvIGRvd25sb2FkXG4gKiBAcGFyYW0gb3JpZ2luYWxTaXplIC0gdGhlIG9yaWdpbmFsIHNpemUgb2YgdGhlIGRhdGFcbiAqIEBwYXJhbSBnZXRUYXJnZXRCdWZmZXIgLSBvcHRpb25hbC4gSWYgcHJvdmlkZWQsIHRoZSBkYXRhIHdpbGwgYmUgY29waWVkIHRvIHRoZSB0YXJnZXQgYnVmZmVyLiBPdGhlcndpc2UsIGEgbmV3IGJ1ZmZlclxuICogd2lsbCBiZSBjcmVhdGVkIGFuZCByZXR1cm5lZC5cbiAqL1xuZXhwb3J0IGNvbnN0IGRvd25sb2FkR3B1RGF0YSA9XG4gICAgYXN5bmMoYmFja2VuZDogV2ViR3B1QmFja2VuZCwgZ3B1QnVmZmVyOiBHUFVCdWZmZXIsIG9yaWdpbmFsU2l6ZTogbnVtYmVyLCBnZXRUYXJnZXRCdWZmZXI/OiAoKSA9PiBVaW50OEFycmF5KTpcbiAgICAgICAgUHJvbWlzZTxVaW50OEFycmF5PiA9PiB7XG4gICAgICAgICAgY29uc3QgYnVmZmVyU2l6ZSA9IGNhbGNOb3JtYWxpemVkQnVmZmVyU2l6ZShvcmlnaW5hbFNpemUpO1xuICAgICAgICAgIGNvbnN0IGdwdVJlYWRCdWZmZXIgPSBiYWNrZW5kLmRldmljZS5jcmVhdGVCdWZmZXIoXG4gICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1iaXR3aXNlXG4gICAgICAgICAgICAgIHtzaXplOiBidWZmZXJTaXplLCB1c2FnZTogR1BVQnVmZmVyVXNhZ2UuQ09QWV9EU1QgfCBHUFVCdWZmZXJVc2FnZS5NQVBfUkVBRH0pO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBjb21tYW5kRW5jb2RlciA9IGJhY2tlbmQuZ2V0Q29tbWFuZEVuY29kZXIoKTtcbiAgICAgICAgICAgIGJhY2tlbmQuZW5kQ29tcHV0ZVBhc3MoKTtcbiAgICAgICAgICAgIGNvbW1hbmRFbmNvZGVyLmNvcHlCdWZmZXJUb0J1ZmZlcihcbiAgICAgICAgICAgICAgICBncHVCdWZmZXIgLyogc291cmNlIGJ1ZmZlciAqLywgMCAvKiBzb3VyY2Ugb2Zmc2V0ICovLCBncHVSZWFkQnVmZmVyIC8qIGRlc3RpbmF0aW9uIGJ1ZmZlciAqLyxcbiAgICAgICAgICAgICAgICAwIC8qIGRlc3RpbmF0aW9uIG9mZnNldCAqLywgYnVmZmVyU2l6ZSAvKiBzaXplICovXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgYmFja2VuZC5mbHVzaCgpO1xuXG4gICAgICAgICAgICBhd2FpdCBncHVSZWFkQnVmZmVyLm1hcEFzeW5jKEdQVU1hcE1vZGUuUkVBRCk7XG5cbiAgICAgICAgICAgIGNvbnN0IGFycmF5QnVmZmVyID0gZ3B1UmVhZEJ1ZmZlci5nZXRNYXBwZWRSYW5nZSgpO1xuICAgICAgICAgICAgaWYgKGdldFRhcmdldEJ1ZmZlcikge1xuICAgICAgICAgICAgICAvLyBpZiB3ZSBhbHJlYWR5IGhhdmUgYSBDUFUgYnVmZmVyIHRvIGFjY2VwdCB0aGUgZGF0YSwgbm8gbmVlZCB0byBjbG9uZSB0aGUgQXJyYXlCdWZmZXIuXG4gICAgICAgICAgICAgIGNvbnN0IHRhcmdldEJ1ZmZlciA9IGdldFRhcmdldEJ1ZmZlcigpO1xuICAgICAgICAgICAgICB0YXJnZXRCdWZmZXIuc2V0KG5ldyBVaW50OEFycmF5KGFycmF5QnVmZmVyLCAwLCBvcmlnaW5hbFNpemUpKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldEJ1ZmZlcjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIHRoZSBtYXBwZWQgQXJyYXlCdWZmZXIgd2lsbCBiZSByZWxlYXNlZCB3aGVuIHRoZSBHUFUgYnVmZmVyIGlzIGRlc3Ryb3llZC4gTmVlZCB0byBjbG9uZSB0aGVcbiAgICAgICAgICAgICAgLy8gQXJyYXlCdWZmZXIuXG4gICAgICAgICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShhcnJheUJ1ZmZlci5zbGljZSgwLCBvcmlnaW5hbFNpemUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgZ3B1UmVhZEJ1ZmZlci5kZXN0cm95KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG5jbGFzcyBHcHVEYXRhTWFuYWdlckltcGwgaW1wbGVtZW50cyBHcHVEYXRhTWFuYWdlciB7XG4gIC8vIEdQVSBEYXRhIElEID0+IEdQVSBEYXRhICggc3RvcmFnZSBidWZmZXIgKVxuICBwcml2YXRlIHN0b3JhZ2VDYWNoZTogTWFwPEdwdURhdGFJZCwgU3RvcmFnZUNhY2hlVmFsdWU+O1xuXG4gIC8vIHBlbmRpbmcgYnVmZmVycyBmb3IgdXBsb2FkaW5nICggZGF0YSBpcyB1bm1hcHBlZCApXG4gIHByaXZhdGUgYnVmZmVyc0ZvclVwbG9hZGluZ1BlbmRpbmc6IEdQVUJ1ZmZlcltdO1xuICAvLyBwZW5kaW5nIGJ1ZmZlcnMgZm9yIGNvbXB1dGluZ1xuICBwcml2YXRlIGJ1ZmZlcnNQZW5kaW5nOiBHUFVCdWZmZXJbXTtcblxuICAvLyBUaGUgcmV1c2FibGUgc3RvcmFnZSBidWZmZXJzIGZvciBjb21wdXRpbmcuXG4gIHByaXZhdGUgZnJlZUJ1ZmZlcnM6IE1hcDxudW1iZXIsIEdQVUJ1ZmZlcltdPjtcbiAgLy8gVGhlIHJldXNhYmxlIHVuaWZvcm0gYnVmZmVyc1xuICBwcml2YXRlIGZyZWVVbmlmb3JtQnVmZmVyczogTWFwPG51bWJlciwgR1BVQnVmZmVyW10+O1xuXG4gIC8vIFRoZSBleHRlcm5hbCBidWZmZXJzIHJlZ2lzdGVyZWQgdXNlcnMgZm9yIElPIEJpbmRpbmcuXG4gIHByaXZhdGUgZXh0ZXJuYWxCdWZmZXJzOiBNYXA8R1BVQnVmZmVyLCBHcHVEYXRhSWQ+O1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgYmFja2VuZDogV2ViR3B1QmFja2VuZCkge1xuICAgIHRoaXMuc3RvcmFnZUNhY2hlID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuZnJlZUJ1ZmZlcnMgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5mcmVlVW5pZm9ybUJ1ZmZlcnMgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5idWZmZXJzRm9yVXBsb2FkaW5nUGVuZGluZyA9IFtdO1xuICAgIHRoaXMuYnVmZmVyc1BlbmRpbmcgPSBbXTtcbiAgICB0aGlzLmV4dGVybmFsQnVmZmVycyA9IG5ldyBNYXAoKTtcbiAgfVxuXG4gIHVwbG9hZChpZDogR3B1RGF0YUlkLCBkYXRhOiBVaW50OEFycmF5KTogdm9pZCB7XG4gICAgY29uc3Qgc3JjQXJyYXlCdWZmZXIgPSBkYXRhLmJ1ZmZlcjtcbiAgICBjb25zdCBzcmNPZmZzZXQgPSBkYXRhLmJ5dGVPZmZzZXQ7XG4gICAgY29uc3Qgc3JjTGVuZ3RoID0gZGF0YS5ieXRlTGVuZ3RoO1xuICAgIGNvbnN0IHNpemUgPSBjYWxjTm9ybWFsaXplZEJ1ZmZlclNpemUoc3JjTGVuZ3RoKTtcblxuICAgIC8vIGdldCBkZXN0aW5hdGlvbiBncHUgYnVmZmVyXG4gICAgY29uc3QgZ3B1RGF0YUNhY2hlID0gdGhpcy5zdG9yYWdlQ2FjaGUuZ2V0KGlkKTtcbiAgICBpZiAoIWdwdURhdGFDYWNoZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdncHUgZGF0YSBmb3IgdXBsb2FkaW5nIGRvZXMgbm90IGV4aXN0Jyk7XG4gICAgfVxuICAgIGlmIChncHVEYXRhQ2FjaGUub3JpZ2luYWxTaXplICE9PSBzcmNMZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgaW5jb25zaXN0ZW50IGRhdGEgc2l6ZS4gZ3B1IGRhdGEgc2l6ZT0ke2dwdURhdGFDYWNoZS5vcmlnaW5hbFNpemV9LCBkYXRhIHNpemU9JHtzcmNMZW5ndGh9YCk7XG4gICAgfVxuXG4gICAgLy8gY3JlYXRlIGdwdSBidWZmZXJcbiAgICBjb25zdCBncHVCdWZmZXJGb3JVcGxvYWRpbmcgPSB0aGlzLmJhY2tlbmQuZGV2aWNlLmNyZWF0ZUJ1ZmZlcihcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWJpdHdpc2VcbiAgICAgICAge21hcHBlZEF0Q3JlYXRpb246IHRydWUsIHNpemUsIHVzYWdlOiBHUFVCdWZmZXJVc2FnZS5NQVBfV1JJVEUgfCBHUFVCdWZmZXJVc2FnZS5DT1BZX1NSQ30pO1xuXG4gICAgLy8gY29weSAodXBsb2FkKSBkYXRhXG4gICAgY29uc3QgYXJyYXlCdWZmZXIgPSBncHVCdWZmZXJGb3JVcGxvYWRpbmcuZ2V0TWFwcGVkUmFuZ2UoKTtcbiAgICBuZXcgVWludDhBcnJheShhcnJheUJ1ZmZlcikuc2V0KG5ldyBVaW50OEFycmF5KHNyY0FycmF5QnVmZmVyLCBzcmNPZmZzZXQsIHNyY0xlbmd0aCkpO1xuICAgIGdwdUJ1ZmZlckZvclVwbG9hZGluZy51bm1hcCgpO1xuXG5cbiAgICAvLyBHUFUgY29weVxuICAgIGNvbnN0IGNvbW1hbmRFbmNvZGVyID0gdGhpcy5iYWNrZW5kLmdldENvbW1hbmRFbmNvZGVyKCk7XG4gICAgdGhpcy5iYWNrZW5kLmVuZENvbXB1dGVQYXNzKCk7XG4gICAgY29tbWFuZEVuY29kZXIuY29weUJ1ZmZlclRvQnVmZmVyKGdwdUJ1ZmZlckZvclVwbG9hZGluZywgMCwgZ3B1RGF0YUNhY2hlLmdwdURhdGEuYnVmZmVyLCAwLCBzaXplKTtcblxuICAgIExPR19ERUJVRygndmVyYm9zZScsICgpID0+IGBbV2ViR1BVXSBHcHVEYXRhTWFuYWdlci51cGxvYWQoaWQ9JHtpZH0pYCk7XG5cbiAgICB0aGlzLmJ1ZmZlcnNGb3JVcGxvYWRpbmdQZW5kaW5nLnB1c2goZ3B1QnVmZmVyRm9yVXBsb2FkaW5nKTtcbiAgfVxuXG4gIG1lbWNweShzb3VyY2VJZDogR3B1RGF0YUlkLCBkZXN0aW5hdGlvbklkOiBHcHVEYXRhSWQpOiB2b2lkIHtcbiAgICAvLyBnZXQgc291cmNlIGdwdSBidWZmZXJcbiAgICBjb25zdCBzb3VyY2VHcHVEYXRhQ2FjaGUgPSB0aGlzLnN0b3JhZ2VDYWNoZS5nZXQoc291cmNlSWQpO1xuICAgIGlmICghc291cmNlR3B1RGF0YUNhY2hlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NvdXJjZSBncHUgZGF0YSBmb3IgbWVtY3B5IGRvZXMgbm90IGV4aXN0Jyk7XG4gICAgfVxuICAgIC8vIGdldCBkZXN0aW5hdGlvbiBncHUgYnVmZmVyXG4gICAgY29uc3QgZGVzdGluYXRpb25HcHVEYXRhQ2FjaGUgPSB0aGlzLnN0b3JhZ2VDYWNoZS5nZXQoZGVzdGluYXRpb25JZCk7XG4gICAgaWYgKCFkZXN0aW5hdGlvbkdwdURhdGFDYWNoZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdkZXN0aW5hdGlvbiBncHUgZGF0YSBmb3IgbWVtY3B5IGRvZXMgbm90IGV4aXN0Jyk7XG4gICAgfVxuICAgIGlmIChzb3VyY2VHcHVEYXRhQ2FjaGUub3JpZ2luYWxTaXplICE9PSBkZXN0aW5hdGlvbkdwdURhdGFDYWNoZS5vcmlnaW5hbFNpemUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW5jb25zaXN0ZW50IHNvdXJjZSBhbmQgZGVzdGluYXRpb24gZ3B1IGRhdGEgc2l6ZScpO1xuICAgIH1cbiAgICBjb25zdCBzaXplID0gY2FsY05vcm1hbGl6ZWRCdWZmZXJTaXplKHNvdXJjZUdwdURhdGFDYWNoZS5vcmlnaW5hbFNpemUpO1xuXG4gICAgLy8gR1BVIGNvcHlcbiAgICBjb25zdCBjb21tYW5kRW5jb2RlciA9IHRoaXMuYmFja2VuZC5nZXRDb21tYW5kRW5jb2RlcigpO1xuICAgIHRoaXMuYmFja2VuZC5lbmRDb21wdXRlUGFzcygpO1xuICAgIGNvbW1hbmRFbmNvZGVyLmNvcHlCdWZmZXJUb0J1ZmZlcihcbiAgICAgICAgc291cmNlR3B1RGF0YUNhY2hlLmdwdURhdGEuYnVmZmVyLCAwLCBkZXN0aW5hdGlvbkdwdURhdGFDYWNoZS5ncHVEYXRhLmJ1ZmZlciwgMCwgc2l6ZSk7XG4gIH1cblxuICByZWdpc3RlckV4dGVybmFsQnVmZmVyKGJ1ZmZlcjogR1BVQnVmZmVyLCBvcmlnaW5hbFNpemU6IG51bWJlciwgcHJldmlvdXNCdWZmZXI/OiBHUFVCdWZmZXIpOiBudW1iZXIge1xuICAgIGxldCBpZDogbnVtYmVyfHVuZGVmaW5lZDtcbiAgICBpZiAocHJldmlvdXNCdWZmZXIpIHtcbiAgICAgIGlkID0gdGhpcy5leHRlcm5hbEJ1ZmZlcnMuZ2V0KHByZXZpb3VzQnVmZmVyKTtcbiAgICAgIGlmIChpZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncHJldmlvdXMgYnVmZmVyIGlzIG5vdCByZWdpc3RlcmVkJyk7XG4gICAgICB9XG4gICAgICBpZiAoYnVmZmVyID09PSBwcmV2aW91c0J1ZmZlcikge1xuICAgICAgICBMT0dfREVCVUcoXG4gICAgICAgICAgICAndmVyYm9zZScsXG4gICAgICAgICAgICAoKSA9PiBgW1dlYkdQVV0gR3B1RGF0YU1hbmFnZXIucmVnaXN0ZXJFeHRlcm5hbEJ1ZmZlcihzaXplPSR7b3JpZ2luYWxTaXplfSkgPT4gaWQ9JHtcbiAgICAgICAgICAgICAgICBpZH0sIGJ1ZmZlciBpcyB0aGUgc2FtZSwgc2tpcC5gKTtcbiAgICAgICAgcmV0dXJuIGlkO1xuICAgICAgfVxuICAgICAgdGhpcy5leHRlcm5hbEJ1ZmZlcnMuZGVsZXRlKHByZXZpb3VzQnVmZmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWQgPSBjcmVhdGVOZXdHcHVEYXRhSWQoKTtcbiAgICB9XG5cbiAgICB0aGlzLnN0b3JhZ2VDYWNoZS5zZXQoaWQsIHtncHVEYXRhOiB7aWQsIHR5cGU6IEdwdURhdGFUeXBlLmRlZmF1bHQsIGJ1ZmZlcn0sIG9yaWdpbmFsU2l6ZX0pO1xuICAgIHRoaXMuZXh0ZXJuYWxCdWZmZXJzLnNldChidWZmZXIsIGlkKTtcbiAgICBMT0dfREVCVUcoXG4gICAgICAgICd2ZXJib3NlJyxcbiAgICAgICAgKCkgPT4gYFtXZWJHUFVdIEdwdURhdGFNYW5hZ2VyLnJlZ2lzdGVyRXh0ZXJuYWxCdWZmZXIoc2l6ZT0ke29yaWdpbmFsU2l6ZX0pID0+IGlkPSR7aWR9LCByZWdpc3RlcmVkLmApO1xuICAgIHJldHVybiBpZDtcbiAgfVxuXG4gIHVucmVnaXN0ZXJFeHRlcm5hbEJ1ZmZlcihidWZmZXI6IEdQVUJ1ZmZlcik6IHZvaWQge1xuICAgIGNvbnN0IGlkID0gdGhpcy5leHRlcm5hbEJ1ZmZlcnMuZ2V0KGJ1ZmZlcik7XG4gICAgaWYgKGlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuc3RvcmFnZUNhY2hlLmRlbGV0ZShpZCk7XG4gICAgICB0aGlzLmV4dGVybmFsQnVmZmVycy5kZWxldGUoYnVmZmVyKTtcbiAgICAgIExPR19ERUJVRygndmVyYm9zZScsICgpID0+IGBbV2ViR1BVXSBHcHVEYXRhTWFuYWdlci51bnJlZ2lzdGVyRXh0ZXJuYWxCdWZmZXIoKSA9PiBpZD0ke2lkfWApO1xuICAgIH1cbiAgfVxuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1iaXR3aXNlXG4gIGNyZWF0ZShzaXplOiBudW1iZXIsIHVzYWdlID0gR1BVQnVmZmVyVXNhZ2UuU1RPUkFHRSB8IEdQVUJ1ZmZlclVzYWdlLkNPUFlfU1JDIHwgR1BVQnVmZmVyVXNhZ2UuQ09QWV9EU1QpOiBHcHVEYXRhIHtcbiAgICBjb25zdCBidWZmZXJTaXplID0gY2FsY05vcm1hbGl6ZWRCdWZmZXJTaXplKHNpemUpO1xuXG4gICAgbGV0IGdwdUJ1ZmZlcjtcbiAgICAvLyBDdXJyZW50bHksIG9ubHkgc3RvcmFnZSBidWZmZXJzIGFyZSByZXVzZWQuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWJpdHdpc2VcbiAgICBjb25zdCBpc1N0b3JhZ2UgPSAodXNhZ2UgJiBHUFVCdWZmZXJVc2FnZS5TVE9SQUdFKSA9PT0gR1BVQnVmZmVyVXNhZ2UuU1RPUkFHRTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYml0d2lzZVxuICAgIGNvbnN0IGlzVW5pZm9ybSA9ICh1c2FnZSAmIEdQVUJ1ZmZlclVzYWdlLlVOSUZPUk0pID09PSBHUFVCdWZmZXJVc2FnZS5VTklGT1JNO1xuICAgIGlmIChpc1N0b3JhZ2UgfHwgaXNVbmlmb3JtKSB7XG4gICAgICBjb25zdCBmcmVlQnVmZmVycyA9IGlzU3RvcmFnZSA/IHRoaXMuZnJlZUJ1ZmZlcnMgOiB0aGlzLmZyZWVVbmlmb3JtQnVmZmVycztcbiAgICAgIGxldCBidWZmZXJzID0gZnJlZUJ1ZmZlcnMuZ2V0KGJ1ZmZlclNpemUpO1xuICAgICAgaWYgKCFidWZmZXJzKSB7XG4gICAgICAgIGJ1ZmZlcnMgPSBbXTtcbiAgICAgICAgZnJlZUJ1ZmZlcnMuc2V0KGJ1ZmZlclNpemUsIGJ1ZmZlcnMpO1xuICAgICAgfVxuICAgICAgaWYgKGJ1ZmZlcnMubGVuZ3RoID4gMCkge1xuICAgICAgICBncHVCdWZmZXIgPSBidWZmZXJzLnBvcCgpIGFzIEdQVUJ1ZmZlcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGNyZWF0ZSBncHUgYnVmZmVyXG4gICAgICAgIGdwdUJ1ZmZlciA9IHRoaXMuYmFja2VuZC5kZXZpY2UuY3JlYXRlQnVmZmVyKHtzaXplOiBidWZmZXJTaXplLCB1c2FnZX0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBjcmVhdGUgZ3B1IGJ1ZmZlclxuICAgICAgZ3B1QnVmZmVyID0gdGhpcy5iYWNrZW5kLmRldmljZS5jcmVhdGVCdWZmZXIoe3NpemU6IGJ1ZmZlclNpemUsIHVzYWdlfSk7XG4gICAgfVxuXG4gICAgY29uc3QgZ3B1RGF0YSA9IHtpZDogY3JlYXRlTmV3R3B1RGF0YUlkKCksIHR5cGU6IEdwdURhdGFUeXBlLmRlZmF1bHQsIGJ1ZmZlcjogZ3B1QnVmZmVyfTtcbiAgICB0aGlzLnN0b3JhZ2VDYWNoZS5zZXQoZ3B1RGF0YS5pZCwge2dwdURhdGEsIG9yaWdpbmFsU2l6ZTogc2l6ZX0pO1xuXG4gICAgTE9HX0RFQlVHKCd2ZXJib3NlJywgKCkgPT4gYFtXZWJHUFVdIEdwdURhdGFNYW5hZ2VyLmNyZWF0ZShzaXplPSR7c2l6ZX0pID0+IGlkPSR7Z3B1RGF0YS5pZH1gKTtcbiAgICByZXR1cm4gZ3B1RGF0YTtcbiAgfVxuXG4gIGdldChpZDogR3B1RGF0YUlkKTogR3B1RGF0YXx1bmRlZmluZWQge1xuICAgIHJldHVybiB0aGlzLnN0b3JhZ2VDYWNoZS5nZXQoaWQpPy5ncHVEYXRhO1xuICB9XG5cbiAgcmVsZWFzZShpZDogR3B1RGF0YUlkKTogbnVtYmVyIHtcbiAgICBjb25zdCBjYWNoZWREYXRhID0gdGhpcy5zdG9yYWdlQ2FjaGUuZ2V0KGlkKTtcbiAgICBpZiAoIWNhY2hlZERhdGEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigncmVsZWFzaW5nIGRhdGEgZG9lcyBub3QgZXhpc3QnKTtcbiAgICB9XG5cbiAgICBMT0dfREVCVUcoJ3ZlcmJvc2UnLCAoKSA9PiBgW1dlYkdQVV0gR3B1RGF0YU1hbmFnZXIucmVsZWFzZShpZD0ke2lkfSksIGdwdURhdGFJZD0ke2NhY2hlZERhdGEuZ3B1RGF0YS5pZH1gKTtcblxuICAgIHRoaXMuc3RvcmFnZUNhY2hlLmRlbGV0ZShpZCk7XG4gICAgdGhpcy5idWZmZXJzUGVuZGluZy5wdXNoKGNhY2hlZERhdGEuZ3B1RGF0YS5idWZmZXIpO1xuICAgIC8vIGNhY2hlZERhdGEuZ3B1RGF0YS5idWZmZXIuZGVzdHJveSgpO1xuXG4gICAgcmV0dXJuIGNhY2hlZERhdGEub3JpZ2luYWxTaXplO1xuICB9XG5cbiAgYXN5bmMgZG93bmxvYWQoaWQ6IEdwdURhdGFJZCwgZ2V0VGFyZ2V0QnVmZmVyOiAoKSA9PiBVaW50OEFycmF5KTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc3QgY2FjaGVkRGF0YSA9IHRoaXMuc3RvcmFnZUNhY2hlLmdldChpZCk7XG4gICAgaWYgKCFjYWNoZWREYXRhKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2RhdGEgZG9lcyBub3QgZXhpc3QnKTtcbiAgICB9XG5cbiAgICBhd2FpdCBkb3dubG9hZEdwdURhdGEodGhpcy5iYWNrZW5kLCBjYWNoZWREYXRhLmdwdURhdGEuYnVmZmVyLCBjYWNoZWREYXRhLm9yaWdpbmFsU2l6ZSwgZ2V0VGFyZ2V0QnVmZmVyKTtcbiAgfVxuXG4gIHJlZnJlc2hQZW5kaW5nQnVmZmVycygpOiB2b2lkIHtcbiAgICBmb3IgKGNvbnN0IGJ1ZmZlciBvZiB0aGlzLmJ1ZmZlcnNGb3JVcGxvYWRpbmdQZW5kaW5nKSB7XG4gICAgICAvLyB1cGxvYWQgYnVmZmVyIGlzIG9ubHkgdXNlZnVsIGluIHRoZSBzZXNzaW9uIGNyZWF0aW9uIHRpbWUuIFNvIHdlIGRvbid0IG5lZWQgdG8gcmV1c2UgdGhlbSBpbiBzZXNzaW9uIHJ1bm5pbmcuXG4gICAgICBidWZmZXIuZGVzdHJveSgpO1xuICAgIH1cbiAgICB0aGlzLmJ1ZmZlcnNGb3JVcGxvYWRpbmdQZW5kaW5nID0gW107XG4gICAgZm9yIChjb25zdCBidWZmZXIgb2YgdGhpcy5idWZmZXJzUGVuZGluZykge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWJpdHdpc2VcbiAgICAgIGlmICgoYnVmZmVyLnVzYWdlICYgR1BVQnVmZmVyVXNhZ2UuU1RPUkFHRSkgPT09IEdQVUJ1ZmZlclVzYWdlLlNUT1JBR0UpIHtcbiAgICAgICAgLy8gUHV0IHRoZSBwZW5kaW5nIGJ1ZmZlciB0byBmcmVlQnVmZmVycyBsaXN0IGluc3RlYWQgb2YgcmVhbGx5IGRlc3Ryb3lpbmcgaXQgZm9yIGJ1ZmZlciByZXVzaW5nLlxuICAgICAgICB0aGlzLmZyZWVCdWZmZXJzLmdldChidWZmZXIuc2l6ZSkhLnB1c2goYnVmZmVyKTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWJpdHdpc2VcbiAgICAgIH0gZWxzZSBpZiAoKGJ1ZmZlci51c2FnZSAmIEdQVUJ1ZmZlclVzYWdlLlVOSUZPUk0pID09PSBHUFVCdWZmZXJVc2FnZS5VTklGT1JNKSB7XG4gICAgICAgIC8vIFB1dCB0aGUgcGVuZGluZyBidWZmZXIgdG8gZnJlZVVuaWZvcm1CdWZmZXJzIGxpc3QgaW5zdGVhZCBvZiByZWFsbHkgZGVzdHJveWluZyBpdCBmb3IgYnVmZmVyIHJldXNpbmcuXG4gICAgICAgIHRoaXMuZnJlZVVuaWZvcm1CdWZmZXJzLmdldChidWZmZXIuc2l6ZSkhLnB1c2goYnVmZmVyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJ1ZmZlci5kZXN0cm95KCk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuYnVmZmVyc1BlbmRpbmcgPSBbXTtcbiAgfVxuXG4gIGRpc3Bvc2UoKSB7XG4gICAgdGhpcy5mcmVlQnVmZmVycy5mb3JFYWNoKChidWZmZXJzKSA9PiB7XG4gICAgICBidWZmZXJzLmZvckVhY2goYnVmZmVyID0+IHtcbiAgICAgICAgYnVmZmVyLmRlc3Ryb3koKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHRoaXMuZnJlZVVuaWZvcm1CdWZmZXJzLmZvckVhY2goKGJ1ZmZlcnMpID0+IHtcbiAgICAgIGJ1ZmZlcnMuZm9yRWFjaChidWZmZXIgPT4ge1xuICAgICAgICBidWZmZXIuZGVzdHJveSgpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICB0aGlzLnN0b3JhZ2VDYWNoZS5mb3JFYWNoKChzdG9yYWdlKSA9PiB7XG4gICAgICBzdG9yYWdlLmdwdURhdGEuYnVmZmVyLmRlc3Ryb3koKTtcbiAgICB9KTtcblxuICAgIHRoaXMuc3RvcmFnZUNhY2hlID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuZnJlZUJ1ZmZlcnMgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5mcmVlVW5pZm9ybUJ1ZmZlcnMgPSBuZXcgTWFwKCk7XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IGNyZWF0ZUdwdURhdGFNYW5hZ2VyID0gKC4uLmFyZ3M6IENvbnN0cnVjdG9yUGFyYW1ldGVyczx0eXBlb2YgR3B1RGF0YU1hbmFnZXJJbXBsPik6IEdwdURhdGFNYW5hZ2VyID0+XG4gICAgbmV3IEdwdURhdGFNYW5hZ2VySW1wbCguLi5hcmdzKTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuY2xhc3MgQXR0cmlidXRlV2l0aENhY2hlS2V5SW1wbCB7XG4gIGNvbnN0cnVjdG9yKGF0dHJpYnV0ZTogUmVjb3JkPHN0cmluZywgdW5rbm93bj4pIHtcbiAgICBPYmplY3QuYXNzaWduKHRoaXMsIGF0dHJpYnV0ZSk7XG4gIH1cblxuICBwcml2YXRlIGtleTogc3RyaW5nO1xuICBwdWJsaWMgZ2V0IGNhY2hlS2V5KCk6IHN0cmluZyB7XG4gICAgaWYgKCF0aGlzLmtleSkge1xuICAgICAgdGhpcy5rZXkgPVxuICAgICAgICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRoaXMpLnNvcnQoKS5tYXAobmFtZSA9PiBgJHsodGhpcyBhcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPilbbmFtZV19YCkuam9pbignOycpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5rZXk7XG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkge1xuICByZWFkb25seSBjYWNoZUtleTogc3RyaW5nO1xufVxuXG4vKipcbiAqIGNyZWF0ZSBhIG5ldyBvYmplY3QgZnJvbSB0aGUgZ2l2ZW4gYXR0cmlidXRlLCBhbmQgYWRkIGEgY2FjaGVLZXkgcHJvcGVydHkgdG8gaXRcbiAqL1xuZXhwb3J0IGNvbnN0IGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSA9IDxUIGV4dGVuZHMgUmVjb3JkPHN0cmluZywgdW5rbm93bj4+KGF0dHJpYnV0ZTogVCk6IFQmQXR0cmlidXRlV2l0aENhY2hlS2V5ID0+XG4gICAgbmV3IEF0dHJpYnV0ZVdpdGhDYWNoZUtleUltcGwoYXR0cmlidXRlKSBhcyB1bmtub3duIGFzIFQgJiBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXk7XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXBhcmFtLXJlYXNzaWduICovXG5cbmV4cG9ydCBjbGFzcyBNYXRNdWxVdGlsIHtcbiAgLyoqXG4gICAqIENhbGN1bGF0ZSB0aGUgZXhwZWN0ZWQgc2hhcGUgd2hlbiBtYXRyaXggbXVsdGlwbGljYXRpb25cbiAgICogQHBhcmFtIGEgVGhlIHNoYXBlIG9mIHRlbnNvciBBLiBTaG91bGQgYmUgYSB0dXBsZSBvZiAyIHBvc2l0aXZlIGludGVnZXJzXG4gICAqIEBwYXJhbSBiIFRoZSBzaGFwZSBvZiB0ZW5zb3IgQi4gU2hvdWxkIGJlIGEgdHVwbGUgb2YgMiBwb3NpdGl2ZSBpbnRlZ2Vyc1xuICAgKiBAcmV0dXJucyBUaGUgZXhwZWN0ZWQgc2hhcGUgb2YgdGhlIHJlc3VsdCwgb3IgdW5kZWZpbmVkIGlmIE4vQVxuICAgKi9cbiAgc3RhdGljIGNhbGNNYXRNdWxTaGFwZShhOiBbbnVtYmVyLCBudW1iZXJdLCBiOiBbbnVtYmVyLCBudW1iZXJdKTogW251bWJlciwgbnVtYmVyXXx1bmRlZmluZWQge1xuICAgIHJldHVybiAoYVsxXSAhPT0gYlswXSkgPyB1bmRlZmluZWQgOiBbYVswXSwgYlsxXV07XG4gIH1cbn1cblxuXG5leHBvcnQgY2xhc3MgQnJvYWRjYXN0VXRpbCB7XG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgdGhlIGV4cGVjdGVkIHNoYXBlIHdoZW4gYnJvYWRjYXN0aW5nIDIgdGVuc29yc1xuICAgKiBAcGFyYW0gYSBUaGUgc2hhcGUgb2YgdGVuc29yIEEuIFNob3VsZCBiZSBhbiBhcnJheSBvZiBwb3NpdGl2ZSBpbnRlZ2Vyc1xuICAgKiBAcGFyYW0gYiBUaGUgc2hhcGUgb2YgdGVuc29yIEIuIFNob3VsZCBiZSBhbiBhcnJheSBvZiBwb3NpdGl2ZSBpbnRlZ2Vyc1xuICAgKiBAcGFyYW0gaXNNYXRNdWwgV2hldGhlciB0aGUgb3BlcmF0aW9uIGlzIE1hdE11bFxuICAgKiBAcmV0dXJucyBUaGUgZXhwZWN0ZWQgc2hhcGUgb2YgdGhlIHJlc3VsdCwgb3IgdW5kZWZpbmVkIGlmIE4vQVxuICAgKi9cbiAgc3RhdGljIGNhbGNTaGFwZShhZGltczogcmVhZG9ubHkgbnVtYmVyW10sIGJkaW1zOiByZWFkb25seSBudW1iZXJbXSwgaXNNYXRNdWwgPSBmYWxzZSk6IHJlYWRvbmx5IG51bWJlcltdfHVuZGVmaW5lZCB7XG4gICAgY29uc3QgYXJhbmsgPSBhZGltcy5sZW5ndGg7XG4gICAgY29uc3QgYnJhbmsgPSBiZGltcy5sZW5ndGg7XG4gICAgaWYgKGFyYW5rID09PSAwKSB7XG4gICAgICByZXR1cm4gYmRpbXM7XG4gICAgfVxuICAgIGlmIChicmFuayA9PT0gMCkge1xuICAgICAgcmV0dXJuIGFkaW1zO1xuICAgIH1cbiAgICBjb25zdCBjcmFuayA9IE1hdGgubWF4KGFkaW1zLmxlbmd0aCwgYmRpbXMubGVuZ3RoKTtcbiAgICBjb25zdCBjZGltcyA9IG5ldyBBcnJheTxudW1iZXI+KGNyYW5rKTtcblxuICAgIC8vIGNhbGN1bGF0ZSB0aGUgbGFzdCAyIGRpbWVuc2lvbiBpZiBpdCBpcyBNYXRNdWxcbiAgICBpZiAoaXNNYXRNdWwpIHtcbiAgICAgIGlmIChhcmFuayA8IDIgfHwgYnJhbmsgPCAyKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBjb25zdCBjU2hhcGVNYXRNdWwgPVxuICAgICAgICAgIE1hdE11bFV0aWwuY2FsY01hdE11bFNoYXBlKFthZGltc1thcmFuayAtIDJdLCBhZGltc1thcmFuayAtIDFdXSwgW2JkaW1zW2JyYW5rIC0gMl0sIGJkaW1zW2JyYW5rIC0gMV1dKTtcbiAgICAgIGlmIChjU2hhcGVNYXRNdWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgW2NkaW1zW2NyYW5rIC0gMl0sIGNkaW1zW2NyYW5rIC0gMV1dID0gY1NoYXBlTWF0TXVsO1xuICAgIH1cblxuICAgIGZvciAobGV0IGkgPSBpc01hdE11bCA/IDMgOiAxOyBpIDw9IGNyYW5rOyBpKyspIHtcbiAgICAgIGNvbnN0IGFMZW4gPSBhcmFuayAtIGkgPCAwID8gMSA6IGFkaW1zW2FyYW5rIC0gaV07XG4gICAgICBjb25zdCBiTGVuID0gYnJhbmsgLSBpIDwgMCA/IDEgOiBiZGltc1ticmFuayAtIGldO1xuXG4gICAgICBpZiAoYUxlbiAhPT0gYkxlbiAmJiBhTGVuID4gMSAmJiBiTGVuID4gMSkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgY2RpbXNbY3JhbmsgLSBpXSA9IE1hdGgubWF4KGFMZW4sIGJMZW4pO1xuICAgIH1cblxuICAgIHJldHVybiBjZGltcztcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmUgaWYgYSBzaGFwZSBpcyB1bmlkaXJlY3Rpb25hbCBicm9hZGNhc3RhYmxlIHRvIGFub3RoZXIgc2hhcGVcbiAgICogQHBhcmFtIHNoYXBlIFRoZSBpbnB1dCBzaGFwZVxuICAgKiBAcGFyYW0gZmluYWxTaGFwZSBUaGUgZGVzaXJlZCBzaGFwZSBhZnRlciBicm9hZGNhc3RpbmdcbiAgICovXG4gIHN0YXRpYyBpc1ZhbGlkQnJvYWRjYXN0KHNoYXBlOiByZWFkb25seSBudW1iZXJbXSwgZmluYWxTaGFwZTogcmVhZG9ubHkgbnVtYmVyW10pOiBib29sZWFuIHtcbiAgICAvLyBhbGlnbiBzaGFwZSB0byB0aGUgcmlnaHRcbiAgICBjb25zdCBpbnB1dFJhbmsgPSBzaGFwZS5sZW5ndGg7XG4gICAgY29uc3QgZmluYWxSYW5rID0gZmluYWxTaGFwZS5sZW5ndGg7XG4gICAgaWYgKGlucHV0UmFuayA+IGZpbmFsUmFuaykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMTsgaSA8PSBpbnB1dFJhbms7IGkrKykge1xuICAgICAgaWYgKHNoYXBlW2lucHV0UmFuayAtIGldICE9PSAxICYmIHNoYXBlW2lucHV0UmFuayAtIGldICE9PSBmaW5hbFNoYXBlW2ZpbmFsUmFuayAtIGldKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cblxuXG5leHBvcnQgY2xhc3MgU2hhcGVVdGlsIHtcbiAgLyoqXG4gICAqIGNhbGN1bGF0ZSB0aGUgc2l6ZSAobnVtYmVyIG9mIGVsZW1lbnRzKVxuICAgKi9cbiAgc3RhdGljIHNpemUoZGltczogcmVhZG9ubHkgbnVtYmVyW10pOiBudW1iZXIge1xuICAgIHJldHVybiBTaGFwZVV0aWwuZ2V0U2l6ZUZyb21EaW1lbnNpb25SYW5nZShkaW1zLCAwLCBkaW1zLmxlbmd0aCk7XG4gIH1cblxuICAvKipcbiAgICogY2FsY3VsYXRlIHRoZSBzaXplIChudW1iZXIgb2YgZWxlbWVudHMpIGZyb20gdGhlIGdpdmVuIGF4aXMgKGluY2x1c2l2ZSlcbiAgICovXG4gIHN0YXRpYyBzaXplRnJvbURpbWVuc2lvbihkaW1zOiByZWFkb25seSBudW1iZXJbXSwgYXhpczogbnVtYmVyKTogbnVtYmVyIHtcbiAgICBpZiAoYXhpcyA8IDAgfHwgYXhpcyA+IGRpbXMubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgZGltZW5zaW9uIG9mICR7YXhpc30gZm9yIHNpemVGcm9tRGltZW5zaW9uIGFzIFRlbnNvciBoYXMgJHtkaW1zLmxlbmd0aH0gZGltZW5zaW9ucy5gKTtcbiAgICB9XG4gICAgcmV0dXJuIFNoYXBlVXRpbC5nZXRTaXplRnJvbURpbWVuc2lvblJhbmdlKGRpbXMsIGF4aXMsIGRpbXMubGVuZ3RoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBjYWxjdWxhdGUgdGhlIHNpemUgKG51bWJlciBvZiBlbGVtZW50cykgdG8gdGhlIGdpdmVuIGF4aXMgKGV4Y2x1c2l2ZSlcbiAgICovXG4gIHN0YXRpYyBzaXplVG9EaW1lbnNpb24oZGltczogcmVhZG9ubHkgbnVtYmVyW10sIGF4aXM6IG51bWJlcik6IG51bWJlciB7XG4gICAgaWYgKGF4aXMgPCAwIHx8IGF4aXMgPiBkaW1zLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGRpbWVuc2lvbiBvZiAke2F4aXN9IGZvciBzaXplVG9EaW1lbnNpb24gYXMgVGVuc29yIGhhcyAke2RpbXMubGVuZ3RofSBkaW1lbnNpb25zLmApO1xuICAgIH1cbiAgICByZXR1cm4gU2hhcGVVdGlsLmdldFNpemVGcm9tRGltZW5zaW9uUmFuZ2UoZGltcywgMCwgYXhpcyk7XG4gIH1cblxuICAvKipcbiAgICogY2FsY3VsYXRlIHRoZSBzaXplIChudW1iZXIgb2YgZWxlbWVudHMpIGZyb20gYW5kIHRvIHRoZSBnaXZlbiBheGlzIFtzdGFydCwgZW5kKVxuICAgKi9cbiAgc3RhdGljIGdldFNpemVGcm9tRGltZW5zaW9uUmFuZ2UoZGltczogcmVhZG9ubHkgbnVtYmVyW10sIHN0YXJ0OiBudW1iZXIsIGVuZDogbnVtYmVyKTogbnVtYmVyIHtcbiAgICBsZXQgc2l6ZSA9IDE7XG4gICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICAgIC8vIHNhZmV0eSBjaGVjayBhcyB0aGlzIG1ldGhvZCBpcyBjYWxsZWQgYnkgbXVsdGlwbGUgb3RoZXIgbWV0aG9kcyByZXF1aXJpbmcgc2l6ZS5cbiAgICAgIC8vIHNpemUgY2Fubm90IGJlIG5lZ2F0aXZlLlxuICAgICAgaWYgKGRpbXNbaV0gPCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtbGVuXG4gICAgICAgICAgICAnY2Fubm90IGdldCB2YWxpZCBzaXplIGZyb20gc3BlY2lmaWVkIGRpbWVuc2lvbiByYW5nZS4gTW9zdCBsaWtlbHkgdGhlIHJhbmdlIGNvbnRhaW5zIG5lZ2F0aXZlIHZhbHVlcyBpbiB0aGVtLicpO1xuICAgICAgfVxuICAgICAgc2l6ZSAqPSBkaW1zW2ldO1xuICAgIH1cbiAgICByZXR1cm4gc2l6ZTtcbiAgfVxuXG4gIHN0YXRpYyBjb21wdXRlU3RyaWRlcyhkaW1zOiByZWFkb25seSBudW1iZXJbXSk6IHJlYWRvbmx5IG51bWJlcltdIHtcbiAgICBjb25zdCByYW5rID0gZGltcy5sZW5ndGg7XG4gICAgaWYgKHJhbmsgPT09IDApIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9IGVsc2UgaWYgKHJhbmsgPT09IDEpIHtcbiAgICAgIHJldHVybiBbMV07XG4gICAgfVxuICAgIGNvbnN0IHN0cmlkZXMgPSBuZXcgQXJyYXkocmFuayk7XG4gICAgc3RyaWRlc1tyYW5rIC0gMV0gPSAxO1xuICAgIHN0cmlkZXNbcmFuayAtIDJdID0gZGltc1tyYW5rIC0gMV07XG4gICAgZm9yIChsZXQgaSA9IHJhbmsgLSAzOyBpID49IDA7IC0taSkge1xuICAgICAgc3RyaWRlc1tpXSA9IHN0cmlkZXNbaSArIDFdICogZGltc1tpICsgMV07XG4gICAgfVxuICAgIHJldHVybiBzdHJpZGVzO1xuICB9XG5cbiAgLyoqXG4gICAqIG5vcm1haWx6ZSBheGlzIG9mIHJhbmdlIFstciwgcikgaW50byBbMCwgcikuXG4gICAqL1xuICBzdGF0aWMgbm9ybWFsaXplQXhpcyhheGlzOiBudW1iZXIsIHRlbnNvclJhbms6IG51bWJlcik6IG51bWJlciB7XG4gICAgaWYgKGF4aXMgPCAtdGVuc29yUmFuayAmJiBheGlzID49IHRlbnNvclJhbmspIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigndW5zdXBwb3J0ZWQgYXhpcyBmb3IgdGhpcyBvcGVyYXRpb24uJyk7XG4gICAgfVxuICAgIHJldHVybiBheGlzIDwgMCA/IGF4aXMgKyB0ZW5zb3JSYW5rIDogYXhpcztcbiAgfVxuXG4gIHN0YXRpYyBub3JtYWxpemVBeGVzKGF4ZXM6IHJlYWRvbmx5IG51bWJlcltdLCB0ZW5zb3JSYW5rPzogbnVtYmVyKTogbnVtYmVyW10ge1xuICAgIHJldHVybiBheGVzLm1hcCh4ID0+IHRoaXMubm9ybWFsaXplQXhpcyh4LCB0ZW5zb3JSYW5rID8/IGF4ZXMubGVuZ3RoKSk7XG4gIH1cblxuICAvKipcbiAgICogU29ydHMgYSBnaXZlbiBhcnJheSBiYXNlZCBvbiB0aGUgaW5kaWNlcyBpbiB0aGUgUGVybSBhcnJheVxuICAgKiBVc2VkIGluIFRyYW5zcG9zZVxuICAgKiBAcGFyYW0gYSBBcnJheSB0byBiZSBzb3J0ZWQgc3VjaCBhcyBkaW1zIG9yIHN0cmlkZXNcbiAgICogQHBhcmFtIHBlcm0gUGVybSBnaXZlbjsgaWYgbnVsbCBhIHdpbGwgYmUgcmV2ZXJzZWRcbiAgICovXG4gIHN0YXRpYyBzb3J0QmFzZWRPblBlcm0oYTogcmVhZG9ubHkgbnVtYmVyW10sIHBlcm0/OiByZWFkb25seSBudW1iZXJbXSk6IHJlYWRvbmx5IG51bWJlcltdIHtcbiAgICBpZiAocGVybSkge1xuICAgICAgcmV0dXJuIHBlcm0ubWFwKCh2KSA9PiBhW3ZdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGEuc2xpY2UoKS5yZXZlcnNlKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFBhZHMgYSBnaXZlbiBzaGFwZSBhY2NvcmRpbmcgdG8gdGhlIHBhZGRpbmcgdmFsdWVzXG4gICAqIEBwYXJhbSBkaW1zIHNoYXBlIG9mIHRoZSBUZW5zb3IgdG8gYmUgcGFkZGVkXG4gICAqIEBwYXJhbSBwYWQgcGFkIHZhbHVlc1xuICAgKi9cbiAgc3RhdGljIHBhZFNoYXBlKGRpbXM6IHJlYWRvbmx5IG51bWJlcltdLCBwYWQ6IHJlYWRvbmx5IG51bWJlcltdKTogcmVhZG9ubHkgbnVtYmVyW10ge1xuICAgIGNvbnN0IHJhbmsgPSBkaW1zLmxlbmd0aDtcbiAgICByZXR1cm4gZGltcy5tYXAoKHYsIGkpID0+IHYgKyBwYWRbaV0gKyBwYWRbaSArIHJhbmtdKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIGlmIHRoZSB0d28gc2hhcGVzIGFyZSBpZGVudGljYWxcbiAgICogQHBhcmFtIHNoYXBlMVxuICAgKiBAcGFyYW0gc2hhcGUyXG4gICAqL1xuICBzdGF0aWMgYXJlRXF1YWwoc2hhcGUxOiByZWFkb25seSBudW1iZXJbXSwgc2hhcGUyOiByZWFkb25seSBudW1iZXJbXSk6IGJvb2xlYW4ge1xuICAgIGlmIChzaGFwZTEubGVuZ3RoICE9PSBzaGFwZTIubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBzaGFwZTEuZXZlcnkoKHYsIGkpID0+IHYgPT09IHNoYXBlMltpXSk7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIFBvb2xDb252VXRpbCB7XG4gIC8qKlxuICAgKiBBZGp1c3QgdGhlIGtlcm5lbCwgc3RyaWRlcywgcGFkcyB0byBjb3JyZWN0IHJhbmsuIFNldCB0byBkZWZhdWx0IHZhbHVlIGlmIG5vdCBwcmVzZW50XG4gICAqIEBwYXJhbSBpc0dsb2JhbE9wZXJhdG9yIElmIHRydWUsIHBlcmZvcm0gZ2xvYmFsIHBvb2xpbmcuXG4gICAqIEBwYXJhbSBpbnB1dERpbXMgVGhlIGlucHV0IHRlbnNvciBkaW1lbnNpb24uXG4gICAqIEBwYXJhbSBrZXJuZWxTaGFwZSBUaGUgc2l6ZSBvZiB0aGUga2VybmVsIGFsb25nIGVhY2ggYXhpcy5cbiAgICogQHBhcmFtIHN0cmlkZXMgU3RyaWRlIGFsb25nIGVhY2ggYXhpcy5cbiAgICogQHBhcmFtIGRpbGF0aW9ucyBEaWxhdGlvbiBhbG9uZyBlYWNoIGF4aXMuXG4gICAqIEBwYXJhbSBwYWRzIFBhZGRpbmcgZm9yIHRoZSBiZWdpbm5pbmcgYW5kIGVuZGluZyBhbG9uZyBlYWNoIGF4aXMuXG4gICAqL1xuICBzdGF0aWMgYWRqdXN0UG9vbEF0dHJpYnV0ZXMoXG4gICAgICBpc0dsb2JhbE9wZXJhdG9yOiBib29sZWFuLCBpbnB1dERpbXM6IHJlYWRvbmx5IG51bWJlcltdLCBrZXJuZWxTaGFwZTogbnVtYmVyW10sIHN0cmlkZXM6IG51bWJlcltdLFxuICAgICAgZGlsYXRpb25zOiBudW1iZXJbXSwgcGFkczogbnVtYmVyW10pOiB2b2lkIHtcbiAgICBpZiAoIWlzR2xvYmFsT3BlcmF0b3IgJiYga2VybmVsU2hhcGUubGVuZ3RoICE9PSBpbnB1dERpbXMubGVuZ3RoIC0gMikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdsZW5ndGggb2Ygc3BlY2lmaWVkIGtlcm5lbCBzaGFwZXMgc2hvdWxkIGJlIDIgbGVzcyB0aGFuIGxlbmd0aCBvZiBpbnB1dCBkaW1lbnNpb25zJyk7XG4gICAgfVxuXG4gICAgaWYgKGlzR2xvYmFsT3BlcmF0b3IpIHtcbiAgICAgIC8vIGFkanVzdCBrZXJuZWwgc2hhcGUgdG8gY292ZXIgdGhlIGlucHV0IGRpbXNcbiAgICAgIGZvciAobGV0IGRpbSA9IDA7IGRpbSA8IGlucHV0RGltcy5sZW5ndGggLSAyOyBkaW0rKykge1xuICAgICAgICBpZiAoZGltID49IGtlcm5lbFNoYXBlLmxlbmd0aCkge1xuICAgICAgICAgIGtlcm5lbFNoYXBlLnB1c2goaW5wdXREaW1zW2RpbSArIDJdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBrZXJuZWxTaGFwZVtkaW1dID0gaW5wdXREaW1zW2RpbSArIDJdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gYWRqdXN0IHN0cmlkZXMgbGVuZ3RoIHRvIG1hdGNoIGtlcm5lbCBzaGFwZSBsZW5ndGhcbiAgICBmb3IgKGxldCBkaW0gPSAwOyBkaW0gPCBrZXJuZWxTaGFwZS5sZW5ndGg7IGRpbSsrKSB7XG4gICAgICBpZiAoZGltIDwgc3RyaWRlcy5sZW5ndGgpIHtcbiAgICAgICAgaWYgKHN0cmlkZXNbZGltXSA8IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3N0cmlkZXMgc2hvdWxkIGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAxJyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0cmlkZXMucHVzaCgxKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBhZGp1c3QgZGlsYXRpb24gdmFsdWVcbiAgICBmb3IgKGxldCBkaW0gPSAwOyBkaW0gPCBrZXJuZWxTaGFwZS5sZW5ndGg7IGRpbSsrKSB7XG4gICAgICBpZiAoZGltIDwgZGlsYXRpb25zLmxlbmd0aCkge1xuICAgICAgICBpZiAoZGlsYXRpb25zW2RpbV0gPCAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdkaWxhdGlvbnMgc2hvdWxkIGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAxJyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRpbGF0aW9ucy5wdXNoKDEpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGFkanVzdCBwYWRzIGxlbmd0aCB0byBtYXRjaCAyICoga2VybmVsIHNoYXBlIGxlbmd0aFxuICAgIGZvciAobGV0IGRpbSA9IDA7IGRpbSA8IGtlcm5lbFNoYXBlLmxlbmd0aCAqIDI7IGRpbSsrKSB7XG4gICAgICBpZiAoZGltIDwgcGFkcy5sZW5ndGgpIHtcbiAgICAgICAgaWYgKHBhZHNbZGltXSA8IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BhZCBzaG91bGQgYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIDEnKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFkcy5wdXNoKDApO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHNhbml0eSBjaGVja3MgZm9yIHZhbHVlcyBpbiBrZXJuZWwgc2hhcGVzIGFuZCBwYWRzXG4gICAgZm9yIChsZXQgZGltID0gMDsgZGltIDwga2VybmVsU2hhcGUubGVuZ3RoOyBkaW0rKykge1xuICAgICAgaWYgKGtlcm5lbFNoYXBlW2RpbV0gPD0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2tlcm5lbCBzaGFwZXMgbmVlZCB0byBiZSBncmVhdGVyIHRoYW4gMCcpO1xuICAgICAgfVxuXG4gICAgICBpZiAocGFkc1tkaW1dID49IGtlcm5lbFNoYXBlW2RpbV0gfHwgcGFkc1tkaW0gKyBrZXJuZWxTaGFwZS5sZW5ndGhdID49IGtlcm5lbFNoYXBlW2RpbV0pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwYWRzIHNob3VsZCBiZSBzbWFsbGVyIHRoYW4ga2VybmVsJyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gYWRqdXN0IHBhZCB2YWx1ZXMgYmFzZWQgb24gJ2F1dG9QYWQnIGF0dHJpYnV0ZVxuICBzdGF0aWMgYWRqdXN0UGFkc0Jhc2VkT25BdXRvUGFkKFxuICAgICAgaW5wdXREaW1zOiByZWFkb25seSBudW1iZXJbXSwgc3RyaWRlczogcmVhZG9ubHkgbnVtYmVyW10sIGRpbGF0aW9uczogcmVhZG9ubHkgbnVtYmVyW10sXG4gICAgICBrZXJuZWxTaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sIHBhZHM6IG51bWJlcltdLCBpc0NoYW5uZWxMYXN0OiBib29sZWFuLCBhdXRvUGFkPzogc3RyaW5nKTogdm9pZCB7XG4gICAgaWYgKCFhdXRvUGFkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHBhZHMubGVuZ3RoICE9PSAyICogKGlucHV0RGltcy5sZW5ndGggLSAyKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdsZW5ndGggb2YgcGFkcyBzaG91bGQgYmUgdHdpY2UgdGhlIGxlbmd0aCBvZiBkYXRhIGRpbWVuc2lvbnMnKTtcbiAgICB9XG5cbiAgICBpZiAoc3RyaWRlcy5sZW5ndGggIT09IChpbnB1dERpbXMubGVuZ3RoIC0gMikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbGVuZ3RoIG9mIHN0cmlkZXMgc2hvdWxkIGJlIHRoZSBsZW5ndGggb2YgZGF0YSBkaW1lbnNpb25zJyk7XG4gICAgfVxuXG4gICAgaWYgKGtlcm5lbFNoYXBlLmxlbmd0aCAhPT0gKGlucHV0RGltcy5sZW5ndGggLSAyKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdsZW5ndGggb2Yga2VybmVsIHNoYXBlcyBzaG91bGQgYmUgdGhlIGxlbmd0aCBvZiBkYXRhIGRpbWVuc2lvbnMnKTtcbiAgICB9XG5cbiAgICBmb3IgKGxldCBkaW0gPSAwOyBkaW0gPCBpbnB1dERpbXMubGVuZ3RoIC0gMjsgZGltKyspIHtcbiAgICAgIFBvb2xDb252VXRpbC5hZGp1c3RQYWRBbmRSZXR1cm5TaGFwZShcbiAgICAgICAgICBpbnB1dERpbXNbZGltICsgKGlzQ2hhbm5lbExhc3QgPyAxIDogMildLCBzdHJpZGVzW2RpbV0sIGRpbGF0aW9uc1tkaW1dLCBrZXJuZWxTaGFwZVtkaW1dLCBwYWRzLCBkaW0sXG4gICAgICAgICAgZGltICsgaW5wdXREaW1zLmxlbmd0aCAtIDIsIGF1dG9QYWQpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgdGhlIG91dHB1dCBzaGFwZSBmb3IgUG9vbCBvcHMgYmFzZWQgb24gaW5wdXQgYXR0cmlidXRlcy4gKFNob3VsZCBiZSB1c2VkIG9ubHkgZm9yIFBvb2wgb3BzKVxuICAgKiBAcGFyYW0gaXNHbG9iYWxPcGVyYXRvciBJZiB0cnVlLCBwZXJmb3JtIGdsb2JhbCBwb29saW5nLlxuICAgKiBAcGFyYW0gaW5wdXREaW1zIFRoZSBpbnB1dCB0ZW5zb3IgZGltZW5zaW9uLiAoaW5wdXRzWzBdLmRpbXMpXG4gICAqIEBwYXJhbSBzdHJpZGVzIFN0cmlkZSBhbG9uZyBlYWNoIGF4aXMuXG4gICAqIEBwYXJhbSBkaWxhdGlvbnMgRGlsYXRpb24gYWxvbmcgZWFjaCBheGlzLlxuICAgKiBAcGFyYW0ga2VybmVsU2hhcGUgVGhlIHNpemUgb2YgdGhlIGtlcm5lbCBhbG9uZyBlYWNoIGF4aXMuXG4gICAqIEBwYXJhbSBwYWRzIFBhZGRpbmcgZm9yIHRoZSBiZWdpbm5pbmcgYW5kIGVuZGluZyBhbG9uZyBlYWNoIGF4aXMuXG4gICAqIEBwYXJhbSBhdXRvUGFkIERFUFJFQ0FURUQgYXR0cmlidXRlIHN1cHBvcnRlZCBmb3IgbGVnYWN5IG1vZGVscy4gU3BlY2lmaWVzIGhvdyB0byBpbXBsaWNpdGx5IGNhbGN1bGF0ZSBwYWRzIGluIGVhY2hcbiAgICogICAgIGRpbWVuc2lvbi4gQ2FuIHRha2UgdmFsdWVzIE5PVFNFVCwgU0FNRV9VUFBFUiwgU0FNRV9MT1dFUiwgb3IgVkFMSUQuXG4gICAqL1xuICBzdGF0aWMgY29tcHV0ZVBvb2xPdXRwdXRTaGFwZShcbiAgICAgIGlzR2xvYmFsT3BlcmF0b3I6IGJvb2xlYW4sIGlucHV0RGltczogcmVhZG9ubHkgbnVtYmVyW10sIHN0cmlkZXM6IG51bWJlcltdLCBkaWxhdGlvbnM6IG51bWJlcltdLFxuICAgICAga2VybmVsU2hhcGU6IG51bWJlcltdLCBwYWRzOiBudW1iZXJbXSwgYXV0b1BhZD86IHN0cmluZyk6IG51bWJlcltdIHtcbiAgICBpZiAoaW5wdXREaW1zLmxlbmd0aCA8PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2lucHV0IHNoYXBlIG11c3QgYmUgb2Ygc2l6ZSBncmVhdGVyIHRoYW4gMCcpO1xuICAgIH1cblxuICAgIC8vIEFkZCBiYXRjaCBzaXplIGFuZCBudW1iZXIgb2YgY2hhbm5lbHMgb2Ygb3V0cHV0XG4gICAgY29uc3Qgb3V0cHV0RGltcyA9IFtpbnB1dERpbXNbMF0sIGlucHV0RGltc1sxXV07XG5cbiAgICBQb29sQ29udlV0aWwuY29tcHV0ZVNoYXBlSGVscGVyKFxuICAgICAgICBpc0dsb2JhbE9wZXJhdG9yLCBpbnB1dERpbXMsIG91dHB1dERpbXMsIHN0cmlkZXMsIGRpbGF0aW9ucywga2VybmVsU2hhcGUsIHBhZHMsIGF1dG9QYWQpO1xuICAgIHJldHVybiBvdXRwdXREaW1zO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSB0aGUgb3V0cHV0IHNoYXBlIGZvciBDb252IG9wIGJhc2VkIG9uIGlucHV0IGF0dHJpYnV0ZXMuIChTaG91bGQgYmUgdXNlZCBvbmx5IGZvciBDb252IG9wKVxuICAgKiBAcGFyYW0gaW5wdXREaW1zIFRoZSBpbnB1dCB0ZW5zb3IgZGltZW5zaW9uLiAoaW5wdXRzWzBdLmRpbXMpXG4gICAqIEBwYXJhbSBmaWx0ZXJEaW1zIFRoZSBmaWx0ZXIgdGVuc29yIGRpbWVuc2lvbi4gKGlucHV0c1sxXS5kaW1zKVxuICAgKiBAcGFyYW0gc3RyaWRlcyBTdHJpZGUgYWxvbmcgZWFjaCBheGlzLlxuICAgKiBAcGFyYW0ga2VybmVsU2hhcGUgVGhlIHNpemUgb2YgdGhlIGtlcm5lbCBhbG9uZyBlYWNoIGF4aXMuXG4gICAqIEBwYXJhbSBwYWRzIFBhZGRpbmcgZm9yIHRoZSBiZWdpbm5pbmcgYW5kIGVuZGluZyBhbG9uZyBlYWNoIGF4aXMuXG4gICAqIEBwYXJhbSBhdXRvUGFkIERFUFJFQ0FURUQgYXR0cmlidXRlIHN1cHBvcnRlZCBmb3IgbGVnYWN5IG1vZGVscy4gU3BlY2lmaWVzIGhvdyB0byBpbXBsaWNpdGx5IGNhbGN1bGF0ZSBwYWRzIGluIGVhY2hcbiAgICogICAgIGRpbWVuc2lvbi4gQ2FuIHRha2UgdmFsdWVzIE5PVFNFVCwgU0FNRV9VUFBFUiwgU0FNRV9MT1dFUiwgb3IgVkFMSUQuXG4gICAqL1xuICBzdGF0aWMgY29tcHV0ZUNvbnZPdXRwdXRTaGFwZShcbiAgICAgIGlucHV0RGltczogcmVhZG9ubHkgbnVtYmVyW10sIGZpbHRlckRpbXM6IHJlYWRvbmx5IG51bWJlcltdLCBzdHJpZGVzOiBudW1iZXJbXSwgZGlsYXRpb25zOiBudW1iZXJbXSxcbiAgICAgIGtlcm5lbFNoYXBlOiBudW1iZXJbXSwgcGFkczogbnVtYmVyW10sIGF1dG9QYWQ/OiBzdHJpbmcpOiBudW1iZXJbXSB7XG4gICAgaWYgKGlucHV0RGltcy5sZW5ndGggPD0gMCB8fCBmaWx0ZXJEaW1zLmxlbmd0aCA8PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgaW5wdXQgdGVuc29yIGRpbXMgb3IgaW52YWxpZCBmaWx0ZXIgdGVuc29yIGRpbXMnKTtcbiAgICB9XG5cbiAgICAvLyBBZGQgYmF0Y2ggc2l6ZSBhbmQgbnVtYmVyIG9mIGNoYW5uZWxzIG9mIG91dHB1dFxuICAgIGNvbnN0IG91dHB1dERpbXMgPSBbaW5wdXREaW1zWzBdLCBmaWx0ZXJEaW1zWzBdXTtcblxuICAgIFBvb2xDb252VXRpbC5jb21wdXRlU2hhcGVIZWxwZXIoZmFsc2UsIGlucHV0RGltcywgb3V0cHV0RGltcywgc3RyaWRlcywgZGlsYXRpb25zLCBrZXJuZWxTaGFwZSwgcGFkcywgYXV0b1BhZCk7XG4gICAgcmV0dXJuIG91dHB1dERpbXM7XG4gIH1cblxuICAvLyB3aWxsIGNvbXB1dGUgb3V0cHV0IHNoYXBlcyBmb3IgZGF0YSBkaW1lbnNpb25zIE9OTFkgKGkuZS4pIG5vIGJhdGNoIHNpemUgYW5kIGNoYW5uZWxzXG4gIC8vIGNhbGxlZCBieSBjb21wdXRlUG9vbE91dHB1dFNoYXBlKCkgYW5kIGNvbXB1dGVDb252T3V0cHV0U2hhcGUoKVxuICAvLyBhZGp1c3QgcGFkcyBiYXNlZCBvbiAnYXV0b1BhZCcgYXR0cmlidXRlIHByaW9yIHRvIHNoYXBlIGNvbXB1dGF0aW9uXG4gIHByaXZhdGUgc3RhdGljIGNvbXB1dGVTaGFwZUhlbHBlcihcbiAgICAgIGlzR2xvYmFsT3BlcmF0b3I6IGJvb2xlYW4sIGlucHV0RGltczogcmVhZG9ubHkgbnVtYmVyW10sIG91dHB1dERpbXM6IG51bWJlcltdLCBzdHJpZGVzOiByZWFkb25seSBudW1iZXJbXSxcbiAgICAgIGRpbGF0aW9uczogcmVhZG9ubHkgbnVtYmVyW10sIGtlcm5lbFNoYXBlOiByZWFkb25seSBudW1iZXJbXSwgcGFkczogbnVtYmVyW10sIGF1dG9QYWQ/OiBzdHJpbmcpIHtcbiAgICBpZiAoaXNHbG9iYWxPcGVyYXRvcikge1xuICAgICAgZm9yIChsZXQgZGltID0gMDsgZGltIDwgaW5wdXREaW1zLmxlbmd0aCAtIDI7IGRpbSsrKSB7XG4gICAgICAgIG91dHB1dERpbXMucHVzaCgxKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChsZXQgZGltID0gMDsgZGltIDwgaW5wdXREaW1zLmxlbmd0aCAtIDI7IGRpbSsrKSB7XG4gICAgICAgIG91dHB1dERpbXMucHVzaChQb29sQ29udlV0aWwuYWRqdXN0UGFkQW5kUmV0dXJuU2hhcGUoXG4gICAgICAgICAgICBpbnB1dERpbXNbZGltICsgMl0sIHN0cmlkZXNbZGltXSwgZGlsYXRpb25zW2RpbV0sIGtlcm5lbFNoYXBlW2RpbV0sIHBhZHMsIGRpbSwgZGltICsgaW5wdXREaW1zLmxlbmd0aCAtIDIsXG4gICAgICAgICAgICBhdXRvUGFkKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gaGVscGVyIGZvciBjb21wdXRlU2hhcGVIZWxwZXIoKSBhbmQgYWRqdXN0UGFkc0Jhc2VkT25BdXRvUGFkKClcbiAgLy8gYWRqdXN0cyBwYWQgdmFsdWUgZm9yIGdpdmVuICdhdXRvUGFkJyBzdHJpbmcgYW5kIGNvbXB1dGVzIG91dHB1dCBzaGFwZSBhbG9uZyBhIHBhcnRpY3VsYXIgZGltZW5zaW9uXG4gIHByaXZhdGUgc3RhdGljIGFkanVzdFBhZEFuZFJldHVyblNoYXBlKFxuICAgICAgaW5TaXplOiBudW1iZXIsIHN0cmlkZTogbnVtYmVyLCBkaWxhdGlvbjogbnVtYmVyLCBrZXJuZWw6IG51bWJlciwgcGFkczogbnVtYmVyW10sIHBhZEhlYWRJbmRleDogbnVtYmVyLFxuICAgICAgcGFkVGFpbEluZGV4OiBudW1iZXIsIGF1dG9QYWQ/OiBzdHJpbmcpOiBudW1iZXIge1xuICAgIGNvbnN0IGRrZXJuZWwgPSBkaWxhdGlvbiAqIChrZXJuZWwgLSAxKSArIDE7XG4gICAgaWYgKGF1dG9QYWQgJiYgYXV0b1BhZCAhPT0gJ05PVFNFVCcpIHtcbiAgICAgIHN3aXRjaCAoYXV0b1BhZCkge1xuICAgICAgICBjYXNlICdWQUxJRCc6XG4gICAgICAgICAgcGFkc1twYWRIZWFkSW5kZXhdID0gMDtcbiAgICAgICAgICBwYWRzW3BhZFRhaWxJbmRleF0gPSAwO1xuICAgICAgICAgIHJldHVybiBNYXRoLmZsb29yKCgoaW5TaXplIC0gZGtlcm5lbCkgLyBzdHJpZGUpICsgMSk7XG4gICAgICAgIGNhc2UgJ1NBTUVfTE9XRVInOlxuICAgICAgICBjYXNlICdTQU1FX1VQUEVSJzpcbiAgICAgICAgICBpZiAoZGlsYXRpb24gIT09IDEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRGlsYXRpb24gbm90IHN1cHBvcnRlZCBmb3IgU0FNRV9VUFBFUiBvciBTQU1FX0xPV0VSJyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGxlZ2FjeVRhcmdldFNpemUgPSAoaW5TaXplICsgc3RyaWRlIC0gMSkgLyBzdHJpZGU7XG4gICAgICAgICAgICBjb25zdCBwYWROZWVkZWQgPSAobGVnYWN5VGFyZ2V0U2l6ZSAtIDEpICogc3RyaWRlICsga2VybmVsIC0gaW5TaXplO1xuICAgICAgICAgICAgcGFkc1twYWRIZWFkSW5kZXhdID1cbiAgICAgICAgICAgICAgICAoYXV0b1BhZCA9PT0gJ1NBTUVfTE9XRVInKSA/IE1hdGguZmxvb3IoKHBhZE5lZWRlZCArIDEpIC8gMikgOiBNYXRoLmZsb29yKHBhZE5lZWRlZCAvIDIpO1xuICAgICAgICAgICAgcGFkc1twYWRUYWlsSW5kZXhdID0gcGFkTmVlZGVkIC0gcGFkc1twYWRIZWFkSW5kZXhdO1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IoKChpblNpemUgKyBwYWROZWVkZWQgLSBrZXJuZWwpIC8gc3RyaWRlKSArIDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIEF1dG9QYWQgdHlwZScpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gTWF0aC5mbG9vcigoKGluU2l6ZSArIHBhZHNbcGFkSGVhZEluZGV4XSArIHBhZHNbcGFkVGFpbEluZGV4XSAtIGRrZXJuZWwpIC8gc3RyaWRlKSArIDEpO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgR2VtbVV0aWwge1xuICAvLyB3aWxsIG1ha2Ugc3VyZSBpbnB1dCBzaGFwZXMgYXJlIGNvbXBhdGlibGUgZm9yIHRoaXMgb3BcbiAgLy8gYW5kIHJldHVybiBiYWNrIHRoZSBzaGFwZSBvZiB0aGUgb3V0cHV0IGluIHRoZSBmb3JtIG9mIGEgdHVwbGVcbiAgLy8gd2lsbCB0aHJvdyBleGNlcHRpb24gaWYgdGhlIGlucHV0IHNoYXBlcyBhcmUgbm90IGNvbXBhdGlibGVcbiAgc3RhdGljIGdldFNoYXBlT2ZHZW1tUmVzdWx0KFxuICAgICAgbGVmdFNoYXBlOiByZWFkb25seSBudW1iZXJbXSwgdHJhbnNMZWZ0OiBib29sZWFuLCByaWdodFNoYXBlOiByZWFkb25seSBudW1iZXJbXSwgdHJhbnNSaWdodDogYm9vbGVhbixcbiAgICAgIGJpYXNTaGFwZT86IHJlYWRvbmx5IG51bWJlcltdKTogcmVhZG9ubHkgbnVtYmVyW10ge1xuICAgIGlmIChsZWZ0U2hhcGUubGVuZ3RoICE9PSAyIHx8IHJpZ2h0U2hhcGUubGVuZ3RoICE9PSAyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NoYXBlIG5lZWQgdG8gYmUgb2Ygc2l6ZSAyJyk7XG4gICAgfVxuXG4gICAgbGV0IE06IG51bWJlcjtcbiAgICBsZXQgSzogbnVtYmVyO1xuICAgIGxldCBOOiBudW1iZXI7XG5cbiAgICBpZiAodHJhbnNMZWZ0KSB7XG4gICAgICBNID0gbGVmdFNoYXBlWzFdO1xuICAgICAgSyA9IGxlZnRTaGFwZVswXTtcbiAgICB9IGVsc2Uge1xuICAgICAgTSA9IGxlZnRTaGFwZVswXTtcbiAgICAgIEsgPSBsZWZ0U2hhcGVbMV07XG4gICAgfVxuXG4gICAgbGV0IGtEaW0gPSAtMTtcblxuICAgIGlmICh0cmFuc1JpZ2h0KSB7XG4gICAgICBOID0gcmlnaHRTaGFwZVswXTtcbiAgICAgIGtEaW0gPSAxO1xuICAgIH0gZWxzZSB7XG4gICAgICBOID0gcmlnaHRTaGFwZVsxXTtcbiAgICAgIGtEaW0gPSAwO1xuICAgIH1cblxuICAgIGlmIChyaWdodFNoYXBlW2tEaW1dICE9PSBLKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2RpbWVuc2lvbiBtaXNtYXRjaCcpO1xuICAgIH1cblxuICAgIGlmIChNIDw9IDAgfHwgTiA8PSAwIHx8IEsgPD0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHNoYXBlIHNwZWNpZmllZCcpO1xuICAgIH1cblxuICAgIGlmIChiaWFzU2hhcGUgJiYgIUJyb2FkY2FzdFV0aWwuaXNWYWxpZEJyb2FkY2FzdChiaWFzU2hhcGUsIFtNLCBOXSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignZ2VtbTogaW52YWxpZCBiaWFzIHNoYXBlIGZvciBicm9hZGNhc3QnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gW00sIE4sIEtdO1xuICB9XG59XG5cblxuZXhwb3J0IGNvbnN0IE1JTl9DTElQID0gLTMuNDAyODIzNDY2Mzg1Mjg4NmUrMzg7XG5leHBvcnQgY29uc3QgTUFYX0NMSVAgPSAzLjQwMjgyMzQ2NjM4NTI4ODZlKzM4O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge0RhdGFUeXBlfSBmcm9tICcuLi8uLi8uLi93YXNtLWNvbW1vbic7XG5pbXBvcnQge1NoYXBlVXRpbH0gZnJvbSAnLi4vLi4vdXRpbCc7XG5pbXBvcnQge1Byb2dyYW1Vbmlmb3JtfSBmcm9tICcuLi90eXBlcyc7XG5cbi8qKlxuICogY29uc3RhbnQgdmFsdWUgZm9yIGEgd29ya2dyb3VwIHNpemUuXG4gKlxuICogV2UgZGVmaW5pdGVseSBjYW4gZG8gZnVydGhlciBvcHRpbWl6YXRpb24gaW4gZnV0dXJlLCBidXQgZm9yIG5vdyB3ZSB1c2UgNjQuXG4gKlxuICogcnVsZSBvZiB0aHVtYjogVXNlIFthIHdvcmtncm91cCBzaXplIG9mXSA2NCB1bmxlc3MgeW91IGtub3cgd2hhdCBHUFUgeW91IGFyZSB0YXJnZXRpbmcgb3IgdGhhdCB5b3VyIHdvcmtsb2FkXG4gKiAgICAgICAgICAgICAgICBuZWVkcyBzb21ldGhpbmcgZGlmZmVyZW50LlxuICpcbiAqIGZyb206IGh0dHBzOi8vc3VybWEuZGV2L3RoaW5ncy93ZWJncHUvXG4gKiovXG5leHBvcnQgY29uc3QgV09SS0dST1VQX1NJWkUgPSA2NDtcblxuaW50ZXJmYWNlIEluZGljZXNIZWxwZXJUeXBlcyB7XG4gIC8qKlxuICAgKiBXR1NMIHR5cGUgb2YgaW5kaWNlcyBleHByZXNzaW9uXG4gICAqL1xuICByZWFkb25seSBpbmRpY2VzOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFdHU0wgdHlwZSBvZiBhIHZhbHVlXG4gICAqL1xuICByZWFkb25seSB2YWx1ZTogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBXR1NMIHR5cGUgb2Ygc3RvcmFnZSB0eXBlIHJlcHJlc2VudGluZyBhIHZhbHVlXG4gICAqXG4gICAqIFRoaXMgaXMgdXN1YWxseSB0aGUgc2FtZSB0byBgdmFsdWVgLCBidXQgZm9yIHNvbWUgdHlwZSAoZWcuIGJvb2wpLCB3ZSBuZWVkIHRvIHVzZSBgdTMyYCBhcyBzdG9yYWdlIHR5cGUgZm9yXG4gICAqIHZhbHVlIHR5cGUgYHZlYzQ8Ym9vbD5gXG4gICAqL1xuICByZWFkb25seSBzdG9yYWdlOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIHRlbnNvciB0eXBlIGFzIHJlcHJlc2VudGVkIGluIFRlbnNvclZpZXdcbiAgICovXG4gIHJlYWRvbmx5IHRlbnNvcjogbnVtYmVyO1xufVxuXG4vKipcbiAqIEEgaGVscGVyIGNsYXNzIGZvciBnZW5lcmF0aW5nIFdHU0wgY29kZSBmb3IgbWFuaXB1bGF0aW5nIGluZGljZXMgYW5kIGRhdGEgZm9yIGEgc2hhZGVyJ3MgaW5wdXQgb3Igb3V0cHV0LlxuICpcbiAqIFRoaXMgY2xhc3MgaXMgZGVzaWduZWQgdG8gb2ZmZXIgYSB1bmlmaWVkIHdheSB0byBnZW5lcmF0ZSBXR1NMIGNvZGUgZm9yIG1hbmlwdWxhdGluZyBpbmRpY2VzIGFuZCBkYXRhIGZvciBhIHNoYWRlcidzXG4gKiBpbnB1dCBvciBvdXRwdXQuXG4gKlxuICogVGhlIGZvbGxvd2luZyBpcyBhIGxpc3Qgb2YgdGVybWlub2xvZ2llcyB1c2VkIGluIHRoaXMgY2xhc3M6XG4gKiAtIGBvZmZzZXRgOiBhIHVpbnQzMiB2YWx1ZSByZXByZXNlbnRpbmcgdGhlIG9mZnNldCBvZiBhbiBlbGVtZW50IGluIHRoZSBkYXRhIGJ1ZmZlci5cbiAqIC0gYGluZGljZXNgOiBhbiBhYnN0cmFjdGlvbiBvZiBhIG11bHRpLWRpbWVuc2lvbmFsIGFycmF5J3MgaW5kaWNlcyByZXByZXNlbnRpbmcgdGhlIGRhdGEncyBpbmRleCBvbiBlYWNoIGRpbWVuc2lvbi5cbiAqIC0gYHZhbHVlYDogYSB2YWx1ZSBvZiBhIGRhdGEgZWxlbWVudC5cbiAqXG4gKiBVc2VycyBhcmUgZXhwZWN0ZWQgdG8gY3JlYXRlIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MgZm9yIGVhY2ggc2hhZGVyJ3MgaW5wdXQgb3Igb3V0cHV0LCBhbmQgdXNlIHRoZSBpbnN0YW5jZSB0b1xuICogZ2VuZXJhdGUgV0dTTCBjb2RlIGZvciBtYW5pcHVsYXRpbmcgaW5kaWNlcyBhbmQgZGF0YS4gVGhlIGZvbGxvd2luZyAyIGV4cG9ydGVkIGZ1bmN0aW9ucyBhcmUgZm9yIHVzZXJzIHRvIGNhbGwgdG9cbiAqIGNyZWF0ZSBhbiBpbnN0YW5jZSBvZiBhbiBpbmRpY2VzIGhlbHBlcjpcbiAqIC0gYGlucHV0VmFyaWFibGUoKWA6IGNyZWF0ZSBhbiBpbmRpY2VzIGhlbHBlciBpbnN0YW5jZSBmb3IgYW4gaW5wdXQuXG4gKiAtIGBvdXRwdXRWYXJpYWJsZSgpYDogY3JlYXRlIGFuIGluZGljZXMgaGVscGVyIGluc3RhbmNlIGZvciBhbiBvdXRwdXQuXG4gKiAtIGBpbnRlcm5hbFZhcmlhYmxlKClgOiBjcmVhdGUgYW4gaW5kaWNlcyBoZWxwZXIgaW5zdGFuY2UgZm9yIGFuIGludGVybmFsIHZhcmlhYmxlLlxuICpcbiAqIEFuIGluZGljZXMgaGVscGVyIGluc3RhbmNlIGNvbnRhaW5zIGhlbHBlciBmdW5jdGlvbnMgZm9yIHRoZSBmb2xsb3dpbmcgb3BlcmF0aW9uczpcbiAqIC0gYWNjZXNzIHJlYWRvbmx5IGJhc2ljIGluZm9ybWF0aW9uLCBpbmNsdWRpbmc6IGBuYW1lYCh0aGUgbmFtZSBvZiB0aGUgaW5wdXQgb3Igb3V0cHV0KSwgYHVzYWdlYCh3aGV0aGVyIGl0J3MgYW5cbiAqIGlucHV0LCBhbiBvdXRwdXQgb3IgYW4gaW50ZXJuYWwgdmFyaWFibGUpIGFuZCBgc2hhcGVgKHRoZSBwYXNzZWQgaW4gc2hhcGUpLlxuICogLSBgdHlwZWA6IGFjY2VzcyByZWFkb25seSB0eXBlIGluZm9ybWF0aW9uLCBpbmNsdWRpbmc6IGBpbmRpY2VzYCh0aGUgdHlwZSBvZiBpbmRpY2VzKSwgYHZhbHVlYCh0aGUgdHlwZSBvZiB2YWx1ZSBhdFxuICogcnVudGltZSksIGBzdG9yYWdlYCh0aGUgdHlwZSBvZiB2YWx1ZSBhdCBzdG9yYWdlKSBhbmQgYHRlbnNvcmAodGhlIHRlbnNvciB0eXBlIGFzIHJlcHJlc2VudGVkIGluIFRlbnNvclZpZXcpLlxuICogLSBnZW5lcmF0ZSBXR1NMIGNvZGUgZm9yIGdldHRpbmcgaW5kaWNlcyBmcm9tIG9mZnNldC4gVXNlIGBvZmZzZXRUb0luZGljZXMoKWAgZm9yIFdHU0wgY29kZSBzbmlwcGV0IHRvIGNhbGN1bGF0ZVxuICogaW5kaWNlcyBmcm9tIG9mZnNldCwgYW5kIHVzZSBgaW5kaWNlc1RvT2Zmc2V0KClgIGZvciBXR1NMIGNvZGUgc25pcHBldCB0byBjYWxjdWxhdGUgb2Zmc2V0IGZyb20gaW5kaWNlcy5cbiAqIC0gdG8gbWFuaXB1bGF0ZSBhbiBpbnN0YW5jZSBvZiBpbmRpY2VzLCB1c2UgYHNldEluZGljZXMoKWAgYW5kIGBnZXRJbmRpY2VzKClgIHRvIHNldCBhbmQgZ2V0IHRoZSBpbmRpY2VzIG9uIGFuXG4gKiBpbmRpY2VzIHZhcmlhYmxlLlxuICogLSB0byBtYW5pcHVsYXRlIGRhdGEsIHVzZSBgc2V0KClgL2BnZXQoKWAgdG8gYWNjZXNzIGRhdGEgYXQgdGhlIGdpdmVuIGluZGljZXMgZnJvbSBwYXJhbWV0ZXIgbGlzdCwgdXNlXG4gKiBgc2V0QnlJbmRpY2VzKClgL2BnZXRCeUluZGljZXMoKWAgdG8gYWNjZXNzIGRhdGEgYXQgdGhlIGdpdmVuIGluZGljZXMgZnJvbSBhbiBpbmRpY2VzIHZhcmlhYmxlLCBhbmQgdXNlXG4gKiBgc2V0QnlPZmZzZXQoKWAvYGdldEJ5T2Zmc2V0KClgIHRvIGFjY2VzcyBkYXRhIGF0IHRoZSBnaXZlbiBvZmZzZXQuXG4gKiAtIGBpbXBsYDogZ2V0IFdHU0wgY29kZSBvZiBmdW5jdGlvbiBpbXBsZW1lbnRhdGlvbiBmb3IgdGhlIHV0aWwgZnVuY3Rpb25zIG1lbnRpb25lZCBhYm92ZS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBJbmRpY2VzSGVscGVyIHtcbiAgLyoqXG4gICAqIGdldCBXR1NMIGNvZGUgb2YgZnVuY3Rpb24gaW1wbGVtZW50YXRpb24gZm9yIHRoZSB1dGlsIGZ1bmN0aW9ucy5cbiAgICpcbiAgICovXG4gIHJlYWRvbmx5IGltcGw6ICgpID0+IHN0cmluZztcblxuICAvKipcbiAgICogZ2V0IHR5cGUgaW5mb1xuICAgKi9cbiAgcmVhZG9ubHkgdHlwZTogSW5kaWNlc0hlbHBlclR5cGVzO1xuXG4gIC8qKlxuICAgKiBXR1NMIGNvZGUgb2YgYSBleHByZXNzaW9uIGZvciBnZXR0aW5nIGluZGljZXMgZnJvbSBvZmZzZXQuXG4gICAqXG4gICAqIEBwYXJhbSB2YXJPZmZzZXQgLSBhIHUzMiBleHByZXNzaW9uIHJlcHJlc2VudGluZyB0aGUgb2Zmc2V0LlxuICAgKlxuICAgKiBAcmV0dXJucyBhbiBgdHlwZS5pbmRpY2VzYCBleHByZXNzaW9uXG4gICAqL1xuICByZWFkb25seSBvZmZzZXRUb0luZGljZXM6ICh2YXJPZmZzZXQ6IHN0cmluZykgPT4gc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBXR1NMIGNvZGUgb2YgYW4gYHUzMmAgZXhwcmVzc2lvbiBmb3IgZ2V0dGluZyBvZmZzZXQgZnJvbSBpbmRpY2VzLlxuICAgKlxuICAgKiBAcGFyYW0gdmFySW5kaWNlcyAtIGEgYHR5cGUuaW5kaWNlc2AgZXhwcmVzc2lvbiByZXByZXNlbnRpbmcgdGhlIGluZGljZXMuXG4gICAqXG4gICAqIEByZXR1cm5zIGFuIGB1MzJgIGV4cHJlc3Npb25cbiAgICovXG4gIHJlYWRvbmx5IGluZGljZXNUb09mZnNldDogKHZhckluZGljZXM6IHN0cmluZykgPT4gc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBXR1NMIGNvZGUgb2YgYW4gYHUzMmAgZXhwcmVzc2lvbiBmb3IgZ2V0dGluZyBvcmlnaW5hbCBvZmZzZXQgZnJvbSBicm9hZGNhc3RlZCBpbmRpY2VzLlxuICAgKlxuICAgKiBAcGFyYW0gdmFySW5kaWNlcyAtIGEgYHR5cGUuaW5kaWNlc2AgZXhwcmVzc2lvbiByZXByZXNlbnRpbmcgdGhlIG91dHB1dCBpbmRpY2VzLlxuICAgKiBAcGFyYW0gb3V0cHV0IC0gb3V0cHV0IEluZGljZXNIZWxwZXIuXG4gICAqXG4gICAqIEByZXR1cm5zIGFuIGB1MzJgIGV4cHJlc3Npb25cbiAgICovXG4gIHJlYWRvbmx5IGJyb2FkY2FzdGVkSW5kaWNlc1RvT2Zmc2V0OiAodmFySW5kaWNlczogc3RyaW5nLCBvdXRwdXQ6IEluZGljZXNIZWxwZXIpID0+IHN0cmluZztcblxuICAvKipcbiAgICogV0dTTCBjb2RlIG9mIGdlbmVyYXRpbmcgYW4gaW5kaWNlcyBsaXRlcmFsXG4gICAqXG4gICAqIEBwYXJhbSBpbml0IC0gaW5pdGlhbCB2YWx1ZS5cbiAgICovXG4gIHJlYWRvbmx5IGluZGljZXM6ICguLi5pbml0OiBSZWFkb25seUFycmF5PG51bWJlcnxzdHJpbmc+KSA9PiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFdHU0wgY29kZSBvZiBhIHN0YXRlbWVudCBmb3Igc2V0dGluZyBpbmRpY2VzLlxuICAgKlxuICAgKiBAcGFyYW0gdmFySW5kaWNlcyAtIGEgdmFyaWFibGUgbmFtZSBmb3IgdGhlIGluZGljZXMuXG4gICAqIEBwYXJhbSBpZHggLSB0aGUgaW5kZXggb2YgdGhlIGluZGljZXMgdG8gc2V0LiBjYW4gYmUgYSBudW1iZXIgb3IgYSBzdHJpbmcgKFdHU0wgYHUzMmAgZXhwcmVzc2lvbikuXG4gICAqIEBwYXJhbSB2YWx1ZSAtIHRoZSB2YWx1ZSB0byBzZXQuIGNhbiBiZSBhIG51bWJlciBvciBhIHN0cmluZyAoV0dTTCBgdTMyYCBleHByZXNzaW9uKS5cbiAgICpcbiAgICogQHJldHVybnMgYSBXR1NMIHN0YXRlbWVudFxuICAgKi9cbiAgcmVhZG9ubHkgaW5kaWNlc1NldDogKHZhckluZGljZXM6IHN0cmluZywgaWR4OiBudW1iZXJ8c3RyaW5nLCB2YWx1ZTogbnVtYmVyfHN0cmluZykgPT4gdm9pZDtcblxuICAvKipcbiAgICogV0dTTCBjb2RlIG9mIGFuIGB1MzJgIGV4cHJlc3Npb24gZm9yIGdldHRpbmcgaW5kaWNlcy5cbiAgICpcbiAgICogQHBhcmFtIHZhckluZGljZXMgLSBhIHZhcmlhYmxlIG5hbWUgZm9yIHRoZSBpbmRpY2VzLlxuICAgKiBAcGFyYW0gaWR4IC0gdGhlIGluZGV4IG9mIHRoZSBpbmRpY2VzIHRvIGdldC4gY2FuIGJlIGEgbnVtYmVyIG9yIGEgc3RyaW5nIChXR1NMIGB1MzJgIGV4cHJlc3Npb24pLlxuICAgKlxuICAgKiBAcmV0dXJucyBhbiBgdTMyYCBleHByZXNzaW9uXG4gICAqL1xuICByZWFkb25seSBpbmRpY2VzR2V0OiAodmFySW5kaWNlczogc3RyaW5nLCBpZHg6IG51bWJlcnxzdHJpbmcpID0+IHN0cmluZztcblxuICAvKipcbiAgICogV0dTTCBjb2RlIGZvciBhIHN0YXRlbWVudCBmb3Igc2V0dGluZyBkYXRhIGF0IHRoZSBnaXZlbiBpbmRpY2VzLlxuICAgKlxuICAgKiBAcGFyYW0gaW5kaWNlc0FuZFZhbHVlIC0gYW4gYXJyYXkgb2YgbnVtYmVycyBvciBzdHJpbmdzIChXR1NMIGB1MzJgIGV4cHJlc3Npb24pIHJlcHJlc2VudGluZyB0aGUgaW5kaWNlcywgZm9sbG93ZWRcbiAgICogICAgIGJ5IHRoZSB2YWx1ZSB0byBzZXQuIFRoaXMgYXJyYXkgc2hvdWxkIGhhdmUgZXhhY3RseSBgc2hhcGUubGVuZ3RoICsgMWAgZWxlbWVudHMuXG4gICAqL1xuICByZWFkb25seSBzZXQ6ICguLi5pbmRpY2VzQW5kVmFsdWU6IFJlYWRvbmx5QXJyYXk8bnVtYmVyfHN0cmluZz4pID0+IHN0cmluZztcblxuICAvKipcbiAgICogV0dTTCBjb2RlIGZvciBhIHN0YXRlbWVudCBmb3Igc2V0dGluZyBkYXRhIGF0IHRoZSBnaXZlbiBpbmRpY2VzIHZhcmlhYmxlLlxuICAgKlxuICAgKiBAcGFyYW0gdmFySW5kaWNlcyAtIGEgdmFyaWFibGUgbmFtZSBmb3IgdGhlIGluZGljZXMuXG4gICAqIEBwYXJhbSB2YWx1ZSAtIHRoZSB2YWx1ZSB0byBzZXQuIHNob3VsZCBiZSBhIFdHU0wgZXhwcmVzc2lvbi5cbiAgICovXG4gIHJlYWRvbmx5IHNldEJ5SW5kaWNlczogKHZhckluZGljZXM6IHN0cmluZywgdmFsdWU6IHN0cmluZykgPT4gc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBXR1NMIGNvZGUgZm9yIGEgc3RhdGVtZW50IGZvciBzZXR0aW5nIGRhdGEgYXQgdGhlIGdpdmVuIG9mZnNldC5cbiAgICpcbiAgICogQHBhcmFtIG9mZnNldCAtIGEgbnVtYmVyIG9yIGEgc3RyaW5nIChXR1NMIGB1MzJgIGV4cHJlc3Npb24pIHJlcHJlc2VudGluZyB0aGUgb2Zmc2V0LlxuICAgKiBAcGFyYW0gdmFsdWUgLSB0aGUgdmFsdWUgdG8gc2V0LiBzaG91bGQgYmUgYSBXR1NMIGV4cHJlc3Npb24uXG4gICAqL1xuICByZWFkb25seSBzZXRCeU9mZnNldDogKG9mZnNldDogbnVtYmVyfHN0cmluZywgdmFsdWU6IHN0cmluZykgPT4gc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBXR1NMIGNvZGUgZm9yIGFuIGV4cHJlc3Npb24gZm9yIGdldHRpbmcgZGF0YSBhdCB0aGUgZ2l2ZW4gaW5kaWNlcy5cbiAgICpcbiAgICogQHBhcmFtIGluZGljZXMgLSBhbiBhcnJheSBvZiBudW1iZXJzIG9yIHN0cmluZ3MgKFdHU0wgYHUzMmAgZXhwcmVzc2lvbikgcmVwcmVzZW50aW5nIHRoZSBpbmRpY2VzLlxuICAgKi9cbiAgcmVhZG9ubHkgZ2V0OiAoLi4uaW5kaWNlczogUmVhZG9ubHlBcnJheTxudW1iZXJ8c3RyaW5nPikgPT4gc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBXR1NMIGNvZGUgZm9yIGFuIGV4cHJlc3Npb24gZm9yIGdldHRpbmcgZGF0YSBhdCB0aGUgZ2l2ZW4gaW5kaWNlcyB2YXJpYWJsZS5cbiAgICpcbiAgICogQHBhcmFtIHZhckluZGljZXMgLSBhIHZhcmlhYmxlIG5hbWUgZm9yIHRoZSBpbmRpY2VzLlxuICAgKi9cbiAgcmVhZG9ubHkgZ2V0QnlJbmRpY2VzOiAodmFySW5kaWNlczogc3RyaW5nKSA9PiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFdHU0wgY29kZSBmb3IgYW4gZXhwcmVzc2lvbiBmb3IgZ2V0dGluZyBkYXRhIGF0IHRoZSBnaXZlbiBvZmZzZXQuXG4gICAqXG4gICAqIEBwYXJhbSBvZmZzZXQgLSBhIG51bWJlciBvciBhIHN0cmluZyAoV0dTTCBgdTMyYCBleHByZXNzaW9uKSByZXByZXNlbnRpbmcgdGhlIG9mZnNldC5cbiAgICovXG4gIHJlYWRvbmx5IGdldEJ5T2Zmc2V0OiAob2Zmc2V0OiBudW1iZXJ8c3RyaW5nKSA9PiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIG5hbWUgb2YgdGhlIGRhdGEgdmFyaWFibGVcbiAgICovXG4gIHJlYWRvbmx5IG5hbWU6IHN0cmluZztcblxuICAvKipcbiAgICogd2hldGhlciB0aGUgaGVscGVyIGlzIGZvciBhbiBpbnB1dCwgYW4gb3V0cHV0IG9yIGFuIGludGVybmFsIHZhcmlhYmxlLlxuICAgKi9cbiAgcmVhZG9ubHkgdXNhZ2U6ICdpbnB1dCd8J291dHB1dCd8J2ludGVybmFsJztcblxuICAvKipcbiAgICogdGhlIHJhbmsgb2YgdGhlIGlucHV0IG9yIG91dHB1dC5cbiAgICovXG4gIHJlYWRvbmx5IHJhbms6IG51bWJlcjtcblxuICAvKipcbiAgICogYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSB2YXJpYWJsZSBuYW1lIGZvciB0aGUgc2hhcGUgb2YgdGhlIGlucHV0IG9yIG91dHB1dC5cbiAgICovXG4gIHJlYWRvbmx5IHNoYXBlOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgdmFyaWFibGUgbmFtZSBmb3IgdGhlIHN0cmlkZXMgb2YgdGhlIGlucHV0IG9yIG91dHB1dC5cbiAgICovXG4gIHJlYWRvbmx5IHN0cmlkZXM6IHN0cmluZztcbn1cblxuY29uc3QgZ2V0V2dzbE1hcHBlZFR5cGUgPSAodHlwZTogbnVtYmVyLCBjb21wb25lbnRzOiAxfDJ8M3w0KTogc3RyaW5nfFtzdHJpbmcsIHN0cmluZ10gPT4ge1xuICBpZiAoY29tcG9uZW50cyA9PT0gMykge1xuICAgIHRocm93IG5ldyBFcnJvcigndmVjMyBoYXMgc2FtZSBhbGlnbm1lbnQgYXMgdmVjNCwgdXNlIHZlYzQgaW5zdGVhZCcpO1xuICB9XG5cbiAgLy8gcmV0dXJuIHR5cGUgaXMgWyBzdG9yYWdlIHR5cGUsIHJ1bnRpbWUgdHlwZSBdIG9yIGEgc2luZ2xlIHN0cmluZyBmb3IgYm90aFxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIERhdGFUeXBlLmZsb2F0MTY6XG4gICAgICByZXR1cm4gY29tcG9uZW50cyA+IDEgPyBgdmVjJHtjb21wb25lbnRzfTxmMTY+YCA6ICdmMTYnO1xuICAgIGNhc2UgRGF0YVR5cGUuZmxvYXQ6XG4gICAgICByZXR1cm4gY29tcG9uZW50cyA+IDEgPyBgdmVjJHtjb21wb25lbnRzfTxmMzI+YCA6ICdmMzInO1xuICAgIGNhc2UgRGF0YVR5cGUuaW50MzI6XG4gICAgICByZXR1cm4gY29tcG9uZW50cyA+IDEgPyBgdmVjJHtjb21wb25lbnRzfTxpMzI+YCA6ICdpMzInO1xuICAgIGNhc2UgRGF0YVR5cGUudWludDMyOlxuICAgICAgcmV0dXJuIGNvbXBvbmVudHMgPiAxID8gYHZlYyR7Y29tcG9uZW50c308dTMyPmAgOiAndTMyJztcbiAgICBjYXNlIERhdGFUeXBlLmludDY0OlxuICAgICAgaWYgKGNvbXBvbmVudHMgPiAxKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignY3VycmVudGx5IG5vdCBzdXBwb3J0ZWQgdmVjWCBvZiB1aW50NjQgeWV0Jyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gWyd2ZWMyPHUzMj4nLCAnaTMyJ107XG4gICAgY2FzZSBEYXRhVHlwZS51aW50NjQ6XG4gICAgICBpZiAoY29tcG9uZW50cyA+IDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjdXJyZW50bHkgbm90IHN1cHBvcnRlZCB2ZWNYIG9mIHVpbnQ2NCB5ZXQnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBbJ3ZlYzI8dTMyPicsICd1MzInXTtcbiAgICBjYXNlIERhdGFUeXBlLmJvb2w6XG4gICAgICBpZiAoY29tcG9uZW50cyAhPT0gNCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Jvb2wgbXVzdCBiZSB2ZWM0Jyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gWyd1MzInLCAndmVjNDxib29sPiddO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBkYXRhIHR5cGU6ICR7dHlwZX1gKTtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IHRlbnNvclR5cGVUb1dzZ2xTdG9yYWdlVHlwZSA9ICh0eXBlOiBEYXRhVHlwZSwgY29tcG9uZW50czogMXwyfDN8NCA9IDEpID0+IHtcbiAgY29uc3QgbWFwcGVkVHlwZSA9IGdldFdnc2xNYXBwZWRUeXBlKHR5cGUsIGNvbXBvbmVudHMpO1xuICByZXR1cm4gdHlwZW9mIG1hcHBlZFR5cGUgPT09ICdzdHJpbmcnID8gbWFwcGVkVHlwZSA6IG1hcHBlZFR5cGVbMF07XG59O1xuXG5leHBvcnQgY29uc3QgdGVuc29yVHlwZVRvV3NnbFZhbHVlVHlwZSA9ICh0eXBlOiBEYXRhVHlwZSwgY29tcG9uZW50czogMXwyfDN8NCA9IDEpID0+IHtcbiAgY29uc3QgbWFwcGVkVHlwZSA9IGdldFdnc2xNYXBwZWRUeXBlKHR5cGUsIGNvbXBvbmVudHMpO1xuICByZXR1cm4gdHlwZW9mIG1hcHBlZFR5cGUgPT09ICdzdHJpbmcnID8gbWFwcGVkVHlwZSA6IG1hcHBlZFR5cGVbMV07XG59O1xuXG5leHBvcnQgY29uc3QgY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMgPSAoZGltczogcmVhZG9ubHkgbnVtYmVyW10pOiBQcm9ncmFtVW5pZm9ybVtdID0+XG4gICAgZGltcy5sZW5ndGggPT09IDAgPyBbXSA6IFt7dHlwZTogJ3VpbnQzMicsIGRhdGE6IGRpbXN9LCB7dHlwZTogJ3VpbnQzMicsIGRhdGE6IFNoYXBlVXRpbC5jb21wdXRlU3RyaWRlcyhkaW1zKX1dO1xuXG4vKipcbiAqIEEgaGVscGVyIGZ1bmN0aW9uIHRvIGdldCBtYXhpbXVtIHZlY3RvciBzaXplIGZvciBzcGVjaWZpZWQgZGF0YSBsZW5ndGhcbiAqIEBwYXJhbSBzaXplXG4gKi9cbmV4cG9ydCBjb25zdCBnZXRNYXhDb21wb25lbnRzID0gKHNpemU6IG51bWJlcikgPT4ge1xuICAvLyB3ZSBjYW5ub3QgdXNlIHZlYzMgdHlwZSBzaW5jZSBpdCBoYXMgYWxpZ25tZW50IG9mIDE2IGJ5dGVzXG4gIGlmIChzaXplICUgNCA9PT0gMCkge1xuICAgIHJldHVybiA0O1xuICB9IGVsc2UgaWYgKHNpemUgJSAyID09PSAwKSB7XG4gICAgcmV0dXJuIDI7XG4gIH1cblxuICByZXR1cm4gMTtcbn07XG5cbi8qKlxuICogQSBoZWxwZXIgZnVuY3Rpb24gdGhhdCBpbml0aWFsaXplcyB2YXJpYWJsZSBhcyBhIHNjYWxhciBvciB2ZWN0b3IuIGUuZy4gZjMyKDApIG9yIHZlYzRmKDAsMCwwLDApXG4gKiBAcGFyYW0gZGF0YVR5cGVcbiAqIEBwYXJhbSBjb21wb25lbnRzXG4gKiBAcGFyYW0gdmFsdWVcbiAqL1xuZXhwb3J0IGNvbnN0IGZpbGxWZWN0b3IgPSAoZGF0YVR5cGUgPSAnZjMyJywgY29tcG9uZW50cz86IG51bWJlciwgdmFsdWUgPSAnMCcpID0+IHtcbiAgaWYgKCFjb21wb25lbnRzIHx8IGNvbXBvbmVudHMgPT09IDEpIHtcbiAgICByZXR1cm4gYCR7ZGF0YVR5cGV9KCR7dmFsdWV9KWA7XG4gIH1cblxuICByZXR1cm4gYHZlYyR7Y29tcG9uZW50c308JHtkYXRhVHlwZX0+KCR7dmFsdWV9KWA7XG59O1xuXG4vKipcbiAqIEEgaGVscGVyIGZ1bmN0aW9uIHRoYXQgY2FzdHMgdmFsdWUgb3IgdmVjdG9yIHRvIGYzMlxuICogQHBhcmFtIGRhdGFUeXBlXG4gKiBAcGFyYW0gY29tcG9uZW50c1xuICogQHBhcmFtIHZhbHVlXG4gKi9cbmV4cG9ydCBjb25zdCBjYXN0VG9GMzIgPSAoZGF0YVR5cGU6IHN0cmluZywgY29tcG9uZW50czogbnVtYmVyLCB2YWx1ZTogc3RyaW5nKSA9PiB7XG4gIGlmIChkYXRhVHlwZSA9PT0gJ2YzMicpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaWYgKGNvbXBvbmVudHMgPT09IDEpIHtcbiAgICByZXR1cm4gYGYzMigke3ZhbHVlfSlgO1xuICB9XG5cbiAgcmV0dXJuIGB2ZWMke2NvbXBvbmVudHN9Zigke3ZhbHVlfSlgO1xufTtcblxuLyoqXG4gKiBBIGhlbHBlciBmdW5jdGlvbiB0aGF0IHJldHVybnMgc2NhbGFyIG9yIHN1bXMgYWxsIGNvbXBvbmVudHMgb2YgYSB2ZWN0b3JcbiAqIEBwYXJhbSBuYW1lXG4gKiBAcGFyYW0gY29tcG9uZW50c1xuICovXG5leHBvcnQgY29uc3Qgc3VtVmVjdG9yID0gKG5hbWU6IHN0cmluZywgY29tcG9uZW50czogbnVtYmVyKSA9PiB7XG4gIGlmIChjb21wb25lbnRzID09PSA0KSB7XG4gICAgcmV0dXJuIGAoJHtuYW1lfS54ICsgJHtuYW1lfS55ICsgJHtuYW1lfS56ICsgJHtuYW1lfS53KWA7XG4gIH0gZWxzZSBpZiAoY29tcG9uZW50cyA9PT0gMikge1xuICAgIHJldHVybiBgKCR7bmFtZX0ueCArICR7bmFtZX0ueSlgO1xuICB9IGVsc2UgaWYgKGNvbXBvbmVudHMgPT09IDMpIHtcbiAgICByZXR1cm4gYCgke25hbWV9LnggKyAke25hbWV9LnkgKyAke25hbWV9LnopYDtcbiAgfVxuXG4gIHJldHVybiBuYW1lO1xufTtcblxuLyoqXG4gKiBBIGhlbHBlciBmdW5jdGlvbiB0aGF0IHJldHVybnMgdmFyaWFibGUgZWxlbWVudCBhdCBpbmRleC5cbiAqIEBwYXJhbSBuYW1lIC0gdGhlIG5hbWUgb2YgdmFyaWFibGUuXG4gKiBAcGFyYW0gaW5kZXggLSB0aGUgaW5kZXggb2YgdmFyaWFibGUgZWxlbWVudC5cbiAqIEBwYXJhbSBsZW5ndGggLSB0aGUgbGVuZ3RoIG9mIHZhcmlhYmxlLlxuICovXG5leHBvcnQgY29uc3QgZ2V0RWxlbWVudEF0ID0gKG5hbWU6IHN0cmluZywgaW5kZXg6IG51bWJlcnxzdHJpbmcsIGxlbmd0aDogbnVtYmVyKTogc3RyaW5nID0+IHtcbiAgaWYgKG5hbWUuc3RhcnRzV2l0aCgndW5pZm9ybXMuJykgJiYgbGVuZ3RoID4gNCkge1xuICAgIGlmICh0eXBlb2YgKGluZGV4KSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBgJHtuYW1lfVsoJHtpbmRleH0pIC8gNF1bKCR7aW5kZXh9KSAlIDRdYDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGAke25hbWV9WyR7TWF0aC5mbG9vcihpbmRleCAvIDQpfV1bJHtpbmRleCAlIDR9XWA7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBsZW5ndGggPiAxID8gYCR7bmFtZX1bJHtpbmRleH1dYCA6IG5hbWU7XG4gIH1cbn07XG5cbi8qKlxuICogQSBoZWxwZXIgZnVuY3Rpb24gdG8gZ2V0IGEgSW5kaWNlc0hlbHBlciBmb3IgYSBnaXZlbiBpbnB1dCBvciBvdXRwdXQuXG4gKlxuICogQHBhcmFtIG5hbWUgLSB0aGUgbmFtZSBvZiB0aGUgaW5wdXQgb3Igb3V0cHV0LlxuICogQHBhcmFtIHRlbnNvclR5cGUgLSB0aGUgdGVuc29yIHR5cGUgb2YgdGhlIGlucHV0IG9yIG91dHB1dC5cbiAqIEBwYXJhbSBzaGFwZU9yUmFuayAtIHRoZSB0ZW5zb3Igc2hhcGUgb3IgdGhlIHJhbmsgb2YgdGhlIGlucHV0IG9yIG91dHB1dC5cbiAqIEBwYXJhbSB1c2FnZSAtIHRoZSB1c2FnZSBvZiB0aGUgaW5kaWNlcyBoZWxwZXIuXG4gKiBAcGFyYW0gY29tcG9uZW50cyAtIGluZGljYXRlcyB0aGUgbnVtYmVyIG9mIGNvbXBvbmVudHMgb2YgZWFjaCBlbGVtZW50LiAxIGZvciBzY2FsYXIsIDIgZm9yIHZlYzIsIDMgZm9yIHZlYzMsIDQgZm9yXG4gKiAgICB2ZWM0LlxuICovXG5jb25zdCBjcmVhdGVJbmRpY2VzSGVscGVyID1cbiAgICAobmFtZTogc3RyaW5nLCB0ZW5zb3JUeXBlOiBudW1iZXIsIHNoYXBlT3JSYW5rOiBudW1iZXJ8cmVhZG9ubHkgbnVtYmVyW10sIHVzYWdlOiBJbmRpY2VzSGVscGVyWyd1c2FnZSddLFxuICAgICBjb21wb25lbnRzOiAxfDJ8M3w0KTogSW5kaWNlc0hlbHBlciA9PiB7XG4gICAgICBjb25zdCB1c2VVbmlmb3JtID0gdHlwZW9mIHNoYXBlT3JSYW5rID09PSAnbnVtYmVyJztcbiAgICAgIGNvbnN0IHJhbmsgPSB1c2VVbmlmb3JtID8gc2hhcGVPclJhbmsgOiBzaGFwZU9yUmFuay5sZW5ndGg7XG4gICAgICBjb25zdCByYW5rSWRlbnRpdHkgPSBbLi4ubmV3IEFycmF5KHJhbmspLmtleXMoKV07XG4gICAgICBjb25zdCBpbmRpY2VzVHlwZSA9IHJhbmsgPCAyID8gJ3UzMicgOiByYW5rIDw9IDQgPyBgdmVjJHtyYW5rfTx1MzI+YCA6IGBhcnJheTx1MzIsICR7cmFua30+YDtcbiAgICAgIGNvbnN0IG1hcHBlZFR5cGUgPSBnZXRXZ3NsTWFwcGVkVHlwZSh0ZW5zb3JUeXBlLCBjb21wb25lbnRzKTtcbiAgICAgIGNvbnN0IHZhbHVlVHlwZSA9IHR5cGVvZiBtYXBwZWRUeXBlID09PSAnc3RyaW5nJyA/IG1hcHBlZFR5cGUgOiBtYXBwZWRUeXBlWzFdO1xuICAgICAgY29uc3Qgc3RvcmFnZVR5cGUgPSB0eXBlb2YgbWFwcGVkVHlwZSA9PT0gJ3N0cmluZycgPyBtYXBwZWRUeXBlIDogbWFwcGVkVHlwZVswXTtcbiAgICAgIGNvbnN0IHR5cGUgPSB7aW5kaWNlczogaW5kaWNlc1R5cGUsIHZhbHVlOiB2YWx1ZVR5cGUsIHN0b3JhZ2U6IHN0b3JhZ2VUeXBlLCB0ZW5zb3I6IHRlbnNvclR5cGV9O1xuXG4gICAgICBjb25zdCBub3JtYWxpemVEaW0gPSAoZGltOiBudW1iZXJ8c3RyaW5nKTogc3RyaW5nID0+IHR5cGVvZiBkaW0gPT09ICdzdHJpbmcnID8gZGltIDogYCR7ZGltfXVgO1xuXG4gICAgICBjb25zdCBpbXBsZW1lbnRhdGlvblVzZWQgPSB7XG4gICAgICAgIG9mZnNldFRvSW5kaWNlczogZmFsc2UsXG4gICAgICAgIGluZGljZXNUb09mZnNldDogZmFsc2UsXG4gICAgICAgIGJyb2FkY2FzdGVkSW5kaWNlc1RvT2Zmc2V0OiBmYWxzZSxcbiAgICAgICAgc2V0OiBmYWxzZSxcbiAgICAgICAgc2V0QnlJbmRpY2VzOiBmYWxzZSxcbiAgICAgICAgZ2V0OiBmYWxzZSxcbiAgICAgICAgZ2V0QnlJbmRpY2VzOiBmYWxzZSxcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHVuaWZvcm1QcmVmaXggPSB1c2VVbmlmb3JtID8gJ3VuaWZvcm1zLicgOiAnJztcbiAgICAgIGNvbnN0IHNoYXBlID0gYCR7dW5pZm9ybVByZWZpeH0ke25hbWV9X3NoYXBlYDtcbiAgICAgIGNvbnN0IHN0cmlkZXMgPSBgJHt1bmlmb3JtUHJlZml4fSR7bmFtZX1fc3RyaWRlc2A7XG5cbiAgICAgIGxldCBvMmlTbmlwcGV0ID0gJyc7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJhbmsgLSAxOyBpKyspIHtcbiAgICAgICAgbzJpU25pcHBldCArPSBgXG4gICAgbGV0IGRpbSR7aX0gPSBjdXJyZW50IC8gJHtnZXRFbGVtZW50QXQoc3RyaWRlcywgaSwgcmFuayl9O1xuICAgIGxldCByZXN0JHtpfSA9IGN1cnJlbnQgJSAke2dldEVsZW1lbnRBdChzdHJpZGVzLCBpLCByYW5rKX07XG4gICAgaW5kaWNlc1ske2l9XSA9IGRpbSR7aX07XG4gICAgY3VycmVudCA9IHJlc3Qke2l9O1xuICAgIGA7XG4gICAgICB9XG4gICAgICBvMmlTbmlwcGV0ICs9IGBpbmRpY2VzWyR7cmFuayAtIDF9XSA9IGN1cnJlbnQ7YDtcblxuICAgICAgY29uc3Qgb2Zmc2V0VG9JbmRpY2VzSW1wbGVtZW50YXRpb24gPSByYW5rIDwgMiA/ICcnIDogYFxuICBmbiBvMmlfJHtuYW1lfShvZmZzZXQ6IHUzMikgLT4gJHt0eXBlLmluZGljZXN9IHtcbiAgICB2YXIgaW5kaWNlczogJHt0eXBlLmluZGljZXN9O1xuICAgIHZhciBjdXJyZW50ID0gb2Zmc2V0O1xuICAgICR7bzJpU25pcHBldH1cbiAgICByZXR1cm4gaW5kaWNlcztcbiAgfWA7XG5cbiAgICAgIGNvbnN0IG9mZnNldFRvSW5kaWNlcyA9ICh2YXJPZmZzZXQ6IHN0cmluZykgPT4ge1xuICAgICAgICBpbXBsZW1lbnRhdGlvblVzZWQub2Zmc2V0VG9JbmRpY2VzID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHJhbmsgPCAyID8gdmFyT2Zmc2V0IDogYG8yaV8ke25hbWV9KCR7dmFyT2Zmc2V0fSlgO1xuICAgICAgfTtcblxuICAgICAgY29uc3Qgb2Zmc2V0czogc3RyaW5nW10gPSBbXTtcbiAgICAgIGlmIChyYW5rID49IDIpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IHJhbmsgLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIG9mZnNldHMucHVzaChgJHtnZXRFbGVtZW50QXQoc3RyaWRlcywgaSwgcmFuayl9ICogKGluZGljZXNbJHtpfV0pYCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY29uc3QgaW5kaWNlc1RvT2Zmc2V0SW1wbGVtZW50YXRpb24gPSByYW5rIDwgMiA/ICcnIDogYFxuICBmbiBpMm9fJHtuYW1lfShpbmRpY2VzOiAke3R5cGUuaW5kaWNlc30pIC0+IHUzMiB7XG4gICAgcmV0dXJuICR7b2Zmc2V0cy5qb2luKCcrJyl9O1xuICB9YDtcblxuICAgICAgY29uc3QgaW5kaWNlc1RvT2Zmc2V0ID0gKHZhckluZGljZXM6IHN0cmluZykgPT4ge1xuICAgICAgICBpbXBsZW1lbnRhdGlvblVzZWQuaW5kaWNlc1RvT2Zmc2V0ID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHJhbmsgPCAyID8gdmFySW5kaWNlcyA6IGBpMm9fJHtuYW1lfSgke3ZhckluZGljZXN9KWA7XG4gICAgICB9O1xuXG4gICAgICBjb25zdCBpbmRpY2VzID0gKC4uLmluaXQ6IFJlYWRvbmx5QXJyYXk8bnVtYmVyfHN0cmluZz4pID0+XG4gICAgICAgICAgcmFuayA9PT0gMCA/ICcwdScgOiBgJHt0eXBlLmluZGljZXN9KCR7aW5pdC5tYXAobm9ybWFsaXplRGltKS5qb2luKCcsJyl9KWA7XG5cbiAgICAgIGNvbnN0IGluZGljZXNHZXQgPSAodmFySW5kaWNlczogc3RyaW5nLCBpZHg6IG51bWJlcnxzdHJpbmcpID0+IHtcbiAgICAgICAgaWYgKHJhbmsgPCAyKSB7XG4gICAgICAgICAgcmV0dXJuIGAke3ZhckluZGljZXN9YDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gYCR7Z2V0RWxlbWVudEF0KHZhckluZGljZXMsIGlkeCwgcmFuayl9YDtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgY29uc3QgaW5kaWNlc1NldCA9ICh2YXJJbmRpY2VzOiBzdHJpbmcsIGlkeDogbnVtYmVyfHN0cmluZywgdmFsdWU6IHN0cmluZykgPT4ge1xuICAgICAgICBpZiAocmFuayA8IDIpIHtcbiAgICAgICAgICByZXR1cm4gYCR7dmFySW5kaWNlc309JHt2YWx1ZX07YDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gYCR7Z2V0RWxlbWVudEF0KHZhckluZGljZXMsIGlkeCwgcmFuayl9PSR7dmFsdWV9O2A7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IGJyb2FkY2FzdGVkSW5kaWNlc1RvT2Zmc2V0SW1wbGVtZW50YXRpb246IHtba2V5OiBzdHJpbmddOiBzdHJpbmd9ID0ge307XG4gICAgICBjb25zdCBicm9hZGNhc3RlZEluZGljZXNUb09mZnNldCA9ICh2YXJJbmRpY2VzOiBzdHJpbmcsIG91dHB1dDogSW5kaWNlc0hlbHBlcikgPT4ge1xuICAgICAgICBpbXBsZW1lbnRhdGlvblVzZWQuYnJvYWRjYXN0ZWRJbmRpY2VzVG9PZmZzZXQgPSB0cnVlO1xuICAgICAgICBjb25zdCBpbXBsS2V5ID0gYCR7b3V0cHV0Lm5hbWV9YnJvYWRjYXN0ZWRJbmRpY2VzVG8ke25hbWV9T2Zmc2V0YDtcbiAgICAgICAgaWYgKGltcGxLZXkgaW4gYnJvYWRjYXN0ZWRJbmRpY2VzVG9PZmZzZXRJbXBsZW1lbnRhdGlvbikge1xuICAgICAgICAgIHJldHVybiBgJHtpbXBsS2V5fSgke3ZhckluZGljZXN9KWA7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb2Zmc2V0cyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gcmFuayAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgY29uc3QgaWR4ID0gb3V0cHV0LmluZGljZXNHZXQoJ291dHB1dEluZGljZXMnLCBpICsgb3V0cHV0LnJhbmsgLSByYW5rKTtcbiAgICAgICAgICBvZmZzZXRzLnB1c2goYCR7aW5kaWNlc0dldChzdHJpZGVzLCBpKX0gKiAoJHtpZHh9ICUgJHtpbmRpY2VzR2V0KHNoYXBlLCBpKX0pYCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJvYWRjYXN0ZWRJbmRpY2VzVG9PZmZzZXRJbXBsZW1lbnRhdGlvbltpbXBsS2V5XSA9XG4gICAgICAgICAgICBgZm4gJHtpbXBsS2V5fShvdXRwdXRJbmRpY2VzOiAke291dHB1dC50eXBlLmluZGljZXN9KSAtPiB1MzIge1xuICAgICAgICAgICAgIHJldHVybiAke29mZnNldHMubGVuZ3RoID4gMCA/IG9mZnNldHMuam9pbignKycpIDogJzB1J307XG4gICAgICAgICAgIH1gO1xuXG4gICAgICAgIHJldHVybiBgJHtpbXBsS2V5fSgke3ZhckluZGljZXN9KWA7XG4gICAgICB9O1xuXG4gICAgICBjb25zdCBzZXRCeU9mZnNldCA9IChvZmZzZXQ6IG51bWJlcnxzdHJpbmcsIHZhbHVlOiBzdHJpbmcpID0+ICgoKSA9PiB7XG4gICAgICAgIGlmICh0eXBlLnN0b3JhZ2UgPT09IHR5cGUudmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gYCR7bmFtZX1bJHtvZmZzZXR9XT0ke3ZhbHVlfTtgO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGUuc3RvcmFnZSA9PT0gJ3ZlYzI8dTMyPicgJiYgdHlwZS52YWx1ZSA9PT0gJ2kzMicpIHtcbiAgICAgICAgICAvLyBpbnQ2NCwgY29tcG9uZW50cyA9PT0gMVxuICAgICAgICAgIHJldHVybiBgJHtuYW1lfVske29mZnNldH1dPXZlYzI8dTMyPih1MzIoJHt2YWx1ZX0pLCBzZWxlY3QoMHUsIDB4RkZGRkZGRkZ1LCAke3ZhbHVlfSA8IDApKTtgO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGUuc3RvcmFnZSA9PT0gJ3ZlYzI8dTMyPicgJiYgdHlwZS52YWx1ZSA9PT0gJ3UzMicpIHtcbiAgICAgICAgICAvLyB1aW50NjQsIGNvbXBvbmVudHMgPT09IDFcbiAgICAgICAgICByZXR1cm4gYCR7bmFtZX1bJHtvZmZzZXR9XT12ZWMyPHUzMj4odTMyKCR7dmFsdWV9KSwgMHUpO2A7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZS5zdG9yYWdlID09PSAndTMyJyAmJiB0eXBlLnZhbHVlID09PSAndmVjNDxib29sPicpIHtcbiAgICAgICAgICAvLyBib29sLCBjb21wb25lbnRzID09PSA0XG4gICAgICAgICAgcmV0dXJuIGAke25hbWV9WyR7b2Zmc2V0fV09ZG90KHZlYzQ8dTMyPigweDEsIDB4MTAwLCAweDEwMDAwLCAweDEwMDAwMDApLCB2ZWM0PHUzMj4oJHt2YWx1ZX0pKTtgO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgbm90IHN1cHBvcnRlZCBjb21iaW5hdGlvbiBvZiBzdG9yYWdlIHR5cGUgJHt0eXBlLnN0b3JhZ2V9IGFuZCB2YWx1ZSB0eXBlICR7dHlwZS52YWx1ZX0geWV0YCk7XG4gICAgICAgIH1cbiAgICAgIH0pKCk7XG5cbiAgICAgIGNvbnN0IGdldEJ5T2Zmc2V0ID0gKG9mZnNldDogbnVtYmVyfHN0cmluZykgPT4gKCgpID0+IHtcbiAgICAgICAgaWYgKHR5cGUuc3RvcmFnZSA9PT0gdHlwZS52YWx1ZSkge1xuICAgICAgICAgIHJldHVybiBgJHtuYW1lfVske29mZnNldH1dYDtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlLnN0b3JhZ2UgPT09ICd2ZWMyPHUzMj4nICYmIHR5cGUudmFsdWUgPT09ICdpMzInKSB7XG4gICAgICAgICAgLy8gaW50NjQsIGNvbXBvbmVudHMgPT09IDFcbiAgICAgICAgICByZXR1cm4gYGkzMigke25hbWV9WyR7b2Zmc2V0fV0ueClgO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGUuc3RvcmFnZSA9PT0gJ3ZlYzI8dTMyPicgJiYgdHlwZS52YWx1ZSA9PT0gJ3UzMicpIHtcbiAgICAgICAgICAvLyB1aW50NjQsIGNvbXBvbmVudHMgPT09IDFcbiAgICAgICAgICByZXR1cm4gYHUzMigke25hbWV9WyR7b2Zmc2V0fV0ueClgO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGUuc3RvcmFnZSA9PT0gJ3UzMicgJiYgdHlwZS52YWx1ZSA9PT0gJ3ZlYzQ8Ym9vbD4nKSB7XG4gICAgICAgICAgLy8gYm9vbCwgY29tcG9uZW50cyA9PT0gNFxuICAgICAgICAgIHJldHVybiBgdmVjNDxib29sPihib29sKCR7bmFtZX1bJHtvZmZzZXR9XSAmIDB4RkZ1KSwgYm9vbCgke25hbWV9WyR7b2Zmc2V0fV0gJiAweEZGMDB1KSwgYm9vbCgke25hbWV9WyR7XG4gICAgICAgICAgICAgIG9mZnNldH1dICYgMHhGRjAwMDB1KSwgYm9vbCgke25hbWV9WyR7b2Zmc2V0fV0gJiAweEZGMDAwMDAwdSkpYDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYG5vdCBzdXBwb3J0ZWQgY29tYmluYXRpb24gb2Ygc3RvcmFnZSB0eXBlICR7dHlwZS5zdG9yYWdlfSBhbmQgdmFsdWUgdHlwZSAke3R5cGUudmFsdWV9IHlldGApO1xuICAgICAgICB9XG4gICAgICB9KSgpO1xuXG4gICAgICBjb25zdCBnZXRCeUluZGljZXNJbXBsZW1lbnRhdGlvbiA9IHJhbmsgPCAyID8gJycgOiBgXG4gIGZuIGdldF8ke25hbWV9QnlJbmRpY2VzKGluZGljZXM6ICR7dHlwZS5pbmRpY2VzfSkgLT4gJHt2YWx1ZVR5cGV9IHtcbiAgICByZXR1cm4gJHtnZXRCeU9mZnNldChgaTJvXyR7bmFtZX0oaW5kaWNlcylgKX07XG4gIH1gO1xuXG4gICAgICBjb25zdCBnZXRJbXBsZW1lbnRhdGlvbiA9IHJhbmsgPCAyID8gJycgOiAoKCkgPT4ge1xuICAgICAgICBjb25zdCBmdW5jdGlvblBhcmFtcyA9IHJhbmtJZGVudGl0eS5tYXAoaSA9PiBgZCR7aX06IHUzMmApLmpvaW4oJywgJyk7XG4gICAgICAgIGNvbnN0IGRpbXNQYXJhbXMgPSByYW5rSWRlbnRpdHkubWFwKGkgPT4gYGQke2l9YCkuam9pbignLCAnKTtcbiAgICAgICAgcmV0dXJuIGBcbiAgZm4gZ2V0XyR7bmFtZX0oJHtmdW5jdGlvblBhcmFtc30pIC0+ICR7dmFsdWVUeXBlfSB7XG4gICAgcmV0dXJuIGdldF8ke25hbWV9QnlJbmRpY2VzKCR7aW5kaWNlcyhkaW1zUGFyYW1zKX0pO1xuICB9YDtcbiAgICAgIH0pKCk7XG5cbiAgICAgIGNvbnN0IGdldCA9ICguLi5pbmRpY2VzOiBSZWFkb25seUFycmF5PG51bWJlcnxzdHJpbmc+KSA9PiB7XG4gICAgICAgIGlmIChpbmRpY2VzLmxlbmd0aCAhPT0gcmFuaykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgaW5kaWNlcyBsZW5ndGggbXVzdCBiZSAke3Jhbmt9YCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBub3JtYWxpemVkSW5kaWNlcyA9IGluZGljZXMubWFwKG5vcm1hbGl6ZURpbSkuam9pbignLCcpO1xuXG4gICAgICAgIGlmIChyYW5rID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIGdldEJ5T2Zmc2V0KCcwdScpO1xuICAgICAgICB9IGVsc2UgaWYgKHJhbmsgPT09IDEpIHtcbiAgICAgICAgICByZXR1cm4gZ2V0QnlPZmZzZXQobm9ybWFsaXplZEluZGljZXNbMF0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGltcGxlbWVudGF0aW9uVXNlZC5nZXQgPSB0cnVlO1xuICAgICAgICAgIGltcGxlbWVudGF0aW9uVXNlZC5nZXRCeUluZGljZXMgPSB0cnVlO1xuICAgICAgICAgIGltcGxlbWVudGF0aW9uVXNlZC5pbmRpY2VzVG9PZmZzZXQgPSB0cnVlO1xuICAgICAgICAgIHJldHVybiBgZ2V0XyR7bmFtZX0oJHtub3JtYWxpemVkSW5kaWNlc30pYDtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgY29uc3QgZ2V0QnlJbmRpY2VzID0gKHZhckluZGljZXM6IHN0cmluZykgPT4ge1xuICAgICAgICBpZiAocmFuayA8IDIpIHtcbiAgICAgICAgICByZXR1cm4gZ2V0QnlPZmZzZXQodmFySW5kaWNlcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaW1wbGVtZW50YXRpb25Vc2VkLmdldEJ5SW5kaWNlcyA9IHRydWU7XG4gICAgICAgICAgaW1wbGVtZW50YXRpb25Vc2VkLmluZGljZXNUb09mZnNldCA9IHRydWU7XG4gICAgICAgICAgcmV0dXJuIGBnZXRfJHtuYW1lfUJ5SW5kaWNlcygke3ZhckluZGljZXN9KWA7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHNldEJ5SW5kaWNlc0ltcGxlbWVudGF0aW9uID0gcmFuayA8IDIgPyAnJyA6IGBcbiAgZm4gc2V0XyR7bmFtZX1CeUluZGljZXMoaW5kaWNlczogJHt0eXBlLmluZGljZXN9LCB2YWx1ZTogJHt2YWx1ZVR5cGV9KSB7XG4gICAgJHtzZXRCeU9mZnNldChgaTJvXyR7bmFtZX0oaW5kaWNlcylgLCAndmFsdWUnKX1cbiAgfWA7XG5cbiAgICAgIGNvbnN0IHNldEltcGxlbWVudGF0aW9uID0gcmFuayA8IDIgPyAnJyA6ICgoKSA9PiB7XG4gICAgICAgIGNvbnN0IGZ1bmN0aW9uUGFyYW1zID0gcmFua0lkZW50aXR5Lm1hcChpID0+IGBkJHtpfTogdTMyYCkuam9pbignLCAnKTtcbiAgICAgICAgY29uc3QgZGltc1BhcmFtcyA9IHJhbmtJZGVudGl0eS5tYXAoaSA9PiBgZCR7aX1gKS5qb2luKCcsICcpO1xuICAgICAgICByZXR1cm4gYFxuICBmbiBzZXRfJHtuYW1lfSgke2Z1bmN0aW9uUGFyYW1zfSwgdmFsdWU6ICR7dmFsdWVUeXBlfSkge1xuICAgIHNldF8ke25hbWV9QnlJbmRpY2VzKCR7aW5kaWNlcyhkaW1zUGFyYW1zKX0sIHZhbHVlKTtcbiAgfWA7XG4gICAgICB9KSgpO1xuXG4gICAgICBjb25zdCBzZXQgPSAoLi4uaW5kaWNlc0FuZFZhbHVlOiBSZWFkb25seUFycmF5PG51bWJlcnxzdHJpbmc+KSA9PiB7XG4gICAgICAgIGlmIChpbmRpY2VzQW5kVmFsdWUubGVuZ3RoICE9PSByYW5rICsgMSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgaW5kaWNlcyBsZW5ndGggbXVzdCBiZSAke3Jhbmt9YCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmFsdWUgPSBpbmRpY2VzQW5kVmFsdWVbcmFua107XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd2YWx1ZSBtdXN0IGJlIHN0cmluZycpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgbm9ybWFsaXplZEluZGljZXMgPSBpbmRpY2VzQW5kVmFsdWUuc2xpY2UoMCwgcmFuaykubWFwKG5vcm1hbGl6ZURpbSkuam9pbignLCcpO1xuXG4gICAgICAgIGlmIChyYW5rID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIHNldEJ5T2Zmc2V0KCcwdScsIHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIGlmIChyYW5rID09PSAxKSB7XG4gICAgICAgICAgcmV0dXJuIHNldEJ5T2Zmc2V0KG5vcm1hbGl6ZWRJbmRpY2VzWzBdLCB2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaW1wbGVtZW50YXRpb25Vc2VkLnNldCA9IHRydWU7XG4gICAgICAgICAgaW1wbGVtZW50YXRpb25Vc2VkLnNldEJ5SW5kaWNlcyA9IHRydWU7XG4gICAgICAgICAgaW1wbGVtZW50YXRpb25Vc2VkLmluZGljZXNUb09mZnNldCA9IHRydWU7XG4gICAgICAgICAgcmV0dXJuIGBzZXRfJHtuYW1lfSgke25vcm1hbGl6ZWRJbmRpY2VzfSwgJHt2YWx1ZX0pYDtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgY29uc3Qgc2V0QnlJbmRpY2VzID0gKHZhckluZGljZXM6IHN0cmluZywgdmFsdWU6IHN0cmluZykgPT4ge1xuICAgICAgICBpZiAocmFuayA8IDIpIHtcbiAgICAgICAgICByZXR1cm4gc2V0QnlPZmZzZXQodmFySW5kaWNlcywgdmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGltcGxlbWVudGF0aW9uVXNlZC5zZXRCeUluZGljZXMgPSB0cnVlO1xuICAgICAgICAgIGltcGxlbWVudGF0aW9uVXNlZC5pbmRpY2VzVG9PZmZzZXQgPSB0cnVlO1xuICAgICAgICAgIHJldHVybiBgc2V0XyR7bmFtZX1CeUluZGljZXMoJHt2YXJJbmRpY2VzfSwgJHt2YWx1ZX0pO2A7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IGltcGwgPSAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGltcGxzID0gW107XG4gICAgICAgIGxldCBuZWVkU2hhcGVTdHJpZGVzID0gZmFsc2U7XG4gICAgICAgIGlmIChpbXBsZW1lbnRhdGlvblVzZWQub2Zmc2V0VG9JbmRpY2VzKSB7XG4gICAgICAgICAgaW1wbHMucHVzaChvZmZzZXRUb0luZGljZXNJbXBsZW1lbnRhdGlvbik7XG4gICAgICAgICAgbmVlZFNoYXBlU3RyaWRlcyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGltcGxlbWVudGF0aW9uVXNlZC5pbmRpY2VzVG9PZmZzZXQpIHtcbiAgICAgICAgICBpbXBscy5wdXNoKGluZGljZXNUb09mZnNldEltcGxlbWVudGF0aW9uKTtcbiAgICAgICAgICBuZWVkU2hhcGVTdHJpZGVzID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW1wbGVtZW50YXRpb25Vc2VkLmJyb2FkY2FzdGVkSW5kaWNlc1RvT2Zmc2V0KSB7XG4gICAgICAgICAgT2JqZWN0LnZhbHVlcyhicm9hZGNhc3RlZEluZGljZXNUb09mZnNldEltcGxlbWVudGF0aW9uKS5mb3JFYWNoKGltcGwgPT4gaW1wbHMucHVzaChpbXBsKSk7XG4gICAgICAgICAgbmVlZFNoYXBlU3RyaWRlcyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGltcGxlbWVudGF0aW9uVXNlZC5zZXQpIHtcbiAgICAgICAgICBpbXBscy5wdXNoKHNldEltcGxlbWVudGF0aW9uKTtcbiAgICAgICAgICBuZWVkU2hhcGVTdHJpZGVzID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW1wbGVtZW50YXRpb25Vc2VkLnNldEJ5SW5kaWNlcykge1xuICAgICAgICAgIGltcGxzLnB1c2goc2V0QnlJbmRpY2VzSW1wbGVtZW50YXRpb24pO1xuICAgICAgICAgIG5lZWRTaGFwZVN0cmlkZXMgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbXBsZW1lbnRhdGlvblVzZWQuZ2V0KSB7XG4gICAgICAgICAgaW1wbHMucHVzaChnZXRJbXBsZW1lbnRhdGlvbik7XG4gICAgICAgICAgbmVlZFNoYXBlU3RyaWRlcyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGltcGxlbWVudGF0aW9uVXNlZC5nZXRCeUluZGljZXMpIHtcbiAgICAgICAgICBpbXBscy5wdXNoKGdldEJ5SW5kaWNlc0ltcGxlbWVudGF0aW9uKTtcbiAgICAgICAgICBuZWVkU2hhcGVTdHJpZGVzID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXVzZVVuaWZvcm0gJiYgbmVlZFNoYXBlU3RyaWRlcykge1xuICAgICAgICAgIGltcGxzLnVuc2hpZnQoXG4gICAgICAgICAgICAgIGBjb25zdCAke3NoYXBlfSA9ICR7dHlwZS5pbmRpY2VzfSgke3NoYXBlT3JSYW5rLmpvaW4oJywnKX0pO2AsXG4gICAgICAgICAgICAgIGBjb25zdCAke3N0cmlkZXN9ID0gJHt0eXBlLmluZGljZXN9KCR7U2hhcGVVdGlsLmNvbXB1dGVTdHJpZGVzKHNoYXBlT3JSYW5rKS5qb2luKCcsJyl9KTtgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW1wbHMuam9pbignXFxuJyk7XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBpbXBsLFxuICAgICAgICB0eXBlLFxuICAgICAgICBvZmZzZXRUb0luZGljZXMsXG4gICAgICAgIGluZGljZXNUb09mZnNldCxcbiAgICAgICAgYnJvYWRjYXN0ZWRJbmRpY2VzVG9PZmZzZXQsXG4gICAgICAgIGluZGljZXMsXG4gICAgICAgIGluZGljZXNHZXQsXG4gICAgICAgIGluZGljZXNTZXQsXG4gICAgICAgIHNldCxcbiAgICAgICAgc2V0QnlPZmZzZXQsXG4gICAgICAgIHNldEJ5SW5kaWNlcyxcbiAgICAgICAgZ2V0LFxuICAgICAgICBnZXRCeU9mZnNldCxcbiAgICAgICAgZ2V0QnlJbmRpY2VzLFxuICAgICAgICAvLyBpc1ZlYzQsXG4gICAgICAgIHVzYWdlLFxuICAgICAgICBuYW1lLFxuICAgICAgICBzdHJpZGVzLFxuICAgICAgICBzaGFwZSxcbiAgICAgICAgcmFua1xuICAgICAgfTtcbiAgICB9O1xuXG4vKipcbiAqIENyZWF0ZSBhIEluZGljZXNIZWxwZXIgZm9yIGFuIGlucHV0LlxuICpcbiAqIEBwYXJhbSBuYW1lIC0gdGhlIG5hbWUgb2YgdGhlIGlucHV0LlxuICogQHBhcmFtIHR5cGUgLSB0aGUgdGVuc29yIHR5cGUgb2YgdGhlIGlucHV0LlxuICogQHBhcmFtIHNoYXBlT3JSYW5rIC0gdGhlIHRlbnNvciBzaGFwZSBvciB0aGUgcmFuayBvZiB0aGUgaW5wdXQuXG4gKiBAcGFyYW0gY29tcG9uZW50cyAtIHRoZSBudW1iZXIgb2YgY29tcG9uZW50cyBvZiB0aGUgaW5wdXQuIGF2YWlsYWJsZSB2YWx1ZXMgYXJlIDEsIDIsIDMsIDQuIGRlZmF1bHQgaXMgMS5cbiAqIEByZXR1cm5zIGFuIEluZGljZXNIZWxwZXIgZm9yIHRoZSBpbnB1dC5cbiAqL1xuZXhwb3J0IGNvbnN0IGlucHV0VmFyaWFibGUgPVxuICAgIChuYW1lOiBzdHJpbmcsIHR5cGU6IG51bWJlciwgc2hhcGVPclJhbms6IG51bWJlcnxyZWFkb25seSBudW1iZXJbXSwgY29tcG9uZW50czogMXwyfDN8NCA9IDEpOiBJbmRpY2VzSGVscGVyID0+XG4gICAgICAgIGNyZWF0ZUluZGljZXNIZWxwZXIobmFtZSwgdHlwZSwgc2hhcGVPclJhbmssICdpbnB1dCcsIGNvbXBvbmVudHMpO1xuXG4vKipcbiAqIENyZWF0ZSBhIEluZGljZXNIZWxwZXIgZm9yIGFuIG91dHB1dC5cbiAqXG4gKiBAcGFyYW0gbmFtZSAtIHRoZSBuYW1lIG9mIHRoZSBvdXRwdXQuXG4gKiBAcGFyYW0gdHlwZSAtIHRoZSB0ZW5zb3IgdHlwZSBvZiB0aGUgb3V0cHV0LlxuICogQHBhcmFtIHNoYXBlT3JSYW5rIC0gdGhlIHRlbnNvciBzaGFwZSBvciB0aGUgcmFuayBvZiB0aGUgb3V0cHV0LlxuICogQHBhcmFtIGNvbXBvbmVudHMgLSB0aGUgbnVtYmVyIG9mIGNvbXBvbmVudHMgb2YgdGhlIG91dHB1dC4gYXZhaWxhYmxlIHZhbHVlcyBhcmUgMSwgMiwgMywgNC4gZGVmYXVsdCBpcyAxLlxuICogQHJldHVybnMgYW4gSW5kaWNlc0hlbHBlciBmb3IgdGhlIG91dHB1dC5cbiAqL1xuZXhwb3J0IGNvbnN0IG91dHB1dFZhcmlhYmxlID1cbiAgICAobmFtZTogc3RyaW5nLCB0eXBlOiBudW1iZXIsIHNoYXBlT3JSYW5rOiBudW1iZXJ8cmVhZG9ubHkgbnVtYmVyW10sIGNvbXBvbmVudHM6IDF8MnwzfDQgPSAxKTogSW5kaWNlc0hlbHBlciA9PlxuICAgICAgICBjcmVhdGVJbmRpY2VzSGVscGVyKG5hbWUsIHR5cGUsIHNoYXBlT3JSYW5rLCAnb3V0cHV0JywgY29tcG9uZW50cyk7XG5cbi8qKlxuICogQ3JlYXRlIGEgSW5kaWNlc0hlbHBlciBmb3IgYW4gaW50ZXJuYWwgdmFyaWFibGUuXG4gKlxuICogQHBhcmFtIG5hbWUgLSB0aGUgbmFtZSBvZiB0aGUgdmFyaWFibGUuXG4gKiBAcGFyYW0gdHlwZSAtIHRoZSB0ZW5zb3IgdHlwZSBvZiB0aGUgdmFyaWFibGUuXG4gKiBAcGFyYW0gc2hhcGVPclJhbmsgLSB0aGUgdGVuc29yIHNoYXBlIG9yIHRoZSByYW5rIG9mIHRoZSB2YXJpYWJsZS5cbiAqIEBwYXJhbSBjb21wb25lbnRzIC0gdGhlIG51bWJlciBvZiBjb21wb25lbnRzIG9mIHRoZSB2YXJpYWJsZS4gYXZhaWxhYmxlIHZhbHVlcyBhcmUgMSwgMiwgMywgNC4gZGVmYXVsdCBpcyAxLlxuICogQHJldHVybnMgYW4gSW5kaWNlc0hlbHBlciBmb3IgdGhlIHZhcmlhYmxlLlxuICovXG5leHBvcnQgY29uc3QgaW50ZXJuYWxWYXJpYWJsZSA9XG4gICAgKG5hbWU6IHN0cmluZywgdHlwZTogbnVtYmVyLCBzaGFwZU9yUmFuazogbnVtYmVyfHJlYWRvbmx5IG51bWJlcltdLCBjb21wb25lbnRzOiAxfDJ8M3w0ID0gMSk6IEluZGljZXNIZWxwZXIgPT5cbiAgICAgICAgY3JlYXRlSW5kaWNlc0hlbHBlcihuYW1lLCB0eXBlLCBzaGFwZU9yUmFuaywgJ2ludGVybmFsJywgY29tcG9uZW50cyk7XG5cbmV4cG9ydCB0eXBlIFVuaWZvcm1EYXRhRWxlbWVudFR5cGUgPSAndTMyJ3wnZjMyJ3wnaTMyJztcbmV4cG9ydCB0eXBlIFVuaWZvcm1zQXJyYXlUeXBlID0gQXJyYXk8e25hbWU6IHN0cmluZzsgdHlwZTogVW5pZm9ybURhdGFFbGVtZW50VHlwZTsgbGVuZ3RoPzogbnVtYmVyfT47XG5cbi8qKlxuICogQSBTaGFkZXJIZWxwZXIgaXMgYSBoZWxwZXIgY2xhc3MgZm9yIGdlbmVyYXRpbmcgV0dTTCBjb2RlLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFNoYWRlckhlbHBlciB7XG4gIC8qKlxuICAgKiBBIGhlbHBlciBmdW5jdGlvbiB0byBnZW5lcmF0ZSB0aGUgc3RhcnQgb2YgbWFpbiBmdW5jdGlvbiBpbiBXR1NMIHNvdXJjZSBjb2RlLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBjb25zdCBnZXRTaGFkZXJTb3VyY2UgPSAoc2hhZGVySGVscGVyOiBTaGFkZXJIZWxwZXIpID0+IGBcbiAgICogIC4uLlxuICAgKlxuICAgKiAgJHtzaGFkZXJIZWxwZXIubWFpblN0YXJ0KCl9XG4gICAqICAgIC8vIHlvdXIgY29kZSBoZXJlIGluc2lkZSBtYWluKCkgZnVuY3Rpb25cbiAgICogICAgLi4uXG4gICAqICB9XG4gICAqIGA7XG4gICAqXG4gICAqIEBwYXJhbSB3b3JrZ3JvdXBTaXplIC0gYW4gb3B0aW9uYWwgd29ya2dyb3VwIHNpemUuIGRlZmF1bHQgaXMgV09SS0dST1VQX1NJWkUuXG4gICAqL1xuICBtYWluU3RhcnQod29ya2dyb3VwU2l6ZT86IG51bWJlcnxbbnVtYmVyLCBudW1iZXIsIG51bWJlcl0pOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIEEgaGVscGVyIGZ1bmN0aW9uIHRvIGdlbmVyYXRlIHRoZSBjb2RlIHNuaXBwZXQgZm9yIGd1YXJkaW5nIGFnYWluc3Qgb3V0LW9mLWJvdW5kcyBzaXplLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBjb25zdCBnZXRTaGFkZXJTb3VyY2UgPSAoc2hhZGVySGVscGVyOiBTaGFkZXJIZWxwZXIpID0+IGBcbiAgICogIC4uLlxuICAgKlxuICAgKiAgJHtzaGFkZXJIZWxwZXIubWFpblN0YXJ0KCl9XG4gICAqICAgICR7c2hhZGVySGVscGVyLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMob3V0cHV0U2l6ZSl9XG4gICAqXG4gICAqICAgIC8vIHlvdXIgY29kZSBoZXJlIGluc2lkZSBtYWluKCkgZnVuY3Rpb25cbiAgICogICAgLi4uXG4gICAqICB9XG4gICAqIGA7XG4gICAqXG4gICAqIEBwYXJhbSBzaXplIC0gdGhlIHNpemUgb2YgdGhlIGRhdGEgdG8gZ3VhcmQgYWdhaW5zdC4gY2FuIGJlIGEgbnVtYmVyIG9yIGEgc3RyaW5nIChXR1NMIGB1MzJgIGV4cHJlc3Npb24pLlxuICAgKi9cbiAgZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhzaXplOiB1bmtub3duKTogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBBIGhlbHBlciBmdW5jdGlvbiB0byBnZW5lcmF0ZSB0aGUgY29kZSBzbmlwcGV0IGZvciBkZWNsYXJpbmcgbXVsdGlwbGUgaW5wdXRzIG9yIG91dHB1dHMuXG4gICAqXG4gICAqIEBwYXJhbSB2YXJpYWJsZXMgLSBhbiBhcnJheSBvZiBJbmRpY2VzSGVscGVyIGZvciB0aGUgdmFyaWFibGVzLlxuICAgKi9cbiAgZGVjbGFyZVZhcmlhYmxlcyguLi52YXJpYWJsZXM6IEluZGljZXNIZWxwZXJbXSk6IHN0cmluZztcblxuICAvKipcbiAgICogQSBoZWxwZXIgZnVuY3Rpb24gdG8gcmVnaXN0ZXIgb25lIHVuaWZvcm0uIENhbiBiZSBjYWxsZWQgbXVsdGlwbGUgdGltZXMgdG8gcmVnaXN0ZXIgbXVsdGlwbGUgdW5pZm9ybXMuXG4gICAqXG4gICAqIEBwYXJhbSBuYW1lIC0gdGhlIG5hbWUgb2YgdGhlIHVuaWZvcm0uXG4gICAqIEBwYXJhbSB0eXBlIC0gdGhlIHR5cGUgb2YgdGhlIHVuaWZvcm0uXG4gICAqIEBwYXJhbSBsZW5ndGggLSB0aGUgbGVuZ3RoIG9mIHRoZSB1bmlmb3JtLCBkZWZhdWx0IHRvIDEgd2hlbiBpdCBpcyBub3QgcHJvdmlkZWQuXG4gICAqL1xuICByZWdpc3RlclVuaWZvcm0obmFtZTogc3RyaW5nLCB0eXBlOiBzdHJpbmcsIGxlbmd0aD86IG51bWJlcik6IFNoYWRlckhlbHBlcjtcblxuICAvKipcbiAgICogQSBoZWxwZXIgZnVuY3Rpb24gdG8gcmVnaXN0ZXIgbXVsdGlwbGUgdW5pZm9ybXMuIENhbiBiZSBjYWxsZWQgbXVsdGlwbGUgdGltZXMgdG8gcmVnaXN0ZXIgbXVsdGlwbGUgdW5pZm9ybXMuXG4gICAqXG4gICAqIEBwYXJhbSB1bmlmb3JtcyAtIGFuIGFycmF5IG9mIHVuaWZvcm1zLiBFYWNoIGVsZW1lbnQgb2YgdGhlIGFycmF5IGlzIGFuIG9iamVjdCB3aXRoIDIgcHJvcGVydGllczogYG5hbWVgIGFuZFxuICAgKiAgICAgYHR5cGVgLlxuICAgKi9cbiAgcmVnaXN0ZXJVbmlmb3Jtcyh1bmlmb3JtczogVW5pZm9ybXNBcnJheVR5cGUpOiBTaGFkZXJIZWxwZXI7XG5cbiAgLyoqXG4gICAqIEEgaGVscGVyIGZ1bmN0aW9uIHRvIHJlZ2lzdGVyIG11bHRpcGxlIGludGVybmFsIHZhcmlhYmxlcy4gQ2FuIGJlIGNhbGxlZCBtdWx0aXBsZSB0aW1lcyB0byByZWdpc3RlciBtdWx0aXBsZVxuICAgKiBpbnRlcm5hbCB2YXJpYWJsZXMuXG4gICAqXG4gICAqIEBwYXJhbSB2YXJpYWJsZXMgLSBhbiBhcnJheSBvZiBJbmRpY2VzSGVscGVyIGZvciB0aGUgdmFyaWFibGVzLlxuICAgKi9cbiAgcmVnaXN0ZXJJbnRlcm5hbFZhcmlhYmxlcyguLi52YXJpYWJsZXM6IEluZGljZXNIZWxwZXJbXSk6IFNoYWRlckhlbHBlcjtcbn1cblxuY2xhc3MgU2hhZGVySGVscGVySW1wbCBpbXBsZW1lbnRzIFNoYWRlckhlbHBlciB7XG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgbm9ybWFsaXplZERpc3BhdGNoR3JvdXA6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyXSkge31cblxuICBndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKHNpemU6IG51bWJlcnxzdHJpbmcpOiBzdHJpbmcge1xuICAgIC8vIEd1YXJkIGFnYWluc3Qgb3V0LW9mLWJvdW5kcyB3b3JrIGdyb3VwIHNpemVzXG4gICAgY29uc3Qgc2l6ZUluQ29kZSA9IHR5cGVvZiBzaXplID09PSAnbnVtYmVyJyA/IGAke3NpemV9dWAgOiBzaXplO1xuICAgIHJldHVybiBgaWYgKGdsb2JhbF9pZHggPj0gJHtzaXplSW5Db2RlfSkgeyByZXR1cm47IH1gO1xuICB9XG5cbiAgbWFpblN0YXJ0KHdvcmtncm91cFNpemU6IG51bWJlcnxbbnVtYmVyLCBudW1iZXIsIG51bWJlcl0gPSBXT1JLR1JPVVBfU0laRSkge1xuICAgIGNvbnN0IHdvcmtncm91cFNpemVYID0gdHlwZW9mIHdvcmtncm91cFNpemUgPT09ICdudW1iZXInID8gd29ya2dyb3VwU2l6ZSA6IHdvcmtncm91cFNpemVbMF07XG4gICAgY29uc3Qgd29ya2dyb3VwU2l6ZVkgPSB0eXBlb2Ygd29ya2dyb3VwU2l6ZSA9PT0gJ251bWJlcicgPyAxIDogd29ya2dyb3VwU2l6ZVsxXTtcbiAgICBjb25zdCB3b3JrZ3JvdXBTaXplWiA9IHR5cGVvZiB3b3JrZ3JvdXBTaXplID09PSAnbnVtYmVyJyA/IDEgOiB3b3JrZ3JvdXBTaXplWzJdO1xuXG4gICAgY29uc3QgaXMxRGltZW5zaW9uRGlzcGF0Y2ggPSB0aGlzLm5vcm1hbGl6ZWREaXNwYXRjaEdyb3VwWzFdID09PSAxICYmIHRoaXMubm9ybWFsaXplZERpc3BhdGNoR3JvdXBbMl0gPT09IDE7XG4gICAgY29uc3QgcGFyYW1MaXN0ID0gaXMxRGltZW5zaW9uRGlzcGF0Y2ggPyBgQGJ1aWx0aW4oZ2xvYmFsX2ludm9jYXRpb25faWQpIGdsb2JhbF9pZCA6IHZlYzM8dTMyPixcbiAgICBAYnVpbHRpbih3b3JrZ3JvdXBfaWQpIHdvcmtncm91cF9pZCA6IHZlYzM8dTMyPixcbiAgICBAYnVpbHRpbihsb2NhbF9pbnZvY2F0aW9uX2lkKSBsb2NhbF9pZCA6IHZlYzM8dTMyPmAgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYEBidWlsdGluKGxvY2FsX2ludm9jYXRpb25faWQpIGxvY2FsX2lkIDogdmVjMzx1MzI+LFxuICAgIEBidWlsdGluKGxvY2FsX2ludm9jYXRpb25faW5kZXgpIGxvY2FsX2lkeCA6IHUzMixcbiAgICBAYnVpbHRpbih3b3JrZ3JvdXBfaWQpIHdvcmtncm91cF9pZCA6IHZlYzM8dTMyPixcbiAgICBAYnVpbHRpbihudW1fd29ya2dyb3VwcykgbnVtX3dvcmtncm91cHMgOiB2ZWMzPHUzMj5gO1xuICAgIGNvbnN0IGdsb2JhbElkeERlZmluaXRpb24gPSBpczFEaW1lbnNpb25EaXNwYXRjaCA/XG4gICAgICAgICdsZXQgZ2xvYmFsX2lkeCA9IGdsb2JhbF9pZC54OyBsZXQgbG9jYWxfaWR4ID0gbG9jYWxfaWQueDsnIDpcbiAgICAgICAgYGxldCBnbG9iYWxfaWR4ID0gKHdvcmtncm91cF9pZC56ICogbnVtX3dvcmtncm91cHNbMF0gKiBudW1fd29ya2dyb3Vwc1sxXSArXG4gICAgICAgICAgd29ya2dyb3VwX2lkLnkgKiBudW1fd29ya2dyb3Vwc1swXSArIHdvcmtncm91cF9pZC54KSAqICR7XG4gICAgICAgICAgICB3b3JrZ3JvdXBTaXplWCAqIHdvcmtncm91cFNpemVZICogd29ya2dyb3VwU2l6ZVp9dSArIGxvY2FsX2lkeDtgO1xuXG4gICAgcmV0dXJuIGBAY29tcHV0ZSBAd29ya2dyb3VwX3NpemUoJHt3b3JrZ3JvdXBTaXplWH0sICR7d29ya2dyb3VwU2l6ZVl9LCAke3dvcmtncm91cFNpemVafSlcbiAgZm4gbWFpbigke3BhcmFtTGlzdH0pIHtcbiAgICAke2dsb2JhbElkeERlZmluaXRpb259XG4gIGA7XG4gIH1cblxuICBwcml2YXRlIGFwcGVuZFZhcmlhYmxlVW5pZm9ybXModmFyaWFibGU6IEluZGljZXNIZWxwZXIpOiB2b2lkIHtcbiAgICBpZiAodmFyaWFibGUucmFuayAhPT0gMCkge1xuICAgICAgaWYgKHZhcmlhYmxlLnNoYXBlLnN0YXJ0c1dpdGgoJ3VuaWZvcm1zLicpKSB7XG4gICAgICAgIHRoaXMudW5pZm9ybXMucHVzaCh7bmFtZTogdmFyaWFibGUuc2hhcGUucmVwbGFjZSgndW5pZm9ybXMuJywgJycpLCB0eXBlOiAndTMyJywgbGVuZ3RoOiB2YXJpYWJsZS5yYW5rfSk7XG4gICAgICB9XG4gICAgICBpZiAodmFyaWFibGUuc3RyaWRlcy5zdGFydHNXaXRoKCd1bmlmb3Jtcy4nKSkge1xuICAgICAgICB0aGlzLnVuaWZvcm1zLnB1c2goe25hbWU6IHZhcmlhYmxlLnN0cmlkZXMucmVwbGFjZSgndW5pZm9ybXMuJywgJycpLCB0eXBlOiAndTMyJywgbGVuZ3RoOiB2YXJpYWJsZS5yYW5rfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBkZWNsYXJlVmFyaWFibGUodmFyaWFibGU6IEluZGljZXNIZWxwZXIsIGJpbmRpbmdJbmRleDogbnVtYmVyKTogc3RyaW5nIHtcbiAgICBpZiAodmFyaWFibGUudXNhZ2UgPT09ICdpbnRlcm5hbCcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignY2Fubm90IHVzZSBpbnRlcm5hbCB2YXJpYWJsZSB3aXRoIGRlY2xhcmVWYXJpYWJsZSgpLiB1c2UgcmVnaXN0ZXJJbnRlcm5hbFZhcmlhYmxlcygpIGluc3RlYWQuJyk7XG4gICAgfVxuICAgIHRoaXMudmFyaWFibGVzLnB1c2godmFyaWFibGUpO1xuICAgIHRoaXMuYXBwZW5kVmFyaWFibGVVbmlmb3Jtcyh2YXJpYWJsZSk7XG5cbiAgICBjb25zdCBhY2Nlc3MgPSB2YXJpYWJsZS51c2FnZSA9PT0gJ2lucHV0JyA/ICdyZWFkJyA6ICdyZWFkX3dyaXRlJztcbiAgICBjb25zdCBzdG9yYWdlVHlwZSA9IHZhcmlhYmxlLnR5cGUuc3RvcmFnZTtcbiAgICByZXR1cm4gYEBncm91cCgwKSBAYmluZGluZygke2JpbmRpbmdJbmRleH0pIHZhcjxzdG9yYWdlLCAke2FjY2Vzc30+ICR7dmFyaWFibGUubmFtZX06IGFycmF5PCR7c3RvcmFnZVR5cGV9PjtgO1xuICB9XG5cbiAgZGVjbGFyZVZhcmlhYmxlcyguLi52YXJpYWJsZXM6IEluZGljZXNIZWxwZXJbXSk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHZhcmlhYmxlcy5tYXAodiA9PiB0aGlzLmRlY2xhcmVWYXJpYWJsZSh2LCB0aGlzLnZhcmlhYmxlSW5kZXgrKykpLmpvaW4oJ1xcbicpO1xuICB9XG5cbiAgcHJpdmF0ZSByZWdpc3RlckludGVybmFsVmFyaWFibGUodmFyaWFibGU6IEluZGljZXNIZWxwZXIpOiB2b2lkIHtcbiAgICBpZiAodmFyaWFibGUudXNhZ2UgIT09ICdpbnRlcm5hbCcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAnY2Fubm90IHVzZSBpbnB1dCBvciBvdXRwdXQgdmFyaWFibGUgd2l0aCByZWdpc3RlckludGVybmFsVmFyaWFibGUoKS4gdXNlIGRlY2xhcmVWYXJpYWJsZXMoKSBpbnN0ZWFkLicpO1xuICAgIH1cblxuICAgIHRoaXMuaW50ZXJuYWxWYXJpYWJsZXMucHVzaCh2YXJpYWJsZSk7XG4gICAgdGhpcy5hcHBlbmRWYXJpYWJsZVVuaWZvcm1zKHZhcmlhYmxlKTtcbiAgfVxuXG4gIHJlZ2lzdGVySW50ZXJuYWxWYXJpYWJsZXMoLi4udmFyaWFibGVzOiBJbmRpY2VzSGVscGVyW10pOiBTaGFkZXJIZWxwZXIge1xuICAgIHZhcmlhYmxlcy5mb3JFYWNoKHYgPT4gdGhpcy5yZWdpc3RlckludGVybmFsVmFyaWFibGUodikpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgcmVnaXN0ZXJVbmlmb3JtKG5hbWU6IHN0cmluZywgdHlwZTogVW5pZm9ybURhdGFFbGVtZW50VHlwZSwgbGVuZ3RoID0gMSk6IFNoYWRlckhlbHBlciB7XG4gICAgdGhpcy51bmlmb3Jtcy5wdXNoKHtuYW1lLCB0eXBlLCBsZW5ndGh9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHJlZ2lzdGVyVW5pZm9ybXMoYWRkaXRpb25hbFVuaWZvcm1zOiBVbmlmb3Jtc0FycmF5VHlwZSk6IFNoYWRlckhlbHBlciB7XG4gICAgdGhpcy51bmlmb3JtcyA9IHRoaXMudW5pZm9ybXMuY29uY2F0KGFkZGl0aW9uYWxVbmlmb3Jtcyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBwcml2YXRlIGludGVybmFsVmFyaWFibGVzOiBJbmRpY2VzSGVscGVyW10gPSBbXTtcbiAgcHJpdmF0ZSB2YXJpYWJsZXM6IEluZGljZXNIZWxwZXJbXSA9IFtdO1xuICBwcml2YXRlIHVuaWZvcm1zOiBVbmlmb3Jtc0FycmF5VHlwZSA9IFtdO1xuICBwcml2YXRlIHVuaWZvcm1EZWNsYXJhdGlvbigpOiBzdHJpbmcge1xuICAgIGlmICh0aGlzLnVuaWZvcm1zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cblxuICAgIGNvbnN0IHVuaWZvcm1TbmlwcGV0czogc3RyaW5nW10gPSBbXTtcbiAgICBmb3IgKGNvbnN0IHtuYW1lLCB0eXBlLCBsZW5ndGh9IG9mIHRoaXMudW5pZm9ybXMpIHtcbiAgICAgIGlmIChsZW5ndGggJiYgbGVuZ3RoID4gNCkge1xuICAgICAgICB1bmlmb3JtU25pcHBldHMucHVzaChgJHtuYW1lfTphcnJheTx2ZWM0PCR7dHlwZX0+LCAke01hdGguY2VpbChsZW5ndGggLyA0KX0+YCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCB0eXBlVGVtcCA9IGxlbmd0aCA9PSBudWxsIHx8IGxlbmd0aCA9PT0gMSA/IHR5cGUgOiBgdmVjJHtsZW5ndGh9PCR7dHlwZX0+YDtcbiAgICAgICAgdW5pZm9ybVNuaXBwZXRzLnB1c2goYCR7bmFtZX06JHt0eXBlVGVtcH1gKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gYFxuICAgICAgc3RydWN0IFVuaWZvcm1zIHsgJHt1bmlmb3JtU25pcHBldHMuam9pbignLCAnKX0gfTtcbiAgICAgIEBncm91cCgwKSBAYmluZGluZygke3RoaXMudmFyaWFibGVJbmRleH0pIHZhcjx1bmlmb3JtPiB1bmlmb3JtczogVW5pZm9ybXM7YDtcbiAgfVxuICBwcml2YXRlIHZhcmlhYmxlSW5kZXggPSAwO1xuXG4gIC8qKlxuICAgKiBHZXQgYWRkaXRpb25hbCBpbXBsZW1lbnRhdGlvbiB0aGF0IG5lZWRzIHRvIGJlIGFkZGVkIHRvIHRoZSBzaGFkZXIgc291cmNlLlxuICAgKi9cbiAgZ2V0IGFkZGl0aW9uYWxJbXBsZW1lbnRhdGlvbnMoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3JtRGVjbGFyYXRpb24oKSArIHRoaXMudmFyaWFibGVzLm1hcChpID0+IGkuaW1wbCgpKS5qb2luKCdcXG4nKSArXG4gICAgICAgIHRoaXMuaW50ZXJuYWxWYXJpYWJsZXMubWFwKGkgPT4gaS5pbXBsKCkpLmpvaW4oJ1xcbicpO1xuICB9XG59XG5cbmV4cG9ydCBjb25zdCBjcmVhdGVTaGFkZXJIZWxwZXIgPSAoZGlzcGF0Y2hHcm91cDogW251bWJlciwgbnVtYmVyLCBudW1iZXJdKSA9PiBuZXcgU2hhZGVySGVscGVySW1wbChkaXNwYXRjaEdyb3VwKTtcblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGNvbWVzIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL3RlbnNvcmZsb3cvdGZqcy9ibG9iL21hc3Rlci90ZmpzLWNvcmUvc3JjL29wcy9icm9hZGNhc3RfdXRpbC50cyNMMTgtTDQwXG4gKiBSZXR1cm5zIHRoZSBkaW1lbnNpb25zIGluIHRoZSBpbnB1dCBzaGFwZSB0aGF0IGFyZSBicm9hZGNhc3RlZCB0b1xuICogcHJvZHVjZSB0aGUgcHJvdmlkZWQgb3V0cHV0IHNoYXBlLlxuICpcbiAqIFRoZSByZXR1cm5lZCBkaW1lbnNpb25zIGFyZSAwLWluZGV4ZWQgYW5kIHNvcnRlZC4gQW4gZXhhbXBsZTpcbiAqIGluU2hhcGUgPSBbNCwgMSwgM11cbiAqIG91dFNoYXBlID0gWzUsIDQsIDMsIDNdXG4gKiByZXN1bHQgPSBbMV0uIERpbWVuc2lvbiAxICgybmQgZGltZW5zaW9uIG9mIGlucHV0KSBnZXRzIGJyb2FkY2FzdGVkIDEgPT4gMy5cbiAqL1xuZXhwb3J0IGNvbnN0IGdldEJyb2FkY2FzdERpbXMgPSAoaW5TaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sIG91dFNoYXBlOiByZWFkb25seSBudW1iZXJbXSk6IG51bWJlcltdID0+IHtcbiAgY29uc3QgaW5SYW5rID0gaW5TaGFwZS5sZW5ndGg7XG4gIGNvbnN0IGRpbXM6IG51bWJlcltdID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgaW5SYW5rOyBpKyspIHtcbiAgICBjb25zdCBkaW0gPSBpblJhbmsgLSAxIC0gaTtcbiAgICBjb25zdCBhID0gaW5TaGFwZVtkaW1dIHx8IDE7XG4gICAgY29uc3QgYiA9IG91dFNoYXBlW291dFNoYXBlLmxlbmd0aCAtIDEgLSBpXSB8fCAxO1xuICAgIGlmIChiID4gMSAmJiBhID09PSAxKSB7XG4gICAgICBkaW1zLnVuc2hpZnQoZGltKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRpbXM7XG59O1xuXG4vLyBUT0RPOiByZW1vdmUgdGhpcyB3aGVuIGFsbCByZWxhdGVkIHVzZXMgaGF2ZSBiZWVuIHJlbW92ZWQuXG5leHBvcnQgY29uc3QgZW5hYmxlU2hhcGVzVW5pZm9ybXMgPSAoX3Jhbms6IG51bWJlcik6IGJvb2xlYW4gPT4gdHJ1ZTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtUZW5zb3JWaWV3fSBmcm9tICcuLi8uLi90ZW5zb3Itdmlldyc7XG5pbXBvcnQge1NoYXBlVXRpbH0gZnJvbSAnLi4vLi4vdXRpbCc7XG5pbXBvcnQge0F0dHJpYnV0ZVdpdGhDYWNoZUtleSwgY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5fSBmcm9tICcuLi9hdHRyaWJ1dGUtd2l0aC1jYWNoZS1rZXknO1xuaW1wb3J0IHtDb21wdXRlQ29udGV4dCwgUHJvZ3JhbUluZm99IGZyb20gJy4uL3R5cGVzJztcblxuaW1wb3J0IHtjcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcywgZW5hYmxlU2hhcGVzVW5pZm9ybXMsIEluZGljZXNIZWxwZXIsIGlucHV0VmFyaWFibGUsIG91dHB1dFZhcmlhYmxlLCBTaGFkZXJIZWxwZXJ9IGZyb20gJy4vY29tbW9uJztcblxuZXhwb3J0IGludGVyZmFjZSBUcmFuc3Bvc2VBdHRyaWJ1dGVzIGV4dGVuZHMgQXR0cmlidXRlV2l0aENhY2hlS2V5IHtcbiAgcmVhZG9ubHkgcGVybTogbnVtYmVyW107XG59XG5cbmNvbnN0IHZhbGlkYXRlSW5wdXRzID0gKGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdKTogdm9pZCA9PiB7XG4gIGlmICghaW5wdXRzIHx8IGlucHV0cy5sZW5ndGggIT09IDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyYW5zcG9zZSByZXF1aXJlcyAxIGlucHV0LicpO1xuICB9XG59O1xuXG5jb25zdCBnZXRBZGp1c3RlZFBlcm0gPSAoaW5wdXRSYW5rOiBudW1iZXIsIHBlcm06IG51bWJlcltdKTogbnVtYmVyW10gPT5cbiAgICAocGVybSAmJiBwZXJtLmxlbmd0aCAhPT0gaW5wdXRSYW5rKSA/IFsuLi4obmV3IEFycmF5KGlucHV0UmFuaykua2V5cygpKV0ucmV2ZXJzZSgpIDogcGVybTtcblxuY29uc3QgZ2V0T3V0cHV0U2hhcGUgPSAoaW5wdXRTaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sIHBlcm06IG51bWJlcltdKTogcmVhZG9ubHkgbnVtYmVyW10gPT5cbiAgICBTaGFwZVV0aWwuc29ydEJhc2VkT25QZXJtKGlucHV0U2hhcGUsIGdldEFkanVzdGVkUGVybShpbnB1dFNoYXBlLmxlbmd0aCwgcGVybSkpO1xuXG5jb25zdCBwZXJtRnVuY3Rpb25Cb2R5ID0gKHBlcm06IG51bWJlcltdLCByYW5rOiBudW1iZXIsIGlucHV0OiBJbmRpY2VzSGVscGVyLCBvdXRwdXQ6IEluZGljZXNIZWxwZXIpOiBzdHJpbmcgPT4ge1xuICBjb25zdCByZXZlcnNlRnVuYyA9IFtdO1xuICByZXZlcnNlRnVuYy5wdXNoKGBmbiBwZXJtKGk6ICR7b3V0cHV0LnR5cGUuaW5kaWNlc30pIC0+ICR7aW5wdXQudHlwZS5pbmRpY2VzfSB7XG4gICAgdmFyIGE6ICR7aW5wdXQudHlwZS5pbmRpY2VzfTtgKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCByYW5rOyArK2kpIHtcbiAgICByZXZlcnNlRnVuYy5wdXNoKGlucHV0LmluZGljZXNTZXQoJ2EnLCBwZXJtW2ldLCBgaVske2l9XWApKTtcbiAgfVxuICByZXZlcnNlRnVuYy5wdXNoKCdyZXR1cm4gYTt9Jyk7XG4gIHJldHVybiByZXZlcnNlRnVuYy5qb2luKCdcXG4nKTtcbn07XG5cbmV4cG9ydCBjb25zdCBjcmVhdGVUcmFuc3Bvc2VQcm9ncmFtSW5mbyA9IChpbnB1dFRlbnNvcjogVGVuc29yVmlldywgcGVybUF0dHI6IG51bWJlcltdKTogUHJvZ3JhbUluZm8gPT4ge1xuICBjb25zdCBpbnB1dERhdGFUeXBlID0gaW5wdXRUZW5zb3IuZGF0YVR5cGU7XG4gIGNvbnN0IGlucHV0UmFuayA9IGlucHV0VGVuc29yLmRpbXMubGVuZ3RoO1xuICBjb25zdCBwZXJtID0gZ2V0QWRqdXN0ZWRQZXJtKGlucHV0UmFuaywgcGVybUF0dHIpO1xuICBjb25zdCB1c2VTaGFwZXNVbmlmb3JtcyA9IGVuYWJsZVNoYXBlc1VuaWZvcm1zKGlucHV0UmFuayk7XG4gIGNvbnN0IG91dHB1dFNoYXBlID0gZ2V0T3V0cHV0U2hhcGUoaW5wdXRUZW5zb3IuZGltcywgcGVybSk7XG4gIGNvbnN0IG91dFNoYXBlT3JSYW5rID0gdXNlU2hhcGVzVW5pZm9ybXMgPyBvdXRwdXRTaGFwZS5sZW5ndGggOiBvdXRwdXRTaGFwZTtcbiAgY29uc3QgaW5TaGFwZU9yUmFuayA9IHVzZVNoYXBlc1VuaWZvcm1zID8gaW5wdXRSYW5rIDogaW5wdXRUZW5zb3IuZGltcztcbiAgY29uc3Qgb3V0cHV0ID0gb3V0cHV0VmFyaWFibGUoJ291dHB1dCcsIGlucHV0RGF0YVR5cGUsIG91dFNoYXBlT3JSYW5rKTtcbiAgY29uc3QgaW5wdXQgPSBpbnB1dFZhcmlhYmxlKCdhJywgaW5wdXREYXRhVHlwZSwgaW5TaGFwZU9yUmFuayk7XG5cbiAgY29uc3QgZ2V0U2hhZGVyU291cmNlID0gKHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyKSA9PiBgXG4gICR7c2hhZGVySGVscGVyLnJlZ2lzdGVyVW5pZm9ybSgnb3V0cHV0X3NpemUnLCAndTMyJykuZGVjbGFyZVZhcmlhYmxlcyhpbnB1dCwgb3V0cHV0KX1cblxuICAke3Blcm1GdW5jdGlvbkJvZHkocGVybSwgaW5wdXRSYW5rLCBpbnB1dCwgb3V0cHV0KX1cblxuICAke3NoYWRlckhlbHBlci5tYWluU3RhcnQoKX1cbiAgICAke3NoYWRlckhlbHBlci5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKCd1bmlmb3Jtcy5vdXRwdXRfc2l6ZScpfVxuXG4gICAgbGV0IGluZGljZXMgPSAke291dHB1dC5vZmZzZXRUb0luZGljZXMoJ2dsb2JhbF9pZHgnKX07XG4gICAgbGV0IGFJbmRpY2VzID0gcGVybShpbmRpY2VzKTtcblxuICAgICR7b3V0cHV0LnNldEJ5T2Zmc2V0KCdnbG9iYWxfaWR4JywgaW5wdXQuZ2V0QnlJbmRpY2VzKCdhSW5kaWNlcycpKX1cbiAgfWA7XG4gIHJldHVybiB7XG4gICAgbmFtZTogJ1RyYW5zcG9zZScsXG4gICAgc2hhZGVyQ2FjaGU6IHtoaW50OiBgJHtwZXJtQXR0cn1gLCBpbnB1dERlcGVuZGVuY2llczogdXNlU2hhcGVzVW5pZm9ybXMgPyBbJ3JhbmsnXSA6IFsnZGltcyddfSxcbiAgICBnZXRSdW5EYXRhOiAoaW5wdXRzKSA9PiB7XG4gICAgICBjb25zdCBvdXRwdXRTaXplID0gU2hhcGVVdGlsLnNpemUob3V0cHV0U2hhcGUpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgb3V0cHV0czogW3tkaW1zOiBvdXRwdXRTaGFwZSwgZGF0YVR5cGU6IGlucHV0c1swXS5kYXRhVHlwZX1dLFxuICAgICAgICBkaXNwYXRjaEdyb3VwOiB7eDogTWF0aC5jZWlsKG91dHB1dFNpemUgLyA2NCAvKiB3b3JrZ3JvdXAgc2l6ZSAqLyl9LFxuICAgICAgICBwcm9ncmFtVW5pZm9ybXM6IHVzZVNoYXBlc1VuaWZvcm1zID9cbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAge3R5cGU6ICd1aW50MzInLCBkYXRhOiBvdXRwdXRTaXplfSxcbiAgICAgICAgICAgICAgLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMoaW5wdXRzWzBdLmRpbXMpLFxuICAgICAgICAgICAgICAuLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhvdXRwdXRTaGFwZSksXG4gICAgICAgICAgICBdIDpcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAge3R5cGU6ICd1aW50MzInLCBkYXRhOiBvdXRwdXRTaXplfSxcbiAgICAgICAgICAgIF0sXG4gICAgICB9O1xuICAgIH0sXG4gICAgZ2V0U2hhZGVyU291cmNlLFxuICB9O1xufTtcblxuZXhwb3J0IGNvbnN0IHRyYW5zcG9zZSA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogVHJhbnNwb3NlQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICB2YWxpZGF0ZUlucHV0cyhjb250ZXh0LmlucHV0cyk7XG4gIGNvbnRleHQuY29tcHV0ZShjcmVhdGVUcmFuc3Bvc2VQcm9ncmFtSW5mbyhjb250ZXh0LmlucHV0c1swXSwgYXR0cmlidXRlcy5wZXJtKSk7XG59O1xuXG5leHBvcnQgY29uc3QgcGFyc2VUcmFuc3Bvc2VBdHRyaWJ1dGVzID0gKGF0dHJpYnV0ZXM6IFJlY29yZDxzdHJpbmcsIHVua25vd24+KTogVHJhbnNwb3NlQXR0cmlidXRlcyA9PlxuICAgIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSh7cGVybTogYXR0cmlidXRlcy5wZXJtIGFzIG51bWJlcltdfSk7XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7RGF0YVR5cGV9IGZyb20gJy4uLy4uLy4uL3dhc20tY29tbW9uJztcbmltcG9ydCB7VGVuc29yVmlld30gZnJvbSAnLi4vLi4vdGVuc29yLXZpZXcnO1xuaW1wb3J0IHtTaGFwZVV0aWx9IGZyb20gJy4uLy4uL3V0aWwnO1xuaW1wb3J0IHtDb21wdXRlQ29udGV4dCwgUHJvZ3JhbUluZm8sIFByb2dyYW1TaGFkZXJDYWNoZUluZm99IGZyb20gJy4uL3R5cGVzJztcblxuaW1wb3J0IHtpbnB1dFZhcmlhYmxlLCBvdXRwdXRWYXJpYWJsZSwgU2hhZGVySGVscGVyfSBmcm9tICcuL2NvbW1vbic7XG5pbXBvcnQge2NyZWF0ZVJlZHVjZUF0dHJpYnV0ZXNGcm9tSW5wdXRzLCBSZWR1Y2VBdHRyaWJ1dGVzfSBmcm9tICcuL3JlZHVjZSc7XG5pbXBvcnQge2NyZWF0ZVRyYW5zcG9zZVByb2dyYW1JbmZvfSBmcm9tICcuL3RyYW5zcG9zZSc7XG5cbmNvbnN0IHJlZHVjZU9wczoge1trZXk6IHN0cmluZ106IHN0cmluZ30gPSB7XG4gIG1heDogJ3NlbGVjdChiZXN0VmFsdWUsIGNhbmRpZGF0ZSwgY2FuZGlkYXRlID4gYmVzdFZhbHVlKScsXG4gIG1pbjogJ3NlbGVjdChiZXN0VmFsdWUsIGNhbmRpZGF0ZSwgY2FuZGlkYXRlIDwgYmVzdFZhbHVlKScsXG4gIG1lYW46ICdiZXN0VmFsdWUgKyBjYW5kaWRhdGUnLFxuICBzdW06ICdiZXN0VmFsdWUgKyBjYW5kaWRhdGUnLFxuICBwcm9kOiAnYmVzdFZhbHVlICogY2FuZGlkYXRlJyxcbiAgc3VtU3F1YXJlOiAnYmVzdFZhbHVlICsgY2FuZGlkYXRlICogY2FuZGlkYXRlJyxcbiAgbG9nU3VtRXhwOiAnYmVzdFZhbHVlICsgZXhwKGNhbmRpZGF0ZSknLFxuICBsMTogJ2Jlc3RWYWx1ZSArIGFicyhjYW5kaWRhdGUpJyxcbiAgbDI6ICdiZXN0VmFsdWUgKyBjYW5kaWRhdGUgKiBjYW5kaWRhdGUnLFxuICBsb2dTdW06ICdiZXN0VmFsdWUgKyBjYW5kaWRhdGUnXG59O1xuXG5jb25zdCByZWR1Y2VTaGFyZWRPcHM6IHtba2V5OiBzdHJpbmddOiBzdHJpbmd9ID0ge1xuICBtYXg6ICdzZWxlY3QoYmVzdFZhbHVlLCBjYW5kaWRhdGUsIGNhbmRpZGF0ZSA+IGJlc3RWYWx1ZSknLFxuICBtaW46ICdzZWxlY3QoYmVzdFZhbHVlLCBjYW5kaWRhdGUsIGNhbmRpZGF0ZSA8IGJlc3RWYWx1ZSknLFxuICBtZWFuOiAnYmVzdFZhbHVlICsgY2FuZGlkYXRlJyxcbiAgc3VtOiAnYmVzdFZhbHVlICsgY2FuZGlkYXRlJyxcbiAgcHJvZDogJ2Jlc3RWYWx1ZSAqIGNhbmRpZGF0ZScsXG4gIHN1bVNxdWFyZTogJ2Jlc3RWYWx1ZSArIGNhbmRpZGF0ZScsXG4gIGxvZ1N1bUV4cDogJ2Jlc3RWYWx1ZSArIGNhbmRpZGF0ZScsXG4gIGwxOiAnYmVzdFZhbHVlICsgY2FuZGlkYXRlJyxcbiAgbDI6ICdiZXN0VmFsdWUgKyBjYW5kaWRhdGUnLFxuICBsb2dTdW06ICdiZXN0VmFsdWUgKyBjYW5kaWRhdGUnXG59O1xuXG5jb25zdCByZWR1Y2VJbml0VmFsdWVzOiB7W2tleTogc3RyaW5nXTogc3RyaW5nfSA9IHtcbiAgbWF4OiAnX0Fbb2Zmc2V0XScsXG4gIG1pbjogJ19BW29mZnNldF0nLFxuICBtZWFuOiAnMCcsXG4gIHN1bTogJzAnLFxuICBwcm9kOiAnMScsXG4gIHN1bVNxdWFyZTogJzAnLFxuICBsb2dTdW1FeHA6ICcwJyxcbiAgbDE6ICcwJyxcbiAgbDI6ICcwJyxcbiAgbG9nU3VtOiAnMCdcbn07XG5cbmNvbnN0IHJlZHVjZU91dHB1dFZhbHVlczoge1trZXk6IHN0cmluZ106IHN0cmluZ30gPSB7XG4gIG1heDogJ2Jlc3RWYWx1ZScsXG4gIG1pbjogJ2Jlc3RWYWx1ZScsXG4gIHN1bTogJ2Jlc3RWYWx1ZScsXG4gIHByb2Q6ICdiZXN0VmFsdWUnLFxuICBzdW1TcXVhcmU6ICdiZXN0VmFsdWUnLFxuICBsb2dTdW1FeHA6ICdsb2coYmVzdFZhbHVlKScsXG4gIGwxOiAnYmVzdFZhbHVlJyxcbiAgbDI6ICdzcXJ0KGJlc3RWYWx1ZSknLFxuICBsb2dTdW06ICdsb2coYmVzdFZhbHVlKSdcbn07XG5cbmNvbnN0IGdldElubmVyTW9zdEF4ZXMgPSAobnVtSW5uZXJBeGVzOiBudW1iZXIsIHJhbms6IG51bWJlcik6IG51bWJlcltdID0+IHtcbiAgY29uc3QgcmVzID0gW107XG4gIGZvciAobGV0IGkgPSByYW5rIC0gbnVtSW5uZXJBeGVzOyBpIDwgcmFuazsgKytpKSB7XG4gICAgcmVzLnB1c2goaSk7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn07XG5cbmNvbnN0IGNvbXB1dGVPdXRBbmRSZWR1Y2VTaGFwZXMgPSAoc2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLCBheGVzOiByZWFkb25seSBudW1iZXJbXSk6IFtudW1iZXJbXSwgbnVtYmVyW11dID0+IHtcbiAgY29uc3Qgb3V0cHV0U2hhcGUgPSBbXTtcbiAgY29uc3QgcmFuayA9IHNoYXBlLmxlbmd0aDtcbiAgZm9yIChsZXQgZGltID0gMDsgZGltIDwgcmFuazsgZGltKyspIHtcbiAgICBpZiAoYXhlcy5pbmRleE9mKGRpbSkgPT09IC0xKSB7XG4gICAgICBvdXRwdXRTaGFwZS5wdXNoKHNoYXBlW2RpbV0pO1xuICAgIH1cbiAgfVxuICBjb25zdCByZWR1Y2VTaGFwZSA9IGF4ZXMubWFwKGRpbSA9PiBzaGFwZVtkaW1dKTtcbiAgcmV0dXJuIFtvdXRwdXRTaGFwZSwgcmVkdWNlU2hhcGVdO1xufTtcblxuY29uc3QgZXhwYW5kU2hhcGVUb0tlZXBEaW0gPSAoc2hhcGU6IG51bWJlcltdLCBheGVzOiBudW1iZXJbXSk6IG51bWJlcltdID0+IHtcbiAgY29uc3QgcmFuayA9IHNoYXBlLmxlbmd0aCArIGF4ZXMubGVuZ3RoO1xuICBjb25zdCBleHBhbmRTaGFwZSA9IFtdO1xuICBsZXQgc2hhcGVJZHggPSAwO1xuICBmb3IgKGxldCBkaW0gPSAwOyBkaW0gPCByYW5rOyBkaW0rKykge1xuICAgIGlmIChheGVzLmluZGV4T2YoZGltKSA9PT0gLTEpIHtcbiAgICAgIGV4cGFuZFNoYXBlLnB1c2goc2hhcGVbc2hhcGVJZHgrK10pO1xuICAgIH0gZWxzZSB7XG4gICAgICBleHBhbmRTaGFwZS5wdXNoKDEpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZXhwYW5kU2hhcGU7XG59O1xuXG5jb25zdCBhcmVBeGVzSW5uZXJNb3N0RGltcyA9IChheGVzOiBudW1iZXJbXSwgcmFuazogbnVtYmVyKTogYm9vbGVhbiA9PiB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYXhlcy5sZW5ndGg7ICsraSkge1xuICAgIGlmIChheGVzW2F4ZXMubGVuZ3RoIC0gaSAtIDFdICE9PSByYW5rIC0gMSAtIGkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5jb25zdCBnZXRBeGVzUGVybXV0YXRpb24gPSAoYXhlczogbnVtYmVyW10sIHJhbms6IG51bWJlcik6IG51bWJlcltdID0+IHtcbiAgY29uc3QgcmVzID0gW107XG4gIGlmICghYXJlQXhlc0lubmVyTW9zdERpbXMoYXhlcywgcmFuaykpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJhbms7ICsraSkge1xuICAgICAgaWYgKGF4ZXMuaW5kZXhPZihpKSA9PT0gLTEpIHtcbiAgICAgICAgcmVzLnB1c2goaSk7XG4gICAgICB9XG4gICAgfVxuICAgIGF4ZXMuZm9yRWFjaChheGlzID0+IHJlcy5wdXNoKGF4aXMpKTtcbiAgfVxuICByZXR1cm4gcmVzO1xufTtcblxuZXhwb3J0IGNvbnN0IGNyZWF0ZVJlZHVjZVNoYXJlZFByb2dyYW1JbmZvID1cbiAgICAobmFtZTogc3RyaW5nLCBzaGFkZXJDYWNoZTogUHJvZ3JhbVNoYWRlckNhY2hlSW5mbywgaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10sIHJlZHVjZVR5cGU6IHN0cmluZyxcbiAgICAgb3V0cHV0RGF0YVR5cGU6IERhdGFUeXBlLCBvdXRwdXRTaGFwZTogbnVtYmVyW10sIHJlZHVjZVNoYXBlOiBudW1iZXJbXSk6IFByb2dyYW1JbmZvID0+IHtcbiAgICAgIGNvbnN0IGlucHV0U2hhcGUgPSBpbnB1dHNbMF0uZGltcztcblxuICAgICAgY29uc3Qgb3V0cHV0U2l6ZSA9IFNoYXBlVXRpbC5zaXplKG91dHB1dFNoYXBlKTtcbiAgICAgIGNvbnN0IHJlZHVjZVNpemUgPSBTaGFwZVV0aWwuc2l6ZShyZWR1Y2VTaGFwZSk7XG5cbiAgICAgIGNvbnN0IGlucHV0ID0gaW5wdXRWYXJpYWJsZSgnX0EnLCBpbnB1dHNbMF0uZGF0YVR5cGUsIGlucHV0U2hhcGUpO1xuICAgICAgY29uc3Qgb3V0cHV0ID0gb3V0cHV0VmFyaWFibGUoJ291dHB1dCcsIG91dHB1dERhdGFUeXBlLCBvdXRwdXRTaGFwZSk7XG5cbiAgICAgIGNvbnN0IHdvcmtncm91cFNpemUgPSAzMjtcblxuICAgICAgY29uc3Qgc2hhcmVkTWVtb3J5U25pcHBldCA9IGBcbiAgICAgICAgICB2YXI8d29ya2dyb3VwPiBhQmVzdFZhbHVlcyA6IGFycmF5PCR7b3V0cHV0LnR5cGUuc3RvcmFnZX0sICR7d29ya2dyb3VwU2l6ZX0+O1xuICAgICAgIGA7XG5cbiAgICAgIGNvbnN0IGdldFNoYWRlclNvdXJjZSA9IChzaGFkZXJIZWxwZXI6IFNoYWRlckhlbHBlcikgPT4gYFxuICAgICAgICAke3NoYWRlckhlbHBlci5yZWdpc3RlclVuaWZvcm0oJ3JlZHVjZVNpemUnLCAndTMyJykuZGVjbGFyZVZhcmlhYmxlcyhpbnB1dCwgb3V0cHV0KX1cbiAgICAgICAgJHtzaGFyZWRNZW1vcnlTbmlwcGV0fVxuICAgICAgICBmbiBESVZfQ0VJTChhIDogdTMyLCBiIDogdTMyKSAtPiB1MzIge1xuICAgICAgICAgIHJldHVybiAoKGEgLSAxdSkgLyBiICsgMXUpO1xuICAgICAgICAgfVxuICAgICAgICAgJHtzaGFkZXJIZWxwZXIubWFpblN0YXJ0KHdvcmtncm91cFNpemUpfVxuXG4gICAgICAgICAgbGV0IG91dHB1dEluZGV4ID0gZ2xvYmFsX2lkeCAvICR7d29ya2dyb3VwU2l6ZX07XG4gICAgICAgICAgbGV0IG9mZnNldCA9IG91dHB1dEluZGV4ICogdW5pZm9ybXMucmVkdWNlU2l6ZTtcblxuICAgICAgICAgIHZhciBiZXN0VmFsdWUgPSAke291dHB1dC50eXBlLnN0b3JhZ2V9KCR7cmVkdWNlSW5pdFZhbHVlc1tyZWR1Y2VUeXBlXX0pO1xuICAgICAgICAgIGxldCBMZW5ndGggPSB1bmlmb3Jtcy5yZWR1Y2VTaXplO1xuICAgICAgICAgIGZvciAodmFyIGsgPSBsb2NhbF9pZHg7IGsgPCBMZW5ndGg7IGsgPSBrICsgJHt3b3JrZ3JvdXBTaXplfSkge1xuICAgICAgICAgICBsZXQgY2FuZGlkYXRlID0gJHtvdXRwdXQudHlwZS5zdG9yYWdlfSgke2lucHV0LmdldEJ5T2Zmc2V0KCdvZmZzZXQgKyBrJyl9KTtcbiAgICAgICAgICAgYmVzdFZhbHVlID0gJHtyZWR1Y2VPcHNbcmVkdWNlVHlwZV19O1xuICAgICAgICAgIH1cbiAgICAgICAgICBhQmVzdFZhbHVlc1tsb2NhbF9pZHhdID0gYmVzdFZhbHVlO1xuICAgICAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcblxuICAgICAgICAgdmFyIHJlZHVjZVNpemUgPSBtaW4oTGVuZ3RoLCAke3dvcmtncm91cFNpemV9dSk7XG4gICAgICAgICBmb3IgKHZhciBjdXJyZW50U2l6ZSA9IHJlZHVjZVNpemUgLyAydTsgcmVkdWNlU2l6ZSA+IDF1O1xuICAgICAgICAgICAgIGN1cnJlbnRTaXplID0gcmVkdWNlU2l6ZSAvIDJ1KSB7XG4gICAgICAgICAgIGxldCBpbnRlcnZhbCA9IERJVl9DRUlMKHJlZHVjZVNpemUsIDJ1KTtcbiAgICAgICAgICAgaWYgKGxvY2FsX2lkeCA8IGN1cnJlbnRTaXplKSB7XG4gICAgICAgICAgICBsZXQgY2FuZGlkYXRlID0gYUJlc3RWYWx1ZXNbbG9jYWxfaWR4ICsgaW50ZXJ2YWxdO1xuICAgICAgICAgICAgYmVzdFZhbHVlID0gJHtyZWR1Y2VTaGFyZWRPcHNbcmVkdWNlVHlwZV19O1xuICAgICAgICAgICAgYUJlc3RWYWx1ZXNbbG9jYWxfaWR4XSA9IGJlc3RWYWx1ZTtcbiAgICAgICAgICAgfVxuICAgICAgICAgICByZWR1Y2VTaXplID0gaW50ZXJ2YWw7XG4gICAgICAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcbiAgICAgICAgIH1cblxuICAgICAgICAgaWYgKGxvY2FsX2lkeCA9PSAwdSkge1xuICAgICAgICAgICR7XG4gICAgICAgICAgb3V0cHV0LnNldEJ5T2Zmc2V0KFxuICAgICAgICAgICAgICAnb3V0cHV0SW5kZXgnLFxuICAgICAgICAgICAgICBgJHtcbiAgICAgICAgICAgICAgICAgIHJlZHVjZVR5cGUgPT09ICdtZWFuJyA/IGBiZXN0VmFsdWUgLyAke291dHB1dC50eXBlLnN0b3JhZ2V9KHVuaWZvcm1zLnJlZHVjZVNpemUpYCA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgJHtyZWR1Y2VPdXRwdXRWYWx1ZXNbcmVkdWNlVHlwZV19YH1gKX07XG4gICAgICAgICB9XG4gICAgICAgIH1gO1xuXG4gICAgICAvLyBPbmUgd29yayBncm91cCBpcyByZXNwb25zaWJsZSBmb3Igb25seSBvbmUgZWxlbWVudCBvZiBvdXRwdXQuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBuYW1lLFxuICAgICAgICBzaGFkZXJDYWNoZSxcbiAgICAgICAgZ2V0U2hhZGVyU291cmNlLFxuICAgICAgICBnZXRSdW5EYXRhOiAoKSA9PiAoe1xuICAgICAgICAgIG91dHB1dHM6IFt7ZGltczogb3V0cHV0U2hhcGUsIGRhdGFUeXBlOiBvdXRwdXREYXRhVHlwZX1dLFxuICAgICAgICAgIGRpc3BhdGNoR3JvdXA6IHt4OiBvdXRwdXRTaXplfSxcbiAgICAgICAgICBwcm9ncmFtVW5pZm9ybXM6IFt7dHlwZTogJ3VpbnQzMicsIGRhdGE6IHJlZHVjZVNpemV9XVxuICAgICAgICB9KSxcbiAgICAgIH07XG4gICAgfTtcblxuY29uc3QgcmVkdWNlQ29tbW9uID1cbiAgICAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIG5hbWU6IHN0cmluZywgYXR0cmlidXRlczogUmVkdWNlQXR0cmlidXRlcyxcbiAgICAgcmVkdWNlVHlwZTogJ3N1bSd8J3N1bVNxdWFyZSd8J3Byb2QnfCdtaW4nfCdtYXgnfCdtZWFuJ3wnbG9nU3VtRXhwJ3wnbDEnfCdsMid8J2xvZ1N1bScpOiB2b2lkID0+IHtcbiAgICAgIGNvbnN0IHVwZGF0ZWRBdHRyaWJ1dGVzOiBSZWR1Y2VBdHRyaWJ1dGVzID1cbiAgICAgICAgICBjb250ZXh0LmlucHV0cy5sZW5ndGggPT09IDEgPyBhdHRyaWJ1dGVzIDogY3JlYXRlUmVkdWNlQXR0cmlidXRlc0Zyb21JbnB1dHMoY29udGV4dC5pbnB1dHMsIGF0dHJpYnV0ZXMpO1xuXG4gICAgICBsZXQgdXBkYXRlZEF4ZXMgPSB1cGRhdGVkQXR0cmlidXRlcy5heGVzO1xuICAgICAgaWYgKHVwZGF0ZWRBeGVzLmxlbmd0aCA9PT0gMCAmJiAhdXBkYXRlZEF0dHJpYnV0ZXMubm9vcFdpdGhFbXB0eUF4ZXMpIHtcbiAgICAgICAgdXBkYXRlZEF4ZXMgPSBjb250ZXh0LmlucHV0c1swXS5kaW1zLm1hcCgoX2RpbSwgaSkgPT4gaSk7XG4gICAgICB9XG4gICAgICBjb25zdCBub3JtYWxpemVBeGVzID0gU2hhcGVVdGlsLm5vcm1hbGl6ZUF4ZXModXBkYXRlZEF4ZXMsIGNvbnRleHQuaW5wdXRzWzBdLmRpbXMubGVuZ3RoKTtcblxuICAgICAgbGV0IGF4ZXMgPSBub3JtYWxpemVBeGVzO1xuICAgICAgbGV0IGlucHV0ID0gY29udGV4dC5pbnB1dHNbMF07XG4gICAgICBjb25zdCBwZXJtdXRlZEF4ZXMgPSBnZXRBeGVzUGVybXV0YXRpb24oYXhlcywgY29udGV4dC5pbnB1dHNbMF0uZGltcy5sZW5ndGgpO1xuICAgICAgaWYgKHBlcm11dGVkQXhlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGlucHV0ID0gY29udGV4dC5jb21wdXRlKFxuICAgICAgICAgICAgY3JlYXRlVHJhbnNwb3NlUHJvZ3JhbUluZm8oY29udGV4dC5pbnB1dHNbMF0sIHBlcm11dGVkQXhlcyksIHtpbnB1dHM6IFswXSwgb3V0cHV0czogWy0xXX0pWzBdO1xuICAgICAgICBheGVzID0gZ2V0SW5uZXJNb3N0QXhlcyhheGVzLmxlbmd0aCwgaW5wdXQuZGltcy5sZW5ndGgpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBbb3V0cHV0U2hhcGUsIHJlZHVjZVNoYXBlXSA9IGNvbXB1dGVPdXRBbmRSZWR1Y2VTaGFwZXMoaW5wdXQuZGltcywgYXhlcyk7XG4gICAgICBsZXQgZmluYWxPdXRwdXRTaGFwZSA9IG91dHB1dFNoYXBlO1xuICAgICAgaWYgKHVwZGF0ZWRBdHRyaWJ1dGVzLmtlZXBEaW1zKSB7XG4gICAgICAgIGZpbmFsT3V0cHV0U2hhcGUgPSBleHBhbmRTaGFwZVRvS2VlcERpbShvdXRwdXRTaGFwZSwgbm9ybWFsaXplQXhlcyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnRleHQuY29tcHV0ZShcbiAgICAgICAgICBjcmVhdGVSZWR1Y2VTaGFyZWRQcm9ncmFtSW5mbyhcbiAgICAgICAgICAgICAgbmFtZSwge2hpbnQ6IHVwZGF0ZWRBdHRyaWJ1dGVzLmNhY2hlS2V5LCBpbnB1dERlcGVuZGVuY2llczogWyd0eXBlJ119LCBbaW5wdXRdLCByZWR1Y2VUeXBlLFxuICAgICAgICAgICAgICBjb250ZXh0LmlucHV0c1swXS5kYXRhVHlwZSwgZmluYWxPdXRwdXRTaGFwZSwgcmVkdWNlU2hhcGUpLFxuICAgICAgICAgIHtpbnB1dHM6IFtpbnB1dF19KTtcbiAgICB9O1xuXG5leHBvcnQgY29uc3QgcmVkdWNlTWVhblNoYXJlZCA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogUmVkdWNlQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICByZWR1Y2VDb21tb24oY29udGV4dCwgJ1JlZHVjZU1lYW5TaGFyZWQnLCBhdHRyaWJ1dGVzLCAnbWVhbicpO1xufTtcblxuZXhwb3J0IGNvbnN0IHJlZHVjZUwxU2hhcmVkID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBSZWR1Y2VBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIHJlZHVjZUNvbW1vbihjb250ZXh0LCAnUmVkdWNlTDFTaGFyZWQnLCBhdHRyaWJ1dGVzLCAnbDEnKTtcbn07XG5cbmV4cG9ydCBjb25zdCByZWR1Y2VMMlNoYXJlZCA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogUmVkdWNlQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICByZWR1Y2VDb21tb24oY29udGV4dCwgJ1JlZHVjZUwyU2hhcmVkJywgYXR0cmlidXRlcywgJ2wyJyk7XG59O1xuXG5leHBvcnQgY29uc3QgcmVkdWNlTG9nU3VtRXhwU2hhcmVkID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBSZWR1Y2VBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIHJlZHVjZUNvbW1vbihjb250ZXh0LCAnUmVkdWNlTG9nU3VtRXhwU2hhcmVkJywgYXR0cmlidXRlcywgJ2xvZ1N1bUV4cCcpO1xufTtcblxuZXhwb3J0IGNvbnN0IHJlZHVjZU1heFNoYXJlZCA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogUmVkdWNlQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICByZWR1Y2VDb21tb24oY29udGV4dCwgJ1JlZHVjZU1heFNoYXJlZCcsIGF0dHJpYnV0ZXMsICdtYXgnKTtcbn07XG5cbmV4cG9ydCBjb25zdCByZWR1Y2VNaW5TaGFyZWQgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IFJlZHVjZUF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgcmVkdWNlQ29tbW9uKGNvbnRleHQsICdSZWR1Y2VNaW5TaGFyZWQnLCBhdHRyaWJ1dGVzLCAnbWluJyk7XG59O1xuXG5leHBvcnQgY29uc3QgcmVkdWNlUHJvZFNoYXJlZCA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogUmVkdWNlQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICByZWR1Y2VDb21tb24oY29udGV4dCwgJ1JlZHVjZVByb2RTaGFyZWQnLCBhdHRyaWJ1dGVzLCAncHJvZCcpO1xufTtcblxuZXhwb3J0IGNvbnN0IHJlZHVjZVN1bVNoYXJlZCA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogUmVkdWNlQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICByZWR1Y2VDb21tb24oY29udGV4dCwgJ1JlZHVjZVN1bVNoYXJlZCcsIGF0dHJpYnV0ZXMsICdzdW0nKTtcbn07XG5cbmV4cG9ydCBjb25zdCByZWR1Y2VTdW1TcXVhcmVTaGFyZWQgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IFJlZHVjZUF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgcmVkdWNlQ29tbW9uKGNvbnRleHQsICdSZWR1Y2VTdW1TcXVhcmVTaGFyZWQnLCBhdHRyaWJ1dGVzLCAnc3VtU3F1YXJlJyk7XG59O1xuXG5leHBvcnQgY29uc3QgcmVkdWNlTG9nU3VtU2hhcmVkID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBSZWR1Y2VBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIHJlZHVjZUNvbW1vbihjb250ZXh0LCAnUmVkdWNlTG9nU3VtU2hhcmVkJywgYXR0cmlidXRlcywgJ2xvZ1N1bScpO1xufTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtEYXRhVHlwZX0gZnJvbSAnLi4vLi4vLi4vd2FzbS1jb21tb24nO1xuaW1wb3J0IHtUZW5zb3JWaWV3fSBmcm9tICcuLi8uLi90ZW5zb3Itdmlldyc7XG5pbXBvcnQge1NoYXBlVXRpbH0gZnJvbSAnLi4vLi4vdXRpbCc7XG5pbXBvcnQge0F0dHJpYnV0ZVdpdGhDYWNoZUtleSwgY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5fSBmcm9tICcuLi9hdHRyaWJ1dGUtd2l0aC1jYWNoZS1rZXknO1xuaW1wb3J0IHtDb21wdXRlQ29udGV4dCwgUHJvZ3JhbUluZm8sIFByb2dyYW1TaGFkZXJDYWNoZUluZm99IGZyb20gJy4uL3R5cGVzJztcblxuaW1wb3J0IHtjcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcywgSW5kaWNlc0hlbHBlciwgaW5wdXRWYXJpYWJsZSwgb3V0cHV0VmFyaWFibGUsIFNoYWRlckhlbHBlcn0gZnJvbSAnLi9jb21tb24nO1xuaW1wb3J0IHtyZWR1Y2VMMVNoYXJlZCwgcmVkdWNlTDJTaGFyZWQsIHJlZHVjZUxvZ1N1bUV4cFNoYXJlZCwgcmVkdWNlTG9nU3VtU2hhcmVkLCByZWR1Y2VNYXhTaGFyZWQsIHJlZHVjZU1lYW5TaGFyZWQsIHJlZHVjZU1pblNoYXJlZCwgcmVkdWNlUHJvZFNoYXJlZCwgcmVkdWNlU3VtU2hhcmVkLCByZWR1Y2VTdW1TcXVhcmVTaGFyZWR9IGZyb20gJy4vcmVkdWNlLXNoYXJlZCc7XG5cbmNvbnN0IHZhbGlkYXRlSW5wdXRzID0gKGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdKTogdm9pZCA9PiB7XG4gIGlmICghaW5wdXRzIHx8IGlucHV0cy5sZW5ndGggPT09IDAgfHwgaW5wdXRzLmxlbmd0aCA+IDIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlZHVjZSBvcCByZXF1aXJlcyAxIG9yIDIgaW5wdXRzLicpO1xuICB9XG5cbiAgaWYgKGlucHV0cy5sZW5ndGggPT09IDIgJiYgaW5wdXRzWzFdLmRpbXMubGVuZ3RoICE9PSAxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGF4ZXMgaW5wdXQgZGltcy4nKTtcbiAgfVxufTtcblxuZXhwb3J0IGludGVyZmFjZSBSZWR1Y2VBdHRyaWJ1dGVzIGV4dGVuZHMgQXR0cmlidXRlV2l0aENhY2hlS2V5IHtcbiAga2VlcERpbXM6IGJvb2xlYW47XG4gIG5vb3BXaXRoRW1wdHlBeGVzOiBib29sZWFuO1xuICBheGVzOiBudW1iZXJbXTtcbn1cblxuZXhwb3J0IHR5cGUgUmVkdWNlT3AgPVxuICAgIChpbnB1dDogSW5kaWNlc0hlbHBlciwgb3V0cHV0OiBJbmRpY2VzSGVscGVyLFxuICAgICBheGVzOiByZWFkb25seSBudW1iZXJbXSkgPT4gW3N0cmluZywgc3RyaW5nLCBzdHJpbmcsIHN0cmluZywgLi4uc3RyaW5nW11dO1xuXG5jb25zdCBub09wOiBSZWR1Y2VPcCA9IChpbnB1dCkgPT4gWycnLCAnJywgYHZhciB2YWx1ZSA9ICR7aW5wdXQuZ2V0QnlJbmRpY2VzKCdpbnB1dF9pbmRpY2VzJyl9O2AsICcnXTtcbmV4cG9ydCBjb25zdCBjcmVhdGVSZWR1Y2VQcm9ncmFtSW5mbyA9XG4gICAgKG5hbWU6IHN0cmluZywgc2hhZGVyQ2FjaGU6IFByb2dyYW1TaGFkZXJDYWNoZUluZm8sIGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdLCByZWR1Y2VPcDogUmVkdWNlT3AsXG4gICAgIGF4ZXNJbnB1dDogbnVtYmVyW10sIG91dHB1dERhdGFUeXBlOiBEYXRhVHlwZSwga2VlcERpbXMgPSBmYWxzZSwgbm9vcFdpdGhFbXB0eUF4ZXMgPSBmYWxzZSk6IFByb2dyYW1JbmZvID0+IHtcbiAgICAgIGNvbnN0IG91dHB1dFNoYXBlOiBudW1iZXJbXSA9IFtdO1xuICAgICAgY29uc3QgaW5wdXRTaGFwZSA9IGlucHV0c1swXS5kaW1zO1xuICAgICAgY29uc3QgaW5wdXRSYW5rID0gaW5wdXRTaGFwZS5sZW5ndGg7XG4gICAgICBjb25zdCBheGVzID0gU2hhcGVVdGlsLm5vcm1hbGl6ZUF4ZXMoYXhlc0lucHV0LCBpbnB1dFJhbmspO1xuICAgICAgY29uc3QgcmVkdWNlT25BbGxBeGVzID0gIW5vb3BXaXRoRW1wdHlBeGVzICYmIGF4ZXMubGVuZ3RoID09PSAwO1xuICAgICAgaW5wdXRTaGFwZS5mb3JFYWNoKChkLCBpKSA9PiB7XG4gICAgICAgIGlmIChyZWR1Y2VPbkFsbEF4ZXMgfHwgYXhlcy5pbmRleE9mKGkpID49IDApIHtcbiAgICAgICAgICBpZiAoa2VlcERpbXMpIHtcbiAgICAgICAgICAgIG91dHB1dFNoYXBlLnB1c2goMSk7XG4gICAgICAgICAgfSAgLy8gZWxzZSB7IC8vIHNraXAgdGhpcyBheGlzfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG91dHB1dFNoYXBlLnB1c2goZCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgY29uc3Qgb3V0cHV0UmFuayA9IG91dHB1dFNoYXBlLmxlbmd0aDtcbiAgICAgIGNvbnN0IG91dHB1dFNpemUgPSBTaGFwZVV0aWwuc2l6ZShvdXRwdXRTaGFwZSk7XG4gICAgICBjb25zdCBnZXRTaGFkZXJTb3VyY2UgPSAoc2hhZGVySGVscGVyOiBTaGFkZXJIZWxwZXIpID0+IHtcbiAgICAgICAgY29uc3QgaWR4Q29weTogc3RyaW5nW10gPSBbXTsgIC8vIGNvcHkgb3V0cHV0IGluZGV4ZXMgdG8gaW5wdXQgaW5kZXhlc1xuXG4gICAgICAgIGNvbnN0IGlucHV0ID0gaW5wdXRWYXJpYWJsZSgnX0EnLCBpbnB1dHNbMF0uZGF0YVR5cGUsIGlucHV0UmFuayk7XG4gICAgICAgIGNvbnN0IG91dHB1dCA9IG91dHB1dFZhcmlhYmxlKCdvdXRwdXQnLCBvdXRwdXREYXRhVHlwZSwgb3V0cHV0UmFuayk7XG4gICAgICAgIGNvbnN0IG9wcyA9IHJlZHVjZU9wKGlucHV0LCBvdXRwdXQsIGF4ZXMpO1xuICAgICAgICBsZXQgcmVkdWNlT3BzID0gb3BzWzJdO1xuXG4gICAgICAgIGZvciAobGV0IGsgPSAwLCBsID0gMDsgayA8IGlucHV0UmFuazsgaysrKSB7XG4gICAgICAgICAgLy8gaWYgdGhpcyBheGlzIGlzIHJlZHVjZWRcbiAgICAgICAgICBpZiAocmVkdWNlT25BbGxBeGVzIHx8IGF4ZXMuaW5kZXhPZihrKSA+PSAwKSB7XG4gICAgICAgICAgICBpZiAoa2VlcERpbXMpIHtcbiAgICAgICAgICAgICAgbCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gbG9vcCBvdmVyIHRoZSBkLXRoIGF4aXNcbiAgICAgICAgICAgIHJlZHVjZU9wcyA9IGBmb3IodmFyIGoke2t9OiB1MzIgPSAwOyBqJHtrfSA8ICR7aW5wdXRTaGFwZVtrXX07IGoke2t9KyspIHtcbiAgICAgICAgICAgICAgICAgICR7b3BzWzJdLmluY2x1ZGVzKCdsYXN0X2luZGV4JykgPyBgbGV0IGxhc3RfaW5kZXggPSBqJHtrfTtgIDogJyd9XG4gICAgICAgICAgICAgICAgICAke2lucHV0LmluZGljZXNTZXQoJ2lucHV0X2luZGljZXMnLCBrLCBgaiR7a31gKX1cbiAgICAgICAgICAgICAgICAgICR7cmVkdWNlT3BzfVxuICAgICAgICAgICAgICAgIH1gO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZHhDb3B5LnB1c2goYCR7aW5wdXQuaW5kaWNlc1NldCgnaW5wdXRfaW5kaWNlcycsIGssIG91dHB1dC5pbmRpY2VzR2V0KCdvdXRwdXRfaW5kaWNlcycsIGwpKX07YCk7XG4gICAgICAgICAgICBsKys7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBgXG5cbiAgICAgICAgJHtzaGFkZXJIZWxwZXIucmVnaXN0ZXJVbmlmb3JtKCdvdXRwdXRfc2l6ZScsICd1MzInKS5kZWNsYXJlVmFyaWFibGVzKGlucHV0LCBvdXRwdXQpfVxuXG4gICAgICAgICR7c2hhZGVySGVscGVyLm1haW5TdGFydCgpfVxuICAgICAgICAgICR7c2hhZGVySGVscGVyLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoJ3VuaWZvcm1zLm91dHB1dF9zaXplJyl9XG4gICAgICAgICAgdmFyIGlucHV0X2luZGljZXM6ICR7aW5wdXQudHlwZS5pbmRpY2VzfTtcbiAgICAgICAgICBsZXQgb3V0cHV0X2luZGljZXMgPSAke291dHB1dC5vZmZzZXRUb0luZGljZXMoJ2dsb2JhbF9pZHgnKX07XG5cbiAgICAgICAgICAke2lkeENvcHkuam9pbignXFxuJyl9XG4gICAgICAgICAgJHtvcHNbMF19ICAgICAgIC8vIGluaXQgb3BzIGZvciByZWR1Y2UgbWF4L21pblxuICAgICAgICAgICR7b3BzWzFdfVxuICAgICAgICAgICR7cmVkdWNlT3BzfVxuICAgICAgICAgICR7b3BzWzNdfVxuICAgICAgICAgICR7b3BzLmxlbmd0aCA9PT0gNCA/IG91dHB1dC5zZXRCeU9mZnNldCgnZ2xvYmFsX2lkeCcsICd2YWx1ZScpIDogb3BzLnNsaWNlKDQpLmpvaW4oJ1xcbicpfVxuICAgICAgICB9YDtcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5hbWUsXG4gICAgICAgIHNoYWRlckNhY2hlLFxuICAgICAgICBnZXRTaGFkZXJTb3VyY2UsXG4gICAgICAgIGdldFJ1bkRhdGE6ICgpID0+ICh7XG4gICAgICAgICAgb3V0cHV0czogW3tkaW1zOiBvdXRwdXRTaGFwZSwgZGF0YVR5cGU6IG91dHB1dERhdGFUeXBlfV0sXG4gICAgICAgICAgZGlzcGF0Y2hHcm91cDoge3g6IE1hdGguY2VpbChvdXRwdXRTaXplIC8gNjQgLyogd29ya2dyb3VwIHNpemUgKi8pfSxcbiAgICAgICAgICBwcm9ncmFtVW5pZm9ybXM6IFtcbiAgICAgICAgICAgIHt0eXBlOiAndWludDMyJywgZGF0YTogb3V0cHV0U2l6ZX0sIC4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKGlucHV0U2hhcGUpLFxuICAgICAgICAgICAgLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMob3V0cHV0U2hhcGUpXG4gICAgICAgICAgXVxuICAgICAgICB9KSxcbiAgICAgIH07XG4gICAgfTtcblxuZXhwb3J0IGNvbnN0IGNyZWF0ZVJlZHVjZUF0dHJpYnV0ZXNGcm9tSW5wdXRzID1cbiAgICAoaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10sIGF0dHJpYnV0ZXM6IFJlZHVjZUF0dHJpYnV0ZXMpOiBSZWR1Y2VBdHRyaWJ1dGVzID0+IHtcbiAgICAgIGNvbnN0IGF4ZXM6IG51bWJlcltdID0gW107XG4gICAgICBpZiAoaW5wdXRzWzFdLmRpbXNbMF0gPiAwKSB7XG4gICAgICAgIGlucHV0c1sxXS5nZXRCaWdJbnQ2NEFycmF5KCkuZm9yRWFjaCh2ID0+IGF4ZXMucHVzaChOdW1iZXIodikpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkoXG4gICAgICAgICAge2F4ZXMsIGtlZXBEaW1zOiBhdHRyaWJ1dGVzLmtlZXBEaW1zLCBub29wV2l0aEVtcHR5QXhlczogYXR0cmlidXRlcy5ub29wV2l0aEVtcHR5QXhlc30pO1xuICAgIH07XG5cbmNvbnN0IHJ1blJlZHVjZVByb2dyYW0gPVxuICAgIChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgbmFtZTogc3RyaW5nLCBhdHRyaWJ1dGVzOiBSZWR1Y2VBdHRyaWJ1dGVzLCByZWR1Y2VPcDogUmVkdWNlT3ApOiB2b2lkID0+IHtcbiAgICAgIGNvbnN0IGlucHV0cyA9IGNvbnRleHQuaW5wdXRzO1xuICAgICAgY29uc3QgdXBkYXRlZEF0dHJpYnV0ZXM6IFJlZHVjZUF0dHJpYnV0ZXMgPVxuICAgICAgICAgIGlucHV0cy5sZW5ndGggPT09IDEgPyBhdHRyaWJ1dGVzIDogY3JlYXRlUmVkdWNlQXR0cmlidXRlc0Zyb21JbnB1dHMoaW5wdXRzLCBhdHRyaWJ1dGVzKTtcblxuICAgICAgY29udGV4dC5jb21wdXRlKFxuICAgICAgICAgIGNyZWF0ZVJlZHVjZVByb2dyYW1JbmZvKFxuICAgICAgICAgICAgICBuYW1lLCB7aGludDogdXBkYXRlZEF0dHJpYnV0ZXMuY2FjaGVLZXksIGlucHV0RGVwZW5kZW5jaWVzOiBbJ3JhbmsnXX0sIFtpbnB1dHNbMF1dLFxuICAgICAgICAgICAgICB1cGRhdGVkQXR0cmlidXRlcy5ub29wV2l0aEVtcHR5QXhlcyAmJiB1cGRhdGVkQXR0cmlidXRlcy5heGVzLmxlbmd0aCA9PT0gMCA/IG5vT3AgOiByZWR1Y2VPcCxcbiAgICAgICAgICAgICAgdXBkYXRlZEF0dHJpYnV0ZXMuYXhlcywgaW5wdXRzWzBdLmRhdGFUeXBlLCB1cGRhdGVkQXR0cmlidXRlcy5rZWVwRGltcyxcbiAgICAgICAgICAgICAgdXBkYXRlZEF0dHJpYnV0ZXMubm9vcFdpdGhFbXB0eUF4ZXMpLFxuICAgICAgICAgIHtpbnB1dHM6IFswXX0pO1xuICAgIH07XG5cbmNvbnN0IHJlZHVjZUxvZ1N1bU5haXZlID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBSZWR1Y2VBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIHZhbGlkYXRlSW5wdXRzKGNvbnRleHQuaW5wdXRzKTtcbiAgY29uc3QgcmVkdWNlT3A6IFJlZHVjZU9wID0gKGlucHV0LCBvdXRwdXQpID0+XG4gICAgICBbYHZhciB2YWx1ZSA9ICR7b3V0cHV0LnR5cGUuc3RvcmFnZX0oMCk7YCxcbiAgICAgICAnJyxcbiAgICAgICBgdmFsdWUgKz0gJHtpbnB1dC5nZXRCeUluZGljZXMoJ2lucHV0X2luZGljZXMnKX07YCxcbiAgICAgICAndmFsdWUgPSBsb2codmFsdWUpOycsXG4gIF07XG4gIHJ1blJlZHVjZVByb2dyYW0oY29udGV4dCwgJ1JlZHVjZUxvZ1N1bScsIGF0dHJpYnV0ZXMsIHJlZHVjZU9wKTtcbn07XG5cbmNvbnN0IHJlZHVjZUwxTmFpdmUgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IFJlZHVjZUF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgdmFsaWRhdGVJbnB1dHMoY29udGV4dC5pbnB1dHMpO1xuICBjb25zdCByZWR1Y2VPcDogUmVkdWNlT3AgPSAoaW5wdXQsIG91dHB1dCkgPT5cbiAgICAgIFtgdmFyIHZhbHVlID0gJHtvdXRwdXQudHlwZS5zdG9yYWdlfSgwKTtgLFxuICAgICAgICcnLFxuICAgICAgIGB2YWx1ZSArPSBhYnMoJHtpbnB1dC5nZXRCeUluZGljZXMoJ2lucHV0X2luZGljZXMnKX0pO2AsXG4gICAgICAgJycsXG4gIF07XG4gIHJ1blJlZHVjZVByb2dyYW0oY29udGV4dCwgJ1JlZHVjZUwxJywgYXR0cmlidXRlcywgcmVkdWNlT3ApO1xufTtcblxuY29uc3QgcmVkdWNlTDJOYWl2ZSA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogUmVkdWNlQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICB2YWxpZGF0ZUlucHV0cyhjb250ZXh0LmlucHV0cyk7XG4gIGNvbnN0IHJlZHVjZU9wOiBSZWR1Y2VPcCA9IChpbnB1dCwgb3V0cHV0KSA9PlxuICAgICAgW2B2YXIgdCA9ICR7b3V0cHV0LnR5cGUudmFsdWV9KDApOyB2YXIgdmFsdWUgPSAke291dHB1dC50eXBlLnZhbHVlfSgwKTtgLFxuICAgICAgICcnLFxuICAgICAgIGB0ID0gJHtpbnB1dC5nZXRCeUluZGljZXMoJ2lucHV0X2luZGljZXMnKX07IHZhbHVlICs9ICh0ICogdCk7YCxcbiAgICAgICAndmFsdWUgPSBzcXJ0KHZhbHVlKTsnLFxuICBdO1xuICBydW5SZWR1Y2VQcm9ncmFtKGNvbnRleHQsICdSZWR1Y2VMMicsIGF0dHJpYnV0ZXMsIHJlZHVjZU9wKTtcbn07XG5cbmNvbnN0IHJlZHVjZUxvZ1N1bUV4cE5haXZlID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBSZWR1Y2VBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIHZhbGlkYXRlSW5wdXRzKGNvbnRleHQuaW5wdXRzKTtcbiAgY29uc3QgcmVkdWNlT3A6IFJlZHVjZU9wID0gKGlucHV0LCBvdXRwdXQpID0+XG4gICAgICBbYHZhciB2YWx1ZSA9ICR7b3V0cHV0LnR5cGUuc3RvcmFnZX0oMCk7YCxcbiAgICAgICAnJyxcbiAgICAgICBgdmFsdWUgKz0gZXhwKCR7aW5wdXQuZ2V0QnlJbmRpY2VzKCdpbnB1dF9pbmRpY2VzJyl9KTtgLFxuICAgICAgICd2YWx1ZSA9IGxvZyh2YWx1ZSk7JyxcbiAgXTtcbiAgcnVuUmVkdWNlUHJvZ3JhbShjb250ZXh0LCAnUmVkdWNlTG9nU3VtRXhwJywgYXR0cmlidXRlcywgcmVkdWNlT3ApO1xufTtcblxuY29uc3QgcmVkdWNlTWF4TmFpdmUgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IFJlZHVjZUF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgdmFsaWRhdGVJbnB1dHMoY29udGV4dC5pbnB1dHMpO1xuICBjb25zdCByZWR1Y2VPcDogUmVkdWNlT3AgPSAoaW5wdXQsIF9vdXRwdXQsIGF4ZXMpID0+IHtcbiAgICBjb25zdCBpZHhaZXJvID0gW107XG4gICAgZm9yIChsZXQgayA9IDA7IGsgPCBpbnB1dC5yYW5rOyBrKyspIHtcbiAgICAgIGlmIChheGVzLmluZGV4T2YoaykgPj0gMCB8fCBheGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBpZHhaZXJvLnB1c2goaW5wdXQuaW5kaWNlc1NldCgnaW5wdXRfaW5kaWNlcycsIGssIDApKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gW1xuICAgICAgYCR7aWR4WmVyby5qb2luKCdcXG4nKX1gLFxuICAgICAgYHZhciB2YWx1ZSA9ICR7aW5wdXQuZ2V0QnlJbmRpY2VzKCdpbnB1dF9pbmRpY2VzJyl9O2AsXG4gICAgICBgdmFsdWUgPSBtYXgodmFsdWUsICR7aW5wdXQuZ2V0QnlJbmRpY2VzKCdpbnB1dF9pbmRpY2VzJyl9KTtgLFxuICAgICAgJycsXG4gICAgXTtcbiAgfTtcbiAgcnVuUmVkdWNlUHJvZ3JhbShjb250ZXh0LCAnUmVkdWNlTWF4JywgYXR0cmlidXRlcywgcmVkdWNlT3ApO1xufTtcblxuY29uc3QgcmVkdWNlTWVhbk5haXZlID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBSZWR1Y2VBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIHZhbGlkYXRlSW5wdXRzKGNvbnRleHQuaW5wdXRzKTtcbiAgY29uc3QgcmVkdWNlT3A6IFJlZHVjZU9wID0gKGlucHV0LCBvdXRwdXQsIGF4ZXMpID0+IHtcbiAgICBsZXQgc2l6ZSA9IDEuMDtcbiAgICBmb3IgKGxldCBrID0gMDsgayA8IGlucHV0LnJhbms7IGsrKykge1xuICAgICAgaWYgKGF4ZXMuaW5kZXhPZihrKSA+PSAwIHx8IGF4ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIC8vIFRPRE86IHRoaXMgZGVwZW5kcyBvbiB0aGUgaW5wdXQgZGltcy4gSWYgd2Ugd2FudCB0byB1c2UgdW5pZm9ybSwgdGhpcyBuZWVkIHRvIGJlIHVwZGF0ZWQuXG4gICAgICAgIHNpemUgKj0gY29udGV4dC5pbnB1dHNbMF0uZGltc1trXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gW1xuICAgICAgJ3ZhciBzdW0gPSBmMzIoMCk7JyxcbiAgICAgICcnLFxuICAgICAgYHN1bSArPSBmMzIoJHtpbnB1dC5nZXRCeUluZGljZXMoJ2lucHV0X2luZGljZXMnKX0pO2AsXG4gICAgICBgbGV0IHZhbHVlID0gJHtvdXRwdXQudHlwZS52YWx1ZX0oc3VtIC8gJHtzaXplfSk7YCxcbiAgICBdO1xuICB9O1xuICBydW5SZWR1Y2VQcm9ncmFtKGNvbnRleHQsICdSZWR1Y2VNZWFuJywgYXR0cmlidXRlcywgcmVkdWNlT3ApO1xufTtcblxuY29uc3QgcmVkdWNlTWluTmFpdmUgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IFJlZHVjZUF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgdmFsaWRhdGVJbnB1dHMoY29udGV4dC5pbnB1dHMpO1xuICBjb25zdCByZWR1Y2VPcDogUmVkdWNlT3AgPSAoaW5wdXQsIF9vdXRwdXQsIGF4ZXMpID0+IHtcbiAgICBjb25zdCBpZHhaZXJvID0gW107XG4gICAgZm9yIChsZXQgayA9IDA7IGsgPCBpbnB1dC5yYW5rOyBrKyspIHtcbiAgICAgIGlmIChheGVzLmluZGV4T2YoaykgPj0gMCB8fCBheGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBpZHhaZXJvLnB1c2goYGlucHV0X2luZGljZXNbJHtrfV0gPSAwO2ApOyAgLy8gZmlyc3QgZWxlbWVudFxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBbXG4gICAgICBgJHtpZHhaZXJvLmpvaW4oJ1xcbicpfWAsXG4gICAgICBgdmFyIHZhbHVlID0gJHtpbnB1dC5nZXRCeUluZGljZXMoJ2lucHV0X2luZGljZXMnKX07YCxcbiAgICAgIGB2YWx1ZSA9IG1pbih2YWx1ZSwgJHtpbnB1dC5nZXRCeUluZGljZXMoJ2lucHV0X2luZGljZXMnKX0pO2AsXG4gICAgICAnJyxcbiAgICBdO1xuICB9O1xuICBydW5SZWR1Y2VQcm9ncmFtKGNvbnRleHQsICdSZWR1Y2VNaW4nLCBhdHRyaWJ1dGVzLCByZWR1Y2VPcCk7XG59O1xuXG5jb25zdCByZWR1Y2VQcm9kTmFpdmUgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IFJlZHVjZUF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgdmFsaWRhdGVJbnB1dHMoY29udGV4dC5pbnB1dHMpO1xuICBjb25zdCByZWR1Y2VPcDogUmVkdWNlT3AgPSAoaW5wdXQsIG91dHB1dCkgPT5cbiAgICAgIFtgdmFyIHZhbHVlID0gJHtvdXRwdXQudHlwZS5zdG9yYWdlfSgxKTtgLFxuICAgICAgICcnLFxuICAgICAgIGB2YWx1ZSAqPSAke2lucHV0LmdldEJ5SW5kaWNlcygnaW5wdXRfaW5kaWNlcycpfTtgLFxuICAgICAgICcnLFxuICBdO1xuICBydW5SZWR1Y2VQcm9ncmFtKGNvbnRleHQsICdSZWR1Y2VQcm9kJywgYXR0cmlidXRlcywgcmVkdWNlT3ApO1xufTtcblxuY29uc3QgcmVkdWNlU3VtTmFpdmUgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IFJlZHVjZUF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgdmFsaWRhdGVJbnB1dHMoY29udGV4dC5pbnB1dHMpO1xuICBjb25zdCByZWR1Y2VPcDogUmVkdWNlT3AgPSAoaW5wdXQsIG91dHB1dCkgPT5cbiAgICAgIFtgdmFyIHZhbHVlID0gJHtvdXRwdXQudHlwZS5zdG9yYWdlfSgwKTtgLFxuICAgICAgICcnLFxuICAgICAgIGB2YWx1ZSArPSAke2lucHV0LmdldEJ5SW5kaWNlcygnaW5wdXRfaW5kaWNlcycpfTtgLFxuICAgICAgICcnLFxuICBdO1xuICBydW5SZWR1Y2VQcm9ncmFtKGNvbnRleHQsICdSZWR1Y2VTdW0nLCBhdHRyaWJ1dGVzLCByZWR1Y2VPcCk7XG59O1xuXG5jb25zdCByZWR1Y2VTdW1TcXVhcmVOYWl2ZSA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogUmVkdWNlQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICB2YWxpZGF0ZUlucHV0cyhjb250ZXh0LmlucHV0cyk7XG4gIGNvbnN0IHJlZHVjZU9wOiBSZWR1Y2VPcCA9IChpbnB1dCwgb3V0cHV0KSA9PlxuICAgICAgW2B2YXIgdCA9ICR7b3V0cHV0LnR5cGUudmFsdWV9KDApOyB2YXIgdmFsdWUgPSAke291dHB1dC50eXBlLnZhbHVlfSgwKTtgLFxuICAgICAgICcnLFxuICAgICAgIGB0ID0gJHtpbnB1dC5nZXRCeUluZGljZXMoJ2lucHV0X2luZGljZXMnKX07IHZhbHVlICs9IHQgKiB0O2AsXG4gICAgICAgJycsXG4gIF07XG4gIHJ1blJlZHVjZVByb2dyYW0oY29udGV4dCwgJ1JlZHVjZVN1bVNxdWFyZScsIGF0dHJpYnV0ZXMsIHJlZHVjZU9wKTtcbn07XG5cbmNvbnN0IHVzZU5haXZlUmVkdWNlTWV0aG9kID1cbiAgICAoc2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLCBheGVzOiByZWFkb25seSBudW1iZXJbXSwgbm9vcFdpdGhFbXB0eUF4ZXM6IGJvb2xlYW4pOiBib29sZWFuID0+IHtcbiAgICAgIGlmIChheGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gbm9vcFdpdGhFbXB0eUF4ZXM7XG4gICAgICB9XG5cbiAgICAgIGxldCBvdXRwdXRTaXplID0gMTtcbiAgICAgIGxldCByZWR1Y2VTaXplID0gMTtcbiAgICAgIGZvciAobGV0IGRpbSA9IDA7IGRpbSA8IGF4ZXMubGVuZ3RoOyBkaW0rKykge1xuICAgICAgICBpZiAoYXhlcy5pbmRleE9mKGRpbSkgPT09IC0xKSB7XG4gICAgICAgICAgb3V0cHV0U2l6ZSAqPSBzaGFwZVtkaW1dO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlZHVjZVNpemUgKj0gc2hhcGVbZGltXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUaGUgY29uZGl0aW9uIGRhdGEgaXMgdmVyeSByb3VnaCwgYWx0aG91Z2ggY29uc2lkZXJpbmcgdGhlIGNvdW50IG9mIEV4ZWN1dGlvbiBVbml0IChFVSksIHRoZSBwb3RlbnRpYWxcbiAgICAgIC8vIHdvcmsgZ3JvdXBzIGluIGEgRVUgYW5kIHRoZSBjb3VudHMgb2YgbG9vcHMgaW4gdGhlIG5haXZlIGFuZCBzaGFyZWQgbWV0aG9kcywgYWxzbyBkb2luZyBleHBlcmltZW50c1xuICAgICAgLy8gb24gc29tZSBtYWNoaW5lcy5cbiAgICAgIHJldHVybiByZWR1Y2VTaXplIDwgMzIgJiYgb3V0cHV0U2l6ZSA+IDEwMjQ7XG4gICAgfTtcblxuZXhwb3J0IGNvbnN0IHJlZHVjZU1lYW4gPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IFJlZHVjZUF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgaWYgKHVzZU5haXZlUmVkdWNlTWV0aG9kKGNvbnRleHQuaW5wdXRzWzBdLmRpbXMsIGF0dHJpYnV0ZXMuYXhlcywgYXR0cmlidXRlcy5ub29wV2l0aEVtcHR5QXhlcykpIHtcbiAgICByZWR1Y2VNZWFuTmFpdmUoY29udGV4dCwgYXR0cmlidXRlcyk7XG4gIH0gZWxzZSB7XG4gICAgcmVkdWNlTWVhblNoYXJlZChjb250ZXh0LCBhdHRyaWJ1dGVzKTtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IHJlZHVjZUwxID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBSZWR1Y2VBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIGlmICh1c2VOYWl2ZVJlZHVjZU1ldGhvZChjb250ZXh0LmlucHV0c1swXS5kaW1zLCBhdHRyaWJ1dGVzLmF4ZXMsIGF0dHJpYnV0ZXMubm9vcFdpdGhFbXB0eUF4ZXMpKSB7XG4gICAgcmVkdWNlTDFOYWl2ZShjb250ZXh0LCBhdHRyaWJ1dGVzKTtcbiAgfSBlbHNlIHtcbiAgICByZWR1Y2VMMVNoYXJlZChjb250ZXh0LCBhdHRyaWJ1dGVzKTtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IHJlZHVjZUwyID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBSZWR1Y2VBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIGlmICh1c2VOYWl2ZVJlZHVjZU1ldGhvZChjb250ZXh0LmlucHV0c1swXS5kaW1zLCBhdHRyaWJ1dGVzLmF4ZXMsIGF0dHJpYnV0ZXMubm9vcFdpdGhFbXB0eUF4ZXMpKSB7XG4gICAgcmVkdWNlTDJOYWl2ZShjb250ZXh0LCBhdHRyaWJ1dGVzKTtcbiAgfSBlbHNlIHtcbiAgICByZWR1Y2VMMlNoYXJlZChjb250ZXh0LCBhdHRyaWJ1dGVzKTtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IHJlZHVjZUxvZ1N1bUV4cCA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogUmVkdWNlQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICBpZiAodXNlTmFpdmVSZWR1Y2VNZXRob2QoY29udGV4dC5pbnB1dHNbMF0uZGltcywgYXR0cmlidXRlcy5heGVzLCBhdHRyaWJ1dGVzLm5vb3BXaXRoRW1wdHlBeGVzKSkge1xuICAgIHJlZHVjZUxvZ1N1bUV4cE5haXZlKGNvbnRleHQsIGF0dHJpYnV0ZXMpO1xuICB9IGVsc2Uge1xuICAgIHJlZHVjZUxvZ1N1bUV4cFNoYXJlZChjb250ZXh0LCBhdHRyaWJ1dGVzKTtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IHJlZHVjZU1heCA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogUmVkdWNlQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICBpZiAodXNlTmFpdmVSZWR1Y2VNZXRob2QoY29udGV4dC5pbnB1dHNbMF0uZGltcywgYXR0cmlidXRlcy5heGVzLCBhdHRyaWJ1dGVzLm5vb3BXaXRoRW1wdHlBeGVzKSkge1xuICAgIHJlZHVjZU1heE5haXZlKGNvbnRleHQsIGF0dHJpYnV0ZXMpO1xuICB9IGVsc2Uge1xuICAgIHJlZHVjZU1heFNoYXJlZChjb250ZXh0LCBhdHRyaWJ1dGVzKTtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IHJlZHVjZU1pbiA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogUmVkdWNlQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICBpZiAodXNlTmFpdmVSZWR1Y2VNZXRob2QoY29udGV4dC5pbnB1dHNbMF0uZGltcywgYXR0cmlidXRlcy5heGVzLCBhdHRyaWJ1dGVzLm5vb3BXaXRoRW1wdHlBeGVzKSkge1xuICAgIHJlZHVjZU1pbk5haXZlKGNvbnRleHQsIGF0dHJpYnV0ZXMpO1xuICB9IGVsc2Uge1xuICAgIHJlZHVjZU1pblNoYXJlZChjb250ZXh0LCBhdHRyaWJ1dGVzKTtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IHJlZHVjZVByb2QgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IFJlZHVjZUF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgaWYgKHVzZU5haXZlUmVkdWNlTWV0aG9kKGNvbnRleHQuaW5wdXRzWzBdLmRpbXMsIGF0dHJpYnV0ZXMuYXhlcywgYXR0cmlidXRlcy5ub29wV2l0aEVtcHR5QXhlcykpIHtcbiAgICByZWR1Y2VQcm9kTmFpdmUoY29udGV4dCwgYXR0cmlidXRlcyk7XG4gIH0gZWxzZSB7XG4gICAgcmVkdWNlUHJvZFNoYXJlZChjb250ZXh0LCBhdHRyaWJ1dGVzKTtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IHJlZHVjZVN1bSA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogUmVkdWNlQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICBpZiAodXNlTmFpdmVSZWR1Y2VNZXRob2QoY29udGV4dC5pbnB1dHNbMF0uZGltcywgYXR0cmlidXRlcy5heGVzLCBhdHRyaWJ1dGVzLm5vb3BXaXRoRW1wdHlBeGVzKSkge1xuICAgIHJlZHVjZVN1bU5haXZlKGNvbnRleHQsIGF0dHJpYnV0ZXMpO1xuICB9IGVsc2Uge1xuICAgIHJlZHVjZVN1bVNoYXJlZChjb250ZXh0LCBhdHRyaWJ1dGVzKTtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IHJlZHVjZVN1bVNxdWFyZSA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogUmVkdWNlQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICBpZiAodXNlTmFpdmVSZWR1Y2VNZXRob2QoY29udGV4dC5pbnB1dHNbMF0uZGltcywgYXR0cmlidXRlcy5heGVzLCBhdHRyaWJ1dGVzLm5vb3BXaXRoRW1wdHlBeGVzKSkge1xuICAgIHJlZHVjZVN1bVNxdWFyZU5haXZlKGNvbnRleHQsIGF0dHJpYnV0ZXMpO1xuICB9IGVsc2Uge1xuICAgIHJlZHVjZVN1bVNxdWFyZVNoYXJlZChjb250ZXh0LCBhdHRyaWJ1dGVzKTtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IHJlZHVjZUxvZ1N1bSA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogUmVkdWNlQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICBpZiAodXNlTmFpdmVSZWR1Y2VNZXRob2QoY29udGV4dC5pbnB1dHNbMF0uZGltcywgYXR0cmlidXRlcy5heGVzLCBhdHRyaWJ1dGVzLm5vb3BXaXRoRW1wdHlBeGVzKSkge1xuICAgIHJlZHVjZUxvZ1N1bU5haXZlKGNvbnRleHQsIGF0dHJpYnV0ZXMpO1xuICB9IGVsc2Uge1xuICAgIHJlZHVjZUxvZ1N1bVNoYXJlZChjb250ZXh0LCBhdHRyaWJ1dGVzKTtcbiAgfVxufTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuLy8gVE9ETzogdGhpcyBpcyB0aGUgc2FtZSBuYWl2ZSBpbXBsZW1lbnRhdGlvbiB3ZSB1c2UgZm9yIHJlZHVjZSB0aGF0IGhhc1xuLy8gcGVyZm9ybWFuY2UgbGltaXRhdGlvbnMgd2hlbiB0aGUgcmVkdWNlZCBheGlzIGlzIGxvbmcuIE5lZWQgdG8gYWRkXG4vLyBhIG9wdGltaXplZCBjb2RlcGF0aCBmb3IgdGhpcy5cblxuaW1wb3J0IHtEYXRhVHlwZX0gZnJvbSAnLi4vLi4vLi4vd2FzbS1jb21tb24nO1xuaW1wb3J0IHtUZW5zb3JWaWV3fSBmcm9tICcuLi8uLi90ZW5zb3Itdmlldyc7XG5pbXBvcnQge0F0dHJpYnV0ZVdpdGhDYWNoZUtleSwgY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5fSBmcm9tICcuLi9hdHRyaWJ1dGUtd2l0aC1jYWNoZS1rZXknO1xuaW1wb3J0IHtDb21wdXRlQ29udGV4dH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5pbXBvcnQge2NyZWF0ZVJlZHVjZVByb2dyYW1JbmZvLCBSZWR1Y2VPcH0gZnJvbSAnLi9yZWR1Y2UnO1xuXG5jb25zdCB2YWxpZGF0ZUlucHV0cyA9IChpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSk6IHZvaWQgPT4ge1xuICBpZiAoIWlucHV0cyB8fCBpbnB1dHMubGVuZ3RoID09PSAwIHx8IGlucHV0cy5sZW5ndGggPiAyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdBcmdNaW5NYXhPcCBvcCByZXF1aXJlcyAxIG9yIDIgaW5wdXRzLicpO1xuICB9XG4gIGlmIChpbnB1dHNbMF0uZGF0YVR5cGUgIT09IERhdGFUeXBlLmZsb2F0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGlucHV0IHR5cGUuJyk7XG4gIH1cbn07XG5cbmV4cG9ydCBpbnRlcmZhY2UgQXJnTWluTWF4QXR0cmlidXRlcyBleHRlbmRzIEF0dHJpYnV0ZVdpdGhDYWNoZUtleSB7XG4gIGtlZXBEaW1zOiBib29sZWFuO1xuICBheGlzOiBudW1iZXI7XG4gIHNlbGVjdExhc3RJbmRleDogbnVtYmVyO1xufVxuXG5leHBvcnQgY29uc3QgYXJnTWluID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBBcmdNaW5NYXhBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIHZhbGlkYXRlSW5wdXRzKGNvbnRleHQuaW5wdXRzKTtcbiAgY29uc3QgYXJnTWluTWF4T3A6IFJlZHVjZU9wID0gKGlucHV0LCBvdXRwdXQsIGF4ZXMpID0+IHtcbiAgICBjb25zdCBpZHhaZXJvID0gW107XG4gICAgZm9yIChsZXQgayA9IDA7IGsgPCBpbnB1dC5yYW5rOyBrKyspIHtcbiAgICAgIGlmIChheGVzLmluZGV4T2YoaykgPj0gMCB8fCBheGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBpZHhaZXJvLnB1c2goYGlucHV0X2luZGljZXNbJHtrfV0gPSAwO2ApOyAgLy8gZmlyc3QgZWxlbWVudFxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gW1xuICAgICAgYCR7aWR4WmVyby5qb2luKCdcXG4nKX1gLCBgdmFyIHZhbHVlID0gJHtpbnB1dC5nZXRCeUluZGljZXMoJ2lucHV0X2luZGljZXMnKX07XFxudmFyIGJlc3RfaW5kZXggOiBpMzIgPSAwO2AsXG4gICAgICBgaWYgKCR7aW5wdXQuZ2V0QnlJbmRpY2VzKCdpbnB1dF9pbmRpY2VzJyl9ICR7YXR0cmlidXRlcy5zZWxlY3RMYXN0SW5kZXggPiAwID8gJzw9JyA6ICc8J30gdmFsdWUpIHtcbiAgICAgICAgIHZhbHVlID0gJHtpbnB1dC5nZXRCeUluZGljZXMoJ2lucHV0X2luZGljZXMnKX07XG4gICAgICAgICBiZXN0X2luZGV4ID0gaTMyKGxhc3RfaW5kZXgpO1xuICAgICAgIH1gLFxuICAgICAgJycsIG91dHB1dC5zZXRCeU9mZnNldCgnZ2xvYmFsX2lkeCcsICdiZXN0X2luZGV4JylcbiAgICBdO1xuICB9O1xuXG4gIGNvbnRleHQuY29tcHV0ZShcbiAgICAgIGNyZWF0ZVJlZHVjZVByb2dyYW1JbmZvKFxuICAgICAgICAgICdBcmdNaW4nLCB7aGludDogYXR0cmlidXRlcy5jYWNoZUtleSwgaW5wdXREZXBlbmRlbmNpZXM6IFsncmFuayddfSwgW2NvbnRleHQuaW5wdXRzWzBdXSwgYXJnTWluTWF4T3AsXG4gICAgICAgICAgW2F0dHJpYnV0ZXMuYXhpc10sIERhdGFUeXBlLmludDY0LCBhdHRyaWJ1dGVzLmtlZXBEaW1zKSxcbiAgICAgIHtpbnB1dHM6IFswXX0pO1xufTtcblxuZXhwb3J0IGNvbnN0IGFyZ01heCA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogQXJnTWluTWF4QXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICB2YWxpZGF0ZUlucHV0cyhjb250ZXh0LmlucHV0cyk7XG4gIGNvbnN0IGFyZ01pbk1heE9wOiBSZWR1Y2VPcCA9IChpbnB1dCwgb3V0cHV0LCBheGVzKSA9PiB7XG4gICAgY29uc3QgaWR4WmVybyA9IFtdO1xuICAgIGZvciAobGV0IGsgPSAwOyBrIDwgaW5wdXQucmFuazsgaysrKSB7XG4gICAgICBpZiAoYXhlcy5pbmRleE9mKGspID49IDAgfHwgYXhlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgaWR4WmVyby5wdXNoKGBpbnB1dF9pbmRpY2VzWyR7a31dID0gMDtgKTsgIC8vIGZpcnN0IGVsZW1lbnRcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFtcbiAgICAgIGAke2lkeFplcm8uam9pbignXFxuJyl9YCwgYHZhciB2YWx1ZSA9ICR7aW5wdXQuZ2V0QnlJbmRpY2VzKCdpbnB1dF9pbmRpY2VzJyl9O1xcbnZhciBiZXN0X2luZGV4IDogaTMyID0gMDtgLFxuICAgICAgYGlmICgke2lucHV0LmdldEJ5SW5kaWNlcygnaW5wdXRfaW5kaWNlcycpfSAke2F0dHJpYnV0ZXMuc2VsZWN0TGFzdEluZGV4ID4gMCA/ICc+PScgOiAnPid9IHZhbHVlKSB7XG4gICAgICAgICB2YWx1ZSA9ICR7aW5wdXQuZ2V0QnlJbmRpY2VzKCdpbnB1dF9pbmRpY2VzJyl9O1xuICAgICAgICAgYmVzdF9pbmRleCA9IGkzMihsYXN0X2luZGV4KTtcbiAgICAgICB9YCxcbiAgICAgICcnLCBvdXRwdXQuc2V0QnlPZmZzZXQoJ2dsb2JhbF9pZHgnLCAnYmVzdF9pbmRleCcpXG4gICAgXTtcbiAgfTtcblxuICBjb250ZXh0LmNvbXB1dGUoXG4gICAgICBjcmVhdGVSZWR1Y2VQcm9ncmFtSW5mbyhcbiAgICAgICAgICAnYXJnTWF4Jywge2hpbnQ6IGF0dHJpYnV0ZXMuY2FjaGVLZXksIGlucHV0RGVwZW5kZW5jaWVzOiBbJ3JhbmsnXX0sIFtjb250ZXh0LmlucHV0c1swXV0sIGFyZ01pbk1heE9wLFxuICAgICAgICAgIFthdHRyaWJ1dGVzLmF4aXNdLCBEYXRhVHlwZS5pbnQ2NCwgYXR0cmlidXRlcy5rZWVwRGltcyksXG4gICAgICB7aW5wdXRzOiBbMF19KTtcbn07XG5cbmV4cG9ydCBjb25zdCBwYXJzZUFyZ01pbk1heEF0dHJpYnV0ZXMgPSAoYXR0cmlidXRlczogUmVjb3JkPHN0cmluZywgdW5rbm93bj4pOiBBcmdNaW5NYXhBdHRyaWJ1dGVzID0+XG4gICAgY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KGF0dHJpYnV0ZXMgYXMgT21pdDxBcmdNaW5NYXhBdHRyaWJ1dGVzLCBrZXlvZiBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXk+KTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHt0ZW5zb3JEYXRhVHlwZUVudW1Ub1N0cmluZ30gZnJvbSAnLi4vLi4vLi4vd2FzbS1jb21tb24nO1xuaW1wb3J0IHtUZW5zb3JWaWV3fSBmcm9tICcuLi8uLi90ZW5zb3Itdmlldyc7XG5pbXBvcnQge0NvbXB1dGVDb250ZXh0LCBHcHVEYXRhVHlwZSwgUHJvZ3JhbVVuaWZvcm19IGZyb20gJy4uL3R5cGVzJztcblxuaW1wb3J0IHtjYXN0VG9GMzIsIGZpbGxWZWN0b3IsIGdldE1heENvbXBvbmVudHMsIGlucHV0VmFyaWFibGUsIG91dHB1dFZhcmlhYmxlLCBTaGFkZXJIZWxwZXIsIHN1bVZlY3RvciwgdGVuc29yVHlwZVRvV3NnbFN0b3JhZ2VUeXBlLCB0ZW5zb3JUeXBlVG9Xc2dsVmFsdWVUeXBlLCBVbmlmb3JtRGF0YUVsZW1lbnRUeXBlLCBVbmlmb3Jtc0FycmF5VHlwZX0gZnJvbSAnLi9jb21tb24nO1xuXG5leHBvcnQgY29uc3QgZW51bSBBdHRlbnRpb25Ra3ZGb3JtYXQge1xuICB1bmtub3duLCAgICAgICAgICAvLyBlbnVtIHZhbHVlIG5vdCBzZXQsIG9yIGRlcGVuZHMgb24gcWt2IHByb2plY3Rpb24gaW1wbGVtZW50YXRpb24gZGV0YWlsc1xuICBxa3ZCTlNILCAgICAgICAgICAvLyBmb3Igbm9uLXBhY2tlZCBxa3YsIHBlcm11dGVkXG4gIHFrdkJTTkgsICAgICAgICAgIC8vIGZvciBub24tcGFja2VkIHFrdiwgbm90IHBlcm11dGVkLCB1c2VkIGJ5IG1lbW9yeSBlZmZpY2llbnQgYXR0ZW50aW9uIG9yIE11bHRpSGVhZEF0dGVudGlvblxuICBxa3ZCU04zSCwgICAgICAgICAvLyBmb3IgVFJUIGZ1c2VkIGF0dGVudGlvbiwgcWt2IGFyZSBwYWNrZWRcbiAgcWt2Qk5TSHFrdkJTM05ILCAgLy8gZm9yIFRSVCBmdXNlZCBjYXVzYWwgYXR0ZW50aW9uLCBkYXRhIGhhcyB0d28gZm9ybWF0cyAocWt2IGlzIDNCTlNILCBnZW1tX2J1ZmZlciBpcyBCUzNOSClcbiAgcUt2QlNOSHhCU04ySCwgICAgLy8gZm9yIFRSVCBmdXNlZCBjcm9zcyBhdHRlbnRpb24sIGt2IGFyZSBwYWNrZWRcbiAgcWt2VE5ILCAgICAgICAgICAgLy8gZm9yIG1lbW9yeSBlZmZpY2llbnQgYXR0ZW50aW9uLCBxa3YgYXJlIG5vdCBwYWNrZWQsIGFuZCBwYWRkaW5ncyBhcmUgcmVtb3ZlZC5cbiAgcWt2VE4zSCwgICAgICAgICAgLy8gZm9yIFRSVCBmdXNlZCBhdHRlbnRpb24sIHFrdiBhcmUgcGFja2VkIGFuZCBwYWRkaW5ncyBhcmUgcmVtb3ZlZFxufVxuXG5leHBvcnQgY29uc3QgZW51bSBBdHRlbnRpb25NYXNrVHlwZSB7XG4gIG5vbmUsICAgICAgICAgICAgICAgICAgLy8gTm8gbWFza1xuICBtYXNrMWRLZXlTZXFMZW4sICAgICAgIC8vIFtiYXRjaF9zaXplXSwga2V5IHNlcXVlbmNlIGxlbmd0aFxuICBtYXNrMWRFbmRTdGFydCwgICAgICAgIC8vIFsyICogYmF0Y2hfc2l6ZV0gd2l0aCBlbmQgcG9zaXRpb25zIGFuZCBzdGFydCBwb3NpdGlvbnNcbiAgbWFzazFES2V5U2VxTGVuU3RhcnQsICAvLyBbMyAqIGJhdGNoX3NpemUgKyAyXSB3aXRoIFtrZXlfbGVuWzBdLCAuLi4sIGtleV9sZW5bYmF0Y2hfc2l6ZSAtIDFdLCBxdWVyeV9zdGFydFswXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAvLyAuLi4sIHF1ZXJ5X3N0YXJ0W2JhdGNoX3NpemUgLSAxXSwgcXVlcnlfZW5kW2JhdGNoX3NpemUgLSAxXSwga2V5X3N0YXJ0WzBdLCAuLi4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgLy8ga2V5X3N0YXJ0W2JhdGNoX3NpemUgLSAxXSwga2V5X2VuZFtiYXRjaF9zaXplIC0gMV1dXG4gIG1hc2syZER1bW15LCAgICAgICAgICAgLy8gZHVtbXkgbWFzayB3aXRoIHNoYXBlIFsxLCAxXSBvciBbYmF0Y2hfc2l6ZSwgMV0uIEl0IGhhcyBzYW1lIGVmZmVjdCBhcyBubyBtYXNrLlxuICBtYXNrMmRLZXlQYWRkaW5nLCAgICAgIC8vIFtiYXRjaF9zaXplLCB0b3RhbF9zZXF1ZW5jZV9sZW5ndGhdXG4gIG1hc2szZEF0dGVudGlvbiwgICAgICAgLy8gW2JhdGNoX3NpemUsIHNlcXVlbmNlX2xlbmd0aCwgdG90YWxfc2VxdWVuY2VfbGVuZ3RoXVxuICBtYXNrNGRNZWdhdHJvbiwgICAgICAgIC8vIE1lZ2F0cm9uIGNhdXNhbCBtYXNrIHdpdGggc2hhcGUgW2JhdGNoX3NpemUsIDEsIG1heF9zZXF1ZW5jZV9sZW5ndGgsIG1heF9zZXF1ZW5jZV9sZW5ndGhdXG4gIG1hc2tVbmtub3duXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQXR0ZW50aW9uUGFyYW1ldGVycyB7XG4gIGJhdGNoU2l6ZTogbnVtYmVyO1xuICBzZXF1ZW5jZUxlbmd0aDogbnVtYmVyO1xuICBwYXN0U2VxdWVuY2VMZW5ndGg6IG51bWJlcjtcbiAga3ZTZXF1ZW5jZUxlbmd0aDogbnVtYmVyO1xuICB0b3RhbFNlcXVlbmNlTGVuZ3RoOiBudW1iZXI7XG4gIG1heFNlcXVlbmNlTGVuZ3RoOiBudW1iZXI7XG4gIGlucHV0SGlkZGVuU2l6ZTogbnVtYmVyO1xuICBoaWRkZW5TaXplOiBudW1iZXI7XG4gIHZIaWRkZW5TaXplOiBudW1iZXI7XG4gIGhlYWRTaXplOiBudW1iZXI7XG4gIHZIZWFkU2l6ZTogbnVtYmVyO1xuICBudW1IZWFkczogbnVtYmVyO1xuICBpc1VuaWRpcmVjdGlvbmFsOiBib29sZWFuO1xuICBwYXN0UHJlc2VudFNoYXJlQnVmZmVyOiBib29sZWFuO1xuICBtYXNrRmlsdGVyVmFsdWU6IG51bWJlcjtcbiAgbWFza1R5cGU6IEF0dGVudGlvbk1hc2tUeXBlO1xuICBzY2FsZTogbnVtYmVyO1xuICBicm9hZGNhc3RSZXNQb3NCaWFzOiBib29sZWFuO1xuICBwYXNzUGFzdEluS3Y6IGJvb2xlYW47XG4gIHFrdkZvcm1hdDogQXR0ZW50aW9uUWt2Rm9ybWF0O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEF0dGVudGlvbkF0dHJzIHtcbiAgbnVtSGVhZHM6IG51bWJlcjtcbiAgaXNVbmlkaXJlY3Rpb25hbDogbnVtYmVyO1xuICBtYXNrRmlsdGVyVmFsdWU6IG51bWJlcjtcbiAgc2NhbGU6IG51bWJlcjtcbiAgZG9Sb3Rhcnk6IG51bWJlcjtcbiAgcWt2SGlkZGVuU2l6ZXM6IG51bWJlcltdO1xuICBwYXN0UHJlc2VudFNoYXJlQnVmZmVyOiBib29sZWFuO1xufVxuXG5jb25zdCB2YWxpZGF0ZUF0dGVudGlvbklucHV0cyA9IChpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSwgYXR0cmlidXRlczogQXR0ZW50aW9uQXR0cnMpOiBBdHRlbnRpb25QYXJhbWV0ZXJzID0+IHtcbiAgLy8gQWJicmV2aWF0aW9uIGFuZCBNZWFuaW5nczpcbiAgLy8gICBCOiAgICBiYXRjaF9zaXplXG4gIC8vICAgUzogICAgc2VxdWVuY2VfbGVuZ3RoIChpbnB1dCBzZXF1ZW5jZSBsZW5ndGggb2YgcXVlcnkpXG4gIC8vICAgUDogICAgcGFzdF9zZXF1ZW5jZV9sZW5ndGggKHBhc3Qgc2VxdWVuY2UgbGVuZ3RoIG9mIGtleSBvciB2YWx1ZSlcbiAgLy8gICBMOiAgICBrdl9zZXF1ZW5jZV9sZW5ndGggKGlucHV0IHNlcXVlbmNlIGxlbmd0aCBvZiBrZXkgb3IgdmFsdWUpXG4gIC8vICAgTTogICAgbWF4X3NlcXVlbmNlX2xlbmd0aFxuICAvLyAgIFQ6ICAgIHRvdGFsX3NlcXVlbmNlX2xlbmd0aCA9IHBhc3Rfc2VxdWVuY2VfbGVuZ3RoICsga3Zfc2VxdWVuY2VfbGVuZ3RoXG4gIC8vICAgTjogICAgbnVtX2hlYWRzXG4gIC8vICAgSDogICAgaGVhZCBzaXplIGZvciBRIGFuZCBLLCBha2EgcV9oZWFkX3NpemUgb3Iga19oZWFkX3NpemUgb3IgcWtfaGVhZF9zaXplXG4gIC8vICAgSF92OiAgdl9oZWFkX3NpemVcbiAgLy8gICBEX2k6ICBpbnB1dCBoaWRkZW4gc2l6ZVxuICAvLyAgIEQ6ICAgIGhpZGRlbiBzaXplIGZvciBRIGFuZCBLIChEID0gTiAqIEgpLCBha2EgcV9oaWRkZW5fc2l6ZSBvciBrX2hpZGRlbl9zaXplIG9yIHFrX2hpZGRlbl9zaXplXG4gIC8vICAgRF92OiAgdl9oaWRkZW5fc2l6ZSA9IG51bV9oZWFkcyAqIHZfaGVhZF9zaXplXG5cbiAgLy8gV2hlbiBwYXN0IHN0YXRlIGlzIHVzZWQsIFEsIEsgYW5kIFYgc2hvdWxkIGhhdmUgc2FtZSBoaWRkZW4gc2l6ZSAodW5sZXNzIHdlIHNwbGl0IGl0IGludG8gcGFzdF9rZXkgYW5kIHBhc3RfdmFsdWUpLlxuXG4gIC8vIElucHV0IHNoYXBlczpcbiAgLy8gICBpbnB1dCAgICAgICAgKFEvSy9WKSAgICA6IChCLCBTLCBEX2kpXG4gIC8vICAgd2VpZ2h0cyAgICAgIChRL0svVikgICAgOiAoRF9pLCBEICsgRCArIERfdilcbiAgLy8gICBiaWFzICAgICAgICAgKFEvSy9WKSAgICA6IChEICsgRCArIERfdilcbiAgLy8gICBtYXNrX2luZGV4ICAgICAgICAgICAgICA6IHNlZSBiZWxvd1xuICAvLyAgIHBhc3QgICAgICAgICAoSy9WKSAgICAgIDogKDIsIEIsIE4sIFAsIEgpIG9yIE5VTExcbiAgLy8gICByZWxhdGl2ZV9wb3NpdGlvbl9iaWFzICAgICAgICAgICAgOiAoQiwgTiwgUywgVCkgb3IgTlVMTFxuXG4gIC8vIEZvciBtYXNrX2luZGV4LCB0aGUgZm9sbG93aW5nIHNoYXBlcyBhcmUgc3VwcG9ydGVkOlxuICAvLyAgICAgTlVMTCwgKEIsIDEpLCAoMSwgMSlcbiAgLy8gICAgIChCKSwgKDIgKiBCKSwgKDMgKiBCICsgMilcbiAgLy8gICAgIChCLCBUKVxuICAvLyAgICAgKEIsIFMsIFQpXG4gIC8vICAgICAoQiwgMSwgTSwgTSlcbiAgLy9cbiAgLy8gV2hlbiBhIG1vZGVsIGlzIHBydW5lZCAobGlrZSBzb21lIGF0dGVudGlvbiBoZWFkcyBhcmUgcmVtb3ZlZCBpbiBRL0svViksIGlucHV0X2hpZGRlbl9zaXplIGNvdWxkIGJlIGxhcmdlclxuICAvLyB0aGFuIGhpZGRlbiBkaW1lbnNpb24gb2YgUSwgSyBhbmQgVi5cblxuICBjb25zdCBpbnB1dCA9IGlucHV0c1swXTtcbiAgY29uc3Qgd2VpZ2h0cyA9IGlucHV0c1sxXTtcbiAgY29uc3QgYmlhcyA9IGlucHV0c1syXTtcbiAgY29uc3QgbWFza0luZGV4ID0gaW5wdXRzWzNdO1xuICBjb25zdCBwYXN0ID0gaW5wdXRzWzRdO1xuICBjb25zdCByZWxhdGl2ZVBvc2l0aW9uQmlhcyA9IGlucHV0c1s1XTtcblxuICBpZiAocGFzdCAmJiByZWxhdGl2ZVBvc2l0aW9uQmlhcykge1xuICAgIHRocm93IG5ldyBFcnJvcignQXR0ZW50aW9uIGNhbm5vdCBoYXZlIGJvdGggcGFzdCBhbmQgcmVsYXRpdmVfcG9zaXRpb25fYmlhcycpO1xuICB9XG5cbiAgaWYgKGlucHV0LmRpbXMubGVuZ3RoICE9PSAzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcImlucHV0XCIgbXVzdCBoYXZlIDMgZGltZW5zaW9ucycpO1xuICB9XG5cbiAgY29uc3QgYmF0Y2hTaXplID0gaW5wdXQuZGltc1swXTtcbiAgY29uc3Qgc2VxdWVuY2VMZW5ndGggPSBpbnB1dC5kaW1zWzFdO1xuICBjb25zdCBpbnB1dEhpZGRlblNpemUgPSBpbnB1dC5kaW1zWzJdO1xuXG4gIGlmIChiaWFzLmRpbXMubGVuZ3RoICE9PSAxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcImJpYXNcIiBpcyBleHBlY3RlZCB0byBoYXZlIDEgZGltZW5zaW9ucycpO1xuICB9XG5cbiAgaWYgKHdlaWdodHMuZGltcy5sZW5ndGggIT09IDIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwid2VpZ2h0c1wiIGlzIGV4cGVjdGVkIHRvIGhhdmUgMiBkaW1lbnNpb25zJyk7XG4gIH1cblxuICBpZiAod2VpZ2h0cy5kaW1zWzBdICE9PSBpbnB1dEhpZGRlblNpemUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IDEgZGltZW5zaW9uIDAgc2hvdWxkIGhhdmUgc2FtZSBsZW5ndGggYXMgZGltZW5zaW9uIDIgb2YgaW5wdXQgMCcpO1xuICB9XG5cbiAgaWYgKGJpYXMuZGltc1swXSAhPT0gd2VpZ2h0cy5kaW1zWzFdKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcImJpYXNcIiBkaW1lbnNpb24gMCBzaG91bGQgaGF2ZSBzYW1lIGxlbmd0aCBhcyBkaW1lbnNpb24gMSBvZiBpbnB1dCBcIndlaWdodHNcIicpO1xuICB9XG5cbiAgbGV0IHFIaWRkZW5TaXplID0gYmlhcy5kaW1zWzBdIC8gMztcbiAgbGV0IGtIaWRkZW5TaXplID0gcUhpZGRlblNpemU7XG4gIGxldCB2SGlkZGVuU2l6ZSA9IGtIaWRkZW5TaXplO1xuICBpZiAoYXR0cmlidXRlcy5xa3ZIaWRkZW5TaXplcy5sZW5ndGggPiAwKSB7XG4gICAgaWYgKGF0dHJpYnV0ZXMucWt2SGlkZGVuU2l6ZXMubGVuZ3RoICE9PSAzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Frdl9oaWRkZW5fc2l6ZXMgYXR0cmlidXRlIHNob3VsZCBoYXZlIDMgZWxlbWVudHMnKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBzeiBvZiBhdHRyaWJ1dGVzLnFrdkhpZGRlblNpemVzKSB7XG4gICAgICBpZiAoc3ogJSBhdHRyaWJ1dGVzLm51bUhlYWRzICE9PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncWt2X2hpZGRlbl9zaXplcyBzaG91bGQgYmUgZGl2aXNpYmxlIGJ5IG51bV9oZWFkcycpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHFIaWRkZW5TaXplID0gYXR0cmlidXRlcy5xa3ZIaWRkZW5TaXplc1swXTtcbiAgICBrSGlkZGVuU2l6ZSA9IGF0dHJpYnV0ZXMucWt2SGlkZGVuU2l6ZXNbMV07XG4gICAgdkhpZGRlblNpemUgPSBhdHRyaWJ1dGVzLnFrdkhpZGRlblNpemVzWzJdO1xuICB9XG5cbiAgY29uc3Qga3ZTZXF1ZW5jZUxlbmd0aCA9IHNlcXVlbmNlTGVuZ3RoO1xuXG4gIGlmIChxSGlkZGVuU2l6ZSAhPT0ga0hpZGRlblNpemUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Frdl9oaWRkZW5fc2l6ZXMgZmlyc3QgZWxlbWVudCBzaG91bGQgYmUgc2FtZSBhcyB0aGUgc2Vjb25kJyk7XG4gIH1cblxuICBpZiAoYmlhcy5kaW1zWzBdICE9PSBxSGlkZGVuU2l6ZSArIGtIaWRkZW5TaXplICsgdkhpZGRlblNpemUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwiYmlhc1wiIGRpbWVuc2lvbiAwIHNob3VsZCBoYXZlIHNhbWUgbGVuZ3RoIGFzIHN1bSBvZiBRL0svViBoaWRkZW4gc2l6ZXMnKTtcbiAgfVxuXG4gIGxldCBwYXN0U2VxdWVuY2VMZW5ndGggPSAwO1xuICBpZiAocGFzdCkge1xuICAgIGlmIChrSGlkZGVuU2l6ZSAhPT0gdkhpZGRlblNpemUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgXCJwYXN0XCIgZXhwZWN0IGtfaGlkZGVuX3NpemUgPT0gdl9oaWRkZW5fc2l6ZScpO1xuICAgIH1cbiAgICBpZiAocGFzdC5kaW1zLmxlbmd0aCAhPT0gNSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInBhc3RcIiBtdXN0IGhhdmUgNSBkaW1lbnNpb25zJyk7XG4gICAgfVxuICAgIGlmIChwYXN0LmRpbXNbMF0gIT09IDIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgXCJwYXN0XCIgZmlyc3QgZGltZW5zaW9uIG11c3QgYmUgMicpO1xuICAgIH1cbiAgICBpZiAocGFzdC5kaW1zWzFdICE9PSBiYXRjaFNpemUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgXCJwYXN0XCIgc2Vjb25kIGRpbWVuc2lvbiBtdXN0IGJlIGJhdGNoX3NpemUnKTtcbiAgICB9XG4gICAgaWYgKHBhc3QuZGltc1syXSAhPT0gYXR0cmlidXRlcy5udW1IZWFkcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInBhc3RcIiB0aGlyZCBkaW1lbnNpb24gbXVzdCBiZSBudW1faGVhZHMnKTtcbiAgICB9XG4gICAgaWYgKHBhc3QuZGltc1s0XSAhPT0ga0hpZGRlblNpemUgLyBhdHRyaWJ1dGVzLm51bUhlYWRzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwicGFzdFwiIGZpZnRoIGRpbWVuc2lvbiBtdXN0IGJlIGtfaGlkZGVuX3NpemUgLyBudW1faGVhZHMnKTtcbiAgICB9XG5cbiAgICBpZiAoIWF0dHJpYnV0ZXMucGFzdFByZXNlbnRTaGFyZUJ1ZmZlcikge1xuICAgICAgcGFzdFNlcXVlbmNlTGVuZ3RoID0gcGFzdC5kaW1zWzNdO1xuICAgIH1cbiAgICAvLyBUT0RPOiBoYW5kbGUgcGFzdF9zZXFfbGVuXG4gIH1cblxuICBjb25zdCB0b3RhbFNlcXVlbmNlTGVuZ3RoID0ga3ZTZXF1ZW5jZUxlbmd0aCArIHBhc3RTZXF1ZW5jZUxlbmd0aDtcbiAgY29uc3QgbWF4U2VxdWVuY2VMZW5ndGggPSAtMTtcblxuICBjb25zdCBtYXNrVHlwZSA9IEF0dGVudGlvbk1hc2tUeXBlLm5vbmU7XG4gIGlmIChtYXNrSW5kZXgpIHtcbiAgICAvLyBtYXNrVHlwZSA9IEF0dGVudGlvbk1hc2tUeXBlLk1BU0tfVU5LTk9XTjtcbiAgICAvLyBUT0RPOiBoYW5kbGUgbWFza1xuICAgIHRocm93IG5ldyBFcnJvcignTWFzayBub3Qgc3VwcG9ydGVkJyk7XG4gIH1cblxuICBpZiAocGFzdCkge1xuICAgIHRocm93IG5ldyBFcnJvcigncGFzdCBpcyBub3Qgc3VwcG9ydGVkJyk7XG4gIH1cbiAgaWYgKHJlbGF0aXZlUG9zaXRpb25CaWFzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdyZWxhdGl2ZVBvc2l0aW9uQmlhcyBpcyBub3Qgc3VwcG9ydGVkJyk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGJhdGNoU2l6ZSxcbiAgICBzZXF1ZW5jZUxlbmd0aCxcbiAgICBwYXN0U2VxdWVuY2VMZW5ndGgsXG4gICAga3ZTZXF1ZW5jZUxlbmd0aCxcbiAgICB0b3RhbFNlcXVlbmNlTGVuZ3RoLFxuICAgIG1heFNlcXVlbmNlTGVuZ3RoLFxuICAgIGlucHV0SGlkZGVuU2l6ZSxcbiAgICBoaWRkZW5TaXplOiBxSGlkZGVuU2l6ZSxcbiAgICB2SGlkZGVuU2l6ZSxcbiAgICBoZWFkU2l6ZTogTWF0aC5mbG9vcihxSGlkZGVuU2l6ZSAvIGF0dHJpYnV0ZXMubnVtSGVhZHMpLFxuICAgIHZIZWFkU2l6ZTogTWF0aC5mbG9vcih2SGlkZGVuU2l6ZSAvIGF0dHJpYnV0ZXMubnVtSGVhZHMpLFxuICAgIG51bUhlYWRzOiBhdHRyaWJ1dGVzLm51bUhlYWRzLFxuICAgIGlzVW5pZGlyZWN0aW9uYWw6IGZhbHNlLFxuICAgIHBhc3RQcmVzZW50U2hhcmVCdWZmZXI6IGZhbHNlLFxuICAgIG1hc2tGaWx0ZXJWYWx1ZTogYXR0cmlidXRlcy5tYXNrRmlsdGVyVmFsdWUsXG4gICAgbWFza1R5cGUsXG4gICAgc2NhbGU6IGF0dHJpYnV0ZXMuc2NhbGUsXG4gICAgYnJvYWRjYXN0UmVzUG9zQmlhczogZmFsc2UsXG4gICAgcGFzc1Bhc3RJbkt2OiBmYWxzZSxcbiAgICBxa3ZGb3JtYXQ6IEF0dGVudGlvblFrdkZvcm1hdC5xa3ZCTlNILFxuICB9O1xufTtcblxuZXhwb3J0IGNvbnN0IGNvbXB1dGVJblBsYWNlU29mdG1heCA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgaW5wdXQ6IFRlbnNvclZpZXcsIG46IG51bWJlciwgZDogbnVtYmVyKSA9PiB7XG4gIGNvbnN0IGNvbXBvbmVudHMgPSBnZXRNYXhDb21wb25lbnRzKGQpO1xuICBsZXQgV0cgPSA2NDtcbiAgY29uc3QgZENvbXAgPSBkIC8gY29tcG9uZW50cztcbiAgaWYgKGRDb21wIDwgV0cpIHtcbiAgICBXRyA9IDE7XG4gIH0gZWxzZSBpZiAoZENvbXAgLyA4IDwgNjQpIHtcbiAgICBXRyA9IE1hdGguY2VpbChkQ29tcCAvIDgpO1xuICB9XG4gIGNvbnN0IGVsZW1lbnRzUGVyV0cgPSBNYXRoLmNlaWwoZCAvIGNvbXBvbmVudHMgLyBXRyk7XG4gIGNvbnN0IHRlbnNvckRhdGFUeXBlID0gdGVuc29yRGF0YVR5cGVFbnVtVG9TdHJpbmcoaW5wdXQuZGF0YVR5cGUpIGFzIFByb2dyYW1Vbmlmb3JtWyd0eXBlJ107XG4gIGNvbnN0IHByb2dyYW1Vbmlmb3JtczogUHJvZ3JhbVVuaWZvcm1bXSA9XG4gICAgICBbe3R5cGU6IHRlbnNvckRhdGFUeXBlLCBkYXRhOiAxIC8gZH0sIHt0eXBlOiAndWludDMyJywgZGF0YTogZENvbXB9LCB7dHlwZTogJ3VpbnQzMicsIGRhdGE6IGVsZW1lbnRzUGVyV0d9XTtcbiAgY29uc3QgZGF0YVR5cGUgPSB0ZW5zb3JUeXBlVG9Xc2dsU3RvcmFnZVR5cGUoaW5wdXQuZGF0YVR5cGUsIGNvbXBvbmVudHMpO1xuXG4gIGNvbnN0IGdldFNoYWRlclNvdXJjZSA9IChzaGFkZXJIZWxwZXI6IFNoYWRlckhlbHBlcikgPT4ge1xuICAgIGNvbnN0IGlucHV0SGVscGVyID0gb3V0cHV0VmFyaWFibGUoJ3gnLCBpbnB1dC5kYXRhVHlwZSwgaW5wdXQuZGltcywgY29tcG9uZW50cyk7XG4gICAgbGV0IHRocmVhZE1heFZhbHVlID0gJ3RocmVhZF9tYXhfdmVjdG9yJztcbiAgICBpZiAoY29tcG9uZW50cyA9PT0gMikge1xuICAgICAgdGhyZWFkTWF4VmFsdWUgPSAnbWF4KHRocmVhZF9tYXhfdmVjdG9yLngsIHRocmVhZF9tYXhfdmVjdG9yLnkpJztcbiAgICB9IGVsc2UgaWYgKGNvbXBvbmVudHMgPT09IDQpIHtcbiAgICAgIHRocmVhZE1heFZhbHVlID1cbiAgICAgICAgICAnbWF4KG1heCh0aHJlYWRfbWF4X3ZlY3Rvci54LCB0aHJlYWRfbWF4X3ZlY3Rvci55KSwgbWF4KHRocmVhZF9tYXhfdmVjdG9yLnosIHRocmVhZF9tYXhfdmVjdG9yLncpKSc7XG4gICAgfVxuICAgIGNvbnN0IGVsZW1WYWx1ZVR5cGUgPSB0ZW5zb3JUeXBlVG9Xc2dsVmFsdWVUeXBlKGlucHV0LmRhdGFUeXBlKTtcbiAgICBjb25zdCB1bmlmb3JtczogVW5pZm9ybXNBcnJheVR5cGUgPSBbXG4gICAgICB7bmFtZTogJ2RfaW52JywgdHlwZTogZWxlbVZhbHVlVHlwZSBhcyBVbmlmb3JtRGF0YUVsZW1lbnRUeXBlfSwge25hbWU6ICdkX2NvbXAnLCB0eXBlOiAndTMyJ30sXG4gICAgICB7bmFtZTogJ2VsZW1lbnRzX3Blcl93ZycsIHR5cGU6ICd1MzInfVxuICAgIF07XG5cbiAgICByZXR1cm4gYFxuICB2YXI8d29ya2dyb3VwPiB3Z01heDogYXJyYXk8ZjMyLCAke1dHfT47XG4gIHZhcjx3b3JrZ3JvdXA+IHdnU3VtOiBhcnJheTxmMzIsICR7V0d9PjtcbiAgJHtzaGFkZXJIZWxwZXIucmVnaXN0ZXJVbmlmb3Jtcyh1bmlmb3JtcykuZGVjbGFyZVZhcmlhYmxlcyhpbnB1dEhlbHBlcil9XG4gICR7c2hhZGVySGVscGVyLm1haW5TdGFydChbXG4gICAgICBXRywgMSwgMVxuICAgIF0pfVxuICAgIGxldCBsb2NhbE9mZnNldCA9IGxvY2FsX2lkeCAqIHVuaWZvcm1zLmVsZW1lbnRzX3Blcl93ZztcbiAgICBsZXQgb2Zmc2V0OiB1MzIgPSB3b3JrZ3JvdXBfaWQueCAqIHVuaWZvcm1zLmRfY29tcCArIGxvY2FsT2Zmc2V0O1xuXG4gICAgdmFyIHRocmVhZF9tYXhfdmVjdG9yID0gJHtmaWxsVmVjdG9yKCdmMzInLCBjb21wb25lbnRzLCAnLTMuNDAyODIzZSszOGYnKX07XG4gICAgZm9yICh2YXIgaTogdTMyID0gMDsgaSA8IHVuaWZvcm1zLmVsZW1lbnRzX3Blcl93ZyAmJiBpICsgbG9jYWxPZmZzZXQgPCB1bmlmb3Jtcy5kX2NvbXA7IGkrKykge1xuICAgICAgdGhyZWFkX21heF92ZWN0b3IgPSBtYXgoJHtjYXN0VG9GMzIoZWxlbVZhbHVlVHlwZSwgY29tcG9uZW50cywgJ3hbb2Zmc2V0ICsgaV0nKX0sIHRocmVhZF9tYXhfdmVjdG9yKTtcbiAgICB9XG4gICAgd2dNYXhbbG9jYWxfaWR4XSA9ICR7dGhyZWFkTWF4VmFsdWV9O1xuICAgIHdvcmtncm91cEJhcnJpZXIoKTtcblxuICAgIHZhciBtYXhWYWx1ZSA9IC0zLjQwMjgyM2UrMzhmO1xuICAgIGZvciAodmFyIGkgPSAwdTsgaSA8ICR7V0d9OyBpKyspIHtcbiAgICAgIG1heFZhbHVlID0gbWF4KHdnTWF4W2ldLCBtYXhWYWx1ZSk7XG4gICAgfVxuXG4gICAgdmFyIHN1bVZlY3RvciA9ICR7ZmlsbFZlY3RvcignZjMyJywgY29tcG9uZW50cywgJzAnKX07XG4gICAgZm9yICh2YXIgaTogdTMyID0gMDsgaSA8IHVuaWZvcm1zLmVsZW1lbnRzX3Blcl93ZyAmJiBpICsgbG9jYWxPZmZzZXQgPCB1bmlmb3Jtcy5kX2NvbXA7IGkrKykge1xuICAgICAgc3VtVmVjdG9yICs9IGV4cCgke2Nhc3RUb0YzMihlbGVtVmFsdWVUeXBlLCBjb21wb25lbnRzLCAneFtvZmZzZXQgKyBpXScpfSAtIG1heFZhbHVlKTtcbiAgICB9XG4gICAgd2dTdW1bbG9jYWxfaWR4XSA9ICR7c3VtVmVjdG9yKCdzdW1WZWN0b3InLCBjb21wb25lbnRzKX07XG4gICAgd29ya2dyb3VwQmFycmllcigpO1xuXG4gICAgdmFyIHN1bTogZjMyID0gMDtcbiAgICBmb3IgKHZhciBpID0gMHU7IGkgPCAke1dHfTsgaSsrKSB7XG4gICAgICBzdW0gKz0gd2dTdW1baV07XG4gICAgfVxuXG4gICAgaWYgKHN1bSA9PSAwKSB7XG4gICAgICBmb3IgKHZhciBpOiB1MzIgPSAwOyBpIDwgdW5pZm9ybXMuZWxlbWVudHNfcGVyX3dnICYmIGkgKyBsb2NhbE9mZnNldCA8IHVuaWZvcm1zLmRfY29tcDsgaSsrKSB7XG4gICAgICAgIHhbb2Zmc2V0ICsgaV0gPSAke2ZpbGxWZWN0b3IoJ2YzMicsIGNvbXBvbmVudHMsICd1bmlmb3Jtcy5kX2ludicpfTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZm9yICh2YXIgaTogdTMyID0gMDsgaSA8IHVuaWZvcm1zLmVsZW1lbnRzX3Blcl93ZyAmJiBpICsgbG9jYWxPZmZzZXQgPCB1bmlmb3Jtcy5kX2NvbXA7IGkrKykge1xuICAgICAgICBsZXQgZjMyaW5wdXQgPSAke2Nhc3RUb0YzMihlbGVtVmFsdWVUeXBlLCBjb21wb25lbnRzLCAneFtvZmZzZXQgKyBpXScpfTtcbiAgICAgICAgeFtvZmZzZXQgKyBpXSA9ICR7aW5wdXRIZWxwZXIudHlwZS52YWx1ZX0oZXhwKGYzMmlucHV0IC0gbWF4VmFsdWUpIC8gc3VtKTtcbiAgICAgIH1cbiAgICB9XG4gIH1gO1xuICB9O1xuXG4gIGNvbnRleHQuY29tcHV0ZShcbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ0F0dGVudGlvblByb2JzU29mdG1heCcsXG4gICAgICAgIHNoYWRlckNhY2hlOiB7aGludDogYCR7V0d9OyR7ZGF0YVR5cGV9OyR7Y29tcG9uZW50c31gfSxcbiAgICAgICAgZ2V0U2hhZGVyU291cmNlLFxuICAgICAgICBnZXRSdW5EYXRhOiAoKSA9PiAoe291dHB1dHM6IFtdLCBkaXNwYXRjaEdyb3VwOiB7eDogbn0sIHByb2dyYW1Vbmlmb3Jtc30pLFxuICAgICAgfSxcbiAgICAgIHtpbnB1dHM6IFtpbnB1dF0sIG91dHB1dHM6IFtdfSk7XG59O1xuXG5jb25zdCBjb21wdXRlQXR0ZW50aW9uUHJvYnMgPVxuICAgIChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgcTogVGVuc29yVmlldywga2V5OiBUZW5zb3JWaWV3LCBfYmlhczogVGVuc29yVmlld3x1bmRlZmluZWQsXG4gICAgIHBhcmFtZXRlcnM6IEF0dGVudGlvblBhcmFtZXRlcnMsIGF0dHJpYnV0ZXM6IEF0dGVudGlvbkF0dHJzKSA9PiB7XG4gICAgICBjb25zdCBwcm9ic1NoYXBlID0gW1xuICAgICAgICBwYXJhbWV0ZXJzLmJhdGNoU2l6ZSwgcGFyYW1ldGVycy5udW1IZWFkcywgcGFyYW1ldGVycy5zZXF1ZW5jZUxlbmd0aCxcbiAgICAgICAgcGFyYW1ldGVycy5rdlNlcXVlbmNlTGVuZ3RoICsgcGFyYW1ldGVycy5wYXN0U2VxdWVuY2VMZW5ndGhcbiAgICAgIF07XG4gICAgICAvLyBUT0RPOiBoYW5kbGUgbWFza1xuXG4gICAgICBjb25zdCBhbHBoYSA9IGF0dHJpYnV0ZXMuc2NhbGUgPT09IDAgPyAxLjAgLyBNYXRoLnNxcnQocGFyYW1ldGVycy5oZWFkU2l6ZSkgOiBhdHRyaWJ1dGVzLnNjYWxlO1xuICAgICAgY29uc3QgY29tcG9uZW50cyA9IGdldE1heENvbXBvbmVudHMocGFyYW1ldGVycy5oZWFkU2l6ZSk7XG4gICAgICBjb25zdCB2ZWN0b3JpemVkSGVhZFNpemUgPSBwYXJhbWV0ZXJzLmhlYWRTaXplIC8gY29tcG9uZW50cztcbiAgICAgIGNvbnN0IFRJTEVfU0laRSA9IDEyO1xuICAgICAgY29uc3QgZGlzcGF0Y2ggPSB7XG4gICAgICAgIHg6IE1hdGguY2VpbChwYXJhbWV0ZXJzLnRvdGFsU2VxdWVuY2VMZW5ndGggLyBUSUxFX1NJWkUpLFxuICAgICAgICB5OiBNYXRoLmNlaWwocGFyYW1ldGVycy5zZXF1ZW5jZUxlbmd0aCAvIFRJTEVfU0laRSksXG4gICAgICAgIHo6IHBhcmFtZXRlcnMuYmF0Y2hTaXplICogcGFyYW1ldGVycy5udW1IZWFkc1xuICAgICAgfTtcbiAgICAgIGNvbnN0IHRlbnNvckRhdGFUeXBlID0gdGVuc29yRGF0YVR5cGVFbnVtVG9TdHJpbmcocS5kYXRhVHlwZSkgYXMgUHJvZ3JhbVVuaWZvcm1bJ3R5cGUnXTtcbiAgICAgIGNvbnN0IHByb2dyYW1Vbmlmb3JtczogUHJvZ3JhbVVuaWZvcm1bXSA9IFtcbiAgICAgICAge3R5cGU6ICd1aW50MzInLCBkYXRhOiBwYXJhbWV0ZXJzLnNlcXVlbmNlTGVuZ3RofSwge3R5cGU6ICd1aW50MzInLCBkYXRhOiB2ZWN0b3JpemVkSGVhZFNpemV9LFxuICAgICAgICB7dHlwZTogJ3VpbnQzMicsIGRhdGE6IHBhcmFtZXRlcnMudG90YWxTZXF1ZW5jZUxlbmd0aH0sIHt0eXBlOiAndWludDMyJywgZGF0YTogcGFyYW1ldGVycy5rdlNlcXVlbmNlTGVuZ3RofSxcbiAgICAgICAge3R5cGU6IHRlbnNvckRhdGFUeXBlLCBkYXRhOiBhbHBoYX1cbiAgICAgIF07XG5cbiAgICAgIGNvbnN0IGlucHV0cyA9IFtxLCBrZXldO1xuXG4gICAgICBjb25zdCBnZXRTaGFkZXJTb3VyY2UgPSAoc2hhZGVySGVscGVyOiBTaGFkZXJIZWxwZXIpID0+IHtcbiAgICAgICAgY29uc3QgcUlucHV0ID0gaW5wdXRWYXJpYWJsZSgncScsIHEuZGF0YVR5cGUsIHEuZGltcywgY29tcG9uZW50cyk7XG4gICAgICAgIGNvbnN0IGtJbnB1dCA9IGlucHV0VmFyaWFibGUoJ2tleScsIGtleS5kYXRhVHlwZSwga2V5LmRpbXMsIGNvbXBvbmVudHMpO1xuICAgICAgICBjb25zdCBvdXRwdXQgPSBvdXRwdXRWYXJpYWJsZSgnb3V0cHV0JywgcS5kYXRhVHlwZSwgcHJvYnNTaGFwZSk7XG4gICAgICAgIGNvbnN0IGRhdGFUeXBlID0gdGVuc29yVHlwZVRvV3NnbFN0b3JhZ2VUeXBlKHEuZGF0YVR5cGUpO1xuXG4gICAgICAgIGNvbnN0IHVuaWZvcm1zOiBVbmlmb3Jtc0FycmF5VHlwZSA9IFtcbiAgICAgICAgICB7bmFtZTogJ00nLCB0eXBlOiAndTMyJ30sIHtuYW1lOiAnSycsIHR5cGU6ICd1MzInfSwge25hbWU6ICdOJywgdHlwZTogJ3UzMid9LFxuICAgICAgICAgIHtuYW1lOiAna3Zfc2VxdWVuY2VfbGVuZ3RoJywgdHlwZTogJ3UzMid9LCB7bmFtZTogJ2FscGhhJywgdHlwZTogZGF0YVR5cGUgYXMgVW5pZm9ybURhdGFFbGVtZW50VHlwZX1cbiAgICAgICAgXTtcbiAgICAgICAgcmV0dXJuIGBcbiAgY29uc3QgYmV0YTogJHtkYXRhVHlwZX0gPSAxLjA7XG4gIGNvbnN0IFRJTEVfU0laRSA9ICR7VElMRV9TSVpFfXU7XG5cbiAgdmFyPHdvcmtncm91cD4gdGlsZVE6IGFycmF5PCR7cUlucHV0LnR5cGUuc3RvcmFnZX0sICR7VElMRV9TSVpFICogVElMRV9TSVpFfT47XG4gIHZhcjx3b3JrZ3JvdXA+IHRpbGVLOiBhcnJheTwke3FJbnB1dC50eXBlLnN0b3JhZ2V9LCAke1RJTEVfU0laRSAqIFRJTEVfU0laRX0+O1xuICAke3NoYWRlckhlbHBlci5yZWdpc3RlclVuaWZvcm1zKHVuaWZvcm1zKS5kZWNsYXJlVmFyaWFibGVzKHFJbnB1dCwga0lucHV0LCBvdXRwdXQpfVxuICAke3NoYWRlckhlbHBlci5tYWluU3RhcnQoW1xuICAgICAgICAgIFRJTEVfU0laRSwgVElMRV9TSVpFLCAxXG4gICAgICAgIF0pfVxuICAgIC8vIHggaG9sZHMgdGhlIE4gYW5kIHkgaG9sZHMgdGhlIE1cbiAgICBsZXQgaGVhZElkeCA9IHdvcmtncm91cF9pZC56O1xuICAgIGxldCBtID0gd29ya2dyb3VwX2lkLnkgKiBUSUxFX1NJWkU7XG4gICAgbGV0IG4gPSB3b3JrZ3JvdXBfaWQueCAqIFRJTEVfU0laRTtcbiAgICBsZXQgbG0gPSBtICsgbG9jYWxfaWQueTtcbiAgICBsZXQgbG4gPSBuICsgbG9jYWxfaWQueDtcblxuICAgIGxldCBxT2Zmc2V0ID0gdW5pZm9ybXMuTSAqIHVuaWZvcm1zLksgKiBoZWFkSWR4ICsgbSAqIHVuaWZvcm1zLks7XG4gICAgbGV0IGtPZmZzZXQgPSB1bmlmb3Jtcy5rdl9zZXF1ZW5jZV9sZW5ndGggKiB1bmlmb3Jtcy5LICogaGVhZElkeCArIG4gKiB1bmlmb3Jtcy5LO1xuXG4gICAgdmFyIHZhbHVlID0gJHtmaWxsVmVjdG9yKGRhdGFUeXBlLCBjb21wb25lbnRzKX07XG4gICAgZm9yICh2YXIgdzogdTMyID0gMHU7IHcgPCB1bmlmb3Jtcy5LOyB3ICs9IFRJTEVfU0laRSkge1xuICAgICAgaWYgKG0gKyBsb2NhbF9pZC55IDwgdW5pZm9ybXMuTSAmJiB3ICsgbG9jYWxfaWQueCA8IHVuaWZvcm1zLkspIHtcbiAgICAgICAgdGlsZVFbVElMRV9TSVpFICogbG9jYWxfaWQueSArIGxvY2FsX2lkLnhdID0gcVtxT2Zmc2V0ICsgbG9jYWxfaWQueSAqIHVuaWZvcm1zLksgKyB3ICsgbG9jYWxfaWQueF07XG4gICAgICB9XG4gICAgICBpZiAobiArIGxvY2FsX2lkLnkgPCB1bmlmb3Jtcy5OICYmIHcgKyBsb2NhbF9pZC54IDwgdW5pZm9ybXMuSykge1xuICAgICAgICB0aWxlS1tUSUxFX1NJWkUgKiBsb2NhbF9pZC55ICsgbG9jYWxfaWQueF0gPSBrZXlba09mZnNldCArIGxvY2FsX2lkLnkgKiB1bmlmb3Jtcy5LICsgdyArIGxvY2FsX2lkLnhdO1xuICAgICAgfVxuICAgICAgd29ya2dyb3VwQmFycmllcigpO1xuXG4gICAgICBmb3IgKHZhciBrOiB1MzIgPSAwdTsgazxUSUxFX1NJWkUgJiYgdytrIDwgdW5pZm9ybXMuSzsgaysrKSB7XG4gICAgICAgIHZhbHVlICs9IHRpbGVRW1RJTEVfU0laRSAqIGxvY2FsX2lkLnkgKyBrXSAqIHRpbGVLW1RJTEVfU0laRSAqIGxvY2FsX2lkLnggKyBrXTtcbiAgICAgIH1cblxuICAgICAgd29ya2dyb3VwQmFycmllcigpO1xuICAgIH1cblxuICAgIGxldCBoZWFkT2Zmc2V0ID0gaGVhZElkeCAqIHVuaWZvcm1zLk0gKiB1bmlmb3Jtcy5OO1xuICAgIGlmIChsbSA8IHVuaWZvcm1zLk0gJiYgbG4gPCB1bmlmb3Jtcy5OKSB7XG4gICAgICBsZXQgb3V0cHV0SWR4ID0gaGVhZE9mZnNldCArIGxtICogdW5pZm9ybXMuTiArIGxuO1xuICAgICAgb3V0cHV0W291dHB1dElkeF0gPSAke3N1bVZlY3RvcigndmFsdWUnLCBjb21wb25lbnRzKX0gKiB1bmlmb3Jtcy5hbHBoYTtcbiAgICB9XG4gIH1gO1xuICAgICAgfTtcblxuICAgICAgY29uc3QgcHJvYnMgPSBjb250ZXh0LmNvbXB1dGUoXG4gICAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0F0dGVudGlvblByb2JzJyxcbiAgICAgICAgICAgIHNoYWRlckNhY2hlOiB7aGludDogYCR7Y29tcG9uZW50c31gLCBpbnB1dERlcGVuZGVuY2llczogWyd0eXBlJywgJ3R5cGUnXX0sXG4gICAgICAgICAgICBnZXRSdW5EYXRhOiAoKSA9PiAoe1xuICAgICAgICAgICAgICBvdXRwdXRzOiBbe2RpbXM6IHByb2JzU2hhcGUsIGRhdGFUeXBlOiBxLmRhdGFUeXBlLCBncHVEYXRhVHlwZTogR3B1RGF0YVR5cGUuZGVmYXVsdH1dLFxuICAgICAgICAgICAgICBkaXNwYXRjaEdyb3VwOiBkaXNwYXRjaCxcbiAgICAgICAgICAgICAgcHJvZ3JhbVVuaWZvcm1zXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGdldFNoYWRlclNvdXJjZSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIHtpbnB1dHMsIG91dHB1dHM6IFstMV19KVswXTtcblxuICAgICAgY29tcHV0ZUluUGxhY2VTb2Z0bWF4KFxuICAgICAgICAgIGNvbnRleHQsIHByb2JzLCBwYXJhbWV0ZXJzLmJhdGNoU2l6ZSAqIHBhcmFtZXRlcnMubnVtSGVhZHMgKiBwYXJhbWV0ZXJzLnNlcXVlbmNlTGVuZ3RoLFxuICAgICAgICAgIHBhcmFtZXRlcnMudG90YWxTZXF1ZW5jZUxlbmd0aCk7XG5cbiAgICAgIHJldHVybiBwcm9icztcbiAgICB9O1xuXG5jb25zdCBjb21wdXRlVnhBdHRlbnRpb25TY29yZSA9XG4gICAgKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBwcm9iczogVGVuc29yVmlldywgdjogVGVuc29yVmlldywgcGFyYW1zOiBBdHRlbnRpb25QYXJhbWV0ZXJzKSA9PiB7XG4gICAgICBjb25zdCBvdXRwdXRTaGFwZSA9IFtwYXJhbXMuYmF0Y2hTaXplLCBwYXJhbXMuc2VxdWVuY2VMZW5ndGgsIHBhcmFtcy52SGlkZGVuU2l6ZV07XG4gICAgICBjb25zdCBUSUxFX1NJWkUgPSAxMjtcbiAgICAgIGNvbnN0IGRpc3BhdGNoID0ge1xuICAgICAgICB4OiBNYXRoLmNlaWwocGFyYW1zLnZIZWFkU2l6ZSAvIFRJTEVfU0laRSksXG4gICAgICAgIHk6IE1hdGguY2VpbChwYXJhbXMuc2VxdWVuY2VMZW5ndGggLyBUSUxFX1NJWkUpLFxuICAgICAgICB6OiBwYXJhbXMuYmF0Y2hTaXplICogcGFyYW1zLm51bUhlYWRzXG4gICAgICB9O1xuICAgICAgY29uc3QgcHJvZ3JhbVVuaWZvcm1zOiBQcm9ncmFtVW5pZm9ybVtdID0gW1xuICAgICAgICB7dHlwZTogJ3VpbnQzMicsIGRhdGE6IHBhcmFtcy5zZXF1ZW5jZUxlbmd0aH0sIHt0eXBlOiAndWludDMyJywgZGF0YTogcGFyYW1zLnRvdGFsU2VxdWVuY2VMZW5ndGh9LFxuICAgICAgICB7dHlwZTogJ3VpbnQzMicsIGRhdGE6IHBhcmFtcy52SGVhZFNpemV9LCB7dHlwZTogJ3VpbnQzMicsIGRhdGE6IHBhcmFtcy5udW1IZWFkc30sXG4gICAgICAgIHt0eXBlOiAndWludDMyJywgZGF0YTogcGFyYW1zLnZIaWRkZW5TaXplfVxuICAgICAgXTtcblxuICAgICAgY29uc3QgZ2V0U2hhZGVyU291cmNlID0gKHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyKSA9PiB7XG4gICAgICAgIGNvbnN0IHByb2JzSGVscGVyID0gaW5wdXRWYXJpYWJsZSgncHJvYnMnLCBwcm9icy5kYXRhVHlwZSwgcHJvYnMuZGltcyk7XG4gICAgICAgIGNvbnN0IHZIZWxwZXIgPSBpbnB1dFZhcmlhYmxlKCd2Jywgdi5kYXRhVHlwZSwgdi5kaW1zKTtcbiAgICAgICAgY29uc3Qgb3V0cHV0ID0gb3V0cHV0VmFyaWFibGUoJ291dHB1dCcsIHByb2JzLmRhdGFUeXBlLCBvdXRwdXRTaGFwZSk7XG4gICAgICAgIGNvbnN0IHVuaWZvcm1zOiBVbmlmb3Jtc0FycmF5VHlwZSA9IFtcbiAgICAgICAgICB7bmFtZTogJ00nLCB0eXBlOiAndTMyJ30sIHtuYW1lOiAnSycsIHR5cGU6ICd1MzInfSwge25hbWU6ICdOJywgdHlwZTogJ3UzMid9LFxuICAgICAgICAgIHtuYW1lOiAnbnVtX2hlYWRzJywgdHlwZTogJ3UzMid9LCB7bmFtZTogJ3ZfaGlkZGVuX3NpemUnLCB0eXBlOiAndTMyJ31cbiAgICAgICAgXTtcbiAgICAgICAgcmV0dXJuIGBcbiAgY29uc3QgVElMRV9TSVpFID0gJHtUSUxFX1NJWkV9dTtcbiAgdmFyPHdvcmtncm91cD4gdGlsZVE6IGFycmF5PCR7cHJvYnNIZWxwZXIudHlwZS52YWx1ZX0sICR7VElMRV9TSVpFICogVElMRV9TSVpFfT47XG4gIHZhcjx3b3JrZ3JvdXA+IHRpbGVLOiBhcnJheTwke3Byb2JzSGVscGVyLnR5cGUudmFsdWV9LCAke1RJTEVfU0laRSAqIFRJTEVfU0laRX0+O1xuICAke3NoYWRlckhlbHBlci5yZWdpc3RlclVuaWZvcm1zKHVuaWZvcm1zKS5kZWNsYXJlVmFyaWFibGVzKHByb2JzSGVscGVyLCB2SGVscGVyLCBvdXRwdXQpfVxuICAke3NoYWRlckhlbHBlci5tYWluU3RhcnQoW1xuICAgICAgICAgIFRJTEVfU0laRSwgVElMRV9TSVpFLCAxXG4gICAgICAgIF0pfVxuICAgbGV0IGhlYWRJZHggPSB3b3JrZ3JvdXBfaWQuejtcbiAgIGxldCBtID0gd29ya2dyb3VwX2lkLnkgKiBUSUxFX1NJWkUgKyBsb2NhbF9pZC55O1xuICAgbGV0IG4gPSB3b3JrZ3JvdXBfaWQueCAqIFRJTEVfU0laRSArIGxvY2FsX2lkLng7XG5cbiAgIGxldCBvZmZzZXRBID0gaGVhZElkeCAqICh1bmlmb3Jtcy5NICogdW5pZm9ybXMuSykgKyBtICogdW5pZm9ybXMuSztcbiAgIGxldCBvZmZzZXRCID0gaGVhZElkeCAqICh1bmlmb3Jtcy5OICogdW5pZm9ybXMuSykgKyBuO1xuXG4gICB2YXIgdmFsdWUgPSAke3Byb2JzSGVscGVyLnR5cGUuc3RvcmFnZX0oMCk7XG4gICBmb3IgKHZhciB3OiB1MzIgPSAwdTsgdyA8IHVuaWZvcm1zLks7IHcgKz0gVElMRV9TSVpFKSB7XG4gICAgIGlmIChtIDwgdW5pZm9ybXMuTSAmJiB3ICsgbG9jYWxfaWQueCA8IHVuaWZvcm1zLkspIHtcbiAgICAgICB0aWxlUVtUSUxFX1NJWkUgKiBsb2NhbF9pZC55ICsgbG9jYWxfaWQueF0gPSBwcm9ic1tvZmZzZXRBICsgdyArIGxvY2FsX2lkLnhdO1xuICAgICB9XG4gICAgIGlmIChuIDwgdW5pZm9ybXMuTiAmJiB3ICsgbG9jYWxfaWQueSA8IHVuaWZvcm1zLkspIHtcbiAgICAgICB0aWxlS1tUSUxFX1NJWkUgKiBsb2NhbF9pZC55ICsgbG9jYWxfaWQueF0gPSB2W29mZnNldEIgKyAodyArIGxvY2FsX2lkLnkpICogdW5pZm9ybXMuTl07XG4gICAgIH1cbiAgICAgd29ya2dyb3VwQmFycmllcigpO1xuICAgICBmb3IgKHZhciBrOiB1MzIgPSAwdTsgazxUSUxFX1NJWkUgJiYgdytrIDwgdW5pZm9ybXMuSzsgaysrKSB7XG4gICAgICAgdmFsdWUgKz0gdGlsZVFbVElMRV9TSVpFICogbG9jYWxfaWQueSArIGtdICogdGlsZUtbVElMRV9TSVpFICogayArIGxvY2FsX2lkLnhdO1xuICAgICB9XG4gICAgIHdvcmtncm91cEJhcnJpZXIoKTtcbiAgIH1cblxuICAgLy8gd2UgbmVlZCB0byB0cmFuc3Bvc2Ugb3V0cHV0IGZyb20gQk5TSF92IHRvIEJTTkRfdlxuICAgbGV0IGJhdGNoSWR4ID0gd29ya2dyb3VwX2lkLnogLyB1bmlmb3Jtcy5udW1faGVhZHM7XG4gICBsZXQgY3VycmVudEJhdGNoSGVhZE51bWJlciA9IHdvcmtncm91cF9pZC56ICUgdW5pZm9ybXMubnVtX2hlYWRzO1xuICAgbGV0IGhlYWRPZmZzZXQgPSAoYmF0Y2hJZHggKiB1bmlmb3Jtcy5NICogdW5pZm9ybXMubnVtX2hlYWRzICsgY3VycmVudEJhdGNoSGVhZE51bWJlcikgKiB1bmlmb3Jtcy5OO1xuICAgaWYgKG0gPCB1bmlmb3Jtcy5NICYmIG4gPCB1bmlmb3Jtcy5OKSB7XG4gICAgIGxldCBvdXRwdXRJZHggPSBiYXRjaElkeCAqIHVuaWZvcm1zLk0gKnVuaWZvcm1zLnZfaGlkZGVuX3NpemUgKyBtICogdW5pZm9ybXMudl9oaWRkZW5fc2l6ZVxuICAgICAgICsgY3VycmVudEJhdGNoSGVhZE51bWJlciAqIHVuaWZvcm1zLk4gKyBuO1xuICAgICBvdXRwdXRbb3V0cHV0SWR4XSA9IHZhbHVlO1xuICAgfVxuICB9YDtcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBjb250ZXh0LmNvbXB1dGUoXG4gICAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0F0dGVudGlvblNjb3JlJyxcbiAgICAgICAgICAgIHNoYWRlckNhY2hlOiB7aW5wdXREZXBlbmRlbmNpZXM6IFsndHlwZScsICd0eXBlJ119LFxuICAgICAgICAgICAgZ2V0UnVuRGF0YTogKCkgPT4gKHtcbiAgICAgICAgICAgICAgb3V0cHV0czogW3tkaW1zOiBvdXRwdXRTaGFwZSwgZGF0YVR5cGU6IHByb2JzLmRhdGFUeXBlLCBncHVEYXRhVHlwZTogR3B1RGF0YVR5cGUuZGVmYXVsdH1dLFxuICAgICAgICAgICAgICBkaXNwYXRjaEdyb3VwOiBkaXNwYXRjaCxcbiAgICAgICAgICAgICAgcHJvZ3JhbVVuaWZvcm1zXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGdldFNoYWRlclNvdXJjZSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIHtpbnB1dHM6IFtwcm9icywgdl0sIG91dHB1dHM6IFswXX0pWzBdO1xuICAgIH07XG5cbmV4cG9ydCBjb25zdCBhcHBseUF0dGVudGlvbiA9XG4gICAgKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBxOiBUZW5zb3JWaWV3LCBrOiBUZW5zb3JWaWV3LCB2OiBUZW5zb3JWaWV3LCBfbWFza0luZGV4OiBUZW5zb3JWaWV3fHVuZGVmaW5lZCxcbiAgICAgX3Bhc3Q6IFRlbnNvclZpZXd8dW5kZWZpbmVkLCBfcGFzdEtleTogVGVuc29yVmlld3x1bmRlZmluZWQsIF9wYXN0VmFsdWU6IFRlbnNvclZpZXd8dW5kZWZpbmVkLFxuICAgICByZWxhdGl2ZVBvc2l0aW9uQmlhczogVGVuc29yVmlld3x1bmRlZmluZWQsIHBhcmFtZXRlcnM6IEF0dGVudGlvblBhcmFtZXRlcnMsIGF0dHJpYnV0ZXM6IEF0dGVudGlvbkF0dHJzKSA9PiB7XG4gICAgICBjb25zdCBwcm9icyA9IGNvbXB1dGVBdHRlbnRpb25Qcm9icyhjb250ZXh0LCBxLCBrLCByZWxhdGl2ZVBvc2l0aW9uQmlhcywgcGFyYW1ldGVycywgYXR0cmlidXRlcyk7XG5cbiAgICAgIGNvbXB1dGVWeEF0dGVudGlvblNjb3JlKGNvbnRleHQsIHByb2JzLCB2LCBwYXJhbWV0ZXJzKTtcbiAgICB9O1xuXG5jb25zdCBwcmVwYXJlID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBwYXJhbWV0ZXJzOiBBdHRlbnRpb25QYXJhbWV0ZXJzKSA9PiB7XG4gIGNvbnN0IG91dHB1dFNoYXBlID0gW1xuICAgIHBhcmFtZXRlcnMuYmF0Y2hTaXplLFxuICAgIHBhcmFtZXRlcnMubnVtSGVhZHMsXG4gICAgcGFyYW1ldGVycy5zZXF1ZW5jZUxlbmd0aCxcbiAgICBwYXJhbWV0ZXJzLmhlYWRTaXplLFxuICBdO1xuICBjb25zdCBNID0gcGFyYW1ldGVycy5zZXF1ZW5jZUxlbmd0aDtcbiAgY29uc3QgSyA9IHBhcmFtZXRlcnMuaW5wdXRIaWRkZW5TaXplO1xuICBjb25zdCBOID0gcGFyYW1ldGVycy5oZWFkU2l6ZTtcbiAgY29uc3QgVElMRV9TSVpFID0gMTI7XG4gIGNvbnN0IGRpc3BhdGNoID0ge1xuICAgIHg6IE1hdGguY2VpbChwYXJhbWV0ZXJzLmhlYWRTaXplIC8gVElMRV9TSVpFKSxcbiAgICB5OiBNYXRoLmNlaWwocGFyYW1ldGVycy5zZXF1ZW5jZUxlbmd0aCAvIFRJTEVfU0laRSksXG4gICAgejogcGFyYW1ldGVycy5iYXRjaFNpemUgKiBwYXJhbWV0ZXJzLm51bUhlYWRzXG4gIH07XG4gIGNvbnN0IGlucHV0cyA9IFtjb250ZXh0LmlucHV0c1swXSwgY29udGV4dC5pbnB1dHNbMV0sIGNvbnRleHQuaW5wdXRzWzJdXTtcbiAgY29uc3QgcHJvZ3JhbVVuaWZvcm1zOiBQcm9ncmFtVW5pZm9ybVtdID0gW1xuICAgIHt0eXBlOiAndWludDMyJywgZGF0YTogTX0sIHt0eXBlOiAndWludDMyJywgZGF0YTogS30sIHt0eXBlOiAndWludDMyJywgZGF0YTogTn0sXG4gICAge3R5cGU6ICd1aW50MzInLCBkYXRhOiBwYXJhbWV0ZXJzLm51bUhlYWRzfSwge3R5cGU6ICd1aW50MzInLCBkYXRhOiBwYXJhbWV0ZXJzLmhlYWRTaXplfSxcbiAgICB7dHlwZTogJ3VpbnQzMicsIGRhdGE6IHBhcmFtZXRlcnMuaGlkZGVuU2l6ZX0sXG4gICAge3R5cGU6ICd1aW50MzInLCBkYXRhOiBwYXJhbWV0ZXJzLmhpZGRlblNpemUgKyBwYXJhbWV0ZXJzLmhpZGRlblNpemUgKyBwYXJhbWV0ZXJzLnZIaWRkZW5TaXplfVxuICBdO1xuXG4gIGNvbnN0IGdldFNoYWRlclNvdXJjZSA9IChzaGFkZXJIZWxwZXI6IFNoYWRlckhlbHBlcikgPT4ge1xuICAgIGNvbnN0IG91dHB1dFEgPSBvdXRwdXRWYXJpYWJsZSgnb3V0cHV0X3EnLCBpbnB1dHNbMF0uZGF0YVR5cGUsIG91dHB1dFNoYXBlKTtcbiAgICBjb25zdCBvdXRwdXRLID0gb3V0cHV0VmFyaWFibGUoJ291dHB1dF9rJywgaW5wdXRzWzBdLmRhdGFUeXBlLCBvdXRwdXRTaGFwZSk7XG4gICAgY29uc3Qgb3V0cHV0ViA9IG91dHB1dFZhcmlhYmxlKCdvdXRwdXRfdicsIGlucHV0c1swXS5kYXRhVHlwZSwgb3V0cHV0U2hhcGUpO1xuICAgIGNvbnN0IGlucHV0ID0gaW5wdXRWYXJpYWJsZSgnaW5wdXQnLCBpbnB1dHNbMF0uZGF0YVR5cGUsIGlucHV0c1swXS5kaW1zKTtcbiAgICBjb25zdCB3ZWlnaHQgPSBpbnB1dFZhcmlhYmxlKCd3ZWlnaHQnLCBpbnB1dHNbMV0uZGF0YVR5cGUsIGlucHV0c1sxXS5kaW1zKTtcbiAgICBjb25zdCBiaWFzID0gaW5wdXRWYXJpYWJsZSgnYmlhcycsIGlucHV0c1syXS5kYXRhVHlwZSwgaW5wdXRzWzJdLmRpbXMpO1xuICAgIGNvbnN0IGRhdGFUeXBlID0gaW5wdXQudHlwZS5zdG9yYWdlO1xuXG4gICAgY29uc3QgdW5pZm9ybXM6IFVuaWZvcm1zQXJyYXlUeXBlID0gW1xuICAgICAge25hbWU6ICdNJywgdHlwZTogJ3UzMid9LCB7bmFtZTogJ0snLCB0eXBlOiAndTMyJ30sIHtuYW1lOiAnTicsIHR5cGU6ICd1MzInfSwge25hbWU6ICdudW1faGVhZHMnLCB0eXBlOiAndTMyJ30sXG4gICAgICB7bmFtZTogJ2hlYWRfc2l6ZScsIHR5cGU6ICd1MzInfSwge25hbWU6ICdoaWRkZW5fc2l6ZScsIHR5cGU6ICd1MzInfSwge25hbWU6ICdsZGInLCB0eXBlOiAndTMyJ31cbiAgICBdO1xuICAgIHJldHVybiBgXG4gIGNvbnN0IFRJTEVfU0laRSA9ICR7VElMRV9TSVpFfXU7XG4gIHZhcjx3b3JrZ3JvdXA+IHRpbGVJbnB1dDogYXJyYXk8JHtkYXRhVHlwZX0sICR7VElMRV9TSVpFICogVElMRV9TSVpFfT47XG4gIHZhcjx3b3JrZ3JvdXA+IHRpbGVXZWlnaHRROiBhcnJheTwke2RhdGFUeXBlfSwgJHtUSUxFX1NJWkUgKiBUSUxFX1NJWkV9PjtcbiAgdmFyPHdvcmtncm91cD4gdGlsZVdlaWdodEs6IGFycmF5PCR7ZGF0YVR5cGV9LCAke1RJTEVfU0laRSAqIFRJTEVfU0laRX0+O1xuICB2YXI8d29ya2dyb3VwPiB0aWxlV2VpZ2h0VjogYXJyYXk8JHtkYXRhVHlwZX0sICR7VElMRV9TSVpFICogVElMRV9TSVpFfT47XG4gICR7c2hhZGVySGVscGVyLnJlZ2lzdGVyVW5pZm9ybXModW5pZm9ybXMpLmRlY2xhcmVWYXJpYWJsZXMoaW5wdXQsIHdlaWdodCwgYmlhcywgb3V0cHV0USwgb3V0cHV0Sywgb3V0cHV0Vil9XG4gICR7c2hhZGVySGVscGVyLm1haW5TdGFydChbXG4gICAgICBUSUxFX1NJWkUsIFRJTEVfU0laRSwgMVxuICAgIF0pfVxuICAgIGxldCBiYXRjaEluZGV4ID0gd29ya2dyb3VwX2lkLnogLyB1bmlmb3Jtcy5udW1faGVhZHM7XG4gICAgbGV0IGhlYWROdW1iZXIgPSB3b3JrZ3JvdXBfaWQueiAlIHVuaWZvcm1zLm51bV9oZWFkcztcbiAgICBsZXQgbSA9IHdvcmtncm91cF9pZC55ICogVElMRV9TSVpFICsgbG9jYWxfaWQueTtcbiAgICBsZXQgbiA9IHdvcmtncm91cF9pZC54ICogVElMRV9TSVpFICsgbG9jYWxfaWQueDtcblxuICAgIGxldCBpbnB1dE9mZnNldCA9IGJhdGNoSW5kZXggKiAodW5pZm9ybXMuTSAqIHVuaWZvcm1zLkspICsgbSAqIHVuaWZvcm1zLks7XG4gICAgbGV0IGJpYXNPZmZzZXRRID0gaGVhZE51bWJlciAqIHVuaWZvcm1zLmhlYWRfc2l6ZTtcbiAgICBsZXQgYmlhc09mZnNldEsgPSB1bmlmb3Jtcy5oaWRkZW5fc2l6ZSArIGJpYXNPZmZzZXRRO1xuICAgIGxldCBiaWFzT2Zmc2V0ViA9IHVuaWZvcm1zLmhpZGRlbl9zaXplICsgYmlhc09mZnNldEs7XG5cbiAgICB2YXIgdmFsdWVRID0gJHtkYXRhVHlwZX0oMCk7XG4gICAgdmFyIHZhbHVlSyA9ICR7ZGF0YVR5cGV9KDApO1xuICAgIHZhciB2YWx1ZVYgPSAke2RhdGFUeXBlfSgwKTtcbiAgICBmb3IgKHZhciB3OiB1MzIgPSAwdTsgdyA8IHVuaWZvcm1zLks7IHcgKz0gVElMRV9TSVpFKSB7XG4gICAgICBpZiAobSA8IHVuaWZvcm1zLk0gJiYgdyArIGxvY2FsX2lkLnggPCB1bmlmb3Jtcy5LKSB7XG4gICAgICAgIHRpbGVJbnB1dFtUSUxFX1NJWkUgKiBsb2NhbF9pZC55ICsgbG9jYWxfaWQueF0gPSBpbnB1dFtpbnB1dE9mZnNldCArIHcgKyBsb2NhbF9pZC54XTtcbiAgICAgIH1cbiAgICAgIGlmIChuIDwgdW5pZm9ybXMuTiAmJiB3ICsgbG9jYWxfaWQueSA8IHVuaWZvcm1zLkspIHtcbiAgICAgICAgbGV0IG9mZnNldCA9IG4gKyAodyArIGxvY2FsX2lkLnkpICogdW5pZm9ybXMubGRiO1xuICAgICAgICB0aWxlV2VpZ2h0UVtUSUxFX1NJWkUgKiBsb2NhbF9pZC55ICsgbG9jYWxfaWQueF0gPSB3ZWlnaHRbYmlhc09mZnNldFEgKyBvZmZzZXRdO1xuICAgICAgICB0aWxlV2VpZ2h0S1tUSUxFX1NJWkUgKiBsb2NhbF9pZC55ICsgbG9jYWxfaWQueF0gPSB3ZWlnaHRbYmlhc09mZnNldEsgKyBvZmZzZXRdO1xuICAgICAgICB0aWxlV2VpZ2h0VltUSUxFX1NJWkUgKiBsb2NhbF9pZC55ICsgbG9jYWxfaWQueF0gPSB3ZWlnaHRbYmlhc09mZnNldFYgKyBvZmZzZXRdO1xuICAgICAgfVxuICAgICAgd29ya2dyb3VwQmFycmllcigpO1xuICAgICAgZm9yICh2YXIgazogdTMyID0gMHU7IGs8VElMRV9TSVpFICYmIHcrayA8IHVuaWZvcm1zLks7IGsrKykge1xuICAgICAgICBsZXQgaW5wdXRUaWxlT2Zmc2V0ID0gVElMRV9TSVpFICogbG9jYWxfaWQueSArIGs7XG4gICAgICAgIGxldCB3ZWlnaHRUaWxlT2Zmc2V0ID0gVElMRV9TSVpFICogayArIGxvY2FsX2lkLng7XG4gICAgICAgIHZhbHVlUSArPSB0aWxlSW5wdXRbaW5wdXRUaWxlT2Zmc2V0XSAqIHRpbGVXZWlnaHRRW3dlaWdodFRpbGVPZmZzZXRdO1xuICAgICAgICB2YWx1ZUsgKz0gdGlsZUlucHV0W2lucHV0VGlsZU9mZnNldF0gKiB0aWxlV2VpZ2h0S1t3ZWlnaHRUaWxlT2Zmc2V0XTtcbiAgICAgICAgdmFsdWVWICs9IHRpbGVJbnB1dFtpbnB1dFRpbGVPZmZzZXRdICogdGlsZVdlaWdodFZbd2VpZ2h0VGlsZU9mZnNldF07XG4gICAgICB9XG5cbiAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcbiAgICB9XG5cbiAgICBsZXQgaGVhZE9mZnNldCA9IChtICogdW5pZm9ybXMuTiArIG4pICUgdW5pZm9ybXMuaGVhZF9zaXplO1xuICAgIHZhbHVlUSArPSBiaWFzW2hlYWRPZmZzZXQgKyBiaWFzT2Zmc2V0UV07XG4gICAgdmFsdWVLICs9IGJpYXNbaGVhZE9mZnNldCArIGJpYXNPZmZzZXRLXTtcbiAgICB2YWx1ZVYgKz0gYmlhc1toZWFkT2Zmc2V0ICsgYmlhc09mZnNldFZdO1xuXG4gICAgbGV0IG9mZnNldCA9IHdvcmtncm91cF9pZC56ICogdW5pZm9ybXMuTSAqIHVuaWZvcm1zLk47XG4gICAgaWYgKG0gPCB1bmlmb3Jtcy5NICYmIG4gPCB1bmlmb3Jtcy5OKSB7XG4gICAgICBsZXQgb3V0cHV0SWR4ID0gb2Zmc2V0ICsgbSAqIHVuaWZvcm1zLk4gKyBuO1xuICAgICAgb3V0cHV0X3Fbb3V0cHV0SWR4XSA9IHZhbHVlUTtcbiAgICAgIG91dHB1dF9rW291dHB1dElkeF0gPSB2YWx1ZUs7XG4gICAgICBvdXRwdXRfdltvdXRwdXRJZHhdID0gdmFsdWVWO1xuICAgIH1cbiAgfWA7XG4gIH07XG5cbiAgcmV0dXJuIGNvbnRleHQuY29tcHV0ZShcbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ0F0dGVudGlvblByZXBhcmUnLFxuICAgICAgICBzaGFkZXJDYWNoZToge2lucHV0RGVwZW5kZW5jaWVzOiBbJ3R5cGUnLCAndHlwZScsICd0eXBlJ119LFxuICAgICAgICBnZXRSdW5EYXRhOiAoKSA9PiAoe1xuICAgICAgICAgIG91dHB1dHM6IFtcbiAgICAgICAgICAgIHtkaW1zOiBvdXRwdXRTaGFwZSwgZGF0YVR5cGU6IGNvbnRleHQuaW5wdXRzWzBdLmRhdGFUeXBlLCBncHVEYXRhVHlwZTogR3B1RGF0YVR5cGUuZGVmYXVsdH0sXG4gICAgICAgICAgICB7ZGltczogb3V0cHV0U2hhcGUsIGRhdGFUeXBlOiBjb250ZXh0LmlucHV0c1swXS5kYXRhVHlwZSwgZ3B1RGF0YVR5cGU6IEdwdURhdGFUeXBlLmRlZmF1bHR9LFxuICAgICAgICAgICAge2RpbXM6IG91dHB1dFNoYXBlLCBkYXRhVHlwZTogY29udGV4dC5pbnB1dHNbMF0uZGF0YVR5cGUsIGdwdURhdGFUeXBlOiBHcHVEYXRhVHlwZS5kZWZhdWx0fSxcbiAgICAgICAgICBdLFxuICAgICAgICAgIGRpc3BhdGNoR3JvdXA6IGRpc3BhdGNoLFxuICAgICAgICAgIHByb2dyYW1Vbmlmb3Jtc1xuICAgICAgICB9KSxcbiAgICAgICAgZ2V0U2hhZGVyU291cmNlLFxuICAgICAgfSxcbiAgICAgIHtpbnB1dHMsIG91dHB1dHM6IFstMSwgLTEsIC0xXX0pO1xufTtcblxuZXhwb3J0IGNvbnN0IGF0dGVudGlvbiA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogQXR0ZW50aW9uQXR0cnMpOiB2b2lkID0+IHtcbiAgY29uc3QgcGFyYW1zID0gdmFsaWRhdGVBdHRlbnRpb25JbnB1dHMoY29udGV4dC5pbnB1dHMsIGF0dHJpYnV0ZXMpO1xuXG4gIGNvbnN0IFtxLCBrLCB2XSA9IHByZXBhcmUoY29udGV4dCwgcGFyYW1zKTtcblxuICByZXR1cm4gYXBwbHlBdHRlbnRpb24oXG4gICAgICBjb250ZXh0LCBxLCBrLCB2LCBjb250ZXh0LmlucHV0c1s0XSwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgY29udGV4dC5pbnB1dHNbNV0sIHBhcmFtcywgYXR0cmlidXRlcyk7XG59O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge2Vudn0gZnJvbSAnb25ueHJ1bnRpbWUtY29tbW9uJztcblxuaW1wb3J0IHtUZW5zb3JWaWV3fSBmcm9tICcuLi8uLi90ZW5zb3Itdmlldyc7XG5pbXBvcnQge1NoYXBlVXRpbH0gZnJvbSAnLi4vLi4vdXRpbCc7XG5pbXBvcnQge0F0dHJpYnV0ZVdpdGhDYWNoZUtleSwgY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5fSBmcm9tICcuLi9hdHRyaWJ1dGUtd2l0aC1jYWNoZS1rZXknO1xuaW1wb3J0IHtDb21wdXRlQ29udGV4dCwgUHJvZ3JhbUluZm99IGZyb20gJy4uL3R5cGVzJztcblxuaW1wb3J0IHtjcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcywgZW5hYmxlU2hhcGVzVW5pZm9ybXMsIGdldE1heENvbXBvbmVudHMsIGlucHV0VmFyaWFibGUsIG91dHB1dFZhcmlhYmxlLCBTaGFkZXJIZWxwZXJ9IGZyb20gJy4vY29tbW9uJztcblxuZXhwb3J0IGludGVyZmFjZSBCYXRjaE5vcm1BdHRyaWJ1dGVzIGV4dGVuZHMgQXR0cmlidXRlV2l0aENhY2hlS2V5IHtcbiAgcmVhZG9ubHkgZXBzaWxvbjogbnVtYmVyO1xuICByZWFkb25seSBtb21lbnR1bTogbnVtYmVyO1xuICByZWFkb25seSBzcGF0aWFsOiBib29sZWFuO1xuICByZWFkb25seSB0cmFpbmluZ01vZGU6IGJvb2xlYW47XG4gIHJlYWRvbmx5IGZvcm1hdDogJ05IV0MnfCdOQ0hXJztcbiAgcmVhZG9ubHkgb3V0cHV0Q291bnQ6IG51bWJlcjtcbn1cblxuY29uc3QgdmFsaWRhdGVJbnB1dHMgPSAoaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10sIGF0dHJpYnV0ZXM6IEJhdGNoTm9ybUF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgaWYgKCFpbnB1dHMgfHwgaW5wdXRzLmxlbmd0aCAhPT0gNSkge1xuICAgIHRocm93IG5ldyBFcnJvcignQmF0Y2hOb3JtYWxpemF0aW9uIHJlcXVpcmVzIDUgaW5wdXRzJyk7XG4gIH1cblxuICBjb25zdCBjaGVja1NoYXBlRXF1YWwgPSAoYWN0dWFsOiByZWFkb25seSBudW1iZXJbXSwgZXhwZWN0ZWQ6IHJlYWRvbmx5IG51bWJlcltdLCBtZXNzYWdlOiBzdHJpbmcpID0+IHtcbiAgICBjb25zdCByID0gZXhwZWN0ZWQubGVuZ3RoO1xuICAgIGlmIChyICE9PSBhY3R1YWwubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7bWVzc2FnZX06IG51bSBkaW1lbnNpb25zICE9ICR7cn1gKTtcbiAgICB9XG4gICAgZXhwZWN0ZWQuZm9yRWFjaCgodiwgaSkgPT4ge1xuICAgICAgaWYgKHYgIT09IGFjdHVhbFtpXSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7bWVzc2FnZX06IGRpbVske2l9XSBkbyBub3QgbWF0Y2hgKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICBpZiAoaW5wdXRzWzBdLmRpbXMubGVuZ3RoID4gMSkge1xuICAgIGNvbnN0IHNoYXBlID0gYXR0cmlidXRlcy5mb3JtYXQgPT09ICdOSFdDJyA/XG4gICAgICAgIChhdHRyaWJ1dGVzLnNwYXRpYWwgPyBpbnB1dHNbMF0uZGltcy5zbGljZSgtMSkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXRzWzBdLmRpbXMuc2xpY2UoLTEpLmNvbmNhdChpbnB1dHNbMF0uZGltcy5zbGljZSgxLCBpbnB1dHNbMF0uZGltcy5sZW5ndGggLSAxKSkpIDpcbiAgICAgICAgaW5wdXRzWzBdLmRpbXMuc2xpY2UoMSwgYXR0cmlidXRlcy5zcGF0aWFsID8gMiA6IHVuZGVmaW5lZCk7XG4gICAgY2hlY2tTaGFwZUVxdWFsKGlucHV0c1sxXS5kaW1zLCBzaGFwZSwgJ0ludmFsaWQgaW5wdXQgc2NhbGUnKTtcbiAgICBjaGVja1NoYXBlRXF1YWwoaW5wdXRzWzJdLmRpbXMsIHNoYXBlLCAnSW52YWxpZCBpbnB1dCBCJyk7XG4gICAgY2hlY2tTaGFwZUVxdWFsKGlucHV0c1szXS5kaW1zLCBzaGFwZSwgJ0ludmFsaWQgaW5wdXQgbWVhbicpO1xuICAgIGNoZWNrU2hhcGVFcXVhbChpbnB1dHNbNF0uZGltcywgc2hhcGUsICdJbnZhbGlkIGlucHV0IHZhcicpO1xuICB9IGVsc2Uge1xuICAgIGNoZWNrU2hhcGVFcXVhbChpbnB1dHNbMV0uZGltcywgWzFdLCAnSW52YWxpZCBpbnB1dCBzY2FsZScpO1xuICAgIGNoZWNrU2hhcGVFcXVhbChpbnB1dHNbMl0uZGltcywgWzFdLCAnSW52YWxpZCBpbnB1dCBCJyk7XG4gICAgY2hlY2tTaGFwZUVxdWFsKGlucHV0c1szXS5kaW1zLCBbMV0sICdJbnZhbGlkIGlucHV0IG1lYW4nKTtcbiAgICBjaGVja1NoYXBlRXF1YWwoaW5wdXRzWzRdLmRpbXMsIFsxXSwgJ0ludmFsaWQgaW5wdXQgdmFyJyk7XG4gIH1cbn07XG5cbmNvbnN0IGNyZWF0ZUJhdGNoTm9ybUluZmVyZW5jZVByb2dyYW1JbmZvID1cbiAgICAoaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10sIGF0dHJpYnV0ZXM6IEJhdGNoTm9ybUF0dHJpYnV0ZXMpOiBQcm9ncmFtSW5mbyA9PiB7XG4gICAgICBjb25zdCB7ZXBzaWxvbiwgc3BhdGlhbCwgZm9ybWF0fSA9IGF0dHJpYnV0ZXM7XG4gICAgICBjb25zdCB5U2hhcGUgPSBpbnB1dHNbMF0uZGltcztcbiAgICAgIGNvbnN0IGNvbXBvbmVudHMgPSBzcGF0aWFsID8gZ2V0TWF4Q29tcG9uZW50cyh5U2hhcGVbeVNoYXBlLmxlbmd0aCAtIDFdKSA6IDE7XG4gICAgICBjb25zdCBjQ29tcG9uZW50cyA9IGZvcm1hdCA9PT0gJ05IV0MnICYmIHlTaGFwZS5sZW5ndGggPiAxID8gY29tcG9uZW50cyA6IDE7XG4gICAgICBjb25zdCBvdXRwdXRTaXplID0gU2hhcGVVdGlsLnNpemUoeVNoYXBlKSAvIGNvbXBvbmVudHM7XG4gICAgICAvLyBPbmx5IHN1cHBvcnQgdW5pZm9ybXMgZm9yIG9wc2V0IHZlcnNpb24gPj0gOSAoc3BhdGlhbCA9IHRydWUpLlxuICAgICAgY29uc3QgdXNlU2hhcGVzVW5pZm9ybXMgPSBlbmFibGVTaGFwZXNVbmlmb3Jtcyh5U2hhcGUubGVuZ3RoKSAmJiBzcGF0aWFsO1xuICAgICAgY29uc3Qgc2hhcGVPclJhbmsgPSB1c2VTaGFwZXNVbmlmb3JtcyA/IHlTaGFwZS5sZW5ndGggOiB5U2hhcGU7XG4gICAgICBjb25zdCB4ID0gaW5wdXRWYXJpYWJsZSgneCcsIGlucHV0c1swXS5kYXRhVHlwZSwgaW5wdXRzWzBdLmRpbXMsIGNvbXBvbmVudHMpO1xuICAgICAgY29uc3Qgc2NhbGUgPSBpbnB1dFZhcmlhYmxlKCdzY2FsZScsIGlucHV0c1sxXS5kYXRhVHlwZSwgaW5wdXRzWzFdLmRpbXMsIGNDb21wb25lbnRzKTtcbiAgICAgIGNvbnN0IGJpYXMgPSBpbnB1dFZhcmlhYmxlKCdiaWFzJywgaW5wdXRzWzJdLmRhdGFUeXBlLCBpbnB1dHNbMl0uZGltcywgY0NvbXBvbmVudHMpO1xuICAgICAgY29uc3QgaW5wdXRNZWFuID0gaW5wdXRWYXJpYWJsZSgnaW5wdXRNZWFuJywgaW5wdXRzWzNdLmRhdGFUeXBlLCBpbnB1dHNbM10uZGltcywgY0NvbXBvbmVudHMpO1xuICAgICAgY29uc3QgaW5wdXRWYXIgPSBpbnB1dFZhcmlhYmxlKCdpbnB1dFZhcicsIGlucHV0c1s0XS5kYXRhVHlwZSwgaW5wdXRzWzRdLmRpbXMsIGNDb21wb25lbnRzKTtcbiAgICAgIGNvbnN0IHkgPSBvdXRwdXRWYXJpYWJsZSgneScsIGlucHV0c1swXS5kYXRhVHlwZSwgc2hhcGVPclJhbmssIGNvbXBvbmVudHMpO1xuICAgICAgLy8gVE9ETzogc3VwcG9ydCBpbnB1dHMgd2l0aCBkaWZmZXJlbnQgZGF0YSB0eXBlLiBDdXJyZW50IHdlIG5lZWQgdG8gbWFrZSBzdXJlIGFsbCBpbnB1dHMgaGF2ZSB0aGUgc2FtZSBkYXRhIHR5cGUuXG4gICAgICAvLyBPdGhlcndpc2UsIHRoZSBzaGFkZXIgY29tcGlsYXRpb24gd2lsbCBmYWlsLlxuICAgICAgY29uc3QgY2FsY0NPZmZzZXQgPSAoKTogc3RyaW5nID0+IHtcbiAgICAgICAgbGV0IGNPZmZzZXQgPSAnJztcbiAgICAgICAgaWYgKHNwYXRpYWwpIHtcbiAgICAgICAgICBjT2Zmc2V0ID0gYGxldCBjT2Zmc2V0ID0gJHtcbiAgICAgICAgICAgICAgeVNoYXBlLmxlbmd0aCA9PT0gMSAgID8gJzB1JyA6XG4gICAgICAgICAgICAgICAgICBmb3JtYXQgPT09ICdOSFdDJyA/IGBvdXRwdXRJbmRpY2VzWyR7eVNoYXBlLmxlbmd0aCAtIDF9XSAvICR7Y29tcG9uZW50c31gIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ291dHB1dEluZGljZXNbMV0nfTtgO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChmb3JtYXQgPT09ICdOQ0hXJykge1xuICAgICAgICAgICAgY09mZnNldCA9IGBcbiAgICAgICAgICAgICR7eS5pbmRpY2VzU2V0KCdvdXRwdXRJbmRpY2VzJywgJzAnLCAnMCcpfVxuICAgICAgICAgICAgbGV0IGNPZmZzZXQgPSAke3kuaW5kaWNlc1RvT2Zmc2V0KCdvdXRwdXRJbmRpY2VzJyl9O2A7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHVwZGF0ZSBDIGNoYW5uZWwuXG4gICAgICAgICAgICBjT2Zmc2V0ID0gYHZhciBjSW5kaWNlcyA9ICR7c2NhbGUudHlwZS5pbmRpY2VzfSgwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgY0luZGljZXNbMF0gPSBvdXRwdXRJbmRpY2VzWyR7eVNoYXBlLmxlbmd0aCAtIDF9XTtgO1xuICAgICAgICAgICAgLy8gdXBkYXRlIEQxIHggLi4uIHggRG4gY2hhbm5lbHMuXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHNjYWxlLnJhbms7IGkrKykge1xuICAgICAgICAgICAgICBjT2Zmc2V0ICs9IGBjSW5kaWNlc1ske2l9XSA9IG91dHB1dEluZGljZXNbJHtpfV07YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNPZmZzZXQgKz0gYGxldCBjT2Zmc2V0ID0gJHtzY2FsZS5pbmRpY2VzVG9PZmZzZXQoJ2NJbmRpY2VzJyl9O2A7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjT2Zmc2V0O1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGdldEluZmVyZW5jZU1vZGVTaGFkZXJTb3VyY2UgPSAoaGVscGVyOiBTaGFkZXJIZWxwZXIpID0+IGBcbiAgY29uc3QgZXBzaWxvbiA9ICR7ZXBzaWxvbn07XG4gICR7aGVscGVyLnJlZ2lzdGVyVW5pZm9ybSgnb3V0cHV0U2l6ZScsICd1MzInKS5kZWNsYXJlVmFyaWFibGVzKHgsIHNjYWxlLCBiaWFzLCBpbnB1dE1lYW4sIGlucHV0VmFyLCB5KX1cbiAgJHtoZWxwZXIubWFpblN0YXJ0KCl9XG4gICR7aGVscGVyLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoJ3VuaWZvcm1zLm91dHB1dFNpemUnKX1cbiAgICB2YXIgb3V0cHV0SW5kaWNlcyA9ICR7eS5vZmZzZXRUb0luZGljZXMoYGdsb2JhbF9pZHggKiAke2NvbXBvbmVudHN9YCl9O1xuICAgICR7Y2FsY0NPZmZzZXQoKX1cbiAgICBsZXQgc2NhbGUgPSAke3NjYWxlLmdldEJ5T2Zmc2V0KCdjT2Zmc2V0Jyl9O1xuICAgIGxldCBiaWFzID0gJHtiaWFzLmdldEJ5T2Zmc2V0KCdjT2Zmc2V0Jyl9O1xuICAgIGxldCBpbnB1dE1lYW4gPSAke2lucHV0TWVhbi5nZXRCeU9mZnNldCgnY09mZnNldCcpfTtcbiAgICBsZXQgaW5wdXRWYXIgPSAke2lucHV0VmFyLmdldEJ5T2Zmc2V0KCdjT2Zmc2V0Jyl9O1xuICAgIGxldCB4ID0gJHt4LmdldEJ5T2Zmc2V0KCdnbG9iYWxfaWR4Jyl9O1xuICAgIGxldCB2YWx1ZSA9ICh4IC0gaW5wdXRNZWFuKSAqIGludmVyc2VTcXJ0KGlucHV0VmFyICsgZXBzaWxvbikgKiBzY2FsZSArIGJpYXM7XG4gICAgJHt5LnNldEJ5T2Zmc2V0KCdnbG9iYWxfaWR4JywgJ3ZhbHVlJyl9XG4gIH1gO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZTogJ0JhdGNoTm9ybWFsaXphdGlvbicsXG4gICAgICAgIHNoYWRlckNhY2hlOiB7XG4gICAgICAgICAgaGludDogYCR7YXR0cmlidXRlcy5lcHNpbG9ufV8ke2F0dHJpYnV0ZXMuZm9ybWF0fV8ke3NwYXRpYWx9XyR7Y29tcG9uZW50c31gLFxuICAgICAgICAgIGlucHV0RGVwZW5kZW5jaWVzOiB1c2VTaGFwZXNVbmlmb3JtcyA/IFsncmFuaycsICd0eXBlJywgJ3R5cGUnLCAndHlwZScsICd0eXBlJ10gOiB1bmRlZmluZWQsXG4gICAgICAgIH0sXG4gICAgICAgIGdldFNoYWRlclNvdXJjZTogZ2V0SW5mZXJlbmNlTW9kZVNoYWRlclNvdXJjZSxcbiAgICAgICAgZ2V0UnVuRGF0YTogKCkgPT4gKHtcbiAgICAgICAgICBvdXRwdXRzOiBbe2RpbXM6IGlucHV0c1swXS5kaW1zLCBkYXRhVHlwZTogaW5wdXRzWzBdLmRhdGFUeXBlfV0sXG4gICAgICAgICAgZGlzcGF0Y2hHcm91cDoge3g6IE1hdGguY2VpbChvdXRwdXRTaXplIC8gNjQgLyogd29ya2dyb3VwIHNpemUgKi8pfSxcbiAgICAgICAgICBwcm9ncmFtVW5pZm9ybXM6IHVzZVNoYXBlc1VuaWZvcm1zID9cbiAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIHt0eXBlOiAndWludDMyJywgZGF0YTogb3V0cHV0U2l6ZX0sXG4gICAgICAgICAgICAgICAgLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMoeVNoYXBlKSxcbiAgICAgICAgICAgICAgXSA6XG4gICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICB7dHlwZTogJ3VpbnQzMicsIGRhdGE6IG91dHB1dFNpemV9LFxuICAgICAgICAgICAgICBdLFxuICAgICAgICB9KSxcbiAgICAgIH07XG4gICAgfTtcblxuZXhwb3J0IGNvbnN0IHBhcnNlQmF0Y2hOb3JtQXR0cmlidXRlcyA9IChhdHRyaWJ1dGVzOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPik6IEJhdGNoTm9ybUF0dHJpYnV0ZXMgPT5cbiAgICBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkoYXR0cmlidXRlcyBhcyBPbWl0PEJhdGNoTm9ybUF0dHJpYnV0ZXMsIGtleW9mIEF0dHJpYnV0ZVdpdGhDYWNoZUtleT4pO1xuXG5leHBvcnQgY29uc3QgYmF0Y2hOb3JtID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPik6IHZvaWQgPT4ge1xuICBjb25zdCB7aW5wdXRzLCBvdXRwdXRDb3VudH0gPSBjb250ZXh0O1xuICBjb25zdCB1cGRhdGVkQXR0cmlidXRlcyA9IHBhcnNlQmF0Y2hOb3JtQXR0cmlidXRlcyh7Li4uYXR0cmlidXRlcywgb3V0cHV0Q291bnR9KTtcbiAgaWYgKGVudi53ZWJncHUudmFsaWRhdGVJbnB1dENvbnRlbnQpIHtcbiAgICB2YWxpZGF0ZUlucHV0cyhpbnB1dHMsIHVwZGF0ZWRBdHRyaWJ1dGVzKTtcbiAgfVxuICBpZiAoYXR0cmlidXRlcy50cmFpbmluZ01vZGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0JhdGNoTm9ybWFsaXphdGlvbiB0cmFpbmluZ01vZGUgaXMgbm90IHN1cHBvcnRlZCB5ZXQuJyk7XG4gIH0gZWxzZSB7XG4gICAgY29udGV4dC5jb21wdXRlKGNyZWF0ZUJhdGNoTm9ybUluZmVyZW5jZVByb2dyYW1JbmZvKGlucHV0cywgdXBkYXRlZEF0dHJpYnV0ZXMpKTtcbiAgfVxufTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtUZW5zb3JWaWV3fSBmcm9tICcuLi8uLi90ZW5zb3Itdmlldyc7XG5pbXBvcnQge1NoYXBlVXRpbH0gZnJvbSAnLi4vLi4vdXRpbCc7XG5pbXBvcnQge0NvbXB1dGVDb250ZXh0LCBQcm9ncmFtSW5mb30gZnJvbSAnLi4vdHlwZXMnO1xuXG5pbXBvcnQge2lucHV0VmFyaWFibGUsIG91dHB1dFZhcmlhYmxlLCBTaGFkZXJIZWxwZXJ9IGZyb20gJy4vY29tbW9uJztcblxuY29uc3QgdmFsaWRhdGVJbnB1dHMgPSAoaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10pOiB2b2lkID0+IHtcbiAgaWYgKGlucHV0c1swXS5kaW1zLmxlbmd0aCAhPT0gMykge1xuICAgIHRocm93IG5ldyBFcnJvcignaW5wdXQgc2hvdWxkIGhhdmUgMyBkaW1lbnNpb25zJyk7XG4gIH1cblxuICBpZiAoIVszMjAsIDY0MCwgMTI4MF0uaW5jbHVkZXMoaW5wdXRzWzBdLmRpbXNbMl0pKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdudW1iZXIgb2YgY2hhbm5lbHMgc2hvdWxkIGJlIDMyMCwgNjQwIG9yIDEyODAnKTtcbiAgfVxuXG4gIGlmIChpbnB1dHNbMV0uZGltcy5sZW5ndGggIT09IDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2JpYXMgaXMgZXhwZWN0ZWQgdG8gaGF2ZSAxIGRpbWVuc2lvbnMnKTtcbiAgfVxuXG4gIGlmIChpbnB1dHNbMF0uZGltc1syXSAhPT0gaW5wdXRzWzFdLmRpbXNbMF0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2xhc3QgZGltZW5zaW9uIG9mIGlucHV0IGFuZCBiaWFzIGFyZSBub3QgdGhlIHNhbWUnKTtcbiAgfVxufTtcblxuY29uc3QgY3JlYXRlQmlhc0FkZFByb2dyYW1JbmZvID0gKGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdKTogUHJvZ3JhbUluZm8gPT4ge1xuICBjb25zdCBvdXRwdXRTaGFwZSA9IGlucHV0c1swXS5kaW1zO1xuXG4gIGNvbnN0IGNoYW5uZWxzID0gaW5wdXRzWzBdLmRpbXNbMl07XG4gIC8vIHNpbmNlIGNoYW5uZWwgbnVtYmVyIGNhbiBiZSBvbmx5IDMyMC82NDAvMTI4MCwgaXQncyBhbHdheXMgZGl2aXNhYmxlIGJ5IDRcbiAgY29uc3Qgb3V0cHV0U2l6ZSA9IFNoYXBlVXRpbC5zaXplKG91dHB1dFNoYXBlKSAvIDQ7XG5cbiAgY29uc3QgZGF0YVR5cGUgPSBpbnB1dHNbMF0uZGF0YVR5cGU7XG4gIGNvbnN0IGlucHV0ID0gaW5wdXRWYXJpYWJsZSgnaW5wdXQnLCBkYXRhVHlwZSwgb3V0cHV0U2hhcGUsIDQpO1xuICBjb25zdCBiaWFzID0gaW5wdXRWYXJpYWJsZSgnYmlhcycsIGRhdGFUeXBlLCBbY2hhbm5lbHNdLCA0KTtcbiAgY29uc3QgcmVzaWR1YWwgPSBpbnB1dFZhcmlhYmxlKCdyZXNpZHVhbCcsIGRhdGFUeXBlLCBvdXRwdXRTaGFwZSwgNCk7XG4gIGNvbnN0IG91dHB1dCA9IG91dHB1dFZhcmlhYmxlKCdvdXRwdXQnLCBkYXRhVHlwZSwgb3V0cHV0U2hhcGUsIDQpO1xuXG4gIGNvbnN0IGdldFNoYWRlclNvdXJjZSA9IChzaGFkZXJIZWxwZXI6IFNoYWRlckhlbHBlcikgPT4gYFxuICBjb25zdCBjaGFubmVscyA9ICR7Y2hhbm5lbHN9dSAvIDQ7XG4gICR7c2hhZGVySGVscGVyLmRlY2xhcmVWYXJpYWJsZXMoaW5wdXQsIGJpYXMsIHJlc2lkdWFsLCBvdXRwdXQpfVxuXG4gICR7c2hhZGVySGVscGVyLm1haW5TdGFydCgpfVxuICAgICR7c2hhZGVySGVscGVyLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMob3V0cHV0U2l6ZSl9XG4gICAgbGV0IHZhbHVlID0gJHtpbnB1dC5nZXRCeU9mZnNldCgnZ2xvYmFsX2lkeCcpfVxuICAgICAgKyAke2JpYXMuZ2V0QnlPZmZzZXQoJ2dsb2JhbF9pZHggJSBjaGFubmVscycpfSArICR7cmVzaWR1YWwuZ2V0QnlPZmZzZXQoJ2dsb2JhbF9pZHgnKX07XG4gICAgJHtvdXRwdXQuc2V0QnlPZmZzZXQoJ2dsb2JhbF9pZHgnLCAndmFsdWUnKX1cbiAgfWA7XG5cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiAnQmlhc0FkZCcsXG4gICAgZ2V0UnVuRGF0YTogKCkgPT4gKHtcbiAgICAgIG91dHB1dHM6IFt7ZGltczogb3V0cHV0U2hhcGUsIGRhdGFUeXBlOiBpbnB1dHNbMF0uZGF0YVR5cGV9XSxcbiAgICAgIGRpc3BhdGNoR3JvdXA6IHt4OiBNYXRoLmNlaWwob3V0cHV0U2l6ZSAvIDY0IC8qIHdvcmtncm91cCBzaXplICovKX1cbiAgICB9KSxcbiAgICBnZXRTaGFkZXJTb3VyY2UsXG4gIH07XG59O1xuXG5leHBvcnQgY29uc3QgYmlhc0FkZCA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCk6IHZvaWQgPT4ge1xuICB2YWxpZGF0ZUlucHV0cyhjb250ZXh0LmlucHV0cyk7XG4gIGNvbnRleHQuY29tcHV0ZShjcmVhdGVCaWFzQWRkUHJvZ3JhbUluZm8oY29udGV4dC5pbnB1dHMpKTtcbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7RGF0YVR5cGV9IGZyb20gJy4uLy4uLy4uL3dhc20tY29tbW9uJztcbmltcG9ydCB7VGVuc29yVmlld30gZnJvbSAnLi4vLi4vdGVuc29yLXZpZXcnO1xuaW1wb3J0IHtNQVhfQ0xJUCwgTUlOX0NMSVAsIFNoYXBlVXRpbH0gZnJvbSAnLi4vLi4vdXRpbCc7XG5pbXBvcnQge0F0dHJpYnV0ZVdpdGhDYWNoZUtleSwgY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5fSBmcm9tICcuLi9hdHRyaWJ1dGUtd2l0aC1jYWNoZS1rZXknO1xuaW1wb3J0IHtDb21wdXRlQ29udGV4dCwgUHJvZ3JhbUluZm99IGZyb20gJy4uL3R5cGVzJztcblxuaW1wb3J0IHtpbnB1dFZhcmlhYmxlLCBvdXRwdXRWYXJpYWJsZSwgU2hhZGVySGVscGVyLCB0ZW5zb3JUeXBlVG9Xc2dsVmFsdWVUeXBlfSBmcm9tICcuL2NvbW1vbic7XG5cbnR5cGUgQnVpbHRpbkZ1bmN0aW9uTmFtZSA9IHN0cmluZztcbnR5cGUgRWxlbWVudHdpc2VDdXN0b21FeHByZXNzaW9uID0gKGV4cHJlc3Npb246IHN0cmluZykgPT4gc3RyaW5nO1xudHlwZSBFbGVtZW50d2lzZUZ1bmN0aW9uQ2FsbCA9IEJ1aWx0aW5GdW5jdGlvbk5hbWV8RWxlbWVudHdpc2VDdXN0b21FeHByZXNzaW9uO1xuXG5jb25zdCBjcmVhdGVFbGVtZW50d2lzZVByb2dyYW1TaGFkZXIgPVxuICAgIChzaGFkZXJIZWxwZXI6IFNoYWRlckhlbHBlciwgZGF0YXNpemU6IG51bWJlciwgaW5wdXREYXRhVHlwZTogbnVtYmVyLCBvdXRwdXREYXRhVHlwZTogbnVtYmVyLFxuICAgICBmdW5jQ2FsbDogRWxlbWVudHdpc2VGdW5jdGlvbkNhbGwsIGFkZGl0aW9uYWxJbXBsZW1lbnRhdGlvbj86IHN0cmluZyk6IHN0cmluZyA9PiB7XG4gICAgICBjb25zdCB2ZWNTaXplID0gTWF0aC5jZWlsKGRhdGFzaXplIC8gNCk7XG5cbiAgICAgIGxldCBleHByZXNzaW9uID0gJyc7XG4gICAgICBpZiAodHlwZW9mIGZ1bmNDYWxsID09PSAnc3RyaW5nJykge1xuICAgICAgICBleHByZXNzaW9uID0gYCR7ZnVuY0NhbGx9KGEpYDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGV4cHJlc3Npb24gPSBmdW5jQ2FsbCgnYScpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBpbnB1dCA9IGlucHV0VmFyaWFibGUoJ2lucHV0RGF0YScsIGlucHV0RGF0YVR5cGUsIFt2ZWNTaXplXSwgNCk7XG4gICAgICBjb25zdCBvdXRwdXQgPSBvdXRwdXRWYXJpYWJsZSgnb3V0cHV0RGF0YScsIG91dHB1dERhdGFUeXBlLCBbdmVjU2l6ZV0sIDQpO1xuXG4gICAgICByZXR1cm4gYFxuICAgICAgJHtzaGFkZXJIZWxwZXIucmVnaXN0ZXJVbmlmb3JtKCd2ZWNfc2l6ZScsICd1MzInKS5kZWNsYXJlVmFyaWFibGVzKGlucHV0LCBvdXRwdXQpfVxuXG4gICR7YWRkaXRpb25hbEltcGxlbWVudGF0aW9uID8/ICcnfVxuXG4gICR7c2hhZGVySGVscGVyLm1haW5TdGFydCgpfVxuICAgICR7c2hhZGVySGVscGVyLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoJ3VuaWZvcm1zLnZlY19zaXplJyl9XG5cbiAgICBsZXQgYSA9ICR7aW5wdXQuZ2V0QnlPZmZzZXQoJ2dsb2JhbF9pZHgnKX07XG4gICAgJHtvdXRwdXQuc2V0QnlPZmZzZXQoJ2dsb2JhbF9pZHgnLCBleHByZXNzaW9uKX1cbiAgfWA7XG4gICAgfTtcblxuY29uc3QgY3JlYXRlRWxlbWVudHdpc2VQcm9ncmFtSW5mbyA9XG4gICAgKGlucHV0OiBUZW5zb3JWaWV3LCBuYW1lOiBzdHJpbmcsIGZ1bmNDYWxsOiBFbGVtZW50d2lzZUZ1bmN0aW9uQ2FsbCwgYWRkaXRpb25hbEltcGxlbWVudGF0aW9uPzogc3RyaW5nLFxuICAgICBjYWNoZUtleT86IHN0cmluZywgb3V0cHV0RGF0YVR5cGU6IG51bWJlciA9IGlucHV0LmRhdGFUeXBlKTogUHJvZ3JhbUluZm8gPT4gKHtcbiAgICAgIG5hbWUsXG4gICAgICBzaGFkZXJDYWNoZToge2hpbnQ6IGNhY2hlS2V5LCBpbnB1dERlcGVuZGVuY2llczogWyd0eXBlJ119LFxuICAgICAgZ2V0U2hhZGVyU291cmNlOiBzaGFkZXJIZWxwZXIgPT4gY3JlYXRlRWxlbWVudHdpc2VQcm9ncmFtU2hhZGVyKFxuICAgICAgICAgIHNoYWRlckhlbHBlciwgU2hhcGVVdGlsLnNpemUoaW5wdXQuZGltcyksIGlucHV0LmRhdGFUeXBlLCBvdXRwdXREYXRhVHlwZSwgZnVuY0NhbGwsIGFkZGl0aW9uYWxJbXBsZW1lbnRhdGlvbiksXG4gICAgICBnZXRSdW5EYXRhOiAoaW5wdXRUZW5zb3JzKSA9PiAoe1xuICAgICAgICBvdXRwdXRzOiBbe2RpbXM6IGlucHV0LmRpbXMsIGRhdGFUeXBlOiBvdXRwdXREYXRhVHlwZX1dLFxuICAgICAgICBkaXNwYXRjaEdyb3VwOlxuICAgICAgICAgICAge3g6IE1hdGguY2VpbChTaGFwZVV0aWwuc2l6ZShpbnB1dFRlbnNvcnNbMF0uZGltcykgLyA2NCAvKiB3b3JrZ3JvdXAgc2l6ZSAqLyAvIDQgLyogdmVjIHNpemUgKi8pfSxcbiAgICAgICAgcHJvZ3JhbVVuaWZvcm1zOiBbXG4gICAgICAgICAge3R5cGU6ICd1aW50MzInLCBkYXRhOiBNYXRoLmNlaWwoU2hhcGVVdGlsLnNpemUoaW5wdXQuZGltcykgLyA0KX0sXG4gICAgICAgIF0sXG4gICAgICB9KVxuICAgIH0pO1xuXG5leHBvcnQgY29uc3QgYWJzID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0KTogdm9pZCA9PiB7XG4gIGNvbnRleHQuY29tcHV0ZShjcmVhdGVFbGVtZW50d2lzZVByb2dyYW1JbmZvKGNvbnRleHQuaW5wdXRzWzBdLCAnQWJzJywgJ2FicycpKTtcbn07XG5cbmV4cG9ydCBjb25zdCBhY29zID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0KTogdm9pZCA9PiB7XG4gIGNvbnRleHQuY29tcHV0ZShjcmVhdGVFbGVtZW50d2lzZVByb2dyYW1JbmZvKGNvbnRleHQuaW5wdXRzWzBdLCAnQWNvcycsICdhY29zJykpO1xufTtcblxuZXhwb3J0IGNvbnN0IGFjb3NoID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0KTogdm9pZCA9PiB7XG4gIGNvbnRleHQuY29tcHV0ZShjcmVhdGVFbGVtZW50d2lzZVByb2dyYW1JbmZvKGNvbnRleHQuaW5wdXRzWzBdLCAnQWNvc2gnLCAnYWNvc2gnKSk7XG59O1xuXG5leHBvcnQgY29uc3QgYXNpbiA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCk6IHZvaWQgPT4ge1xuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlRWxlbWVudHdpc2VQcm9ncmFtSW5mbyhjb250ZXh0LmlucHV0c1swXSwgJ0FzaW4nLCAnYXNpbicpKTtcbn07XG5cbmV4cG9ydCBjb25zdCBhc2luaCA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCk6IHZvaWQgPT4ge1xuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlRWxlbWVudHdpc2VQcm9ncmFtSW5mbyhjb250ZXh0LmlucHV0c1swXSwgJ0FzaW5oJywgJ2FzaW5oJykpO1xufTtcblxuZXhwb3J0IGNvbnN0IGF0YW4gPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQpOiB2b2lkID0+IHtcbiAgY29udGV4dC5jb21wdXRlKGNyZWF0ZUVsZW1lbnR3aXNlUHJvZ3JhbUluZm8oY29udGV4dC5pbnB1dHNbMF0sICdBdGFuJywgJ2F0YW4nKSk7XG59O1xuZXhwb3J0IGNvbnN0IGF0YW5oID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0KTogdm9pZCA9PiB7XG4gIGNvbnRleHQuY29tcHV0ZShjcmVhdGVFbGVtZW50d2lzZVByb2dyYW1JbmZvKGNvbnRleHQuaW5wdXRzWzBdLCAnQXRhbmgnLCAnYXRhbmgnKSk7XG59O1xuXG5leHBvcnQgaW50ZXJmYWNlIENhc3RBdHRyaWJ1dGVzIGV4dGVuZHMgQXR0cmlidXRlV2l0aENhY2hlS2V5IHtcbiAgcmVhZG9ubHkgdG86IG51bWJlcjtcbiAgcmVhZG9ubHkgc2F0dXJhdGU/OiBib29sZWFuO1xufVxuXG5leHBvcnQgY29uc3QgcGFyc2VDYXN0QXR0cmlidXRlcyA9IChhdHRyaWJ1dGVzOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPik6IENhc3RBdHRyaWJ1dGVzID0+XG4gICAgY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KGF0dHJpYnV0ZXMgYXMge3RvOiBudW1iZXJ9KTtcblxuXG5leHBvcnQgY29uc3QgY2FzdCA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogQ2FzdEF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgbGV0IGZ1bmM6IEVsZW1lbnR3aXNlRnVuY3Rpb25DYWxsO1xuICBzd2l0Y2ggKGF0dHJpYnV0ZXMudG8pIHtcbiAgICBjYXNlIERhdGFUeXBlLmZsb2F0MTY6XG4gICAgICBmdW5jID0gJ3ZlYzQ8ZjE2Pic7XG4gICAgICBicmVhaztcbiAgICBjYXNlIERhdGFUeXBlLmZsb2F0OlxuICAgICAgZnVuYyA9ICd2ZWM0PGYzMj4nO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBEYXRhVHlwZS51aW50MzI6XG4gICAgICBmdW5jID0gJ3ZlYzQ8dTMyPic7XG4gICAgICBicmVhaztcbiAgICBjYXNlIERhdGFUeXBlLmludDMyOlxuICAgICAgZnVuYyA9ICd2ZWM0PGkzMj4nO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBEYXRhVHlwZS5ib29sOlxuICAgICAgZnVuYyA9ICd2ZWM0PGJvb2w+JztcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgbm90IHN1cHBvcnRlZCB0eXBlIChzcGVjaWZpZWQgaW4gYXR0cmlidXRlICd0bycgZnJvbSAnQ2FzdCcgb3BlcmF0b3IpOiAke2F0dHJpYnV0ZXMudG99YCk7XG4gIH1cbiAgY29udGV4dC5jb21wdXRlKFxuICAgICAgY3JlYXRlRWxlbWVudHdpc2VQcm9ncmFtSW5mbyhjb250ZXh0LmlucHV0c1swXSwgJ0Nhc3QnLCBmdW5jLCB1bmRlZmluZWQsIGF0dHJpYnV0ZXMuY2FjaGVLZXksIGF0dHJpYnV0ZXMudG8pKTtcbn07XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ2xpcEF0dHJpYnV0ZXMgZXh0ZW5kcyBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkge1xuICByZWFkb25seSBtaW46IG51bWJlcjtcbiAgcmVhZG9ubHkgbWF4OiBudW1iZXI7XG59XG5cbmNvbnN0IGdlbmVyYXRlQ2xpcEF0dHJpYnV0ZXNGcm9tSW5wdXRzID0gKGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdKTogQ2xpcEF0dHJpYnV0ZXMgPT4ge1xuICBjb25zdCBtaW4gPSAoaW5wdXRzLmxlbmd0aCA+PSAyICYmIGlucHV0c1sxXS5kYXRhICE9PSAwKSA/IGlucHV0c1sxXS5nZXRGbG9hdDMyQXJyYXkoKVswXSA6IE1JTl9DTElQO1xuICBjb25zdCBtYXggPSAoaW5wdXRzLmxlbmd0aCA+PSAzICYmIGlucHV0c1syXS5kYXRhICE9PSAwKSA/IGlucHV0c1syXS5nZXRGbG9hdDMyQXJyYXkoKVswXSA6IE1BWF9DTElQO1xuICByZXR1cm4gY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KHttaW4sIG1heH0pO1xufTtcblxuZXhwb3J0IGNvbnN0IGNsaXAgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGNsaXBBdHRyaWJ1dGVzOiBDbGlwQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICBjb25zdCBhdHRyaWJ1dGVzID0gY29udGV4dC5pbnB1dHMubGVuZ3RoID09PSAxID8gY2xpcEF0dHJpYnV0ZXMgOiBnZW5lcmF0ZUNsaXBBdHRyaWJ1dGVzRnJvbUlucHV0cyhjb250ZXh0LmlucHV0cyk7XG4gIGNvbnN0IGRhdGFUeXBlID0gdGVuc29yVHlwZVRvV3NnbFZhbHVlVHlwZShjb250ZXh0LmlucHV0c1swXS5kYXRhVHlwZSk7XG4gIGNvbnRleHQuY29tcHV0ZShcbiAgICAgIGNyZWF0ZUVsZW1lbnR3aXNlUHJvZ3JhbUluZm8oXG4gICAgICAgICAgY29udGV4dC5pbnB1dHNbMF0sICdDbGlwJywgYSA9PiBgY2xhbXAoJHthfSwgY2xpcF9taW5fLCBjbGlwX21heF8pYCwgYFxuICAgIGNvbnN0IGNsaXBfbWluXzogdmVjNDwke2RhdGFUeXBlfT4gPSB2ZWM0KCR7ZGF0YVR5cGV9KCR7YXR0cmlidXRlcy5taW59KSk7XG4gICAgY29uc3QgY2xpcF9tYXhfOiB2ZWM0PCR7ZGF0YVR5cGV9PiA9IHZlYzQoJHtkYXRhVHlwZX0oJHthdHRyaWJ1dGVzLm1heH0pKTtcbmAsXG4gICAgICAgICAgYXR0cmlidXRlcy5jYWNoZUtleSksXG4gICAgICB7aW5wdXRzOiBbMF19KTtcbn07XG5cbmV4cG9ydCBjb25zdCBjZWlsID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0KTogdm9pZCA9PiB7XG4gIGNvbnRleHQuY29tcHV0ZShjcmVhdGVFbGVtZW50d2lzZVByb2dyYW1JbmZvKGNvbnRleHQuaW5wdXRzWzBdLCAnQ2VpbCcsICdjZWlsJykpO1xufTtcblxuZXhwb3J0IGNvbnN0IGNvcyA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCk6IHZvaWQgPT4ge1xuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlRWxlbWVudHdpc2VQcm9ncmFtSW5mbyhjb250ZXh0LmlucHV0c1swXSwgJ0NvcycsICdjb3MnKSk7XG59O1xuXG5leHBvcnQgY29uc3QgY29zaCA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCk6IHZvaWQgPT4ge1xuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlRWxlbWVudHdpc2VQcm9ncmFtSW5mbyhjb250ZXh0LmlucHV0c1swXSwgJ0Nvc2gnLCAnY29zaCcpKTtcbn07XG5cbmV4cG9ydCBpbnRlcmZhY2UgQWxwaGFBdHRyaWJ1dGVzIGV4dGVuZHMgQXR0cmlidXRlV2l0aENhY2hlS2V5IHtcbiAgcmVhZG9ubHkgYWxwaGE6IG51bWJlcjtcbn1cblxuZXhwb3J0IGNvbnN0IHBhcnNlQWxwaGFBdHRyaWJ1dGVzID0gKGF0dHJpYnV0ZXM6IFJlY29yZDxzdHJpbmcsIHVua25vd24+KTogQWxwaGFBdHRyaWJ1dGVzID0+XG4gICAgY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KGF0dHJpYnV0ZXMgYXMge2FscGhhOiBudW1iZXJ9KTtcblxuZXhwb3J0IGNvbnN0IGVsdSA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogQWxwaGFBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIGNvbnN0IGRhdGFUeXBlID0gdGVuc29yVHlwZVRvV3NnbFZhbHVlVHlwZShjb250ZXh0LmlucHV0c1swXS5kYXRhVHlwZSk7XG4gIGNvbnRleHQuY29tcHV0ZShjcmVhdGVFbGVtZW50d2lzZVByb2dyYW1JbmZvKFxuICAgICAgY29udGV4dC5pbnB1dHNbMF0sICdFbHUnLCBhID0+IGBlbHVfdmYzMigke2F9KWAsIGBcbiAgY29uc3QgZWx1X2FscGhhXyA9ICR7ZGF0YVR5cGV9KCR7YXR0cmlidXRlcy5hbHBoYX0pO1xuXG4gIGZuIGVsdV9mMzIoYTogJHtkYXRhVHlwZX0pIC0+ICR7ZGF0YVR5cGV9IHtcbiAgcmV0dXJuIHNlbGVjdCgoZXhwKGEpIC0gMS4wKSAqIGVsdV9hbHBoYV8sIGEsIGEgPj0gMC4wKTtcbiAgfVxuXG4gIGZuIGVsdV92ZjMyKHY6IHZlYzQ8JHtkYXRhVHlwZX0+KSAtPiB2ZWM0PCR7ZGF0YVR5cGV9PiB7XG4gIHJldHVybiB2ZWM0KGVsdV9mMzIodi54KSwgZWx1X2YzMih2LnkpLCBlbHVfZjMyKHYueiksIGVsdV9mMzIodi53KSk7XG4gIH1gLFxuICAgICAgYXR0cmlidXRlcy5jYWNoZUtleSkpO1xufTtcblxuZXhwb3J0IGNvbnN0IGVyZkltcGwgPSAoZGF0YVR5cGU6IHN0cmluZywgdmFyVHlwZSA9ICdmMzInKSA9PiBgXG5jb25zdCByMDogJHt2YXJUeXBlfSA9IDAuMzI3NTkxMTtcbmNvbnN0IHIxOiAke3ZhclR5cGV9ID0gMC4yNTQ4Mjk1OTI7XG5jb25zdCByMjogJHt2YXJUeXBlfSA9IC0wLjI4NDQ5NjczNjtcbmNvbnN0IHIzOiAke3ZhclR5cGV9ID0gMS40MjE0MTM3NDE7XG5jb25zdCByNDogJHt2YXJUeXBlfSA9IC0xLjQ1MzE1MjAyNztcbmNvbnN0IHI1OiAke3ZhclR5cGV9ID0gMS4wNjE0MDU0Mjk7XG5cbmZuIGVyZl92ZjMyKHY6ICR7ZGF0YVR5cGV9KSAtPiAke2RhdGFUeXBlfSB7XG4gIGxldCBhYnN2ID0gYWJzKHYpO1xuICBsZXQgeCA9IDEuMCAvICgxLjAgKyByMCAqIGFic3YpO1xuICByZXR1cm4gc2lnbih2KSAqICgxLjAgLSAoKCgocjUgKiB4ICsgcjQpICogeCArIHIzKSAqIHggKyByMikgKiB4ICsgcjEpICogeCAqIGV4cCgtYWJzdiAqIGFic3YpKTtcbn1gO1xuXG5leHBvcnQgY29uc3QgZXJmID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0KTogdm9pZCA9PiB7XG4gIGNvbnN0IGRhdGFUeXBlID0gdGVuc29yVHlwZVRvV3NnbFZhbHVlVHlwZShjb250ZXh0LmlucHV0c1swXS5kYXRhVHlwZSk7XG4gIGNvbnRleHQuY29tcHV0ZShjcmVhdGVFbGVtZW50d2lzZVByb2dyYW1JbmZvKFxuICAgICAgY29udGV4dC5pbnB1dHNbMF0sICdFcmYnLCBhID0+IGBlcmZfdmYzMigke2F9KWAsIGVyZkltcGwoYHZlYzQ8JHtkYXRhVHlwZX0+YCwgZGF0YVR5cGUpKSk7XG59O1xuXG5leHBvcnQgY29uc3QgZXhwID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0KTogdm9pZCA9PiB7XG4gIGNvbnRleHQuY29tcHV0ZShjcmVhdGVFbGVtZW50d2lzZVByb2dyYW1JbmZvKGNvbnRleHQuaW5wdXRzWzBdLCAnRXhwJywgJ2V4cCcpKTtcbn07XG5cbmV4cG9ydCBjb25zdCBmbG9vciA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCk6IHZvaWQgPT4ge1xuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlRWxlbWVudHdpc2VQcm9ncmFtSW5mbyhjb250ZXh0LmlucHV0c1swXSwgJ0Zsb29yJywgJ2Zsb29yJykpO1xufTtcblxuZXhwb3J0IGNvbnN0IGdlbHUgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQpOiB2b2lkID0+IHtcbiAgY29uc3QgZGF0YVR5cGUgPSB0ZW5zb3JUeXBlVG9Xc2dsVmFsdWVUeXBlKGNvbnRleHQuaW5wdXRzWzBdLmRhdGFUeXBlKTtcbiAgY29udGV4dC5jb21wdXRlKGNyZWF0ZUVsZW1lbnR3aXNlUHJvZ3JhbUluZm8oXG4gICAgICBjb250ZXh0LmlucHV0c1swXSwgJ0dlbHUnLCBhID0+IGAwLjUgKiAke2F9ICogKDEuMCArIGVyZl92ZjMyKCR7YX0gKiAwLjcwNzEwNjc4MTE4NjU0NzUpKWAsXG4gICAgICBlcmZJbXBsKGB2ZWM0PCR7ZGF0YVR5cGV9PmAsIGRhdGFUeXBlKSkpO1xufTtcblxuZXhwb3J0IGNvbnN0IGxlYWt5UmVsdSA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogQWxwaGFBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIGNvbnN0IGRhdGFUeXBlID0gdGVuc29yVHlwZVRvV3NnbFZhbHVlVHlwZShjb250ZXh0LmlucHV0c1swXS5kYXRhVHlwZSk7XG4gIGNvbnRleHQuY29tcHV0ZShjcmVhdGVFbGVtZW50d2lzZVByb2dyYW1JbmZvKFxuICAgICAgY29udGV4dC5pbnB1dHNbMF0sICdMZWFreVJlbHUnLCBhID0+IGBzZWxlY3QobGVha3lfcmVsdV9hbHBoYV8gKiAke2F9LCAke2F9LCAke2F9ID49IHZlYzQ8JHtkYXRhVHlwZX0+KDAuMCkpYCxcbiAgICAgIGBjb25zdCBsZWFreV9yZWx1X2FscGhhXyA9ICR7ZGF0YVR5cGV9KCR7YXR0cmlidXRlcy5hbHBoYX0pO2AsIGF0dHJpYnV0ZXMuY2FjaGVLZXkpKTtcbn07XG5cbmV4cG9ydCBjb25zdCBub3QgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQpOiB2b2lkID0+IHtcbiAgY29udGV4dC5jb21wdXRlKGNyZWF0ZUVsZW1lbnR3aXNlUHJvZ3JhbUluZm8oY29udGV4dC5pbnB1dHNbMF0sICdOb3QnLCBhID0+IGAhJHthfWApKTtcbn07XG5cbmV4cG9ydCBjb25zdCBuZWcgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQpOiB2b2lkID0+IHtcbiAgY29udGV4dC5jb21wdXRlKGNyZWF0ZUVsZW1lbnR3aXNlUHJvZ3JhbUluZm8oY29udGV4dC5pbnB1dHNbMF0sICdOZWcnLCBhID0+IGAtJHthfWApKTtcbn07XG5cbmV4cG9ydCBjb25zdCByZWNpcHJvY2FsID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0KTogdm9pZCA9PiB7XG4gIGNvbnRleHQuY29tcHV0ZShjcmVhdGVFbGVtZW50d2lzZVByb2dyYW1JbmZvKGNvbnRleHQuaW5wdXRzWzBdLCAnUmVjaXByb2NhbCcsIGEgPT4gYDEuMC8ke2F9YCkpO1xufTtcblxuZXhwb3J0IGNvbnN0IHJlbHUgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQpOiB2b2lkID0+IHtcbiAgY29uc3QgZGF0YVR5cGUgPSB0ZW5zb3JUeXBlVG9Xc2dsVmFsdWVUeXBlKGNvbnRleHQuaW5wdXRzWzBdLmRhdGFUeXBlKTtcbiAgY29udGV4dC5jb21wdXRlKGNyZWF0ZUVsZW1lbnR3aXNlUHJvZ3JhbUluZm8oXG4gICAgICBjb250ZXh0LmlucHV0c1swXSwgJ1JlbHUnLCBhID0+IGBzZWxlY3QodmVjNDwke2RhdGFUeXBlfT4oMC4wKSwgJHthfSwgJHthfSA+IHZlYzQ8JHtkYXRhVHlwZX0+KDAuMCkpYCkpO1xufTtcblxuZXhwb3J0IGNvbnN0IHNpZ21vaWQgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQpOiB2b2lkID0+IHtcbiAgY29udGV4dC5jb21wdXRlKGNyZWF0ZUVsZW1lbnR3aXNlUHJvZ3JhbUluZm8oY29udGV4dC5pbnB1dHNbMF0sICdTaWdtb2lkJywgYSA9PiBgKDEuMCAvICgxLjAgKyBleHAoLSR7YX0pKSlgKSk7XG59O1xuXG5leHBvcnQgY29uc3Qgc2luID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0KTogdm9pZCA9PiB7XG4gIGNvbnRleHQuY29tcHV0ZShjcmVhdGVFbGVtZW50d2lzZVByb2dyYW1JbmZvKGNvbnRleHQuaW5wdXRzWzBdLCAnU2luJywgJ3NpbicpKTtcbn07XG5cbmV4cG9ydCBjb25zdCBzaW5oID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0KTogdm9pZCA9PiB7XG4gIGNvbnRleHQuY29tcHV0ZShjcmVhdGVFbGVtZW50d2lzZVByb2dyYW1JbmZvKGNvbnRleHQuaW5wdXRzWzBdLCAnU2luaCcsICdzaW5oJykpO1xufTtcblxuZXhwb3J0IGNvbnN0IHNxcnQgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQpOiB2b2lkID0+IHtcbiAgY29udGV4dC5jb21wdXRlKGNyZWF0ZUVsZW1lbnR3aXNlUHJvZ3JhbUluZm8oY29udGV4dC5pbnB1dHNbMF0sICdTcXJ0JywgJ3NxcnQnKSk7XG59O1xuXG5leHBvcnQgY29uc3QgdGFuID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0KTogdm9pZCA9PiB7XG4gIGNvbnRleHQuY29tcHV0ZShjcmVhdGVFbGVtZW50d2lzZVByb2dyYW1JbmZvKGNvbnRleHQuaW5wdXRzWzBdLCAnVGFuJywgJ3RhbicpKTtcbn07XG5cbmV4cG9ydCBjb25zdCB0YW5oID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0KTogdm9pZCA9PiB7XG4gIGNvbnRleHQuY29tcHV0ZShjcmVhdGVFbGVtZW50d2lzZVByb2dyYW1JbmZvKGNvbnRleHQuaW5wdXRzWzBdLCAnVGFuaCcsICd0YW5oJykpO1xufTtcblxuZXhwb3J0IGNvbnN0IHRocmVzaG9sZGVkUmVsdSA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogQWxwaGFBdHRyaWJ1dGVzKTogbnVtYmVyID0+IHtcbiAgY29uc3QgZGF0YVR5cGUgPSB0ZW5zb3JUeXBlVG9Xc2dsVmFsdWVUeXBlKGNvbnRleHQuaW5wdXRzWzBdLmRhdGFUeXBlKTtcbiAgY29udGV4dC5jb21wdXRlKGNyZWF0ZUVsZW1lbnR3aXNlUHJvZ3JhbUluZm8oXG4gICAgICBjb250ZXh0LmlucHV0c1swXSwgJ1RocmVzaG9sZGVkUmVsdScsIGEgPT4gYHNlbGVjdCh2ZWM0PCR7ZGF0YVR5cGV9PigwLjApLCAke2F9LCAke2F9ID4gdGhyZXNob2xkZWRfcmVsdV9hbHBoYV8pYCxcbiAgICAgIGBjb25zdCB0aHJlc2hvbGRlZF9yZWx1X2FscGhhXyA9IHZlYzQ8JHtkYXRhVHlwZX0+KCR7YXR0cmlidXRlcy5hbHBoYX0pO2AsIGF0dHJpYnV0ZXMuY2FjaGVLZXkpKTtcbiAgcmV0dXJuIDA7XG59O1xuXG5leHBvcnQgY29uc3QgbG9nID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0KTogdm9pZCA9PiB7XG4gIGNvbnRleHQuY29tcHV0ZShjcmVhdGVFbGVtZW50d2lzZVByb2dyYW1JbmZvKGNvbnRleHQuaW5wdXRzWzBdLCAnTG9nJywgJ2xvZycpKTtcbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7VGVuc29yVmlld30gZnJvbSAnLi4vLi4vdGVuc29yLXZpZXcnO1xuaW1wb3J0IHtTaGFwZVV0aWx9IGZyb20gJy4uLy4uL3V0aWwnO1xuaW1wb3J0IHtDb21wdXRlQ29udGV4dCwgUHJvZ3JhbUluZm99IGZyb20gJy4uL3R5cGVzJztcblxuaW1wb3J0IHtpbnB1dFZhcmlhYmxlLCBvdXRwdXRWYXJpYWJsZSwgU2hhZGVySGVscGVyLCB0ZW5zb3JUeXBlVG9Xc2dsU3RvcmFnZVR5cGV9IGZyb20gJy4vY29tbW9uJztcbmltcG9ydCB7ZXJmSW1wbH0gZnJvbSAnLi91bmFyeS1vcCc7XG5cbmNvbnN0IHZhbGlkYXRlSW5wdXRzID0gKGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdKTogdm9pZCA9PiB7XG4gIGlmIChpbnB1dHNbMF0uZGltcy5sZW5ndGggIT09IDMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2lucHV0IHNob3VsZCBoYXZlIDMgZGltZW5zaW9ucycpO1xuICB9XG5cbiAgaWYgKCFbMjU2MCwgNTEyMCwgMTAyNDBdLmluY2x1ZGVzKGlucHV0c1swXS5kaW1zWzJdKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignaGlkZGVuIHN0YXRlIHNob3VsZCBiZSAyNTYwLCA1MTIwIG9yIDEwMjQwJyk7XG4gIH1cblxuICBpZiAoaW5wdXRzWzFdLmRpbXMubGVuZ3RoICE9PSAxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdiaWFzIGlzIGV4cGVjdGVkIHRvIGhhdmUgMSBkaW1lbnNpb25zJyk7XG4gIH1cblxuICBpZiAoaW5wdXRzWzBdLmRpbXNbMl0gIT09IGlucHV0c1sxXS5kaW1zWzBdKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdsYXN0IGRpbWVuc2lvbiBvZiBpbnB1dCBhbmQgYmlhcyBhcmUgbm90IHRoZSBzYW1lJyk7XG4gIH1cbn07XG5cbmNvbnN0IGNyZWF0ZUJpYXNTcGxpdEdlbHVQcm9ncmFtSW5mbyA9IChpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSk6IFByb2dyYW1JbmZvID0+IHtcbiAgY29uc3Qgb3V0cHV0U2hhcGUgPSBpbnB1dHNbMF0uZGltcy5zbGljZSgpO1xuICBvdXRwdXRTaGFwZVsyXSA9IG91dHB1dFNoYXBlWzJdIC8gMjtcblxuICBjb25zdCBpbnB1dCA9IGlucHV0VmFyaWFibGUoJ2lucHV0JywgaW5wdXRzWzBdLmRhdGFUeXBlLCBpbnB1dHNbMF0uZGltcywgNCk7XG4gIGNvbnN0IGJpYXMgPSBpbnB1dFZhcmlhYmxlKCdiaWFzJywgaW5wdXRzWzBdLmRhdGFUeXBlLCBbaW5wdXRzWzBdLmRpbXNbMl1dLCA0KTtcbiAgY29uc3Qgb3V0cHV0ID0gb3V0cHV0VmFyaWFibGUoJ291dHB1dCcsIGlucHV0c1swXS5kYXRhVHlwZSwgb3V0cHV0U2hhcGUsIDQpO1xuXG4gIGNvbnN0IG91dHB1dFNpemUgPSBTaGFwZVV0aWwuc2l6ZShvdXRwdXRTaGFwZSkgLyA0O1xuICBjb25zdCBkYXRhVHlwZSA9IHRlbnNvclR5cGVUb1dzZ2xTdG9yYWdlVHlwZShpbnB1dHNbMF0uZGF0YVR5cGUpO1xuXG4gIGNvbnN0IGdldFNoYWRlclNvdXJjZSA9IChzaGFkZXJIZWxwZXI6IFNoYWRlckhlbHBlcikgPT4gYFxuICBjb25zdCBNX1NRUlQyID0gc3FydCgyLjApO1xuICBjb25zdCBoYWxmQ2hhbm5lbHMgPSAke2lucHV0c1swXS5kaW1zWzJdIC8gNCAvIDJ9dTtcblxuICAke3NoYWRlckhlbHBlci5kZWNsYXJlVmFyaWFibGVzKGlucHV0LCBiaWFzLCBvdXRwdXQpfVxuXG4gICR7ZXJmSW1wbChgdmVjNDwke2RhdGFUeXBlfT5gLCBkYXRhVHlwZSl9XG5cbiAgJHtzaGFkZXJIZWxwZXIubWFpblN0YXJ0KCl9XG4gICAgJHtzaGFkZXJIZWxwZXIuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhvdXRwdXRTaXplKX1cbiAgICBsZXQgYmlhc0lkeCA9IGdsb2JhbF9pZHggJSBoYWxmQ2hhbm5lbHM7XG4gICAgbGV0IGJhdGNoSW5kZXggPSBnbG9iYWxfaWR4IC8gaGFsZkNoYW5uZWxzO1xuICAgIGxldCBpbnB1dE9mZnNldCA9IGJpYXNJZHggKyBiYXRjaEluZGV4ICogaGFsZkNoYW5uZWxzICogMjtcbiAgICBsZXQgdmFsdWVMZWZ0ID0gaW5wdXRbaW5wdXRPZmZzZXRdICsgYmlhc1tiaWFzSWR4XTtcbiAgICBsZXQgdmFsdWVSaWdodCA9IGlucHV0W2lucHV0T2Zmc2V0ICsgaGFsZkNoYW5uZWxzXSArIGJpYXNbYmlhc0lkeCArIGhhbGZDaGFubmVsc107XG4gICAgbGV0IGdlbHVSaWdodCA9IHZhbHVlUmlnaHQgKiAwLjUgKiAoZXJmX3ZmMzIodmFsdWVSaWdodCAvIE1fU1FSVDIpICsgMSk7XG5cbiAgICAke291dHB1dC5zZXRCeU9mZnNldCgnZ2xvYmFsX2lkeCcsICd2YWx1ZUxlZnQgKiBnZWx1UmlnaHQnKX1cbiAgfWA7XG5cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiAnQmlhc1NwbGl0R2VsdScsXG4gICAgZ2V0UnVuRGF0YTogKCkgPT4gKHtcbiAgICAgIG91dHB1dHM6IFt7ZGltczogb3V0cHV0U2hhcGUsIGRhdGFUeXBlOiBpbnB1dHNbMF0uZGF0YVR5cGV9XSxcbiAgICAgIGRpc3BhdGNoR3JvdXA6IHt4OiBNYXRoLmNlaWwob3V0cHV0U2l6ZSAvIDY0IC8qIHdvcmtncm91cCBzaXplICovKX1cbiAgICB9KSxcbiAgICBnZXRTaGFkZXJTb3VyY2UsXG4gIH07XG59O1xuXG5leHBvcnQgY29uc3QgYmlhc1NwbGl0R2VsdSA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCk6IHZvaWQgPT4ge1xuICB2YWxpZGF0ZUlucHV0cyhjb250ZXh0LmlucHV0cyk7XG4gIGNvbnRleHQuY29tcHV0ZShjcmVhdGVCaWFzU3BsaXRHZWx1UHJvZ3JhbUluZm8oY29udGV4dC5pbnB1dHMpKTtcbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7RGF0YVR5cGV9IGZyb20gJy4uLy4uLy4uL3dhc20tY29tbW9uJztcbmltcG9ydCB7VGVuc29yVmlld30gZnJvbSAnLi4vLi4vdGVuc29yLXZpZXcnO1xuaW1wb3J0IHtCcm9hZGNhc3RVdGlsLCBTaGFwZVV0aWx9IGZyb20gJy4uLy4uL3V0aWwnO1xuaW1wb3J0IHtDb21wdXRlQ29udGV4dCwgUHJvZ3JhbUluZm99IGZyb20gJy4uL3R5cGVzJztcblxuaW1wb3J0IHtjcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcywgZW5hYmxlU2hhcGVzVW5pZm9ybXMsIGlucHV0VmFyaWFibGUsIG91dHB1dFZhcmlhYmxlLCBTaGFkZXJIZWxwZXJ9IGZyb20gJy4vY29tbW9uJztcblxudHlwZSBCdWlsdGluRnVuY3Rpb25OYW1lID0gc3RyaW5nO1xudHlwZSBCaW5hcnlDdXN0b21FeHByZXNzaW9uID0gKGV4cHJlc3Npb25BOiBzdHJpbmcsIGV4cHJlc3Npb25COiBzdHJpbmcpID0+IHN0cmluZztcbnR5cGUgQmluYXJ5RnVuY3Rpb25DYWxsID0gQnVpbHRpbkZ1bmN0aW9uTmFtZXxCaW5hcnlDdXN0b21FeHByZXNzaW9ufHtcbiAgc2NhbGFyOiBCaW5hcnlDdXN0b21FeHByZXNzaW9uO1xuICB2ZWN0b3I6IEJpbmFyeUN1c3RvbUV4cHJlc3Npb247XG59O1xuXG5jb25zdCBjcmVhdGVCaW5hcnlPcFByb2dyYW1TaGFkZXIgPVxuICAgIChzaGFkZXJIZWxwZXI6IFNoYWRlckhlbHBlciwgZGltc0E6IHJlYWRvbmx5IG51bWJlcltdLCBkaW1zQjogcmVhZG9ubHkgbnVtYmVyW10sIGRpbXNPdXRwdXQ6IHJlYWRvbmx5IG51bWJlcltdLFxuICAgICB2ZWN0b3JpemU6IGJvb2xlYW4sIGRvQnJvYWRjYXN0OiBib29sZWFuLCBzaGFyZWREaW1lbnNpb25EaXZpc2libGVCeTQ6IGJvb2xlYW4sIGZ1bmNDYWxsOiBCaW5hcnlGdW5jdGlvbkNhbGwsXG4gICAgIHR5cGVBOiBudW1iZXIsIHR5cGVCOiBudW1iZXIsIHR5cGVPdXRwdXQ6IG51bWJlciwgdXNlU2hhcGVzVW5pZm9ybXM6IGJvb2xlYW4sXG4gICAgIGFkZGl0aW9uYWxJbXBsZW1lbnRhdGlvbj86IHN0cmluZykgPT4ge1xuICAgICAgbGV0IGV4cHJlc3Npb25TY2FsYXI6IEJpbmFyeUN1c3RvbUV4cHJlc3Npb247XG4gICAgICBsZXQgZXhwcmVzc2lvblZlY3RvcjogQmluYXJ5Q3VzdG9tRXhwcmVzc2lvbjtcbiAgICAgIGlmICh0eXBlb2YgZnVuY0NhbGwgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGV4cHJlc3Npb25TY2FsYXIgPSBleHByZXNzaW9uVmVjdG9yID0gKGEsIGIpID0+IGAke2Z1bmNDYWxsfSgoJHthfSksKCR7Yn0pKWA7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBmdW5jQ2FsbCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBleHByZXNzaW9uU2NhbGFyID0gZXhwcmVzc2lvblZlY3RvciA9IGZ1bmNDYWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXhwcmVzc2lvblNjYWxhciA9IGZ1bmNDYWxsLnNjYWxhcjtcbiAgICAgICAgZXhwcmVzc2lvblZlY3RvciA9IGZ1bmNDYWxsLnZlY3RvcjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgaW5wdXRBU2hhcGVPclJhbmsgPSB1c2VTaGFwZXNVbmlmb3JtcyA/IGRpbXNBLmxlbmd0aCA6IGRpbXNBO1xuICAgICAgY29uc3QgaW5wdXRCU2hhcGVPclJhbmsgPSB1c2VTaGFwZXNVbmlmb3JtcyA/IGRpbXNCLmxlbmd0aCA6IGRpbXNCO1xuICAgICAgY29uc3Qgb3V0cHV0U2hhcGVPclJhbmsgPSB1c2VTaGFwZXNVbmlmb3JtcyA/IGRpbXNPdXRwdXQubGVuZ3RoIDogZGltc091dHB1dDtcbiAgICAgIGNvbnN0IG91dHB1dCA9IG91dHB1dFZhcmlhYmxlKCdvdXRwdXREYXRhJywgdHlwZU91dHB1dCwgb3V0cHV0U2hhcGVPclJhbmssIDQpO1xuICAgICAgY29uc3QgYSA9IGlucHV0VmFyaWFibGUoJ2FEYXRhJywgdHlwZUEsIGlucHV0QVNoYXBlT3JSYW5rLCA0KTtcbiAgICAgIGNvbnN0IGIgPSBpbnB1dFZhcmlhYmxlKCdiRGF0YScsIHR5cGVCLCBpbnB1dEJTaGFwZU9yUmFuaywgNCk7XG5cbiAgICAgIGxldCBhc3NpZ25tZW50OiBzdHJpbmc7XG4gICAgICBpZiAodmVjdG9yaXplKSB7XG4gICAgICAgIGlmIChkb0Jyb2FkY2FzdCkge1xuICAgICAgICAgIGNvbnN0IGlzQU9uZUVsZW1lbnQgPSBTaGFwZVV0aWwuc2l6ZShkaW1zQSkgPT09IDE7XG4gICAgICAgICAgY29uc3QgaXNCT25lRWxlbWVudCA9IFNoYXBlVXRpbC5zaXplKGRpbXNCKSA9PT0gMTtcbiAgICAgICAgICBjb25zdCBhTGFzdERpbURpdmlzaWJsZUJ5NCA9IGRpbXNBLmxlbmd0aCA+IDAgJiYgZGltc0FbZGltc0EubGVuZ3RoIC0gMV0gJSA0ID09PSAwO1xuICAgICAgICAgIGNvbnN0IGJMYXN0RGltRGl2aXNpYmxlQnk0ID0gZGltc0IubGVuZ3RoID4gMCAmJiBkaW1zQltkaW1zQi5sZW5ndGggLSAxXSAlIDQgPT09IDA7XG4gICAgICAgICAgaWYgKGlzQU9uZUVsZW1lbnQgfHwgaXNCT25lRWxlbWVudCkge1xuICAgICAgICAgICAgYXNzaWdubWVudCA9IG91dHB1dC5zZXRCeU9mZnNldChcbiAgICAgICAgICAgICAgICAnZ2xvYmFsX2lkeCcsXG4gICAgICAgICAgICAgICAgZXhwcmVzc2lvblZlY3RvcihcbiAgICAgICAgICAgICAgICAgICAgaXNBT25lRWxlbWVudCA/IGAke2EudHlwZS52YWx1ZX0oJHthLmdldEJ5T2Zmc2V0KCcwJyl9LngpYCA6IGEuZ2V0QnlPZmZzZXQoJ2dsb2JhbF9pZHgnKSxcbiAgICAgICAgICAgICAgICAgICAgaXNCT25lRWxlbWVudCA/IGAke2IudHlwZS52YWx1ZX0oJHtiLmdldEJ5T2Zmc2V0KCcwJyl9LngpYCA6IGIuZ2V0QnlPZmZzZXQoJ2dsb2JhbF9pZHgnKSkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhc3NpZ25tZW50ID0gYFxuICAgICAgICAgICAgbGV0IG91dHB1dEluZGljZXMgPSAke291dHB1dC5vZmZzZXRUb0luZGljZXMoJ2dsb2JhbF9pZHggKiA0dScpfTtcbiAgICAgICAgICAgIGxldCBvZmZzZXRBID0gJHthLmJyb2FkY2FzdGVkSW5kaWNlc1RvT2Zmc2V0KCdvdXRwdXRJbmRpY2VzJywgb3V0cHV0KX07XG4gICAgICAgICAgICBsZXQgb2Zmc2V0QiA9ICR7Yi5icm9hZGNhc3RlZEluZGljZXNUb09mZnNldCgnb3V0cHV0SW5kaWNlcycsIG91dHB1dCl9O1xuICAgICAgICAgICAgJHtcbiAgICAgICAgICAgICAgICBvdXRwdXQuc2V0QnlPZmZzZXQoXG4gICAgICAgICAgICAgICAgICAgICdnbG9iYWxfaWR4JyxcbiAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvblZlY3RvcihcbiAgICAgICAgICAgICAgICAgICAgICAgIHNoYXJlZERpbWVuc2lvbkRpdmlzaWJsZUJ5NCB8fCBhTGFzdERpbURpdmlzaWJsZUJ5NCA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYS5nZXRCeU9mZnNldCgnb2Zmc2V0QSAvIDR1JykgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGAke2EudHlwZS52YWx1ZX0oJHthLmdldEJ5T2Zmc2V0KCdvZmZzZXRBIC8gNHUnKX1bb2Zmc2V0QSAlIDR1XSlgLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2hhcmVkRGltZW5zaW9uRGl2aXNpYmxlQnk0IHx8IGJMYXN0RGltRGl2aXNpYmxlQnk0ID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiLmdldEJ5T2Zmc2V0KCdvZmZzZXRCIC8gNHUnKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYCR7Yi50eXBlLnZhbHVlfSgke2IuZ2V0QnlPZmZzZXQoJ29mZnNldEIgLyA0dScpfVtvZmZzZXRCICUgNHVdKWApKX1cbiAgICAgICAgICBgO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhc3NpZ25tZW50ID0gb3V0cHV0LnNldEJ5T2Zmc2V0KFxuICAgICAgICAgICAgICAnZ2xvYmFsX2lkeCcsIGV4cHJlc3Npb25WZWN0b3IoYS5nZXRCeU9mZnNldCgnZ2xvYmFsX2lkeCcpLCBiLmdldEJ5T2Zmc2V0KCdnbG9iYWxfaWR4JykpKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCFkb0Jyb2FkY2FzdCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbm8gbmVjZXNzYXJ5IHRvIHVzZSBzY2FsYXIgaW1wbGVtZW50YXRpb24gZm9yIGVsZW1lbnQtd2lzZSBiaW5hcnkgb3AgaW1wbGVtZW50YXRpb24uJyk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBzaW5nbGVBc3NpZ25tZW50ID0gKHJlc1N0cjogc3RyaW5nLCB4OiBudW1iZXIsIHR5cGVDYXN0ID0gJycpID0+IHtcbiAgICAgICAgICBjb25zdCBleHByZXNzaW9uQSA9IGBhRGF0YVtpbmRleEEke3h9XVtjb21wb25lbnRBJHt4fV1gO1xuICAgICAgICAgIGNvbnN0IGV4cHJlc3Npb25CID0gYGJEYXRhW2luZGV4QiR7eH1dW2NvbXBvbmVudEIke3h9XWA7XG4gICAgICAgICAgcmV0dXJuIGBcbiAgICAgICAgICAgIGxldCBvdXRwdXRJbmRpY2VzJHt4fSA9ICR7b3V0cHV0Lm9mZnNldFRvSW5kaWNlcyhgZ2xvYmFsX2lkeCAqIDR1ICsgJHt4fXVgKX07XG4gICAgICAgICAgICBsZXQgb2Zmc2V0QSR7eH0gPSAke2EuYnJvYWRjYXN0ZWRJbmRpY2VzVG9PZmZzZXQoYG91dHB1dEluZGljZXMke3h9YCwgb3V0cHV0KX07XG4gICAgICAgICAgICBsZXQgb2Zmc2V0QiR7eH0gPSAke2IuYnJvYWRjYXN0ZWRJbmRpY2VzVG9PZmZzZXQoYG91dHB1dEluZGljZXMke3h9YCwgb3V0cHV0KX07XG4gICAgICAgICAgICBsZXQgaW5kZXhBJHt4fSA9IG9mZnNldEEke3h9IC8gNHU7XG4gICAgICAgICAgICBsZXQgaW5kZXhCJHt4fSA9IG9mZnNldEIke3h9IC8gNHU7XG4gICAgICAgICAgICBsZXQgY29tcG9uZW50QSR7eH0gPSBvZmZzZXRBJHt4fSAlIDR1O1xuICAgICAgICAgICAgbGV0IGNvbXBvbmVudEIke3h9ID0gb2Zmc2V0QiR7eH0gJSA0dTtcbiAgICAgICAgICAgICR7cmVzU3RyfVske3h9XSA9ICR7dHlwZUNhc3R9KCR7ZXhwcmVzc2lvblNjYWxhcihleHByZXNzaW9uQSwgZXhwcmVzc2lvbkIpfSk7XG4gICAgICAgICAgYDtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHR5cGVPdXRwdXQgPT09IERhdGFUeXBlLmJvb2wpIHtcbiAgICAgICAgICBhc3NpZ25tZW50ID0gYFxuICAgICAgICAgICAgdmFyIGRhdGEgPSB2ZWM0PHUzMj4oMCk7XG4gICAgICAgICAgICAke3NpbmdsZUFzc2lnbm1lbnQoJ2RhdGEnLCAwLCAndTMyJyl9XG4gICAgICAgICAgICAke3NpbmdsZUFzc2lnbm1lbnQoJ2RhdGEnLCAxLCAndTMyJyl9XG4gICAgICAgICAgICAke3NpbmdsZUFzc2lnbm1lbnQoJ2RhdGEnLCAyLCAndTMyJyl9XG4gICAgICAgICAgICAke3NpbmdsZUFzc2lnbm1lbnQoJ2RhdGEnLCAzLCAndTMyJyl9XG4gICAgICAgICAgICBvdXRwdXREYXRhW2dsb2JhbF9pZHhdID0gZG90KHZlYzQ8dTMyPigweDEsIDB4MTAwLCAweDEwMDAwLCAweDEwMDAwMDApLCB2ZWM0PHUzMj4oZGF0YSkpO2A7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYXNzaWdubWVudCA9IGBcbiAgICAgICAgICAgICR7c2luZ2xlQXNzaWdubWVudCgnb3V0cHV0RGF0YVtnbG9iYWxfaWR4XScsIDApfVxuICAgICAgICAgICAgJHtzaW5nbGVBc3NpZ25tZW50KCdvdXRwdXREYXRhW2dsb2JhbF9pZHhdJywgMSl9XG4gICAgICAgICAgICAke3NpbmdsZUFzc2lnbm1lbnQoJ291dHB1dERhdGFbZ2xvYmFsX2lkeF0nLCAyKX1cbiAgICAgICAgICAgICR7c2luZ2xlQXNzaWdubWVudCgnb3V0cHV0RGF0YVtnbG9iYWxfaWR4XScsIDMpfVxuICAgICAgICAgIGA7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGBcbiAgICAgICAgJHtzaGFkZXJIZWxwZXIucmVnaXN0ZXJVbmlmb3JtKCd2ZWNfc2l6ZScsICd1MzInKS5kZWNsYXJlVmFyaWFibGVzKGEsIGIsIG91dHB1dCl9XG5cbiAgICAgICAgJHthZGRpdGlvbmFsSW1wbGVtZW50YXRpb24gPz8gJyd9XG5cbiAgICAgICAgJHtzaGFkZXJIZWxwZXIubWFpblN0YXJ0KCl9XG4gICAgICAgICR7c2hhZGVySGVscGVyLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoJ3VuaWZvcm1zLnZlY19zaXplJyl9XG4gICAgICAgICR7YXNzaWdubWVudH1cbiAgICAgIH1gO1xuICAgIH07XG5cbmNvbnN0IGNyZWF0ZUJpbmFyeU9wUHJvZ3JhbUluZm8gPVxuICAgIChuYW1lOiBzdHJpbmcsIGNhY2hlS2V5OiBzdHJpbmcsIGE6IFRlbnNvclZpZXcsIGI6IFRlbnNvclZpZXcsIGZ1bmNDYWxsOiBCaW5hcnlGdW5jdGlvbkNhbGwsXG4gICAgIGFkZGl0aW9uYWxJbXBsZW1lbnRhdGlvbj86IHN0cmluZywgb3V0cHV0RGF0YVR5cGU6IG51bWJlciA9IGEuZGF0YVR5cGUpOiBQcm9ncmFtSW5mbyA9PiB7XG4gICAgICBjb25zdCBpc0Jyb2FkY2FzdCA9ICFTaGFwZVV0aWwuYXJlRXF1YWwoYS5kaW1zLCBiLmRpbXMpO1xuICAgICAgbGV0IG91dHB1dFNoYXBlID0gYS5kaW1zO1xuICAgICAgbGV0IG91dHB1dFNpemUgPSBTaGFwZVV0aWwuc2l6ZShhLmRpbXMpO1xuXG4gICAgICBsZXQgdmVjdG9yaXplID0gZmFsc2U7XG4gICAgICBsZXQgc2hhcmVkRGltZW5zaW9uRGl2aXNpYmxlQnk0ID0gZmFsc2U7XG5cbiAgICAgIC8vIFRPRE86IGRlYWwgd2l0aCB6ZXJvLXNpemVkIHRlbnNvcnMgKGVnLiBkaW1zPVsxLDBdKVxuICAgICAgY29uc3QgY2FjaGVLZXlBdXggPSBbaXNCcm9hZGNhc3RdO1xuICAgICAgaWYgKGlzQnJvYWRjYXN0KSB7XG4gICAgICAgIGNvbnN0IGNhbGN1bGF0ZWRTaGFwZSA9IEJyb2FkY2FzdFV0aWwuY2FsY1NoYXBlKGEuZGltcywgYi5kaW1zLCBmYWxzZSk7XG4gICAgICAgIGlmICghY2FsY3VsYXRlZFNoYXBlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5cXCd0IHBlcmZvcm0gYmluYXJ5IG9wIG9uIHRoZSBnaXZlbiB0ZW5zb3JzJyk7XG4gICAgICAgIH1cbiAgICAgICAgb3V0cHV0U2hhcGUgPSBjYWxjdWxhdGVkU2hhcGU7XG4gICAgICAgIG91dHB1dFNpemUgPSBTaGFwZVV0aWwuc2l6ZShvdXRwdXRTaGFwZSk7XG4gICAgICAgIGNvbnN0IGlzQU9uZUVsZW1lbnQgPSBTaGFwZVV0aWwuc2l6ZShhLmRpbXMpID09PSAxO1xuICAgICAgICBjb25zdCBpc0JPbmVFbGVtZW50ID0gU2hhcGVVdGlsLnNpemUoYi5kaW1zKSA9PT0gMTtcbiAgICAgICAgY29uc3QgYUxhc3REaW1EaXZpc2libGVCeTQgPSBhLmRpbXMubGVuZ3RoID4gMCAmJiBhLmRpbXNbYS5kaW1zLmxlbmd0aCAtIDFdICUgNCA9PT0gMDtcbiAgICAgICAgY29uc3QgYkxhc3REaW1EaXZpc2libGVCeTQgPSBiLmRpbXMubGVuZ3RoID4gMCAmJiBiLmRpbXNbYi5kaW1zLmxlbmd0aCAtIDFdICUgNCA9PT0gMDtcbiAgICAgICAgY2FjaGVLZXlBdXgucHVzaChpc0FPbmVFbGVtZW50KTtcbiAgICAgICAgY2FjaGVLZXlBdXgucHVzaChpc0JPbmVFbGVtZW50KTtcbiAgICAgICAgY2FjaGVLZXlBdXgucHVzaChhTGFzdERpbURpdmlzaWJsZUJ5NCk7XG4gICAgICAgIGNhY2hlS2V5QXV4LnB1c2goYkxhc3REaW1EaXZpc2libGVCeTQpO1xuICAgICAgICAvLyBjaGVjayB3aGV0aGVyIHZlY3Rvcml6ZSBjYW4gYmUgZW5hYmxlZFxuICAgICAgICBsZXQgc2hhcmVkRGltZW5zaW9uID0gMTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBvdXRwdXRTaGFwZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNvbnN0IGRpbUEgPSBhLmRpbXNbYS5kaW1zLmxlbmd0aCAtIGldID8/IDE7XG4gICAgICAgICAgY29uc3QgZGltQiA9IGIuZGltc1tiLmRpbXMubGVuZ3RoIC0gaV0gPz8gMTtcbiAgICAgICAgICBpZiAoZGltQSA9PT0gZGltQikge1xuICAgICAgICAgICAgc2hhcmVkRGltZW5zaW9uICo9IGRpbUE7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoc2hhcmVkRGltZW5zaW9uICUgNCA9PT0gMCkge1xuICAgICAgICAgIHNoYXJlZERpbWVuc2lvbkRpdmlzaWJsZUJ5NCA9IHRydWU7XG4gICAgICAgICAgdmVjdG9yaXplID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0FPbmVFbGVtZW50IHx8IGlzQk9uZUVsZW1lbnQgfHwgYUxhc3REaW1EaXZpc2libGVCeTQgfHwgYkxhc3REaW1EaXZpc2libGVCeTQpIHtcbiAgICAgICAgICB2ZWN0b3JpemUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBlbGVtZW50LXdpc2VcbiAgICAgICAgdmVjdG9yaXplID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGNhY2hlS2V5QXV4LnB1c2godmVjdG9yaXplKTtcbiAgICAgIGNvbnN0IHVzZVNoYXBlc1VuaWZvcm1zID0gZW5hYmxlU2hhcGVzVW5pZm9ybXMoYS5kaW1zLmxlbmd0aCkgJiYgZW5hYmxlU2hhcGVzVW5pZm9ybXMoYi5kaW1zLmxlbmd0aCkgJiZcbiAgICAgICAgICBlbmFibGVTaGFwZXNVbmlmb3JtcyhvdXRwdXRTaGFwZS5sZW5ndGgpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZSxcbiAgICAgICAgc2hhZGVyQ2FjaGU6IHtcbiAgICAgICAgICBoaW50OiBjYWNoZUtleSArIGNhY2hlS2V5QXV4Lm1hcCgoeCkgPT4geC50b1N0cmluZygpKS5qb2luKCdfJyksXG4gICAgICAgICAgaW5wdXREZXBlbmRlbmNpZXM6IHVzZVNoYXBlc1VuaWZvcm1zID8gWydyYW5rJywgJ3JhbmsnXSA6IFsnZGltcycsICdkaW1zJ10sXG4gICAgICAgIH0sXG4gICAgICAgIGdldFNoYWRlclNvdXJjZTogKHNoYWRlckhlbHBlcikgPT4gY3JlYXRlQmluYXJ5T3BQcm9ncmFtU2hhZGVyKFxuICAgICAgICAgICAgc2hhZGVySGVscGVyLCBhLmRpbXMsIGIuZGltcywgb3V0cHV0U2hhcGUsIHZlY3Rvcml6ZSwgaXNCcm9hZGNhc3QsIHNoYXJlZERpbWVuc2lvbkRpdmlzaWJsZUJ5NCwgZnVuY0NhbGwsXG4gICAgICAgICAgICBhLmRhdGFUeXBlLCBiLmRhdGFUeXBlLCBvdXRwdXREYXRhVHlwZSwgdXNlU2hhcGVzVW5pZm9ybXMsIGFkZGl0aW9uYWxJbXBsZW1lbnRhdGlvbiksXG4gICAgICAgIGdldFJ1bkRhdGE6ICgpID0+ICh7XG4gICAgICAgICAgb3V0cHV0czogW3tkaW1zOiBvdXRwdXRTaGFwZSwgZGF0YVR5cGU6IG91dHB1dERhdGFUeXBlfV0sXG4gICAgICAgICAgZGlzcGF0Y2hHcm91cDoge3g6IE1hdGguY2VpbChvdXRwdXRTaXplIC8gNjQgLyogd29ya2dyb3VwIHNpemUgKi8gLyA0IC8qIGNvbXBvbmVudCBzaXplICovKX0sXG4gICAgICAgICAgcHJvZ3JhbVVuaWZvcm1zOiB1c2VTaGFwZXNVbmlmb3JtcyA/XG4gICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICB7dHlwZTogJ3VpbnQzMicsIGRhdGE6IE1hdGguY2VpbChTaGFwZVV0aWwuc2l6ZShvdXRwdXRTaGFwZSkgLyA0KX0sXG4gICAgICAgICAgICAgICAgLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMoYS5kaW1zKSxcbiAgICAgICAgICAgICAgICAuLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhiLmRpbXMpLFxuICAgICAgICAgICAgICAgIC4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKG91dHB1dFNoYXBlKSxcbiAgICAgICAgICAgICAgXSA6XG4gICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICB7dHlwZTogJ3VpbnQzMicsIGRhdGE6IE1hdGguY2VpbChTaGFwZVV0aWwuc2l6ZShvdXRwdXRTaGFwZSkgLyA0KX0sXG4gICAgICAgICAgICAgIF0sXG4gICAgICAgIH0pLFxuICAgICAgfTtcbiAgICB9O1xuXG5jb25zdCBydW5CaW5hcnlPcCA9XG4gICAgKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBuYW1lOiBzdHJpbmcsIGZ1bmNDYWxsOiBCaW5hcnlGdW5jdGlvbkNhbGwsIGFkZGl0aW9uYWxJbXBsZW1lbnRhdGlvbj86IHN0cmluZyxcbiAgICAgY2FjaGVLZXk/OiBzdHJpbmcsIG91dHB1dERhdGFUeXBlPzogbnVtYmVyKTogdm9pZCA9PiB7XG4gICAgICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlQmluYXJ5T3BQcm9ncmFtSW5mbyhcbiAgICAgICAgICBuYW1lLCBjYWNoZUtleSA/PyAnJywgY29udGV4dC5pbnB1dHNbMF0sIGNvbnRleHQuaW5wdXRzWzFdLCBmdW5jQ2FsbCwgYWRkaXRpb25hbEltcGxlbWVudGF0aW9uLFxuICAgICAgICAgIG91dHB1dERhdGFUeXBlKSk7XG4gICAgfTtcblxuZXhwb3J0IGNvbnN0IGFkZCA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCk6IHZvaWQgPT4ge1xuICBydW5CaW5hcnlPcChjb250ZXh0LCAnQWRkJywgKGEsIGIpID0+IGAke2F9KyR7Yn1gKTtcbn07XG5cbmV4cG9ydCBjb25zdCBkaXYgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQpOiB2b2lkID0+IHtcbiAgcnVuQmluYXJ5T3AoY29udGV4dCwgJ0RpdicsIChhLCBiKSA9PiBgJHthfS8ke2J9YCk7XG59O1xuXG5leHBvcnQgY29uc3QgZXF1YWwgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQpOiB2b2lkID0+IHtcbiAgcnVuQmluYXJ5T3AoXG4gICAgICBjb250ZXh0LCAnRXF1YWwnLCAoe3NjYWxhcjogKGEsIGIpID0+IGB1MzIoJHthfT09JHtifSlgLCB2ZWN0b3I6IChhLCBiKSA9PiBgdmVjNDx1MzI+KCR7YX09PSR7Yn0pYH0pLCB1bmRlZmluZWQsXG4gICAgICB1bmRlZmluZWQsIERhdGFUeXBlLmJvb2wpO1xufTtcblxuZXhwb3J0IGNvbnN0IG11bCA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCk6IHZvaWQgPT4ge1xuICBydW5CaW5hcnlPcChjb250ZXh0LCAnTXVsJywgKGEsIGIpID0+IGAke2F9KiR7Yn1gKTtcbn07XG5cbmV4cG9ydCBjb25zdCBwb3cgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQpOiB2b2lkID0+IHtcbiAgY29uc3QgdHlwZSA9IGlucHV0VmFyaWFibGUoJ2lucHV0JywgY29udGV4dC5pbnB1dHNbMF0uZGF0YVR5cGUsIGNvbnRleHQuaW5wdXRzWzBdLmRpbXMpLnR5cGUudmFsdWU7XG4gIGNvbnN0IHJvdW5kU3RyID0gdHlwZSA9PT0gJ2kzMicgPyAncm91bmQnIDogJyc7XG4gIHJ1bkJpbmFyeU9wKFxuICAgICAgY29udGV4dCwgJ1BvdycsICh7c2NhbGFyOiAoYSwgYikgPT4gYHBvd19jdXN0b20oJHthfSwke2J9KWAsIHZlY3RvcjogKGEsIGIpID0+IGBwb3dfdmVjdG9yX2N1c3RvbSgke2F9LCR7Yn0pYH0pLFxuICAgICAgYFxuICAgIGZuIHBvd19jdXN0b20oYSA6ICR7dHlwZX0sIGIgOiAke3R5cGV9KSAtPiAke3R5cGV9IHtcbiAgICAgIGlmIChiID09ICR7dHlwZX0oMC4wKSkge1xuICAgICAgICByZXR1cm4gJHt0eXBlfSgxLjApO1xuICAgICAgfSBlbHNlIGlmIChhIDwgJHt0eXBlfSgwLjApICYmIGYzMihiKSAhPSBmbG9vcihmMzIoYikpKSB7XG4gICAgICAgIHJldHVybiAke3R5cGV9KHBvdyhmMzIoYSksIGYzMihiKSkpOyAvLyBOYU5cbiAgICAgIH1cbiAgICAgIHJldHVybiBzZWxlY3Qoc2lnbihhKSwgJHt0eXBlfSgxLjApLCByb3VuZChmMzIoYWJzKGIpICUgJHt0eXBlfSgyLjApKSkgIT0gMS4wKSAqICR7dHlwZX0oJHtcbiAgICAgICAgICByb3VuZFN0cn0ocG93KGYzMihhYnMoYSkpLCBmMzIoYikpKSk7XG4gICAgfVxuICAgIGZuIHBvd192ZWN0b3JfY3VzdG9tKGEgOiB2ZWM0PCR7dHlwZX0+LCBiIDogdmVjNDwke3R5cGV9PikgLT4gdmVjNDwke3R5cGV9PiB7XG4gICAgICAvLyBUT0RPOiBpbXBsZW1lbnQgdmVjdG9yaXplZCBwb3dcbiAgICAgIHJldHVybiB2ZWM0PCR7dHlwZX0+KHBvd19jdXN0b20oYS54LCBiLngpLCBwb3dfY3VzdG9tKGEueSwgYi55KSwgcG93X2N1c3RvbShhLnosIGIueiksIHBvd19jdXN0b20oYS53LCBiLncpKTtcbiAgICB9XG4gICAgICBgKTtcbn07XG5cbmV4cG9ydCBjb25zdCBzdWIgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQpOiB2b2lkID0+IHtcbiAgcnVuQmluYXJ5T3AoY29udGV4dCwgJ1N1YicsIChhLCBiKSA9PiBgJHthfS0ke2J9YCk7XG59O1xuXG5leHBvcnQgY29uc3QgZ3JlYXRlciA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCk6IHZvaWQgPT4ge1xuICBydW5CaW5hcnlPcChcbiAgICAgIGNvbnRleHQsICdHcmVhdGVyJywgKHtzY2FsYXI6IChhLCBiKSA9PiBgdTMyKCR7YX0+JHtifSlgLCB2ZWN0b3I6IChhLCBiKSA9PiBgdmVjNDx1MzI+KCR7YX0+JHtifSlgfSksIHVuZGVmaW5lZCxcbiAgICAgIHVuZGVmaW5lZCwgRGF0YVR5cGUuYm9vbCk7XG59O1xuXG5leHBvcnQgY29uc3QgbGVzcyA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCk6IHZvaWQgPT4ge1xuICBydW5CaW5hcnlPcChcbiAgICAgIGNvbnRleHQsICdMZXNzJywgKHtzY2FsYXI6IChhLCBiKSA9PiBgdTMyKCR7YX08JHtifSlgLCB2ZWN0b3I6IChhLCBiKSA9PiBgdmVjNDx1MzI+KCR7YX08JHtifSlgfSksIHVuZGVmaW5lZCxcbiAgICAgIHVuZGVmaW5lZCwgRGF0YVR5cGUuYm9vbCk7XG59O1xuXG5leHBvcnQgY29uc3QgZ3JlYXRlck9yRXF1YWwgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQpOiB2b2lkID0+IHtcbiAgcnVuQmluYXJ5T3AoXG4gICAgICBjb250ZXh0LCAnR3JlYXRlck9yRXF1YWwnLCAoe3NjYWxhcjogKGEsIGIpID0+IGB1MzIoJHthfT49JHtifSlgLCB2ZWN0b3I6IChhLCBiKSA9PiBgdmVjNDx1MzI+KCR7YX0+PSR7Yn0pYH0pLFxuICAgICAgdW5kZWZpbmVkLCB1bmRlZmluZWQsIERhdGFUeXBlLmJvb2wpO1xufTtcblxuZXhwb3J0IGNvbnN0IGxlc3NPckVxdWFsID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0KTogdm9pZCA9PiB7XG4gIHJ1bkJpbmFyeU9wKFxuICAgICAgY29udGV4dCwgJ0xlc3NPckVxdWFsJywgKHtzY2FsYXI6IChhLCBiKSA9PiBgdTMyKCR7YX08PSR7Yn0pYCwgdmVjdG9yOiAoYSwgYikgPT4gYHZlYzQ8dTMyPigke2F9PD0ke2J9KWB9KSxcbiAgICAgIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBEYXRhVHlwZS5ib29sKTtcbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7VGVuc29yVmlld30gZnJvbSAnLi4vLi4vdGVuc29yLXZpZXcnO1xuaW1wb3J0IHtTaGFwZVV0aWx9IGZyb20gJy4uLy4uL3V0aWwnO1xuaW1wb3J0IHtBdHRyaWJ1dGVXaXRoQ2FjaGVLZXksIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleX0gZnJvbSAnLi4vYXR0cmlidXRlLXdpdGgtY2FjaGUta2V5JztcbmltcG9ydCB7Q29tcHV0ZUNvbnRleHQsIFByb2dyYW1JbmZvLCBQcm9ncmFtSW5wdXRUZW5zb3JJbmZvRGVwZW5kZW5jeSwgUHJvZ3JhbVVuaWZvcm19IGZyb20gJy4uL3R5cGVzJztcblxuaW1wb3J0IHtjcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcywgZW5hYmxlU2hhcGVzVW5pZm9ybXMsIEluZGljZXNIZWxwZXIsIGlucHV0VmFyaWFibGUsIG91dHB1dFZhcmlhYmxlLCBTaGFkZXJIZWxwZXJ9IGZyb20gJy4vY29tbW9uJztcblxuZXhwb3J0IGludGVyZmFjZSBDb25jYXRBdHRyaWJ1dGVzIGV4dGVuZHMgQXR0cmlidXRlV2l0aENhY2hlS2V5IHtcbiAgcmVhZG9ubHkgYXhpczogbnVtYmVyO1xufVxuXG5jb25zdCB2YWxpZGF0ZUlucHV0cyA9IChpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSk6IHZvaWQgPT4ge1xuICBpZiAoIWlucHV0cyB8fCBpbnB1dHMubGVuZ3RoIDwgMSkge1xuICAgIHRocm93IG5ldyBFcnJvcigndG9vIGZldyBpbnB1dHMnKTtcbiAgfVxuXG4gIGNvbnN0IGlucHV0VHlwZSA9IGlucHV0c1swXS5kYXRhVHlwZTtcbiAgY29uc3QgaW5wdXREaW1lbnNpb25hbGl0eSA9IGlucHV0c1swXS5kaW1zLmxlbmd0aDtcblxuICBmb3IgKGNvbnN0IGlucHV0IG9mIGlucHV0cykge1xuICAgIC8vIG1ha2Ugc3VyZSB0eXBlcyBvZiBhbGwgaW5wdXRzIG1hdGNoXG4gICAgaWYgKGlucHV0LmRhdGFUeXBlICE9PSBpbnB1dFR5cGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW5wdXQgdGVuc29ycyBzaG91bGQgYmUgb25lIHR5cGUnKTtcbiAgICB9XG5cbiAgICAvLyBtYWtlIHN1cmUgdGhlIGRpbWVuc2lvbmFsaXR5IG9mIGFsbCBpbnB1dHMgYXJlIHRoZSBzYW1lXG4gICAgaWYgKGlucHV0LmRpbXMubGVuZ3RoICE9PSBpbnB1dERpbWVuc2lvbmFsaXR5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2lucHV0IHRlbnNvcnMgc2hvdWxkIGhhdmUgdGhlIHNhbWUgc2hhcGUnKTtcbiAgICB9XG4gIH1cbn07XG5cbmNvbnN0IGNhbGN1bGF0ZUlucHV0SW5kZXhJbXBsID0gKG51bWJlck9mVGVuc29yczogbnVtYmVyLCBzaXplSW5Db25jYXRBeGlzU3RyOiBzdHJpbmcpOiBzdHJpbmcgPT4gYFxuICBmbiBjYWxjdWxhdGVJbnB1dEluZGV4KGluZGV4OiB1MzIpIC0+IHUzMiB7XG4gICAgbGV0IHNpemVJbkNvbmNhdEF4aXMgPSBhcnJheTx1MzIsICR7bnVtYmVyT2ZUZW5zb3JzfXU+KCR7c2l6ZUluQ29uY2F0QXhpc1N0cn0pO1xuICAgIGZvciAodmFyIGk6IHUzMiA9IDB1OyBpIDwgJHtudW1iZXJPZlRlbnNvcnN9OyBpICs9IDF1ICkge1xuICAgICAgaWYgKGluZGV4IDwgc2l6ZUluQ29uY2F0QXhpc1tpXSkge1xuICAgICAgICByZXR1cm4gaTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuICR7bnVtYmVyT2ZUZW5zb3JzfXU7XG4gIH1gO1xuXG5jb25zdCBhc3NpZ25PdXRwdXREYXRhID0gKGlucHV0czogcmVhZG9ubHkgSW5kaWNlc0hlbHBlcltdLCBvdXRwdXQ6IEluZGljZXNIZWxwZXIpID0+IHtcbiAgY29uc3QgbnVtYmVyT2ZUZW5zb3JzID0gaW5wdXRzLmxlbmd0aDtcblxuICBjb25zdCBjb2RlTGluZXM6IHN0cmluZ1tdID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtYmVyT2ZUZW5zb3JzOyArK2kpIHtcbiAgICBjb25zdCByZXR1cm5TbmlwcGV0ID0gb3V0cHV0LnNldEJ5T2Zmc2V0KCdnbG9iYWxfaWR4JywgaW5wdXRzW2ldLmdldEJ5SW5kaWNlcygnaW5kaWNlcycpKTtcbiAgICBpZiAobnVtYmVyT2ZUZW5zb3JzID09PSAxKSB7XG4gICAgICBjb2RlTGluZXMucHVzaChyZXR1cm5TbmlwcGV0KTtcbiAgICB9IGVsc2UgaWYgKGkgPT09IDApIHtcbiAgICAgIGNvZGVMaW5lcy5wdXNoKGBpZiAoaW5wdXRJbmRleCA9PSAke2l9dSkgeyAke3JldHVyblNuaXBwZXR9IH1gKTtcbiAgICB9IGVsc2UgaWYgKGkgPT09IG51bWJlck9mVGVuc29ycyAtIDEpIHtcbiAgICAgIGNvZGVMaW5lcy5wdXNoKGBlbHNlIHsgJHtyZXR1cm5TbmlwcGV0fSB9YCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvZGVMaW5lcy5wdXNoKGBlbHNlIGlmIChpbnB1dEluZGV4ID09ICR7aX0pIHsgJHtyZXR1cm5TbmlwcGV0fSB9YCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBjb2RlTGluZXMuam9pbignXFxuJyk7XG59O1xuXG5jb25zdCBjcmVhdGVDb25jYXRQcm9ncmFtSW5mbyA9IChpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSwgYXhpczogbnVtYmVyKTogUHJvZ3JhbUluZm8gPT4ge1xuICBjb25zdCBpbnB1dFNoYXBlID0gaW5wdXRzWzBdLmRpbXMuc2xpY2UoKTtcbiAgaWYgKGF4aXMgPj0gaW5wdXRTaGFwZS5sZW5ndGggfHwgYXhpcyA8ICgtMSAqIGlucHV0U2hhcGUubGVuZ3RoKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignYXhpcyBzcGVjaWZpZWQgZm9yIGNvbmNhdCBkb2VzblxcJ3QgbWF0Y2ggaW5wdXQgZGltZW5zaW9uYWxpdHknKTtcbiAgfVxuICBjb25zdCBhZGp1c3RlZEF4aXMgPSAoYXhpcyA8IDApID8gaW5wdXRTaGFwZS5sZW5ndGggKyBheGlzIDogYXhpcztcbiAgLy8gZW5zdXJlIGFsbCBvZiB0aGUgbm9uLWNvbmNhdGVuYXRlZCBheGVzIG1hdGNoIGVhY2ggb3RoZXJcbiAgLy8gY2FsY3VsYXRlIHRoZSBzaGFwZSBvZiB0aGUgb3V0cHV0IHRlbnNvciB3aGlsZSB3ZSBkbyB0aGF0XG4gIGNvbnN0IG91dHB1dFNoYXBlID0gaW5wdXRTaGFwZS5zbGljZSgwKTtcbiAgZm9yIChsZXQgaSA9IDE7IGkgPCBpbnB1dHMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBkYXRhTlNoYXBlID0gaW5wdXRzW2ldLmRpbXMuc2xpY2UoKTtcbiAgICBmb3IgKGxldCBheGlzSW5kZXggPSAwOyBheGlzSW5kZXggPCBpbnB1dFNoYXBlLmxlbmd0aDsgYXhpc0luZGV4KyspIHtcbiAgICAgIC8vIGFkZCB0byB0aGUgcGxhY2Vob2xkZXIgZm9yIGNvbXB1dGluZyBvdXRwdXQgc2hhcGVcbiAgICAgIGlmIChheGlzSW5kZXggPT09IGFkanVzdGVkQXhpcykge1xuICAgICAgICBvdXRwdXRTaGFwZVthZGp1c3RlZEF4aXNdICs9IGRhdGFOU2hhcGVbYXhpc0luZGV4XTtcbiAgICAgIH1cbiAgICAgIC8vIGVuc3VyZSBhbGwgbm9uLWNhbmNhdGVuYXRlZCBheGVzIG1hdGNoIGVhY2ggb3RoZXJcbiAgICAgIGVsc2UgaWYgKGlucHV0U2hhcGVbYXhpc0luZGV4XSAhPT0gZGF0YU5TaGFwZVtheGlzSW5kZXhdKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbm9uIGNvbmNhdCBkaW1lbnNpb25zIG11c3QgbWF0Y2gnKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBjb25zdCBvdXRwdXRTaXplID0gU2hhcGVVdGlsLnNpemUob3V0cHV0U2hhcGUpO1xuXG4gIGNvbnN0IHNpemVJbkNvbmNhdEF4aXMgPSBuZXcgQXJyYXk8bnVtYmVyPihpbnB1dHMubGVuZ3RoKTtcbiAgY29uc3QgaW5wdXRWYXJzID0gbmV3IEFycmF5PEluZGljZXNIZWxwZXI+KGlucHV0cy5sZW5ndGgpO1xuICBjb25zdCBkYXRhVHlwZSA9IGlucHV0c1swXS5kYXRhVHlwZTtcblxuICBsZXQgcHJldmlvdXNTdW0gPSAwO1xuICBjb25zdCBpbnB1dERlcGVuZGVuY2llczogUHJvZ3JhbUlucHV0VGVuc29ySW5mb0RlcGVuZGVuY3lbXSA9IFtdO1xuICBjb25zdCBpbnB1dFNoYXBlT3JSYW5rcyA9IFtdO1xuICBjb25zdCBlbmFibGVJbnB1dFNoYXBlc1VuaWZvcm1zID0gW107XG4gIGNvbnN0IHByb2dyYW1Vbmlmb3JtczogUHJvZ3JhbVVuaWZvcm1bXSA9IFt7dHlwZTogJ3VpbnQzMicsIGRhdGE6IG91dHB1dFNpemV9XTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnB1dHMubGVuZ3RoOyArK2kpIHtcbiAgICBwcmV2aW91c1N1bSArPSBpbnB1dHNbaV0uZGltc1thZGp1c3RlZEF4aXNdO1xuICAgIHNpemVJbkNvbmNhdEF4aXNbaV0gPSBwcmV2aW91c1N1bTtcbiAgICBlbmFibGVJbnB1dFNoYXBlc1VuaWZvcm1zLnB1c2goZW5hYmxlU2hhcGVzVW5pZm9ybXMoaW5wdXRzW2ldLmRpbXMubGVuZ3RoKSk7XG4gICAgaW5wdXRTaGFwZU9yUmFua3MucHVzaChlbmFibGVJbnB1dFNoYXBlc1VuaWZvcm1zW2ldID8gaW5wdXRzW2ldLmRpbXMubGVuZ3RoIDogaW5wdXRzW2ldLmRpbXMpO1xuICAgIGlucHV0VmFyc1tpXSA9IGlucHV0VmFyaWFibGUoYGlucHV0JHtpfWAsIGRhdGFUeXBlLCBpbnB1dFNoYXBlT3JSYW5rc1tpXSk7XG4gICAgaW5wdXREZXBlbmRlbmNpZXMucHVzaChlbmFibGVJbnB1dFNoYXBlc1VuaWZvcm1zW2ldID8gJ3JhbmsnIDogJ2RpbXMnKTtcbiAgICBwcm9ncmFtVW5pZm9ybXMucHVzaCh7dHlwZTogJ3VpbnQzMicsIGRhdGE6IHNpemVJbkNvbmNhdEF4aXNbaV19KTtcbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0cy5sZW5ndGg7ICsraSkge1xuICAgIGlmIChlbmFibGVJbnB1dFNoYXBlc1VuaWZvcm1zW2ldKSB7XG4gICAgICBwcm9ncmFtVW5pZm9ybXMucHVzaCguLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhpbnB1dHNbaV0uZGltcykpO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGVuYWJsZU91dHB1dFNoYXBlc1VuaWZvcm1zID0gZW5hYmxlU2hhcGVzVW5pZm9ybXMob3V0cHV0U2hhcGUubGVuZ3RoKTtcbiAgaWYgKGVuYWJsZU91dHB1dFNoYXBlc1VuaWZvcm1zKSB7XG4gICAgcHJvZ3JhbVVuaWZvcm1zLnB1c2goLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMob3V0cHV0U2hhcGUpKTtcbiAgfVxuXG4gIGNvbnN0IG91dHB1dFNoYXBlT3JSYW5rID0gZW5hYmxlT3V0cHV0U2hhcGVzVW5pZm9ybXMgPyBvdXRwdXRTaGFwZS5sZW5ndGggOiBvdXRwdXRTaGFwZTtcbiAgY29uc3Qgb3V0cHV0ID0gb3V0cHV0VmFyaWFibGUoJ291dHB1dCcsIGRhdGFUeXBlLCBvdXRwdXRTaGFwZU9yUmFuayk7XG5cbiAgY29uc3QgaW5kaWNlc0F4aXMgPSBvdXRwdXQuaW5kaWNlc0dldCgnaW5kaWNlcycsIGFkanVzdGVkQXhpcyk7XG4gIGNvbnN0IHNpemVJbkNvbmNhdEF4aXNTdHIgPVxuICAgICAgQXJyYXkuZnJvbShBcnJheShzaXplSW5Db25jYXRBeGlzLmxlbmd0aCkua2V5cygpKS5tYXAoaSA9PiBgdW5pZm9ybXMuc2l6ZUluQ29uY2F0QXhpcyR7aX1gKS5qb2luKCcsJyk7XG4gIGNvbnN0IGdldFNoYWRlclNvdXJjZSA9IChzaGFkZXJIZWxwZXI6IFNoYWRlckhlbHBlcikgPT4gYFxuXG4gICR7KCgpID0+IHtcbiAgICBzaGFkZXJIZWxwZXIucmVnaXN0ZXJVbmlmb3JtKCdvdXRwdXRTaXplJywgJ3UzMicpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5wdXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBzaGFkZXJIZWxwZXIucmVnaXN0ZXJVbmlmb3JtKGBzaXplSW5Db25jYXRBeGlzJHtpfWAsICd1MzInKTtcbiAgICB9XG4gICAgcmV0dXJuIHNoYWRlckhlbHBlci5kZWNsYXJlVmFyaWFibGVzKC4uLmlucHV0VmFycywgb3V0cHV0KTtcbiAgfSkoKX1cblxuICAke2NhbGN1bGF0ZUlucHV0SW5kZXhJbXBsKHNpemVJbkNvbmNhdEF4aXMubGVuZ3RoLCBzaXplSW5Db25jYXRBeGlzU3RyKX1cblxuICAke3NoYWRlckhlbHBlci5tYWluU3RhcnQoKX1cbiAgICAke3NoYWRlckhlbHBlci5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKCd1bmlmb3Jtcy5vdXRwdXRTaXplJyl9XG5cbiAgICB2YXIgaW5kaWNlcyA9ICR7b3V0cHV0Lm9mZnNldFRvSW5kaWNlcygnZ2xvYmFsX2lkeCcpfTtcblxuICAgIGxldCBpbnB1dEluZGV4ID0gY2FsY3VsYXRlSW5wdXRJbmRleCgke2luZGljZXNBeGlzfSk7XG4gICAgaWYgKGlucHV0SW5kZXggIT0gMHUpIHtcbiAgICAgIGxldCBzaXplSW5Db25jYXRBeGlzID0gYXJyYXk8dTMyLCAke3NpemVJbkNvbmNhdEF4aXMubGVuZ3RofXU+KCR7c2l6ZUluQ29uY2F0QXhpc1N0cn0pO1xuICAgICAgJHtpbmRpY2VzQXhpc30gLT0gc2l6ZUluQ29uY2F0QXhpc1tpbnB1dEluZGV4IC0gMXVdO1xuICAgIH1cblxuICAgICR7YXNzaWduT3V0cHV0RGF0YShpbnB1dFZhcnMsIG91dHB1dCl9XG4gIH1gO1xuXG4gIHJldHVybiB7XG4gICAgbmFtZTogJ0NvbmNhdCcsXG4gICAgc2hhZGVyQ2FjaGU6IHtoaW50OiBgJHtheGlzfWAsIGlucHV0RGVwZW5kZW5jaWVzfSxcbiAgICBnZXRSdW5EYXRhOiAoKSA9PiAoe1xuICAgICAgb3V0cHV0czogW3tkaW1zOiBvdXRwdXRTaGFwZSwgZGF0YVR5cGU6IGlucHV0c1swXS5kYXRhVHlwZX1dLFxuICAgICAgZGlzcGF0Y2hHcm91cDoge3g6IE1hdGguY2VpbChvdXRwdXRTaXplIC8gNjQgLyogd29ya2dyb3VwIHNpemUgKi8pfSxcbiAgICAgIHByb2dyYW1Vbmlmb3JtcyxcbiAgICB9KSxcbiAgICBnZXRTaGFkZXJTb3VyY2UsXG4gIH07XG59O1xuXG5leHBvcnQgY29uc3QgY29uY2F0ID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBDb25jYXRBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIHZhbGlkYXRlSW5wdXRzKGNvbnRleHQuaW5wdXRzKTtcbiAgY29udGV4dC5jb21wdXRlKGNyZWF0ZUNvbmNhdFByb2dyYW1JbmZvKGNvbnRleHQuaW5wdXRzLCBhdHRyaWJ1dGVzLmF4aXMpKTtcbn07XG5cbmV4cG9ydCBjb25zdCBwYXJzZUNvbmNhdEF0dHJpYnV0ZXMgPSAoYXR0cmlidXRlczogUmVjb3JkPHN0cmluZywgdW5rbm93bj4pOiBDb25jYXRBdHRyaWJ1dGVzID0+XG4gICAgY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KHtheGlzOiBhdHRyaWJ1dGVzLmF4aXMgYXMgbnVtYmVyfSk7XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7TUFYX0NMSVAsIE1JTl9DTElQfSBmcm9tICcuLi8uLi91dGlsJztcblxuZXhwb3J0IGludGVyZmFjZSBJbnRlcm5hbEFjdGl2YXRpb25BdHRyaWJ1dGVzIHtcbiAgcmVhZG9ubHkgYWN0aXZhdGlvbjogc3RyaW5nO1xuICByZWFkb25seSBjbGlwTWluPzogbnVtYmVyO1xuICByZWFkb25seSBjbGlwTWF4PzogbnVtYmVyO1xuICByZWFkb25seSBhY3RpdmF0aW9uQ2FjaGVLZXk6IHN0cmluZztcbn1cblxuZXhwb3J0IGNvbnN0IGdldEFjdGl2YXRpb25TbmlwcGV0ID0gKGF0dHJpYnV0ZXM6IEludGVybmFsQWN0aXZhdGlvbkF0dHJpYnV0ZXMsIHZhbHVlVHlwZTogc3RyaW5nKTpcbiAgICB7YWN0aXZhdGlvbkZ1bmN0aW9uOiBzdHJpbmc7IGFwcGx5QWN0aXZhdGlvbjogc3RyaW5nfSA9PiB7XG4gICAgICBzd2l0Y2ggKGF0dHJpYnV0ZXMuYWN0aXZhdGlvbikge1xuICAgICAgICBjYXNlICdSZWx1JzpcbiAgICAgICAgICByZXR1cm4ge2FjdGl2YXRpb25GdW5jdGlvbjogJycsIGFwcGx5QWN0aXZhdGlvbjogYHZhbHVlID0gbWF4KHZhbHVlLCAke3ZhbHVlVHlwZX0oMC4wKSk7YH07XG4gICAgICAgIGNhc2UgJ1NpZ21vaWQnOlxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhY3RpdmF0aW9uRnVuY3Rpb246ICcnLFxuICAgICAgICAgICAgYXBwbHlBY3RpdmF0aW9uOiBgdmFsdWUgPSAoJHt2YWx1ZVR5cGV9KDEuMCkgLyAoJHt2YWx1ZVR5cGV9KDEuMCkgKyBleHAoLXZhbHVlKSkpO2BcbiAgICAgICAgICB9O1xuICAgICAgICBjYXNlICdDbGlwJzpcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYWN0aXZhdGlvbkZ1bmN0aW9uOiBgY29uc3QgY2xpcF9taW5fPSR7dmFsdWVUeXBlfSgke2F0dHJpYnV0ZXMuY2xpcE1pbiF9KTtjb25zdCBjbGlwX21heF89JHt2YWx1ZVR5cGV9KCR7XG4gICAgICAgICAgICAgICAgYXR0cmlidXRlcy5jbGlwTWF4IX0pO2AsXG4gICAgICAgICAgICBhcHBseUFjdGl2YXRpb246ICd2YWx1ZSA9IGNsYW1wKHZhbHVlLCBjbGlwX21pbl8sIGNsaXBfbWF4Xyk7J1xuICAgICAgICAgIH07XG4gICAgICAgICAgLy8gVE9ETzogYWRkaW5nIG90aGVyIGFjdGl2YXRpb25zIHRoYXQgY2FuIGJlIGZ1c2VkLlxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiB7YWN0aXZhdGlvbkZ1bmN0aW9uOiAnJywgYXBwbHlBY3RpdmF0aW9uOiAnJ307XG4gICAgICB9XG4gICAgfTtcblxuZXhwb3J0IGNvbnN0IHBhcnNlSW50ZXJuYWxBY3RpdmF0aW9uQXR0cmlidXRlcyA9XG4gICAgKGF0dHJpYnV0ZXM6IFJlY29yZDxzdHJpbmcsIHVua25vd24+fHVuZGVmaW5lZCk6IEludGVybmFsQWN0aXZhdGlvbkF0dHJpYnV0ZXMgPT4ge1xuICAgICAgY29uc3QgYWN0aXZhdGlvbiA9IGF0dHJpYnV0ZXM/LmFjdGl2YXRpb24gYXMgc3RyaW5nIHx8ICcnO1xuXG4gICAgICBpZiAoYWN0aXZhdGlvbiA9PT0gJ0NsaXAnKSB7XG4gICAgICAgIGNvbnN0IFtjbGlwTWluLCBjbGlwTWF4XSA9IGF0dHJpYnV0ZXM/LmFjdGl2YXRpb25fcGFyYW1zIGFzIFtudW1iZXIsIG51bWJlcl0gfHwgW01JTl9DTElQLCBNQVhfQ0xJUF07XG4gICAgICAgIHJldHVybiB7YWN0aXZhdGlvbiwgY2xpcE1heCwgY2xpcE1pbiwgYWN0aXZhdGlvbkNhY2hlS2V5OiBgJHthY3RpdmF0aW9ufToke2NsaXBNaW59LCR7Y2xpcE1heH1gfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7YWN0aXZhdGlvbiwgYWN0aXZhdGlvbkNhY2hlS2V5OiBhY3RpdmF0aW9ufTtcbiAgICB9O1xuIiwgIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIxIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cblxuLy8gc2FtcGxlZCBmcm9tIFtAdGVuc29yZmxvdy90ZmpzXSB0ZmpzLWJhY2tlbmQtd2ViZ3B1L3NyYy9hY3RpdmF0aW9uX3V0aWwudHNcbi8vXG4vLyBtb2RpZmllZCB0byBmaXQgdGhlIG5lZWRzIG9mIHRoZSBwcm9qZWN0XG5cbmV4cG9ydCBjb25zdCB0eXBlU25pcHBldCA9IChjb21wb25lbnQ6IG51bWJlciwgZGF0YVR5cGU6IHN0cmluZykgPT4ge1xuICBzd2l0Y2ggKGNvbXBvbmVudCkge1xuICAgIGNhc2UgMTpcbiAgICAgIHJldHVybiBkYXRhVHlwZTtcbiAgICBjYXNlIDI6XG4gICAgICByZXR1cm4gYHZlYzI8JHtkYXRhVHlwZX0+YDtcbiAgICBjYXNlIDM6XG4gICAgICByZXR1cm4gYHZlYzM8JHtkYXRhVHlwZX0+YDtcbiAgICBjYXNlIDQ6XG4gICAgICByZXR1cm4gYHZlYzQ8JHtkYXRhVHlwZX0+YDtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2NvbXBvbmVudH0tY29tcG9uZW50IGlzIG5vdCBzdXBwb3J0ZWQuYCk7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCBiaWFzU25pcHBldCA9IChoYXNCaWFzOiBib29sZWFuKTogc3RyaW5nID0+IGBcbiAgICAgICR7aGFzQmlhcyA/ICd2YWx1ZSA9IHZhbHVlICsgZ2V0Qmlhc0J5T3V0cHV0Q29vcmRzKGNvb3Jkcyk7JyA6ICcnfVxuICAgICAgYDtcbiIsICIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5cbi8vIHNhbXBsZWQgZnJvbSBbQHRlbnNvcmZsb3cvdGZqc10gdGZqcy1jb3JlL3NyYy9vcHMvY29udl91dGlsLnRzXG4vL1xuLy8gbW9kaWZpZWQgdG8gZml0IHRoZSBuZWVkcyBvZiB0aGUgcHJvamVjdFxuXG5leHBvcnQgY29uc3QgdXRpbEZ1bmN0aW9ucyA9IChzdHJpZGVTdHI6IHN0cmluZykgPT4gKGBcbmZuIGdldEluZGV4RnJvbUNvb3JkczREKGNvb3JkcyA6IHZlYzQ8aTMyPiwgc2hhcGUgOiB2ZWM0PGkzMj4pIC0+IGkzMiB7XG4gIHJldHVybiBkb3QoY29vcmRzLCB2ZWM0PGkzMj4oXG4gICAgICBzaGFwZS55ICogc2hhcGUueiAqIHNoYXBlLncsIHNoYXBlLnogKiBzaGFwZS53LCBzaGFwZS53LCAxKSk7XG59XG5mbiBnZXRPdXRwdXRJbmRleEZyb21Db29yZHMoY29vcmRzIDogdmVjNDxpMzI+KSAtPiBpMzIge1xuICByZXR1cm4gZG90KGNvb3JkcywgdmVjNDxpMzI+KFxuICAgIGkzMigke3N0cmlkZVN0cn0ueCksIGkzMigke3N0cmlkZVN0cn0ueSksIGkzMigke3N0cmlkZVN0cn0ueiksIDEpKTtcbn1cbmApO1xuIiwgIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cblxuLy8gc2FtcGxlZCBmcm9tIFtAdGVuc29yZmxvdy90ZmpzXSB0ZmpzLWJhY2tlbmQtd2ViZ3B1L3NyYy9tYXRtdWxfcGFja2VkX3dlYmdwdS50c1xuLy9cbi8vIG1vZGlmaWVkIHRvIGZpdCB0aGUgbmVlZHMgb2YgdGhlIHByb2plY3RcblxuaW1wb3J0IHtUZW5zb3JWaWV3fSBmcm9tICcuLi8uLi8uLi90ZW5zb3Itdmlldyc7XG5pbXBvcnQge1NoYXBlVXRpbH0gZnJvbSAnLi4vLi4vLi4vdXRpbCc7XG5pbXBvcnQge1Byb2dyYW1JbmZvLCBQcm9ncmFtSW5wdXRUZW5zb3JJbmZvRGVwZW5kZW5jeSwgUHJvZ3JhbVVuaWZvcm19IGZyb20gJy4uLy4uL3R5cGVzJztcbmltcG9ydCB7Y3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMsIGVuYWJsZVNoYXBlc1VuaWZvcm1zLCBnZXRCcm9hZGNhc3REaW1zLCBJbmRpY2VzSGVscGVyLCBpbnB1dFZhcmlhYmxlLCBpbnRlcm5hbFZhcmlhYmxlLCBvdXRwdXRWYXJpYWJsZSwgU2hhZGVySGVscGVyLCB0ZW5zb3JUeXBlVG9Xc2dsU3RvcmFnZVR5cGV9IGZyb20gJy4uL2NvbW1vbic7XG5pbXBvcnQge2dldEFjdGl2YXRpb25TbmlwcGV0LCBJbnRlcm5hbEFjdGl2YXRpb25BdHRyaWJ1dGVzfSBmcm9tICcuLi9mdXNlLXV0aWxzJztcblxuaW1wb3J0IHt0eXBlU25pcHBldH0gZnJvbSAnLi9hY3RpdmF0aW9uX3V0aWwnO1xuXG5jb25zdCB3cml0ZURhdGFUb1N1YkFWZWM0U25pcHBldCA9ICh0cmFuc3Bvc2U6IGJvb2xlYW4sIGJhdGNoRGltcz86IEluZGljZXNIZWxwZXIpID0+IHtcbiAgaWYgKHRyYW5zcG9zZSkge1xuICAgIHJldHVybiBgXG4gICAgICAgIG1tX0FzdWJbaW5wdXRSb3ddW2lucHV0Q29sXSA9IG1tX3JlYWRBKGJhdGNoLFxuICAgICAgICAgIGtTdGFydCArIGlucHV0Um93LFxuICAgICAgICAgIGdsb2JhbFJvd1N0YXJ0IC8gaW5uZXJFbGVtZW50U2l6ZSArIGlucHV0Q29sJHtiYXRjaERpbXMgPyAnLCBiYXRjaEluZGljZXMnIDogJyd9KTtcbiAgICAgICAgYDtcblxuICB9IGVsc2Uge1xuICAgIHJldHVybiBgXG4gICAgICAgIG1tX0FzdWJbaW5wdXRSb3ddW2lucHV0Q29sXSA9IG1tX3JlYWRBKGJhdGNoLFxuICAgICAgICAgIGdsb2JhbFJvdyArIGlubmVyUm93LFxuICAgICAgICAgIGtTdGFydCAvIGlubmVyRWxlbWVudFNpemUgKyBpbnB1dENvbCR7YmF0Y2hEaW1zID8gJywgYmF0Y2hJbmRpY2VzJyA6ICcnfSk7XG4gICAgICAgIGA7XG4gIH1cbn07XG5cbmNvbnN0IGNhbGN1bGF0ZVJlc3VsdFNuaXBwZXQgPSAodHJhbnNwb3NlQTogYm9vbGVhbiwgaW5uZXJFbGVtZW50U2l6ZTogbnVtYmVyKSA9PiB7XG4gIGlmICh0cmFuc3Bvc2VBKSB7XG4gICAgcmV0dXJuIGBcbiAgICAgICAgbGV0IEFDYWNoZWQwID0gbW1fQXN1YltrICogaW5uZXJFbGVtZW50U2l6ZV1bbG9jYWxSb3ddO1xuICAgICAgICBsZXQgQUNhY2hlZDEgPSBtbV9Bc3ViW2sgKiBpbm5lckVsZW1lbnRTaXplICsgMV1bbG9jYWxSb3ddO1xuICAgICAgICBsZXQgQUNhY2hlZDIgPSBtbV9Bc3ViW2sgKiBpbm5lckVsZW1lbnRTaXplICsgMl1bbG9jYWxSb3ddO1xuICAgICAgICAke2lubmVyRWxlbWVudFNpemUgPT09IDMgPyAnJyA6ICdsZXQgQUNhY2hlZDMgPSBtbV9Bc3ViW2sgKiBpbm5lckVsZW1lbnRTaXplICsgM11bbG9jYWxSb3ddOyd9XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcm93UGVyVGhyZWFkOyBpID0gaSArIDEpIHtcbiAgICAgICAgICBhY2NbaV0gPSBCQ2FjaGVkMCAqIEFDYWNoZWQwW2ldICsgYWNjW2ldO1xuICAgICAgICAgIGFjY1tpXSA9IEJDYWNoZWQxICogQUNhY2hlZDFbaV0gKyBhY2NbaV07XG4gICAgICAgICAgYWNjW2ldID0gQkNhY2hlZDIgKiBBQ2FjaGVkMltpXSArIGFjY1tpXTtcbiAgICAgICAgICAke2lubmVyRWxlbWVudFNpemUgPT09IDMgPyAnJyA6ICdhY2NbaV0gPSBCQ2FjaGVkMyAqIEFDYWNoZWQzW2ldICsgYWNjW2ldOyd9XG4gICAgICAgIH1gO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBgXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcm93UGVyVGhyZWFkOyBpID0gaSArIDEpIHtcbiAgICAgICAgICBsZXQgQUNhY2hlZCA9IG1tX0FzdWJbdGlsZVJvdyArIGldW2tdO1xuICAgICAgICAgIGFjY1tpXSA9IEJDYWNoZWQwICogQUNhY2hlZC54ICsgYWNjW2ldO1xuICAgICAgICAgIGFjY1tpXSA9IEJDYWNoZWQxICogQUNhY2hlZC55ICsgYWNjW2ldO1xuICAgICAgICAgIGFjY1tpXSA9IEJDYWNoZWQyICogQUNhY2hlZC56ICsgYWNjW2ldO1xuICAgICAgICAgICR7aW5uZXJFbGVtZW50U2l6ZSA9PT0gMyA/ICcnIDogJ2FjY1tpXSA9IEJDYWNoZWQzICogQUNhY2hlZC53ICsgYWNjW2ldOyd9XG4gICAgICAgIH1gO1xuICB9XG59O1xuXG5leHBvcnQgY29uc3QgbWFrZU1hdE11bFBhY2tlZFZlYzRTb3VyY2UgPVxuICAgICh3b3JrUGVyVGhyZWFkOiBudW1iZXJbXSwgd29ya2dyb3VwU2l6ZTogW251bWJlciwgbnVtYmVyLCBudW1iZXJdLCB0eXBlID0gJ2YzMicsIGJhdGNoRGltcz86IEluZGljZXNIZWxwZXIsXG4gICAgIHRyYW5zcG9zZUEgPSBmYWxzZSwgdGlsZUlubmVyID0gMzIsIHNwbGl0SyA9IGZhbHNlLCBzcGxpdGVkRGltSW5uZXIgPSAzMik6IHN0cmluZyA9PiB7XG4gICAgICBjb25zdCB0aWxlQU91dGVyID0gd29ya2dyb3VwU2l6ZVsxXSAqIHdvcmtQZXJUaHJlYWRbMV07XG4gICAgICBjb25zdCB0aWxlQk91dGVyID0gd29ya2dyb3VwU2l6ZVswXSAqIHdvcmtQZXJUaHJlYWRbMF07XG4gICAgICBjb25zdCB0aWxlQVdpZHRoID0gdHJhbnNwb3NlQSA/IHRpbGVBT3V0ZXIgOiB0aWxlSW5uZXI7XG4gICAgICBjb25zdCB0aWxlQUhpZ2h0ID0gdHJhbnNwb3NlQSA/IHRpbGVJbm5lciA6IHRpbGVBT3V0ZXI7XG4gICAgICBjb25zdCBpbm5lckVsZW1lbnRTaXplID0gdGlsZUFXaWR0aCAvIHdvcmtncm91cFNpemVbMF07XG4gICAgICBjb25zdCByb3dQZXJUaHJlYWRCID0gdGlsZUlubmVyIC8gd29ya2dyb3VwU2l6ZVsxXTtcblxuICAgICAgaWYgKCEoKCh0cmFuc3Bvc2VBICYmIGlubmVyRWxlbWVudFNpemUgPT09IDQgJiYgd29ya1BlclRocmVhZFsxXSA9PT0gNCkgfHxcbiAgICAgICAgICAgICAoIXRyYW5zcG9zZUEgJiYgKGlubmVyRWxlbWVudFNpemUgPT09IDMgfHwgaW5uZXJFbGVtZW50U2l6ZSA9PT0gNCkpKSAmJlxuICAgICAgICAgICAgdGlsZUFXaWR0aCAlIHdvcmtncm91cFNpemVbMF0gPT09IDAgJiYgdGlsZUlubmVyICUgd29ya2dyb3VwU2l6ZVsxXSA9PT0gMCAmJiB3b3JrUGVyVGhyZWFkWzBdID09PSA0KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYElmIHRyYW5zcG9zZUEgJHt0cmFuc3Bvc2VBfSBpcyB0cnVlLCBpbm5lckVsZW1lbnRTaXplICR7XG4gICAgICAgICAgICBpbm5lckVsZW1lbnRTaXplfSBhbmQgd29ya1BlclRocmVhZFsxXSAke3dvcmtQZXJUaHJlYWRbMV19IG11c3QgYmUgNC5cbiAgICAgIE90aGVyd2lzZSwgaW5uZXJFbGVtZW50U2l6ZSAke2lubmVyRWxlbWVudFNpemV9IG11c3QgYmUgMyBvciA0LlxuICB0aWxlQVdpZHRoICR7dGlsZUFXaWR0aH0gbXVzdCBiZSBkaXZpc2libGUgYnkgd29ya2dyb3VwU2l6ZVswXSR7d29ya2dyb3VwU2l6ZVswXX0uIHRpbGVJbm5lciAke1xuICAgICAgICAgICAgdGlsZUlubmVyfSBtdXN0IGJlIGRpdmlzaWJsZSBieSB3b3JrZ3JvdXBTaXplWzFdICR7d29ya2dyb3VwU2l6ZVsxXX0uIGNvbFBlclRocmVhZCAke1xuICAgICAgICAgICAgd29ya1BlclRocmVhZFswXX0gbXVzdCBiZSA0LmApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGBcbnZhcjx3b3JrZ3JvdXA+IG1tX0FzdWI6IGFycmF5PGFycmF5PHZlYyR7aW5uZXJFbGVtZW50U2l6ZX08JHt0eXBlfT4sICR7dGlsZUFXaWR0aCAvIGlubmVyRWxlbWVudFNpemV9PiwgJHt0aWxlQUhpZ2h0fT47XG52YXI8d29ya2dyb3VwPiBtbV9Cc3ViOiBhcnJheTxhcnJheTx2ZWM0PCR7dHlwZX0+LCAke3RpbGVCT3V0ZXIgLyB3b3JrUGVyVGhyZWFkWzBdfT4sICR7dGlsZUlubmVyfT47XG5cbmNvbnN0IHJvd1BlclRocmVhZCA9ICR7d29ya1BlclRocmVhZFsxXX07XG5jb25zdCBjb2xQZXJUaHJlYWQgPSAke3dvcmtQZXJUaHJlYWRbMF19O1xuY29uc3QgaW5uZXJFbGVtZW50U2l6ZSA9ICR7aW5uZXJFbGVtZW50U2l6ZX07XG5jb25zdCB0aWxlSW5uZXIgPSAke3RpbGVJbm5lcn07XG5cbkBjb21wdXRlIEB3b3JrZ3JvdXBfc2l6ZSgke3dvcmtncm91cFNpemVbMF19LCAke3dvcmtncm91cFNpemVbMV19LCAke3dvcmtncm91cFNpemVbMl19KVxuZm4gbWFpbihAYnVpbHRpbihsb2NhbF9pbnZvY2F0aW9uX2lkKSBsb2NhbElkIDogdmVjMzx1MzI+LFxuICAgICAgICBAYnVpbHRpbihnbG9iYWxfaW52b2NhdGlvbl9pZCkgZ2xvYmFsSWQgOiB2ZWMzPHUzMj4sXG4gICAgICAgIEBidWlsdGluKHdvcmtncm91cF9pZCkgd29ya2dyb3VwSWQgOiB2ZWMzPHUzMj4pIHtcbiAgbGV0IGxvY2FsUm93ID0gaTMyKGxvY2FsSWQueSk7XG4gIGxldCB0aWxlUm93ID0gbG9jYWxSb3cgKiByb3dQZXJUaHJlYWQ7XG4gIGxldCB0aWxlQ29sID0gaTMyKGxvY2FsSWQueCk7XG5cbiAgbGV0IGdsb2JhbFJvdyA9aTMyKGdsb2JhbElkLnkpICogcm93UGVyVGhyZWFkO1xuICBsZXQgZ2xvYmFsQ29sID0gaTMyKGdsb2JhbElkLngpO1xuICBsZXQgYmF0Y2ggPSAke3NwbGl0SyA/ICcwJyA6ICdpMzIoZ2xvYmFsSWQueiknfTtcbiAgJHtiYXRjaERpbXMgPyBgbGV0IGJhdGNoSW5kaWNlcyA9ICR7YmF0Y2hEaW1zLm9mZnNldFRvSW5kaWNlcygndTMyKGJhdGNoKScpfTtgIDogJyd9XG4gIGxldCBnbG9iYWxSb3dTdGFydCA9IGkzMih3b3JrZ3JvdXBJZC55KSAqICR7dGlsZUFPdXRlcn07XG5cbiAgbGV0IG51bVRpbGVzID0gJHtzcGxpdEsgPyBgJHtNYXRoLmNlaWwoc3BsaXRlZERpbUlubmVyIC8gdGlsZUlubmVyKX1gIDogJyh1bmlmb3Jtcy5kaW1Jbm5lciAtIDEpIC8gdGlsZUlubmVyICsgMSd9O1xuICB2YXIga1N0YXJ0ID0gJHtzcGxpdEsgPyBgaTMyKGdsb2JhbElkLnopICogJHtzcGxpdGVkRGltSW5uZXJ9YCA6ICcwJ307XG5cbiAgdmFyIGFjYzogYXJyYXk8dmVjNDwke3R5cGV9Piwgcm93UGVyVGhyZWFkPjtcblxuICAvLyBMb29wIG92ZXIgc2hhcmVkIGRpbWVuc2lvbi5cbiAgbGV0IHRpbGVSb3dCID0gbG9jYWxSb3cgKiAke3Jvd1BlclRocmVhZEJ9O1xuICBmb3IgKHZhciB0ID0gMDsgdCA8IG51bVRpbGVzOyB0ID0gdCArIDEpIHtcbiAgICAgIC8vIExvYWQgb25lIHRpbGUgb2YgQSBpbnRvIGxvY2FsIG1lbW9yeS5cbiAgICAgIGZvciAodmFyIGlubmVyUm93ID0gMDsgaW5uZXJSb3cgPCByb3dQZXJUaHJlYWQ7IGlubmVyUm93ID0gaW5uZXJSb3cgKyAxKSB7XG4gICAgICAgICAgbGV0IGlucHV0Um93ID0gdGlsZVJvdyArIGlubmVyUm93O1xuICAgICAgICAgIGxldCBpbnB1dENvbCA9IHRpbGVDb2w7XG4gICAgICAgICAgJHt3cml0ZURhdGFUb1N1YkFWZWM0U25pcHBldCh0cmFuc3Bvc2VBLCBiYXRjaERpbXMpfVxuICAgICAgfVxuXG4gICAgICAvLyBMb2FkIG9uZSB0aWxlIG9mIEIgaW50byBsb2NhbCBtZW1vcnkuXG4gICAgICBmb3IgKHZhciBpbm5lclJvdyA9IDA7IGlubmVyUm93IDwgJHtyb3dQZXJUaHJlYWRCfTsgaW5uZXJSb3cgPSBpbm5lclJvdyArIDEpIHtcbiAgICAgICAgICBsZXQgaW5wdXRSb3cgPSB0aWxlUm93QiArIGlubmVyUm93O1xuICAgICAgICAgIGxldCBpbnB1dENvbCA9IHRpbGVDb2w7XG4gICAgICAgICAgbW1fQnN1YltpbnB1dFJvd11baW5wdXRDb2xdID0gbW1fcmVhZEIoYmF0Y2gsIGtTdGFydCArIGlucHV0Um93LCBnbG9iYWxDb2wke1xuICAgICAgICAgIGJhdGNoRGltcyA/ICcsIGJhdGNoSW5kaWNlcycgOiAnJ30pO1xuICAgICAgfVxuICAgICAga1N0YXJ0ID0ga1N0YXJ0ICsgdGlsZUlubmVyO1xuICAgICAgd29ya2dyb3VwQmFycmllcigpO1xuXG4gICAgICAvLyBDb21wdXRlIGFjYyB2YWx1ZXMgZm9yIGEgc2luZ2xlIHRocmVhZC5cbiAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgdGlsZUlubmVyIC8gaW5uZXJFbGVtZW50U2l6ZTsgayA9IGsgKyAxKSB7XG4gICAgICAgICAgbGV0IEJDYWNoZWQwID0gbW1fQnN1YltrICogaW5uZXJFbGVtZW50U2l6ZV1bdGlsZUNvbF07XG4gICAgICAgICAgbGV0IEJDYWNoZWQxID0gbW1fQnN1YltrICogaW5uZXJFbGVtZW50U2l6ZSArIDFdW3RpbGVDb2xdO1xuICAgICAgICAgIGxldCBCQ2FjaGVkMiA9IG1tX0JzdWJbayAqIGlubmVyRWxlbWVudFNpemUgKyAyXVt0aWxlQ29sXTtcbiAgICAgICAgICAke2lubmVyRWxlbWVudFNpemUgPT09IDMgPyAnJyA6ICdsZXQgQkNhY2hlZDMgPSBtbV9Cc3ViW2sgKiBpbm5lckVsZW1lbnRTaXplICsgM11bdGlsZUNvbF07J31cblxuICAgICAgICAgICR7Y2FsY3VsYXRlUmVzdWx0U25pcHBldCh0cmFuc3Bvc2VBLCBpbm5lckVsZW1lbnRTaXplKX1cbiAgICAgIH1cblxuICAgICAgd29ya2dyb3VwQmFycmllcigpO1xuICB9XG5cbiAgZm9yICh2YXIgaW5uZXJSb3cgPSAwOyBpbm5lclJvdyA8IHJvd1BlclRocmVhZDsgaW5uZXJSb3cgPSBpbm5lclJvdyArIDEpIHtcbiAgICAgIG1tX3dyaXRlKGJhdGNoLCBnbG9iYWxSb3cgKyBpbm5lclJvdywgZ2xvYmFsQ29sLCBhY2NbaW5uZXJSb3ddKTtcbiAgfVxufWA7XG4gICAgfTtcblxuY29uc3Qgd3JpdGVEYXRhVG9TdWJBU25pcHBldCA9ICh0cmFuc3Bvc2U6IGJvb2xlYW4sIGJhdGNoRGltcz86IEluZGljZXNIZWxwZXIpID0+IHtcbiAgaWYgKHRyYW5zcG9zZSkge1xuICAgIHJldHVybiBgXG4gICAgICAgICAgICBtbV9Bc3ViW2lucHV0Um93XVtpbnB1dENvbF0gPSBtbV9yZWFkQShiYXRjaCxcbiAgICAgICAgICAgICAga1N0YXJ0ICsgaW5wdXRSb3csXG4gICAgICAgICAgICAgIGdsb2JhbFJvd1N0YXJ0ICsgaW5wdXRDb2wke2JhdGNoRGltcyA/ICcsIGJhdGNoSW5kaWNlcycgOiAnJ30pO1xuICAgICAgICAgICAgYDtcblxuICB9IGVsc2Uge1xuICAgIHJldHVybiBgXG4gICAgICAgICAgICBtbV9Bc3ViW2lucHV0Um93XVtpbnB1dENvbF0gPSBtbV9yZWFkQShiYXRjaCxcbiAgICAgICAgICAgICAgZ2xvYmFsUm93U3RhcnQgKyBpbnB1dFJvdyxcbiAgICAgICAgICAgICAga1N0YXJ0ICsgaW5wdXRDb2wke2JhdGNoRGltcyA/ICcsIGJhdGNoSW5kaWNlcycgOiAnJ30pO1xuICAgICAgICAgICAgYDtcbiAgfVxufTtcblxuY29uc3QgcmVhZERhdGFGcm9tU3ViQVNuaXBwZXQgPSAodHJhbnNwb3NlQTogYm9vbGVhbikgPT5cbiAgICB0cmFuc3Bvc2VBID8gJ2xldCBBQ2FjaGVkID0gbW1fQXN1YltrXVt0aWxlUm93ICsgaW5uZXJSb3ddOycgOiAnbGV0IEFDYWNoZWQgPSBtbV9Bc3ViW3RpbGVSb3cgKyBpbm5lclJvd11ba107JztcblxuLy8gc2VxdWVudGlhbEFjY2Vzc0J5VGhyZWFkcyBtZWFucyBzZXF1ZW50aWFsIGRhdGEgaW4gbWVtb3J5IGlzIGFjY2Vzc2VkIGJ5XG4vLyB0aHJlYWRzLCBpbnN0ZWFkIG9mIGEgc2luZ2xlIHRocmVhZCAoZGVmYXVsdCBiZWhhdmlvcikuXG5leHBvcnQgY29uc3QgbWFrZU1hdE11bFBhY2tlZFNvdXJjZSA9XG4gICAgKHdvcmtQZXJUaHJlYWQ6IG51bWJlcltdLCB3b3JrZ3JvdXBTaXplOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl0sIHR5cGUgPSAnZjMyJywgYmF0Y2hEaW1zPzogSW5kaWNlc0hlbHBlcixcbiAgICAgdHJhbnNwb3NlQSA9IGZhbHNlLCB0aWxlSW5uZXIgPSAzMiwgc3BsaXRLID0gZmFsc2UsIHNwbGl0ZWREaW1Jbm5lciA9IDMyLFxuICAgICBzZXF1ZW50aWFsQWNjZXNzQnlUaHJlYWRzID0gZmFsc2UpOiBzdHJpbmcgPT4ge1xuICAgICAgY29uc3QgdGlsZUFPdXRlciA9IHdvcmtQZXJUaHJlYWRbMV0gKiB3b3JrZ3JvdXBTaXplWzFdO1xuICAgICAgY29uc3QgdGlsZUJPdXRlciA9IHdvcmtQZXJUaHJlYWRbMF0gKiB3b3JrZ3JvdXBTaXplWzBdO1xuICAgICAgY29uc3QgdGlsZUFXaWR0aCA9IHRyYW5zcG9zZUEgPyB0aWxlQU91dGVyIDogdGlsZUlubmVyO1xuICAgICAgY29uc3QgdGlsZUFIaWdodCA9IHRyYW5zcG9zZUEgPyB0aWxlSW5uZXIgOiB0aWxlQU91dGVyO1xuXG4gICAgICBpZiAoISh0aWxlQUhpZ2h0ICUgd29ya2dyb3VwU2l6ZVsxXSA9PT0gMCAmJiB0aWxlQVdpZHRoICUgd29ya2dyb3VwU2l6ZVswXSA9PT0gMCAmJlxuICAgICAgICAgICAgdGlsZUlubmVyICUgd29ya2dyb3VwU2l6ZVsxXSA9PT0gMCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB0aWxlQUhpZ2h0ICR7dGlsZUFIaWdodH0gbXVzdCBiZSBkaXZpc2libGUgYnkgd29ya2dyb3VwU2l6ZVsxXSR7XG4gICAgICAgICAgICB3b3JrZ3JvdXBTaXplWzFdfSwgdGlsZUFXaWR0aCAke3RpbGVBV2lkdGh9IG11c3QgYmUgZGl2aXNpYmxlIGJ5IHdvcmtncm91cFNpemVbMF0ke1xuICAgICAgICAgICAgd29ya2dyb3VwU2l6ZVswXX0sIHRpbGVJbm5lciAke3RpbGVJbm5lcn0gbXVzdCBiZSBkaXZpc2libGUgYnkgd29ya2dyb3VwU2l6ZVsxXSR7d29ya2dyb3VwU2l6ZVsxXX1gKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJvd1BlclRocmVhZEEgPSB0aWxlQUhpZ2h0IC8gd29ya2dyb3VwU2l6ZVsxXTtcbiAgICAgIGNvbnN0IGNvbFBlclRocmVhZEEgPSB0aWxlQVdpZHRoIC8gd29ya2dyb3VwU2l6ZVswXTtcbiAgICAgIGNvbnN0IHJvd1BlclRocmVhZEIgPSB0aWxlSW5uZXIgLyB3b3JrZ3JvdXBTaXplWzFdO1xuICAgICAgY29uc3QgbWF0bXVsU25pcHBldCA9IHNlcXVlbnRpYWxBY2Nlc3NCeVRocmVhZHMgP1xuICAgICAgICAgIGBcbiAgICBsZXQgbG9jYWxSb3cgPSBpMzIobG9jYWxJZC55KTtcbiAgICBsZXQgbG9jYWxDb2wgPSBpMzIobG9jYWxJZC54KTtcbiAgICBsZXQgZ2xvYmFsUm93U3RhcnQgPSBpMzIod29ya2dyb3VwSWQueSkgKiAke3RpbGVBT3V0ZXJ9O1xuICAgIGxldCBnbG9iYWxDb2xTdGFydCA9IGkzMih3b3JrZ3JvdXBJZC54KSAqICR7dGlsZUJPdXRlcn07XG5cbiAgICAvLyBMb29wIG92ZXIgc2hhcmVkIGRpbWVuc2lvbi5cbiAgICBmb3IgKHZhciB0ID0gMDsgdCA8IG51bVRpbGVzOyB0ID0gdCArIDEpIHtcbiAgICAgIC8vIExvYWQgb25lIHRpbGUgb2YgQSBpbnRvIGxvY2FsIG1lbW9yeS5cbiAgICAgIGZvciAodmFyIGlucHV0Um93ID0gbG9jYWxSb3c7IGlucHV0Um93IDwgJHt0aWxlQUhpZ2h0fTsgaW5wdXRSb3cgPSBpbnB1dFJvdyArICR7d29ya2dyb3VwU2l6ZVsxXX0pIHtcbiAgICAgICAgZm9yICh2YXIgaW5wdXRDb2wgPSBsb2NhbENvbDsgaW5wdXRDb2wgPCAke3RpbGVBV2lkdGh9OyBpbnB1dENvbCA9IGlucHV0Q29sICsgJHt3b3JrZ3JvdXBTaXplWzBdfSkge1xuICAgICAgICAgICR7d3JpdGVEYXRhVG9TdWJBU25pcHBldCh0cmFuc3Bvc2VBLCBiYXRjaERpbXMpfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBMb2FkIG9uZSB0aWxlIG9mIEIgaW50byBsb2NhbCBtZW1vcnkuXG4gICAgICBmb3IgKHZhciBpbnB1dFJvdyA9IGxvY2FsUm93OyBpbnB1dFJvdyA8ICR7dGlsZUlubmVyfTsgaW5wdXRSb3cgPSBpbnB1dFJvdyArICR7d29ya2dyb3VwU2l6ZVsxXX0pIHtcbiAgICAgICAgICAgIGZvciAodmFyIGlucHV0Q29sID0gbG9jYWxDb2w7IGlucHV0Q29sIDwgJHt0aWxlQk91dGVyfTsgaW5wdXRDb2wgPSBpbnB1dENvbCArICR7d29ya2dyb3VwU2l6ZVswXX0pIHtcbiAgICAgICAgICBtbV9Cc3ViW2lucHV0Um93XVtpbnB1dENvbF0gPSBtbV9yZWFkQihiYXRjaCxcbiAgICAgICAgICAgIGtTdGFydCArIGlucHV0Um93LFxuICAgICAgICAgICAgZ2xvYmFsQ29sU3RhcnQgKyBpbnB1dENvbCR7YmF0Y2hEaW1zID8gJywgYmF0Y2hJbmRpY2VzJyA6ICcnfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGtTdGFydCA9IGtTdGFydCArIHRpbGVJbm5lcjtcbiAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcblxuICAgICAgLy8gQ29tcHV0ZSBhY2MgdmFsdWVzIGZvciBhIHNpbmdsZSB0aHJlYWQuXG4gICAgICB2YXIgQkNhY2hlZCA6IGFycmF5PCR7dHlwZX0sIGNvbFBlclRocmVhZD47XG4gICAgICBmb3IgKHZhciBrID0gMDsgayA8IHRpbGVJbm5lcjsgayA9IGsgKyAxKSB7XG4gICAgICAgIGZvciAodmFyIGlubmVyID0gMDsgaW5uZXIgPCBjb2xQZXJUaHJlYWQ7IGlubmVyID0gaW5uZXIgKyAxKSB7XG4gICAgICAgICAgQkNhY2hlZFtpbm5lcl0gPSBtbV9Cc3ViW2tdW2xvY2FsQ29sICsgaW5uZXIgKiAke3dvcmtncm91cFNpemVbMF19XTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpbm5lclJvdyA9IDA7IGlubmVyUm93IDwgcm93UGVyVGhyZWFkOyBpbm5lclJvdyA9IGlubmVyUm93ICsgMSkge1xuICAgICAgICAgIGxldCBBQ2FjaGVkID0gJHtcbiAgICAgICAgICAgICAgdHJhbnNwb3NlQSA/IGBtbV9Bc3ViW2tdW2xvY2FsUm93ICsgaW5uZXJSb3cgKiAke3dvcmtncm91cFNpemVbMV19XTtgIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGBtbV9Bc3ViW2xvY2FsUm93ICsgaW5uZXJSb3cgKiAke3dvcmtncm91cFNpemVbMV19XVtrXTtgfVxuICAgICAgICAgIGZvciAodmFyIGlubmVyQ29sID0gMDsgaW5uZXJDb2wgPCBjb2xQZXJUaHJlYWQ7IGlubmVyQ29sID0gaW5uZXJDb2wgKyAxKSB7XG4gICAgICAgICAgICBhY2NbaW5uZXJSb3ddW2lubmVyQ29sXSA9IGFjY1tpbm5lclJvd11baW5uZXJDb2xdICtcbiAgICAgICAgICAgICAgICBBQ2FjaGVkICogQkNhY2hlZFtpbm5lckNvbF07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG4gICAgfVxuICAgIGZvciAodmFyIGlubmVyUm93ID0gMDsgaW5uZXJSb3cgPCByb3dQZXJUaHJlYWQ7IGlubmVyUm93ID0gaW5uZXJSb3cgKyAxKSB7XG4gICAgICBsZXQgZ1JvdyA9IGdsb2JhbFJvd1N0YXJ0ICsgbG9jYWxSb3cgKyBpbm5lclJvdyAqICR7d29ya2dyb3VwU2l6ZVsxXX07XG4gICAgICBmb3IgKHZhciBpbm5lckNvbCA9IDA7IGlubmVyQ29sIDwgY29sUGVyVGhyZWFkOyBpbm5lckNvbCA9IGlubmVyQ29sICsgMSkge1xuICAgICAgICBsZXQgZ0NvbCA9IGdsb2JhbENvbFN0YXJ0ICsgbG9jYWxDb2wgKyBpbm5lckNvbCAqICR7d29ya2dyb3VwU2l6ZVswXX07XG4gICAgICAgIG1tX3dyaXRlKGJhdGNoLCBnUm93LCBnQ29sLCBhY2NbaW5uZXJSb3ddW2lubmVyQ29sXSk7XG4gICAgICB9XG4gICAgfVxuICAgIGAgOlxuICAgICAgICAgIGBcbmxldCB0aWxlUm93ID0gaTMyKGxvY2FsSWQueSkgKiByb3dQZXJUaHJlYWQ7XG5sZXQgdGlsZUNvbCA9IGkzMihsb2NhbElkLngpICogY29sUGVyVGhyZWFkO1xuXG5sZXQgZ2xvYmFsUm93ID0gaTMyKGdsb2JhbElkLnkpICogcm93UGVyVGhyZWFkO1xubGV0IGdsb2JhbENvbCA9IGkzMihnbG9iYWxJZC54KSAqIGNvbFBlclRocmVhZDtcbmxldCBnbG9iYWxSb3dTdGFydCA9IGkzMih3b3JrZ3JvdXBJZC55KSAqICR7dGlsZUFPdXRlcn07XG5cbmxldCB0aWxlUm93QSA9IGkzMihsb2NhbElkLnkpICogJHtyb3dQZXJUaHJlYWRBfTtcbmxldCB0aWxlQ29sQSA9IGkzMihsb2NhbElkLngpICogJHtjb2xQZXJUaHJlYWRBfTtcbmxldCB0aWxlUm93QiA9IGkzMihsb2NhbElkLnkpICogJHtyb3dQZXJUaHJlYWRCfTtcbi8vIExvb3Agb3ZlciBzaGFyZWQgZGltZW5zaW9uLlxuZm9yICh2YXIgdCA9IDA7IHQgPCBudW1UaWxlczsgdCA9IHQgKyAxKSB7XG4gIC8vIExvYWQgb25lIHRpbGUgb2YgQSBpbnRvIGxvY2FsIG1lbW9yeS5cbiAgZm9yICh2YXIgaW5uZXJSb3cgPSAwOyBpbm5lclJvdyA8ICR7cm93UGVyVGhyZWFkQX07IGlubmVyUm93ID0gaW5uZXJSb3cgKyAxKSB7XG4gICAgZm9yICh2YXIgaW5uZXJDb2wgPSAwOyBpbm5lckNvbCA8ICR7Y29sUGVyVGhyZWFkQX07IGlubmVyQ29sID0gaW5uZXJDb2wgKyAxKSB7XG4gICAgICBsZXQgaW5wdXRSb3cgPSB0aWxlUm93QSArIGlubmVyUm93O1xuICAgICAgbGV0IGlucHV0Q29sID0gdGlsZUNvbEEgKyBpbm5lckNvbDtcbiAgICAgICR7d3JpdGVEYXRhVG9TdWJBU25pcHBldCh0cmFuc3Bvc2VBLCBiYXRjaERpbXMpfVxuICAgIH1cbiAgfVxuXG4gIC8vIExvYWQgb25lIHRpbGUgb2YgQiBpbnRvIGxvY2FsIG1lbW9yeS5cbiAgZm9yICh2YXIgaW5uZXJSb3cgPSAwOyBpbm5lclJvdyA8ICR7cm93UGVyVGhyZWFkQn07IGlubmVyUm93ID0gaW5uZXJSb3cgKyAxKSB7XG4gICAgZm9yICh2YXIgaW5uZXJDb2wgPSAwOyBpbm5lckNvbCA8IGNvbFBlclRocmVhZDsgaW5uZXJDb2wgPSBpbm5lckNvbCArIDEpIHtcbiAgICAgIGxldCBpbnB1dFJvdyA9IHRpbGVSb3dCICsgaW5uZXJSb3c7XG4gICAgICBsZXQgaW5wdXRDb2wgPSB0aWxlQ29sICsgaW5uZXJDb2w7XG4gICAgICBtbV9Cc3ViW2lucHV0Um93XVtpbnB1dENvbF0gPSBtbV9yZWFkQihiYXRjaCxcbiAgICAgICAga1N0YXJ0ICsgaW5wdXRSb3csXG4gICAgICAgIGdsb2JhbENvbCArIGlubmVyQ29sJHtiYXRjaERpbXMgPyAnLCBiYXRjaEluZGljZXMnIDogJyd9KTtcbiAgICB9XG4gIH1cbiAga1N0YXJ0ID0ga1N0YXJ0ICsgdGlsZUlubmVyO1xuICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG5cbiAgLy8gQ29tcHV0ZSBhY2MgdmFsdWVzIGZvciBhIHNpbmdsZSB0aHJlYWQuXG4gIHZhciBCQ2FjaGVkIDogYXJyYXk8JHt0eXBlfSwgY29sUGVyVGhyZWFkPjtcbiAgZm9yICh2YXIgayA9IDA7IGsgPCB0aWxlSW5uZXI7IGsgPSBrICsgMSkge1xuICAgIGZvciAodmFyIGlubmVyID0gMDsgaW5uZXIgPCBjb2xQZXJUaHJlYWQ7IGlubmVyID0gaW5uZXIgKyAxKSB7XG4gICAgICBCQ2FjaGVkW2lubmVyXSA9IG1tX0JzdWJba11bdGlsZUNvbCArIGlubmVyXTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpbm5lclJvdyA9IDA7IGlubmVyUm93IDwgcm93UGVyVGhyZWFkOyBpbm5lclJvdyA9IGlubmVyUm93ICsgMSkge1xuICAgICAgJHtyZWFkRGF0YUZyb21TdWJBU25pcHBldCh0cmFuc3Bvc2VBKX1cbiAgICAgIGZvciAodmFyIGlubmVyQ29sID0gMDsgaW5uZXJDb2wgPCBjb2xQZXJUaHJlYWQ7IGlubmVyQ29sID0gaW5uZXJDb2wgKyAxKSB7XG4gICAgICAgIGFjY1tpbm5lclJvd11baW5uZXJDb2xdID0gYWNjW2lubmVyUm93XVtpbm5lckNvbF0gKyBBQ2FjaGVkICogQkNhY2hlZFtpbm5lckNvbF07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgd29ya2dyb3VwQmFycmllcigpO1xufVxuXG5mb3IgKHZhciBpbm5lclJvdyA9IDA7IGlubmVyUm93IDwgcm93UGVyVGhyZWFkOyBpbm5lclJvdyA9IGlubmVyUm93ICsgMSkge1xuICBmb3IgKHZhciBpbm5lckNvbCA9IDA7IGlubmVyQ29sIDwgY29sUGVyVGhyZWFkOyBpbm5lckNvbCA9IGlubmVyQ29sICsgMSkge1xuICAgIG1tX3dyaXRlKGJhdGNoLCBnbG9iYWxSb3cgKyBpbm5lclJvdywgZ2xvYmFsQ29sICsgaW5uZXJDb2wsXG4gICAgICAgIGFjY1tpbm5lclJvd11baW5uZXJDb2xdKTtcbiAgfVxufVxuYDtcblxuICAgICAgcmV0dXJuIGBcbiAgdmFyPHdvcmtncm91cD4gbW1fQXN1YiA6IGFycmF5PGFycmF5PCR7dHlwZX0sICR7dGlsZUFXaWR0aH0+LCAke3RpbGVBSGlnaHR9PjtcbiAgdmFyPHdvcmtncm91cD4gbW1fQnN1YiA6IGFycmF5PGFycmF5PCR7dHlwZX0sICR7dGlsZUJPdXRlcn0+LCAke3RpbGVJbm5lcn0+O1xuICBjb25zdCByb3dQZXJUaHJlYWQgPSAke3dvcmtQZXJUaHJlYWRbMV19O1xuICBjb25zdCBjb2xQZXJUaHJlYWQgPSAke3dvcmtQZXJUaHJlYWRbMF19O1xuICBjb25zdCB0aWxlSW5uZXIgPSAke3RpbGVJbm5lcn07XG5cbkBjb21wdXRlIEB3b3JrZ3JvdXBfc2l6ZSgke3dvcmtncm91cFNpemVbMF19LCAke3dvcmtncm91cFNpemVbMV19LCAke3dvcmtncm91cFNpemVbMl19KVxuZm4gbWFpbihAYnVpbHRpbihsb2NhbF9pbnZvY2F0aW9uX2lkKSBsb2NhbElkIDogdmVjMzx1MzI+LFxuICAgICAgICBAYnVpbHRpbihnbG9iYWxfaW52b2NhdGlvbl9pZCkgZ2xvYmFsSWQgOiB2ZWMzPHUzMj4sXG4gICAgICAgIEBidWlsdGluKHdvcmtncm91cF9pZCkgd29ya2dyb3VwSWQgOiB2ZWMzPHUzMj4pIHtcbiAgICBsZXQgYmF0Y2ggPSAke3NwbGl0SyA/ICcwJyA6ICdpMzIoZ2xvYmFsSWQueiknfTtcbiAgICAke2JhdGNoRGltcyA/IGBsZXQgYmF0Y2hJbmRpY2VzID0gJHtiYXRjaERpbXMub2Zmc2V0VG9JbmRpY2VzKCd1MzIoYmF0Y2gpJyl9O2AgOiAnJ31cbiAgICBsZXQgbnVtVGlsZXMgPSAke3NwbGl0SyA/IGAke01hdGguY2VpbChzcGxpdGVkRGltSW5uZXIgLyB0aWxlSW5uZXIpfWAgOiAnKHVuaWZvcm1zLmRpbUlubmVyIC0gMSkgLyB0aWxlSW5uZXIgKyAxJ307XG4gICAgdmFyIGtTdGFydCA9ICR7c3BsaXRLID8gYGkzMihnbG9iYWxJZC56KSAqICR7c3BsaXRlZERpbUlubmVyfWAgOiAnMCd9O1xuXG4gICAgdmFyIGFjYyA6IGFycmF5PGFycmF5PCR7dHlwZX0sIGNvbFBlclRocmVhZD4sIHJvd1BlclRocmVhZD47XG5cbiAgICAvLyBXaXRob3V0IHRoaXMgaW5pdGlhbGl6YXRpb24gc3RyYW5nZSB2YWx1ZXMgc2hvdyB1cCBpbiBhY2MuXG4gICAgZm9yICh2YXIgaW5uZXJSb3cgPSAwOyBpbm5lclJvdyA8IHJvd1BlclRocmVhZDsgaW5uZXJSb3cgPSBpbm5lclJvdyArIDEpIHtcbiAgICAgIGZvciAodmFyIGlubmVyQ29sID0gMDsgaW5uZXJDb2wgPCBjb2xQZXJUaHJlYWQ7IGlubmVyQ29sID0gaW5uZXJDb2wgKyAxKSB7XG4gICAgICAgIGFjY1tpbm5lclJvd11baW5uZXJDb2xdID0gMC4wO1xuICAgICAgfVxuICAgIH1cbiAgICAke21hdG11bFNuaXBwZXR9XG4gIH1cbmA7XG4gICAgfTtcblxuY29uc3QgbWF0TXVsUmVhZFdyaXRlRm5Tb3VyY2UgPVxuICAgIChjb21wb25lbnQ6IG51bWJlciwgaGFzQmlhczogYm9vbGVhbiwgYXBwbHlBY3RpdmF0aW9uOiBzdHJpbmcsIHZhcmlhYmxlczogSW5kaWNlc0hlbHBlcltdLFxuICAgICBiYXRjaFNoYXBlczogQXJyYXk8cmVhZG9ubHkgbnVtYmVyW10+LCBpc0NoYW5uZWxzTGFzdCA9IGZhbHNlKTogc3RyaW5nID0+IHtcbiAgICAgIGNvbnN0IFtiYXRjaEFTaGFwZSwgYmF0Y2hCU2hhcGUsIGJhdGNoU2hhcGVdID0gYmF0Y2hTaGFwZXM7XG4gICAgICBjb25zdCBbYmF0Y2hWYXJpYWJsZSwgYVZhcmlhYmxlLCBiVmFyaWFibGUsIG91dHB1dFZhcmlhYmxlXSA9IHZhcmlhYmxlcztcbiAgICAgIGNvbnN0IGJyb2FkQ2FzdEFEaW1zID0gZ2V0QnJvYWRjYXN0RGltcyhiYXRjaEFTaGFwZSwgYmF0Y2hTaGFwZSk7XG4gICAgICBjb25zdCBicm9hZENhc3RCRGltcyA9IGdldEJyb2FkY2FzdERpbXMoYmF0Y2hCU2hhcGUsIGJhdGNoU2hhcGUpO1xuICAgICAgY29uc3QgZGF0YVR5cGUgPSB0ZW5zb3JUeXBlVG9Xc2dsU3RvcmFnZVR5cGUodmFyaWFibGVzWzBdLnR5cGUudGVuc29yKTtcbiAgICAgIGNvbnN0IGdldEFJbmRpY2VzID0gKCkgPT4ge1xuICAgICAgICBjb25zdCBhUmFuayA9IGFWYXJpYWJsZS5yYW5rO1xuICAgICAgICBjb25zdCBiYXRjaFJhbmsgPSBiYXRjaFZhcmlhYmxlLnJhbms7XG4gICAgICAgIGxldCByZXNTdHIgPSBgdmFyIGFJbmRpY2VzOiAke2FWYXJpYWJsZS50eXBlLmluZGljZXN9O2A7XG4gICAgICAgIGZvciAobGV0IGkgPSBhUmFuayAtIDIgLSAxLCBqID0gYmF0Y2hSYW5rIC0gMTsgaSA+PSAwOyBpLS0sIGotLSkge1xuICAgICAgICAgIHJlc1N0ciArPSBgXFxuYUluZGljZXNbJHtpfV0gPSAke2JhdGNoUmFuayA+IDEgPyBgYmF0Y2hJbmRpY2VzWyR7an1dYCA6ICdiYXRjaEluZGljZXMnfTtgO1xuICAgICAgICB9XG4gICAgICAgIGJyb2FkQ2FzdEFEaW1zLmZvckVhY2goaSA9PiB7XG4gICAgICAgICAgcmVzU3RyICs9IGBcXG5hSW5kaWNlc1ske2l9XSA9IDA7YDtcbiAgICAgICAgfSk7XG4gICAgICAgIHJlc1N0ciArPSBgXFxuYUluZGljZXNbJHthUmFuayAtIDJ9XSA9IHUzMihyb3cpO1xuICAgICAgICAgICAgICAgICAgIGFJbmRpY2VzWyR7YVJhbmsgLSAxfV0gPSB1MzIoY29sSW4pO2A7XG4gICAgICAgIHJldHVybiByZXNTdHI7XG4gICAgICB9O1xuICAgICAgY29uc3QgZ2V0QkluZGljZXMgPSAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGJSYW5rID0gYlZhcmlhYmxlLnJhbms7XG4gICAgICAgIGNvbnN0IGJhdGNoUmFuayA9IGJhdGNoVmFyaWFibGUucmFuaztcbiAgICAgICAgbGV0IHJlc1N0ciA9IGB2YXIgYkluZGljZXM6ICR7YlZhcmlhYmxlLnR5cGUuaW5kaWNlc307YDtcbiAgICAgICAgZm9yIChsZXQgaSA9IGJSYW5rIC0gMiAtIDEsIGogPSBiYXRjaFJhbmsgLSAxOyBpID49IDA7IGktLSwgai0tKSB7XG4gICAgICAgICAgcmVzU3RyICs9IGBcXG5iSW5kaWNlc1ske2l9XSA9ICR7YmF0Y2hSYW5rID4gMSA/IGBiYXRjaEluZGljZXNbJHtqfV1gIDogJ2JhdGNoSW5kaWNlcyd9O2A7XG4gICAgICAgIH1cbiAgICAgICAgYnJvYWRDYXN0QkRpbXMuZm9yRWFjaChpID0+IHtcbiAgICAgICAgICByZXNTdHIgKz0gYFxcbmJJbmRpY2VzWyR7aX1dID0gMDtgO1xuICAgICAgICB9KTtcbiAgICAgICAgcmVzU3RyICs9IGBcXG5iSW5kaWNlc1ske2JSYW5rIC0gMn1dID0gdTMyKHJvdyk7XG4gICAgICAgICAgICAgICAgICAgYkluZGljZXNbJHtiUmFuayAtIDF9XSA9IHUzMihjb2xJbik7YDtcbiAgICAgICAgcmV0dXJuIHJlc1N0cjtcbiAgICAgIH07XG4gICAgICBjb25zdCBzb3VyY2UgPSBgXG4gICAgZm4gbW1fcmVhZEEoYmF0Y2g6IGkzMiwgcm93OiBpMzIsIGNvbEluOiBpMzIsIGJhdGNoSW5kaWNlczogJHtiYXRjaFZhcmlhYmxlLnR5cGUuaW5kaWNlc30pIC0+ICR7XG4gICAgICAgICAgdHlwZVNuaXBwZXQoY29tcG9uZW50LCBkYXRhVHlwZSl9IHtcbiAgICAgIHZhciB2YWx1ZSA9ICR7dHlwZVNuaXBwZXQoY29tcG9uZW50LCBkYXRhVHlwZSl9KDAuMCk7XG4gICAgICBsZXQgY29sID0gY29sSW4gKiAke2NvbXBvbmVudH07XG4gICAgICBpZihyb3cgPCB1bmlmb3Jtcy5kaW1BT3V0ZXIgJiYgY29sIDwgdW5pZm9ybXMuZGltSW5uZXIpXG4gICAgICB7XG4gICAgICAgICR7Z2V0QUluZGljZXMoKX1cbiAgICAgICAgdmFsdWUgPSAke2FWYXJpYWJsZS5nZXRCeUluZGljZXMoJ2FJbmRpY2VzJyl9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIGZuIG1tX3JlYWRCKGJhdGNoOiBpMzIsIHJvdzogaTMyLCBjb2xJbjogaTMyLCBiYXRjaEluZGljZXM6ICR7YmF0Y2hWYXJpYWJsZS50eXBlLmluZGljZXN9KSAtPiAke1xuICAgICAgICAgIHR5cGVTbmlwcGV0KGNvbXBvbmVudCwgZGF0YVR5cGUpfSB7XG4gICAgICB2YXIgdmFsdWUgPSAke3R5cGVTbmlwcGV0KGNvbXBvbmVudCwgZGF0YVR5cGUpfSgwLjApO1xuICAgICAgbGV0IGNvbCA9IGNvbEluICogJHtjb21wb25lbnR9O1xuICAgICAgaWYocm93IDwgdW5pZm9ybXMuZGltSW5uZXIgJiYgY29sIDwgdW5pZm9ybXMuZGltQk91dGVyKVxuICAgICAge1xuICAgICAgICAke2dldEJJbmRpY2VzKCl9XG4gICAgICAgIHZhbHVlID0gJHtiVmFyaWFibGUuZ2V0QnlJbmRpY2VzKCdiSW5kaWNlcycpfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICBmbiBtbV93cml0ZShiYXRjaDogaTMyLCByb3c6IGkzMiwgY29sSW46IGkzMiwgdmFsdWVJbjogJHt0eXBlU25pcHBldChjb21wb25lbnQsIGRhdGFUeXBlKX0pIHtcbiAgICAgIGxldCBjb2wgPSBjb2xJbiAqICR7Y29tcG9uZW50fTtcbiAgICAgIGlmIChyb3cgPCB1bmlmb3Jtcy5kaW1BT3V0ZXIgJiYgY29sIDwgdW5pZm9ybXMuZGltQk91dGVyKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHZhbHVlSW47XG4gICAgICAgIGxldCBjb29yZHMgPSB2ZWMzPGkzMj4oYmF0Y2gsIHJvdywgY29sSW4pO1xuICAgICAgICAke1xuICAgICAgICAgIGhhc0JpYXMgP1xuICAgICAgICAgICAgICBgdmFsdWUgPSB2YWx1ZSArICR7aXNDaGFubmVsc0xhc3QgPyAnYmlhc1tjb2xJbl0nIDogYCR7dHlwZVNuaXBwZXQoY29tcG9uZW50LCBkYXRhVHlwZSl9KGJpYXNbcm93XSlgfTtgIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJycgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICR7YXBwbHlBY3RpdmF0aW9ufVxuICAgICAgICAke291dHB1dFZhcmlhYmxlLnNldEJ5SW5kaWNlcygndmVjMzx1MzI+KGNvb3JkcyknLCAndmFsdWUnKX1cbiAgICAgIH1cbiAgICB9XG4gICAgYDtcbiAgICAgIHJldHVybiBzb3VyY2U7XG4gICAgfTtcblxuZXhwb3J0IGNvbnN0IGNyZWF0ZU1hdG11bFByb2dyYW1JbmZvID1cbiAgICAoaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10sIGFjdGl2YXRpb25BdHRyaWJ1dGVzOiBJbnRlcm5hbEFjdGl2YXRpb25BdHRyaWJ1dGVzLCBvdXRwdXRTaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sXG4gICAgIHJlc2hhcGVkT3V0cHV0U2hhcGU/OiByZWFkb25seSBudW1iZXJbXSxcbiAgICAgaXNDaGFubmVsc0xhc3QgPSBmYWxzZSAvKiBvbmx5IHVzZWQgZm9yIGNvbnYyZEJ5TWF0TXVsKi8pOiBQcm9ncmFtSW5mbyA9PiB7XG4gICAgICBjb25zdCBhU2hhcGUgPSBpbnB1dHNbMF0uZGltcztcbiAgICAgIGNvbnN0IGJTaGFwZSA9IGlucHV0c1sxXS5kaW1zO1xuXG4gICAgICBjb25zdCBvdXRlckRpbXNBID0gYVNoYXBlLnNsaWNlKDAsIC0yKTtcbiAgICAgIGNvbnN0IG91dGVyRGltc0IgPSBiU2hhcGUuc2xpY2UoMCwgLTIpO1xuXG4gICAgICBjb25zdCBvdXRlckRpbXMgPSByZXNoYXBlZE91dHB1dFNoYXBlID8gcmVzaGFwZWRPdXRwdXRTaGFwZS5zbGljZSgwLCAtMikgOiBvdXRwdXRTaGFwZS5zbGljZSgwLCAtMik7XG4gICAgICBjb25zdCBlbmFibGVCYXRjaFVuaWZvcm1zID0gZW5hYmxlU2hhcGVzVW5pZm9ybXMob3V0ZXJEaW1zLmxlbmd0aCk7XG4gICAgICBjb25zdCBiYXRjaFNoYXBlT3JSYW5rID0gZW5hYmxlQmF0Y2hVbmlmb3JtcyA/IG91dGVyRGltcy5sZW5ndGggOiBvdXRlckRpbXM7XG4gICAgICBjb25zdCBiYXRjaERpbXMgPSBpbnRlcm5hbFZhcmlhYmxlKCdiYXRjaERpbXMnLCBpbnB1dHNbMF0uZGF0YVR5cGUsIGJhdGNoU2hhcGVPclJhbmssIDEpO1xuICAgICAgY29uc3QgYmF0Y2hTaXplID0gU2hhcGVVdGlsLnNpemUob3V0ZXJEaW1zKTtcblxuICAgICAgY29uc3QgZGltQU91dGVyID0gYVNoYXBlW2FTaGFwZS5sZW5ndGggLSAyXTtcbiAgICAgIGNvbnN0IGRpbUlubmVyID0gYVNoYXBlW2FTaGFwZS5sZW5ndGggLSAxXTtcbiAgICAgIGNvbnN0IGRpbUJPdXRlciA9IGJTaGFwZVtiU2hhcGUubGVuZ3RoIC0gMV07XG4gICAgICBjb25zdCBpc1ZlYzQgPSBkaW1Jbm5lciAlIDQgPT09IDAgJiYgZGltQk91dGVyICUgNCA9PT0gMDtcblxuICAgICAgLy8gVE9ETzogZmluZSB0dW5lIHNpemVcbiAgICAgIGNvbnN0IGVsZW1lbnRzUGVyVGhyZWFkID0gZGltQU91dGVyIDw9IDggPyBbNCwgMSwgMV0gOiBbNCwgNCwgMV07XG4gICAgICBjb25zdCB3b3JrZ3JvdXBTaXplOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl0gPSBbOCwgOCwgMV07XG4gICAgICBjb25zdCBkaXNwYXRjaCA9IFtcbiAgICAgICAgTWF0aC5jZWlsKGRpbUJPdXRlciAvIHdvcmtncm91cFNpemVbMF0gLyBlbGVtZW50c1BlclRocmVhZFswXSksXG4gICAgICAgIE1hdGguY2VpbChkaW1BT3V0ZXIgLyB3b3JrZ3JvdXBTaXplWzFdIC8gZWxlbWVudHNQZXJUaHJlYWRbMV0pLFxuICAgICAgICBNYXRoLmNlaWwoYmF0Y2hTaXplIC8gd29ya2dyb3VwU2l6ZVsyXSAvIGVsZW1lbnRzUGVyVGhyZWFkWzJdKVxuICAgICAgXTtcblxuICAgICAgY29uc3QgZGF0YVR5cGUgPSB0ZW5zb3JUeXBlVG9Xc2dsU3RvcmFnZVR5cGUoaW5wdXRzWzBdLmRhdGFUeXBlKTtcbiAgICAgIGNvbnN0IGNvbXBvbmVudHMgPSBpc1ZlYzQgPyA0IDogMTtcblxuICAgICAgY29uc3QgYVNoYXBlVGVtcCA9IFsuLi5vdXRlckRpbXNBLCBkaW1BT3V0ZXIsIGRpbUlubmVyIC8gY29tcG9uZW50c107XG4gICAgICBjb25zdCBlbmFibGVBU2hhcGVzVW5pZm9ybXMgPSBlbmFibGVTaGFwZXNVbmlmb3JtcyhhU2hhcGVUZW1wLmxlbmd0aCk7XG4gICAgICBjb25zdCBhU2hhcGVPclJhbmsgPSBlbmFibGVBU2hhcGVzVW5pZm9ybXMgPyBhU2hhcGVUZW1wLmxlbmd0aCA6IGFTaGFwZVRlbXA7XG5cbiAgICAgIGNvbnN0IGJTaGFwZVRlbXAgPSBbLi4ub3V0ZXJEaW1zQiwgZGltSW5uZXIsIGRpbUJPdXRlciAvIGNvbXBvbmVudHNdO1xuICAgICAgY29uc3QgZW5hYmxlQlNoYXBlc1VuaWZvcm1zID0gZW5hYmxlU2hhcGVzVW5pZm9ybXMoYlNoYXBlVGVtcC5sZW5ndGgpO1xuICAgICAgY29uc3QgYlNoYXBlT3JSYW5rID0gZW5hYmxlQlNoYXBlc1VuaWZvcm1zID8gYlNoYXBlVGVtcC5sZW5ndGggOiBiU2hhcGVUZW1wO1xuXG4gICAgICBjb25zdCBvdXRwdXRTaGFwZVRlbXAgPSBbYmF0Y2hTaXplLCBkaW1BT3V0ZXIsIGRpbUJPdXRlciAvIGNvbXBvbmVudHNdO1xuXG4gICAgICBjb25zdCBBID0gaW5wdXRWYXJpYWJsZSgnYScsIGlucHV0c1swXS5kYXRhVHlwZSwgYVNoYXBlT3JSYW5rLCBjb21wb25lbnRzKTtcbiAgICAgIGNvbnN0IEIgPSBpbnB1dFZhcmlhYmxlKCdiJywgaW5wdXRzWzFdLmRhdGFUeXBlLCBiU2hhcGVPclJhbmssIGNvbXBvbmVudHMpO1xuICAgICAgY29uc3Qgb3V0cHV0ID0gb3V0cHV0VmFyaWFibGUoJ3Jlc3VsdCcsIGlucHV0c1swXS5kYXRhVHlwZSwgb3V0cHV0U2hhcGVUZW1wLmxlbmd0aCwgY29tcG9uZW50cyk7XG4gICAgICBjb25zdCBpbnB1dFZhcmlhYmxlcyA9IFtBLCBCXTtcbiAgICAgIGNvbnN0IHByb2dyYW1Vbmlmb3JtczogUHJvZ3JhbVVuaWZvcm1bXSA9XG4gICAgICAgICAgW3t0eXBlOiAnaW50MzInLCBkYXRhOiBkaW1BT3V0ZXJ9LCB7dHlwZTogJ2ludDMyJywgZGF0YTogZGltQk91dGVyfSwge3R5cGU6ICdpbnQzMicsIGRhdGE6IGRpbUlubmVyfV07XG4gICAgICBpZiAoZW5hYmxlQmF0Y2hVbmlmb3Jtcykge1xuICAgICAgICBwcm9ncmFtVW5pZm9ybXMucHVzaCguLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhvdXRlckRpbXMpKTtcbiAgICAgIH1cbiAgICAgIGlmIChlbmFibGVBU2hhcGVzVW5pZm9ybXMpIHtcbiAgICAgICAgcHJvZ3JhbVVuaWZvcm1zLnB1c2goLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMoYVNoYXBlVGVtcCkpO1xuICAgICAgfVxuICAgICAgaWYgKGVuYWJsZUJTaGFwZXNVbmlmb3Jtcykge1xuICAgICAgICBwcm9ncmFtVW5pZm9ybXMucHVzaCguLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhiU2hhcGVUZW1wKSk7XG4gICAgICB9XG4gICAgICBjb25zdCBpbnB1dERlcGVuZGVuY2llczogUHJvZ3JhbUlucHV0VGVuc29ySW5mb0RlcGVuZGVuY3lbXSA9IFtdO1xuICAgICAgaW5wdXREZXBlbmRlbmNpZXMucHVzaChlbmFibGVBU2hhcGVzVW5pZm9ybXMgPyAncmFuaycgOiAnZGltcycpO1xuICAgICAgaW5wdXREZXBlbmRlbmNpZXMucHVzaChlbmFibGVCU2hhcGVzVW5pZm9ybXMgPyAncmFuaycgOiAnZGltcycpO1xuXG4gICAgICBjb25zdCBoYXNCaWFzID0gaW5wdXRzLmxlbmd0aCA+IDI7XG4gICAgICBjb25zdCB7YWN0aXZhdGlvbkZ1bmN0aW9uLCBhcHBseUFjdGl2YXRpb259ID0gZ2V0QWN0aXZhdGlvblNuaXBwZXQoYWN0aXZhdGlvbkF0dHJpYnV0ZXMsIG91dHB1dC50eXBlLnZhbHVlKTtcbiAgICAgIGNvbnN0IGRlY2xhcmVGdW5jdGlvbnMgPSBtYXRNdWxSZWFkV3JpdGVGblNvdXJjZShcbiAgICAgICAgICBjb21wb25lbnRzLCBoYXNCaWFzLCBhcHBseUFjdGl2YXRpb24sIFtiYXRjaERpbXMsIEEsIEIsIG91dHB1dF0sIFtvdXRlckRpbXNBLCBvdXRlckRpbXNCLCBvdXRlckRpbXNdLFxuICAgICAgICAgIGlzQ2hhbm5lbHNMYXN0KTtcbiAgICAgIGlmIChoYXNCaWFzKSB7XG4gICAgICAgIGNvbnN0IGJpYXNDb21wb25lbnRzID0gaXNDaGFubmVsc0xhc3QgPyBjb21wb25lbnRzIDogMTtcbiAgICAgICAgaW5wdXRWYXJpYWJsZXMucHVzaChpbnB1dFZhcmlhYmxlKCdiaWFzJywgaW5wdXRzWzJdLmRhdGFUeXBlLCBpbnB1dHNbMl0uZGltcy5sZW5ndGgsIGJpYXNDb21wb25lbnRzKSk7XG4gICAgICAgIHByb2dyYW1Vbmlmb3Jtcy5wdXNoKC4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKGlucHV0c1syXS5kaW1zKSk7XG5cbiAgICAgICAgaW5wdXREZXBlbmRlbmNpZXMucHVzaCgncmFuaycpO1xuICAgICAgfVxuICAgICAgcHJvZ3JhbVVuaWZvcm1zLnB1c2goLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMob3V0cHV0U2hhcGVUZW1wKSk7XG5cbiAgICAgIGNvbnN0IGdldFNoYWRlclNvdXJjZSA9IChzaGFkZXJIZWxwZXI6IFNoYWRlckhlbHBlcikgPT4gYFxuICAke1xuICAgICAgICAgIHNoYWRlckhlbHBlci5yZWdpc3RlclVuaWZvcm0oJ2RpbUFPdXRlcicsICdpMzInKVxuICAgICAgICAgICAgICAucmVnaXN0ZXJVbmlmb3JtKCdkaW1CT3V0ZXInLCAnaTMyJylcbiAgICAgICAgICAgICAgLnJlZ2lzdGVyVW5pZm9ybSgnZGltSW5uZXInLCAnaTMyJylcbiAgICAgICAgICAgICAgLnJlZ2lzdGVySW50ZXJuYWxWYXJpYWJsZXMoYmF0Y2hEaW1zKVxuICAgICAgICAgICAgICAuZGVjbGFyZVZhcmlhYmxlcyguLi5pbnB1dFZhcmlhYmxlcywgb3V0cHV0KX1cbiAgJHthY3RpdmF0aW9uRnVuY3Rpb259XG4gICR7ZGVjbGFyZUZ1bmN0aW9uc31cbiAgJHtcbiAgICAgICAgICBpc1ZlYzQgPyBtYWtlTWF0TXVsUGFja2VkVmVjNFNvdXJjZShlbGVtZW50c1BlclRocmVhZCwgd29ya2dyb3VwU2l6ZSwgZGF0YVR5cGUsIGJhdGNoRGltcykgOlxuICAgICAgICAgICAgICAgICAgIG1ha2VNYXRNdWxQYWNrZWRTb3VyY2UoZWxlbWVudHNQZXJUaHJlYWQsIHdvcmtncm91cFNpemUsIGRhdGFUeXBlLCBiYXRjaERpbXMpfVxuICAgICAgICAgICAgICAgICAgIGA7XG4gICAgICAvLyBUT0RPOiB0dXJuIGNsaXBNYXggYW5kIGNsaXBNaW4gdG8gdW5pZm9ybXMuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBuYW1lOiAnTWF0TXVsJyxcbiAgICAgICAgc2hhZGVyQ2FjaGU6IHtcbiAgICAgICAgICBoaW50OiBhY3RpdmF0aW9uQXR0cmlidXRlcy5hY3RpdmF0aW9uQ2FjaGVLZXkgKyBgJHtlbGVtZW50c1BlclRocmVhZH1gICtcbiAgICAgICAgICAgICAgYCR7aXNWZWM0fWAgK1xuICAgICAgICAgICAgICBgJHtpc0NoYW5uZWxzTGFzdH1gLFxuICAgICAgICAgIGlucHV0RGVwZW5kZW5jaWVzXG4gICAgICAgIH0sXG4gICAgICAgIGdldFJ1bkRhdGE6ICgpID0+ICh7XG4gICAgICAgICAgb3V0cHV0czogW3tkaW1zOiBvdXRwdXRTaGFwZSwgZGF0YVR5cGU6IGlucHV0c1swXS5kYXRhVHlwZX1dLFxuICAgICAgICAgIGRpc3BhdGNoR3JvdXA6IHt4OiBkaXNwYXRjaFswXSwgeTogZGlzcGF0Y2hbMV0sIHo6IGRpc3BhdGNoWzJdfSxcbiAgICAgICAgICBwcm9ncmFtVW5pZm9ybXNcbiAgICAgICAgfSksXG4gICAgICAgIGdldFNoYWRlclNvdXJjZSxcbiAgICAgIH07XG4gICAgfTtcbiIsICIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5cbi8vIHNhbXBsZWQgZnJvbSBbQHRlbnNvcmZsb3cvdGZqc10gdGZqcy1iYWNrZW5kLXdlYmdwdS9zcmMvY29udjJkX21tX3dlYmdwdS50c1xuLy9cbi8vIG1vZGlmaWVkIHRvIGZpdCB0aGUgbmVlZHMgb2YgdGhlIHByb2plY3RcblxuaW1wb3J0IHtMT0dfREVCVUd9IGZyb20gJy4uLy4uLy4uL2xvZyc7XG5pbXBvcnQge1RlbnNvclZpZXd9IGZyb20gJy4uLy4uLy4uL3RlbnNvci12aWV3JztcbmltcG9ydCB7UHJvZ3JhbUluZm8sIFByb2dyYW1Vbmlmb3JtfSBmcm9tICcuLi8uLi90eXBlcyc7XG5pbXBvcnQge2NyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzLCBpbnB1dFZhcmlhYmxlLCBvdXRwdXRWYXJpYWJsZSwgU2hhZGVySGVscGVyLCB0ZW5zb3JUeXBlVG9Xc2dsU3RvcmFnZVR5cGV9IGZyb20gJy4uL2NvbW1vbic7XG5pbXBvcnQge0NvbnZBdHRyaWJ1dGVzfSBmcm9tICcuLi9jb252JztcbmltcG9ydCB7Z2V0QWN0aXZhdGlvblNuaXBwZXR9IGZyb20gJy4uL2Z1c2UtdXRpbHMnO1xuXG5pbXBvcnQge2JpYXNTbmlwcGV0LCB0eXBlU25pcHBldH0gZnJvbSAnLi9hY3RpdmF0aW9uX3V0aWwnO1xuaW1wb3J0IHt1dGlsRnVuY3Rpb25zfSBmcm9tICcuL2NvbnZfdXRpbCc7XG5pbXBvcnQge21ha2VNYXRNdWxQYWNrZWRTb3VyY2UsIG1ha2VNYXRNdWxQYWNrZWRWZWM0U291cmNlfSBmcm9tICcuL21hdG11bF9wYWNrZWRfd2ViZ3B1JztcblxuY29uc3QgY29udjJkQ29tbW9uU25pcHBldCA9XG4gICAgKGlzQ2hhbm5lbHNMYXN0OiBib29sZWFuLCBmaXRBT3V0ZXI6IGJvb2xlYW4sIGZpdEJPdXRlcjogYm9vbGVhbiwgZml0SW5uZXI6IGJvb2xlYW4sIGFkZEJpYXMgPSBmYWxzZSxcbiAgICAgYXR0cmlidXRlczogQ29udkF0dHJpYnV0ZXMsIGlubmVyRWxlbWVudFNpemVYID0gNCwgaW5uZXJFbGVtZW50U2l6ZVcgPSA0LCBpbm5lckVsZW1lbnRTaXplID0gNCxcbiAgICAgZGF0YVR5cGUgPSAnZjMyJyk6IHN0cmluZyA9PiB7XG4gICAgICBjb25zdCBnZXRYU25pcHBldCA9IChpbm5lckVsZW1lbnRTaXplOiBudW1iZXIpID0+IHtcbiAgICAgICAgc3dpdGNoIChpbm5lckVsZW1lbnRTaXplKSB7XG4gICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgcmV0dXJuICdyZXNEYXRhID0geFt4SW5kZXhdOyc7XG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgcmV0dXJuIGByZXNEYXRhID0gdmVjMzwke2RhdGFUeXBlfT4oeFt4SW5kZXhdLCB4W3hJbmRleCArIDFdLCB4W3hJbmRleCArIDJdKTtgO1xuICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgIHJldHVybiAncmVzRGF0YSA9IHhbeEluZGV4IC8gNF07JztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbm5lckVsZW1lbnRTaXplICR7aW5uZXJFbGVtZW50U2l6ZX0gaXMgbm90IHN1cHBvcnRlZC5gKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGNvbnN0IGdldFdTbmlwcGV0ID0gKGlubmVyRWxlbWVudFNpemU6IG51bWJlcikgPT4ge1xuICAgICAgICBzd2l0Y2ggKGlubmVyRWxlbWVudFNpemUpIHtcbiAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICByZXR1cm4gJ3JldHVybiB3W3JvdyAqIGkzMih1bmlmb3Jtcy53X3NoYXBlWzNdKSArIGNvbEluXTsnO1xuICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgIHJldHVybiAncmV0dXJuIHdbcm93ICogaTMyKHVuaWZvcm1zLndfc2hhcGVbM10pIC8gNCArIGNvbEluXTsnO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGlubmVyRWxlbWVudFNpemUgJHtpbm5lckVsZW1lbnRTaXplfSBpcyBub3Qgc3VwcG9ydGVkLmApO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY29uc3QgY29vcmRBU25pcHBldCA9IGlzQ2hhbm5lbHNMYXN0ID8gYFxuICAgIGxldCBjb29yZCA9IHZlYzQ8aTMyPihiYXRjaCwgeFJvdywgeENvbCwgeENoKTtcbiAgICBgIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBcbiAgICBsZXQgY29vcmQgPSB2ZWM0PGkzMj4oYmF0Y2gsIHhDaCwgeFJvdywgeENvbCk7XG4gICAgYDtcblxuICAgICAgY29uc3QgY29vcmRSZXNTbmlwcGV0ID0gaXNDaGFubmVsc0xhc3QgPyBgXG4gICAgbGV0IGNvb3JkcyA9IHZlYzQ8aTMyPihcbiAgICAgIGJhdGNoLFxuICAgICAgcm93IC8gb3V0V2lkdGgsXG4gICAgICByb3cgJSBvdXRXaWR0aCxcbiAgICAgIGNvbCk7XG4gICAgYCA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBcbiAgICBsZXQgY29vcmRzID0gdmVjNDxpMzI+KFxuICAgICAgYmF0Y2gsXG4gICAgICByb3csXG4gICAgICBjb2wgLyBvdXRXaWR0aCxcbiAgICAgIGNvbCAlIG91dFdpZHRoKTtcbiAgICBgO1xuXG4gICAgICBjb25zdCB4SGVpZ2h0ID0gaXNDaGFubmVsc0xhc3QgPyAnaTMyKHVuaWZvcm1zLnhfc2hhcGVbMV0pJyA6ICdpMzIodW5pZm9ybXMueF9zaGFwZVsyXSknO1xuICAgICAgY29uc3QgeFdpZHRoID0gaXNDaGFubmVsc0xhc3QgPyAnaTMyKHVuaWZvcm1zLnhfc2hhcGVbMl0pJyA6ICdpMzIodW5pZm9ybXMueF9zaGFwZVszXSknO1xuICAgICAgY29uc3Qgcm93ID0gaXNDaGFubmVsc0xhc3QgPyAncm93JyA6ICdjb2wnO1xuICAgICAgY29uc3QgY29sID0gaXNDaGFubmVsc0xhc3QgPyAnY29sJyA6ICdyb3cnO1xuICAgICAgY29uc3QgcmVhZFhTbmlwcGV0ID0gYFxuICAgIGxldCBpbkNoYW5uZWxzID0gaTMyKHVuaWZvcm1zLndfc2hhcGVbMl0pO1xuICAgIGxldCBvdXRXaWR0aCA9ICR7aXNDaGFubmVsc0xhc3QgPyAnaTMyKHVuaWZvcm1zLnJlc3VsdF9zaGFwZVsyXSknIDogJ2kzMih1bmlmb3Jtcy5yZXN1bHRfc2hhcGVbM10pJ307XG4gICAgbGV0IG91dFJvdyA9ICR7cm93fSAvIG91dFdpZHRoO1xuICAgIGxldCBvdXRDb2wgPSAke3Jvd30gJSBvdXRXaWR0aDtcblxuICAgIGxldCBXUm93ID0gJHtjb2x9IC8gKGZpbHRlckRpbXNbMV0gKiBpbkNoYW5uZWxzKTtcbiAgICBsZXQgV0NvbCA9ICR7Y29sfSAvIGluQ2hhbm5lbHMgJSBmaWx0ZXJEaW1zWzFdO1xuICAgIGxldCB4Um93ID0gb3V0Um93ICogc3RyaWRlWzBdICsgZGlsYXRpb25bMF0gKiBXUm93IC0gcGFkWzBdO1xuICAgIGxldCB4Q29sID0gb3V0Q29sICogc3RyaWRlWzFdICsgZGlsYXRpb25bMV0gKiBXQ29sIC0gcGFkWzFdO1xuICAgIGxldCB4Q2ggPSAke2NvbH0gJSBpbkNoYW5uZWxzO1xuICAgIHZhciByZXNEYXRhID0gJHt0eXBlU25pcHBldChpbm5lckVsZW1lbnRTaXplWCwgZGF0YVR5cGUpfSgwLjApO1xuICAgIC8vIFRoZSBib3VuZHMgY2hlY2tpbmcgaXMgYWx3YXlzIG5lZWRlZCBzaW5jZSB3ZSB1c2UgaXQgdG8gcGFkIHplcm8gZm9yXG4gICAgLy8gdGhlICdzYW1lJyBwYWRkaW5nIHR5cGUuXG4gICAgaWYgKHhSb3cgPj0gMCAmJiB4Um93IDwgJHt4SGVpZ2h0fSAmJiB4Q29sID49IDAgJiYgeENvbCA8ICR7eFdpZHRofSkge1xuICAgICAgJHtjb29yZEFTbmlwcGV0fVxuICAgICAgbGV0IHhJbmRleCA9IGdldEluZGV4RnJvbUNvb3JkczREKGNvb3JkLCB2ZWM0PGkzMj4odW5pZm9ybXMueF9zaGFwZSkpO1xuICAgICAgJHtnZXRYU25pcHBldChpbm5lckVsZW1lbnRTaXplWCl9XG4gICAgfVxuICAgIHJldHVybiByZXNEYXRhO2A7XG5cbiAgICAgIGNvbnN0IHNhbXBsZVggPSBpc0NoYW5uZWxzTGFzdCA/IChmaXRBT3V0ZXIgJiYgZml0SW5uZXIgPyBgXG4gICAgbGV0IGNvbCA9IGNvbEluICogJHtpbm5lckVsZW1lbnRTaXplWH07XG4gICAgJHtyZWFkWFNuaXBwZXR9YCA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYFxuICAgIGxldCBjb2wgPSBjb2xJbiAqICR7aW5uZXJFbGVtZW50U2l6ZVh9O1xuICAgIGlmIChyb3cgPCB1bmlmb3Jtcy5kaW1BT3V0ZXIgJiYgY29sIDwgdW5pZm9ybXMuZGltSW5uZXIpIHtcbiAgICAgICR7cmVhZFhTbmlwcGV0fVxuICAgIH1cbiAgICByZXR1cm4gJHt0eXBlU25pcHBldChpbm5lckVsZW1lbnRTaXplWCwgZGF0YVR5cGUpfSgwLjApO2ApIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChmaXRJbm5lciAmJiBmaXRCT3V0ZXIgPyBgXG4gICAgbGV0IGNvbCA9IGNvbEluICogJHtpbm5lckVsZW1lbnRTaXplWH07XG4gICAgJHtyZWFkWFNuaXBwZXR9YCA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYFxuICAgIGxldCBjb2wgPSBjb2xJbiAqICR7aW5uZXJFbGVtZW50U2l6ZVh9O1xuICAgIGlmIChyb3cgPCB1bmlmb3Jtcy5kaW1Jbm5lciAmJiBjb2wgPCB1bmlmb3Jtcy5kaW1CT3V0ZXIpIHtcbiAgICAgICR7cmVhZFhTbmlwcGV0fVxuICAgIH1cbiAgICByZXR1cm4gJHt0eXBlU25pcHBldChpbm5lckVsZW1lbnRTaXplWCwgZGF0YVR5cGUpfSgwLjApO2ApO1xuXG4gICAgICBjb25zdCBzYW1wbGVXID0gYCR7Z2V0V1NuaXBwZXQoaW5uZXJFbGVtZW50U2l6ZVcpfWA7XG5cbiAgICAgIGNvbnN0IHJlc1R5cGUgPSB0eXBlU25pcHBldChpbm5lckVsZW1lbnRTaXplLCBkYXRhVHlwZSk7XG4gICAgICBjb25zdCBhVHlwZSA9XG4gICAgICAgICAgaXNDaGFubmVsc0xhc3QgPyB0eXBlU25pcHBldChpbm5lckVsZW1lbnRTaXplWCwgZGF0YVR5cGUpIDogdHlwZVNuaXBwZXQoaW5uZXJFbGVtZW50U2l6ZVcsIGRhdGFUeXBlKTtcbiAgICAgIGNvbnN0IGJUeXBlID1cbiAgICAgICAgICBpc0NoYW5uZWxzTGFzdCA/IHR5cGVTbmlwcGV0KGlubmVyRWxlbWVudFNpemVXLCBkYXRhVHlwZSkgOiB0eXBlU25pcHBldChpbm5lckVsZW1lbnRTaXplWCwgZGF0YVR5cGUpO1xuICAgICAgY29uc3Qge2FjdGl2YXRpb25GdW5jdGlvbiwgYXBwbHlBY3RpdmF0aW9ufSA9IGdldEFjdGl2YXRpb25TbmlwcGV0KGF0dHJpYnV0ZXMsIHJlc1R5cGUpO1xuICAgICAgY29uc3QgdXNlckNvZGUgPSBgXG4gICAgJHthY3RpdmF0aW9uRnVuY3Rpb259XG4gICAgZm4gbW1fcmVhZEEoYmF0Y2g6IGkzMiwgcm93IDogaTMyLCBjb2xJbiA6IGkzMikgLT4gJHthVHlwZX0ge1xuICAgICAgJHtpc0NoYW5uZWxzTGFzdCA/IHNhbXBsZVggOiBzYW1wbGVXfVxuICAgIH1cblxuICAgIGZuIG1tX3JlYWRCKGJhdGNoOiBpMzIsIHJvdyA6IGkzMiwgY29sSW4gOiBpMzIpIC0+ICR7YlR5cGV9IHtcbiAgICAgICR7aXNDaGFubmVsc0xhc3QgPyBzYW1wbGVXIDogc2FtcGxlWH1cbiAgICB9XG5cbiAgICBmbiBtbV93cml0ZShiYXRjaDogaTMyLCByb3cgOiBpMzIsIGNvbEluIDogaTMyLCB2YWx1ZUluIDogJHtyZXNUeXBlfSkge1xuICAgICAgbGV0IGNvbCA9IGNvbEluICogJHtpbm5lckVsZW1lbnRTaXplfTtcbiAgICAgIGlmIChyb3cgPCB1bmlmb3Jtcy5kaW1BT3V0ZXIgJiYgY29sIDwgdW5pZm9ybXMuZGltQk91dGVyKVxuICAgICAge1xuICAgICAgdmFyIHZhbHVlID0gdmFsdWVJbjtcbiAgICAgIGxldCBvdXRXaWR0aCA9ICR7aXNDaGFubmVsc0xhc3QgPyAnaTMyKHVuaWZvcm1zLnJlc3VsdF9zaGFwZVsyXSknIDogJ2kzMih1bmlmb3Jtcy5yZXN1bHRfc2hhcGVbM10pJ307XG4gICAgICAke2Nvb3JkUmVzU25pcHBldH1cbiAgICAgICR7Ymlhc1NuaXBwZXQoYWRkQmlhcyl9XG4gICAgICAke2FwcGx5QWN0aXZhdGlvbn1cbiAgICAgIHNldE91dHB1dEF0Q29vcmRzKGNvb3Jkc1swXSwgY29vcmRzWzFdLCBjb29yZHNbMl0sIGNvb3Jkc1szXSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH1gO1xuICAgICAgcmV0dXJuIHVzZXJDb2RlO1xuICAgIH07XG5cbmV4cG9ydCBjb25zdCBjcmVhdGVDb252MkRNYXRNdWxQcm9ncmFtSW5mbyA9XG4gICAgKGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdLCBhdHRyaWJ1dGVzOiBDb252QXR0cmlidXRlcywgb3V0cHV0U2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLCBkaW1BT3V0ZXI6IG51bWJlcixcbiAgICAgZGltQk91dGVyOiBudW1iZXIsIGRpbUlubmVyOiBudW1iZXIsIGhhc0JpYXM6IGJvb2xlYW4sIHNlcXVlbnRpYWxBY2Nlc3NCeVRocmVhZHM6IGJvb2xlYW4pOiBQcm9ncmFtSW5mbyA9PiB7XG4gICAgICBjb25zdCBpc0NoYW5uZWxzTGFzdCA9IGF0dHJpYnV0ZXMuZm9ybWF0ID09PSAnTkhXQyc7XG4gICAgICBjb25zdCBpbkNoYW5uZWxzID0gaXNDaGFubmVsc0xhc3QgPyBpbnB1dHNbMF0uZGltc1szXSA6IGlucHV0c1swXS5kaW1zWzFdO1xuICAgICAgY29uc3QgYmF0Y2hTaXplID0gb3V0cHV0U2hhcGVbMF07XG4gICAgICBjb25zdCBvdXRXaWR0aCA9IGlzQ2hhbm5lbHNMYXN0ID8gb3V0cHV0U2hhcGVbMl0gOiBvdXRwdXRTaGFwZVszXTtcbiAgICAgIGNvbnN0IG91dEhlaWdodCA9IGlzQ2hhbm5lbHNMYXN0ID8gb3V0cHV0U2hhcGVbMV0gOiBvdXRwdXRTaGFwZVsyXTtcbiAgICAgIGNvbnN0IG91dENoYW5uZWxzID0gaXNDaGFubmVsc0xhc3QgPyBvdXRwdXRTaGFwZVszXSA6IG91dHB1dFNoYXBlWzFdO1xuICAgICAgLy8gVE9ETzogZW5hYmxlIHZlYzQgZm9yIE5DSFdcbiAgICAgIGNvbnN0IGlzVmVjNCA9IGlzQ2hhbm5lbHNMYXN0ICYmIChpbkNoYW5uZWxzICUgNCA9PT0gMCB8fCBpbkNoYW5uZWxzICUgMyA9PT0gMCkgJiYgb3V0Q2hhbm5lbHMgJSA0ID09PSAwO1xuXG4gICAgICAvLyBUT0RPOiBmaW5lIHR1bmUgc2l6ZVxuICAgICAgY29uc3QgZGlzcGF0Y2hYID0gaXNDaGFubmVsc0xhc3QgPyBvdXRDaGFubmVscyA6IG91dFdpZHRoICogb3V0SGVpZ2h0O1xuICAgICAgY29uc3QgZGlzcGF0Y2hZID0gaXNDaGFubmVsc0xhc3QgPyBvdXRXaWR0aCAqIG91dEhlaWdodCA6IG91dENoYW5uZWxzO1xuICAgICAgY29uc3Qgd29ya0dyb3VwU2l6ZTogW251bWJlciwgbnVtYmVyLCBudW1iZXJdID0gWzgsIDgsIDFdO1xuICAgICAgY29uc3QgZWxlbWVudHNQZXJUaHJlYWQgPSBkaW1BT3V0ZXIgPD0gOCA/IFs0LCAxLCAxXSA6IFs0LCA0LCAxXTtcbiAgICAgIGNvbnN0IGRpc3BhdGNoID0gW1xuICAgICAgICBNYXRoLmNlaWwoZGlzcGF0Y2hYIC8gd29ya0dyb3VwU2l6ZVswXSAvIGVsZW1lbnRzUGVyVGhyZWFkWzBdKSxcbiAgICAgICAgTWF0aC5jZWlsKGRpc3BhdGNoWSAvIHdvcmtHcm91cFNpemVbMV0gLyBlbGVtZW50c1BlclRocmVhZFsxXSksXG4gICAgICAgIE1hdGguY2VpbChiYXRjaFNpemUgLyB3b3JrR3JvdXBTaXplWzJdIC8gZWxlbWVudHNQZXJUaHJlYWRbMl0pXG4gICAgICBdO1xuXG4gICAgICBMT0dfREVCVUcoJ3ZlcmJvc2UnLCAoKSA9PiBgW2NvbnYyZF9tbV93ZWJncHVdIGRpc3BhdGNoID0gJHtkaXNwYXRjaH1gKTtcblxuICAgICAgY29uc3QgaW5uZXJFbGVtZW50U2l6ZSA9IGlzVmVjNCA/IChpc0NoYW5uZWxzTGFzdCAmJiBpbkNoYW5uZWxzICUgNCAhPT0gMCA/IDMgOiA0KSA6IDE7XG5cbiAgICAgIGNvbnN0IHRpbGVBT3V0ZXIgPSB3b3JrR3JvdXBTaXplWzFdICogZWxlbWVudHNQZXJUaHJlYWRbMV07XG4gICAgICBjb25zdCB0aWxlQk91dGVyID0gd29ya0dyb3VwU2l6ZVswXSAqIGVsZW1lbnRzUGVyVGhyZWFkWzBdO1xuICAgICAgY29uc3QgdGlsZUlubmVyID0gTWF0aC5tYXgod29ya0dyb3VwU2l6ZVswXSAqIGlubmVyRWxlbWVudFNpemUsIHdvcmtHcm91cFNpemVbMV0pO1xuXG4gICAgICBjb25zdCBmaXRBT3V0ZXIgPSBkaW1BT3V0ZXIgJSB0aWxlQU91dGVyID09PSAwO1xuICAgICAgY29uc3QgZml0Qk91dGVyID0gZGltQk91dGVyICUgdGlsZUJPdXRlciA9PT0gMDtcbiAgICAgIGNvbnN0IGZpdElubmVyID0gZGltSW5uZXIgJSB0aWxlSW5uZXIgPT09IDA7XG5cbiAgICAgIGNvbnN0IGVsZW1lbnRzU2l6ZSA9IGlzVmVjNCA/IFtpbm5lckVsZW1lbnRTaXplLCA0LCA0XSA6IFsxLCAxLCAxXTtcbiAgICAgIGNvbnN0IHQgPSB0ZW5zb3JUeXBlVG9Xc2dsU3RvcmFnZVR5cGUoaW5wdXRzWzBdLmRhdGFUeXBlKTtcblxuICAgICAgLy8gVE9ETzogc3VwcG9ydCBjb21wb25lbnQgMiwgMy5cbiAgICAgIGNvbnN0IGNvbXBvbmVudHMgPSBpc1ZlYzQgPyA0IDogMTtcbiAgICAgIGNvbnN0IHByb2dyYW1Vbmlmb3JtczogUHJvZ3JhbVVuaWZvcm1bXSA9XG4gICAgICAgICAgW3t0eXBlOiAnaW50MzInLCBkYXRhOiBkaW1BT3V0ZXJ9LCB7dHlwZTogJ2ludDMyJywgZGF0YTogZGltQk91dGVyfSwge3R5cGU6ICdpbnQzMicsIGRhdGE6IGRpbUlubmVyfV07XG4gICAgICBjb25zdCB4ID1cbiAgICAgICAgICBpbnB1dFZhcmlhYmxlKCd4JywgaW5wdXRzWzBdLmRhdGFUeXBlLCBpbnB1dHNbMF0uZGltcy5sZW5ndGgsIGlubmVyRWxlbWVudFNpemUgPT09IDMgPyAxIDogaW5uZXJFbGVtZW50U2l6ZSk7XG4gICAgICBjb25zdCB3ID0gaW5wdXRWYXJpYWJsZSgndycsIGlucHV0c1sxXS5kYXRhVHlwZSwgaW5wdXRzWzFdLmRpbXMubGVuZ3RoLCBjb21wb25lbnRzKTtcbiAgICAgIGNvbnN0IGlucHV0VmFyaWFibGVzID0gW3gsIHddO1xuXG4gICAgICBwcm9ncmFtVW5pZm9ybXMucHVzaCguLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhpbnB1dHNbMF0uZGltcykpO1xuICAgICAgcHJvZ3JhbVVuaWZvcm1zLnB1c2goLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMoaW5wdXRzWzFdLmRpbXMpKTtcblxuICAgICAgbGV0IGRlY2xhcmVGdW5jdGlvbnMgPSBgXG4gICAgICBmbiBzZXRPdXRwdXRBdEluZGV4KGZsYXRJbmRleCA6IGkzMiwgdmFsdWUgOiAke2lzVmVjNCA/IGB2ZWM0PCR7dH0+YCA6IHR9KSB7XG4gICAgICAgIHJlc3VsdFtmbGF0SW5kZXhdID0gJHtpc1ZlYzQgPyBgdmVjNDwke3R9PmAgOiB0fSh2YWx1ZSk7XG4gICAgICB9XG4gICAgICBmbiBzZXRPdXRwdXRBdENvb3JkcyhkMCA6IGkzMiwgZDEgOiBpMzIsIGQyIDogaTMyLCBkMyA6IGkzMiwgdmFsdWUgOiAke2lzVmVjNCA/IGB2ZWM0PCR7dH0+YCA6IHR9KSB7XG4gICAgICAgIGxldCBmbGF0SW5kZXggPSBnZXRPdXRwdXRJbmRleEZyb21Db29yZHModmVjNDxpMzI+KGQwLCBkMSwgZDIsIGQzKSk7XG4gICAgICAgIHNldE91dHB1dEF0SW5kZXgoZmxhdEluZGV4ICR7aXNWZWM0ID8gJy8gNCcgOiAnJ30sIHZhbHVlKTtcbiAgICAgIH1gO1xuICAgICAgaWYgKGhhc0JpYXMpIHtcbiAgICAgICAgY29uc3QgYmlhcyA9IGlucHV0VmFyaWFibGUoJ2JpYXMnLCBpbnB1dHNbMl0uZGF0YVR5cGUsIGlucHV0c1syXS5kaW1zLmxlbmd0aCwgY29tcG9uZW50cyk7XG4gICAgICAgIGlucHV0VmFyaWFibGVzLnB1c2goYmlhcyk7XG5cbiAgICAgICAgcHJvZ3JhbVVuaWZvcm1zLnB1c2goLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMoaW5wdXRzWzJdLmRpbXMpKTtcblxuICAgICAgICBkZWNsYXJlRnVuY3Rpb25zICs9IGBcbiAgICAgICAgZm4gZ2V0Qmlhc0J5T3V0cHV0Q29vcmRzKGNvb3JkcyA6IHZlYzQ8aTMyPikgLT4gJHtpc1ZlYzQgPyBgdmVjNDwke3R9PmAgOiB0fSB7XG4gICAgICAgICAgcmV0dXJuIGJpYXNbY29vcmRzLiR7aXNDaGFubmVsc0xhc3QgPyAndycgOiAneSd9JHtpc1ZlYzQgPyAnLyA0JyA6ICcnfV07XG4gICAgICAgIH1gO1xuICAgICAgfVxuICAgICAgY29uc3Qgb3V0cHV0ID0gb3V0cHV0VmFyaWFibGUoJ3Jlc3VsdCcsIGlucHV0c1swXS5kYXRhVHlwZSwgb3V0cHV0U2hhcGUubGVuZ3RoLCBjb21wb25lbnRzKTtcbiAgICAgIHByb2dyYW1Vbmlmb3Jtcy5wdXNoKC4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKG91dHB1dFNoYXBlKSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBuYW1lOiAnQ29udjJETWF0TXVsJyxcbiAgICAgICAgc2hhZGVyQ2FjaGU6IHtoaW50OiBhdHRyaWJ1dGVzLmNhY2hlS2V5fSxcbiAgICAgICAgZ2V0UnVuRGF0YTogKCkgPT4gKHtcbiAgICAgICAgICBvdXRwdXRzOiBbe2RpbXM6IG91dHB1dFNoYXBlLCBkYXRhVHlwZTogaW5wdXRzWzBdLmRhdGFUeXBlfV0sXG4gICAgICAgICAgZGlzcGF0Y2hHcm91cDoge3g6IGRpc3BhdGNoWzBdLCB5OiBkaXNwYXRjaFsxXSwgejogZGlzcGF0Y2hbMl19LFxuICAgICAgICAgIHByb2dyYW1Vbmlmb3JtcyxcbiAgICAgICAgfSksXG4gICAgICAgIGdldFNoYWRlclNvdXJjZTogKHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyKSA9PiBgXG4gICAgICAgICR7dXRpbEZ1bmN0aW9ucygndW5pZm9ybXMucmVzdWx0X3N0cmlkZXMnKX1cbiAgICAgICAgLy9zdHJ1Y3QgVW5pZm9ybXMgeyB4U2hhcGUgOiB2ZWM0PGkzMj4sIHdTaGFwZSA6IHZlYzQ8aTMyPiwgb3V0U2hhcGUgOiB2ZWM0PGkzMj4sXG4gICAgICAgIC8vICBvdXRTaGFwZVN0cmlkZXM6IHZlYzM8aTMyPiwgZmlsdGVyRGltcyA6IHZlYzI8aTMyPiwgcGFkIDogdmVjMjxpMzI+LCBzdHJpZGUgOiB2ZWMyPGkzMj4sXG4gICAgICAgIC8vICBkaWxhdGlvbiA6IHZlYzI8aTMyPiwgZGltQU91dGVyIDogaTMyLCBkaW1CT3V0ZXIgOiBpMzIsIGRpbUlubmVyIDogaTMyIH07XG4gICAgICAgICR7XG4gICAgICAgICAgICBzaGFkZXJIZWxwZXIucmVnaXN0ZXJVbmlmb3JtKCdkaW1BT3V0ZXInLCAnaTMyJylcbiAgICAgICAgICAgICAgICAucmVnaXN0ZXJVbmlmb3JtKCdkaW1CT3V0ZXInLCAnaTMyJylcbiAgICAgICAgICAgICAgICAucmVnaXN0ZXJVbmlmb3JtKCdkaW1Jbm5lcicsICdpMzInKVxuICAgICAgICAgICAgICAgIC5kZWNsYXJlVmFyaWFibGVzKC4uLmlucHV0VmFyaWFibGVzLCBvdXRwdXQpfVxuICAgICAgICBjb25zdCBmaWx0ZXJEaW1zIDogdmVjMjxpMzI+ID0gdmVjMjxpMzI+KCR7YXR0cmlidXRlcy5rZXJuZWxTaGFwZVswXX0sICR7YXR0cmlidXRlcy5rZXJuZWxTaGFwZVsxXX0pO1xuICAgICAgICBjb25zdCBwYWQgOiB2ZWMyPGkzMj4gPSB2ZWMyPGkzMj4oJHthdHRyaWJ1dGVzLnBhZHNbMF19LCAke2F0dHJpYnV0ZXMucGFkc1sxXX0pO1xuICAgICAgICBjb25zdCBzdHJpZGUgOiB2ZWMyPGkzMj4gPSB2ZWMyPGkzMj4oJHthdHRyaWJ1dGVzLnN0cmlkZXNbMF19LCAke2F0dHJpYnV0ZXMuc3RyaWRlc1sxXX0pO1xuICAgICAgICBjb25zdCBkaWxhdGlvbiA6IHZlYzI8aTMyPiA9IHZlYzI8aTMyPigke2F0dHJpYnV0ZXMuZGlsYXRpb25zWzBdfSwgJHthdHRyaWJ1dGVzLmRpbGF0aW9uc1sxXX0pO1xuICAgICAgICAke2RlY2xhcmVGdW5jdGlvbnN9XG4gICAgICAgICR7XG4gICAgICAgICAgICBjb252MmRDb21tb25TbmlwcGV0KFxuICAgICAgICAgICAgICAgIGlzQ2hhbm5lbHNMYXN0LCBmaXRBT3V0ZXIsIGZpdEJPdXRlciwgZml0SW5uZXIsIGhhc0JpYXMsIGF0dHJpYnV0ZXMsIGVsZW1lbnRzU2l6ZVswXSwgZWxlbWVudHNTaXplWzFdLFxuICAgICAgICAgICAgICAgIGVsZW1lbnRzU2l6ZVsyXSwgdCl9XG4gICAgICAgICAgICAke1xuICAgICAgICAgICAgaXNWZWM0ID9cbiAgICAgICAgICAgICAgICBtYWtlTWF0TXVsUGFja2VkVmVjNFNvdXJjZShlbGVtZW50c1BlclRocmVhZCwgd29ya0dyb3VwU2l6ZSwgdCwgdW5kZWZpbmVkLCAhaXNDaGFubmVsc0xhc3QsIHRpbGVJbm5lcikgOlxuICAgICAgICAgICAgICAgIG1ha2VNYXRNdWxQYWNrZWRTb3VyY2UoXG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzUGVyVGhyZWFkLCB3b3JrR3JvdXBTaXplLCB0LCB1bmRlZmluZWQsICFpc0NoYW5uZWxzTGFzdCwgdGlsZUlubmVyLCBmYWxzZSwgdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICBzZXF1ZW50aWFsQWNjZXNzQnlUaHJlYWRzKX1gXG4gICAgICB9O1xuICAgIH07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7VGVuc29yVmlld30gZnJvbSAnLi4vLi4vdGVuc29yLXZpZXcnO1xuaW1wb3J0IHtTaGFwZVV0aWx9IGZyb20gJy4uLy4uL3V0aWwnO1xuaW1wb3J0IHtQcm9ncmFtSW5mbywgUHJvZ3JhbVVuaWZvcm19IGZyb20gJy4uL3R5cGVzJztcblxuaW1wb3J0IHtjcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcywgZ2V0TWF4Q29tcG9uZW50cywgaW5wdXRWYXJpYWJsZSwgb3V0cHV0VmFyaWFibGUsIFNoYWRlckhlbHBlcn0gZnJvbSAnLi9jb21tb24nO1xuaW1wb3J0IHtjYWxjdWxhdGVPdXRwdXRTaGFwZSwgQ29udkF0dHJpYnV0ZXN9IGZyb20gJy4vY29udic7XG5pbXBvcnQge2dldEFjdGl2YXRpb25TbmlwcGV0fSBmcm9tICcuL2Z1c2UtdXRpbHMnO1xuXG4vKipcbiAqIG5haXZlIGdyb3VwZWQgY29udiBpbXBsZW1lbnRhdGlvbiwgc3VwcG9ydHMgMWQvMmQgY29udlxuICogQHBhcmFtIHNxdWVlemVPdXRwdXRTaGFwZUZ1bmN0aW9uIC0gYW4gb3B0aW9uYWwgZnVuY3Rpb24gdG8gc3F1ZWV6ZSB0aGUgb3V0cHV0IHNoYXBlLCBvbmx5IHVzZWQgaW4gY29udjFkXG4gKi9cbmV4cG9ydCBjb25zdCBjcmVhdGVHcm91cGVkQ29udlByb2dyYW1JbmZvID1cbiAgICAoaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10sIGF0dHJpYnV0ZXM6IENvbnZBdHRyaWJ1dGVzLFxuICAgICBzcXVlZXplT3V0cHV0U2hhcGVGdW5jdGlvbj86IChzaGFwZTogcmVhZG9ubHkgbnVtYmVyW10pID0+IG51bWJlcltdKTogUHJvZ3JhbUluZm8gPT4ge1xuICAgICAgY29uc3QgaGFzQmlhcyA9IGlucHV0cy5sZW5ndGggPiAyO1xuICAgICAgY29uc3QgcHJvY2Vzc0JpYXMgPSBoYXNCaWFzID8gJ3ZhbHVlICs9IGJbb3V0cHV0X2NoYW5uZWxdOycgOiAnJztcbiAgICAgIGNvbnN0IHhTaGFwZSA9IGlucHV0c1swXS5kaW1zO1xuICAgICAgY29uc3Qgd1NoYXBlID0gaW5wdXRzWzFdLmRpbXM7XG4gICAgICBjb25zdCBvdXRwdXRDaGFubmVsc1Blckdyb3VwID0gd1NoYXBlWzBdIC8gYXR0cmlidXRlcy5ncm91cDtcblxuICAgICAgY29uc3QgaXNDaGFubmVsTGFzdCA9IGF0dHJpYnV0ZXMuZm9ybWF0ID09PSAnTkhXQyc7XG4gICAgICBjb25zdCBvdXRwdXRTaGFwZSA9IGNhbGN1bGF0ZU91dHB1dFNoYXBlKFxuICAgICAgICAgIHhTaGFwZSwgd1NoYXBlLCBhdHRyaWJ1dGVzLmRpbGF0aW9ucywgYXR0cmlidXRlcy5wYWRzLCBhdHRyaWJ1dGVzLnN0cmlkZXMsIGlzQ2hhbm5lbExhc3QpO1xuICAgICAgY29uc3Qgb3V0cHV0U2l6ZSA9IFNoYXBlVXRpbC5zaXplKG91dHB1dFNoYXBlKTtcblxuICAgICAgY29uc3Qgb3V0cHV0ID0gb3V0cHV0VmFyaWFibGUoJ291dHB1dCcsIGlucHV0c1swXS5kYXRhVHlwZSwgb3V0cHV0U2hhcGUpO1xuICAgICAgY29uc3Qge2FjdGl2YXRpb25GdW5jdGlvbiwgYXBwbHlBY3RpdmF0aW9ufSA9IGdldEFjdGl2YXRpb25TbmlwcGV0KGF0dHJpYnV0ZXMsIG91dHB1dC50eXBlLnZhbHVlKTtcbiAgICAgIGNvbnN0IHggPSBpbnB1dFZhcmlhYmxlKCd4JywgaW5wdXRzWzBdLmRhdGFUeXBlLCB4U2hhcGUpO1xuICAgICAgY29uc3QgdyA9IGlucHV0VmFyaWFibGUoJ3cnLCBpbnB1dHNbMV0uZGF0YVR5cGUsIHdTaGFwZSk7XG4gICAgICBjb25zdCBpbnB1dFZhcnMgPSBbeCwgd107XG4gICAgICBpZiAoaGFzQmlhcykge1xuICAgICAgICBpbnB1dFZhcnMucHVzaChpbnB1dFZhcmlhYmxlKCdiJywgaW5wdXRzWzJdLmRhdGFUeXBlLCBpbnB1dHNbMl0uZGltcykpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBnZXRTaGFkZXJTb3VyY2UgPSAoc2hhZGVySGVscGVyOiBTaGFkZXJIZWxwZXIpID0+IGBcbiAgY29uc3Qgc3RyaWRlczogdmVjMjx1MzI+ID0gdmVjMigke2F0dHJpYnV0ZXMuc3RyaWRlc1swXX11LCAke2F0dHJpYnV0ZXMuc3RyaWRlc1sxXX11KTtcbiAgY29uc3QgcGFkczogdmVjMjx1MzI+ID0gdmVjMigke2F0dHJpYnV0ZXMucGFkc1swXX11LCAke2F0dHJpYnV0ZXMucGFkc1sxXX11KTtcblxuICAke3NoYWRlckhlbHBlci5kZWNsYXJlVmFyaWFibGVzKC4uLmlucHV0VmFycywgb3V0cHV0KX1cblxuICAke2FjdGl2YXRpb25GdW5jdGlvbn1cblxuICAke3NoYWRlckhlbHBlci5tYWluU3RhcnQoKX1cbiAgICAke3NoYWRlckhlbHBlci5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKG91dHB1dFNpemUpfVxuXG4gICAgbGV0IG91dHB1dEluZGljZXMgPSAke291dHB1dC5vZmZzZXRUb0luZGljZXMoJ2dsb2JhbF9pZHgnKX07XG4gICAgbGV0IGJhdGNoOiB1MzIgPSBvdXRwdXRJbmRpY2VzWzBdO1xuICAgIGxldCBvdXRwdXRfY2hhbm5lbDogdTMyID0gb3V0cHV0SW5kaWNlc1ske2lzQ2hhbm5lbExhc3QgPyAzIDogMX1dO1xuICAgIGxldCB4UkNDb3JuZXI6IHZlYzI8dTMyPiA9IHZlYzI8dTMyPihvdXRwdXRJbmRpY2VzWyR7aXNDaGFubmVsTGFzdCA/IDEgOiAyfV0sIG91dHB1dEluZGljZXNbJHtcbiAgICAgICAgICBpc0NoYW5uZWxMYXN0ID8gMiA6IDN9XSkgKiBzdHJpZGVzIC0gcGFkcztcbiAgICBsZXQgZ3JvdXBfaWQ6IHUzMiA9IG91dHB1dF9jaGFubmVsIC8gJHtvdXRwdXRDaGFubmVsc1Blckdyb3VwfXU7XG5cbiAgICB2YXIgdmFsdWU6ICR7b3V0cHV0LnR5cGUudmFsdWV9ID0gJHtvdXRwdXQudHlwZS52YWx1ZX0oMCk7XG4gICAgZm9yICh2YXIgd0luQ2hhbm5lbDogdTMyID0gMHU7IHdJbkNoYW5uZWwgPCAke3dTaGFwZVsxXX11OyB3SW5DaGFubmVsKyspIHtcbiAgICAgIGxldCBpbnB1dF9jaGFubmVsID0gZ3JvdXBfaWQgKiAke3dTaGFwZVsxXX11ICsgd0luQ2hhbm5lbDtcbiAgICAgIGZvciAodmFyIHdIZWlnaHQ6IHUzMiA9IDB1OyB3SGVpZ2h0IDwgJHt3U2hhcGVbMl19dTsgd0hlaWdodCsrKSB7XG4gICAgICAgIGxldCB4SGVpZ2h0ID0geFJDQ29ybmVyLnggKyB3SGVpZ2h0ICogJHthdHRyaWJ1dGVzLmRpbGF0aW9uc1swXX11O1xuXG4gICAgICAgIGlmICh4SGVpZ2h0IDwgMHUgfHwgeEhlaWdodCA+PSAke3hTaGFwZVtpc0NoYW5uZWxMYXN0ID8gMSA6IDJdfXUpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIHdXaWR0aDogdTMyID0gMHU7IHdXaWR0aCA8ICR7d1NoYXBlWzNdfXU7IHdXaWR0aCsrKSB7XG4gICAgICAgICAgbGV0IHhXaWR0aCA9IHhSQ0Nvcm5lci55ICsgd1dpZHRoICogJHthdHRyaWJ1dGVzLmRpbGF0aW9uc1sxXX11O1xuICAgICAgICAgIGlmICh4V2lkdGggPCAwdSB8fCB4V2lkdGggPj0gJHt4U2hhcGVbaXNDaGFubmVsTGFzdCA/IDIgOiAzXX11KSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBsZXQgeFZhbCA9ICR7XG4gICAgICAgICAgaXNDaGFubmVsTGFzdCA/IHguZ2V0KCdiYXRjaCcsICd4SGVpZ2h0JywgJ3hXaWR0aCcsICdpbnB1dF9jaGFubmVsJykgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICB4LmdldCgnYmF0Y2gnLCAnaW5wdXRfY2hhbm5lbCcsICd4SGVpZ2h0JywgJ3hXaWR0aCcpfTtcbiAgICAgICAgICBsZXQgd1ZhbCA9ICR7dy5nZXQoJ291dHB1dF9jaGFubmVsJywgJ3dJbkNoYW5uZWwnLCAnd0hlaWdodCcsICd3V2lkdGgnKX07XG4gICAgICAgICAgdmFsdWUgKz0geFZhbCp3VmFsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgICR7cHJvY2Vzc0JpYXN9XG4gICAgJHthcHBseUFjdGl2YXRpb259XG4gICAgJHtvdXRwdXQuc2V0QnlPZmZzZXQoJ2dsb2JhbF9pZHgnLCAndmFsdWUnKX1cbiAgfWA7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBuYW1lOiAnR3JvdXBlZENvbnYnLFxuICAgICAgICBzaGFkZXJDYWNoZToge2hpbnQ6IGF0dHJpYnV0ZXMuY2FjaGVLZXl9LFxuICAgICAgICBnZXRSdW5EYXRhOiAoKSA9PiAoe1xuICAgICAgICAgIG91dHB1dHM6IFt7XG4gICAgICAgICAgICBkaW1zOiBzcXVlZXplT3V0cHV0U2hhcGVGdW5jdGlvbiA/IHNxdWVlemVPdXRwdXRTaGFwZUZ1bmN0aW9uKG91dHB1dFNoYXBlKSA6IG91dHB1dFNoYXBlLFxuICAgICAgICAgICAgZGF0YVR5cGU6IGlucHV0c1swXS5kYXRhVHlwZVxuICAgICAgICAgIH1dLFxuICAgICAgICAgIGRpc3BhdGNoR3JvdXA6IHt4OiBNYXRoLmNlaWwob3V0cHV0U2l6ZSAvIDY0IC8qIHdvcmtncm91cCBzaXplICovKX0sXG4gICAgICAgIH0pLFxuICAgICAgICBnZXRTaGFkZXJTb3VyY2UsXG4gICAgICB9O1xuICAgIH07XG5cbmV4cG9ydCBjb25zdCBjcmVhdGVHcm91cGVkQ29udlZlY3Rvcml6ZVByb2dyYW1JbmZvID1cbiAgICAoaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10sIGF0dHJpYnV0ZXM6IENvbnZBdHRyaWJ1dGVzLCBvdXRwdXRTaGFwZTogcmVhZG9ubHkgbnVtYmVyW10pOiBQcm9ncmFtSW5mbyA9PiB7XG4gICAgICBjb25zdCBoYXNCaWFzID0gaW5wdXRzLmxlbmd0aCA+IDI7XG4gICAgICBjb25zdCBjb21wb25lbnRzID0gZ2V0TWF4Q29tcG9uZW50cyhvdXRwdXRTaGFwZVszXSk7XG4gICAgICBjb25zdCBvdXRwdXROdW1iZXIgPSBnZXRNYXhDb21wb25lbnRzKG91dHB1dFNoYXBlWzJdKTtcbiAgICAgIGNvbnN0IG91dHB1dFNpemUgPSBTaGFwZVV0aWwuc2l6ZShvdXRwdXRTaGFwZSkgLyBjb21wb25lbnRzIC8gb3V0cHV0TnVtYmVyO1xuICAgICAgY29uc3QgeFNoYXBlID0gW2lucHV0c1swXS5kaW1zWzBdLCBpbnB1dHNbMF0uZGltc1sxXSwgaW5wdXRzWzBdLmRpbXNbMl0sIGlucHV0c1swXS5kaW1zWzNdIC8gY29tcG9uZW50c107XG4gICAgICBjb25zdCB3U2hhcGUgPSBbaW5wdXRzWzFdLmRpbXNbMF0sIGlucHV0c1sxXS5kaW1zWzFdLCBpbnB1dHNbMV0uZGltc1syXSwgaW5wdXRzWzFdLmRpbXNbM10gLyBjb21wb25lbnRzXTtcbiAgICAgIGNvbnN0IG91dHB1dFNoYXBlSW5TaGFkZXIgPSBbb3V0cHV0U2hhcGVbMF0sIG91dHB1dFNoYXBlWzFdLCBvdXRwdXRTaGFwZVsyXSwgb3V0cHV0U2hhcGVbM10gLyBjb21wb25lbnRzXTtcblxuICAgICAgY29uc3QgcHJvZ3JhbVVuaWZvcm1zOiBQcm9ncmFtVW5pZm9ybVtdID0gW1xuICAgICAgICB7dHlwZTogJ3VpbnQzMicsIGRhdGE6IG91dHB1dFNpemV9LCB7dHlwZTogJ2ludDMyJywgZGF0YTogYXR0cmlidXRlcy5zdHJpZGVzfSxcbiAgICAgICAge3R5cGU6ICdpbnQzMicsIGRhdGE6IGF0dHJpYnV0ZXMucGFkc30sIC4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKHhTaGFwZSksXG4gICAgICAgIC4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKHdTaGFwZSksIC4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKG91dHB1dFNoYXBlSW5TaGFkZXIpXG4gICAgICBdO1xuICAgICAgY29uc3QgeE51bWJlciA9IChvdXRwdXROdW1iZXIgLSAxKSAqIGF0dHJpYnV0ZXMuc3RyaWRlc1sxXSArIHdTaGFwZVsxXTtcbiAgICAgIGNvbnN0IGdldFNoYWRlclNvdXJjZSA9IChzaGFkZXJIZWxwZXI6IFNoYWRlckhlbHBlcikgPT4ge1xuICAgICAgICBjb25zdCBvdXRwdXQgPSBvdXRwdXRWYXJpYWJsZSgnb3V0cHV0JywgaW5wdXRzWzBdLmRhdGFUeXBlLCBvdXRwdXRTaGFwZUluU2hhZGVyLmxlbmd0aCwgY29tcG9uZW50cyk7XG4gICAgICAgIGNvbnN0IHthY3RpdmF0aW9uRnVuY3Rpb24sIGFwcGx5QWN0aXZhdGlvbn0gPSBnZXRBY3RpdmF0aW9uU25pcHBldChhdHRyaWJ1dGVzLCBvdXRwdXQudHlwZS52YWx1ZSk7XG4gICAgICAgIGNvbnN0IHggPSBpbnB1dFZhcmlhYmxlKCd4JywgaW5wdXRzWzBdLmRhdGFUeXBlLCB4U2hhcGUubGVuZ3RoLCBjb21wb25lbnRzKTtcbiAgICAgICAgY29uc3QgdyA9IGlucHV0VmFyaWFibGUoJ3cnLCBpbnB1dHNbMV0uZGF0YVR5cGUsIHdTaGFwZS5sZW5ndGgsIGNvbXBvbmVudHMpO1xuICAgICAgICBjb25zdCBpbnB1dFZhcnMgPSBbeCwgd107XG4gICAgICAgIGlmIChoYXNCaWFzKSB7XG4gICAgICAgICAgaW5wdXRWYXJzLnB1c2goaW5wdXRWYXJpYWJsZSgnYicsIGlucHV0c1syXS5kYXRhVHlwZSwgaW5wdXRzWzJdLmRpbXMsIGNvbXBvbmVudHMpKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcm9jZXNzQmlhcyA9IGhhc0JpYXMgPyAndmFsdWUgKz0gYltvdXRwdXRfY2hhbm5lbF07JyA6ICcnO1xuXG4gICAgICAgIHJldHVybiBgXG4gICR7XG4gICAgICAgICAgICBzaGFkZXJIZWxwZXIucmVnaXN0ZXJVbmlmb3JtKCdvdXRwdXRfc2l6ZScsICd1MzInKVxuICAgICAgICAgICAgICAgIC5yZWdpc3RlclVuaWZvcm0oJ3N0cmlkZXMnLCAnaTMyJywgMilcbiAgICAgICAgICAgICAgICAucmVnaXN0ZXJVbmlmb3JtKCdwYWRzJywgJ2kzMicsIDIpXG4gICAgICAgICAgICAgICAgLmRlY2xhcmVWYXJpYWJsZXMoLi4uaW5wdXRWYXJzLCBvdXRwdXQpfVxuICAke2FjdGl2YXRpb25GdW5jdGlvbn1cbiAgJHtzaGFkZXJIZWxwZXIubWFpblN0YXJ0KCl9XG4gICAgJHtzaGFkZXJIZWxwZXIuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcygndW5pZm9ybXMub3V0cHV0X3NpemUnKX1cbiAgICBsZXQgd2lkdGgwID0gdW5pZm9ybXMub3V0cHV0X3NoYXBlWzNdO1xuICAgIGxldCBvdXRwdXRfY2hhbm5lbCA9IGdsb2JhbF9pZHggJSB3aWR0aDA7XG4gICAgdmFyIGluZGV4MSA9IGdsb2JhbF9pZHggLyB3aWR0aDA7XG4gICAgbGV0IHdpZHRoMSA9IHVuaWZvcm1zLm91dHB1dF9zaGFwZVsyXSAvICR7b3V0cHV0TnVtYmVyfXU7XG4gICAgbGV0IGNvbCA9IChpbmRleDEgJSB3aWR0aDEpICogJHtvdXRwdXROdW1iZXJ9dTtcbiAgICBpbmRleDEgPSBpbmRleDEgLyB3aWR0aDE7XG4gICAgbGV0IHJvdyA9IGluZGV4MSAlIHVuaWZvcm1zLm91dHB1dF9zaGFwZVsxXTtcbiAgICBsZXQgYmF0Y2ggPSBpbmRleDEgLyB1bmlmb3Jtcy5vdXRwdXRfc2hhcGVbMV07XG5cbiAgICBsZXQgeF9jb3JuZXIgPSB2ZWMyPGkzMj4oaTMyKHJvdyksIGkzMihjb2wpKSAqIHVuaWZvcm1zLnN0cmlkZXMgLSB1bmlmb3Jtcy5wYWRzO1xuXG4gICAgdmFyIHhfdmFsczogYXJyYXk8JHt4LnR5cGUudmFsdWV9LCAke3hOdW1iZXJ9PjtcbiAgICB2YXIgdmFsdWVzOiBhcnJheTwke291dHB1dC50eXBlLnZhbHVlfSwgJHtvdXRwdXROdW1iZXJ9PjtcbiAgICBsZXQgaW5wdXRfY2hhbm5lbCA9IG91dHB1dF9jaGFubmVsO1xuICAgIC8vIFVzZSBjb25zdGFudCBpbnN0ZWFkIG9mIHVuaWZvcm0gY2FuIGdpdmUgYmV0dGVyIHBlcmZvcm1hbmNlIGZvciB3J3MgaGVpZ2h0L3dpZHRoLlxuICAgIGZvciAodmFyIHdfaGVpZ2h0OiB1MzIgPSAwdTsgd19oZWlnaHQgPCAke3dTaGFwZVswXX07IHdfaGVpZ2h0KyspIHtcbiAgICAgIGxldCB4X2hlaWdodCA9IHhfY29ybmVyLnggKyBpMzIod19oZWlnaHQpO1xuICAgICAgaWYgKHhfaGVpZ2h0ID49IDAgfHwgdTMyKHhfaGVpZ2h0KSA8IHVuaWZvcm1zLnhfc2hhcGVbMV0pIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAke3hOdW1iZXJ9OyBpKyspIHtcbiAgICAgICAgICBsZXQgeF93aWR0aCA9IHhfY29ybmVyLnkgKyBpO1xuICAgICAgICAgIGlmICh4X3dpZHRoID49IDAgJiYgdTMyKHhfd2lkdGgpIDwgdW5pZm9ybXMueF9zaGFwZVsyXSkge1xuICAgICAgICAgICAgeF92YWxzW2ldID0gJHt4LmdldCgnYmF0Y2gnLCAndTMyKHhfaGVpZ2h0KScsICd1MzIoeF93aWR0aCknLCAnaW5wdXRfY2hhbm5lbCcpfTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgeF92YWxzW2ldID0gJHt4LnR5cGUudmFsdWV9KDApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciB3X3dpZHRoOiB1MzIgPSAwdTsgd193aWR0aCA8ICR7d1NoYXBlWzFdfTsgd193aWR0aCsrKSB7XG4gICAgICAgICAgbGV0IHdfdmFsID0gJHt3LmdldCgnd19oZWlnaHQnLCAnd193aWR0aCcsICcwJywgJ291dHB1dF9jaGFubmVsJyl9O1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwdTsgaSA8ICR7b3V0cHV0TnVtYmVyfXU7IGkrKykge1xuICAgICAgICAgICAgdmFsdWVzW2ldID0gZm1hKHhfdmFsc1tpICogJHthdHRyaWJ1dGVzLnN0cmlkZXNbMV19dSArIHdfd2lkdGhdLCB3X3ZhbCwgdmFsdWVzW2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMHU7IGkgPCAke291dHB1dE51bWJlcn11OyBpKyspIHtcbiAgICAgIHZhciB2YWx1ZSA9IHZhbHVlc1tpXTtcbiAgICAgICR7cHJvY2Vzc0JpYXN9XG4gICAgICAke2FwcGx5QWN0aXZhdGlvbn1cbiAgICAgICR7b3V0cHV0LnNldCgnYmF0Y2gnLCAncm93JywgJ2NvbCArIGknLCAnb3V0cHV0X2NoYW5uZWwnLCAndmFsdWUnKX07XG4gICAgfVxuICB9YDtcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5hbWU6ICdHcm91cGVkQ29udi1WZWN0b3JpemUnLFxuICAgICAgICBzaGFkZXJDYWNoZToge1xuICAgICAgICAgIGhpbnQ6IGAke2F0dHJpYnV0ZXMuYWN0aXZhdGlvbkNhY2hlS2V5fTske2NvbXBvbmVudHN9OyR7b3V0cHV0TnVtYmVyfTske3hOdW1iZXJ9OyR7d1NoYXBlWzBdfTske3dTaGFwZVsxXX1gLFxuICAgICAgICAgIGlucHV0RGVwZW5kZW5jaWVzOiBoYXNCaWFzID8gWydyYW5rJywgJ3JhbmsnLCAndHlwZSddIDogWydyYW5rJywgJ3JhbmsnXVxuICAgICAgICB9LFxuICAgICAgICBnZXRSdW5EYXRhOiAoKSA9PiAoe1xuICAgICAgICAgIG91dHB1dHM6IFt7ZGltczogb3V0cHV0U2hhcGUsIGRhdGFUeXBlOiBpbnB1dHNbMF0uZGF0YVR5cGV9XSxcbiAgICAgICAgICBkaXNwYXRjaEdyb3VwOiB7eDogTWF0aC5jZWlsKG91dHB1dFNpemUgLyA2NCAvKiB3b3JrZ3JvdXAgc2l6ZSAqLyl9LFxuICAgICAgICAgIHByb2dyYW1Vbmlmb3Jtc1xuICAgICAgICB9KSxcbiAgICAgICAgZ2V0U2hhZGVyU291cmNlLFxuICAgICAgfTtcbiAgICB9O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge1RlbnNvclZpZXd9IGZyb20gJy4uLy4uL3RlbnNvci12aWV3JztcbmltcG9ydCB7QnJvYWRjYXN0VXRpbCwgU2hhcGVVdGlsfSBmcm9tICcuLi8uLi91dGlsJztcbmltcG9ydCB7Q29tcHV0ZUNvbnRleHQsIFByb2dyYW1JbmZvLCBQcm9ncmFtVW5pZm9ybX0gZnJvbSAnLi4vdHlwZXMnO1xuXG5pbXBvcnQge2NyZWF0ZU1hdG11bFByb2dyYW1JbmZvfSBmcm9tICcuLzNyZC1wYXJ0eS9tYXRtdWxfcGFja2VkX3dlYmdwdSc7XG5pbXBvcnQge2NyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzLCBnZXRCcm9hZGNhc3REaW1zLCBnZXRNYXhDb21wb25lbnRzLCBJbmRpY2VzSGVscGVyLCBpbnB1dFZhcmlhYmxlLCBpbnRlcm5hbFZhcmlhYmxlLCBvdXRwdXRWYXJpYWJsZSwgU2hhZGVySGVscGVyLH0gZnJvbSAnLi9jb21tb24nO1xuaW1wb3J0IHtnZXRBY3RpdmF0aW9uU25pcHBldCwgSW50ZXJuYWxBY3RpdmF0aW9uQXR0cmlidXRlc30gZnJvbSAnLi9mdXNlLXV0aWxzJztcblxuZXhwb3J0IGNvbnN0IGNyZWF0ZU5haXZlTWF0bXVsUHJvZ3JhbUluZm8gPVxuICAgIChpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSwgYWN0aXZhdGlvbkF0dHJpYnV0ZXM6IEludGVybmFsQWN0aXZhdGlvbkF0dHJpYnV0ZXMsIG91dHB1dFNoYXBlOiByZWFkb25seSBudW1iZXJbXSxcbiAgICAgcmVzaGFwZWRPdXRwdXRTaGFwZT86IHJlYWRvbmx5IG51bWJlcltdLFxuICAgICBpc0NoYW5uZWxzTGFzdCA9IGZhbHNlIC8qIG9ubHkgdXNlZCBmb3IgY29udjJkQnlNYXRNdWwqLyk6IFByb2dyYW1JbmZvID0+IHtcbiAgICAgIGNvbnN0IGFTaGFwZSA9IGlucHV0c1swXS5kaW1zO1xuICAgICAgY29uc3QgYlNoYXBlID0gaW5wdXRzWzFdLmRpbXM7XG5cbiAgICAgIGNvbnN0IE0gPSBhU2hhcGVbYVNoYXBlLmxlbmd0aCAtIDJdO1xuICAgICAgY29uc3QgTiA9IGJTaGFwZVtiU2hhcGUubGVuZ3RoIC0gMV07XG4gICAgICBjb25zdCBLID0gYVNoYXBlW2FTaGFwZS5sZW5ndGggLSAxXTtcbiAgICAgIGNvbnN0IGNvbXBvbmVudHMgPSBnZXRNYXhDb21wb25lbnRzKE4pO1xuICAgICAgY29uc3QgYUNvbXBvbmVudHMgPSBnZXRNYXhDb21wb25lbnRzKEspO1xuICAgICAgY29uc3Qgb3V0cHV0TnVtYmVyID0gZ2V0TWF4Q29tcG9uZW50cyhNKTtcbiAgICAgIGNvbnN0IG91dHB1dFNpemUgPSBTaGFwZVV0aWwuc2l6ZShvdXRwdXRTaGFwZSkgLyBjb21wb25lbnRzIC8gb3V0cHV0TnVtYmVyO1xuICAgICAgY29uc3QgaGFzQmlhcyA9IGlucHV0cy5sZW5ndGggPiAyO1xuICAgICAgY29uc3Qgb3V0ZXJEaW1zID0gcmVzaGFwZWRPdXRwdXRTaGFwZSA/IHJlc2hhcGVkT3V0cHV0U2hhcGUuc2xpY2UoMCwgLTIpIDogb3V0cHV0U2hhcGUuc2xpY2UoMCwgLTIpO1xuICAgICAgY29uc3QgYmF0Y2hTaXplID0gU2hhcGVVdGlsLnNpemUob3V0ZXJEaW1zKTtcbiAgICAgIGNvbnN0IG91dHB1dFNoYXBlSW5TaGFkZXIgPSBbYmF0Y2hTaXplLCBNLCBOXTtcbiAgICAgIGNvbnN0IHByb2dyYW1Vbmlmb3JtczogUHJvZ3JhbVVuaWZvcm1bXSA9IFtcbiAgICAgICAge3R5cGU6ICd1aW50MzInLCBkYXRhOiBvdXRwdXRTaXplfSwge3R5cGU6ICd1aW50MzInLCBkYXRhOiBNfSwge3R5cGU6ICd1aW50MzInLCBkYXRhOiBOfSxcbiAgICAgICAge3R5cGU6ICd1aW50MzInLCBkYXRhOiBLfSwgLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMob3V0ZXJEaW1zKSwgLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMoYVNoYXBlKSxcbiAgICAgICAgLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMoYlNoYXBlKVxuICAgICAgXTtcbiAgICAgIGlmIChoYXNCaWFzKSB7XG4gICAgICAgIHByb2dyYW1Vbmlmb3Jtcy5wdXNoKC4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKGlucHV0c1syXS5kaW1zKSk7XG4gICAgICB9XG4gICAgICBwcm9ncmFtVW5pZm9ybXMucHVzaCguLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhvdXRwdXRTaGFwZUluU2hhZGVyKSk7XG5cbiAgICAgIGNvbnN0IGdldFNoYWRlclNvdXJjZSA9IChzaGFkZXJIZWxwZXI6IFNoYWRlckhlbHBlcikgPT4ge1xuICAgICAgICBjb25zdCBiYXRjaERpbXMgPSBpbnRlcm5hbFZhcmlhYmxlKCdiYXRjaF9kaW1zJywgaW5wdXRzWzBdLmRhdGFUeXBlLCBvdXRlckRpbXMubGVuZ3RoKTtcbiAgICAgICAgY29uc3QgYSA9IGlucHV0VmFyaWFibGUoJ2EnLCBpbnB1dHNbMF0uZGF0YVR5cGUsIGFTaGFwZS5sZW5ndGgsIGFDb21wb25lbnRzKTtcbiAgICAgICAgY29uc3QgYiA9IGlucHV0VmFyaWFibGUoJ2InLCBpbnB1dHNbMV0uZGF0YVR5cGUsIGJTaGFwZS5sZW5ndGgsIGNvbXBvbmVudHMpO1xuICAgICAgICBjb25zdCBvdXRwdXQgPSBvdXRwdXRWYXJpYWJsZSgnb3V0cHV0JywgaW5wdXRzWzBdLmRhdGFUeXBlLCBvdXRwdXRTaGFwZUluU2hhZGVyLmxlbmd0aCwgY29tcG9uZW50cyk7XG4gICAgICAgIGNvbnN0IHthY3RpdmF0aW9uRnVuY3Rpb24sIGFwcGx5QWN0aXZhdGlvbn0gPSBnZXRBY3RpdmF0aW9uU25pcHBldChhY3RpdmF0aW9uQXR0cmlidXRlcywgb3V0cHV0LnR5cGUudmFsdWUpO1xuICAgICAgICBjb25zdCBpbnB1dFZhcmlhYmxlcyA9IFthLCBiXTtcbiAgICAgICAgbGV0IHByb2Nlc3NCaWFzID0gJyc7XG4gICAgICAgIGlmIChoYXNCaWFzKSB7XG4gICAgICAgICAgY29uc3QgYmlhc0NvbXBvbmVudHMgPSBpc0NoYW5uZWxzTGFzdCA/IGNvbXBvbmVudHMgOiAxO1xuICAgICAgICAgIGlucHV0VmFyaWFibGVzLnB1c2goaW5wdXRWYXJpYWJsZSgnYmlhcycsIGlucHV0c1syXS5kYXRhVHlwZSwgaW5wdXRzWzJdLmRpbXMubGVuZ3RoLCBiaWFzQ29tcG9uZW50cykpO1xuICAgICAgICAgIHByb2Nlc3NCaWFzID0gYCR7XG4gICAgICAgICAgICAgIGlzQ2hhbm5lbHNMYXN0ID8gYHZhbHVlICs9IGJpYXNbY29sIC8gJHtiaWFzQ29tcG9uZW50c31dO2AgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGB2YWx1ZSArPSAke291dHB1dC50eXBlLnZhbHVlfShiaWFzW3JvdyArIGldKTtgfWA7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBvdXRlckRpbXNBID0gYVNoYXBlLnNsaWNlKDAsIC0yKTtcbiAgICAgICAgY29uc3Qgb3V0ZXJEaW1zQiA9IGJTaGFwZS5zbGljZSgwLCAtMik7XG4gICAgICAgIGNvbnN0IGJyb2FkQ2FzdEFEaW1zID0gZ2V0QnJvYWRjYXN0RGltcyhvdXRlckRpbXNBLCBvdXRlckRpbXMpO1xuICAgICAgICBjb25zdCBicm9hZENhc3RCRGltcyA9IGdldEJyb2FkY2FzdERpbXMob3V0ZXJEaW1zQiwgb3V0ZXJEaW1zKTtcbiAgICAgICAgY29uc3QgZ2V0SW5kaWNlcyA9ICh2YXJpYWJsZTogSW5kaWNlc0hlbHBlciwgYnJvYWRDYXN0RGltczogbnVtYmVyW10pID0+IHtcbiAgICAgICAgICBjb25zdCByYW5rID0gdmFyaWFibGUucmFuaztcbiAgICAgICAgICBjb25zdCBuYW1lID0gdmFyaWFibGUubmFtZTtcbiAgICAgICAgICBpZiAocmFuayA9PT0gMikge1xuICAgICAgICAgICAgcmV0dXJuIGB2YXIgJHtuYW1lfV9pbmRpY2VzID0gJHt2YXJpYWJsZS50eXBlLmluZGljZXN9KDB1LCAwdSk7YDtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgYmF0Y2hSYW5rID0gYmF0Y2hEaW1zLnJhbms7XG4gICAgICAgICAgbGV0IHJlc1N0ciA9IGB2YXIgJHtuYW1lfV9pbmRpY2VzOiAke3ZhcmlhYmxlLnR5cGUuaW5kaWNlc307YDtcbiAgICAgICAgICBmb3IgKGxldCBpID0gcmFuayAtIDIgLSAxLCBqID0gYmF0Y2hSYW5rIC0gMTsgaSA+PSAwOyBpLS0sIGotLSkge1xuICAgICAgICAgICAgcmVzU3RyICs9IGBcXG4ke25hbWV9X2luZGljZXNbJHtpfV0gPSAke2JhdGNoUmFuayA+IDEgPyBgYmF0Y2hfaW5kaWNlc1ske2p9XWAgOiAnYmF0Y2hfaW5kaWNlcyd9O2A7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyb2FkQ2FzdERpbXMuZm9yRWFjaChpID0+IHtcbiAgICAgICAgICAgIHJlc1N0ciArPSBgXFxuJHtuYW1lfV9pbmRpY2VzWyR7aX1dID0gMDtgO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJlc1N0ciArPSBgJHtuYW1lfV9pbmRpY2VzWyR7cmFuayAtIDJ9XSA9IDB1O1xuICAgICAgICAgICAgICAgICAgICAgJHtuYW1lfV9pbmRpY2VzWyR7cmFuayAtIDF9XSA9IDB1O2A7XG4gICAgICAgICAgcmV0dXJuIHJlc1N0cjtcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBjYWxjUmVzdWx0ID0gKCk6IHN0cmluZyA9PiB7XG4gICAgICAgICAgbGV0IGNhbGNTdHIgPSBgdmFyIGFfZGF0YTogJHthLnR5cGUudmFsdWV9O2A7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhQ29tcG9uZW50czsgaSsrKSB7XG4gICAgICAgICAgICBjYWxjU3RyICs9IGBcbiAgICAgICAgICAgICAgbGV0IGJfZGF0YSR7aX0gPSBiWyhiX29mZnNldCArIChrICsgJHtpfSkgKiB1bmlmb3Jtcy5OICsgY29sKSAvICR7Y29tcG9uZW50c31dO2A7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3V0cHV0TnVtYmVyOyBpKyspIHtcbiAgICAgICAgICAgIGNhbGNTdHIgKz0gYGFfZGF0YSA9IGFbKGFfb2Zmc2V0ICsgKHJvdyArICR7aX0pICogdW5pZm9ybXMuSyArIGspIC8gJHthQ29tcG9uZW50c31dO2A7XG5cbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgYUNvbXBvbmVudHM7IGorKykge1xuICAgICAgICAgICAgICBjYWxjU3RyICs9IGBcbiAgICAgICAgICAgIHZhbHVlc1ske2l9XSA9IGZtYSgke2IudHlwZS52YWx1ZX0oYV9kYXRhJHthQ29tcG9uZW50cyA9PT0gMSA/ICcnIDogYFske2p9XWB9KSwgYl9kYXRhJHtqfSwgdmFsdWVzWyR7XG4gICAgICAgICAgICAgICAgICBpfV0pO1xcbmA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBjYWxjU3RyO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBgXG4gICR7XG4gICAgICAgICAgICBzaGFkZXJIZWxwZXIucmVnaXN0ZXJVbmlmb3JtKCdvdXRwdXRTaXplJywgJ3UzMicpXG4gICAgICAgICAgICAgICAgLnJlZ2lzdGVyVW5pZm9ybSgnTScsICd1MzInKVxuICAgICAgICAgICAgICAgIC5yZWdpc3RlclVuaWZvcm0oJ04nLCAndTMyJylcbiAgICAgICAgICAgICAgICAucmVnaXN0ZXJVbmlmb3JtKCdLJywgJ3UzMicpXG4gICAgICAgICAgICAgICAgLnJlZ2lzdGVySW50ZXJuYWxWYXJpYWJsZXMoYmF0Y2hEaW1zKVxuICAgICAgICAgICAgICAgIC5kZWNsYXJlVmFyaWFibGVzKC4uLmlucHV0VmFyaWFibGVzLCBvdXRwdXQpfVxuICAke2FjdGl2YXRpb25GdW5jdGlvbn1cbiAgJHtzaGFkZXJIZWxwZXIubWFpblN0YXJ0KCl9XG4gICAgJHtzaGFkZXJIZWxwZXIuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcygndW5pZm9ybXMub3V0cHV0U2l6ZScpfVxuICAgIGxldCBjb2wgPSAoZ2xvYmFsX2lkeCAlICh1bmlmb3Jtcy5OIC8gJHtjb21wb25lbnRzfSkpICogJHtjb21wb25lbnRzfTtcbiAgICB2YXIgaW5kZXgxID0gZ2xvYmFsX2lkeCAvICh1bmlmb3Jtcy5OIC8gJHtjb21wb25lbnRzfSk7XG4gICAgbGV0IHN0cmlkZTEgPSB1bmlmb3Jtcy5NIC8gJHtvdXRwdXROdW1iZXJ9O1xuICAgIGxldCByb3cgPSAoaW5kZXgxICUgc3RyaWRlMSkgKiAke291dHB1dE51bWJlcn07XG4gICAgbGV0IGJhdGNoID0gaW5kZXgxIC8gc3RyaWRlMTtcblxuICAgICR7b3V0cHV0U2hhcGUubGVuZ3RoID09PSAyID8gJycgOiBgbGV0IGJhdGNoX2luZGljZXMgPSAke2JhdGNoRGltcy5vZmZzZXRUb0luZGljZXMoJ2JhdGNoJyl9O2B9XG4gICAgJHtnZXRJbmRpY2VzKGEsIGJyb2FkQ2FzdEFEaW1zKX1cbiAgICBsZXQgYV9vZmZzZXQgPSAke2EuaW5kaWNlc1RvT2Zmc2V0KCdhX2luZGljZXMnKX07XG4gICAgJHtnZXRJbmRpY2VzKGIsIGJyb2FkQ2FzdEJEaW1zKX1cbiAgICBsZXQgYl9vZmZzZXQgPSAke2IuaW5kaWNlc1RvT2Zmc2V0KCdiX2luZGljZXMnKX07XG4gICAgdmFyIHZhbHVlczogYXJyYXk8JHtvdXRwdXQudHlwZS52YWx1ZX0sICR7b3V0cHV0TnVtYmVyfT47XG4gICAgZm9yICh2YXIgazogdTMyID0gMHU7IGsgPCB1bmlmb3Jtcy5LOyBrID0gayArICR7YUNvbXBvbmVudHN9KSB7XG4gICAgICAke2NhbGNSZXN1bHQoKX1cbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDB1OyBpIDwgJHtvdXRwdXROdW1iZXJ9dTsgaSsrKSB7XG4gICAgICB2YXIgdmFsdWUgPSB2YWx1ZXNbaV07XG4gICAgICAke3Byb2Nlc3NCaWFzfVxuICAgICAgJHthcHBseUFjdGl2YXRpb259XG4gICAgICBsZXQgY3VyX2luZGljZXMgPSAke291dHB1dC50eXBlLmluZGljZXN9KGJhdGNoLCByb3cgKyBpLCBjb2wpO1xuICAgICAgbGV0IG9mZnNldCA9ICR7b3V0cHV0LmluZGljZXNUb09mZnNldCgnY3VyX2luZGljZXMnKX07XG4gICAgICAke291dHB1dC5zZXRCeU9mZnNldChgb2Zmc2V0IC8gJHtjb21wb25lbnRzfWAsICd2YWx1ZScpfTtcbiAgICB9XG4gIH1cbiAgYDtcbiAgICAgIH07XG4gICAgICByZXR1cm4ge1xuICAgICAgICBuYW1lOiAnTWF0TXVsTmFpdmUnLFxuICAgICAgICBzaGFkZXJDYWNoZToge1xuICAgICAgICAgIGhpbnQ6IGAke2FjdGl2YXRpb25BdHRyaWJ1dGVzLmFjdGl2YXRpb25DYWNoZUtleX1fJHtjb21wb25lbnRzfV8ke2FDb21wb25lbnRzfV8ke291dHB1dE51bWJlcn1fJHtcbiAgICAgICAgICAgICAgaXNDaGFubmVsc0xhc3R9YCxcbiAgICAgICAgICBpbnB1dERlcGVuZGVuY2llczogaGFzQmlhcyA/IFsncmFuaycsICdyYW5rJywgJ3JhbmsnXSA6IFsncmFuaycsICdyYW5rJ11cbiAgICAgICAgfSxcbiAgICAgICAgZ2V0UnVuRGF0YTogKCkgPT4gKHtcbiAgICAgICAgICBvdXRwdXRzOiBbe2RpbXM6IG91dHB1dFNoYXBlLCBkYXRhVHlwZTogaW5wdXRzWzBdLmRhdGFUeXBlfV0sXG4gICAgICAgICAgZGlzcGF0Y2hHcm91cDoge3g6IE1hdGguY2VpbChvdXRwdXRTaXplIC8gNjQgLyogd29ya2dyb3VwIHNpemUgKi8pfSxcbiAgICAgICAgICBwcm9ncmFtVW5pZm9ybXNcbiAgICAgICAgfSksXG4gICAgICAgIGdldFNoYWRlclNvdXJjZVxuICAgICAgfTtcbiAgICB9O1xuXG5jb25zdCB2YWxpZGF0ZUlucHV0cyA9IChpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSk6IHZvaWQgPT4ge1xuICBpZiAoIWlucHV0cyB8fCBpbnB1dHMubGVuZ3RoICE9PSAyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdNYXRNdWwgcmVxdWlyZXMgMiBpbnB1dHMuJyk7XG4gIH1cblxuICBpZiAoaW5wdXRzWzBdLmRpbXNbaW5wdXRzWzBdLmRpbXMubGVuZ3RoIC0gMV0gIT09IGlucHV0c1sxXS5kaW1zW2lucHV0c1sxXS5kaW1zLmxlbmd0aCAtIDJdKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzaGFyZWQgZGltZW5zaW9uIGRvZXMgbm90IG1hdGNoLicpO1xuICB9XG59O1xuXG5leHBvcnQgY29uc3QgbWF0TXVsID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0KTogdm9pZCA9PiB7XG4gIHZhbGlkYXRlSW5wdXRzKGNvbnRleHQuaW5wdXRzKTtcbiAgY29uc3Qgb3V0cHV0U2hhcGUgPSBCcm9hZGNhc3RVdGlsLmNhbGNTaGFwZShjb250ZXh0LmlucHV0c1swXS5kaW1zLCBjb250ZXh0LmlucHV0c1sxXS5kaW1zLCB0cnVlKTtcbiAgaWYgKCFvdXRwdXRTaGFwZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignQ2FuXFwndCB1c2UgbWF0bXVsIG9uIHRoZSBnaXZlbiB0ZW5zb3JzJyk7XG4gIH1cbiAgY29uc3QgTiA9IG91dHB1dFNoYXBlW291dHB1dFNoYXBlLmxlbmd0aCAtIDFdO1xuICBjb25zdCBLID0gY29udGV4dC5pbnB1dHNbMF0uZGltc1tjb250ZXh0LmlucHV0c1swXS5kaW1zLmxlbmd0aCAtIDFdO1xuICBpZiAoTiA8IDggJiYgSyA8IDgpIHtcbiAgICBjb250ZXh0LmNvbXB1dGUoXG4gICAgICAgIGNyZWF0ZU5haXZlTWF0bXVsUHJvZ3JhbUluZm8oY29udGV4dC5pbnB1dHMsIHthY3RpdmF0aW9uOiAnJywgYWN0aXZhdGlvbkNhY2hlS2V5OiAnJ30sIG91dHB1dFNoYXBlKSk7XG4gIH0gZWxzZSB7XG4gICAgY29udGV4dC5jb21wdXRlKGNyZWF0ZU1hdG11bFByb2dyYW1JbmZvKGNvbnRleHQuaW5wdXRzLCB7YWN0aXZhdGlvbjogJycsIGFjdGl2YXRpb25DYWNoZUtleTogJyd9LCBvdXRwdXRTaGFwZSkpO1xuICB9XG59O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge1RlbnNvclZpZXd9IGZyb20gJy4uLy4uL3RlbnNvci12aWV3JztcbmltcG9ydCB7UG9vbENvbnZVdGlsfSBmcm9tICcuLi8uLi91dGlsJztcbmltcG9ydCB7QXR0cmlidXRlV2l0aENhY2hlS2V5LCBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXl9IGZyb20gJy4uL2F0dHJpYnV0ZS13aXRoLWNhY2hlLWtleSc7XG5pbXBvcnQge0NvbXB1dGVDb250ZXh0fSBmcm9tICcuLi90eXBlcyc7XG5cbmltcG9ydCB7Y3JlYXRlQ29udjJETWF0TXVsUHJvZ3JhbUluZm99IGZyb20gJy4vM3JkLXBhcnR5L2NvbnYyZF9tbV93ZWJncHUnO1xuaW1wb3J0IHtjcmVhdGVNYXRtdWxQcm9ncmFtSW5mb30gZnJvbSAnLi8zcmQtcGFydHkvbWF0bXVsX3BhY2tlZF93ZWJncHUnO1xuaW1wb3J0IHtjcmVhdGVHcm91cGVkQ29udlByb2dyYW1JbmZvLCBjcmVhdGVHcm91cGVkQ29udlZlY3Rvcml6ZVByb2dyYW1JbmZvfSBmcm9tICcuL2NvbnYtZ3JvdXBlZCc7XG5pbXBvcnQge0ludGVybmFsQWN0aXZhdGlvbkF0dHJpYnV0ZXMsIHBhcnNlSW50ZXJuYWxBY3RpdmF0aW9uQXR0cmlidXRlc30gZnJvbSAnLi9mdXNlLXV0aWxzJztcbmltcG9ydCB7Y3JlYXRlTmFpdmVNYXRtdWxQcm9ncmFtSW5mb30gZnJvbSAnLi9tYXRtdWwnO1xuaW1wb3J0IHtjcmVhdGVUcmFuc3Bvc2VQcm9ncmFtSW5mb30gZnJvbSAnLi90cmFuc3Bvc2UnO1xuXG5leHBvcnQgY29uc3QgY2FsY3VsYXRlT3V0cHV0U2hhcGUgPVxuICAgIChpbnB1dFNoYXBlOiByZWFkb25seSBudW1iZXJbXSwga2VybmVsU2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLCBkaWxhdGlvbnM6IHJlYWRvbmx5IG51bWJlcltdLFxuICAgICBhZGp1c3RQYWRzOiByZWFkb25seSBudW1iZXJbXSwgc3RyaWRlczogcmVhZG9ubHkgbnVtYmVyW10sIGlzQ2hhbm5lbExhc3Q6IGJvb2xlYW4pOiBudW1iZXJbXSA9PiB7XG4gICAgICBjb25zdCBiYXRjaFNpemUgPSBpbnB1dFNoYXBlWzBdO1xuICAgICAgY29uc3QgaW5wdXRTcGF0aWFsU2hhcGUgPSBpbnB1dFNoYXBlLnNsaWNlKGlzQ2hhbm5lbExhc3QgPyAxIDogMiwgaXNDaGFubmVsTGFzdCA/IDMgOiA0KTtcbiAgICAgIGNvbnN0IHNwYXRpYWxSYW5rID0gaW5wdXRTcGF0aWFsU2hhcGUubGVuZ3RoO1xuICAgICAgY29uc3Qgb3V0Q2hhbm5lbHMgPSBrZXJuZWxTaGFwZVswXTtcbiAgICAgIGNvbnN0IGtlcm5lbFNwYXRpYWxTaGFwZSA9IGtlcm5lbFNoYXBlLnNsaWNlKDIpO1xuICAgICAgY29uc3QgZGlsYXRlZEtlcm5lbFNoYXBlID0ga2VybmVsU3BhdGlhbFNoYXBlLm1hcCgodiwgaSkgPT4gdiArICh2IC0gMSkgKiAoZGlsYXRpb25zW2ldIC0gMSkpO1xuICAgICAgY29uc3QgaW5wdXRTcGF0aWFsU2hhcGVXaXRoUGFkID0gaW5wdXRTcGF0aWFsU2hhcGUubWFwKCh2LCBpKSA9PiB2ICsgYWRqdXN0UGFkc1tpXSArIGFkanVzdFBhZHNbaSArIHNwYXRpYWxSYW5rXSk7XG4gICAgICBjb25zdCBvdXRwdXRTaGFwZSA9XG4gICAgICAgICAgaW5wdXRTcGF0aWFsU2hhcGVXaXRoUGFkLm1hcCgodiwgaSkgPT4gTWF0aC5mbG9vcigodiAtIGRpbGF0ZWRLZXJuZWxTaGFwZVtpXSArIHN0cmlkZXNbaV0pIC8gc3RyaWRlc1tpXSkpO1xuICAgICAgb3V0cHV0U2hhcGUuc3BsaWNlKDAsIDAsIGJhdGNoU2l6ZSk7XG4gICAgICBvdXRwdXRTaGFwZS5zcGxpY2UoaXNDaGFubmVsTGFzdCA/IDMgOiAxLCAwLCBvdXRDaGFubmVscyk7XG4gICAgICByZXR1cm4gb3V0cHV0U2hhcGU7XG4gICAgfTtcblxuZXhwb3J0IGludGVyZmFjZSBDb252QXR0cmlidXRlcyBleHRlbmRzIEludGVybmFsQWN0aXZhdGlvbkF0dHJpYnV0ZXMsIEF0dHJpYnV0ZVdpdGhDYWNoZUtleSB7XG4gIHJlYWRvbmx5IGF1dG9QYWQ6IHN0cmluZztcbiAgcmVhZG9ubHkgZGlsYXRpb25zOiByZWFkb25seSBudW1iZXJbXTtcbiAgcmVhZG9ubHkgZm9ybWF0OiAnTkhXQyd8J05DSFcnO1xuICByZWFkb25seSBncm91cDogbnVtYmVyO1xuICByZWFkb25seSBrZXJuZWxTaGFwZTogcmVhZG9ubHkgbnVtYmVyW107XG4gIHJlYWRvbmx5IHBhZHM6IHJlYWRvbmx5IG51bWJlcltdO1xuICByZWFkb25seSBzdHJpZGVzOiByZWFkb25seSBudW1iZXJbXTtcbiAgcmVhZG9ubHkgd0lzQ29uc3Q6IGJvb2xlYW47XG59XG5cbi8vIGZvciB0cmFuc3Bvc2luZyB3ZWlnaHQgdGVuc29yIGZyb20gW00sIEMvZ3JvdXAsIEtILCBLV10gdG8gW0tILCBLVywgQy9ncm91cCwgTV1cbmNvbnN0IHdlaWdodFRyYW5zcG9zZUF0dHJpYnV0ZSA9IFsyLCAzLCAxLCAwXTtcblxuY29uc3QgdmFsaWRhdGVJbnB1dHMgPSAoaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10sIGF0dHJpYnV0ZXM6IENvbnZBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIC8vIFJlZmVyIHRvIHRoZSBiZWxvdyBsaW5rIGZvciBhbGwgaW5wdXQgY2hlY2tzXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9vbm54L29ubngvYmxvYi9tYXN0ZXIvZG9jcy9PcGVyYXRvcnMubWQjQ29udlxuICBpZiAoIWlucHV0cyB8fCAoaW5wdXRzLmxlbmd0aCAhPT0gMiAmJiBpbnB1dHMubGVuZ3RoICE9PSAzKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignQ29udiByZXF1aXJlcyAyIG9yIDMgaW5wdXRzJyk7XG4gIH1cblxuICAvLyBUT0RPIDogTmVlZCB0byBhZGQgc3VwcG9ydCBmb3IgbXVsdGktZGltZW5zaW9uYWwgY29udlxuICBpZiAoaW5wdXRzWzBdLmRpbXMubGVuZ3RoICE9PSA0ICYmIGlucHV0c1swXS5kaW1zLmxlbmd0aCAhPT0gMykge1xuICAgIHRocm93IG5ldyBFcnJvcignY3VycmVudGx5IG9ubHkgc3VwcG9ydCBjb252IDFEIGFuZCAyRCcpO1xuICB9XG5cbiAgaWYgKGlucHV0c1swXS5kaW1zLmxlbmd0aCAhPT0gaW5wdXRzWzFdLmRpbXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdmaWx0ZXIgZG9lcyBub3QgaGF2ZSBzYW1lIGRpbWVuc2lvbiBhcyBpbnB1dCcpO1xuICB9XG5cbiAgLy8gRklMVEVSX0lOX0NIQU5ORUwgc2hvdWxkIGJlIGVxdWFsIHRvIERBVEFfQ0hBTk5FTFxuICBjb25zdCBkYXRhQ2hhbm5lbCA9IGlucHV0c1swXS5kaW1zW2F0dHJpYnV0ZXMuZm9ybWF0ID09PSAnTkhXQycgPyBpbnB1dHNbMF0uZGltcy5sZW5ndGggLSAxIDogMV07XG4gIGNvbnN0IGZpbHRlckluQ2hhbm5lbCA9IGlucHV0c1sxXS5kaW1zWzFdICogYXR0cmlidXRlcy5ncm91cDtcbiAgaWYgKGRhdGFDaGFubmVsICE9PSBmaWx0ZXJJbkNoYW5uZWwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZJTFRFUl9JTl9DSEFOTkVMIHNob3VsZCBiZSBlcXVhbCB0byBEQVRBX0NIQU5ORUwnKTtcbiAgfVxuXG4gIC8vIGlmIGJpYXMgaXMgcHJvdmlkZWQgaXQgc2hvdWxkIGJlIDFEIGFuZCB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIHNob3VsZCBiZSBlcXVhbCB0byB0aGUgbnVtYmVyIG9mIGZlYXR1cmUgbWFwc1xuICBpZiAoaW5wdXRzLmxlbmd0aCA9PT0gMyAmJiAoaW5wdXRzWzJdLmRpbXMubGVuZ3RoICE9PSAxIHx8IGlucHV0c1sxXS5kaW1zWzBdICE9PSBpbnB1dHNbMl0uZGltc1swXSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgYmlhcycpO1xuICB9XG5cbiAgY29uc3Qgc3BhdGlhbFJhbmsgPSBpbnB1dHNbMF0uZGltcy5sZW5ndGggLSAyO1xuICAvLyB3cm9uZyBkaWxhdGlvbnMgZGltZW5zaW9uXG4gIGlmIChhdHRyaWJ1dGVzLmRpbGF0aW9ucy5sZW5ndGggIT09IHNwYXRpYWxSYW5rKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBkaWxhdGlvbnMgc2hvdWxkIGJlICR7c3BhdGlhbFJhbmt9RGApO1xuICB9XG5cbiAgLy8gV3Jvbmcgc3RyaWRlcyBkaW1lbnNpb25cbiAgaWYgKGF0dHJpYnV0ZXMuc3RyaWRlcy5sZW5ndGggIT09IHNwYXRpYWxSYW5rKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBzdHJpZGVzIHNob3VsZCBiZSAke3NwYXRpYWxSYW5rfURgKTtcbiAgfVxuXG4gIC8vIFdyb25nIHBhZHMgZGltZW5zaW9uXG4gIGlmIChhdHRyaWJ1dGVzLnBhZHMubGVuZ3RoICE9PSBzcGF0aWFsUmFuayAqIDIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYHBhZHMgc2hvdWxkIGJlICR7c3BhdGlhbFJhbmsgKiAyfURgKTtcbiAgfVxuXG4gIC8vIGlmIGtlcm5lbFNoYXBlIGlzIHNwZWNpZmllZCwgaXQncyBkYXRhIGxlbmd0aCBtdXN0IGJlIDIgbGVzcyB0aGFuIGRpbXMgbGVuZ3RoIG9mIHRoZSB3ZWlnaHRzIHRlbnNvclxuICAvLyAodGhlIGZpcnN0IDIgZGltcyBhcmUgYmF0Y2hfc2l6ZSBhbmQgY2hhbm5lbHMpXG4gIGlmIChhdHRyaWJ1dGVzLmtlcm5lbFNoYXBlLmxlbmd0aCAhPT0gMCAmJiBhdHRyaWJ1dGVzLmtlcm5lbFNoYXBlLmxlbmd0aCAhPT0gaW5wdXRzWzFdLmRpbXMubGVuZ3RoIC0gMikge1xuICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBrZXJuZWwgc2hhcGUnKTtcbiAgfVxufTtcblxuY29uc3QgZ2V0QWRqdXN0ZWRDb252QXR0cmlidXRlcyA9IDxUIGV4dGVuZHMgQ29udkF0dHJpYnV0ZXM+KGF0dHJpYnV0ZXM6IFQsIGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdKTogVCA9PiB7XG4gIGNvbnN0IGtlcm5lbFNoYXBlID0gYXR0cmlidXRlcy5rZXJuZWxTaGFwZS5zbGljZSgpO1xuICAvLyBpZiBrZXJuZWxTaGFwZSBpcyBub3Qgc3BlY2lmaWVkIGluIHRoZSBhdHRyaWJ1dGVzIG9mIHRoaXMgb3AsIGluZmVyIGl0IGZyb20gdGhlIHdlaWdodCB0ZW5zb3IgZGltc1xuICBmb3IgKGxldCBpID0gMjsgaSA8IGlucHV0c1sxXS5kaW1zLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKGtlcm5lbFNoYXBlW2kgLSAyXSA9PT0gMCkge1xuICAgICAga2VybmVsU2hhcGVbaSAtIDJdID0gaW5wdXRzWzFdLmRpbXNbaV07XG4gICAgfVxuICB9XG4gIGNvbnN0IHBhZHMgPSBhdHRyaWJ1dGVzLnBhZHMuc2xpY2UoKTtcbiAgUG9vbENvbnZVdGlsLmFkanVzdFBhZHNCYXNlZE9uQXV0b1BhZChcbiAgICAgIGlucHV0c1swXS5kaW1zLCBhdHRyaWJ1dGVzLnN0cmlkZXMsIGF0dHJpYnV0ZXMuZGlsYXRpb25zLCBrZXJuZWxTaGFwZSwgcGFkcywgYXR0cmlidXRlcy5mb3JtYXQgPT09ICdOSFdDJyxcbiAgICAgIGF0dHJpYnV0ZXMuYXV0b1BhZCk7XG5cbiAgLy8gYWx3YXlzIHJldHVybiBhIG5ldyBvYmplY3Qgc28gZG9lcyBub3QgbW9kaWZ5IHRoZSBvcmlnaW5hbCBhdHRyaWJ1dGVzXG4gIGNvbnN0IG5ld0F0dHJpYnV0ZXM6IFQgPSBPYmplY3QuYXNzaWduKHt9LCBhdHRyaWJ1dGVzKTtcbiAgT2JqZWN0LmFzc2lnbihuZXdBdHRyaWJ1dGVzLCB7a2VybmVsU2hhcGUsIHBhZHMsIGNhY2hlS2V5OiBhdHRyaWJ1dGVzLmNhY2hlS2V5fSk7XG4gIHJldHVybiBuZXdBdHRyaWJ1dGVzO1xufTtcblxuZXhwb3J0IGNvbnN0IHBhcnNlQ29udkF0dHJpYnV0ZXMgPSAoYXR0cmlidXRlczogUmVjb3JkPHN0cmluZywgdW5rbm93bj4pOiBDb252QXR0cmlidXRlcyA9PiB7XG4gIGNvbnN0IGFjdGl2YXRpb25BdHRyaWJ1dGVzID0gcGFyc2VJbnRlcm5hbEFjdGl2YXRpb25BdHRyaWJ1dGVzKGF0dHJpYnV0ZXMpO1xuICAvLyBUT0RPIDogTWFrZSB0aGlzIGdlbmVyaWMgZW5vdWdoIHRvIGNvbXB1dGUgZGVmYXVsdCBhdHRyaWJ1dGVzIGZvciBtdWx0aS1kaW1lbnNpb25hbCBjb252XG4gIGNvbnN0IGZvcm1hdCA9IGF0dHJpYnV0ZXMuZm9ybWF0IGFzICdOSFdDJyB8ICdOQ0hXJztcbiAgY29uc3QgYXV0b1BhZCA9IFsnTk9UU0VUJywgJ1ZBTElEJywgJ1NBTUVfVVBQRVInLCAnU0FNRV9MT1dFUiddW2F0dHJpYnV0ZXMuYXV0b19wYWQgYXMgbnVtYmVyXTtcbiAgY29uc3QgZGlsYXRpb25zID0gYXR0cmlidXRlcy5kaWxhdGlvbnMgYXMgW251bWJlciwgbnVtYmVyXTtcbiAgY29uc3QgZ3JvdXAgPSBhdHRyaWJ1dGVzLmdyb3VwIGFzIG51bWJlcjtcbiAgY29uc3Qga2VybmVsU2hhcGUgPSBhdHRyaWJ1dGVzLmtlcm5lbF9zaGFwZSBhcyBbbnVtYmVyLCBudW1iZXJdO1xuICBjb25zdCBwYWRzID0gYXR0cmlidXRlcy5wYWRzIGFzIFtudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXJdO1xuICBjb25zdCBzdHJpZGVzID0gYXR0cmlidXRlcy5zdHJpZGVzIGFzIFtudW1iZXIsIG51bWJlcl07XG4gIGNvbnN0IHdJc0NvbnN0ID0gKGF0dHJpYnV0ZXMud19pc19jb25zdCBhcyAoKSA9PiBib29sZWFuKSgpO1xuXG4gIHJldHVybiBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkoXG4gICAgICB7YXV0b1BhZCwgZm9ybWF0LCBkaWxhdGlvbnMsIGdyb3VwLCBrZXJuZWxTaGFwZSwgcGFkcywgc3RyaWRlcywgd0lzQ29uc3QsIC4uLmFjdGl2YXRpb25BdHRyaWJ1dGVzfSk7XG59O1xuXG5jb25zdCBjb252MmQgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdLCBhdHRyaWJ1dGVzOiBDb252QXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICBjb25zdCBhZGp1c3RlZEF0dHJpYnV0ZXMgPSBnZXRBZGp1c3RlZENvbnZBdHRyaWJ1dGVzKGF0dHJpYnV0ZXMsIGlucHV0cyk7XG5cbiAgLy8gY2hlY2sgYXR0cmlidXRlc1xuXG4gIC8vIGNvbnN0IGhhc1ByZWx1QWN0aXZhdGlvbldlaWdodHMgPSBmYWxzZTsgLyogVE9ETzogYWRkIHN1cHBvcnQgZm9yIHByZWx1IGFjdGl2YXRpb24gd2VpZ2h0cyAqL1xuICBjb25zdCBpc0NoYW5uZWxzTGFzdCA9IGF0dHJpYnV0ZXMuZm9ybWF0ID09PSAnTkhXQyc7XG4gIGlmIChhdHRyaWJ1dGVzLmdyb3VwICE9PSAxKSB7XG4gICAgLy8gVGVtcG9yYXJpbHkgZGlzYWJsZSBjcmVhdGVHcm91cGVkQ29udlZlY3Rvcml6ZVByb2dyYW1JbmZvIHBhdGggZHVlIHRvIGJvdHMgZmFpbHVyZXMgd2l0aCBiZWxvdyB0d28gY2FzZXM6XG4gICAgLy8gW3dlYmdwdV1Db252IC0gY29udiAtIHZlY3Rvcml6ZSBncm91cCAtIEJcbiAgICAvLyBbd2ViZ3B1XUNvbnYgLSBjb252IC0gdmVjdG9yaXplIGdyb3VwIC0gRFxuICAgIGNvbnN0IGRpc2FibGVHcm91cGVkQ29udlZlY3Rvcml6ZSA9IHRydWU7XG4gICAgaWYgKCFkaXNhYmxlR3JvdXBlZENvbnZWZWN0b3JpemUgJiYgaXNDaGFubmVsc0xhc3QgJiYgaW5wdXRzWzFdLmRpbXNbMF0gPT09IGF0dHJpYnV0ZXMuZ3JvdXAgJiZcbiAgICAgICAgaW5wdXRzWzFdLmRpbXNbMV0gPT09IDEgJiYgYXR0cmlidXRlcy5kaWxhdGlvbnNbMF0gPT09IDEgJiYgYXR0cmlidXRlcy5kaWxhdGlvbnNbMV0gPT09IDEpIHtcbiAgICAgIGNvbnN0IG91dHB1dFNoYXBlID0gY2FsY3VsYXRlT3V0cHV0U2hhcGUoXG4gICAgICAgICAgaW5wdXRzWzBdLmRpbXMsIGlucHV0c1sxXS5kaW1zLCBhdHRyaWJ1dGVzLmRpbGF0aW9ucywgYWRqdXN0ZWRBdHRyaWJ1dGVzLnBhZHMsIGF0dHJpYnV0ZXMuc3RyaWRlcyxcbiAgICAgICAgICBpc0NoYW5uZWxzTGFzdCk7XG4gICAgICBjb25zdCB0cmFuc3Bvc2VkV2VpZ2h0ID0gKGNvbnRleHQua2VybmVsQ3VzdG9tRGF0YS53VCBhcyBUZW5zb3JWaWV3IHwgdW5kZWZpbmVkKSA/P1xuICAgICAgICAgIGNvbnRleHQuY29tcHV0ZShcbiAgICAgICAgICAgICAgY3JlYXRlVHJhbnNwb3NlUHJvZ3JhbUluZm8oaW5wdXRzWzFdLCB3ZWlnaHRUcmFuc3Bvc2VBdHRyaWJ1dGUpLFxuICAgICAgICAgICAgICB7aW5wdXRzOiBbMV0sIG91dHB1dHM6IFthdHRyaWJ1dGVzLndJc0NvbnN0ID8gLTIgOiAtMV19KVswXTtcbiAgICAgIGlmIChhdHRyaWJ1dGVzLndJc0NvbnN0ICYmICFjb250ZXh0Lmtlcm5lbEN1c3RvbURhdGEud1QpIHtcbiAgICAgICAgY29udGV4dC5rZXJuZWxDdXN0b21EYXRhLndUID0gdHJhbnNwb3NlZFdlaWdodDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNvbnZJbnB1dHMgPSBbaW5wdXRzWzBdLCB0cmFuc3Bvc2VkV2VpZ2h0XTtcbiAgICAgIGlmIChpbnB1dHMubGVuZ3RoID09PSAzKSB7XG4gICAgICAgIGNvbnZJbnB1dHMucHVzaChpbnB1dHNbMl0pO1xuICAgICAgfVxuICAgICAgY29udGV4dC5jb21wdXRlKFxuICAgICAgICAgIGNyZWF0ZUdyb3VwZWRDb252VmVjdG9yaXplUHJvZ3JhbUluZm8oY29udklucHV0cywgYWRqdXN0ZWRBdHRyaWJ1dGVzLCBvdXRwdXRTaGFwZSksIHtpbnB1dHM6IGNvbnZJbnB1dHN9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGV4dC5jb21wdXRlKGNyZWF0ZUdyb3VwZWRDb252UHJvZ3JhbUluZm8oaW5wdXRzLCBhZGp1c3RlZEF0dHJpYnV0ZXMpKTtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3QgaGFzQmlhcyA9IGlucHV0cy5sZW5ndGggPT09IDM7XG4gIGNvbnN0IGlucHV0SGVpZ2h0ID0gaW5wdXRzWzBdLmRpbXNbaXNDaGFubmVsc0xhc3QgPyAxIDogMl07XG4gIGNvbnN0IGlucHV0V2lkdGggPSBpbnB1dHNbMF0uZGltc1tpc0NoYW5uZWxzTGFzdCA/IDIgOiAzXTtcbiAgY29uc3QgaW5wdXRDaGFubmVscyA9IGlucHV0c1swXS5kaW1zW2lzQ2hhbm5lbHNMYXN0ID8gMyA6IDFdO1xuICBjb25zdCB3ZWlnaHRIZWlnaHQgPSBpbnB1dHNbMV0uZGltc1syXTtcbiAgY29uc3Qgd2VpZ2h0V2lkdGggPSBpbnB1dHNbMV0uZGltc1szXTtcblxuICBjb25zdCBvdXRwdXRTaGFwZSA9IGNhbGN1bGF0ZU91dHB1dFNoYXBlKFxuICAgICAgaW5wdXRzWzBdLmRpbXMsIGlucHV0c1sxXS5kaW1zLCBhdHRyaWJ1dGVzLmRpbGF0aW9ucywgYWRqdXN0ZWRBdHRyaWJ1dGVzLnBhZHMsIGF0dHJpYnV0ZXMuc3RyaWRlcyxcbiAgICAgIGlzQ2hhbm5lbHNMYXN0KTtcbiAgY29uc3Qgb3V0SGVpZ2h0ID0gb3V0cHV0U2hhcGVbaXNDaGFubmVsc0xhc3QgPyAxIDogMl07XG4gIGNvbnN0IG91dFdpZHRoID0gb3V0cHV0U2hhcGVbaXNDaGFubmVsc0xhc3QgPyAyIDogM107XG4gIGNvbnN0IG91dENoYW5uZWxzID0gb3V0cHV0U2hhcGVbaXNDaGFubmVsc0xhc3QgPyAzIDogMV07XG5cbiAgY29uc3Qgc2FtZVNpemUgPSBpc0NoYW5uZWxzTGFzdCAmJiB3ZWlnaHRIZWlnaHQgPT09IGlucHV0SGVpZ2h0ICYmIHdlaWdodFdpZHRoID09PSBpbnB1dFdpZHRoICYmXG4gICAgICBhdHRyaWJ1dGVzLnBhZHNbMF0gPT09IDAgJiYgYXR0cmlidXRlcy5wYWRzWzFdID09PSAwO1xuICBpZiAoc2FtZVNpemUgfHxcbiAgICAgICh3ZWlnaHRIZWlnaHQgPT09IDEgJiYgd2VpZ2h0V2lkdGggPT09IDEgJiYgYXR0cmlidXRlcy5kaWxhdGlvbnNbMF0gPT09IDEgJiYgYXR0cmlidXRlcy5kaWxhdGlvbnNbMV0gPT09IDEgJiZcbiAgICAgICBhdHRyaWJ1dGVzLnN0cmlkZXNbMF0gPT09IDEgJiYgYXR0cmlidXRlcy5zdHJpZGVzWzFdID09PSAxICYmIGF0dHJpYnV0ZXMucGFkc1swXSA9PT0gMCAmJlxuICAgICAgIGF0dHJpYnV0ZXMucGFkc1sxXSA9PT0gMCkpIHtcbiAgICAvLyBjb252MmRCeU1hdE11bFxuICAgIGNvbnN0IGJhdGNoID0gb3V0cHV0U2hhcGVbMF07XG4gICAgbGV0IHhSZXNoYXBlZCwgd1Jlc2hhcGVkLCBtYXRtdWxPdXRwdXRTaGFwZTtcbiAgICBjb25zdCBtYXRtdWxJbnB1dHMgPSBbXTtcbiAgICBpZiAoaXNDaGFubmVsc0xhc3QpIHtcbiAgICAgIGNvbnN0IHRyYW5zcG9zZWRXZWlnaHQgPSAoY29udGV4dC5rZXJuZWxDdXN0b21EYXRhLndUIGFzIFRlbnNvclZpZXcgfCB1bmRlZmluZWQpID8/XG4gICAgICAgICAgY29udGV4dC5jb21wdXRlKFxuICAgICAgICAgICAgICBjcmVhdGVUcmFuc3Bvc2VQcm9ncmFtSW5mbyhpbnB1dHNbMV0sIHdlaWdodFRyYW5zcG9zZUF0dHJpYnV0ZSksXG4gICAgICAgICAgICAgIHtpbnB1dHM6IFsxXSwgb3V0cHV0czogW2F0dHJpYnV0ZXMud0lzQ29uc3QgPyAtMiA6IC0xXX0pWzBdO1xuICAgICAgaWYgKGF0dHJpYnV0ZXMud0lzQ29uc3QgJiYgIWNvbnRleHQua2VybmVsQ3VzdG9tRGF0YS53VCkge1xuICAgICAgICBjb250ZXh0Lmtlcm5lbEN1c3RvbURhdGEud1QgPSB0cmFuc3Bvc2VkV2VpZ2h0O1xuICAgICAgfVxuICAgICAgaWYgKHNhbWVTaXplKSB7XG4gICAgICAgIGNvbnN0IHNoYXJlZERpbSA9IGlucHV0SGVpZ2h0ICogaW5wdXRXaWR0aCAqIGlucHV0Q2hhbm5lbHM7XG4gICAgICAgIHhSZXNoYXBlZCA9IGlucHV0c1swXS5yZXNoYXBlKFsxLCBiYXRjaCwgc2hhcmVkRGltXSk7XG4gICAgICAgIHdSZXNoYXBlZCA9IHRyYW5zcG9zZWRXZWlnaHQucmVzaGFwZShbMSwgc2hhcmVkRGltLCBvdXRDaGFubmVsc10pO1xuICAgICAgICBtYXRtdWxPdXRwdXRTaGFwZSA9IFsxLCBiYXRjaCwgb3V0Q2hhbm5lbHNdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeFJlc2hhcGVkID0gaW5wdXRzWzBdLnJlc2hhcGUoW2JhdGNoLCBpbnB1dEhlaWdodCAqIGlucHV0V2lkdGgsIGlucHV0Q2hhbm5lbHNdKTtcbiAgICAgICAgd1Jlc2hhcGVkID0gdHJhbnNwb3NlZFdlaWdodC5yZXNoYXBlKFsxLCBpbnB1dENoYW5uZWxzLCBvdXRDaGFubmVsc10pO1xuICAgICAgICBtYXRtdWxPdXRwdXRTaGFwZSA9IFtiYXRjaCwgb3V0SGVpZ2h0ICogb3V0V2lkdGgsIG91dENoYW5uZWxzXTtcbiAgICAgIH1cbiAgICAgIG1hdG11bElucHV0cy5wdXNoKHhSZXNoYXBlZCk7XG4gICAgICBtYXRtdWxJbnB1dHMucHVzaCh3UmVzaGFwZWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB4UmVzaGFwZWQgPSBpbnB1dHNbMF0ucmVzaGFwZShbYmF0Y2gsIGlucHV0Q2hhbm5lbHMsIGlucHV0SGVpZ2h0ICogaW5wdXRXaWR0aF0pO1xuICAgICAgd1Jlc2hhcGVkID0gaW5wdXRzWzFdLnJlc2hhcGUoWzEsIG91dENoYW5uZWxzLCBpbnB1dENoYW5uZWxzXSk7XG4gICAgICBtYXRtdWxPdXRwdXRTaGFwZSA9IFtiYXRjaCwgb3V0Q2hhbm5lbHMsIG91dEhlaWdodCAqIG91dFdpZHRoXTtcbiAgICAgIG1hdG11bElucHV0cy5wdXNoKHdSZXNoYXBlZCk7XG4gICAgICBtYXRtdWxJbnB1dHMucHVzaCh4UmVzaGFwZWQpO1xuICAgIH1cbiAgICBpZiAoaGFzQmlhcykge1xuICAgICAgbWF0bXVsSW5wdXRzLnB1c2goaW5wdXRzWzJdKTtcbiAgICB9XG4gICAgY29uc3QgTiA9IG1hdG11bE91dHB1dFNoYXBlWzJdO1xuICAgIGNvbnN0IEsgPSBtYXRtdWxJbnB1dHNbMF0uZGltc1ttYXRtdWxJbnB1dHNbMF0uZGltcy5sZW5ndGggLSAxXTtcbiAgICAvLyBUdW5lIHRoZSB0aHJlc2hvbGQuXG4gICAgaWYgKE4gPCA4ICYmIEsgPCA4KSB7XG4gICAgICBjb250ZXh0LmNvbXB1dGUoXG4gICAgICAgICAgY3JlYXRlTmFpdmVNYXRtdWxQcm9ncmFtSW5mbyhcbiAgICAgICAgICAgICAgbWF0bXVsSW5wdXRzLCBhZGp1c3RlZEF0dHJpYnV0ZXMsIG91dHB1dFNoYXBlLCBtYXRtdWxPdXRwdXRTaGFwZSwgaXNDaGFubmVsc0xhc3QpLFxuICAgICAgICAgIHtpbnB1dHM6IG1hdG11bElucHV0c30pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb250ZXh0LmNvbXB1dGUoXG4gICAgICAgICAgY3JlYXRlTWF0bXVsUHJvZ3JhbUluZm8obWF0bXVsSW5wdXRzLCBhZGp1c3RlZEF0dHJpYnV0ZXMsIG91dHB1dFNoYXBlLCBtYXRtdWxPdXRwdXRTaGFwZSwgaXNDaGFubmVsc0xhc3QpLFxuICAgICAgICAgIHtpbnB1dHM6IG1hdG11bElucHV0c30pO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBUT0RPOiBpbXBsZW1lbnQgY29udjJkV2l0aEltMkNvbCgpXG5cbiAgY29uc3Qgc2VxdWVudGlhbEFjY2Vzc0J5VGhyZWFkcyA9IC8qIGJhY2tlbmQuYWRhcHRlckluZm8uaXNJbnRlbCgpICovIHRydWU7XG5cbiAgLy8gU1RFUC4xOiB0cmFuc3Bvc2Ugd2VpZ2h0XG4gIGNvbnN0IHRyYW5zcG9zZWRXZWlnaHQgPSAoY29udGV4dC5rZXJuZWxDdXN0b21EYXRhLndUIGFzIFRlbnNvclZpZXcgfCB1bmRlZmluZWQpID8/XG4gICAgICBjb250ZXh0LmNvbXB1dGUoXG4gICAgICAgICAgY3JlYXRlVHJhbnNwb3NlUHJvZ3JhbUluZm8oaW5wdXRzWzFdLCB3ZWlnaHRUcmFuc3Bvc2VBdHRyaWJ1dGUpLFxuICAgICAgICAgIHtpbnB1dHM6IFsxXSwgb3V0cHV0czogW2F0dHJpYnV0ZXMud0lzQ29uc3QgPyAtMiA6IC0xXX0pWzBdO1xuICBpZiAoYXR0cmlidXRlcy53SXNDb25zdCAmJiAhY29udGV4dC5rZXJuZWxDdXN0b21EYXRhLndUKSB7XG4gICAgY29udGV4dC5rZXJuZWxDdXN0b21EYXRhLndUID0gdHJhbnNwb3NlZFdlaWdodDtcbiAgfVxuXG4gIC8vIFNURVAuMjogcHJlcGFyZSByZXNoYXBlZCBpbnB1dHNcbiAgY29uc3QgY29udklucHV0cyA9IFtpbnB1dHNbMF0sIHRyYW5zcG9zZWRXZWlnaHRdO1xuICBpZiAoaGFzQmlhcykge1xuICAgIGNvbnZJbnB1dHMucHVzaChpbnB1dHNbMl0pO1xuICB9XG5cbiAgLy8gU1RFUC4zOiBjb21wdXRlIG1hdG11bFxuICBjb25zdCBkaW1BT3V0ZXIgPSBpc0NoYW5uZWxzTGFzdCA/IG91dEhlaWdodCAqIG91dFdpZHRoIDogb3V0Q2hhbm5lbHM7XG4gIGNvbnN0IGRpbUJPdXRlciA9IGlzQ2hhbm5lbHNMYXN0ID8gb3V0Q2hhbm5lbHMgOiBvdXRIZWlnaHQgKiBvdXRXaWR0aDtcbiAgY29uc3QgZGltSW5uZXIgPSB3ZWlnaHRIZWlnaHQgKiB3ZWlnaHRXaWR0aCAqIGlucHV0Q2hhbm5lbHM7XG4gIGNvbnRleHQuY29tcHV0ZShcbiAgICAgIGNyZWF0ZUNvbnYyRE1hdE11bFByb2dyYW1JbmZvKFxuICAgICAgICAgIGNvbnZJbnB1dHMsIGFkanVzdGVkQXR0cmlidXRlcywgb3V0cHV0U2hhcGUsIGRpbUFPdXRlciwgZGltQk91dGVyLCBkaW1Jbm5lciwgaGFzQmlhcyxcbiAgICAgICAgICBzZXF1ZW50aWFsQWNjZXNzQnlUaHJlYWRzKSxcbiAgICAgIHtpbnB1dHM6IGNvbnZJbnB1dHN9KTtcbn07XG5cbmNvbnN0IGNvbnYxZCA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogQ29udkF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgLy8gZXh0ZW5kIHRoZSBpbnB1dCB0byAyRCBieSBhZGRpbmcgSCBkaW1lbnNpb25cbiAgY29uc3QgaXNDaGFubmVsTGFzdCA9IGF0dHJpYnV0ZXMuZm9ybWF0ID09PSAnTkhXQyc7XG4gIGNvbnN0IGlucHV0cyA9IFtcbiAgICBjb250ZXh0LmlucHV0c1swXS5yZXNoYXBlKFxuICAgICAgICBpc0NoYW5uZWxMYXN0ID9cbiAgICAgICAgICAgIC8vIFtOLCBXLCBDXSAtPiBbTiwgSD0xLCBXLCBDXVxuICAgICAgICAgICAgW2NvbnRleHQuaW5wdXRzWzBdLmRpbXNbMF0sIDEsIGNvbnRleHQuaW5wdXRzWzBdLmRpbXNbMV0sIGNvbnRleHQuaW5wdXRzWzBdLmRpbXNbMl1dIDpcbiAgICAgICAgICAgIC8vIFtOLCBDLCBXXSAtPiBbTiwgQywgSD0xLCBXXVxuICAgICAgICAgICAgW2NvbnRleHQuaW5wdXRzWzBdLmRpbXNbMF0sIGNvbnRleHQuaW5wdXRzWzBdLmRpbXNbMV0sIDEsIGNvbnRleHQuaW5wdXRzWzBdLmRpbXNbMl1dKSxcbiAgICAvL1tGSUxURVJfT1VUX0NIQU5ORUwsIEZJTFRFUl9JTl9DSEFOTkVMLCBrV10gLT4gW0ZJTFRFUl9PVVRfQ0hBTk5FTCwgRklMVEVSX0lOX0NIQU5ORUwsIGtIPTEsIGtXXVxuICAgIGNvbnRleHQuaW5wdXRzWzFdLnJlc2hhcGUoW2NvbnRleHQuaW5wdXRzWzFdLmRpbXNbMF0sIGNvbnRleHQuaW5wdXRzWzFdLmRpbXNbMV0sIDEsIGNvbnRleHQuaW5wdXRzWzFdLmRpbXNbMl1dKVxuICBdO1xuICBpZiAoY29udGV4dC5pbnB1dHMubGVuZ3RoID09PSAzKSB7XG4gICAgaW5wdXRzLnB1c2goY29udGV4dC5pbnB1dHNbMl0pO1xuICB9XG4gIGNvbnN0IHBhZHMgPSBbMCwgYXR0cmlidXRlcy5wYWRzWzBdLCAwLCBhdHRyaWJ1dGVzLnBhZHNbMV1dO1xuICBjb25zdCBzdHJpZGVzID0gWzFdLmNvbmNhdChhdHRyaWJ1dGVzLnN0cmlkZXMpO1xuICBjb25zdCBkaWxhdGlvbnMgPSBbMV0uY29uY2F0KGF0dHJpYnV0ZXMuZGlsYXRpb25zKTtcbiAgY29uc3Qga2VybmVsU2hhcGUgPSBbMV0uY29uY2F0KGF0dHJpYnV0ZXMua2VybmVsU2hhcGUpO1xuICBjb25zdCBhZGp1c3RlZEF0dHJpYnV0ZXMgPSBnZXRBZGp1c3RlZENvbnZBdHRyaWJ1dGVzKHsuLi5hdHRyaWJ1dGVzLCBwYWRzLCBzdHJpZGVzLCBkaWxhdGlvbnMsIGtlcm5lbFNoYXBlfSwgaW5wdXRzKTtcbiAgY29udGV4dC5jb21wdXRlKGNyZWF0ZUdyb3VwZWRDb252UHJvZ3JhbUluZm8oXG4gICAgICBpbnB1dHMsIGFkanVzdGVkQXR0cmlidXRlcyxcbiAgICAgIG91dHB1dFNoYXBlID0+IGlzQ2hhbm5lbExhc3QgPyBbb3V0cHV0U2hhcGVbMF0sIG91dHB1dFNoYXBlWzJdLCBvdXRwdXRTaGFwZVszXV0gOiBbXSkpO1xufTtcblxuZXhwb3J0IGNvbnN0IGNvbnYgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IENvbnZBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIHZhbGlkYXRlSW5wdXRzKGNvbnRleHQuaW5wdXRzLCBhdHRyaWJ1dGVzKTsgIC8vIGN1cnJlbnRseSB3aWxsIGZhaWwgaWYgbm90IGNvbnYxRC8yRFxuICBpZiAoY29udGV4dC5pbnB1dHNbMF0uZGltcy5sZW5ndGggPT09IDMpIHtcbiAgICBjb252MWQoY29udGV4dCwgYXR0cmlidXRlcyk7XG4gIH0gZWxzZSB7XG4gICAgY29udjJkKGNvbnRleHQsIGNvbnRleHQuaW5wdXRzLCBhdHRyaWJ1dGVzKTtcbiAgfVxufTtcbiIsICIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMSBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5cbi8vIHNhbXBsZWQgZnJvbSBbQHRlbnNvcmZsb3cvdGZqc10gdGZqcy1iYWNrZW5kLXdlYmdwdS9zcmMvY29udl9iYWNrcHJvcF9tbV93ZWJncHUudHNcbi8vXG4vLyBtb2RpZmllZCB0byBmaXQgdGhlIG5lZWRzIG9mIHRoZSBwcm9qZWN0XG5cbmltcG9ydCB7TE9HX0RFQlVHfSBmcm9tICcuLi8uLi8uLi9sb2cnO1xuaW1wb3J0IHtUZW5zb3JWaWV3fSBmcm9tICcuLi8uLi8uLi90ZW5zb3Itdmlldyc7XG5pbXBvcnQge1Byb2dyYW1JbmZvLCBQcm9ncmFtVW5pZm9ybX0gZnJvbSAnLi4vLi4vdHlwZXMnO1xuaW1wb3J0IHtjcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcywgaW5wdXRWYXJpYWJsZSwgb3V0cHV0VmFyaWFibGUsIFNoYWRlckhlbHBlcn0gZnJvbSAnLi4vY29tbW9uJztcbmltcG9ydCB7Q29udlRyYW5zcG9zZUF0dHJpYnV0ZXN9IGZyb20gJy4uL2NvbnYtdHJhbnNwb3NlJztcbmltcG9ydCB7Z2V0QWN0aXZhdGlvblNuaXBwZXR9IGZyb20gJy4uL2Z1c2UtdXRpbHMnO1xuXG5pbXBvcnQge2JpYXNTbmlwcGV0LCB0eXBlU25pcHBldH0gZnJvbSAnLi9hY3RpdmF0aW9uX3V0aWwnO1xuaW1wb3J0IHt1dGlsRnVuY3Rpb25zfSBmcm9tICcuL2NvbnZfdXRpbCc7XG5pbXBvcnQge21ha2VNYXRNdWxQYWNrZWRTb3VyY2UsIG1ha2VNYXRNdWxQYWNrZWRWZWM0U291cmNlfSBmcm9tICcuL21hdG11bF9wYWNrZWRfd2ViZ3B1JztcblxuY29uc3QgY29udjJkVHJhbnNwb3NlQ29tbW9uU25pcHBldCA9XG4gICAgKGlzQ2hhbm5lbHNMYXN0OiBib29sZWFuLCBhZGRCaWFzID0gZmFsc2UsIGF0dHJpYnV0ZXM6IENvbnZUcmFuc3Bvc2VBdHRyaWJ1dGVzLCBpbm5lckVsZW1lbnRTaXplID0gNCk6IHN0cmluZyA9PiB7XG4gICAgICBjb25zdCB0eXBlID0gdHlwZVNuaXBwZXQoaW5uZXJFbGVtZW50U2l6ZSwgJ2YzMicpO1xuICAgICAgY29uc3QgZ2V0V1NuaXBwZXQgPSAoaW5uZXJFbGVtZW50U2l6ZTogbnVtYmVyKSA9PiB7XG4gICAgICAgIHN3aXRjaCAoaW5uZXJFbGVtZW50U2l6ZSkge1xuICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIHJldHVybiAncmV0dXJuIHdbZ2V0SW5kZXhGcm9tQ29vcmRzNEQoY29vcmQsIHZlYzQ8aTMyPih1bmlmb3Jtcy53X3NoYXBlKSldOyc7XG4gICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgcmV0dXJuIGBcbiAgICAgICAgICAgIGxldCBjb29yZDEgPSB2ZWM0PGkzMj4oY29vcmRYLCBjb29yZFksIGNvbCArIDEsIHJvd0lubmVyKTtcbiAgICAgICAgICAgIGxldCBjb29yZDIgPSB2ZWM0PGkzMj4oY29vcmRYLCBjb29yZFksIGNvbCArIDIsIHJvd0lubmVyKTtcbiAgICAgICAgICAgIGxldCBjb29yZDMgPSB2ZWM0PGkzMj4oY29vcmRYLCBjb29yZFksIGNvbCArIDMsIHJvd0lubmVyKTtcbiAgICAgICAgICAgIGxldCB2MCA9IHdbZ2V0SW5kZXhGcm9tQ29vcmRzNEQoY29vcmQsIHZlYzQ8aTMyPih1bmlmb3Jtcy53X3NoYXBlKSldO1xuICAgICAgICAgICAgbGV0IHYxID0gd1tnZXRJbmRleEZyb21Db29yZHM0RChjb29yZDEsIHZlYzQ8aTMyPih1bmlmb3Jtcy53X3NoYXBlKSldO1xuICAgICAgICAgICAgbGV0IHYyID0gd1tnZXRJbmRleEZyb21Db29yZHM0RChjb29yZDIsIHZlYzQ8aTMyPih1bmlmb3Jtcy53X3NoYXBlKSldO1xuICAgICAgICAgICAgbGV0IHYzID0gd1tnZXRJbmRleEZyb21Db29yZHM0RChjb29yZDMsIHZlYzQ8aTMyPih1bmlmb3Jtcy53X3NoYXBlKSldO1xuICAgICAgICAgICAgcmV0dXJuIHZlYzQ8ZjMyPih2MCwgdjEsIHYyLCB2Myk7XG4gICAgICAgICAgICBgO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGlubmVyRWxlbWVudFNpemUgJHtpbm5lckVsZW1lbnRTaXplfSBpcyBub3Qgc3VwcG9ydGVkLmApO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY29uc3QgY29vcmRBU25pcHBldCA9IGlzQ2hhbm5lbHNMYXN0ID8gYFxuICAgICAgbGV0IGNvb3JkID0gdmVjNDxpMzI+KGJhdGNoLCBpWFIsIGlYQywgeENoKTtcbiAgICAgIGAgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYFxuICAgICAgbGV0IGNvb3JkID0gdmVjNDxpMzI+KGJhdGNoLCB4Q2gsIGlYUiwgaVhDKTtcbiAgICAgIGA7XG5cbiAgICAgIGNvbnN0IGNvb3JkUmVzU25pcHBldCA9IGlzQ2hhbm5lbHNMYXN0ID8gYFxuICAgIGxldCBjb29yZHMgPSB2ZWM0PGkzMj4oXG4gICAgICBiYXRjaCxcbiAgICAgIHJvdyAvIG91dFdpZHRoLFxuICAgICAgcm93ICUgb3V0V2lkdGgsXG4gICAgICBjb2wpO1xuICAgIGAgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgXG4gICAgbGV0IGNvb3JkcyA9IHZlYzQ8aTMyPihcbiAgICAgIGJhdGNoLFxuICAgICAgcm93LFxuICAgICAgY29sIC8gb3V0V2lkdGgsXG4gICAgICBjb2wgJSBvdXRXaWR0aCk7XG4gICAgYDtcblxuICAgICAgY29uc3QgeEhlaWdodCA9IGlzQ2hhbm5lbHNMYXN0ID8gJ291dEJhY2twcm9wWzFdJyA6ICdvdXRCYWNrcHJvcFsyXSc7XG4gICAgICBjb25zdCB4V2lkdGggPSBpc0NoYW5uZWxzTGFzdCA/ICdvdXRCYWNrcHJvcFsyXScgOiAnb3V0QmFja3Byb3BbM10nO1xuICAgICAgY29uc3Qgcm93ID0gaXNDaGFubmVsc0xhc3QgPyAncm93JyA6ICdjb2wnO1xuICAgICAgY29uc3QgY29sID0gaXNDaGFubmVsc0xhc3QgPyAnY29sJyA6ICdyb3cnO1xuXG4gICAgICBjb25zdCByZWFkQVNuaXBwZXQgPSBgXG4gICAgICBsZXQgaW5DaGFubmVscyA9ICR7aXNDaGFubmVsc0xhc3QgPyAnb3V0QmFja3Byb3BbM10nIDogJ291dEJhY2twcm9wWzFdJ307XG4gICAgICBsZXQgb3V0V2lkdGggPSAke2lzQ2hhbm5lbHNMYXN0ID8gJ2kzMih1bmlmb3Jtcy5yZXN1bHRfc2hhcGVbMl0pJyA6ICdpMzIodW5pZm9ybXMucmVzdWx0X3NoYXBlWzNdKSd9O1xuICAgICAgbGV0IG91dFJvdyA9ICR7cm93fSAvIG91dFdpZHRoO1xuICAgICAgbGV0IG91dENvbCA9ICR7cm93fSAlIG91dFdpZHRoO1xuXG4gICAgICBsZXQgV1JvdyA9ICR7Y29sfSAvIChmaWx0ZXJEaW1zWzFdICogaW5DaGFubmVscyk7XG4gICAgICBsZXQgV0NvbCA9ICR7Y29sfSAvIGluQ2hhbm5lbHMgJSBmaWx0ZXJEaW1zWzFdO1xuICAgICAgbGV0IHhSID0gZjMyKG91dFJvdyAtIHBhZHNbMF0gKyBkaWxhdGlvblswXSAqIFdSb3cpIC8gZjMyKHN0cmlkZXNbMF0pO1xuICAgICAgbGV0IHhDID0gZjMyKG91dENvbCAtIHBhZHNbMV0gKyBkaWxhdGlvblsxXSAqIFdDb2wpIC8gZjMyKHN0cmlkZXNbMV0pO1xuICAgICAgaWYgKHhSIDwgMC4wIHx8IHhSID49IGYzMigke3hIZWlnaHR9KSB8fCBmcmFjdCh4UikgPiAwLjApIHtcbiAgICAgICAgcmV0dXJuICR7dHlwZX0oMC4wKTtcbiAgICAgIH1cbiAgICAgIGlmICh4QyA8IDAuMCB8fCB4QyA+PSBmMzIoJHt4V2lkdGh9KSB8fCBmcmFjdCh4QykgPiAwLjApIHtcbiAgICAgICAgcmV0dXJuICR7dHlwZX0oMC4wKTtcbiAgICAgIH1cbiAgICAgIGxldCBpWFIgPSBpMzIoeFIpO1xuICAgICAgbGV0IGlYQyA9IGkzMih4Qyk7XG4gICAgICBsZXQgeENoID0gJHtjb2x9ICUgaW5DaGFubmVscztcbiAgICAgICR7Y29vcmRBU25pcHBldH1cbiAgICAgIHJldHVybiB4W2dldEluZGV4RnJvbUNvb3JkczREKGNvb3JkLCB2ZWM0PGkzMj4odW5pZm9ybXMueF9zaGFwZSkpLyR7aW5uZXJFbGVtZW50U2l6ZX1dO2A7XG5cbiAgICAgIGNvbnN0IHNhbXBsZUEgPSBpc0NoYW5uZWxzTGFzdCA/IGBcbiAgICAgIGxldCBjb2wgPSBjb2xJbiAqICR7aW5uZXJFbGVtZW50U2l6ZX07XG4gICAgICBpZiAocm93IDwgdW5pZm9ybXMuZGltQU91dGVyICYmIGNvbCA8IHVuaWZvcm1zLmRpbUlubmVyKSB7XG4gICAgICAgICR7cmVhZEFTbmlwcGV0fVxuICAgICAgfVxuICAgICAgcmV0dXJuICR7dHlwZX0oMC4wKTtgIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBcbiAgICAgIGxldCBjb2wgPSBjb2xJbiAqICR7aW5uZXJFbGVtZW50U2l6ZX07XG4gICAgICBpZiAocm93IDwgdW5pZm9ybXMuZGltSW5uZXIgJiYgY29sIDwgdW5pZm9ybXMuZGltQk91dGVyKSB7XG4gICAgICAgICR7cmVhZEFTbmlwcGV0fVxuICAgICAgfVxuICAgICAgcmV0dXJuICR7dHlwZX0oMC4wKTtgO1xuXG4gICAgICBjb25zdCBzYW1wbGVXID0gYFxuICAgICAgbGV0IGNvbCA9IGNvbEluICogJHtpbm5lckVsZW1lbnRTaXplfTtcbiAgICAgIGxldCBpbkNoYW5uZWxzID0gJHtpc0NoYW5uZWxzTGFzdCA/ICdvdXRCYWNrcHJvcFszXScgOiAnb3V0QmFja3Byb3BbMV0nfTtcbiAgICAgIGxldCBjb29yZFggPSBmaWx0ZXJEaW1zLnggLSAxIC0gcm93IC8gKGZpbHRlckRpbXNbMV0gKiBpbkNoYW5uZWxzKTtcbiAgICAgIGxldCBjb29yZFkgPSBmaWx0ZXJEaW1zLnkgLSAxIC0gKHJvdyAvIGluQ2hhbm5lbHMpICUgZmlsdGVyRGltc1sxXTtcbiAgICAgIGlmICgke1xuICAgICAgICAgIGlzQ2hhbm5lbHNMYXN0ID8gJ3JvdyA8IHVuaWZvcm1zLmRpbUlubmVyICYmIGNvbCA8IHVuaWZvcm1zLmRpbUJPdXRlcicgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3JvdyA8IHVuaWZvcm1zLmRpbUlubmVyICYmIGNvbCA8IHVuaWZvcm1zLmRpbUFPdXRlcid9ICAmJiBjb29yZFggPj0gMCAmJiBjb29yZFkgPj0gMCkge1xuICAgICAgICBsZXQgcm93SW5uZXIgPSByb3cgJSBpbkNoYW5uZWxzO1xuICAgICAgICBsZXQgY29vcmQgPSB2ZWM0PGkzMj4oY29vcmRYLCBjb29yZFksIGNvbCwgcm93SW5uZXIpO1xuICAgICAgICAke2dldFdTbmlwcGV0KGlubmVyRWxlbWVudFNpemUpfVxuICAgICAgfVxuICAgICAgcmV0dXJuICR7dHlwZX0oMC4wKTtcbiAgICAgIGA7XG5cbiAgICAgIGNvbnN0IHthY3RpdmF0aW9uRnVuY3Rpb24sIGFwcGx5QWN0aXZhdGlvbn0gPSBnZXRBY3RpdmF0aW9uU25pcHBldChhdHRyaWJ1dGVzLCB0eXBlKTtcbiAgICAgIGNvbnN0IHVzZXJDb2RlID0gYFxuICAgICAgJHthY3RpdmF0aW9uRnVuY3Rpb259XG4gIGZuIG1tX3JlYWRBKGJhdGNoOiBpMzIsIHJvdyA6IGkzMiwgY29sSW4gOiBpMzIpIC0+ICR7dHlwZX0ge1xuICAgICR7aXNDaGFubmVsc0xhc3QgPyBzYW1wbGVBIDogc2FtcGxlV31cbiAgfVxuXG4gIGZuIG1tX3JlYWRCKGJhdGNoOiBpMzIsIHJvdyA6IGkzMiwgY29sSW4gOiBpMzIpIC0+ICR7dHlwZX0ge1xuICAgICR7aXNDaGFubmVsc0xhc3QgPyBzYW1wbGVXIDogc2FtcGxlQX1cbiAgfVxuXG4gIGZuIG1tX3dyaXRlKGJhdGNoOiBpMzIsIHJvdyA6IGkzMiwgY29sSW4gOiBpMzIsIHZhbHVlSW5wdXQgOiAke3R5cGV9KSB7XG4gICAgbGV0IGNvbCA9IGNvbEluICogJHtpbm5lckVsZW1lbnRTaXplfTtcbiAgICBpZiAocm93IDwgdW5pZm9ybXMuZGltQU91dGVyICYmIGNvbCA8IHVuaWZvcm1zLmRpbUJPdXRlcikge1xuICAgICAgdmFyIHZhbHVlID0gdmFsdWVJbnB1dDtcbiAgICAgIGxldCBvdXRXaWR0aCA9ICR7aXNDaGFubmVsc0xhc3QgPyAnaTMyKHVuaWZvcm1zLnJlc3VsdF9zaGFwZVsyXSknIDogJ2kzMih1bmlmb3Jtcy5yZXN1bHRfc2hhcGVbM10pJ307XG4gICAgICAke2Nvb3JkUmVzU25pcHBldH1cbiAgICAgICR7Ymlhc1NuaXBwZXQoYWRkQmlhcyl9XG4gICAgICAke2FwcGx5QWN0aXZhdGlvbn1cbiAgICAgIHJlc3VsdFtnZXRJbmRleEZyb21Db29yZHM0RChjb29yZHMsIHZlYzQ8aTMyPih1bmlmb3Jtcy5yZXN1bHRfc2hhcGUpKS8ke2lubmVyRWxlbWVudFNpemV9XSA9IHZhbHVlO1xuICAgIH1cbiAgfWA7XG4gICAgICByZXR1cm4gdXNlckNvZGU7XG4gICAgfTtcblxuZXhwb3J0IGNvbnN0IGNyZWF0ZUNvbnYyRFRyYW5zcG9zZU1hdE11bFByb2dyYW1JbmZvID1cbiAgICAoaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10sIGF0dHJpYnV0ZXM6IENvbnZUcmFuc3Bvc2VBdHRyaWJ1dGVzLCBvdXRwdXRTaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sXG4gICAgIGRpbUFPdXRlcjogbnVtYmVyLCBkaW1CT3V0ZXI6IG51bWJlciwgZGltSW5uZXI6IG51bWJlciwgaGFzQmlhczogYm9vbGVhbixcbiAgICAgc2VxdWVudGlhbEFjY2Vzc0J5VGhyZWFkczogYm9vbGVhbik6IFByb2dyYW1JbmZvID0+IHtcbiAgICAgIGNvbnN0IGlzQ2hhbm5lbHNMYXN0ID0gYXR0cmlidXRlcy5mb3JtYXQgPT09ICdOSFdDJztcbiAgICAgIGNvbnN0IGluQ2hhbm5lbHMgPSBpc0NoYW5uZWxzTGFzdCA/IGlucHV0c1swXS5kaW1zWzNdIDogaW5wdXRzWzBdLmRpbXNbMV07XG4gICAgICBjb25zdCBiYXRjaFNpemUgPSBvdXRwdXRTaGFwZVswXTtcbiAgICAgIGNvbnN0IG91dFdpZHRoID0gaXNDaGFubmVsc0xhc3QgPyBvdXRwdXRTaGFwZVsyXSA6IG91dHB1dFNoYXBlWzNdO1xuICAgICAgY29uc3Qgb3V0SGVpZ2h0ID0gaXNDaGFubmVsc0xhc3QgPyBvdXRwdXRTaGFwZVsxXSA6IG91dHB1dFNoYXBlWzJdO1xuICAgICAgY29uc3Qgb3V0Q2hhbm5lbHMgPSBpc0NoYW5uZWxzTGFzdCA/IG91dHB1dFNoYXBlWzNdIDogb3V0cHV0U2hhcGVbMV07XG4gICAgICBjb25zdCBpc1ZlYzQgPVxuICAgICAgICAgIGlzQ2hhbm5lbHNMYXN0ID8gaW5DaGFubmVscyAlIDQgPT09IDAgJiYgb3V0Q2hhbm5lbHMgJSA0ID09PSAwIDogb3V0V2lkdGggJSA0ID09PSAwICYmIG91dENoYW5uZWxzICUgNCA9PT0gMDtcblxuICAgICAgLy8gVE9ETzogZmluZSB0dW5lIHNpemVcbiAgICAgIGNvbnN0IGRpc3BhdGNoWCA9IGlzQ2hhbm5lbHNMYXN0ID8gb3V0Q2hhbm5lbHMgOiBvdXRXaWR0aCAqIG91dEhlaWdodDtcbiAgICAgIGNvbnN0IGRpc3BhdGNoWSA9IGlzQ2hhbm5lbHNMYXN0ID8gb3V0V2lkdGggKiBvdXRIZWlnaHQgOiBvdXRDaGFubmVscztcbiAgICAgIGNvbnN0IHdvcmtHcm91cFNpemU6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyXSA9IGlzVmVjNCA/XG4gICAgICAgICAgWzgsIDgsIDFdIDpcbiAgICAgICAgICBbKGRpc3BhdGNoWCA8PSA0IHx8IGRpc3BhdGNoWSA8PSA0KSA/IDQgOiAxNiwgZGlzcGF0Y2hYID4gNCAmJiBkaXNwYXRjaFkgPD0gNCA/IDQgOiAxNiwgMV07XG4gICAgICBjb25zdCBlbGVtZW50c1BlclRocmVhZCA9XG4gICAgICAgICAgaXNWZWM0ID8gWzQsIDQsIDFdIDogW2Rpc3BhdGNoWCA8PSA0ID8gMSA6IDQsIGRpc3BhdGNoWCA+IDQgJiYgZGlzcGF0Y2hZIDw9IDQgPyAxIDogNCwgMV07XG4gICAgICBjb25zdCBkaXNwYXRjaCA9IFtcbiAgICAgICAgTWF0aC5jZWlsKGRpc3BhdGNoWCAvIHdvcmtHcm91cFNpemVbMF0gLyBlbGVtZW50c1BlclRocmVhZFswXSksXG4gICAgICAgIE1hdGguY2VpbChkaXNwYXRjaFkgLyB3b3JrR3JvdXBTaXplWzFdIC8gZWxlbWVudHNQZXJUaHJlYWRbMV0pLFxuICAgICAgICBNYXRoLmNlaWwoYmF0Y2hTaXplIC8gd29ya0dyb3VwU2l6ZVsyXSAvIGVsZW1lbnRzUGVyVGhyZWFkWzJdKVxuICAgICAgXTtcblxuICAgICAgTE9HX0RFQlVHKCd2ZXJib3NlJywgKCkgPT4gYFtjb252X2JhY2twcm9wX21tX3dlYmdwdV0gZGlzcGF0Y2ggPSAke2Rpc3BhdGNofWApO1xuXG4gICAgICBjb25zdCBpbm5lckVsZW1lbnRTaXplID0gaXNWZWM0ID8gNCA6IDE7XG4gICAgICBjb25zdCB0aWxlSW5uZXIgPSBNYXRoLm1heCh3b3JrR3JvdXBTaXplWzBdICogaW5uZXJFbGVtZW50U2l6ZSwgd29ya0dyb3VwU2l6ZVsxXSk7XG4gICAgICBjb25zdCBjb21wb25lbnRzID0gaXNWZWM0ID8gNCA6IDE7XG4gICAgICBjb25zdCBwcm9ncmFtVW5pZm9ybXM6IFByb2dyYW1Vbmlmb3JtW10gPVxuICAgICAgICAgIFt7dHlwZTogJ2ludDMyJywgZGF0YTogZGltQU91dGVyfSwge3R5cGU6ICdpbnQzMicsIGRhdGE6IGRpbUJPdXRlcn0sIHt0eXBlOiAnaW50MzInLCBkYXRhOiBkaW1Jbm5lcn1dO1xuICAgICAgY29uc3QgeCA9IGlucHV0VmFyaWFibGUoJ3gnLCBpbnB1dHNbMF0uZGF0YVR5cGUsIGlucHV0c1swXS5kaW1zLmxlbmd0aCwgY29tcG9uZW50cyk7XG4gICAgICBjb25zdCB3ID0gaW5wdXRWYXJpYWJsZSgndycsIGlucHV0c1sxXS5kYXRhVHlwZSwgaW5wdXRzWzFdLmRpbXMubGVuZ3RoLCAxKTtcbiAgICAgIGNvbnN0IG91dHB1dCA9IG91dHB1dFZhcmlhYmxlKCdyZXN1bHQnLCBpbnB1dHNbMF0uZGF0YVR5cGUsIG91dHB1dFNoYXBlLmxlbmd0aCwgY29tcG9uZW50cyk7XG4gICAgICBjb25zdCBpbnB1dFZhcmlhYmxlcyA9IFt4LCB3XTtcbiAgICAgIHByb2dyYW1Vbmlmb3Jtcy5wdXNoKC4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKGlucHV0c1swXS5kaW1zKSk7XG4gICAgICBwcm9ncmFtVW5pZm9ybXMucHVzaCguLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhpbnB1dHNbMV0uZGltcykpO1xuXG4gICAgICBsZXQgZGVjbGFyZUZ1bmN0aW9ucyA9ICcnO1xuICAgICAgaWYgKGhhc0JpYXMpIHtcbiAgICAgICAgY29uc3QgYmlhcyA9IGlucHV0VmFyaWFibGUoJ2JpYXMnLCBpbnB1dHNbMl0uZGF0YVR5cGUsIGlucHV0c1syXS5kaW1zLmxlbmd0aCwgY29tcG9uZW50cyk7XG4gICAgICAgIGlucHV0VmFyaWFibGVzLnB1c2goYmlhcyk7XG4gICAgICAgIHByb2dyYW1Vbmlmb3Jtcy5wdXNoKC4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKGlucHV0c1syXS5kaW1zKSk7XG5cbiAgICAgICAgZGVjbGFyZUZ1bmN0aW9ucyArPSBgXG4gICAgICAgIGZuIGdldEJpYXNCeU91dHB1dENvb3Jkcyhjb29yZHMgOiB2ZWM0PGkzMj4pIC0+ICR7aXNWZWM0ID8gJ3ZlYzQ8ZjMyPicgOiAnZjMyJ30ge1xuICAgICAgICAgIHJldHVybiBiaWFzW2Nvb3Jkcy4ke2lzQ2hhbm5lbHNMYXN0ID8gJ3cnIDogJ3knfSR7aXNWZWM0ID8gJy8gNCcgOiAnJ31dO1xuICAgICAgICB9YDtcbiAgICAgIH1cblxuICAgICAgcHJvZ3JhbVVuaWZvcm1zLnB1c2goLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMob3V0cHV0U2hhcGUpKTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZTogJ0NvbnYyRFRyYW5zcG9zZU1hdE11bCcsXG4gICAgICAgIHNoYWRlckNhY2hlOiB7aGludDogYXR0cmlidXRlcy5jYWNoZUtleX0sXG4gICAgICAgIGdldFJ1bkRhdGE6ICgpID0+ICh7XG4gICAgICAgICAgb3V0cHV0czogW3tkaW1zOiBvdXRwdXRTaGFwZSwgZGF0YVR5cGU6IGlucHV0c1swXS5kYXRhVHlwZX1dLFxuICAgICAgICAgIGRpc3BhdGNoR3JvdXA6IHt4OiBkaXNwYXRjaFswXSwgeTogZGlzcGF0Y2hbMV0sIHo6IGRpc3BhdGNoWzJdfSxcbiAgICAgICAgICBwcm9ncmFtVW5pZm9ybXNcbiAgICAgICAgfSksXG4gICAgICAgIGdldFNoYWRlclNvdXJjZTogKHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyKSA9PiBgXG4gICAgICAgICR7dXRpbEZ1bmN0aW9ucygndW5pZm9ybXMucmVzdWx0X3N0cmlkZXMnKX1cbiAgICAgICAgJHtcbiAgICAgICAgICAgIHNoYWRlckhlbHBlci5yZWdpc3RlclVuaWZvcm0oJ2RpbUFPdXRlcicsICdpMzInKVxuICAgICAgICAgICAgICAgIC5yZWdpc3RlclVuaWZvcm0oJ2RpbUJPdXRlcicsICdpMzInKVxuICAgICAgICAgICAgICAgIC5yZWdpc3RlclVuaWZvcm0oJ2RpbUlubmVyJywgJ2kzMicpXG4gICAgICAgICAgICAgICAgLmRlY2xhcmVWYXJpYWJsZXMoLi4uaW5wdXRWYXJpYWJsZXMsIG91dHB1dCl9O1xuICAgICAgICBjb25zdCBvdXRCYWNrcHJvcCA6IHZlYzQ8aTMyPiA9IHZlYzQ8aTMyPigke2lucHV0c1swXS5kaW1zLmpvaW4oJywnKX0pO1xuICAgICAgICBjb25zdCBmaWx0ZXJEaW1zIDogdmVjMjxpMzI+ID0gdmVjMjxpMzI+KCR7YXR0cmlidXRlcy5rZXJuZWxTaGFwZVtpc0NoYW5uZWxzTGFzdCA/IDEgOiAyXX0sICR7XG4gICAgICAgICAgICBhdHRyaWJ1dGVzLmtlcm5lbFNoYXBlW2lzQ2hhbm5lbHNMYXN0ID8gMiA6IDNdfSk7XG4gICAgICAgIGNvbnN0IGVmZmVjdGl2ZUZpbHRlckRpbXMgOiB2ZWMyPGkzMj4gPSBmaWx0ZXJEaW1zICsgdmVjMjxpMzI+KFxuICAgICAgICAgICAgICAke1xuICAgICAgICAgICAgYXR0cmlidXRlcy5kaWxhdGlvbnNbMF0gPD0gMSA/XG4gICAgICAgICAgICAgICAgMCA6XG4gICAgICAgICAgICAgICAgKGF0dHJpYnV0ZXMua2VybmVsU2hhcGVbaXNDaGFubmVsc0xhc3QgPyAxIDogMl0gLSAxKSAqIChhdHRyaWJ1dGVzLmRpbGF0aW9uc1swXSAtIDEpfSxcbiAgICAgICAgICAgICAgJHtcbiAgICAgICAgICAgIGF0dHJpYnV0ZXMuZGlsYXRpb25zWzFdIDw9IDEgP1xuICAgICAgICAgICAgICAgIDAgOlxuICAgICAgICAgICAgICAgIChhdHRyaWJ1dGVzLmtlcm5lbFNoYXBlW2lzQ2hhbm5lbHNMYXN0ID8gMiA6IDNdIC0gMSkgKiAoYXR0cmlidXRlcy5kaWxhdGlvbnNbMV0gLSAxKX0pO1xuICAgICAgICBjb25zdCBwYWRzIDogdmVjMjxpMzI+ID0gdmVjMjxpMzI+KGkzMihlZmZlY3RpdmVGaWx0ZXJEaW1zWzBdKSAtIDEgLSAoJHtcbiAgICAgICAgICAgIGF0dHJpYnV0ZXMucGFkc1swXSArIGF0dHJpYnV0ZXMucGFkc1syXX0pLzIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkzMihlZmZlY3RpdmVGaWx0ZXJEaW1zWzFdKSAtIDEgLSAoJHtcbiAgICAgICAgICAgIGF0dHJpYnV0ZXMucGFkc1sxXSArIGF0dHJpYnV0ZXMucGFkc1szXX0pLzIpO1xuICAgICAgICBjb25zdCBzdHJpZGVzIDogdmVjMjxpMzI+ID0gdmVjMjxpMzI+KCR7YXR0cmlidXRlcy5zdHJpZGVzWzBdfSwgJHthdHRyaWJ1dGVzLnN0cmlkZXNbMV19KTtcbiAgICAgICAgY29uc3QgZGlsYXRpb24gOiB2ZWMyPGkzMj4gPSB2ZWMyPGkzMj4oJHthdHRyaWJ1dGVzLmRpbGF0aW9uc1swXX0sICR7YXR0cmlidXRlcy5kaWxhdGlvbnNbMV19KTtcbiAgICAgICAgY29uc3QgZGltQU91dGVyIDogaTMyID0gJHtkaW1BT3V0ZXJ9O1xuICAgICAgICBjb25zdCBkaW1CT3V0ZXIgOiBpMzIgPSAke2RpbUJPdXRlcn07XG4gICAgICAgIGNvbnN0IGRpbUlubmVyIDogaTMyID0gJHtkaW1Jbm5lcn07XG4gICAgICAgICR7ZGVjbGFyZUZ1bmN0aW9uc31cbiAgICAgICAgJHtjb252MmRUcmFuc3Bvc2VDb21tb25TbmlwcGV0KGlzQ2hhbm5lbHNMYXN0LCBoYXNCaWFzLCBhdHRyaWJ1dGVzLCBpbm5lckVsZW1lbnRTaXplKX1cbiAgICAgICAgJHtcbiAgICAgICAgICAgIGlzVmVjNCA/IG1ha2VNYXRNdWxQYWNrZWRWZWM0U291cmNlKFxuICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzUGVyVGhyZWFkLCB3b3JrR3JvdXBTaXplLCAnZjMyJywgdW5kZWZpbmVkLCAhaXNDaGFubmVsc0xhc3QsIHRpbGVJbm5lcikgOlxuICAgICAgICAgICAgICAgICAgICAgbWFrZU1hdE11bFBhY2tlZFNvdXJjZShcbiAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50c1BlclRocmVhZCwgd29ya0dyb3VwU2l6ZSwgJ2YzMicsIHVuZGVmaW5lZCwgIWlzQ2hhbm5lbHNMYXN0LCB0aWxlSW5uZXIsIGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgIHVuZGVmaW5lZCwgc2VxdWVudGlhbEFjY2Vzc0J5VGhyZWFkcyl9YFxuICAgICAgfTtcbiAgICB9O1xuIiwgIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIxIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cblxuLy8gc2FtcGxlZCBmcm9tIFtAdGVuc29yZmxvdy90ZmpzXSB0ZmpzLWJhY2tlbmQtd2ViZ3B1L3NyYy9jb252X2JhY2twcm9wX3dlYmdwdS50c1xuXG5pbXBvcnQge0xPR19ERUJVR30gZnJvbSAnLi4vLi4vLi4vbG9nJztcbmltcG9ydCB7VGVuc29yVmlld30gZnJvbSAnLi4vLi4vLi4vdGVuc29yLXZpZXcnO1xuaW1wb3J0IHtTaGFwZVV0aWx9IGZyb20gJy4uLy4uLy4uL3V0aWwnO1xuaW1wb3J0IHtQcm9ncmFtSW5mb30gZnJvbSAnLi4vLi4vdHlwZXMnO1xuaW1wb3J0IHtpbnB1dFZhcmlhYmxlLCBvdXRwdXRWYXJpYWJsZSwgU2hhZGVySGVscGVyLCB0ZW5zb3JUeXBlVG9Xc2dsU3RvcmFnZVR5cGV9IGZyb20gJy4uL2NvbW1vbic7XG5pbXBvcnQge0NvbnZUcmFuc3Bvc2VBdHRyaWJ1dGVzfSBmcm9tICcuLi9jb252LXRyYW5zcG9zZSc7XG5cbmNvbnN0IGNyZWF0ZUNvbnZUcmFuc3Bvc2UyRE9wUHJvZ3JhbVNoYWRlclNvdXJjZSA9XG4gICAgKHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyLCBpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSwgYXR0cmlidXRlczogQ29udlRyYW5zcG9zZUF0dHJpYnV0ZXMsXG4gICAgIG91dHB1dFNoYXBlOiByZWFkb25seSBudW1iZXJbXSwgaGFzQmlhczogYm9vbGVhbiwgaXMxRGltZW5zaW9uRGlzcGF0Y2g6IGJvb2xlYW4sIGlzVmVjNCA9IGZhbHNlLFxuICAgICBkYXRhVHlwZTogc3RyaW5nKTogc3RyaW5nID0+IHtcbiAgICAgIGNvbnN0IGlzQ2hhbm5lbHNMYXN0ID0gYXR0cmlidXRlcy5mb3JtYXQgPT09ICdOSFdDJztcbiAgICAgIGNvbnN0IHJvd0RpbSA9IGlzQ2hhbm5lbHNMYXN0ID8gMSA6IDI7XG4gICAgICBjb25zdCBjb2xEaW0gPSBpc0NoYW5uZWxzTGFzdCA/IDIgOiAzO1xuICAgICAgY29uc3QgY2hhbm5lbERpbSA9IGlzQ2hhbm5lbHNMYXN0ID8gMyA6IDE7XG4gICAgICBjb25zdCBvdXRwdXRTaXplID0gU2hhcGVVdGlsLnNpemUob3V0cHV0U2hhcGUpO1xuICAgICAgY29uc3Qgd29ya1BlclRocmVhZCA9IGlzVmVjNCA/IDIgOiAxO1xuICAgICAgY29uc3QgZ3JvdXAgPSBhdHRyaWJ1dGVzLmdyb3VwO1xuICAgICAgY29uc3Qgd1NoYXBlID0gaW5wdXRzWzFdLmRpbXM7XG4gICAgICBjb25zdCBpbnB1dENoYW5uZWxzUGVyR3JvdXAgPSB3U2hhcGVbMF0gLyBncm91cDtcbiAgICAgIGNvbnN0IG91dHB1dENoYW5uZWxzUGVyR3JvdXAgPSB3U2hhcGVbMV07XG5cbiAgICAgIGxldCBkZWNsYXJlRnVuY3Rpb25zID0gYFxuICBmbiBzZXRPdXRwdXRBdEluZGV4KGZsYXRJbmRleCA6IHUzMiwgdmFsdWUgOiAke2lzVmVjNCA/IGB2ZWM0PCR7ZGF0YVR5cGV9PmAgOiBkYXRhVHlwZX0pIHtcbiAgICByZXN1bHRbZmxhdEluZGV4XSA9ICR7aXNWZWM0ID8gYHZlYzQ8JHtkYXRhVHlwZX0+YCA6IGRhdGFUeXBlfSh2YWx1ZSk7XG4gIH1gO1xuICAgICAgaWYgKGhhc0JpYXMpIHtcbiAgICAgICAgZGVjbGFyZUZ1bmN0aW9ucyArPSBgXG4gICAgZm4gZ2V0Qmlhc0J5T3V0cHV0Q29vcmRzKGNvb3JkcyA6IHZlYzQ8dTMyPikgLT4gJHtpc1ZlYzQgPyBgdmVjNDwke2RhdGFUeXBlfT5gIDogZGF0YVR5cGV9IHtcbiAgICAgIHJldHVybiBiaWFzW2Nvb3Jkcy4ke2lzQ2hhbm5lbHNMYXN0ID8gJ3cnIDogJ3knfSR7aXNWZWM0ID8gJy8gNCcgOiAnJ31dO1xuICAgIH1gO1xuICAgICAgfVxuICAgICAgY29uc3QgY29tcG9uZW50cyA9IGlzVmVjNCA/IDQgOiAxO1xuICAgICAgY29uc3QgdyA9IGlucHV0VmFyaWFibGUoJ1cnLCBpbnB1dHNbMV0uZGF0YVR5cGUsIGlucHV0c1sxXS5kaW1zLCBjb21wb25lbnRzKTtcbiAgICAgIGNvbnN0IGR5ID0gaW5wdXRWYXJpYWJsZSgnRHknLCBpbnB1dHNbMF0uZGF0YVR5cGUsIGlucHV0c1swXS5kaW1zLCBjb21wb25lbnRzKTtcbiAgICAgIGNvbnN0IGlucHV0VmFyaWFibGVzID0gW2R5LCB3XTtcbiAgICAgIGlmIChoYXNCaWFzKSB7XG4gICAgICAgIGlucHV0VmFyaWFibGVzLnB1c2goaW5wdXRWYXJpYWJsZSgnYmlhcycsIGlucHV0c1syXS5kYXRhVHlwZSwgW291dHB1dFNoYXBlW2NoYW5uZWxEaW1dXSwgY29tcG9uZW50cykpO1xuICAgICAgfVxuICAgICAgY29uc3Qgb3V0cHV0ID0gb3V0cHV0VmFyaWFibGUoJ3Jlc3VsdCcsIGlucHV0c1swXS5kYXRhVHlwZSwgb3V0cHV0U2hhcGUsIGNvbXBvbmVudHMpO1xuICAgICAgY29uc3QgY29kZVNuaXBwZXQ0ID0gYHtcbiAgICAgICAgbGV0IGJhdGNoOiB1MzIgPSAke2lzMURpbWVuc2lvbkRpc3BhdGNoID8gJ2dsb2JhbF9pZC56JyA6ICd3b3JrZ3JvdXBfaWQueid9IC8gb3V0U2hhcGVbMV07XG4gICAgICAgIGxldCByID0gJHtpczFEaW1lbnNpb25EaXNwYXRjaCA/ICdnbG9iYWxfaWQueicgOiAnd29ya2dyb3VwX2lkLnonfSAlIG91dFNoYXBlWzFdO1xuICAgICAgICBsZXQgYyA9ICR7aXMxRGltZW5zaW9uRGlzcGF0Y2ggPyAnZ2xvYmFsX2lkLnknIDogJ3dvcmtncm91cF9pZC55J30gKiAke3dvcmtQZXJUaHJlYWR9O1xuICAgICAgICBsZXQgZDE6IHUzMiA9ICR7aXMxRGltZW5zaW9uRGlzcGF0Y2ggPyAnZ2xvYmFsX2lkLngnIDogJ3dvcmtncm91cF9pZC54J30gKiA0O1xuXG4gICAgICAgIGxldCBkeUNvcm5lciA9IHZlYzI8aTMyPihpMzIociksIGkzMihjKSkgLSB2ZWMyPGkzMj4ocGFkcyk7XG5cbiAgICAgICAgLy8gQ29udm9sdmUgZHkoPywgPywgZDIpIHdpdGggdyg6LCA6LCBkMSwgZDIpIHRvIGNvbXB1dGUgZHgoeFIsIHhDLCBkMSkuXG4gICAgICAgIC8vID8gPSB0byBiZSBkZXRlcm1pbmVkLiA6ID0gYWNyb3NzIGFsbCB2YWx1ZXMgaW4gdGhhdCBheGlzLlxuICAgICAgICB2YXIgZG90UHJvZDogYXJyYXk8dmVjNDwke2RhdGFUeXBlfT4sICR7d29ya1BlclRocmVhZH0+O1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8ICR7d29ya1BlclRocmVhZH07IGkrKykge1xuICAgICAgICAgIGRvdFByb2RbaV0gPSB2ZWM0PCR7ZGF0YVR5cGV9PigwLjApO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIHdSOiB1MzIgPSAwOyB3UiA8IGZpbHRlckRpbXNbMF07IHdSID0gd1IgKyAxKSB7XG4gICAgICAgICAgdmFyIGR5UiA9ICgke2RhdGFUeXBlfShkeUNvcm5lci54KSArICR7ZGF0YVR5cGV9KHdSKSkgLyAke2RhdGFUeXBlfShzdHJpZGVzLngpO1xuICAgICAgICAgIGxldCB3UlBlcm0gPSBmaWx0ZXJEaW1zWzBdIC0gMSAtIHdSO1xuICAgICAgICAgIGlmIChkeVIgPCAwLjAgfHwgZHlSID49ICR7ZGF0YVR5cGV9KG91dEJhY2twcm9wWzFdKSB8fFxuICAgICAgICAgICAgICBmcmFjdChkeVIpID4gMC4wIHx8IHdSUGVybSA8IDApIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsZXQgaWR5UjogdTMyID0gdTMyKGR5Uik7XG5cbiAgICAgICAgICBmb3IgKHZhciB3QzogdTMyID0gMDsgd0MgPCBmaWx0ZXJEaW1zWzFdOyB3QyA9IHdDICsgMSkge1xuICAgICAgICAgICAgbGV0IGR5QyA9ICgke2RhdGFUeXBlfShkeUNvcm5lci55KSArICR7ZGF0YVR5cGV9KHdDKSkgLyAke2RhdGFUeXBlfShzdHJpZGVzLnkpO1xuICAgICAgICAgICAgbGV0IGR5QzIgPSAoJHtkYXRhVHlwZX0oZHlDb3JuZXIueSkgKyAxLjAgKyAke2RhdGFUeXBlfSh3QykpIC8gJHtkYXRhVHlwZX0oc3RyaWRlcy55KTtcbiAgICAgICAgICAgIGxldCB3Q1Blcm0gPSBmaWx0ZXJEaW1zWzFdIC0gMSAtIHdDO1xuICAgICAgICAgICAgaWYgKHdDUGVybSA8IDApIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgYkR5Q1ZhbCA9IHRydWU7XG4gICAgICAgICAgICB2YXIgYkR5Q1ZhbDIgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKGR5QyA8IDAuMCB8fCBkeUMgPj0gJHtkYXRhVHlwZX0ob3V0QmFja3Byb3BbMl0pIHx8XG4gICAgICAgICAgICAgICAgZnJhY3QoZHlDKSA+IDAuMCkge1xuICAgICAgICAgICAgICBiRHlDVmFsID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZHlDMiA8IDAuMCB8fCBkeUMyID49ICR7ZGF0YVR5cGV9KG91dEJhY2twcm9wWzJdKSB8fFxuICAgICAgICAgICAgICAgIGZyYWN0KGR5QzIpID4gMC4wKSB7XG4gICAgICAgICAgICAgIGJEeUNWYWwyID0gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxldCBpZHlDOiB1MzIgPSB1MzIoZHlDKTtcbiAgICAgICAgICAgIGxldCBpZHlDMjogdTMyID0gdTMyKGR5QzIpO1xuICAgICAgICAgICAgaWYgKGJEeUNWYWwgJiYgYkR5Q1ZhbDIpIHtcbiAgICAgICAgICAgICAgbGV0IGQyTGVuZ3RoID0gb3V0QmFja3Byb3BbM107XG4gICAgICAgICAgICAgIGZvciAodmFyIGQyIDp1MzIgPSAwOyBkMiA8IGQyTGVuZ3RoOyBkMiA9IGQyICsgNCkge1xuICAgICAgICAgICAgICAgIGxldCB3VmFsdWUwID0gJHt3LmdldCgndTMyKHdSUGVybSknLCAndTMyKHdDUGVybSknLCAnZDEnLCAnZDInKX07XG4gICAgICAgICAgICAgICAgbGV0IHdWYWx1ZTEgPSAke3cuZ2V0KCd1MzIod1JQZXJtKScsICd1MzIod0NQZXJtKScsICdkMSArIDEnLCAnZDInKX07XG4gICAgICAgICAgICAgICAgbGV0IHdWYWx1ZTIgPSAke3cuZ2V0KCd1MzIod1JQZXJtKScsICd1MzIod0NQZXJtKScsICdkMSArIDInLCAnZDInKX07XG4gICAgICAgICAgICAgICAgbGV0IHdWYWx1ZTMgPSAke3cuZ2V0KCd1MzIod1JQZXJtKScsICd1MzIod0NQZXJtKScsICdkMSArIDMnLCAnZDInKX07XG5cbiAgICAgICAgICAgICAgICB2YXIgeFZhbHVlID0gJHtkeS5nZXQoJ2JhdGNoJywgJ2lkeVInLCAnaWR5QycsICdkMicpfTtcbiAgICAgICAgICAgICAgICBsZXQgdG1wdmFsID0gdmVjNDwke2RhdGFUeXBlfT4oZG90KHhWYWx1ZSwgd1ZhbHVlMCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvdCh4VmFsdWUsIHdWYWx1ZTEpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb3QoeFZhbHVlLCB3VmFsdWUyKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG90KHhWYWx1ZSwgd1ZhbHVlMykpO1xuICAgICAgICAgICAgICAgIGRvdFByb2RbMF0gPSBkb3RQcm9kWzBdICsgdG1wdmFsO1xuXG4gICAgICAgICAgICAgICAgeFZhbHVlID0gICR7ZHkuZ2V0KCdiYXRjaCcsICdpZHlSJywgJ2lkeUMyJywgJ2QyJyl9O1xuXG4gICAgICAgICAgICAgICAgZG90UHJvZFsxXSA9IGRvdFByb2RbMV0gKyB2ZWM0PCR7ZGF0YVR5cGV9Pihkb3QoeFZhbHVlLCB3VmFsdWUwKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb3QoeFZhbHVlLCB3VmFsdWUxKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb3QoeFZhbHVlLCB3VmFsdWUyKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb3QoeFZhbHVlLCB3VmFsdWUzKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYkR5Q1ZhbCkge1xuICAgICAgICAgICAgICBsZXQgZDJMZW5ndGggPSBvdXRCYWNrcHJvcFske2NoYW5uZWxEaW19XTtcbiAgICAgICAgICAgICAgZm9yICh2YXIgZDI6IHUzMiA9IDA7IGQyIDwgZDJMZW5ndGg7IGQyID0gZDIgKyA0KSB7XG4gICAgICAgICAgICAgICAgbGV0IHdWYWx1ZTAgPSAke3cuZ2V0KCd1MzIod1JQZXJtKScsICd1MzIod0NQZXJtKScsICdkMScsICdkMicpfTtcbiAgICAgICAgICAgICAgICBsZXQgd1ZhbHVlMSA9ICR7dy5nZXQoJ3UzMih3UlBlcm0pJywgJ3UzMih3Q1Blcm0pJywgJ2QxICsgMScsICdkMicpfTtcbiAgICAgICAgICAgICAgICBsZXQgd1ZhbHVlMiA9ICR7dy5nZXQoJ3UzMih3UlBlcm0pJywgJ3UzMih3Q1Blcm0pJywgJ2QxICsgMicsICdkMicpfTtcbiAgICAgICAgICAgICAgICBsZXQgd1ZhbHVlMyA9ICR7dy5nZXQoJ3UzMih3UlBlcm0pJywgJ3UzMih3Q1Blcm0pJywgJ2QxICsgMycsICdkMicpfTtcblxuICAgICAgICAgICAgICAgIHZhciB4VmFsdWUgPSAke2R5LmdldCgnYmF0Y2gnLCAnaWR5UicsICdpZHlDJywgJ2QyJyl9O1xuICAgICAgICAgICAgICAgIGxldCB0bXB2YWwgPSB2ZWM0PCR7ZGF0YVR5cGV9Pihkb3QoeFZhbHVlLCB3VmFsdWUwKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG90KHhWYWx1ZSwgd1ZhbHVlMSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvdCh4VmFsdWUsIHdWYWx1ZTIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb3QoeFZhbHVlLCB3VmFsdWUzKSk7XG4gICAgICAgICAgICAgICAgZG90UHJvZFswXSA9IGRvdFByb2RbMF0gKyB0bXB2YWw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYkR5Q1ZhbDIpIHtcbiAgICAgICAgICAgICAgbGV0IGQyTGVuZ3RoID0gb3V0QmFja3Byb3BbM107XG4gICAgICAgICAgICAgIGZvciAodmFyIGQyOiB1MzIgPSAwOyBkMiA8IGQyTGVuZ3RoOyBkMiA9IGQyICsgNCkge1xuICAgICAgICAgICAgICAgIGxldCB3VmFsdWUwID0gJHt3LmdldCgndTMyKHdSUGVybSknLCAndTMyKHdDUGVybSknLCAnZDEnLCAnZDInKX07XG4gICAgICAgICAgICAgICAgbGV0IHdWYWx1ZTEgPSAke3cuZ2V0KCd1MzIod1JQZXJtKScsICd1MzIod0NQZXJtKScsICdkMSArIDEnLCAnZDInKX07XG4gICAgICAgICAgICAgICAgbGV0IHdWYWx1ZTIgPSAke3cuZ2V0KCd1MzIod1JQZXJtKScsICd1MzIod0NQZXJtKScsICdkMSArIDInLCAnZDInKX07XG4gICAgICAgICAgICAgICAgbGV0IHdWYWx1ZTMgPSAke3cuZ2V0KCd1MzIod1JQZXJtKScsICd1MzIod0NQZXJtKScsICdkMSArIDMnLCAnZDInKX07XG5cbiAgICAgICAgICAgICAgICB2YXIgeFZhbHVlID0gJHtkeS5nZXQoJ2JhdGNoJywgJ2lkeVInLCAnaWR5QzInLCAnZDInKX07XG4gICAgICAgICAgICAgICAgbGV0IHRtcHZhbCA9IHZlYzQ8JHtkYXRhVHlwZX0+KGRvdCh4VmFsdWUsIHdWYWx1ZTApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb3QoeFZhbHVlLCB3VmFsdWUxKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG90KHhWYWx1ZSwgd1ZhbHVlMiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvdCh4VmFsdWUsIHdWYWx1ZTMpKTtcbiAgICAgICAgICAgICAgICBkb3RQcm9kWzFdID0gZG90UHJvZFsxXSArIHRtcHZhbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGk6IHUzMiA9IDA7IGkgPCAke3dvcmtQZXJUaHJlYWR9OyBpID0gaSArIDEpIHtcbiAgICAgICAgICBsZXQgdmFsdWUgPSBkb3RQcm9kW2ldICsgJHtoYXNCaWFzID8gJ2JpYXNbYytpXScgOiBgdmVjNDwke2RhdGFUeXBlfT4oMC4wKWB9O1xuICAgICAgICAgICR7b3V0cHV0LnNldCgnYmF0Y2gnLCAncicsICdjICsgaScsICdkMScsICd2YWx1ZScpfTtcbiAgICAgICAgfVxuICAgICAgfWA7XG4gICAgICBjb25zdCBjb2RlU25pcHBldCA9IGBcbiAgICAgICAgICBsZXQgb3V0cHV0SW5kaWNlcyA9ICR7b3V0cHV0Lm9mZnNldFRvSW5kaWNlcygnZ2xvYmFsX2lkeCcpfTtcbiAgICAgICAgICBsZXQgYmF0Y2ggPSAke291dHB1dC5pbmRpY2VzR2V0KCdvdXRwdXRJbmRpY2VzJywgMCl9O1xuICAgICAgICAgIGxldCBkMSA9ICR7b3V0cHV0LmluZGljZXNHZXQoJ291dHB1dEluZGljZXMnLCBjaGFubmVsRGltKX07XG4gICAgICAgICAgbGV0IHIgPSAke291dHB1dC5pbmRpY2VzR2V0KCdvdXRwdXRJbmRpY2VzJywgcm93RGltKX07XG4gICAgICAgICAgbGV0IGMgPSAke291dHB1dC5pbmRpY2VzR2V0KCdvdXRwdXRJbmRpY2VzJywgY29sRGltKX07XG4gICAgICAgICAgbGV0IGR5Q29ybmVyID0gdmVjMjxpMzI+KGkzMihyKSwgaTMyKGMpKSAtIHBhZHM7XG4gICAgICAgICAgbGV0IGR5UkNvcm5lciA9IGR5Q29ybmVyLng7XG4gICAgICAgICAgbGV0IGR5Q0Nvcm5lciA9IGR5Q29ybmVyLnk7XG4gICAgICAgICAgbGV0IGdyb3VwSWQgPSBkMSAvICR7b3V0cHV0Q2hhbm5lbHNQZXJHcm91cH07XG4gICAgICAgICAgbGV0IHdPdXRDaGFubmVsID0gZDEgLSBncm91cElkICogJHtvdXRwdXRDaGFubmVsc1Blckdyb3VwfTtcbiAgICAgICAgICAvLyBDb252b2x2ZSBkeSg/LCA/LCBkMikgd2l0aCB3KDosIDosIGQxLCBkMikgdG8gY29tcHV0ZSBkeCh4UiwgeEMsIGQxKS5cbiAgICAgICAgICAvLyA/ID0gdG8gYmUgZGV0ZXJtaW5lZC4gOiA9IGFjcm9zcyBhbGwgdmFsdWVzIGluIHRoYXQgYXhpcy5cbiAgICAgICAgICB2YXIgZG90UHJvZCA9ICR7ZGF0YVR5cGV9KDAuMCk7XG4gICAgICAgICAgZm9yICh2YXIgd1I6IHUzMiA9IDA7IHdSIDwgZWZmZWN0aXZlRmlsdGVyRGltcy54OyB3UiA9IHdSICsgMSkge1xuICAgICAgICAgICAgaWYgKHdSICUgZGlsYXRpb25zLnggIT0gMCkge1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBkeVIgPSAoJHtkYXRhVHlwZX0oZHlSQ29ybmVyKSArICR7ZGF0YVR5cGV9KHdSKSkgLyAke2RhdGFUeXBlfShzdHJpZGVzWzBdKTtcbiAgICAgICAgICAgIGxldCB3UlBlcm0gPSBmaWx0ZXJEaW1zLnggLSAxIC0gd1IgLyBkaWxhdGlvbnMueDtcbiAgICAgICAgICAgIGlmIChkeVIgPCAwLjAgfHwgZHlSID49ICR7ZGF0YVR5cGV9KG91dEJhY2twcm9wWyR7cm93RGltfV0pIHx8IGZyYWN0KGR5UikgPiAwLjAgfHxcbiAgICAgICAgICAgICAgICB3UlBlcm0gPCAwKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGlkeVI6IHUzMiA9IHUzMihkeVIpO1xuXG4gICAgICAgICAgICBmb3IgKHZhciB3QzogdTMyID0gMDsgd0MgPCBlZmZlY3RpdmVGaWx0ZXJEaW1zLnk7IHdDID0gd0MgKyAxKSB7XG4gICAgICAgICAgICAgIGlmICh3QyAlIGRpbGF0aW9ucy55ICE9IDApIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBsZXQgZHlDID0gKCR7ZGF0YVR5cGV9KGR5Q0Nvcm5lcikgKyAke2RhdGFUeXBlfSh3QykpIC8gJHtkYXRhVHlwZX0oc3RyaWRlcy55KTtcbiAgICAgICAgICAgICAgbGV0IHdDUGVybSA9IGZpbHRlckRpbXMueSAtIDEgLSB3QyAvIGRpbGF0aW9ucy55O1xuICAgICAgICAgICAgICBpZiAoZHlDIDwgMC4wIHx8IGR5QyA+PSAke2RhdGFUeXBlfShvdXRCYWNrcHJvcFske2NvbERpbX1dKSB8fFxuICAgICAgICAgICAgICAgICAgZnJhY3QoZHlDKSA+IDAuMCB8fCB3Q1Blcm0gPCAwKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgbGV0IGlkeUM6IHUzMiA9IHUzMihkeUMpO1xuICAgICAgICAgICAgICB2YXIgaW5wdXRDaGFubmVsID0gZ3JvdXBJZCAqICR7aW5wdXRDaGFubmVsc1Blckdyb3VwfTtcbiAgICAgICAgICAgICAgZm9yICh2YXIgZDI6IHUzMiA9IDA7IGQyIDwgJHtpbnB1dENoYW5uZWxzUGVyR3JvdXB9OyBkMiA9IGQyICsgMSkge1xuICAgICAgICAgICAgICAgIGxldCB4VmFsdWUgPSAke1xuICAgICAgICAgIGlzQ2hhbm5lbHNMYXN0ID8gZHkuZ2V0KCdiYXRjaCcsICdpZHlSJywgJ2lkeUMnLCAnaW5wdXRDaGFubmVsJykgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgZHkuZ2V0KCdiYXRjaCcsICdpbnB1dENoYW5uZWwnLCAnaWR5UicsICdpZHlDJyl9O1xuICAgICAgICAgICAgICAgIGxldCB3VmFsdWUgPSAke3cuZ2V0KCdpbnB1dENoYW5uZWwnLCAnd091dENoYW5uZWwnLCAndTMyKHdSUGVybSknLCAndTMyKHdDUGVybSknKX07XG4gICAgICAgICAgICAgICAgZG90UHJvZCA9IGRvdFByb2QgKyB4VmFsdWUgKiB3VmFsdWU7XG4gICAgICAgICAgICAgICAgaW5wdXRDaGFubmVsID0gaW5wdXRDaGFubmVsICsgMTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBsZXQgdmFsdWUgPSBkb3RQcm9kICsgJHtoYXNCaWFzID8gJ2JpYXNbZDFdJyA6IGAke2RhdGFUeXBlfSgwLjApYH07XG4gICAgICAgICAgJHtvdXRwdXQuc2V0QnlPZmZzZXQoJ2dsb2JhbF9pZHgnLCAndmFsdWUnKX07XG4gICAgICAgIGA7XG5cbiAgICAgIHJldHVybiBgXG4gICR7c2hhZGVySGVscGVyLmRlY2xhcmVWYXJpYWJsZXMoLi4uaW5wdXRWYXJpYWJsZXMsIG91dHB1dCl9XG4gICR7ZGVjbGFyZUZ1bmN0aW9uc31cbiAgY29uc3Qgb3V0U2hhcGUgOiB2ZWM0PHUzMj4gPSB2ZWM0PHUzMj4oJHtvdXRwdXRTaGFwZS5qb2luKCcsJyl9KTtcbiAgY29uc3Qgb3V0QmFja3Byb3AgOiB2ZWM0PHUzMj4gPSB2ZWM0PHUzMj4oJHtpbnB1dHNbMF0uZGltcy5qb2luKCcsJyl9KTtcbiAgY29uc3Qgc3RyaWRlcyA6IHZlYzI8dTMyPiA9IHZlYzI8dTMyPigke2F0dHJpYnV0ZXMuc3RyaWRlc1swXX0sICR7YXR0cmlidXRlcy5zdHJpZGVzWzFdfSk7XG4gIGNvbnN0IGZpbHRlckRpbXMgOiB2ZWMyPHUzMj4gPSB2ZWMyPHUzMj4oJHthdHRyaWJ1dGVzLmtlcm5lbFNoYXBlW2lzQ2hhbm5lbHNMYXN0ID8gMSA6IDJdfSwgJHtcbiAgICAgICAgICBhdHRyaWJ1dGVzLmtlcm5lbFNoYXBlW2lzQ2hhbm5lbHNMYXN0ID8gMiA6IDNdfSk7XG4gIGNvbnN0IGRpbGF0aW9ucyA6IHZlYzI8dTMyPiA9IHZlYzI8dTMyPigke2F0dHJpYnV0ZXMuZGlsYXRpb25zWzBdfSwgJHthdHRyaWJ1dGVzLmRpbGF0aW9uc1sxXX0pO1xuICBjb25zdCBlZmZlY3RpdmVGaWx0ZXJEaW1zIDogdmVjMjx1MzI+ID0gZmlsdGVyRGltcyArIHZlYzI8dTMyPihcbiAgICAgICAgICAke1xuICAgICAgICAgIGF0dHJpYnV0ZXMuZGlsYXRpb25zWzBdIDw9IDEgP1xuICAgICAgICAgICAgICAwIDpcbiAgICAgICAgICAgICAgKGF0dHJpYnV0ZXMua2VybmVsU2hhcGVbaXNDaGFubmVsc0xhc3QgPyAxIDogMl0gLSAxKSAqIChhdHRyaWJ1dGVzLmRpbGF0aW9uc1swXSAtIDEpfSxcbiAgICAgICAgICAke1xuICAgICAgICAgIGF0dHJpYnV0ZXMuZGlsYXRpb25zWzFdIDw9IDEgP1xuICAgICAgICAgICAgICAwIDpcbiAgICAgICAgICAgICAgKGF0dHJpYnV0ZXMua2VybmVsU2hhcGVbaXNDaGFubmVsc0xhc3QgPyAyIDogM10gLSAxKSAqIChhdHRyaWJ1dGVzLmRpbGF0aW9uc1sxXSAtIDEpfSk7XG4gIGNvbnN0IHBhZHMgOiB2ZWMyPGkzMj4gPSB2ZWMyPGkzMj4oaTMyKGVmZmVjdGl2ZUZpbHRlckRpbXNbMF0pIC0gMSAtICgke2F0dHJpYnV0ZXMucGFkc1swXSArIGF0dHJpYnV0ZXMucGFkc1syXX0pLzIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaTMyKGVmZmVjdGl2ZUZpbHRlckRpbXNbMV0pIC0gMSAtICgke2F0dHJpYnV0ZXMucGFkc1sxXSArIGF0dHJpYnV0ZXMucGFkc1szXX0pLzIpO1xuICAgICR7c2hhZGVySGVscGVyLm1haW5TdGFydCgpfVxuICAgICR7c2hhZGVySGVscGVyLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMob3V0cHV0U2l6ZSl9O1xuICAke2lzVmVjNCA/IGNvZGVTbmlwcGV0NCA6IGNvZGVTbmlwcGV0fX1gO1xuICAgIH07XG5cbmV4cG9ydCBjb25zdCBjcmVhdGVDb252VHJhbnNwb3NlMkRQcm9ncmFtSW5mbyA9XG4gICAgKGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdLCBhdHRyaWJ1dGVzOiBDb252VHJhbnNwb3NlQXR0cmlidXRlcyxcbiAgICAgc3F1ZWV6ZU91dHB1dFNoYXBlRnVuY3Rpb24/OiAoc2hhcGU6IHJlYWRvbmx5IG51bWJlcltdKSA9PiBudW1iZXJbXSk6IFByb2dyYW1JbmZvID0+IHtcbiAgICAgIGNvbnN0IGhhc0JpYXMgPSBpbnB1dHMubGVuZ3RoID4gMjtcbiAgICAgIC8vIGNvbnN0IGlzQ2hhbm5lbHNMYXN0ID0gYXR0cmlidXRlcy5mb3JtYXQgPT09ICdOSFdDJztcbiAgICAgIGNvbnN0IG91dHB1dFNoYXBlID0gYXR0cmlidXRlcy5vdXRwdXRTaGFwZTtcbiAgICAgIGNvbnN0IG91dHB1dFNpemUgPSBTaGFwZVV0aWwuc2l6ZShvdXRwdXRTaGFwZSk7XG5cbiAgICAgIC8vIGNvbnN0IGluQ2hhbm5lbHMgPSBpbnB1dHNbMF0uZGltc1tpc0NoYW5uZWxzTGFzdCA/IDMgOiAxXTtcbiAgICAgIC8vIFRPRE8gRW5hYmxlIGlzVmVjNCBmb3IgcGVyZm9ybWFuY2VcbiAgICAgIC8vIERpc2FibGVkIGR1ZSB0byB3ZWlnaHQgbWF0cml4IGxheW91dCBpc3N1ZVxuICAgICAgLy8gY29uc3QgaXNWZWM0ID0gYXR0cmlidXRlcy5ncm91cCA9PT0gMSAmJiBpc0NoYW5uZWxzTGFzdCAmJiBpbkNoYW5uZWxzICUgNCA9PT0gMCAmJiBvdXRDaGFubmVscyAlIDQgPT09IDA7XG4gICAgICBjb25zdCBkaXNwYXRjaCA9IFtcbiAgICAgICAgTWF0aC5jZWlsKG91dHB1dFNpemUgLyA2NCksXG4gICAgICAgIDEsXG4gICAgICAgIDEsXG4gICAgICBdO1xuICAgICAgTE9HX0RFQlVHKCd2ZXJib3NlJywgKCkgPT4gYFtjb252MmRfYmFja3Byb3Bfd2ViZ3B1XSBkaXNwYXRjaCA9ICR7ZGlzcGF0Y2h9YCk7XG5cbiAgICAgIGNvbnN0IGRhdGFUeXBlID0gdGVuc29yVHlwZVRvV3NnbFN0b3JhZ2VUeXBlKGlucHV0c1swXS5kYXRhVHlwZSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBuYW1lOiAnQ29udlRyYW5zcG9zZTJEJyxcbiAgICAgICAgc2hhZGVyQ2FjaGU6IHtoaW50OiBhdHRyaWJ1dGVzLmNhY2hlS2V5fSxcbiAgICAgICAgZ2V0UnVuRGF0YTogKCkgPT4gKHtcbiAgICAgICAgICBkaXNwYXRjaEdyb3VwOiB7eDogZGlzcGF0Y2hbMF0sIHk6IGRpc3BhdGNoWzFdLCB6OiBkaXNwYXRjaFsyXX0sXG4gICAgICAgICAgb3V0cHV0czogW3tcbiAgICAgICAgICAgIGRpbXM6IHNxdWVlemVPdXRwdXRTaGFwZUZ1bmN0aW9uID8gc3F1ZWV6ZU91dHB1dFNoYXBlRnVuY3Rpb24ob3V0cHV0U2hhcGUpIDogb3V0cHV0U2hhcGUsXG4gICAgICAgICAgICBkYXRhVHlwZTogaW5wdXRzWzBdLmRhdGFUeXBlXG4gICAgICAgICAgfV1cbiAgICAgICAgfSksXG4gICAgICAgIGdldFNoYWRlclNvdXJjZTogKHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyKSA9PiBjcmVhdGVDb252VHJhbnNwb3NlMkRPcFByb2dyYW1TaGFkZXJTb3VyY2UoXG4gICAgICAgICAgICBzaGFkZXJIZWxwZXIsIGlucHV0cywgYXR0cmlidXRlcywgb3V0cHV0U2hhcGUsIGhhc0JpYXMsIGRpc3BhdGNoWzFdID09PSAxICYmIGRpc3BhdGNoWzJdID09PSAxLCBmYWxzZSxcbiAgICAgICAgICAgIGRhdGFUeXBlKSxcbiAgICAgIH07XG4gICAgfTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtUZW5zb3JWaWV3fSBmcm9tICcuLi8uLi90ZW5zb3Itdmlldyc7XG5pbXBvcnQge2NyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleX0gZnJvbSAnLi4vYXR0cmlidXRlLXdpdGgtY2FjaGUta2V5JztcbmltcG9ydCB7Q29tcHV0ZUNvbnRleHR9IGZyb20gJy4uL3R5cGVzJztcblxuaW1wb3J0IHtjcmVhdGVDb252MkRUcmFuc3Bvc2VNYXRNdWxQcm9ncmFtSW5mb30gZnJvbSAnLi8zcmQtcGFydHkvY29udl9iYWNrcHJvcF9tbV93ZWJncHUnO1xuaW1wb3J0IHtjcmVhdGVDb252VHJhbnNwb3NlMkRQcm9ncmFtSW5mb30gZnJvbSAnLi8zcmQtcGFydHkvY29udl9iYWNrcHJvcF93ZWJncHUnO1xuaW1wb3J0IHtDb252QXR0cmlidXRlc30gZnJvbSAnLi9jb252JztcbmltcG9ydCB7cGFyc2VJbnRlcm5hbEFjdGl2YXRpb25BdHRyaWJ1dGVzfSBmcm9tICcuL2Z1c2UtdXRpbHMnO1xuaW1wb3J0IHtjcmVhdGVUcmFuc3Bvc2VQcm9ncmFtSW5mb30gZnJvbSAnLi90cmFuc3Bvc2UnO1xuXG5jb25zdCBjb21wdXRlVG90YWxQYWQgPVxuICAgIChpbkRpbTogbnVtYmVyLCBzdHJpZGU6IG51bWJlciwgYWRqOiBudW1iZXIsIGtlcm5lbDogbnVtYmVyLCBkaWxhdGlvbjogbnVtYmVyLCBvdXRTaXplOiBudW1iZXIpID0+XG4gICAgICAgIChpbkRpbSAtIDEpICogc3RyaWRlICsgYWRqICsgKGtlcm5lbCAtIDEpICogZGlsYXRpb24gKyAxIC0gb3V0U2l6ZTtcblxuY29uc3QgZGlzdHJpYnV0ZVBhZGRpbmcgPSAodG90YWxQYWQ6IG51bWJlciwgYXV0b1BhZDogc3RyaW5nLCBwYWRzOiBudW1iZXJbXSwgaGVhZDogbnVtYmVyLCB0YWlsOiBudW1iZXIpID0+IHtcbiAgY29uc3Qgc21hbGxQYWQgPSBNYXRoLmZsb29yKHRvdGFsUGFkIC8gMik7XG4gIGlmIChhdXRvUGFkID09PSAnU0FNRV9VUFBFUicpIHtcbiAgICBwYWRzW2hlYWRdID0gc21hbGxQYWQ7XG4gICAgcGFkc1t0YWlsXSA9IHRvdGFsUGFkIC0gc21hbGxQYWQ7XG4gIH0gZWxzZSBpZiAoYXV0b1BhZCA9PT0gJ1NBTUVfTE9XRVInKSB7XG4gICAgcGFkc1toZWFkXSA9IHRvdGFsUGFkIC0gc21hbGxQYWQ7XG4gICAgcGFkc1t0YWlsXSA9IHNtYWxsUGFkO1xuICB9XG59O1xuXG5jb25zdCBjYWxjdWxhdGVPdXRwdXRTaGFwZUFuZFBhZHMgPVxuICAgIChpbnB1dFNoYXBlOiByZWFkb25seSBudW1iZXJbXSwga2VybmVsU2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLCBkaWxhdGlvbnM6IHJlYWRvbmx5IG51bWJlcltdLCBhdXRvUGFkOiBzdHJpbmcsXG4gICAgIGdyb3VwOiBudW1iZXIsIHBhZHM6IG51bWJlcltdLCBzdHJpZGVzOiByZWFkb25seSBudW1iZXJbXSwgaXNDaGFubmVsTGFzdDogYm9vbGVhbiwgb3V0cHV0UGFkZGluZzogbnVtYmVyW10sXG4gICAgIG91dHB1dFNoYXBlOiBudW1iZXJbXSkgPT4ge1xuICAgICAgY29uc3Qgc3BhdGlhbFJhbmsgPSBpbnB1dFNoYXBlLmxlbmd0aCAtIDI7XG4gICAgICBjb25zdCB1cGRhdGVPdXRwdXRTaGFwZSA9IG91dHB1dFNoYXBlLmxlbmd0aCA9PT0gMDtcbiAgICAgIGlmIChvdXRwdXRQYWRkaW5nLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNwYXRpYWxSYW5rOyArK2kpIHtcbiAgICAgICAgICBvdXRwdXRQYWRkaW5nLnB1c2goMCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IGJhdGNoU2l6ZSA9IGlucHV0U2hhcGVbMF07XG4gICAgICBjb25zdCBvdXRDaGFubmVscyA9IGtlcm5lbFNoYXBlW2lzQ2hhbm5lbExhc3QgPyAzIDogMV0gKiBncm91cDtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBqID0gaW5wdXRTaGFwZS5sZW5ndGggLSBzcGF0aWFsUmFuayAtIChpc0NoYW5uZWxMYXN0ID8gMSA6IDApOyBpIDwgc3BhdGlhbFJhbms7ICsraSwgKytqKSB7XG4gICAgICAgIGNvbnN0IGluU2l6ZSA9IGlucHV0U2hhcGVbal07XG4gICAgICAgIGNvbnN0IG91dFNpemUgPSB1cGRhdGVPdXRwdXRTaGFwZSA/IGluU2l6ZSAqIHN0cmlkZXNbaV0gOiBvdXRwdXRTaGFwZVtpXTtcbiAgICAgICAgY29uc3QgdG90YWxQYWQgPSBjb21wdXRlVG90YWxQYWQoaW5TaXplLCBzdHJpZGVzW2ldLCBwYWRzW2ldLCBrZXJuZWxTaGFwZVtqXSwgZGlsYXRpb25zW2ldLCBvdXRTaXplKTtcbiAgICAgICAgZGlzdHJpYnV0ZVBhZGRpbmcodG90YWxQYWQsIGF1dG9QYWQsIHBhZHMsIGksIGkgKyBzcGF0aWFsUmFuayk7XG4gICAgICAgIGlmICh1cGRhdGVPdXRwdXRTaGFwZSkge1xuICAgICAgICAgIG91dHB1dFNoYXBlLnB1c2goXG4gICAgICAgICAgICAgIHN0cmlkZXNbaV0gKiAoaW5TaXplIC0gMSkgKyBvdXRwdXRQYWRkaW5nW2ldICsgKGtlcm5lbFNoYXBlW2pdIC0gMSkgKiBkaWxhdGlvbnNbaV0gKyAxIC0gcGFkc1tpXSAtXG4gICAgICAgICAgICAgIHBhZHNbaSArIHNwYXRpYWxSYW5rXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG91dHB1dFNoYXBlLnNwbGljZSgwLCAwLCBiYXRjaFNpemUpO1xuICAgICAgb3V0cHV0U2hhcGUuc3BsaWNlKGlzQ2hhbm5lbExhc3QgPyAzIDogMSwgMCwgb3V0Q2hhbm5lbHMpO1xuICAgIH07XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ29udlRyYW5zcG9zZUF0dHJpYnV0ZXMgZXh0ZW5kcyBDb252QXR0cmlidXRlcyB7XG4gIHJlYWRvbmx5IG91dHB1dFBhZGRpbmc6IHJlYWRvbmx5IG51bWJlcltdO1xuICByZWFkb25seSBvdXRwdXRTaGFwZTogcmVhZG9ubHkgbnVtYmVyW107XG59XG5cblxuY29uc3QgZ2V0QWRqdXN0ZWRDb252VHJhbnNwb3NlQXR0cmlidXRlcyA9XG4gICAgPFQgZXh0ZW5kcyBDb252VHJhbnNwb3NlQXR0cmlidXRlcz4oYXR0cmlidXRlczogVCwgaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10pOiBUID0+IHtcbiAgICAgIGNvbnN0IGtlcm5lbFNoYXBlID0gYXR0cmlidXRlcy5rZXJuZWxTaGFwZS5zbGljZSgpO1xuICAgICAgLy8gaWYga2VybmVsU2hhcGUgaXMgbm90IHNwZWNpZmllZCBpbiB0aGUgYXR0cmlidXRlcyBvZiB0aGlzIG9wLCBpbmZlciBpdCBmcm9tIHRoZSB3ZWlnaHQgdGVuc29yIGRpbXNcbiAgICAgIGlmIChhdHRyaWJ1dGVzLmtlcm5lbFNoYXBlLmxlbmd0aCA9PT0gMCB8fCBhdHRyaWJ1dGVzLmtlcm5lbFNoYXBlLnJlZHVjZSgoYSwgYikgPT4gYSAqIGIsIDEpID09PSAwKSB7XG4gICAgICAgIGtlcm5lbFNoYXBlLmxlbmd0aCA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSAyOyBpIDwgaW5wdXRzWzFdLmRpbXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBrZXJuZWxTaGFwZS5wdXNoKGlucHV0c1sxXS5kaW1zW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgaXNDaGFubmVsc0xhc3QgPSBhdHRyaWJ1dGVzLmZvcm1hdCA9PT0gJ05IV0MnO1xuICAgICAga2VybmVsU2hhcGUuc3BsaWNlKDAsIDAsIGlucHV0c1sxXS5kaW1zWzBdKTtcbiAgICAgIGtlcm5lbFNoYXBlLnNwbGljZShpc0NoYW5uZWxzTGFzdCA/IDMgOiAxLCAwLCBpbnB1dHNbMV0uZGltc1sxXSk7XG5cbiAgICAgIGNvbnN0IHBhZHMgPSBhdHRyaWJ1dGVzLnBhZHMuc2xpY2UoKTtcbiAgICAgIGNvbnN0IG91dHB1dFNoYXBlID0gYXR0cmlidXRlcy5vdXRwdXRTaGFwZS5zbGljZSgpO1xuICAgICAgY29uc3Qgb3V0cHV0UGFkZGluZyA9IGF0dHJpYnV0ZXMub3V0cHV0UGFkZGluZy5zbGljZSgpO1xuICAgICAgY29uc3QgaW5wdXRTaGFwZSA9IGlucHV0c1swXS5kaW1zO1xuICAgICAgbGV0IGRpbGF0aW9ucyA9IGF0dHJpYnV0ZXMuZGlsYXRpb25zLnNsaWNlKCk7XG4gICAgICBpZiAoZGlsYXRpb25zLnJlZHVjZSgoYSwgYikgPT4gYSArIGIsIDApID09PSAwKSB7XG4gICAgICAgIGNvbnN0IHNwYXRpYWxSYW5rID0gaW5wdXRzWzBdLmRpbXMubGVuZ3RoIC0gMjtcbiAgICAgICAgZGlsYXRpb25zID0gbmV3IEFycmF5KHNwYXRpYWxSYW5rKS5maWxsKDEpO1xuICAgICAgfVxuICAgICAgbGV0IHN0cmlkZXMgPSBhdHRyaWJ1dGVzLnN0cmlkZXMuc2xpY2UoKTtcbiAgICAgIGlmIChzdHJpZGVzLnJlZHVjZSgoYSwgYikgPT4gYSArIGIsIDApID09PSAwKSB7XG4gICAgICAgIGNvbnN0IHNwYXRpYWxSYW5rID0gaW5wdXRzWzBdLmRpbXMubGVuZ3RoIC0gMjtcbiAgICAgICAgc3RyaWRlcyA9IG5ldyBBcnJheShzcGF0aWFsUmFuaykuZmlsbCgxKTtcbiAgICAgIH1cbiAgICAgIC8vIElmIG91dHB1dFNoYXBlIGlzIG5vdCBzcGVjaWZpZWQgaW4gdGhlIGF0dHJpYnV0ZXMgb2YgdGhpcyBvcCwgaW5mZXIgaXQgZnJvbSB0aGUgcGFyYW1ldGVyc1xuICAgICAgLy8gU2ltaWxhcmx5LCBhdXRvbWF0aWNhbGx5IGluZmVyIHBhZHMgaWYgbm90IHNwZWNpZmllZFxuICAgICAgY2FsY3VsYXRlT3V0cHV0U2hhcGVBbmRQYWRzKFxuICAgICAgICAgIGlucHV0U2hhcGUsIGtlcm5lbFNoYXBlLCBkaWxhdGlvbnMsIGF0dHJpYnV0ZXMuYXV0b1BhZCwgYXR0cmlidXRlcy5ncm91cCwgcGFkcywgc3RyaWRlcywgaXNDaGFubmVsc0xhc3QsXG4gICAgICAgICAgb3V0cHV0UGFkZGluZywgb3V0cHV0U2hhcGUpO1xuXG4gICAgICAvLyBhbHdheXMgcmV0dXJuIGEgbmV3IG9iamVjdCBzbyBkb2VzIG5vdCBtb2RpZnkgdGhlIG9yaWdpbmFsIGF0dHJpYnV0ZXNcbiAgICAgIGNvbnN0IG5ld0F0dHJpYnV0ZXM6IFQgPSBPYmplY3QuYXNzaWduKHt9LCBhdHRyaWJ1dGVzKTtcbiAgICAgIGNvbnN0IGNhY2hlS2V5ID0gYXR0cmlidXRlcy5jYWNoZUtleSArIFtcbiAgICAgICAga2VybmVsU2hhcGUuam9pbignbiwnKSwgcGFkcy5qb2luKCcsJyksIHN0cmlkZXMuam9pbignLCcpLCBvdXRwdXRQYWRkaW5nLmpvaW4oJywnKSwgb3V0cHV0U2hhcGUuam9pbignLCcpLFxuICAgICAgICBkaWxhdGlvbnMuam9pbignLCcpXG4gICAgICBdLmpvaW4oJ18nKTtcbiAgICAgIE9iamVjdC5hc3NpZ24obmV3QXR0cmlidXRlcywge2tlcm5lbFNoYXBlLCBwYWRzLCBvdXRwdXRQYWRkaW5nLCBvdXRwdXRTaGFwZSwgZGlsYXRpb25zLCBzdHJpZGVzLCBjYWNoZUtleX0pO1xuICAgICAgcmV0dXJuIG5ld0F0dHJpYnV0ZXM7XG4gICAgfTtcblxuZXhwb3J0IGNvbnN0IHBhcnNlQ29udlRyYW5zcG9zZUF0dHJpYnV0ZXMgPSAoYXR0cmlidXRlczogUmVjb3JkPHN0cmluZywgdW5rbm93bj4pOiBDb252VHJhbnNwb3NlQXR0cmlidXRlcyA9PiB7XG4gIGNvbnN0IGFjdGl2YXRpb25BdHRyaWJ1dGVzID0gcGFyc2VJbnRlcm5hbEFjdGl2YXRpb25BdHRyaWJ1dGVzKGF0dHJpYnV0ZXMpO1xuICAvLyBUT0RPIDogTWFrZSB0aGlzIGdlbmVyaWMgZW5vdWdoIHRvIGNvbXB1dGUgZGVmYXVsdCBhdHRyaWJ1dGVzIGZvciBtdWx0aS1kaW1lbnNpb25hbCBjb252XG4gIGNvbnN0IGZvcm1hdCA9IGF0dHJpYnV0ZXMuZm9ybWF0IGFzICdOSFdDJyB8ICdOQ0hXJztcbiAgY29uc3QgYXV0b1BhZCA9XG4gICAgICBbJ05PVFNFVCcsICdWQUxJRCcsICdTQU1FX1VQUEVSJyxcbiAgICAgICAnU0FNRV9MT1dFUiddW3R5cGVvZiBhdHRyaWJ1dGVzLmF1dG9QYWQgPT0gJ3VuZGVmaW5lZCcgPyAwIDogYXR0cmlidXRlcy5hdXRvUGFkIGFzIG51bWJlcl07XG4gIGNvbnN0IGRpbGF0aW9ucyA9IGF0dHJpYnV0ZXMuZGlsYXRpb25zIGFzIFtudW1iZXIsIG51bWJlcl07XG4gIGNvbnN0IGdyb3VwID0gYXR0cmlidXRlcy5ncm91cCBhcyBudW1iZXI7XG4gIGNvbnN0IGtlcm5lbFNoYXBlID0gYXR0cmlidXRlcy5rZXJuZWxTaGFwZSBhcyBbbnVtYmVyLCBudW1iZXJdO1xuICBjb25zdCBwYWRzID0gYXR0cmlidXRlcy5wYWRzIGFzIFtudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXJdO1xuICBjb25zdCBzdHJpZGVzID0gYXR0cmlidXRlcy5zdHJpZGVzIGFzIFtudW1iZXIsIG51bWJlcl07XG4gIGNvbnN0IHdJc0NvbnN0ID0gKGF0dHJpYnV0ZXMud0lzQ29uc3QgYXMgKCkgPT4gYm9vbGVhbikoKTtcbiAgY29uc3Qgb3V0cHV0UGFkZGluZyA9IGF0dHJpYnV0ZXMub3V0cHV0UGFkZGluZyBhcyBbbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyXTtcbiAgY29uc3Qgb3V0cHV0U2hhcGUgPSBhdHRyaWJ1dGVzLm91dHB1dFNoYXBlIGFzIFtudW1iZXIsIG51bWJlcl07XG4gIHJldHVybiBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkoe1xuICAgIGF1dG9QYWQsXG4gICAgZm9ybWF0LFxuICAgIGRpbGF0aW9ucyxcbiAgICBncm91cCxcbiAgICBrZXJuZWxTaGFwZSxcbiAgICBvdXRwdXRQYWRkaW5nLFxuICAgIG91dHB1dFNoYXBlLFxuICAgIHBhZHMsXG4gICAgc3RyaWRlcyxcbiAgICB3SXNDb25zdCxcbiAgICAuLi5hY3RpdmF0aW9uQXR0cmlidXRlc1xuICB9KTtcbn07XG5cbmNvbnN0IHZhbGlkYXRlSW5wdXRzID0gKGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdLCBhdHRyaWJ1dGVzOiBDb252VHJhbnNwb3NlQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICAvLyBSZWZlciB0byB0aGUgYmVsb3cgbGluayBmb3IgYWxsIGlucHV0IGNoZWNrc1xuICAvLyBodHRwczovL2dpdGh1Yi5jb20vb25ueC9vbm54L2Jsb2IvbWFpbi9kb2NzL09wZXJhdG9ycy5tZCNDb252VHJhbnNwb3NlXG4gIGlmICghaW5wdXRzIHx8IChpbnB1dHMubGVuZ3RoICE9PSAyICYmIGlucHV0cy5sZW5ndGggIT09IDMpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDb252IHJlcXVpcmVzIDIgb3IgMyBpbnB1dHMnKTtcbiAgfVxuXG4gIC8vIFRPRE8gOiBOZWVkIHRvIGFkZCBzdXBwb3J0IGZvciBtdWx0aS1kaW1lbnNpb25hbCBjb252XG4gIGlmIChpbnB1dHNbMF0uZGltcy5sZW5ndGggIT09IDQgJiYgaW5wdXRzWzBdLmRpbXMubGVuZ3RoICE9PSAzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjdXJyZW50bHkgb25seSBzdXBwb3J0IDItZGltZW5zaW9uYWwgY29udicpO1xuICB9XG5cbiAgaWYgKGlucHV0c1swXS5kaW1zLmxlbmd0aCAhPT0gaW5wdXRzWzFdLmRpbXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdmaWx0ZXIgZG9lcyBub3QgaGF2ZSBzYW1lIGRpbWVuc2lvbiBhcyBpbnB1dCcpO1xuICB9XG5cbiAgLy8gRklMVEVSX0lOX0NIQU5ORUwgc2hvdWxkIGJlIGVxdWFsIHRvIERBVEFfQ0hBTk5FTFxuICBjb25zdCBkYXRhQ2hhbm5lbCA9IGlucHV0c1swXS5kaW1zW2F0dHJpYnV0ZXMuZm9ybWF0ID09PSAnTkhXQycgPyBpbnB1dHNbMF0uZGltcy5sZW5ndGggLSAxIDogMV07XG4gIGNvbnN0IGZpbHRlckluQ2hhbm5lbCA9IGlucHV0c1sxXS5kaW1zWzBdO1xuICBpZiAoZGF0YUNoYW5uZWwgIT09IGZpbHRlckluQ2hhbm5lbCkge1xuICAgIHRocm93IG5ldyBFcnJvcignRklMVEVSX0lOX0NIQU5ORUwgc2hvdWxkIGJlIGVxdWFsIHRvIERBVEFfQ0hBTk5FTCcpO1xuICB9XG5cbiAgY29uc3QgZmVhdHVyZU1hcHMgPSBpbnB1dHNbMV0uZGltc1sxXSAqIGF0dHJpYnV0ZXMuZ3JvdXA7XG5cbiAgLy8gaWYgYmlhcyBpcyBwcm92aWRlZCBpdCBzaG91bGQgYmUgMUQgYW5kIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgc2hvdWxkIGJlIGVxdWFsIHRvIHRoZSBudW1iZXIgb2YgZmVhdHVyZSBtYXBzXG4gIGlmIChpbnB1dHMubGVuZ3RoID09PSAzICYmIChpbnB1dHNbMl0uZGltcy5sZW5ndGggIT09IDEgfHwgaW5wdXRzWzJdLmRpbXNbMF0gIT09IGZlYXR1cmVNYXBzKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBiaWFzJyk7XG4gIH1cblxuICBjb25zdCBzcGF0aWFsUmFuayA9IGlucHV0c1swXS5kaW1zLmxlbmd0aCAtIDI7XG4gIGNvbnN0IGRpbGF0aW9uc1NldCA9IGF0dHJpYnV0ZXMuZGlsYXRpb25zLnJlZHVjZSgoYSwgYikgPT4gYSArIGIsIDApID4gMDtcbiAgLy8gd3JvbmcgZGlsYXRpb25zIGRpbWVuc2lvblxuICBpZiAoZGlsYXRpb25zU2V0ICYmIGF0dHJpYnV0ZXMuZGlsYXRpb25zLmxlbmd0aCAhPT0gc3BhdGlhbFJhbmspIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYGRpbGF0aW9ucyBzaG91bGQgYmUgJHtzcGF0aWFsUmFua31EYCk7XG4gIH1cblxuICBjb25zdCBzdHJpZGVzU2V0ID0gYXR0cmlidXRlcy5zdHJpZGVzLnJlZHVjZSgoYSwgYikgPT4gYSArIGIsIDApID4gMDtcbiAgLy8gV3Jvbmcgc3RyaWRlcyBkaW1lbnNpb25cbiAgaWYgKHN0cmlkZXNTZXQgJiYgYXR0cmlidXRlcy5zdHJpZGVzLmxlbmd0aCAhPT0gc3BhdGlhbFJhbmspIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYHN0cmlkZXMgc2hvdWxkIGJlICR7c3BhdGlhbFJhbmt9RGApO1xuICB9XG5cbiAgLy8gV3JvbmcgcGFkcyBkaW1lbnNpb25cbiAgY29uc3QgcGFkc1NldCA9IGF0dHJpYnV0ZXMucGFkcy5yZWR1Y2UoKGEsIGIpID0+IGEgKyBiLCAwKSA+IDA7XG4gIGlmIChwYWRzU2V0ICYmIGF0dHJpYnV0ZXMucGFkcy5sZW5ndGggIT09IHNwYXRpYWxSYW5rICogMikge1xuICAgIHRocm93IG5ldyBFcnJvcihgcGFkcyBzaG91bGQgYmUgJHtzcGF0aWFsUmFuayAqIDJ9RGApO1xuICB9XG5cbiAgLy8gV3Jvbmcgb3V0cHV0IHBhZGRpbmcgZGltZW5zaW9uXG4gIGlmIChhdHRyaWJ1dGVzLm91dHB1dFBhZGRpbmcubGVuZ3RoICE9PSBzcGF0aWFsUmFuayAmJiBhdHRyaWJ1dGVzLm91dHB1dFBhZGRpbmcubGVuZ3RoICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBvdXRwdXRfcGFkZGluZyBzaG91bGQgYmUgJHtzcGF0aWFsUmFua31EYCk7XG4gIH1cblxuICAvLyBpZiBrZXJuZWxTaGFwZSBpcyBzcGVjaWZpZWQsIGl0J3MgZGF0YSBsZW5ndGggbXVzdCBiZSAyIGxlc3MgdGhhbiBkaW1zIGxlbmd0aCBvZiB0aGUgd2VpZ2h0cyB0ZW5zb3JcbiAgLy8gKHRoZSBmaXJzdCAyIGRpbXMgYXJlIGJhdGNoX3NpemUgYW5kIGNoYW5uZWxzKVxuICBjb25zdCBrZXJuZWxTaGFwZVNldCA9IGF0dHJpYnV0ZXMua2VybmVsU2hhcGUucmVkdWNlKChhLCBiKSA9PiBhICsgYiwgMCkgPiAwO1xuICBpZiAoa2VybmVsU2hhcGVTZXQgJiYgYXR0cmlidXRlcy5rZXJuZWxTaGFwZS5sZW5ndGggIT09IDAgJiZcbiAgICAgIGF0dHJpYnV0ZXMua2VybmVsU2hhcGUubGVuZ3RoICE9PSBpbnB1dHNbMV0uZGltcy5sZW5ndGggLSAyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGtlcm5lbCBzaGFwZScpO1xuICB9XG5cbiAgLy8gYXMgd2l0aCBrZXJuZWxTaGFwZSwgbXVzdCBoYXZlIHNhbWUgbnVtYmVyIG9mIHNwYXRpYWwgZGltcyBhcyBpbnB1dFxuICBpZiAoYXR0cmlidXRlcy5vdXRwdXRTaGFwZS5sZW5ndGggIT09IDAgJiYgYXR0cmlidXRlcy5vdXRwdXRTaGFwZS5sZW5ndGggIT09IGlucHV0c1swXS5kaW1zLmxlbmd0aCAtIDIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgb3V0cHV0IHNoYXBlJyk7XG4gIH1cbn07XG5cbi8vIGZvciB0cmFuc3Bvc2luZyB3ZWlnaHQgdGVuc29yIGZyb20gW0MsIE0vZ3JvdXAsIEtILCBLV10gdG8gW0tILCBLVywgTS9ncm91cCwgQ11cbmNvbnN0IHdlaWdodFRyYW5zcG9zZVBlcm0gPSBbMiwgMywgMSwgMF07XG5cbmNvbnN0IGNvbnZUcmFuc3Bvc2UyZCA9XG4gICAgKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSwgYXR0cmlidXRlczogQ29udlRyYW5zcG9zZUF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgICAgIGNvbnN0IGFkanVzdGVkQXR0cmlidXRlcyA9IGdldEFkanVzdGVkQ29udlRyYW5zcG9zZUF0dHJpYnV0ZXMoYXR0cmlidXRlcywgaW5wdXRzKTtcbiAgICAgIGNvbnN0IGlzQ2hhbm5lbHNMYXN0ID0gYXR0cmlidXRlcy5mb3JtYXQgPT09ICdOSFdDJztcbiAgICAgIGNvbnN0IG91dHB1dFNoYXBlID0gYWRqdXN0ZWRBdHRyaWJ1dGVzLm91dHB1dFNoYXBlO1xuICAgICAgY29uc3Qgb3V0Q2hhbm5lbHMgPSBvdXRwdXRTaGFwZVtpc0NoYW5uZWxzTGFzdCA/IDMgOiAxXTtcbiAgICAgIGNvbnN0IGlucHV0Q2hhbm5lbHMgPSBpbnB1dHNbMF0uZGltc1tpc0NoYW5uZWxzTGFzdCA/IDMgOiAxXTtcbiAgICAgIC8vIFN3aXRjaCB0byBuYWl2ZSBtZXRob2Qgd2hlbiBvdXRDaGFubmVscyBhbmQgaW5wdXRDaGFubmVscyBhcmUgdmVyeSBzbWFsbC4gSXQncyBiZWNhdXNlIHRoYXQgaW4gdGhpcyBjYXNlIGl0J3NcbiAgICAgIC8vIG5vdCBzdWl0YWJsZSBmb3IgbWF0bXVsIHZlcnNpb24gc2luY2UgbWF0bXVsIHVzZXMgdGlsZSBzaXplIDMyeDMyIHJlc3VsdGluZyB0aGUgdW5kZXJseWluZyBleGVjdXRpb24gdW5pdFxuICAgICAgLy8gdXRpbGl6YXRpb24gcmF0ZSBpcyB2ZXJ5IGxvdy5cbiAgICAgIGlmIChhZGp1c3RlZEF0dHJpYnV0ZXMuZ3JvdXAgIT09IDEgfHwgKG91dENoYW5uZWxzID09PSAxICYmIGlucHV0Q2hhbm5lbHMgPT09IDEpKSB7XG4gICAgICAgIGNvbnRleHQuY29tcHV0ZShjcmVhdGVDb252VHJhbnNwb3NlMkRQcm9ncmFtSW5mbyhpbnB1dHMsIGFkanVzdGVkQXR0cmlidXRlcykpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBvdXRIZWlnaHQgPSBvdXRwdXRTaGFwZVtpc0NoYW5uZWxzTGFzdCA/IDEgOiAyXTtcbiAgICAgIGNvbnN0IG91dFdpZHRoID0gb3V0cHV0U2hhcGVbaXNDaGFubmVsc0xhc3QgPyAyIDogM107XG4gICAgICBjb25zdCB3ZWlnaHRIZWlnaHQgPSBpbnB1dHNbMV0uZGltc1syXTtcbiAgICAgIGNvbnN0IHdlaWdodFdpZHRoID0gaW5wdXRzWzFdLmRpbXNbM107XG5cbiAgICAgIGNvbnN0IGRpbUFPdXRlciA9IGlzQ2hhbm5lbHNMYXN0ID8gb3V0SGVpZ2h0ICogb3V0V2lkdGggOiBvdXRDaGFubmVscztcbiAgICAgIGNvbnN0IGRpbUJPdXRlciA9IGlzQ2hhbm5lbHNMYXN0ID8gb3V0Q2hhbm5lbHMgOiBvdXRIZWlnaHQgKiBvdXRXaWR0aDtcbiAgICAgIGNvbnN0IGRpbUlubmVyID0gd2VpZ2h0SGVpZ2h0ICogd2VpZ2h0V2lkdGggKiBpbnB1dENoYW5uZWxzO1xuXG4gICAgICBjb25zdCBzZXF1ZW50aWFsQWNjZXNzQnlUaHJlYWRzID0gLyogYmFja2VuZC5hZGFwdGVySW5mby5pc0ludGVsKCkgKi8gdHJ1ZTtcblxuXG4gICAgICAvLyBTVEVQLjE6IHRyYW5zcG9zZSB3ZWlnaHRcbiAgICAgIGNvbnN0IHRyYW5zcG9zZWRXZWlnaHQgPSAoY29udGV4dC5rZXJuZWxDdXN0b21EYXRhLndUIGFzIFRlbnNvclZpZXcgfCB1bmRlZmluZWQpID8/XG4gICAgICAgICAgY29udGV4dC5jb21wdXRlKFxuICAgICAgICAgICAgICBjcmVhdGVUcmFuc3Bvc2VQcm9ncmFtSW5mbyhpbnB1dHNbMV0sIHdlaWdodFRyYW5zcG9zZVBlcm0pLFxuICAgICAgICAgICAgICB7aW5wdXRzOiBbMV0sIG91dHB1dHM6IFthdHRyaWJ1dGVzLndJc0NvbnN0ID8gLTIgOiAtMV19KVswXTtcbiAgICAgIGlmIChhdHRyaWJ1dGVzLndJc0NvbnN0ICYmICFjb250ZXh0Lmtlcm5lbEN1c3RvbURhdGEud1QpIHtcbiAgICAgICAgY29udGV4dC5rZXJuZWxDdXN0b21EYXRhLndUID0gdHJhbnNwb3NlZFdlaWdodDtcbiAgICAgIH1cblxuICAgICAgLy8gU1RFUC4yOiBwcmVwYXJlIHJlc2hhcGVkIGlucHV0c1xuICAgICAgY29uc3QgY29udlRyYW5zcG9zZUlucHV0cyA9IFtpbnB1dHNbMF0sIHRyYW5zcG9zZWRXZWlnaHRdO1xuICAgICAgY29uc3QgaGFzQmlhcyA9IGlucHV0cy5sZW5ndGggPT09IDM7XG4gICAgICBpZiAoaGFzQmlhcykge1xuICAgICAgICBpZiAoIWlzQ2hhbm5lbHNMYXN0ICYmIGlucHV0c1syXS5kaW1zLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIGNvbnZUcmFuc3Bvc2VJbnB1dHMucHVzaChpbnB1dHNbMl0ucmVzaGFwZShbaW5wdXRzWzJdLmRpbXNbMF0sIDEsIDFdKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29udlRyYW5zcG9zZUlucHV0cy5wdXNoKGlucHV0c1syXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gU1RFUC4zOiBjb21wdXRlIG1hdG11bFxuICAgICAgY29udGV4dC5jb21wdXRlKFxuICAgICAgICAgIGNyZWF0ZUNvbnYyRFRyYW5zcG9zZU1hdE11bFByb2dyYW1JbmZvKFxuICAgICAgICAgICAgICBjb252VHJhbnNwb3NlSW5wdXRzLCBhZGp1c3RlZEF0dHJpYnV0ZXMsIG91dHB1dFNoYXBlLCBkaW1BT3V0ZXIsIGRpbUJPdXRlciwgZGltSW5uZXIsIGhhc0JpYXMsXG4gICAgICAgICAgICAgIHNlcXVlbnRpYWxBY2Nlc3NCeVRocmVhZHMpLFxuICAgICAgICAgIHtpbnB1dHM6IGNvbnZUcmFuc3Bvc2VJbnB1dHN9KTtcbiAgICB9O1xuXG5jb25zdCBjb252VHJhbnNwb3NlMWQgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IENvbnZUcmFuc3Bvc2VBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIC8vIGV4dGVuZCB0aGUgaW5wdXQgdG8gMkQgYnkgYWRkaW5nIEggZGltZW5zaW9uXG4gIGNvbnN0IGlzQ2hhbm5lbExhc3QgPSBhdHRyaWJ1dGVzLmZvcm1hdCA9PT0gJ05IV0MnO1xuXG4gIGNvbnN0IGlucHV0cyA9IFtcbiAgICBjb250ZXh0LmlucHV0c1swXS5yZXNoYXBlKFxuICAgICAgICBpc0NoYW5uZWxMYXN0ID9cbiAgICAgICAgICAgIC8vIFtOLCBXLCBDXSAtPiBbTiwgSD0xLCBXLCBDXVxuICAgICAgICAgICAgW2NvbnRleHQuaW5wdXRzWzBdLmRpbXNbMF0sIDEsIGNvbnRleHQuaW5wdXRzWzBdLmRpbXNbMV0sIGNvbnRleHQuaW5wdXRzWzBdLmRpbXNbMl1dIDpcbiAgICAgICAgICAgIC8vIFtOLCBDLCBXXSAtPiBbTiwgQywgSD0xLCBXXVxuICAgICAgICAgICAgW2NvbnRleHQuaW5wdXRzWzBdLmRpbXNbMF0sIGNvbnRleHQuaW5wdXRzWzBdLmRpbXNbMV0sIDEsIGNvbnRleHQuaW5wdXRzWzBdLmRpbXNbMl1dKSxcbiAgICAvL1tGSUxURVJfT1VUX0NIQU5ORUwsIEZJTFRFUl9JTl9DSEFOTkVMLCBrV10gLT4gW0ZJTFRFUl9PVVRfQ0hBTk5FTCwgRklMVEVSX0lOX0NIQU5ORUwsIGtIPTEsIGtXXVxuICAgIGNvbnRleHQuaW5wdXRzWzFdLnJlc2hhcGUoW2NvbnRleHQuaW5wdXRzWzFdLmRpbXNbMF0sIGNvbnRleHQuaW5wdXRzWzFdLmRpbXNbMV0sIDEsIGNvbnRleHQuaW5wdXRzWzFdLmRpbXNbMl1dKVxuICBdO1xuICBpZiAoaW5wdXRzLmxlbmd0aCA9PT0gMykge1xuICAgIGlucHV0cy5wdXNoKGNvbnRleHQuaW5wdXRzWzJdKTtcbiAgfVxuICBsZXQga2VybmVsU2hhcGUgPSBhdHRyaWJ1dGVzLmtlcm5lbFNoYXBlO1xuICBpZiAoa2VybmVsU2hhcGUubGVuZ3RoID09PSAwIHx8IGtlcm5lbFNoYXBlWzBdID09PSAwKSB7XG4gICAga2VybmVsU2hhcGUgPSBbY29udGV4dC5pbnB1dHNbMV0uZGltc1syXV07XG4gIH1cbiAgbGV0IGRpbGF0aW9ucyA9IGF0dHJpYnV0ZXMuZGlsYXRpb25zO1xuICBpZiAoZGlsYXRpb25zLmxlbmd0aCA9PT0gMCB8fCBkaWxhdGlvbnNbMF0gPT09IDApIHtcbiAgICBkaWxhdGlvbnMgPSBbMV07XG4gIH1cbiAgbGV0IHN0cmlkZXMgPSBhdHRyaWJ1dGVzLnN0cmlkZXM7XG4gIGlmIChzdHJpZGVzLmxlbmd0aCA9PT0gMCB8fCBzdHJpZGVzWzBdID09PSAwKSB7XG4gICAgc3RyaWRlcyA9IFsxXTtcbiAgfVxuICBsZXQgcGFkcyA9IGF0dHJpYnV0ZXMucGFkcztcbiAgaWYgKHBhZHMubGVuZ3RoID09PSAwKSB7XG4gICAgcGFkcyA9IFswLCAwXTtcbiAgfVxuICBwYWRzID0gWzAsIHBhZHNbMF0sIDAsIHBhZHNbMV1dO1xuICBzdHJpZGVzID0gWzFdLmNvbmNhdChzdHJpZGVzKTtcbiAgZGlsYXRpb25zID0gWzFdLmNvbmNhdChkaWxhdGlvbnMpO1xuICBrZXJuZWxTaGFwZSA9IFsxXS5jb25jYXQoa2VybmVsU2hhcGUpO1xuICBjb25zdCBhZGp1c3RlZEF0dHJpYnV0ZXMgPVxuICAgICAgZ2V0QWRqdXN0ZWRDb252VHJhbnNwb3NlQXR0cmlidXRlcyh7Li4uYXR0cmlidXRlcywgcGFkcywgc3RyaWRlcywgZGlsYXRpb25zLCBrZXJuZWxTaGFwZX0sIGlucHV0cyk7XG4gIGNvbnRleHQuY29tcHV0ZShjcmVhdGVDb252VHJhbnNwb3NlMkRQcm9ncmFtSW5mbyhcbiAgICAgIGlucHV0cywgYWRqdXN0ZWRBdHRyaWJ1dGVzLFxuICAgICAgb3V0cHV0U2hhcGUgPT4gaXNDaGFubmVsTGFzdCA/IFtvdXRwdXRTaGFwZVswXSwgb3V0cHV0U2hhcGVbMl0sIG91dHB1dFNoYXBlWzNdXSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW291dHB1dFNoYXBlWzBdLCBvdXRwdXRTaGFwZVsxXSwgb3V0cHV0U2hhcGVbM11dKSk7XG59O1xuXG5leHBvcnQgY29uc3QgY29udlRyYW5zcG9zZSA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogQ29udlRyYW5zcG9zZUF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgdmFsaWRhdGVJbnB1dHMoY29udGV4dC5pbnB1dHMsIGF0dHJpYnV0ZXMpO1xuICBpZiAoY29udGV4dC5pbnB1dHNbMF0uZGltcy5sZW5ndGggPT09IDMpIHtcbiAgICBjb252VHJhbnNwb3NlMWQoY29udGV4dCwgYXR0cmlidXRlcyk7XG4gIH0gZWxzZSB7XG4gICAgY29udlRyYW5zcG9zZTJkKGNvbnRleHQsIGNvbnRleHQuaW5wdXRzLCBhdHRyaWJ1dGVzKTtcbiAgfVxufTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtEYXRhVHlwZX0gZnJvbSAnLi4vLi4vLi4vd2FzbS1jb21tb24nO1xuaW1wb3J0IHtUZW5zb3JWaWV3fSBmcm9tICcuLi8uLi90ZW5zb3Itdmlldyc7XG5pbXBvcnQge1NoYXBlVXRpbH0gZnJvbSAnLi4vLi4vdXRpbCc7XG5pbXBvcnQge0F0dHJpYnV0ZVdpdGhDYWNoZUtleSwgY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5fSBmcm9tICcuLi9hdHRyaWJ1dGUtd2l0aC1jYWNoZS1rZXknO1xuaW1wb3J0IHtDb21wdXRlQ29udGV4dCwgUHJvZ3JhbUluZm99IGZyb20gJy4uL3R5cGVzJztcblxuaW1wb3J0IHtjcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcywgZ2V0RWxlbWVudEF0LCBpbnB1dFZhcmlhYmxlLCBvdXRwdXRWYXJpYWJsZSwgU2hhZGVySGVscGVyfSBmcm9tICcuL2NvbW1vbic7XG5cblxuZXhwb3J0IGludGVyZmFjZSBDdW1TdW1BdHRyaWJ1dGVzIGV4dGVuZHMgQXR0cmlidXRlV2l0aENhY2hlS2V5IHtcbiAgcmVhZG9ubHkgZXhjbHVzaXZlOiBib29sZWFuO1xuICByZWFkb25seSByZXZlcnNlOiBib29sZWFuO1xufVxuY29uc3QgY3JlYXRlQ3Vtc3VtUHJvZ3JhbUluZm8gPVxuICAgIChpbnB1dFR5cGU6IG51bWJlciwgaW5wdXRTaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sIGF4aXNJbnB1dDogVGVuc29yVmlldywgYXR0cmlidXRlczogQ3VtU3VtQXR0cmlidXRlcyk6XG4gICAgICAgIFByb2dyYW1JbmZvID0+IHtcbiAgICAgICAgICBjb25zdCBvdXRwdXRTaXplID0gU2hhcGVVdGlsLnNpemUoaW5wdXRTaGFwZSk7ICAvLyBvdXRwdXRTaGFwZSBpcyBzYW1lIGFzIGlucHV0U2hhcGUuXG4gICAgICAgICAgY29uc3QgcmFuayA9IGlucHV0U2hhcGUubGVuZ3RoOyAgICAgICAgICAgICAgICAgLy8gaW5wdXQvb3V0cHV0IHJhbmtcbiAgICAgICAgICBjb25zdCBpbnB1dCA9IGlucHV0VmFyaWFibGUoJ2lucHV0JywgaW5wdXRUeXBlLCByYW5rKTtcbiAgICAgICAgICBjb25zdCBvdXRwdXQgPSBvdXRwdXRWYXJpYWJsZSgnb3V0cHV0JywgaW5wdXRUeXBlLCByYW5rKTtcbiAgICAgICAgICBjb25zdCBheGlzVmFsdWUgPSBheGlzSW5wdXQuZGF0YVR5cGUgPT09IERhdGFUeXBlLmludDMyID8gYXhpc0lucHV0LmdldEludDMyQXJyYXkoKVswXSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE51bWJlcihheGlzSW5wdXQuZ2V0QmlnSW50NjRBcnJheSgpWzBdKTtcbiAgICAgICAgICBjb25zdCBheGlzID0gU2hhcGVVdGlsLm5vcm1hbGl6ZUF4aXMoYXhpc1ZhbHVlLCByYW5rKTtcbiAgICAgICAgICBjb25zdCBnZXRTaGFkZXJTb3VyY2UgPSAoc2hhZGVySGVscGVyOiBTaGFkZXJIZWxwZXIpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gYCBpMzIoJHtpbnB1dC5pbmRpY2VzR2V0KCdpbnB1dEluZGljZXMnLCAndW5pZm9ybXMuYXhpcycpfSkgYDtcbiAgICAgICAgICAgIGNvbnN0IG1heCA9IGdldEVsZW1lbnRBdCgndW5pZm9ybXMuaW5wdXRfc2hhcGUnLCAndW5pZm9ybXMuYXhpcycsIHJhbmspO1xuICAgICAgICAgICAgY29uc3QgbG93ZXJMaW1pdCA9IGF0dHJpYnV0ZXMucmV2ZXJzZSA/IGluZGV4ICsgKGF0dHJpYnV0ZXMuZXhjbHVzaXZlID8gJyArIDEnIDogJycpIDogJzAnO1xuICAgICAgICAgICAgY29uc3QgdXBwZXJMaW1pdCA9IGF0dHJpYnV0ZXMucmV2ZXJzZSA/IG1heCA6IGluZGV4ICsgKGF0dHJpYnV0ZXMuZXhjbHVzaXZlID8gJycgOiAnICsgMScpO1xuICAgICAgICAgICAgcmV0dXJuIGBcbiAgICAgICAgICAgICAgICAke1xuICAgICAgICAgICAgICAgIHNoYWRlckhlbHBlci5yZWdpc3RlclVuaWZvcm0oJ291dHB1dFNpemUnLCAndTMyJylcbiAgICAgICAgICAgICAgICAgICAgLnJlZ2lzdGVyVW5pZm9ybSgnYXhpcycsICd1MzInKVxuICAgICAgICAgICAgICAgICAgICAuZGVjbGFyZVZhcmlhYmxlcyhpbnB1dCwgb3V0cHV0KX1cbiAgICAgICAgICAgICAgICAke3NoYWRlckhlbHBlci5tYWluU3RhcnQoKX1cbiAgICAgICAgICAgICAgICAgICR7c2hhZGVySGVscGVyLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoJ3VuaWZvcm1zLm91dHB1dFNpemUnKX1cbiAgICAgICAgICAgICAgICAgIHZhciBpbnB1dEluZGljZXMgPSAke291dHB1dC5vZmZzZXRUb0luZGljZXMoJ2dsb2JhbF9pZHgnKX07XG4gICAgICAgICAgICAgICAgICB2YXIgc3VtID0gJHtvdXRwdXQudHlwZS52YWx1ZX0oMCk7XG4gICAgICAgICAgICAgICAgICBsZXQgZmlyc3QgOiBpMzIgPSAke2xvd2VyTGltaXR9O1xuICAgICAgICAgICAgICAgICAgbGV0IGxhc3QgOiBpMzIgPSAke3VwcGVyTGltaXR9O1xuICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA6IGkzMiA9IGZpcnN0OyBpIDwgbGFzdDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICR7aW5wdXQuaW5kaWNlc1NldCgnaW5wdXRJbmRpY2VzJywgJ3VuaWZvcm1zLmF4aXMnLCAndTMyKGkpJyl9O1xuICAgICAgICAgICAgICAgICAgICBzdW0gPSBzdW0gKyAke2lucHV0LmdldEJ5SW5kaWNlcygnaW5wdXRJbmRpY2VzJyl9O1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgJHtvdXRwdXQuc2V0QnlPZmZzZXQoJ2dsb2JhbF9pZHgnLCAnc3VtJyl9O1xuICAgICAgICAgICAgICAgIH1gO1xuICAgICAgICAgIH07XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5hbWU6ICdDdW1TdW0nLFxuICAgICAgICAgICAgc2hhZGVyQ2FjaGU6IHtoaW50OiBhdHRyaWJ1dGVzLmNhY2hlS2V5LCBpbnB1dERlcGVuZGVuY2llczogWydyYW5rJ119LFxuICAgICAgICAgICAgZ2V0UnVuRGF0YTogKCkgPT4gKHtcbiAgICAgICAgICAgICAgb3V0cHV0czogW3tkaW1zOiBpbnB1dFNoYXBlLCBkYXRhVHlwZTogaW5wdXRUeXBlfV0sXG4gICAgICAgICAgICAgIGRpc3BhdGNoR3JvdXA6IHt4OiBNYXRoLmNlaWwob3V0cHV0U2l6ZSAvIDY0IC8qIHdvcmtncm91cCBzaXplICovKX0sXG4gICAgICAgICAgICAgIHByb2dyYW1Vbmlmb3JtczogW1xuICAgICAgICAgICAgICAgIHt0eXBlOiAndWludDMyJywgZGF0YTogb3V0cHV0U2l6ZX0sIHt0eXBlOiAnaW50MzInLCBkYXRhOiBheGlzfSxcbiAgICAgICAgICAgICAgICAuLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhpbnB1dFNoYXBlKSwgLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMoaW5wdXRTaGFwZSlcbiAgICAgICAgICAgICAgXVxuXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGdldFNoYWRlclNvdXJjZVxuICAgICAgICAgIH07XG4gICAgICAgIH07XG5cblxuZXhwb3J0IGNvbnN0IGN1bXN1bSA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogQ3VtU3VtQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICBjb25zdCBpbnB1dFNoYXBlID0gY29udGV4dC5pbnB1dHNbMF0uZGltcztcbiAgY29uc3QgaW5wdXRUeXBlID0gY29udGV4dC5pbnB1dHNbMF0uZGF0YVR5cGU7XG4gIGNvbnN0IGF4aXMgPSBjb250ZXh0LmlucHV0c1sxXTtcbiAgY29udGV4dC5jb21wdXRlKGNyZWF0ZUN1bXN1bVByb2dyYW1JbmZvKGlucHV0VHlwZSwgaW5wdXRTaGFwZSwgYXhpcywgYXR0cmlidXRlcyksIHtpbnB1dHM6IFswXX0pO1xufTtcblxuZXhwb3J0IGNvbnN0IHBhcnNlQ3VtU3VtQXR0cmlidXRlcyA9IChhdHRyaWJ1dGVzOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPik6IEN1bVN1bUF0dHJpYnV0ZXMgPT4ge1xuICBjb25zdCBleGNsdXNpdmUgPSBhdHRyaWJ1dGVzLmV4Y2x1c2l2ZSBhcyBudW1iZXIgPT09IDE7XG4gIGNvbnN0IHJldmVyc2UgPSBhdHRyaWJ1dGVzLnJldmVyc2UgYXMgbnVtYmVyID09PSAxO1xuICByZXR1cm4gY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KHtleGNsdXNpdmUsIHJldmVyc2V9KTtcbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7VGVuc29yVmlld30gZnJvbSAnLi4vLi4vdGVuc29yLXZpZXcnO1xuaW1wb3J0IHtTaGFwZVV0aWx9IGZyb20gJy4uLy4uL3V0aWwnO1xuaW1wb3J0IHtBdHRyaWJ1dGVXaXRoQ2FjaGVLZXksIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleX0gZnJvbSAnLi4vYXR0cmlidXRlLXdpdGgtY2FjaGUta2V5JztcbmltcG9ydCB7Q29tcHV0ZUNvbnRleHQsIFByb2dyYW1JbmZvLCBQcm9ncmFtVW5pZm9ybX0gZnJvbSAnLi4vdHlwZXMnO1xuXG5pbXBvcnQge2NyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzLCBlbmFibGVTaGFwZXNVbmlmb3JtcywgaW5wdXRWYXJpYWJsZSwgb3V0cHV0VmFyaWFibGUsIFNoYWRlckhlbHBlcn0gZnJvbSAnLi9jb21tb24nO1xuXG5cbmV4cG9ydCBpbnRlcmZhY2UgRWluc3VtQXR0cmlidXRlcyBleHRlbmRzIEF0dHJpYnV0ZVdpdGhDYWNoZUtleSB7XG4gIHJlYWRvbmx5IGVxdWF0aW9uOiBzdHJpbmc7XG59XG4vLyBUaGUgZXF1YXRpb24gYXR0cmlidXRlIHZhbHVlIGlzIGEgc3RyaW5nIHdoaWNoIGNvbnNpc3RzIG9mIGxlZnQgaGFuZCBzaWRlIChMSFMpIGFuZCBvcHRpb25hbGx5IHJpZ2h0IGhhbmQgc2lkZSAoUkhTKVxuLy8gc2VwYXJhdGVkIGJ5ICctPicuIEV4LiBcImlqLGprIC0+IGlrXCIgZXhwcmVzc2VzIG1hdHJpeCBtdWx0aXBsaWNhdGlvblxuLy8gICAgIFwiaWotPmppXCIgZXhwcmVzc2VzIG1hdHJpeCB0cmFuc3Bvc2Vcbi8vICAgICAgXCJpaS0+aVwiIGRpYWdvbmFsIGVsZW1lbnRzIG9mIGEgc3F1YXJlIG1hdHJpeFxuLy8gTEhTIGNvbnNpc3RzIG9mIGEgc2VxdWVuY2Ugb2YgdGVybXMgc2VwYXJhdGVkIGJ5IGNvbW1hcy4gRWFjaCB0ZXJtIGNvcnJlc3BvbmRzIHRvIGFuIGlucHV0IHZhcmlhYmxlLlxuLy8gRWFjaCBzeW1ib2wgY29ycmVzcG9uZHMgdG8gYSBkaW1lbnNpb24gaW4gdGhlIGlucHV0IHZhcmlhYmxlLiBUaGUgc3ltYm9sIGNhbiBiZSBlaXRoZXIgYSBsZXR0ZXIsICdhJyB0byAneicgb3IgJ0EnIHRvXG4vLyAnWicgb3IgJy4uLicgdG8gcmVwcmVzZW50IGFyYml0cmFyeSBkaW1lbnNpb25zLlxuXG5jb25zdCBzeW1ib2xQYXR0ZXJuID1cbiAgICAnW2EtekEtWl18XFxcXC5cXFxcLlxcXFwuJzsgIC8vIFRoZSBwYXR0ZXJuIGVhY2ggc3ltYm9sIGluIGVhY2ggdGVybSBpbiB0aGUgc3ltYm9saWMgZXF1YXRpb24gc2hvdWxkIG1hdGNoXG5jb25zdCB0ZXJtUGF0dGVybiA9ICcoJyArIHN5bWJvbFBhdHRlcm4gKyAnKSsnOyAgIC8vIFRoZSBwYXR0ZXJuIGVhY2ggdGVybSBpbiB0aGUgc3ltYm9saWMgZXF1YXRpb24gc2hvdWxkIG1hdGNoXG5jb25zdCB0ZXJtUGF0dGVybk9ubHkgPSAnXicgKyB0ZXJtUGF0dGVybiArICckJzsgIC8vIFRoZSBwYXR0ZXJucyBvbmx5IG1hdGNocyBhIHRlcm0gYmVnaW4gdG8gZW5kLlxuY29uc3QgbGhzUGF0dGVybiA9ICcoJyArIHRlcm1QYXR0ZXJuICsgJywpKicgKyB0ZXJtUGF0dGVybjsgIC8vIFRoZSBwYXR0ZXJuIHRoZSBMSFMgc2hvdWxkIG1hdGNoXG5jb25zdCBsaHNQYXR0ZXJuT25seSA9ICdeJyArIGxoc1BhdHRlcm4gKyAnJCc7ICAgICAgICAgICAgICAgLy8gVGhlIHBhdHRlcm5zIG9ubHkgbWF0Y2hzIGEgTEhTIGJlZ2luIHRvIGVuZC5cblxuaW50ZXJmYWNlIFN5bWJvbEluZm8ge1xuICBjb3VudDogbnVtYmVyOyAgICAgICAgICAgLy8gU3ltYm9sIGNvcnJlc3BvbmRpbmcgdG8gYSBkaW1tZW5zaW9uIG9mIGFuIGlucHV0XG4gIGlucHV0SW5kaWNlczogbnVtYmVyW107ICAvLyBOdW1iZXIgb2YgaW5wdXQgdmFyaWFibGVzIHRoZSBzeW1ib2wgY29ycmVzcG9uZHMgdG9cbiAgZGltVmFsdWU6IG51bWJlcjsgICAgICAgIC8vIE51bWJlciBvZiBkaW1lbnNpb25zIHRoZSBzeW1ib2wgY29ycmVzcG9uZHMgdG9cbn1cblxuY2xhc3MgRWluc3VtVGVybSB7XG4gIGNvbnN0cnVjdG9yKGlucHV0SW5kZXggPSAtMSkge1xuICAgIHRoaXMuc3ltYm9sVG9JbmRpY2VzID0gbmV3IE1hcDxzdHJpbmcsIG51bWJlcltdPigpO1xuICAgIHRoaXMuaW5wdXRJbmRleCA9IGlucHV0SW5kZXg7XG4gIH1cblxuICAvLyBBZGQgYSBzeW1ib2wgdG8gdGhlIHRlcm1cbiAgYWRkU3ltYm9sKHN5bWJvbDogc3RyaW5nLCBpbmRleDogbnVtYmVyKSB7XG4gICAgbGV0IHZhbHVlID0gdGhpcy5zeW1ib2xUb0luZGljZXMuZ2V0KHN5bWJvbCk7XG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhbHVlID0gW2luZGV4XTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUucHVzaChpbmRleCk7XG4gICAgfVxuICAgIHRoaXMuc3ltYm9sVG9JbmRpY2VzLnNldChzeW1ib2wsIHZhbHVlKTtcbiAgfVxuXG4gIHN5bWJvbFRvSW5kaWNlczogTWFwPHN0cmluZywgbnVtYmVyW10+OyAgLy8gTWFwIGZyb20gc3ltYm9sIHRvIGRpbWVuc2lvbnMgb2YgdGhlIGlucHV0IGNvcnJlc3BvbmRpbmcgdG8gdGhlIHRlcm1cbiAgaW5wdXRJbmRleDogbnVtYmVyOyAgICAgICAgICAgICAgICAgICAgICAvLyAtMSBmb3Igb3V0cHV0IGFuZCAwLCAxLCAyLCAuLi4gZm9yIGlucHV0c1xufVxuXG5jbGFzcyBFaW5zdW1FcXVhdGlvbiB7XG4gIGNvbnN0cnVjdG9yKGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdLCBwdWJsaWMgcmVhZG9ubHkgZXF1YXRpb246IHN0cmluZykge1xuICAgIHRoaXMuaGFzRWxsaXBzaXMgPSBmYWxzZTtcbiAgICB0aGlzLnN5bWJvbFRvSW5mbyA9IG5ldyBNYXA8c3RyaW5nLCBTeW1ib2xJbmZvPigpO1xuICAgIHRoaXMubGhzID0gbmV3IEFycmF5PEVpbnN1bVRlcm0+KCk7XG4gICAgdGhpcy5vdXRwdXREaW1zID0gW107XG4gICAgLy8gQXMgcmhzIG5lZWRzIHRvIGJlIHVwZGF0ZWQgYWxsb3cgdXNpbmcgbGV0IGluc3RlYWQgb2YgY29uc3QgZm9yIGJvdGggbGhzIGFuZCByaHMuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1jb25zdFxuICAgIGxldCBbbGhzLCByaHNdID0gZXF1YXRpb24uaW5jbHVkZXMoJy0+JykgPyBlcXVhdGlvbi5zcGxpdCgnLT4nLCAyKSA6IFtlcXVhdGlvbiwgJyddO1xuICAgIGlmICghbGhzLm1hdGNoKFJlZ0V4cChsaHNQYXR0ZXJuT25seSkpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgTEhTIHRlcm0nKTtcbiAgICB9XG4gICAgY29uc3QgaW5wdXRUZXJtcyA9IGxocy5zcGxpdCgnLCcpO1xuICAgIGlucHV0VGVybXMuZm9yRWFjaCgoaW5wdXRUZXJtLCBpbmRleCkgPT4ge1xuICAgICAgY29uc3QgZGltcyA9IGlucHV0c1tpbmRleF0uZGltcy5zbGljZSgpO1xuICAgICAgaWYgKCFpbnB1dFRlcm0ubWF0Y2goUmVnRXhwKHRlcm1QYXR0ZXJuT25seSkpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBMSFMgdGVybScpO1xuICAgICAgfVxuICAgICAgY29uc3QgZWluc3VtVGVybSA9IHRoaXMucHJvY2Vzc1Rlcm0oaW5wdXRUZXJtLCB0cnVlLCBkaW1zLCBpbmRleCk7XG4gICAgICB0aGlzLmxocy5wdXNoKGVpbnN1bVRlcm0pO1xuICAgIH0pO1xuXG4gICAgLy8gSW5pdGlhbGl6ZSB0aGUgUkhTIGlmIG5vdCBzcGVjaWZpZWRcbiAgICBpZiAocmhzID09PSAnJykge1xuICAgICAgLy8gQ29uc3RydWN0IFJIUyBmcm9tIExIUyB0ZXJtcy9zeW1ib2xzXG4gICAgICByaHMgKz0gWy4uLnRoaXMuc3ltYm9sVG9JbmZvLmVudHJpZXMoKV1cbiAgICAgICAgICAgICAgICAgLmZpbHRlcigoW3N5bSwgaW5mb10pID0+IChpbmZvLmNvdW50ID09PSAxIHx8IHN5bSA9PT0gJy4uLicpKVxuICAgICAgICAgICAgICAgICAubWFwKChbc3ltXSkgPT4gc3ltKVxuICAgICAgICAgICAgICAgICAuam9pbignJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghcmhzLm1hdGNoKFJlZ0V4cCh0ZXJtUGF0dGVybikpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBSSFMnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBDb21wdXRlIG91dHB1dCBkaW1zXG4gICAgY29uc3QgcmhzU3ltYm9scyA9IHJocy5tYXRjaChSZWdFeHAoc3ltYm9sUGF0dGVybiwgJ2cnKSk7XG4gICAgcmhzU3ltYm9scz8uZm9yRWFjaCgoc3ltYm9sKSA9PiB7XG4gICAgICBpZiAoc3ltYm9sID09PSAnLi4uJykge1xuICAgICAgICB0aGlzLm91dHB1dERpbXMgPSB0aGlzLm91dHB1dERpbXMuY29uY2F0KHRoaXMuZWxsaXBzaXNEaW1zKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGluZm8gPSB0aGlzLnN5bWJvbFRvSW5mby5nZXQoc3ltYm9sKTtcbiAgICAgICAgaWYgKGluZm8gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBSSFMgc3ltYm9sJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vdXRwdXREaW1zLnB1c2goaW5mby5kaW1WYWx1ZSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5yaHMgPSB0aGlzLnByb2Nlc3NUZXJtKHJocywgZmFsc2UsIHRoaXMub3V0cHV0RGltcyk7XG4gIH0gIC8vIEVuZCBvZiBFaW5zdW1FcWF0aW9uIGNvbnN0cnVjdG9yXG5cbiAgLy8gQWRkIGEgc3ltYm9sIHRvIHRoZSBlcXVhdGlvblxuICBhZGRTeW1ib2woc3ltYm9sOiBzdHJpbmcsIGRpbVZhbHVlOiBudW1iZXIsIGlucHV0SW5kZXg6IG51bWJlcikge1xuICAgIGxldCBpbmZvID0gdGhpcy5zeW1ib2xUb0luZm8uZ2V0KHN5bWJvbCk7XG4gICAgaWYgKGluZm8gIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKGluZm8uZGltVmFsdWUgIT09IGRpbVZhbHVlICYmIGluZm8uY291bnQgIT09IDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEaW1lbnNpb24gbWlzbWF0Y2gnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluZm8uY291bnQrKztcbiAgICAgICAgaW5mby5pbnB1dEluZGljZXMucHVzaChpbnB1dEluZGV4KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaW5mbyA9IHtjb3VudDogMSwgZGltVmFsdWUsIGlucHV0SW5kaWNlczogW2lucHV0SW5kZXhdfTtcbiAgICB9XG4gICAgdGhpcy5zeW1ib2xUb0luZm8uc2V0KHN5bWJvbCwgaW5mbyk7XG4gIH1cblxuICAvLyBQcm9jZXNzIG9uZSBpbnB1dC9vdXRwdXQgdGVybVxuICBwcm9jZXNzVGVybSh0ZXJtOiBzdHJpbmcsIGlzSW5wdXQ6IGJvb2xlYW4sIGRpbXM6IHJlYWRvbmx5IG51bWJlcltdLCBpbmRleCA9IC0xKTogRWluc3VtVGVybSB7XG4gICAgY29uc3QgcmFuayA9IGRpbXMubGVuZ3RoO1xuICAgIGxldCBlbGxpcHNpcyA9IGZhbHNlO1xuICAgIGxldCBlbGxpcHNpc0RpbXMgPSBbXTtcbiAgICBsZXQgbmV4dERpbSA9IDA7XG4gICAgLy8gRm9yIG91dHB1dCBlbXB0eSBzdHJpbmcgaXMgYWxsb3dlZCBiZWNhdXNlIHRoZSBvdXRwdXQgbWF5IGJlIHJlZHVjZWQgdG8gYSBzY2FsYXIgdmFsdWVcbiAgICBpZiAoIXRlcm0ubWF0Y2goUmVnRXhwKHRlcm1QYXR0ZXJuT25seSkpICYmICghaXNJbnB1dCAmJiB0ZXJtICE9PSAnJykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBMSFMgdGVybScpO1xuICAgIH1cbiAgICBjb25zdCBpbmRleFN5bWJvbHMgPSB0ZXJtLm1hdGNoKFJlZ0V4cChzeW1ib2xQYXR0ZXJuLCAnZycpKTtcbiAgICBjb25zdCBlaW5zdW1UZXJtID0gbmV3IEVpbnN1bVRlcm0oaW5kZXgpO1xuICAgIC8vIHN5bWJvbCBjYW4gYmUgZWl0aGVyIGEgbGV0dHJlLCAnYScgdG8gJ3onIG9yICdBJyB0byAnWicsIG9yICcuLi4nXG4gICAgaW5kZXhTeW1ib2xzPy5mb3JFYWNoKChzeW1ib2w6IHN0cmluZywgaTogbnVtYmVyKSA9PiB7XG4gICAgICBpZiAoc3ltYm9sID09PSAnLi4uJykge1xuICAgICAgICBpZiAoZWxsaXBzaXMpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ09ubHkgb25lIGVsbGlwc2lzIGlzIGFsbG93ZWQgcGVyIGlucHV0IHRlcm0nKTtcbiAgICAgICAgfVxuICAgICAgICBlbGxpcHNpcyA9IHRydWU7XG4gICAgICAgIGNvbnN0IGVsbGlwc2lzRGltTGVuZ3RoID0gcmFuayAtIGluZGV4U3ltYm9scy5sZW5ndGggKyAxO1xuICAgICAgICBpZiAoZWxsaXBzaXNEaW1MZW5ndGggPCAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFbGxpcHNpcyBvdXQgb2YgYm91bmRzJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxsaXBzaXNEaW1zID0gZGltcy5zbGljZShuZXh0RGltLCBuZXh0RGltICsgZWxsaXBzaXNEaW1MZW5ndGgpO1xuICAgICAgICBpZiAodGhpcy5oYXNFbGxpcHNpcykge1xuICAgICAgICAgIGlmICh0aGlzLmVsbGlwc2lzRGltcy5sZW5ndGggIT09IGVsbGlwc2lzRGltcy5sZW5ndGggfHxcbiAgICAgICAgICAgICAgdGhpcy5lbGxpcHNpc0RpbXMudG9TdHJpbmcoKSAhPT0gZWxsaXBzaXNEaW1zLnRvU3RyaW5nKCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRWxsaXBzaXMgZGltZW5zaW9ucyBtaXNtYXRjaCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChpc0lucHV0KSB7XG4gICAgICAgICAgdGhpcy5oYXNFbGxpcHNpcyA9IHRydWU7XG4gICAgICAgICAgdGhpcy5lbGxpcHNpc0RpbXMgPSBlbGxpcHNpc0RpbXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFbGxpcHNpcyBtdXN0IGJlIHNwZWNpZmllZCBpbiB0aGUgTEhTJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWRkICcwJywgJzEnLCAnMicsICczJywgJzQnLCBldGMgdG8gcmVwcmVzZW50IGVsbGlwc2lzIGRpbWVuc2lvbnMgdG8gYXZvaWQgc3BlY2lhbCBoYW5kbGluZ1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGVsbGlwc2lzRGltcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgIGNvbnN0IHN5bWJvbCA9IFN0cmluZy5mcm9tQ2hhckNvZGUoJzAnLmNoYXJDb2RlQXQoMCkgKyBqKTtcbiAgICAgICAgICBlaW5zdW1UZXJtLmFkZFN5bWJvbChzeW1ib2wsIGkgKyBqKTtcbiAgICAgICAgICB0aGlzLmFkZFN5bWJvbChzeW1ib2wsIGRpbXNbbmV4dERpbSsrXSwgaW5kZXgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlaW5zdW1UZXJtLmFkZFN5bWJvbChzeW1ib2wsIGkgKyAodGhpcy5oYXNFbGxpcHNpcyA/IHRoaXMuZWxsaXBzaXNEaW1zLmxlbmd0aCAtIDEgOiAwKSk7XG4gICAgICAgIHRoaXMuYWRkU3ltYm9sKHN5bWJvbCwgZGltc1tuZXh0RGltKytdLCBpbmRleCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGVpbnN1bVRlcm07XG4gIH1cblxuICBzeW1ib2xUb0luZm86IE1hcDxzdHJpbmcsIFN5bWJvbEluZm8+OyAgLy8gQWxsIHN5bWJvbHMgaW4gdGhlIGVxdWF0aW9uXG4gIGhhc0VsbGlwc2lzOiBib29sZWFuOyAgICAgICAgICAgICAgICAgICAvLyBUaGUgZXF1YXRpb24gaGFzIGVsbGlwc2lzIG9yIG5vdFxuICBlbGxpcHNpc0RpbXM6IG51bWJlcltdOyAgICAgICAgICAgICAgICAgLy8gVGhlIGRpbWVuc2lvbnMgb2YgdGhlIGVxdWF0aW9uIGVsbGlwc2lzIGNvcnJlc3BvbmRzIHRvLlxuICBsaHM6IEVpbnN1bVRlcm1bXTsgICAgICAgICAgICAgICAgICAgICAgLy8gVGVybXMgb24gdGhlIGxlZnQtaGFuZCBzaWRlIG9mIHRoZSBlcXVhdGlvblxuICByaHM6IEVpbnN1bVRlcm07ICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGVybSBvbiB0aGUgcmlnaHQtaGFuZCBzaWRlIG9mIHRoZSBlcXVhdGlvblxuICBvdXRwdXREaW1zOiBudW1iZXJbXTsgICAgICAgICAgICAgICAgICAgLy8gT3V0cHV0IGRpbWVuc2lvbnMgb2YgdGhlIGVxdWF0aW9uXG59ICAvLyBFbmQgb2YgY2xhc3MgRWluc3VtRXF1YXRpb25cblxuY29uc3QgYXBwZW5kTWF4ID0gKG5hbWU6IHN0cmluZyk6IHN0cmluZyA9PiBuYW1lICsgJ19tYXgnO1xuXG5jb25zdCBjcmVhdGVFaW5zdW1Qcm9ncmFtSW5mbyA9XG4gICAgKGVuYWJsZUlucHV0U2hhcGVzVW5pZm9ybXM6IHJlYWRvbmx5IGJvb2xlYW5bXSwgaW5wdXRTaGFwZXM6IEFycmF5PHJlYWRvbmx5IG51bWJlcltdPiwgZGF0YVR5cGU6IG51bWJlcixcbiAgICAgZWluc3VtRXF1YXRpb246IEVpbnN1bUVxdWF0aW9uLCBvdXRwdXRTaGFwZTogcmVhZG9ubHkgbnVtYmVyW10pOiBQcm9ncmFtSW5mbyA9PiB7XG4gICAgICBjb25zdCBzaGFwZU9yUmFua3MgPSBpbnB1dFNoYXBlcy5tYXAoKGRpbXMsIGluZGV4KSA9PiBlbmFibGVJbnB1dFNoYXBlc1VuaWZvcm1zW2luZGV4XSA/IGRpbXMubGVuZ3RoIDogZGltcyk7XG4gICAgICBjb25zdCBpbnB1dFZhcnMgPSBzaGFwZU9yUmFua3MubWFwKChzaGFwZU9yUmFuaywgaW5kZXgpID0+IGlucHV0VmFyaWFibGUoYGlucHV0JHtpbmRleH1gLCBkYXRhVHlwZSwgc2hhcGVPclJhbmspKTtcbiAgICAgIGNvbnN0IG91dHB1dFNpemUgPSBTaGFwZVV0aWwuc2l6ZShvdXRwdXRTaGFwZSk7XG4gICAgICBjb25zdCBlbmFibGVPdXRwdXRTaGFwZXNVbmlmb3JtcyA9IGVuYWJsZVNoYXBlc1VuaWZvcm1zKG91dHB1dFNoYXBlLmxlbmd0aCk7XG4gICAgICBjb25zdCBvdXRwdXRTaGFwZU9yUmFuayA9IGVuYWJsZU91dHB1dFNoYXBlc1VuaWZvcm1zID8gb3V0cHV0U2hhcGUubGVuZ3RoIDogb3V0cHV0U2hhcGU7XG4gICAgICBjb25zdCBvdXRwdXQgPSBvdXRwdXRWYXJpYWJsZSgnb3V0cHV0JywgZGF0YVR5cGUsIG91dHB1dFNoYXBlT3JSYW5rKTtcbiAgICAgIGNvbnN0IHVuaWZvcm1zU3ltYm9scyA9XG4gICAgICAgICAgWy4uLmVpbnN1bUVxdWF0aW9uLnN5bWJvbFRvSW5mby5rZXlzKCldLmZpbHRlcigoc3ltYm9sKSA9PiAhZWluc3VtRXF1YXRpb24ucmhzLnN5bWJvbFRvSW5kaWNlcy5oYXMoc3ltYm9sKSk7XG4gICAgICBjb25zdCBnZXRTaGFkZXJTb3VyY2UgPSAoc2hhZGVySGVscGVyOiBTaGFkZXJIZWxwZXIpID0+IHtcbiAgICAgICAgY29uc3QgaWR4Q29weTogc3RyaW5nW10gPSBbXTtcbiAgICAgICAgY29uc3QgaW5pdFByb2QgPSAndmFyIHByb2QgPSAxLjA7JztcbiAgICAgICAgY29uc3QgaW5pdFN1bSA9ICd2YXIgc3VtID0gMC4wOyc7XG4gICAgICAgIGNvbnN0IHVwZGF0ZVN1bSA9ICdzdW0gKz0gcHJvZDsnO1xuICAgICAgICBjb25zdCByZWR1Y2VPcHNTZXRJbmRpY2VzOiBzdHJpbmdbXSA9IFtdO1xuICAgICAgICBjb25zdCByZWR1Y2VPcHNMb29wSGVhZGVyczogc3RyaW5nW10gPSBbXTtcbiAgICAgICAgY29uc3QgcmVkdWNlT3BzTG9vcEZvb3RlcnM6IHN0cmluZ1tdID0gW107XG4gICAgICAgIGNvbnN0IHJlZHVjZU9wQ29tcHV0ZTogc3RyaW5nW10gPSBbXTtcbiAgICAgICAgY29uc3QgaXNSZWR1Y2VPcHNXaXRob3V0TG9vcCA9IGVpbnN1bUVxdWF0aW9uLnN5bWJvbFRvSW5mby5zaXplID09PSBlaW5zdW1FcXVhdGlvbi5yaHMuc3ltYm9sVG9JbmRpY2VzLnNpemU7XG4gICAgICAgIGVpbnN1bUVxdWF0aW9uLnN5bWJvbFRvSW5mby5mb3JFYWNoKChpbmZvLCBzeW1ib2wpID0+IHtcbiAgICAgICAgICBpZiAoZWluc3VtRXF1YXRpb24ucmhzLnN5bWJvbFRvSW5kaWNlcy5oYXMoc3ltYm9sKSkge1xuICAgICAgICAgICAgY29uc3Qgb3V0cHV0SW5kZXggPSBlaW5zdW1FcXVhdGlvbi5yaHMuc3ltYm9sVG9JbmRpY2VzLmdldChzeW1ib2wpPy5bMF07XG4gICAgICAgICAgICBpZiAob3V0cHV0SW5kZXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBlaW5zdW1FcXVhdGlvbi5saHMuZm9yRWFjaCgodGVybSwgaSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChpbmZvLmlucHV0SW5kaWNlcy5pbmNsdWRlcyhpKSkge1xuICAgICAgICAgICAgICAgICAgY29uc3QgaW5kaWNlcyA9IHRlcm0uc3ltYm9sVG9JbmRpY2VzLmdldChzeW1ib2wpO1xuICAgICAgICAgICAgICAgICAgaWYgKGluZGljZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3ltYm9sIGVycm9yJyk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpbmRpY2VzLmZvckVhY2goKGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlkeENvcHkucHVzaChgJHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0VmFyc1tpXS5pbmRpY2VzU2V0KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBpbnB1dCR7aX1JbmRpY2VzYCwgaW5kZXgsIG91dHB1dC5pbmRpY2VzR2V0KCdvdXRwdXRJbmRpY2VzJywgb3V0cHV0SW5kZXgpKX1gKTtcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVpbnN1bUVxdWF0aW9uLmxocy5mb3JFYWNoKCh0ZXJtLCBpKSA9PiB7XG4gICAgICAgICAgICAgIGlmIChpbmZvLmlucHV0SW5kaWNlcy5pbmNsdWRlcyhpKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGluZGljZXMgPSB0ZXJtLnN5bWJvbFRvSW5kaWNlcy5nZXQoc3ltYm9sKTtcbiAgICAgICAgICAgICAgICBpZiAoaW5kaWNlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3ltYm9sIGVycm9yJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGluZGljZXMuZm9yRWFjaCgoaW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICAgIHJlZHVjZU9wc1NldEluZGljZXMucHVzaChgJHtpbnB1dFZhcnNbaV0uaW5kaWNlc1NldChgaW5wdXQke2l9SW5kaWNlc2AsIGluZGV4LCBgJHtzeW1ib2x9YCl9YCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmVkdWNlT3BDb21wdXRlLnB1c2goYHByb2QgKj0gJHtpbnB1dFZhcnNbaV0uZ2V0QnlJbmRpY2VzKGBpbnB1dCR7aX1JbmRpY2VzYCl9O2ApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJlZHVjZU9wc0xvb3BIZWFkZXJzLnB1c2goXG4gICAgICAgICAgICAgICAgYGZvcih2YXIgJHtzeW1ib2x9OiB1MzIgPSAwOyAke3N5bWJvbH0gPCB1bmlmb3Jtcy4ke2FwcGVuZE1heChzeW1ib2wpfTsgJHtzeW1ib2x9KyspIHtgKTtcbiAgICAgICAgICAgIHJlZHVjZU9wc0xvb3BGb290ZXJzLnB1c2goJ30nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCByZWR1Y2VPcHMgPSBpc1JlZHVjZU9wc1dpdGhvdXRMb29wID9cbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgLi4uaWR4Q29weSxcbiAgICAgICAgICAgICAgYGxldCBzdW0gPSAke2lucHV0VmFycy5tYXAoKGlucHV0VmFyLCBpKSA9PiBpbnB1dFZhci5nZXRCeUluZGljZXMoYGlucHV0JHtpfUluZGljZXNgKSkuam9pbignICogJyl9O2BcbiAgICAgICAgICAgIF0gOlxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAuLi5pZHhDb3B5LFxuICAgICAgICAgICAgICBpbml0U3VtLFxuICAgICAgICAgICAgICAuLi5yZWR1Y2VPcHNMb29wSGVhZGVycyxcbiAgICAgICAgICAgICAgLi4ucmVkdWNlT3BzU2V0SW5kaWNlcyxcbiAgICAgICAgICAgICAgaW5pdFByb2QsXG4gICAgICAgICAgICAgIC4uLnJlZHVjZU9wQ29tcHV0ZSxcbiAgICAgICAgICAgICAgdXBkYXRlU3VtLFxuICAgICAgICAgICAgICAuLi5yZWR1Y2VPcHNMb29wRm9vdGVycyxcbiAgICAgICAgICAgIF07XG4gICAgICAgIHJldHVybiBgXG4gICAgICAgICAgICAke1xuICAgICAgICAgICAgc2hhZGVySGVscGVyXG4gICAgICAgICAgICAgICAgLnJlZ2lzdGVyVW5pZm9ybXModW5pZm9ybXNTeW1ib2xzLm1hcCgoc3ltYm9sKSA9PiAoe25hbWU6IGAke2FwcGVuZE1heChzeW1ib2wpfWAsIHR5cGU6ICd1MzInfSkpKVxuICAgICAgICAgICAgICAgIC5yZWdpc3RlclVuaWZvcm0oJ291dHB1dFNpemUnLCAndTMyJylcbiAgICAgICAgICAgICAgICAuZGVjbGFyZVZhcmlhYmxlcyguLi5pbnB1dFZhcnMsIG91dHB1dCl9XG5cbiAgICAgICAgICAgICR7c2hhZGVySGVscGVyLm1haW5TdGFydCgpfVxuICAgICAgICAgICAgJHtzaGFkZXJIZWxwZXIuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcygndW5pZm9ybXMub3V0cHV0U2l6ZScpfVxuICAgICAgICAgICAgdmFyIG91dHB1dEluZGljZXMgPSAke291dHB1dC5vZmZzZXRUb0luZGljZXMoJ2dsb2JhbF9pZHgnKX07XG4gICAgICAgICAgICAke2lucHV0VmFycy5tYXAoKF92YXIsIGkpID0+IGB2YXIgaW5wdXQke2l9SW5kaWNlczogJHtpbnB1dFZhcnNbaV0udHlwZS5pbmRpY2VzfTtgKS5qb2luKCdcXG4nKX1cbiAgICAgICAgICAgICR7cmVkdWNlT3BzLmpvaW4oJ1xcbicpfTtcbiAgICAgICAgICAgICR7b3V0cHV0LnNldEJ5T2Zmc2V0KCdnbG9iYWxfaWR4JywgJ3N1bScpfTtcbiAgICAgICAgICB9YDtcbiAgICAgIH07XG4gICAgICByZXR1cm4ge1xuICAgICAgICBuYW1lOiAnRWluc3VtJyxcbiAgICAgICAgc2hhZGVyQ2FjaGU6IHtcbiAgICAgICAgICBoaW50OiBlaW5zdW1FcXVhdGlvbi5lcXVhdGlvbixcbiAgICAgICAgICBpbnB1dERlcGVuZGVuY2llczogZW5hYmxlSW5wdXRTaGFwZXNVbmlmb3Jtcy5tYXAoKGVuYWJsZVNoYXBlVW5pZm9ybSkgPT4gZW5hYmxlU2hhcGVVbmlmb3JtID8gJ3JhbmsnIDogJ2RpbXMnKVxuICAgICAgICB9LFxuICAgICAgICBnZXRSdW5EYXRhOiAoKSA9PiB7XG4gICAgICAgICAgLy8gVGhlIHN5bWJvbHMgZnJvbSB1bmlmb3JtU3ltYm9scyBhcnJheSBhcmUgZ3VhcmFudGVlZCB0byBleGlzdCBpbiBlaW5zdW1FcXVhdGlvbnMuc3ltYm9sVG9JbmZvIG1hcC4gVGhlXG4gICAgICAgICAgLy8gZmlsdGVyIGlzIGFkZGVkIHRvIG1ha2Ugc3VyZSB0aGF0IGRpbVZhbHVlIGlzIG5ldmVyIDAuXG4gICAgICAgICAgY29uc3QgcHJvZ3JhbVVuaWZvcm1zSW5pdDogUHJvZ3JhbVVuaWZvcm1bXSA9XG4gICAgICAgICAgICAgIHVuaWZvcm1zU3ltYm9scy5maWx0ZXIoKHN5bWJvbCkgPT4gZWluc3VtRXF1YXRpb24uc3ltYm9sVG9JbmZvLmhhcyhzeW1ib2wpKVxuICAgICAgICAgICAgICAgICAgLm1hcCgoc3ltYm9sKSA9PiAoe3R5cGU6ICd1aW50MzInLCBkYXRhOiBlaW5zdW1FcXVhdGlvbi5zeW1ib2xUb0luZm8uZ2V0KHN5bWJvbCk/LmRpbVZhbHVlIHx8IDB9KSk7XG4gICAgICAgICAgcHJvZ3JhbVVuaWZvcm1zSW5pdC5wdXNoKHt0eXBlOiAndWludDMyJywgZGF0YTogb3V0cHV0U2l6ZX0pO1xuICAgICAgICAgIGNvbnN0IHByb2dyYW1Vbmlmb3JtczogUHJvZ3JhbVVuaWZvcm1bXSA9XG4gICAgICAgICAgICAgIGlucHV0U2hhcGVzLmZpbHRlcigoXywgaW5kZXgpID0+IGVuYWJsZUlucHV0U2hhcGVzVW5pZm9ybXNbaW5kZXhdKVxuICAgICAgICAgICAgICAgICAgLm1hcCgoZGltcywgXykgPT4gWy4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKGRpbXMpXSlcbiAgICAgICAgICAgICAgICAgIC5yZWR1Y2UoKGFjYywgaW5wdXRQcm9ncmFtVW5pZm9ybXMpID0+IGFjYy5jb25jYXQoaW5wdXRQcm9ncmFtVW5pZm9ybXMpLCBwcm9ncmFtVW5pZm9ybXNJbml0KTtcbiAgICAgICAgICBpZiAoZW5hYmxlT3V0cHV0U2hhcGVzVW5pZm9ybXMpIHtcbiAgICAgICAgICAgIHByb2dyYW1Vbmlmb3Jtcy5wdXNoKC4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKG91dHB1dFNoYXBlKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiAoe1xuICAgICAgICAgICAgb3V0cHV0czogW3tkaW1zOiBvdXRwdXRTaGFwZSwgZGF0YVR5cGV9XSxcbiAgICAgICAgICAgIGRpc3BhdGNoR3JvdXA6IHt4OiBNYXRoLmNlaWwob3V0cHV0U2l6ZSAvIDY0IC8qIHdvcmtncm91cCBzaXplICovKX0sXG4gICAgICAgICAgICBwcm9ncmFtVW5pZm9ybXNcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0U2hhZGVyU291cmNlLFxuICAgICAgfTtcbiAgICB9O1xuXG5leHBvcnQgY29uc3QgZWluc3VtID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBFaW5zdW1BdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIGNvbnN0IGVpbnN1bUVxdWF0aW9uID0gbmV3IEVpbnN1bUVxdWF0aW9uKGNvbnRleHQuaW5wdXRzLCBhdHRyaWJ1dGVzLmVxdWF0aW9uKTtcbiAgY29uc3QgZW5hYmxlSW5wdXRTaGFwZXNVbmlmb3JtcyA9IGNvbnRleHQuaW5wdXRzLm1hcCgoaW5wdXQsIF8pID0+IGVuYWJsZVNoYXBlc1VuaWZvcm1zKGlucHV0LmRpbXMubGVuZ3RoKSk7XG4gIGNvbnN0IG91dHB1dFNoYXBlID0gZWluc3VtRXF1YXRpb24ub3V0cHV0RGltcztcbiAgY29uc3QgaW5wdXRTaGFwZXMgPSBjb250ZXh0LmlucHV0cy5tYXAoKGlucHV0LCBfKSA9PiBpbnB1dC5kaW1zKTtcbiAgY29udGV4dC5jb21wdXRlKGNyZWF0ZUVpbnN1bVByb2dyYW1JbmZvKFxuICAgICAgZW5hYmxlSW5wdXRTaGFwZXNVbmlmb3JtcywgaW5wdXRTaGFwZXMsIGNvbnRleHQuaW5wdXRzWzBdLmRhdGFUeXBlLCBlaW5zdW1FcXVhdGlvbiwgb3V0cHV0U2hhcGUpKTtcbn07XG5cbmV4cG9ydCBjb25zdCBwYXJzZUVpbnN1bUF0dHJpYnV0ZXMgPSAoYXR0cmlidXRlczogUmVjb3JkPHN0cmluZywgdW5rbm93bj4pOiBFaW5zdW1BdHRyaWJ1dGVzID0+IHtcbiAgY29uc3QgZXF1YXRpb24gPSAoYXR0cmlidXRlcy5lcXVhdGlvbiBhcyBzdHJpbmcpLnJlcGxhY2UoL1xccysvZywgJycpO1xuICByZXR1cm4gY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KHtlcXVhdGlvbn0pO1xufTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtEYXRhVHlwZX0gZnJvbSAnLi4vLi4vLi4vd2FzbS1jb21tb24nO1xuaW1wb3J0IHtUZW5zb3JWaWV3fSBmcm9tICcuLi8uLi90ZW5zb3Itdmlldyc7XG5pbXBvcnQge1NoYXBlVXRpbH0gZnJvbSAnLi4vLi4vdXRpbCc7XG5pbXBvcnQge0NvbXB1dGVDb250ZXh0LCBQcm9ncmFtSW5mbywgUHJvZ3JhbVVuaWZvcm19IGZyb20gJy4uL3R5cGVzJztcblxuaW1wb3J0IHtjcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcywgZW5hYmxlU2hhcGVzVW5pZm9ybXMsIGlucHV0VmFyaWFibGUsIG91dHB1dFZhcmlhYmxlLCBTaGFkZXJIZWxwZXJ9IGZyb20gJy4vY29tbW9uJztcblxuY29uc3QgdmFsaWRhdGVJbnB1dHMgPSAoaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10pOiB2b2lkID0+IHtcbiAgaWYgKCFpbnB1dHMgfHwgaW5wdXRzLmxlbmd0aCAhPT0gMikge1xuICAgIHRocm93IG5ldyBFcnJvcignRXhwYW5kIHJlcXVpcmVzIDIgaW5wdXQuJyk7XG4gIH1cbiAgY29uc3QgaW5wdXRTaGFwZSA9IGlucHV0c1swXS5kaW1zO1xuICBjb25zdCBzaGFwZSA9IEFycmF5LmZyb20oaW5wdXRzWzFdLmdldEJpZ0ludDY0QXJyYXkoKSwgTnVtYmVyKTtcblxuICBsZXQgc2hhcGVJbmRleCA9IHNoYXBlLmxlbmd0aCA8IGlucHV0U2hhcGUubGVuZ3RoID8gMCA6IHNoYXBlLmxlbmd0aCAtIGlucHV0U2hhcGUubGVuZ3RoO1xuICBsZXQgaW5wdXRTaGFwZUluZGV4ID0gaW5wdXRTaGFwZS5sZW5ndGggPCBzaGFwZS5sZW5ndGggPyAwIDogaW5wdXRTaGFwZS5sZW5ndGggLSBzaGFwZS5sZW5ndGg7XG4gIGZvciAoOyBzaGFwZUluZGV4IDwgc2hhcGUubGVuZ3RoICYmIGlucHV0U2hhcGVJbmRleCA8IGlucHV0U2hhcGUubGVuZ3RoOyArK3NoYXBlSW5kZXgsICsraW5wdXRTaGFwZUluZGV4KSB7XG4gICAgaWYgKHNoYXBlW3NoYXBlSW5kZXhdICE9PSBpbnB1dFNoYXBlW2lucHV0U2hhcGVJbmRleF0gJiYgc2hhcGVbc2hhcGVJbmRleF0gIT09IDEgJiZcbiAgICAgICAgaW5wdXRTaGFwZVtpbnB1dFNoYXBlSW5kZXhdICE9PSAxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGFuZCByZXF1aXJlcyBzaGFwZSB0byBiZSBicm9hZGNhc3RhYmxlIHRvIGlucHV0Jyk7XG4gICAgfVxuICB9XG59O1xuXG5jb25zdCBnZXRBZGp1c3RlZFNoYXBlID0gKHNoYXBlMTogcmVhZG9ubHkgbnVtYmVyW10sIHNoYXBlMjogcmVhZG9ubHkgbnVtYmVyW10pOiBudW1iZXJbXSA9PiB7XG4gIGNvbnN0IGRpZmYgPSBzaGFwZTEubGVuZ3RoIC0gc2hhcGUyLmxlbmd0aDtcbiAgY29uc3Qgc2hhcGU6IG51bWJlcltdID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZGlmZjsgKytpKSB7XG4gICAgc2hhcGUucHVzaChzaGFwZTFbaV0pO1xuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc2hhcGUyLmxlbmd0aDsgKytpKSB7XG4gICAgc2hhcGUucHVzaChzaGFwZTJbaV0gPT09IDEgPyBzaGFwZTFbaSArIGRpZmZdIDogc2hhcGUyW2ldKTtcbiAgfVxuICByZXR1cm4gc2hhcGU7XG59O1xuXG5jb25zdCBjYWxjdWxhdGVPdXRwdXRTaGFwZSA9IChpbnB1dFNoYXBlOiByZWFkb25seSBudW1iZXJbXSwgc2hhcGU6IHJlYWRvbmx5IG51bWJlcltdKTogbnVtYmVyW10gPT5cbiAgICAoaW5wdXRTaGFwZS5sZW5ndGggPiBzaGFwZS5sZW5ndGgpID8gZ2V0QWRqdXN0ZWRTaGFwZShpbnB1dFNoYXBlLCBzaGFwZSkgOiBnZXRBZGp1c3RlZFNoYXBlKHNoYXBlLCBpbnB1dFNoYXBlKTtcblxuXG5jb25zdCBjcmVhdGVFeHBhbmRQcm9ncmFtSW5mbyA9IChpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSk6IFByb2dyYW1JbmZvID0+IHtcbiAgY29uc3QgaW5wdXRTaGFwZSA9IGlucHV0c1swXS5kaW1zO1xuICBjb25zdCBzaGFwZSA9IEFycmF5LmZyb20oaW5wdXRzWzFdLmdldEJpZ0ludDY0QXJyYXkoKSwgTnVtYmVyKTtcbiAgY29uc3Qgb3V0cHV0U2hhcGU6IG51bWJlcltdID0gY2FsY3VsYXRlT3V0cHV0U2hhcGUoaW5wdXRTaGFwZSwgc2hhcGUpO1xuICBjb25zdCBkYXRhVHlwZSA9IGlucHV0c1swXS5kYXRhVHlwZTtcbiAgY29uc3QgY29tcG9uZW50cyA9IGRhdGFUeXBlID09PSBEYXRhVHlwZS5ib29sID8gNCA6IDE7XG4gIGNvbnN0IG91dHB1dFNpemUgPSBNYXRoLmNlaWwoU2hhcGVVdGlsLnNpemUob3V0cHV0U2hhcGUpIC8gY29tcG9uZW50cyk7XG5cbiAgY29uc3QgZW5hYmxlSW5wdXRTaGFwZVVuaWZvcm0gPSBlbmFibGVTaGFwZXNVbmlmb3JtcyhpbnB1dFNoYXBlLmxlbmd0aCk7XG4gIGNvbnN0IGVuYWJsZU91dHB1dFNoYXBlVW5pZm9ybSA9IGVuYWJsZVNoYXBlc1VuaWZvcm1zKG91dHB1dFNoYXBlLmxlbmd0aCk7XG5cblxuICBjb25zdCBnZXRTaGFkZXJTb3VyY2UgPSAoc2hhZGVySGVscGVyOiBTaGFkZXJIZWxwZXIpID0+IHtcbiAgICBjb25zdCBpbnB1dFNoYXBlT3JSYW5rID0gZW5hYmxlSW5wdXRTaGFwZVVuaWZvcm0gPyBpbnB1dFNoYXBlLmxlbmd0aCA6IGlucHV0U2hhcGU7XG4gICAgY29uc3Qgb3V0cHV0U2hhcGVPclJhbmsgPSBlbmFibGVPdXRwdXRTaGFwZVVuaWZvcm0gPyBvdXRwdXRTaGFwZS5sZW5ndGggOiBvdXRwdXRTaGFwZTtcbiAgICBjb25zdCBpbnB1dCA9IGlucHV0VmFyaWFibGUoJ2lucHV0JywgZGF0YVR5cGUsIGlucHV0U2hhcGVPclJhbmssIGNvbXBvbmVudHMpO1xuICAgIGNvbnN0IG91dHB1dCA9IG91dHB1dFZhcmlhYmxlKCdvdXRwdXQnLCBkYXRhVHlwZSwgb3V0cHV0U2hhcGVPclJhbmssIGNvbXBvbmVudHMpO1xuICAgIGxldCBhc3NpZ25tZW50OiBzdHJpbmc7XG4gICAgaWYgKGRhdGFUeXBlID09PSBEYXRhVHlwZS5ib29sKSB7XG4gICAgICBjb25zdCBzaW5nbGVBc3NpZ25tZW50ID0gKHJlc1N0cjogc3RyaW5nLCB4OiBudW1iZXIsIHR5cGVDYXN0ID0gJycpID0+IGBcbiAgICAgICAgICBsZXQgb3V0cHV0SW5kaWNlcyR7eH0gPSAke291dHB1dC5vZmZzZXRUb0luZGljZXMoYG91dHB1dE9mZnNldCArICR7eH11YCl9O1xuICAgICAgICAgIGxldCBvZmZzZXQke3h9ID0gJHtpbnB1dC5icm9hZGNhc3RlZEluZGljZXNUb09mZnNldChgb3V0cHV0SW5kaWNlcyR7eH1gLCBvdXRwdXQpfTtcbiAgICAgICAgICBsZXQgaW5kZXgke3h9ID0gb2Zmc2V0JHt4fSAvIDR1O1xuICAgICAgICAgIGxldCBjb21wb25lbnQke3h9ID0gb2Zmc2V0JHt4fSAlIDR1O1xuICAgICAgICAgICR7cmVzU3RyfVske3h9XSA9ICR7dHlwZUNhc3R9KCR7aW5wdXQuZ2V0QnlPZmZzZXQoYGluZGV4JHt4fWApfVtjb21wb25lbnQke3h9XSk7XG4gICAgICAgIGA7XG4gICAgICBhc3NpZ25tZW50ID0gYFxuICAgICAgICBsZXQgb3V0cHV0T2Zmc2V0ID0gZ2xvYmFsX2lkeCAqICR7Y29tcG9uZW50c307XG4gICAgICAgIHZhciBkYXRhID0gdmVjNDx1MzI+KDApO1xuICAgICAgICAke3NpbmdsZUFzc2lnbm1lbnQoJ2RhdGEnLCAwLCAndTMyJyl9XG4gICAgICAgICR7c2luZ2xlQXNzaWdubWVudCgnZGF0YScsIDEsICd1MzInKX1cbiAgICAgICAgJHtzaW5nbGVBc3NpZ25tZW50KCdkYXRhJywgMiwgJ3UzMicpfVxuICAgICAgICAke3NpbmdsZUFzc2lnbm1lbnQoJ2RhdGEnLCAzLCAndTMyJyl9XG4gICAgICAgICR7b3V0cHV0LnNldEJ5T2Zmc2V0KCdnbG9iYWxfaWR4JywgJ2RhdGEnKX1cbiAgICAgIH1gO1xuICAgIH0gZWxzZSB7XG4gICAgICBhc3NpZ25tZW50ID0gYFxuICAgICAgICBsZXQgb3V0cHV0SW5kaWNlcyA9ICR7b3V0cHV0Lm9mZnNldFRvSW5kaWNlcygnZ2xvYmFsX2lkeCcpfTtcbiAgICAgICAgbGV0IGlucHV0T2Zmc2V0ID0gJHtpbnB1dC5icm9hZGNhc3RlZEluZGljZXNUb09mZnNldCgnb3V0cHV0SW5kaWNlcycsIG91dHB1dCl9O1xuICAgICAgICAke291dHB1dC5zZXRCeU9mZnNldCgnZ2xvYmFsX2lkeCcsIGlucHV0LmdldEJ5T2Zmc2V0KCdpbnB1dE9mZnNldCcpKX1cbiAgICAgIH1gO1xuICAgIH1cbiAgICByZXR1cm4gYFxuICAgICR7c2hhZGVySGVscGVyLnJlZ2lzdGVyVW5pZm9ybSgndmVjX3NpemUnLCAndTMyJykuZGVjbGFyZVZhcmlhYmxlcyhpbnB1dCwgb3V0cHV0KX1cbiAgICAke3NoYWRlckhlbHBlci5tYWluU3RhcnQoKX1cbiAgICAke3NoYWRlckhlbHBlci5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKCd1bmlmb3Jtcy52ZWNfc2l6ZScpfVxuICAgICR7YXNzaWdubWVudH1gO1xuICB9O1xuXG4gIGNvbnN0IHByb2dyYW1Vbmlmb3JtczogUHJvZ3JhbVVuaWZvcm1bXSA9IFt7dHlwZTogJ3VpbnQzMicsIGRhdGE6IG91dHB1dFNpemV9XTtcbiAgaWYgKGVuYWJsZUlucHV0U2hhcGVVbmlmb3JtKSB7XG4gICAgcHJvZ3JhbVVuaWZvcm1zLnB1c2goLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMoaW5wdXRTaGFwZSkpO1xuICB9XG4gIGlmIChlbmFibGVPdXRwdXRTaGFwZVVuaWZvcm0pIHtcbiAgICBwcm9ncmFtVW5pZm9ybXMucHVzaCguLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhvdXRwdXRTaGFwZSkpO1xuICB9XG4gIHJldHVybiB7XG4gICAgbmFtZTogJ0V4cGFuZCcsXG4gICAgc2hhZGVyQ2FjaGU6IHtoaW50OiBgJHtvdXRwdXRTaGFwZS5sZW5ndGh9YCwgaW5wdXREZXBlbmRlbmNpZXM6IFtlbmFibGVJbnB1dFNoYXBlVW5pZm9ybSA/ICdyYW5rJyA6ICdkaW1zJ119LFxuICAgIGdldFNoYWRlclNvdXJjZSxcbiAgICBnZXRSdW5EYXRhOiAoKSA9PiAoe1xuICAgICAgb3V0cHV0czogW3tkaW1zOiBvdXRwdXRTaGFwZSwgZGF0YVR5cGU6IGlucHV0c1swXS5kYXRhVHlwZX1dLFxuICAgICAgZGlzcGF0Y2hHcm91cDoge3g6IE1hdGguY2VpbChvdXRwdXRTaXplIC8gNjQgLyogd29ya2dyb3VwIHNpemUgKi8pfSxcbiAgICAgIHByb2dyYW1Vbmlmb3Jtc1xuICAgIH0pXG4gIH07XG59O1xuXG5leHBvcnQgY29uc3QgZXhwYW5kID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0KTogdm9pZCA9PiB7XG4gIHZhbGlkYXRlSW5wdXRzKGNvbnRleHQuaW5wdXRzKTtcbiAgY29udGV4dC5jb21wdXRlKGNyZWF0ZUV4cGFuZFByb2dyYW1JbmZvKGNvbnRleHQuaW5wdXRzKSwge2lucHV0czogWzBdfSk7XG59O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge0RhdGFUeXBlfSBmcm9tICcuLi8uLi8uLi93YXNtLWNvbW1vbic7XG5pbXBvcnQge1RlbnNvclZpZXd9IGZyb20gJy4uLy4uL3RlbnNvci12aWV3JztcbmltcG9ydCB7U2hhcGVVdGlsfSBmcm9tICcuLi8uLi91dGlsJztcbmltcG9ydCB7QXR0cmlidXRlV2l0aENhY2hlS2V5LCBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXl9IGZyb20gJy4uL2F0dHJpYnV0ZS13aXRoLWNhY2hlLWtleSc7XG5pbXBvcnQge0NvbXB1dGVDb250ZXh0LCBQcm9ncmFtSW5mbywgUHJvZ3JhbUlucHV0VGVuc29ySW5mb0RlcGVuZGVuY3ksIFByb2dyYW1Vbmlmb3JtfSBmcm9tICcuLi90eXBlcyc7XG5cbmltcG9ydCB7Y3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMsIGVuYWJsZVNoYXBlc1VuaWZvcm1zLCBpbnB1dFZhcmlhYmxlLCBvdXRwdXRWYXJpYWJsZSwgU2hhZGVySGVscGVyfSBmcm9tICcuL2NvbW1vbic7XG5cbmV4cG9ydCBpbnRlcmZhY2UgR2F0aGVyQXR0cmlidXRlcyBleHRlbmRzIEF0dHJpYnV0ZVdpdGhDYWNoZUtleSB7XG4gIGF4aXM6IG51bWJlcjtcbn1cblxuY29uc3QgdmFsaWRhdGVJbnB1dHMgPSAoaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10pOiB2b2lkID0+IHtcbiAgaWYgKCFpbnB1dHMgfHwgaW5wdXRzLmxlbmd0aCAhPT0gMikge1xuICAgIHRocm93IG5ldyBFcnJvcignR2F0aGVyIHJlcXVpcmVzIDIgaW5wdXRzLicpO1xuICB9XG59O1xuXG5jb25zdCBjcmVhdGVHYXRoZXJQcm9ncmFtSW5mbyA9IChpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSwgYXR0cmlidXRlczogR2F0aGVyQXR0cmlidXRlcyk6IFByb2dyYW1JbmZvID0+IHtcbiAgY29uc3QgaW5wdXRTaGFwZSA9IGlucHV0c1swXS5kaW1zO1xuICBjb25zdCBpbmRpY2VzU2hhcGUgPSBpbnB1dHNbMV0uZGltcztcblxuICBjb25zdCBpbnB1dFJhbmsgPSBpbnB1dFNoYXBlLmxlbmd0aDtcbiAgY29uc3QgYXhpcyA9IFNoYXBlVXRpbC5ub3JtYWxpemVBeGlzKGF0dHJpYnV0ZXMuYXhpcywgaW5wdXRSYW5rKTtcblxuICBjb25zdCBvdXRwdXRTaGFwZSA9IGlucHV0U2hhcGUuc2xpY2UoMCk7XG4gIG91dHB1dFNoYXBlLnNwbGljZShheGlzLCAxLCAuLi5pbmRpY2VzU2hhcGUpO1xuXG4gIGNvbnN0IGF4aXNEaW1MaW1pdCA9IGlucHV0U2hhcGVbYXhpc107XG4gIGNvbnN0IGNvbXBvbmVudHMgPSBpbnB1dHNbMF0uZGF0YVR5cGUgPT09IERhdGFUeXBlLmJvb2wgPyA0IDogMTtcbiAgY29uc3Qgb3V0cHV0U2l6ZSA9IE1hdGguY2VpbChTaGFwZVV0aWwuc2l6ZShvdXRwdXRTaGFwZSkgLyBjb21wb25lbnRzKTtcblxuICBjb25zdCBlbmFibGVJbnB1dFNoYXBlc1VuaWZvcm1zID0gZW5hYmxlU2hhcGVzVW5pZm9ybXMoaW5wdXRzWzBdLmRpbXMubGVuZ3RoKTtcbiAgY29uc3QgaW5wdXRTaGFwZU9yUmFuayA9IGVuYWJsZUlucHV0U2hhcGVzVW5pZm9ybXMgPyBpbnB1dHNbMF0uZGltcy5sZW5ndGggOiBpbnB1dHNbMF0uZGltcztcbiAgY29uc3QgZW5hYmxlSW5kaWNlc1NoYXBlc1VuaWZvcm1zID0gZW5hYmxlU2hhcGVzVW5pZm9ybXMoaW5wdXRzWzFdLmRpbXMubGVuZ3RoKTtcbiAgY29uc3QgaW5kaWNlc1NoYXBlT3JSYW5rID0gZW5hYmxlSW5kaWNlc1NoYXBlc1VuaWZvcm1zID8gaW5wdXRzWzFdLmRpbXMubGVuZ3RoIDogaW5wdXRzWzFdLmRpbXM7XG4gIGNvbnN0IGVuYWJsZU91dHB1dFNoYXBlc1VuaWZvcm1zID0gZW5hYmxlU2hhcGVzVW5pZm9ybXMob3V0cHV0U2hhcGUubGVuZ3RoKTtcbiAgY29uc3Qgb3V0cHV0U2hhcGVPclJhbmsgPSBlbmFibGVPdXRwdXRTaGFwZXNVbmlmb3JtcyA/IG91dHB1dFNoYXBlLmxlbmd0aCA6IG91dHB1dFNoYXBlO1xuXG4gIGNvbnN0IHByb2dyYW1Vbmlmb3JtczogUHJvZ3JhbVVuaWZvcm1bXSA9XG4gICAgICBbe3R5cGU6ICd1aW50MzInLCBkYXRhOiBvdXRwdXRTaXplfSwge3R5cGU6ICdpbnQzMicsIGRhdGE6IGF4aXNEaW1MaW1pdH0sIHt0eXBlOiAndWludDMyJywgZGF0YTogYXhpc31dO1xuICBpZiAoZW5hYmxlSW5wdXRTaGFwZXNVbmlmb3Jtcykge1xuICAgIHByb2dyYW1Vbmlmb3Jtcy5wdXNoKC4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKGlucHV0c1swXS5kaW1zKSk7XG4gIH1cbiAgaWYgKGVuYWJsZUluZGljZXNTaGFwZXNVbmlmb3Jtcykge1xuICAgIHByb2dyYW1Vbmlmb3Jtcy5wdXNoKC4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKGlucHV0c1sxXS5kaW1zKSk7XG4gIH1cbiAgaWYgKGVuYWJsZU91dHB1dFNoYXBlc1VuaWZvcm1zKSB7XG4gICAgcHJvZ3JhbVVuaWZvcm1zLnB1c2goLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMob3V0cHV0U2hhcGUpKTtcbiAgfVxuXG4gIGNvbnN0IGlucHV0RGVwZW5kZW5jaWVzOiBQcm9ncmFtSW5wdXRUZW5zb3JJbmZvRGVwZW5kZW5jeVtdID0gW107XG4gIGlucHV0RGVwZW5kZW5jaWVzLnB1c2goZW5hYmxlSW5wdXRTaGFwZXNVbmlmb3JtcyA/ICdyYW5rJyA6ICdkaW1zJyk7XG4gIGlucHV0RGVwZW5kZW5jaWVzLnB1c2goZW5hYmxlSW5kaWNlc1NoYXBlc1VuaWZvcm1zID8gJ3JhbmsnIDogJ2RpbXMnKTtcblxuICBjb25zdCBnZXRTaGFkZXJTb3VyY2UgPSAoc2hhZGVySGVscGVyOiBTaGFkZXJIZWxwZXIpID0+IHtcbiAgICBjb25zdCBkYXRhID0gaW5wdXRWYXJpYWJsZSgnZGF0YScsIGlucHV0c1swXS5kYXRhVHlwZSwgaW5wdXRTaGFwZU9yUmFuaywgY29tcG9uZW50cyk7XG4gICAgY29uc3QgaW5kaWNlcyA9IGlucHV0VmFyaWFibGUoJ2lucHV0SW5kaWNlcycsIGlucHV0c1sxXS5kYXRhVHlwZSwgaW5kaWNlc1NoYXBlT3JSYW5rKTtcbiAgICBjb25zdCBvdXRwdXQgPSBvdXRwdXRWYXJpYWJsZSgnb3V0cHV0JywgaW5wdXRzWzBdLmRhdGFUeXBlLCBvdXRwdXRTaGFwZU9yUmFuaywgY29tcG9uZW50cyk7XG5cbiAgICBjb25zdCBjYWxjRGF0YUluZGljZXMgPSAoeDogbnVtYmVyfHN0cmluZyk6IHN0cmluZyA9PiB7XG4gICAgICBjb25zdCBpbmRpY2VzUmFuayA9IGluZGljZXNTaGFwZS5sZW5ndGg7XG4gICAgICBsZXQgY2FsY1N0ciA9IGB2YXIgaW5kaWNlc0luZGljZXMke3h9ICA9ICR7aW5kaWNlcy50eXBlLmluZGljZXN9KDApO2A7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGluZGljZXNSYW5rOyBpKyspIHtcbiAgICAgICAgY2FsY1N0ciArPSBgJHtpbmRpY2VzUmFuayA+IDEgPyBgaW5kaWNlc0luZGljZXMke3h9WyR7aX1dYCA6IGBpbmRpY2VzSW5kaWNlcyR7eH1gfSA9ICR7XG4gICAgICAgICAgICBvdXRwdXRTaGFwZS5sZW5ndGggPiAxID8gYG91dHB1dEluZGljZXMke3h9W3VuaWZvcm1zLmF4aXMgKyAke2l9XWAgOiBgb3V0cHV0SW5kaWNlcyR7eH1gfTtgO1xuICAgICAgfVxuICAgICAgY2FsY1N0ciArPSBgXG4gICAgICAgICAgdmFyIGlkeCR7eH0gPSAke2luZGljZXMuZ2V0QnlJbmRpY2VzKGBpbmRpY2VzSW5kaWNlcyR7eH1gKX07XG4gICAgICAgICAgaWYgKGlkeCR7eH0gPCAwKSB7XG4gICAgICAgICAgICBpZHgke3h9ID0gaWR4JHt4fSArIHVuaWZvcm1zLmF4aXNEaW1MaW1pdDtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGRhdGFJbmRpY2VzJHt4fSA9ICR7ZGF0YS50eXBlLmluZGljZXN9KDApO1xuICAgICAgICBgO1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGogPSAwOyBpIDwgaW5wdXRSYW5rOyBpKyspIHtcbiAgICAgICAgaWYgKGkgPT09IGF4aXMpIHtcbiAgICAgICAgICBjYWxjU3RyICs9IGAke2lucHV0UmFuayA+IDEgPyBgZGF0YUluZGljZXMke3h9WyR7aX1dYCA6IGBkYXRhSW5kaWNlcyR7eH1gfSA9IHUzMihpZHgke3h9KTtgO1xuICAgICAgICAgIGogKz0gaW5kaWNlc1Jhbms7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2FsY1N0ciArPSBgJHtpbnB1dFJhbmsgPiAxID8gYGRhdGFJbmRpY2VzJHt4fVske2l9XWAgOiBgZGF0YUluZGljZXMke3h9YH0gPSAke1xuICAgICAgICAgICAgICBvdXRwdXRTaGFwZS5sZW5ndGggPiAxID8gYG91dHB1dEluZGljZXMke3h9WyR7an1dYCA6IGBvdXRwdXRJbmRpY2VzJHt4fWB9O2A7XG4gICAgICAgICAgaisrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gY2FsY1N0cjtcbiAgICB9O1xuICAgIGxldCBhc3NpZ25tZW50OiBzdHJpbmc7XG4gICAgaWYgKGlucHV0c1swXS5kYXRhVHlwZSA9PT0gRGF0YVR5cGUuYm9vbCkge1xuICAgICAgY29uc3Qgc2luZ2xlQXNzaWdubWVudCA9IChyZXNTdHI6IHN0cmluZywgeDogbnVtYmVyLCB0eXBlQ2FzdCA9ICcnKSA9PiBgXG4gICAgICAgICAgbGV0IG91dHB1dEluZGljZXMke3h9ID0gJHtvdXRwdXQub2Zmc2V0VG9JbmRpY2VzKGBvdXRwdXRPZmZzZXQgKyAke3h9dWApfTtcbiAgICAgICAgICAke2NhbGNEYXRhSW5kaWNlcyh4KX07XG4gICAgICAgICAgbGV0IG9mZnNldCR7eH0gPSAke2RhdGEuaW5kaWNlc1RvT2Zmc2V0KGBkYXRhSW5kaWNlcyR7eH1gKX07XG4gICAgICAgICAgbGV0IGluZGV4JHt4fSA9IG9mZnNldCR7eH0gLyA0dTtcbiAgICAgICAgICBsZXQgY29tcG9uZW50JHt4fSA9IG9mZnNldCR7eH0gJSA0dTtcbiAgICAgICAgICAke3Jlc1N0cn1bJHt4fV0gPSAke3R5cGVDYXN0fSgke2RhdGEuZ2V0QnlPZmZzZXQoYGluZGV4JHt4fWApfVtjb21wb25lbnQke3h9XSk7XG4gICAgICAgIGA7XG4gICAgICBhc3NpZ25tZW50ID0gYFxuICAgICAgICBsZXQgb3V0cHV0T2Zmc2V0ID0gZ2xvYmFsX2lkeCAqICR7Y29tcG9uZW50c307XG4gICAgICAgIHZhciB2YWx1ZSA9IHZlYzQ8dTMyPigwKTtcbiAgICAgICAgJHtzaW5nbGVBc3NpZ25tZW50KCd2YWx1ZScsIDAsICd1MzInKX1cbiAgICAgICAgJHtzaW5nbGVBc3NpZ25tZW50KCd2YWx1ZScsIDEsICd1MzInKX1cbiAgICAgICAgJHtzaW5nbGVBc3NpZ25tZW50KCd2YWx1ZScsIDIsICd1MzInKX1cbiAgICAgICAgJHtzaW5nbGVBc3NpZ25tZW50KCd2YWx1ZScsIDMsICd1MzInKX1cbiAgICAgICAgJHtvdXRwdXQuc2V0QnlPZmZzZXQoJ2dsb2JhbF9pZHgnLCAndmFsdWUnKX1cbiAgICAgIGA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFzc2lnbm1lbnQgPSBgXG4gICAgICBsZXQgb3V0cHV0SW5kaWNlcyA9ICR7b3V0cHV0Lm9mZnNldFRvSW5kaWNlcygnZ2xvYmFsX2lkeCcpfTtcbiAgICAgICR7Y2FsY0RhdGFJbmRpY2VzKCcnKX07XG4gICAgICBsZXQgdmFsdWUgPSAke2RhdGEuZ2V0QnlJbmRpY2VzKCdkYXRhSW5kaWNlcycpfTtcbiAgICAgICR7b3V0cHV0LnNldEJ5T2Zmc2V0KCdnbG9iYWxfaWR4JywgJ3ZhbHVlJyl9O1xuICAgICAgYDtcbiAgICB9XG4gICAgcmV0dXJuIGBcbiAgICAgICR7XG4gICAgICAgIHNoYWRlckhlbHBlci5yZWdpc3RlclVuaWZvcm0oJ291dHB1dFNpemUnLCAndTMyJylcbiAgICAgICAgICAgIC5yZWdpc3RlclVuaWZvcm0oJ2F4aXNEaW1MaW1pdCcsICdpMzInKVxuICAgICAgICAgICAgLnJlZ2lzdGVyVW5pZm9ybSgnYXhpcycsICd1MzInKVxuICAgICAgICAgICAgLmRlY2xhcmVWYXJpYWJsZXMoZGF0YSwgaW5kaWNlcywgb3V0cHV0KX1cbiAgICAgICR7c2hhZGVySGVscGVyLm1haW5TdGFydCgpfVxuICAgICAgICAke3NoYWRlckhlbHBlci5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKCd1bmlmb3Jtcy5vdXRwdXRTaXplJyl9XG4gICAgICAgICR7YXNzaWdubWVudH1cbiAgICAgIH1gO1xuICB9O1xuICByZXR1cm4ge1xuICAgIG5hbWU6ICdHYXRoZXInLFxuICAgIHNoYWRlckNhY2hlOiB7aGludDogYXR0cmlidXRlcy5jYWNoZUtleSwgaW5wdXREZXBlbmRlbmNpZXN9LFxuICAgIGdldFJ1bkRhdGE6ICgpID0+ICh7XG4gICAgICBvdXRwdXRzOiBbXG4gICAgICAgIHtkaW1zOiBvdXRwdXRTaGFwZSwgZGF0YVR5cGU6IGlucHV0c1swXS5kYXRhVHlwZX0sXG4gICAgICBdLFxuICAgICAgZGlzcGF0Y2hHcm91cDoge3g6IE1hdGguY2VpbChvdXRwdXRTaXplIC8gNjQgLyogd29ya2dyb3VwIHNpemUgKi8pfSxcbiAgICAgIHByb2dyYW1Vbmlmb3Jtc1xuICAgIH0pLFxuICAgIGdldFNoYWRlclNvdXJjZSxcbiAgfTtcbn07XG5cbmV4cG9ydCBjb25zdCBwYXJzZUdhdGhlckF0dHJpYnV0ZXMgPSAoYXR0cmlidXRlczogUmVjb3JkPHN0cmluZywgdW5rbm93bj4pOiBHYXRoZXJBdHRyaWJ1dGVzID0+XG4gICAgY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KHtheGlzOiBhdHRyaWJ1dGVzLmF4aXMgYXMgbnVtYmVyfSk7XG5cbmV4cG9ydCBjb25zdCBnYXRoZXIgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IEdhdGhlckF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgY29uc3QgaW5wdXRzID0gY29udGV4dC5pbnB1dHM7XG4gIHZhbGlkYXRlSW5wdXRzKGlucHV0cyk7XG4gIGNvbnRleHQuY29tcHV0ZShjcmVhdGVHYXRoZXJQcm9ncmFtSW5mbyhjb250ZXh0LmlucHV0cywgYXR0cmlidXRlcykpO1xufTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtUZW5zb3JWaWV3fSBmcm9tICcuLi8uLi90ZW5zb3Itdmlldyc7XG5pbXBvcnQge1NoYXBlVXRpbH0gZnJvbSAnLi4vLi4vdXRpbCc7XG5pbXBvcnQge0F0dHJpYnV0ZVdpdGhDYWNoZUtleSwgY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5fSBmcm9tICcuLi9hdHRyaWJ1dGUtd2l0aC1jYWNoZS1rZXknO1xuaW1wb3J0IHtDb21wdXRlQ29udGV4dCwgUHJvZ3JhbUluZm8sIFByb2dyYW1JbnB1dFRlbnNvckluZm9EZXBlbmRlbmN5LCBQcm9ncmFtVW5pZm9ybX0gZnJvbSAnLi4vdHlwZXMnO1xuXG5pbXBvcnQge2NyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzLCBpbnB1dFZhcmlhYmxlLCBvdXRwdXRWYXJpYWJsZSwgU2hhZGVySGVscGVyfSBmcm9tICcuL2NvbW1vbic7XG5cbmV4cG9ydCBpbnRlcmZhY2UgR2F0aGVyRWxlbWVudHNBdHRyaWJ1dGVzIGV4dGVuZHMgQXR0cmlidXRlV2l0aENhY2hlS2V5IHtcbiAgYXhpczogbnVtYmVyO1xufVxuXG5jb25zdCB2YWxpZGF0ZUlucHV0cyA9IChpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSk6IHZvaWQgPT4ge1xuICBpZiAoIWlucHV0cyB8fCBpbnB1dHMubGVuZ3RoICE9PSAyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdHYXRoZXJFbGVtZW50cyByZXF1aXJlcyAyIGlucHV0cy4nKTtcbiAgfVxuXG4gIGlmIChpbnB1dHNbMF0uZGltcy5sZW5ndGggPCAxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdHYXRoZXJFbGVtZW50cyByZXF1aXJlcyB0aGF0IHRoZSBkYXRhIGlucHV0IGJlIHJhbmsgPj0gMS4nKTtcbiAgfVxuXG4gIGlmIChpbnB1dHNbMF0uZGltcy5sZW5ndGggIT09IGlucHV0c1sxXS5kaW1zLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgR2F0aGVyRWxlbWVudHMgcmVxdWlyZXMgdGhhdCB0aGUgZGF0YSBpbnB1dCBhbmRcbiAgICAgICAgICAgICAgICAgICAgIGluZGljZXMgaW5wdXQgdGVuc29ycyBiZSBvZiBzYW1lIHJhbmsuYCk7XG4gIH1cbn07XG5cbmNvbnN0IGNyZWF0ZUdhdGhlckVsZW1lbnRzUHJvZ3JhbUluZm8gPVxuICAgIChpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSwgYXR0cmlidXRlczogR2F0aGVyRWxlbWVudHNBdHRyaWJ1dGVzKTogUHJvZ3JhbUluZm8gPT4ge1xuICAgICAgY29uc3QgaW5wdXRTaGFwZSA9IGlucHV0c1swXS5kaW1zO1xuICAgICAgY29uc3QgaW5wdXRPdXRwdXREYXRhVHlwZSA9IGlucHV0c1swXS5kYXRhVHlwZTtcbiAgICAgIGNvbnN0IGlucHV0UmFuayA9IGlucHV0U2hhcGUubGVuZ3RoO1xuXG4gICAgICBjb25zdCBpbmRpY2VzU2hhcGUgPSBpbnB1dHNbMV0uZGltcztcbiAgICAgIGNvbnN0IGluZGljZXNEYXRhVHlwZSA9IGlucHV0c1sxXS5kYXRhVHlwZTtcbiAgICAgIGNvbnN0IGF4aXMgPSBTaGFwZVV0aWwubm9ybWFsaXplQXhpcyhhdHRyaWJ1dGVzLmF4aXMsIGlucHV0UmFuayk7XG4gICAgICBjb25zdCBheGlzRGltTGltaXQgPSBpbnB1dFNoYXBlW2F4aXNdO1xuXG4gICAgICBjb25zdCBvdXRwdXRTaGFwZSA9IGluZGljZXNTaGFwZS5zbGljZSgwKTtcbiAgICAgIGNvbnN0IG91dHB1dFNpemUgPSBTaGFwZVV0aWwuc2l6ZShvdXRwdXRTaGFwZSk7XG5cbiAgICAgIGNvbnN0IGlucHV0ID0gaW5wdXRWYXJpYWJsZSgnaW5wdXQnLCBpbnB1dE91dHB1dERhdGFUeXBlLCBpbnB1dFJhbmspO1xuICAgICAgY29uc3QgaW5kaWNlcyA9IGlucHV0VmFyaWFibGUoJ2luZGljZXNJbnB1dCcsIGluZGljZXNEYXRhVHlwZSwgaW5kaWNlc1NoYXBlLmxlbmd0aCk7XG4gICAgICBjb25zdCBvdXRwdXQgPSBvdXRwdXRWYXJpYWJsZSgnb3V0cHV0JywgaW5wdXRPdXRwdXREYXRhVHlwZSwgb3V0cHV0U2hhcGUubGVuZ3RoKTtcblxuXG4gICAgICBjb25zdCBwcm9ncmFtVW5pZm9ybXM6IFByb2dyYW1Vbmlmb3JtW10gPVxuICAgICAgICAgIFt7dHlwZTogJ3VpbnQzMicsIGRhdGE6IG91dHB1dFNpemV9LCB7dHlwZTogJ2ludDMyJywgZGF0YTogYXhpc0RpbUxpbWl0fSwge3R5cGU6ICd1aW50MzInLCBkYXRhOiBheGlzfV07XG4gICAgICBwcm9ncmFtVW5pZm9ybXMucHVzaCguLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhpbnB1dFNoYXBlKSk7XG4gICAgICBwcm9ncmFtVW5pZm9ybXMucHVzaCguLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhpbmRpY2VzU2hhcGUpKTtcbiAgICAgIHByb2dyYW1Vbmlmb3Jtcy5wdXNoKC4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKG91dHB1dFNoYXBlKSk7XG4gICAgICBjb25zdCBpbnB1dERlcGVuZGVuY2llczogUHJvZ3JhbUlucHV0VGVuc29ySW5mb0RlcGVuZGVuY3lbXSA9IFsncmFuaycsICdyYW5rJ107XG5cbiAgICAgIC8vIGludDY0IGluZGljZXMgd291bGQgYmUgdHJlYXRlZCBhcyBsaXR0bGUgZW5kaWFuIGkzMiB3aXRoIGFzc3VtcHRpb24gdGhleSBmYWxsIGluIGkzMiBsaW1pdHNcbiAgICAgIC8vIFRoYXQgYXNzdW1wdGlvbiBpcyBzYWZlIGFzIGl0J3Mgbm90IHBvc3NpYmxlIHRvIGFsbG9jYXRlID4yZ2IgYnVmZmVyIGZvciBpbnB1dCB0ZW5zb3JcbiAgICAgIC8vIElucHV0IGRhdGEgd2lsbCBiZSB0cmVhdGVkIGFzIHUzMiBvciB0d28gdTMyIGZvciA4LWJ5dGUgdGVuc29yc1xuICAgICAgY29uc3QgZ2V0U2hhZGVyU291cmNlID0gKHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyKSA9PiBgXG4gICAgICAke1xuICAgICAgICAgIHNoYWRlckhlbHBlci5yZWdpc3RlclVuaWZvcm0oJ291dHB1dFNpemUnLCAndTMyJylcbiAgICAgICAgICAgICAgLnJlZ2lzdGVyVW5pZm9ybSgnYXhpc0RpbUxpbWl0JywgJ2kzMicpXG4gICAgICAgICAgICAgIC5yZWdpc3RlclVuaWZvcm0oJ2F4aXMnLCAndTMyJylcbiAgICAgICAgICAgICAgLmRlY2xhcmVWYXJpYWJsZXMoaW5wdXQsIGluZGljZXMsIG91dHB1dCl9XG4gICAgICAke3NoYWRlckhlbHBlci5tYWluU3RhcnQoKX1cbiAgICAgICR7c2hhZGVySGVscGVyLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoJ3VuaWZvcm1zLm91dHB1dFNpemUnKX1cblxuICAgICAgbGV0IG91dHB1dEluZGljZXMgPSAke291dHB1dC5vZmZzZXRUb0luZGljZXMoJ2dsb2JhbF9pZHgnKX07XG5cbiAgICAgIHZhciBpZHggPSAke2luZGljZXMuZ2V0QnlPZmZzZXQoJ2dsb2JhbF9pZHgnKX07XG4gICAgICBpZiAoaWR4IDwgMCkge1xuICAgICAgICBpZHggPSBpZHggKyB1bmlmb3Jtcy5heGlzRGltTGltaXQ7XG4gICAgICB9XG4gICAgICB2YXIgaW5wdXRJbmRpY2VzID0gJHtpbnB1dC50eXBlLmluZGljZXN9KG91dHB1dEluZGljZXMpO1xuICAgICAgJHtpbnB1dC5pbmRpY2VzU2V0KCdpbnB1dEluZGljZXMnLCAndW5pZm9ybXMuYXhpcycsICd1MzIoaWR4KScpfTtcbiAgICAgIGxldCB2YWx1ZSA9ICR7aW5wdXQuZ2V0QnlJbmRpY2VzKCdpbnB1dEluZGljZXMnKX07XG5cbiAgICAgICR7b3V0cHV0LnNldEJ5T2Zmc2V0KCdnbG9iYWxfaWR4JywgJ3ZhbHVlJyl9O1xuICB9YDtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZTogJ0dhdGhlckVsZW1lbnRzJyxcbiAgICAgICAgc2hhZGVyQ2FjaGU6IHtpbnB1dERlcGVuZGVuY2llc30sXG4gICAgICAgIGdldFJ1bkRhdGE6ICgpID0+ICh7XG4gICAgICAgICAgb3V0cHV0czogW3tkaW1zOiBvdXRwdXRTaGFwZSwgZGF0YVR5cGU6IGlucHV0c1swXS5kYXRhVHlwZX1dLFxuICAgICAgICAgIGRpc3BhdGNoR3JvdXA6IHt4OiBNYXRoLmNlaWwob3V0cHV0U2l6ZSAvIDY0IC8qIHdvcmtncm91cCBzaXplICovKX0sXG4gICAgICAgICAgcHJvZ3JhbVVuaWZvcm1zXG4gICAgICAgIH0pLFxuICAgICAgICBnZXRTaGFkZXJTb3VyY2UsXG4gICAgICB9O1xuICAgIH07XG5cbmV4cG9ydCBjb25zdCBwYXJzZUdhdGhlckVsZW1lbnRzQXR0cmlidXRlcyA9IChhdHRyaWJ1dGVzOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPik6IEdhdGhlckVsZW1lbnRzQXR0cmlidXRlcyA9PlxuICAgIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSh7YXhpczogYXR0cmlidXRlcy5heGlzIGFzIG51bWJlcn0pO1xuXG5leHBvcnQgY29uc3QgZ2F0aGVyRWxlbWVudHMgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IEdhdGhlckVsZW1lbnRzQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICBjb25zdCBpbnB1dHMgPSBjb250ZXh0LmlucHV0cztcbiAgdmFsaWRhdGVJbnB1dHMoaW5wdXRzKTtcbiAgY29udGV4dC5jb21wdXRlKGNyZWF0ZUdhdGhlckVsZW1lbnRzUHJvZ3JhbUluZm8oY29udGV4dC5pbnB1dHMsIGF0dHJpYnV0ZXMpKTtcbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7VGVuc29yVmlld30gZnJvbSAnLi4vLi4vdGVuc29yLXZpZXcnO1xuaW1wb3J0IHtHZW1tVXRpbCwgU2hhcGVVdGlsfSBmcm9tICcuLi8uLi91dGlsJztcbmltcG9ydCB7QXR0cmlidXRlV2l0aENhY2hlS2V5fSBmcm9tICcuLi9hdHRyaWJ1dGUtd2l0aC1jYWNoZS1rZXknO1xuaW1wb3J0IHtDb21wdXRlQ29udGV4dCwgUHJvZ3JhbUluZm8sIFByb2dyYW1JbnB1dFRlbnNvckluZm9EZXBlbmRlbmN5LCBQcm9ncmFtVW5pZm9ybX0gZnJvbSAnLi4vdHlwZXMnO1xuXG5pbXBvcnQge2NyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzLCBJbmRpY2VzSGVscGVyLCBpbnB1dFZhcmlhYmxlLCBvdXRwdXRWYXJpYWJsZSwgU2hhZGVySGVscGVyLCBVbmlmb3Jtc0FycmF5VHlwZX0gZnJvbSAnLi9jb21tb24nO1xuXG5jb25zdCB2YWxpZGF0ZUlucHV0cyA9IChpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSk6IHZvaWQgPT4ge1xuICBpZiAoIWlucHV0cykge1xuICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgaXMgbWlzc2luZycpO1xuICB9XG4gIGlmIChpbnB1dHMubGVuZ3RoIDwgMiB8fCBpbnB1dHMubGVuZ3RoID4gMykge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWlkIGlucHV0IG51bWJlci4nKTtcbiAgfVxuXG4gIC8vICdDJyBjYW4gYmUgb2YgZGltZW5zaW9uYWxpdHkgMCwgMSBvciAyIG9ubHlcbiAgaWYgKGlucHV0cy5sZW5ndGggPT09IDMgJiYgaW5wdXRzWzJdLmRpbXMubGVuZ3RoID4gMikge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBpbnB1dCBzaGFwZSBvZiBDJyk7XG4gIH1cblxuICBpZiAoKGlucHV0c1swXS5kYXRhVHlwZSAhPT0gaW5wdXRzWzFdLmRhdGFUeXBlKSB8fFxuICAgICAgKGlucHV0cy5sZW5ndGggPT09IDMgJiYgaW5wdXRzWzBdLmRhdGFUeXBlICE9PSBpbnB1dHNbMl0uZGF0YVR5cGUpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCB0eXBlcyBhcmUgbWlzbWF0Y2hlZCcpO1xuICB9XG59O1xuXG5leHBvcnQgaW50ZXJmYWNlIEdlbW1BdHRyaWJ1dGVzIGV4dGVuZHMgQXR0cmlidXRlV2l0aENhY2hlS2V5IHtcbiAgdHJhbnNBOiBib29sZWFuO1xuICB0cmFuc0I6IGJvb2xlYW47XG4gIGFscGhhOiBudW1iZXI7XG4gIGJldGE6IG51bWJlcjtcbn1cblxuY29uc3QgY3JlYXRlR2VtbVByb2dyYW1JbmZvID0gKGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdLCBhdHRyaWJ1dGVzOiBHZW1tQXR0cmlidXRlcyk6IFByb2dyYW1JbmZvID0+IHtcbiAgY29uc3QgYVNoYXBlID0gaW5wdXRzWzBdLmRpbXMuc2xpY2UoKTtcbiAgY29uc3QgYlNoYXBlID0gaW5wdXRzWzFdLmRpbXMuc2xpY2UoKTtcbiAgY29uc3QgW00sIE4sIEtdID0gR2VtbVV0aWwuZ2V0U2hhcGVPZkdlbW1SZXN1bHQoXG4gICAgICBhU2hhcGUsIGF0dHJpYnV0ZXMudHJhbnNBLCBiU2hhcGUsIGF0dHJpYnV0ZXMudHJhbnNCLCBpbnB1dHMubGVuZ3RoID09PSAzID8gaW5wdXRzWzJdLmRpbXMgOiB1bmRlZmluZWQpO1xuICBjb25zdCBvdXRwdXRTaGFwZSA9IFtNLCBOXTtcbiAgaWYgKCFvdXRwdXRTaGFwZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignQ2FuXFwndCB1c2UgZ2VtbSBvbiB0aGUgZ2l2ZW4gdGVuc29ycycpO1xuICB9XG4gIGNvbnN0IG91dHB1dFNpemUgPSBTaGFwZVV0aWwuc2l6ZShvdXRwdXRTaGFwZSk7XG4gIGNvbnN0IHByb2dyYW1Vbmlmb3JtczogUHJvZ3JhbVVuaWZvcm1bXSA9IFtcbiAgICB7dHlwZTogJ3VpbnQzMicsIGRhdGE6IG91dHB1dFNpemV9LCB7dHlwZTogJ3VpbnQzMicsIGRhdGE6IE19LCB7dHlwZTogJ3VpbnQzMicsIGRhdGE6IE59LCB7dHlwZTogJ3VpbnQzMicsIGRhdGE6IEt9LFxuICAgIHt0eXBlOiAnZmxvYXQzMicsIGRhdGE6IGF0dHJpYnV0ZXMuYWxwaGF9LCB7dHlwZTogJ2Zsb2F0MzInLCBkYXRhOiBhdHRyaWJ1dGVzLmJldGF9XG4gIF07XG4gIGNvbnN0IGlucHV0RGVwZW5kZW5jaWVzOiBQcm9ncmFtSW5wdXRUZW5zb3JJbmZvRGVwZW5kZW5jeVtdID0gWyd0eXBlJywgJ3R5cGUnXTtcbiAgaWYgKGlucHV0cy5sZW5ndGggPT09IDMpIHtcbiAgICBwcm9ncmFtVW5pZm9ybXMucHVzaCguLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhpbnB1dHNbMl0uZGltcykpO1xuICAgIGlucHV0RGVwZW5kZW5jaWVzLnB1c2goJ3JhbmsnKTtcbiAgfVxuICBwcm9ncmFtVW5pZm9ybXMucHVzaCguLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhvdXRwdXRTaGFwZSkpO1xuXG4gIGNvbnN0IGdldFNoYWRlclNvdXJjZSA9IChzaGFkZXJIZWxwZXI6IFNoYWRlckhlbHBlcikgPT4ge1xuICAgIGxldCBsaW5lID0gJyc7XG4gICAgaWYgKGF0dHJpYnV0ZXMudHJhbnNBICYmIGF0dHJpYnV0ZXMudHJhbnNCKSB7XG4gICAgICBsaW5lID0gJ3ZhbHVlICs9IGFbayAqIHVuaWZvcm1zLk0gKyBtXSAqIGJbbiAqIHVuaWZvcm1zLksgKyBrXTsnO1xuICAgIH0gZWxzZSBpZiAoYXR0cmlidXRlcy50cmFuc0EgJiYgIWF0dHJpYnV0ZXMudHJhbnNCKSB7XG4gICAgICBsaW5lID0gJ3ZhbHVlICs9IGFbayAqIHVuaWZvcm1zLk0gKyBtXSAqIGJbayAqIHVuaWZvcm1zLk4gKyBuXTsnO1xuICAgIH0gZWxzZSBpZiAoIWF0dHJpYnV0ZXMudHJhbnNBICYmIGF0dHJpYnV0ZXMudHJhbnNCKSB7XG4gICAgICBsaW5lID0gJ3ZhbHVlICs9IGFbbSAqIHVuaWZvcm1zLksgKyBrXSAqIGJbbiAqIHVuaWZvcm1zLksgKyBrXTsnO1xuICAgIH0gZWxzZSBpZiAoIWF0dHJpYnV0ZXMudHJhbnNBICYmICFhdHRyaWJ1dGVzLnRyYW5zQikge1xuICAgICAgbGluZSA9ICd2YWx1ZSArPSBhW20gKiB1bmlmb3Jtcy5LICsga10gKiBiW2sgKiB1bmlmb3Jtcy5OICsgbl07JztcbiAgICB9XG5cbiAgICBjb25zdCBjYWxjdWxhdGVBbHBoYSA9IGF0dHJpYnV0ZXMuYWxwaGEgPT09IDEgPyAnJyA6ICd2YWx1ZSAqPSB1bmlmb3Jtcy5hbHBoYTsnO1xuICAgIGNvbnN0IGEgPSBpbnB1dFZhcmlhYmxlKCdhJywgaW5wdXRzWzBdLmRhdGFUeXBlLCBpbnB1dHNbMF0uZGltcyk7XG4gICAgY29uc3QgYiA9IGlucHV0VmFyaWFibGUoJ2InLCBpbnB1dHNbMV0uZGF0YVR5cGUsIGlucHV0c1sxXS5kaW1zKTtcbiAgICBjb25zdCBkYXRhVHlwZSA9IGEudHlwZS52YWx1ZTtcbiAgICBsZXQgYzogSW5kaWNlc0hlbHBlcnxudWxsID0gbnVsbDtcbiAgICBjb25zdCB2YXJpYWJsZXMgPSBbYSwgYl07XG4gICAgaWYgKGlucHV0cy5sZW5ndGggPT09IDMpIHtcbiAgICAgIGMgPSBpbnB1dFZhcmlhYmxlKCdjJywgaW5wdXRzWzJdLmRhdGFUeXBlLCBpbnB1dHNbMl0uZGltcy5sZW5ndGgpO1xuICAgICAgdmFyaWFibGVzLnB1c2goYyk7XG4gICAgfVxuICAgIGNvbnN0IG91dHB1dCA9IG91dHB1dFZhcmlhYmxlKCdvdXRwdXQnLCBpbnB1dHNbMF0uZGF0YVR5cGUsIG91dHB1dFNoYXBlLmxlbmd0aCk7XG4gICAgdmFyaWFibGVzLnB1c2gob3V0cHV0KTtcbiAgICBjb25zdCB1bmlmb3JtczogVW5pZm9ybXNBcnJheVR5cGUgPSBbXG4gICAgICB7bmFtZTogJ291dHB1dF9zaXplJywgdHlwZTogJ3UzMid9LCB7bmFtZTogJ00nLCB0eXBlOiAndTMyJ30sIHtuYW1lOiAnTicsIHR5cGU6ICd1MzInfSwge25hbWU6ICdLJywgdHlwZTogJ3UzMid9LFxuICAgICAge25hbWU6ICdhbHBoYScsIHR5cGU6ICdmMzInfSwge25hbWU6ICdiZXRhJywgdHlwZTogJ2YzMid9XG4gICAgXTtcbiAgICByZXR1cm4gYFxuICAke3NoYWRlckhlbHBlci5yZWdpc3RlclVuaWZvcm1zKHVuaWZvcm1zKS5kZWNsYXJlVmFyaWFibGVzKC4uLnZhcmlhYmxlcyl9XG5cbiAgJHtzaGFkZXJIZWxwZXIubWFpblN0YXJ0KCl9XG4gICAgJHtzaGFkZXJIZWxwZXIuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcygndW5pZm9ybXMub3V0cHV0X3NpemUnKX1cblxuICAgIGxldCBtID0gZ2xvYmFsX2lkeCAvIHVuaWZvcm1zLk47XG4gICAgbGV0IG4gPSBnbG9iYWxfaWR4ICUgdW5pZm9ybXMuTjtcblxuICAgIHZhciB2YWx1ZSA9ICR7ZGF0YVR5cGV9KDApO1xuICAgIGZvciAodmFyIGs6IHUzMiA9IDB1OyBrIDwgdW5pZm9ybXMuSzsgaysrKSB7XG4gICAgICAke2xpbmV9XG4gICAgfVxuXG4gICAgJHtjYWxjdWxhdGVBbHBoYX1cbiAgICAkeygoKSA9PiB7XG4gICAgICBpZiAoYyAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBgbGV0IGNPZmZzZXQgPSAke2MuYnJvYWRjYXN0ZWRJbmRpY2VzVG9PZmZzZXQoJ3ZlYzIobSwgbiknLCBvdXRwdXQpfTsgdmFsdWUgKz0gJHtcbiAgICAgICAgICAgIGRhdGFUeXBlfSh1bmlmb3Jtcy5iZXRhKSAqICR7Yy5nZXRCeU9mZnNldCgnY09mZnNldCcpfTtgO1xuICAgICAgfVxuICAgICAgcmV0dXJuICcnO1xuICAgIH0pKCl9XG4gICAgb3V0cHV0W2dsb2JhbF9pZHhdID0gdmFsdWU7XG4gIH1gO1xuICB9O1xuXG4gIHJldHVybiB7XG4gICAgbmFtZTogJ0dlbW0nLFxuICAgIHNoYWRlckNhY2hlOiB7aGludDogYCR7YXR0cmlidXRlcy5jYWNoZUtleX1gLCBpbnB1dERlcGVuZGVuY2llc30sXG4gICAgZ2V0UnVuRGF0YTogKCkgPT4gKHtcbiAgICAgIG91dHB1dHM6IFt7ZGltczogb3V0cHV0U2hhcGUsIGRhdGFUeXBlOiBpbnB1dHNbMF0uZGF0YVR5cGV9XSxcbiAgICAgIGRpc3BhdGNoR3JvdXA6IHt4OiBNYXRoLmNlaWwob3V0cHV0U2l6ZSAvIDY0IC8qIHdvcmtncm91cCBzaXplICovKX0sXG4gICAgICBwcm9ncmFtVW5pZm9ybXNcbiAgICB9KSxcbiAgICBnZXRTaGFkZXJTb3VyY2UsXG4gIH07XG59O1xuXG5leHBvcnQgY29uc3QgcGFyc2VHZW1tQXR0cmlidXRlcyA9IChhdHRyaWJ1dGVzOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPik6IEdlbW1BdHRyaWJ1dGVzID0+IHtcbiAgY29uc3QgdHJhbnNBID0gYXR0cmlidXRlcy50cmFuc0EgYXMgYm9vbGVhbjtcbiAgY29uc3QgdHJhbnNCID0gYXR0cmlidXRlcy50cmFuc0IgYXMgYm9vbGVhbjtcbiAgY29uc3QgYWxwaGEgPSBhdHRyaWJ1dGVzLmFscGhhIGFzIG51bWJlcjtcbiAgY29uc3QgYmV0YSA9IGF0dHJpYnV0ZXMuYmV0YSBhcyBudW1iZXI7XG4gIHJldHVybiB7dHJhbnNBLCB0cmFuc0IsIGFscGhhLCBiZXRhLCBjYWNoZUtleTogYCR7YXR0cmlidXRlcy50cmFuc0F9OyR7YXR0cmlidXRlcy50cmFuc0J9OyR7YXR0cmlidXRlcy5hbHBoYSA9PT0gMX1gfTtcbn07XG5cbmV4cG9ydCBjb25zdCBnZW1tID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBHZW1tQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICB2YWxpZGF0ZUlucHV0cyhjb250ZXh0LmlucHV0cyk7XG4gIGNvbnRleHQuY29tcHV0ZShjcmVhdGVHZW1tUHJvZ3JhbUluZm8oY29udGV4dC5pbnB1dHMsIGF0dHJpYnV0ZXMpKTtcbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7RGF0YVR5cGV9IGZyb20gJy4uLy4uLy4uL3dhc20tY29tbW9uJztcbmltcG9ydCB7VGVuc29yVmlld30gZnJvbSAnLi4vLi4vdGVuc29yLXZpZXcnO1xuaW1wb3J0IHtTaGFwZVV0aWx9IGZyb20gJy4uLy4uL3V0aWwnO1xuaW1wb3J0IHtDb21wdXRlQ29udGV4dCwgUHJvZ3JhbUluZm8sIFByb2dyYW1JbnB1dFRlbnNvckluZm9EZXBlbmRlbmN5LCBQcm9ncmFtVW5pZm9ybX0gZnJvbSAnLi4vdHlwZXMnO1xuXG5pbXBvcnQge2NyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzLCBmaWxsVmVjdG9yLCBnZXRNYXhDb21wb25lbnRzLCBpbnB1dFZhcmlhYmxlLCBvdXRwdXRWYXJpYWJsZSwgU2hhZGVySGVscGVyLCBzdW1WZWN0b3IsIHRlbnNvclR5cGVUb1dzZ2xTdG9yYWdlVHlwZSwgVW5pZm9ybXNBcnJheVR5cGV9IGZyb20gJy4vY29tbW9uJztcblxuZXhwb3J0IGludGVyZmFjZSBJbnN0YW5jZU5vcm1BdHRyaWJ1dGVzIHtcbiAgZXBzaWxvbjogbnVtYmVyO1xuICBmb3JtYXQ6ICdOSFdDJ3wnTkNIVyc7XG59XG5cbmNvbnN0IGNyZWF0ZUluc3RhbmNlTm9ybVByb2dyYW1JbmZvID1cbiAgICAoaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10sIGF0dHJpYnV0ZXM6IEluc3RhbmNlTm9ybUF0dHJpYnV0ZXMpOiBQcm9ncmFtSW5mbyA9PiB7XG4gICAgICBjb25zdCB4U2hhcGUgPSBpbnB1dHNbMF0uZGltcztcbiAgICAgIGNvbnN0IG91dHB1dFNoYXBlID0geFNoYXBlO1xuICAgICAgY29uc3QgYXhpcyA9IDI7XG4gICAgICBjb25zdCBub3JtQ291bnQgPSBTaGFwZVV0aWwuc2l6ZVRvRGltZW5zaW9uKHhTaGFwZSwgYXhpcyk7XG4gICAgICBjb25zdCBub3JtU2l6ZSA9IFNoYXBlVXRpbC5zaXplRnJvbURpbWVuc2lvbih4U2hhcGUsIGF4aXMpO1xuICAgICAgY29uc3QgY29tcG9uZW50cyA9IGdldE1heENvbXBvbmVudHMobm9ybVNpemUpO1xuICAgICAgY29uc3Qgbm9ybVBhY2tlZFNpemUgPSBub3JtU2l6ZSAvIGNvbXBvbmVudHM7XG4gICAgICBjb25zdCBpbnB1dFNoYXBlID0gW3hTaGFwZVswXSwgeFNoYXBlWzFdLCBub3JtUGFja2VkU2l6ZV07XG4gICAgICBjb25zdCBpbnB1dERlcGVuZGVuY2llczogUHJvZ3JhbUlucHV0VGVuc29ySW5mb0RlcGVuZGVuY3lbXSA9IFsncmFuaycsICd0eXBlJywgJ3R5cGUnXTtcbiAgICAgIGNvbnN0IHByb2dyYW1Vbmlmb3JtczogUHJvZ3JhbVVuaWZvcm1bXSA9XG4gICAgICAgICAgW3t0eXBlOiAndWludDMyJywgZGF0YTogbm9ybVNpemV9LCB7dHlwZTogJ3VpbnQzMicsIGRhdGE6IG5vcm1QYWNrZWRTaXplfV07XG4gICAgICBwcm9ncmFtVW5pZm9ybXMucHVzaCguLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhpbnB1dFNoYXBlKSwgLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMoaW5wdXRTaGFwZSkpO1xuXG4gICAgICBjb25zdCBnZXRTaGFkZXJTb3VyY2UgPSAoc2hhZGVySGVscGVyOiBTaGFkZXJIZWxwZXIpID0+IHtcbiAgICAgICAgY29uc3QgeCA9IGlucHV0VmFyaWFibGUoJ3gnLCBpbnB1dHNbMF0uZGF0YVR5cGUsIGlucHV0U2hhcGUubGVuZ3RoLCBjb21wb25lbnRzKTtcbiAgICAgICAgY29uc3Qgc2NhbGUgPSBpbnB1dFZhcmlhYmxlKCdzY2FsZScsIGlucHV0c1sxXS5kYXRhVHlwZSwgaW5wdXRzWzFdLmRpbXMpO1xuICAgICAgICBjb25zdCBiaWFzID0gaW5wdXRWYXJpYWJsZSgnYmlhcycsIGlucHV0c1syXS5kYXRhVHlwZSwgaW5wdXRzWzJdLmRpbXMpO1xuICAgICAgICBjb25zdCBvdXRwdXQgPSBvdXRwdXRWYXJpYWJsZSgnb3V0cHV0JywgaW5wdXRzWzBdLmRhdGFUeXBlLCBpbnB1dFNoYXBlLmxlbmd0aCwgY29tcG9uZW50cyk7XG4gICAgICAgIGNvbnN0IHZhcmlhYmxlcyA9IFt4LCBzY2FsZSwgYmlhcywgb3V0cHV0XTtcbiAgICAgICAgY29uc3QgZGF0YVR5cGUgPSB4LnR5cGUudmFsdWU7XG4gICAgICAgIGNvbnN0IGYzMlR5cGUgPSBjb21wb25lbnRzID09PSAxID8gJ2YzMicgOiBgdmVjJHtjb21wb25lbnRzfTxmMzI+YDtcbiAgICAgICAgY29uc3Qgd29ya2dyb3VwU2l6ZSA9IDY0O1xuXG4gICAgICAgIGNvbnN0IHVuaWZvcm1zOiBVbmlmb3Jtc0FycmF5VHlwZSA9IFt7bmFtZTogJ25vcm1TaXplJywgdHlwZTogJ3UzMid9LCB7bmFtZTogJ25vcm1QYWNrZWRTaXplJywgdHlwZTogJ3UzMid9XTtcbiAgICAgICAgcmV0dXJuIGBcbiAgdmFyPHdvcmtncm91cD4gbWVhblNoYXJlZCA6IGYzMjtcbiAgdmFyPHdvcmtncm91cD4gc3F1YXJlZE5vcm1TaGFyZWQgOiBmMzI7XG4gIHZhcjx3b3JrZ3JvdXA+IHdvcmtncm91cFNoYXJlZCA6IGFycmF5PCR7ZjMyVHlwZX0sICR7d29ya2dyb3VwU2l6ZX0+O1xuICBjb25zdCB3b3JrZ3JvdXBTaXplID0gJHt3b3JrZ3JvdXBTaXplfXU7XG4gICR7c2hhZGVySGVscGVyLnJlZ2lzdGVyVW5pZm9ybXModW5pZm9ybXMpLmRlY2xhcmVWYXJpYWJsZXMoLi4udmFyaWFibGVzKX1cbiAgJHtzaGFkZXJIZWxwZXIubWFpblN0YXJ0KHdvcmtncm91cFNpemUpfVxuICAgIGxldCBub3JtID0gZ2xvYmFsX2lkeCAvIHdvcmtncm91cFNpemU7XG4gICAgbGV0IGJhdGNoID0gbm9ybSAvIHVuaWZvcm1zLnhfc2hhcGVbMV07XG4gICAgbGV0IGNoYW5uZWwgPSBub3JtICUgdW5pZm9ybXMueF9zaGFwZVsxXTtcbiAgICBsZXQgbG9jYWxJbmRleCA9IGxvY2FsX2lkLng7XG5cbiAgICAvLyBpbml0aWFsaXplIHdvcmtncm91cCBtZW1vcnlcbiAgICB2YXIgaW5pdGlhbCA9ICR7ZjMyVHlwZX0oMCk7XG4gICAgZm9yICh2YXIgaCA9IGxvY2FsSW5kZXg7IGggPCB1bmlmb3Jtcy5ub3JtUGFja2VkU2l6ZTsgaCArPSB3b3JrZ3JvdXBTaXplKSB7XG4gICAgICBpbml0aWFsID0gaW5pdGlhbCArICR7ZjMyVHlwZX0oJHt4LmdldCgnYmF0Y2gnLCAnY2hhbm5lbCcsICdoJyl9KTtcbiAgICB9XG4gICAgd29ya2dyb3VwU2hhcmVkW2xvY2FsSW5kZXhdID0gaW5pdGlhbDtcbiAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG5cbiAgICAvLyBDYWxjdWxhdGUgdGhlIG1lYW4gb2YgY3VycmVudCBjaGFubmVsIGRhdGEuXG4gICAgZm9yICh2YXIgY3VyclNpemUgPSB3b3JrZ3JvdXBTaXplID4+IDE7ICBjdXJyU2l6ZSA+IDA7IGN1cnJTaXplID0gY3VyclNpemUgPj4gMSkge1xuICAgICAgaWYgKGxvY2FsSW5kZXggPCBjdXJyU2l6ZSkge1xuICAgICAgICB3b3JrZ3JvdXBTaGFyZWRbbG9jYWxJbmRleF0gPSB3b3JrZ3JvdXBTaGFyZWRbbG9jYWxJbmRleF0gKyB3b3JrZ3JvdXBTaGFyZWRbbG9jYWxJbmRleCArIGN1cnJTaXplXTtcbiAgICAgIH1cbiAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcbiAgICB9XG4gICAgaWYgKGxvY2FsSW5kZXggPT0gMCkge1xuICAgICAgbWVhblNoYXJlZCA9ICR7c3VtVmVjdG9yKCd3b3JrZ3JvdXBTaGFyZWRbMF0nLCBjb21wb25lbnRzKX0gLyBmMzIodW5pZm9ybXMubm9ybVNpemUpO1xuICAgIH1cbiAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG5cbiAgICAvLyByZWluaXRpYWxpemUgd29ya2dyb3VwIG1lbW9yeS5cbiAgICBpbml0aWFsID0gJHtmMzJUeXBlfSgwKTtcbiAgICBmb3IgKHZhciBoID0gbG9jYWxJbmRleDsgaCA8IHVuaWZvcm1zLm5vcm1QYWNrZWRTaXplOyBoICs9IHdvcmtncm91cFNpemUpIHtcbiAgICAgIGxldCBkZXZpYXRpb24gPSAgJHtmMzJUeXBlfSgke3guZ2V0KCdiYXRjaCcsICdjaGFubmVsJywgJ2gnKX0pIC0gJHtmMzJUeXBlfShtZWFuU2hhcmVkKTtcbiAgICAgIGluaXRpYWwgPSBpbml0aWFsICsgZGV2aWF0aW9uICogZGV2aWF0aW9uO1xuICAgIH1cbiAgICB3b3JrZ3JvdXBTaGFyZWRbbG9jYWxJbmRleF0gPSBpbml0aWFsO1xuICAgIHdvcmtncm91cEJhcnJpZXIoKTtcblxuICAgIC8vIENhbGN1bGF0ZSB0aGUgc3VtIG9mIHNxdWFyZSBvZiBkZXZpYXRpb24gb2YgY3VycmVudCBjaGFubmVsIGRhdGEuXG4gICAgZm9yICh2YXIgY3VyclNpemUgPSB3b3JrZ3JvdXBTaXplID4+IDE7ICBjdXJyU2l6ZSA+IDA7IGN1cnJTaXplID0gY3VyclNpemUgPj4gMSkge1xuICAgICAgaWYgKGxvY2FsSW5kZXggPCBjdXJyU2l6ZSkge1xuICAgICAgICB3b3JrZ3JvdXBTaGFyZWRbbG9jYWxJbmRleF0gPSB3b3JrZ3JvdXBTaGFyZWRbbG9jYWxJbmRleF0gKyB3b3JrZ3JvdXBTaGFyZWRbbG9jYWxJbmRleCArIGN1cnJTaXplXTtcbiAgICAgIH1cbiAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcbiAgICB9XG4gICAgaWYgKGxvY2FsSW5kZXggPT0gMCkge1xuICAgICAgc3F1YXJlZE5vcm1TaGFyZWQgPSAke3N1bVZlY3Rvcignd29ya2dyb3VwU2hhcmVkWzBdJywgY29tcG9uZW50cyl9O1xuICAgIH1cbiAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG5cbiAgICBsZXQgaW52U3RkRGV2ID0gaW52ZXJzZVNxcnQoc3F1YXJlZE5vcm1TaGFyZWQgLyBmMzIodW5pZm9ybXMubm9ybVNpemUpICsgZjMyKCR7YXR0cmlidXRlcy5lcHNpbG9ufSkpO1xuICAgIGxldCBjaGFubmVsU2NhbGUgPSBpbnZTdGREZXYgKiBmMzIoJHtzY2FsZS5nZXRCeU9mZnNldCgnY2hhbm5lbCcpfSk7XG4gICAgbGV0IGNoYW5uZWxTaGlmdCA9IGYzMigke2JpYXMuZ2V0QnlPZmZzZXQoJ2NoYW5uZWwnKX0pIC0gbWVhblNoYXJlZCAqIGNoYW5uZWxTY2FsZTtcbiAgICBmb3IgKHZhciBoID0gbG9jYWxJbmRleDsgaCA8IHVuaWZvcm1zLm5vcm1QYWNrZWRTaXplOyBoICs9IHdvcmtncm91cFNpemUpIHtcbiAgICAgIGxldCB2YWx1ZSA9ICR7eC5nZXQoJ2JhdGNoJywgJ2NoYW5uZWwnLCAnaCcpfSAqICR7ZGF0YVR5cGV9KCR7ZjMyVHlwZX0oY2hhbm5lbFNjYWxlKSkgKyAke2RhdGFUeXBlfSgke1xuICAgICAgICAgICAgZjMyVHlwZX0oY2hhbm5lbFNoaWZ0KSk7XG4gICAgICAke291dHB1dC5zZXQoJ2JhdGNoJywgJ2NoYW5uZWwnLCAnaCcsICd2YWx1ZScpfTtcbiAgICB9XG4gIH1gO1xuICAgICAgfTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLntuYW1lOiAnSW5zdGFuY2VOb3JtYWxpemF0aW9uJ30sXG4gICAgICAgIC8vIFRPRE86IHVzZSBlcHNpbG9uIGFzIHVuaWZvcm0uIEN1cnJlbnRseSBlcHNpbG9uIGFzIHVuaWZvcm0gZmFpbHMgdGVzdF9pbnN0YW5jZW5vcm1fZXBzaWxvbi5cbiAgICAgICAgc2hhZGVyQ2FjaGU6IHtoaW50OiBgJHthdHRyaWJ1dGVzLmVwc2lsb259OyR7Y29tcG9uZW50c31gLCBpbnB1dERlcGVuZGVuY2llc30sXG4gICAgICAgIGdldFJ1bkRhdGE6ICgpID0+ICh7XG4gICAgICAgICAgb3V0cHV0czogW1xuICAgICAgICAgICAge2RpbXM6IG91dHB1dFNoYXBlLCBkYXRhVHlwZTogaW5wdXRzWzBdLmRhdGFUeXBlfSxcbiAgICAgICAgICBdLFxuICAgICAgICAgIGRpc3BhdGNoR3JvdXA6IHt4OiBub3JtQ291bnR9LFxuICAgICAgICAgIHByb2dyYW1Vbmlmb3Jtc1xuICAgICAgICB9KSxcbiAgICAgICAgZ2V0U2hhZGVyU291cmNlLFxuICAgICAgfTtcbiAgICB9O1xuXG5jb25zdCBjb21wdXRlTWVhbiA9XG4gICAgKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBpbnB1dDogVGVuc29yVmlldywgc2NhbGU6IFRlbnNvclZpZXcsIGJpYXM6IFRlbnNvclZpZXcsIG46IG51bWJlciwgaDogbnVtYmVyLCBjOiBudW1iZXIsXG4gICAgIGVwc2lsb246IG51bWJlcikgPT4ge1xuICAgICAgY29uc3QgY29tcG9uZW50cyA9IGdldE1heENvbXBvbmVudHMoYyk7XG4gICAgICBjb25zdCBXRyA9IDY0O1xuICAgICAgLy8gd2Ugd2lsbCBzdG9yZSBjaGFubmVsIHNjYWxlIGFuZCBjaGFubmVsIHNoaWZ0IGluIFsyLCBjb21wb25lbnRzXSBtYXRyaXhcbiAgICAgIC8vIG9yIGluIHZlYzIgd2hlbiBjb21wb25lbnRzID09IDFcbiAgICAgIGNvbnN0IG91dHB1dFR5cGUgPSBjb21wb25lbnRzID09PSAxID8gJ3ZlYzJmJyA6IGBtYXQyeCR7Y29tcG9uZW50c31mYDtcbiAgICAgIGNvbnN0IHN1bUNhc3RUeXBlID0gY29tcG9uZW50cyA9PT0gMSA/ICdmMzInIDogYHZlYyR7Y29tcG9uZW50c31mYDtcbiAgICAgIGNvbnN0IHNldE91dHB1dFZhbHVlID0gKHZhcjE6IHN0cmluZywgdmFyMjogc3RyaW5nKSA9PiBgJHtvdXRwdXRUeXBlfSgke3ZhcjF9LCAke3ZhcjJ9KWA7XG4gICAgICBjb25zdCB1bml0c09mV29yayA9IG4gKiBjIC8gY29tcG9uZW50cztcbiAgICAgIGNvbnN0IHdnU2l6ZSA9IE1hdGguY2VpbChoIC8gV0cpO1xuXG4gICAgICBjb25zdCBtZWFuSW5wdXREZXBlbmRlbmNpZXM6IFByb2dyYW1JbnB1dFRlbnNvckluZm9EZXBlbmRlbmN5W10gPSBbJ3R5cGUnXTtcbiAgICAgIGNvbnN0IG1lYW5Qcm9ncmFtVW5pZm9ybXM6IFByb2dyYW1Vbmlmb3JtW10gPSBbXG4gICAgICAgIHt0eXBlOiAndWludDMyJywgZGF0YTogd2dTaXplfSwge3R5cGU6ICd1aW50MzInLCBkYXRhOiBofSwge3R5cGU6ICd1aW50MzInLCBkYXRhOiBNYXRoLmZsb29yKGMgLyBjb21wb25lbnRzKX0sXG4gICAgICAgIHt0eXBlOiAndWludDMyJywgZGF0YTogTWF0aC5mbG9vcihoICogYyAvIGNvbXBvbmVudHMpfVxuICAgICAgXTtcblxuICAgICAgY29uc3QgZ2V0TWVhblNoYWRlclNvdXJjZSA9IChzaGFkZXJIZWxwZXI6IFNoYWRlckhlbHBlcikgPT4ge1xuICAgICAgICBjb25zdCBpbnB1dEhlbHBlciA9IGlucHV0VmFyaWFibGUoJ2lucHV0JywgaW5wdXQuZGF0YVR5cGUsIGlucHV0LmRpbXMsIGNvbXBvbmVudHMpO1xuICAgICAgICByZXR1cm4gYFxuICAke3NoYWRlckhlbHBlci5kZWNsYXJlVmFyaWFibGVzKGlucHV0SGVscGVyKX1cbiAgQGdyb3VwKDApIEBiaW5kaW5nKDEpIHZhcjxzdG9yYWdlLCByZWFkX3dyaXRlPiBvdXRwdXQgOiBhcnJheTwke291dHB1dFR5cGV9PjtcbiAgc3RydWN0IFVuaWZvcm1zIHt3Z19zaXplOnUzMiwgSDp1MzIsIEM6dTMyLCBpbWFnZV9zaXplOnUzMn07XG4gIEBncm91cCgwKSBAYmluZGluZygyKSB2YXI8dW5pZm9ybT4gdW5pZm9ybXM6IFVuaWZvcm1zO1xuXG4gICR7c2hhZGVySGVscGVyLm1haW5TdGFydChXRyl9XG4gICAgbGV0IGN1cnJlbnRJbWFnZU51bWJlciA9IGdsb2JhbF9pZHggLyAke1dHfSAvIHVuaWZvcm1zLkM7XG4gICAgbGV0IGN1cnJlbnRDaGFubmVsTnVtYmVyID0gKGdsb2JhbF9pZHggLyAke1dHfSkgJSB1bmlmb3Jtcy5DO1xuICAgIGxldCB3Z0lkID0gZ2xvYmFsX2lkeCAlICR7V0d9O1xuICAgIGxldCB3Z09mZnNldCA9IHdnSWQgKiB1bmlmb3Jtcy53Z19zaXplO1xuICAgIGlmICh3Z09mZnNldCA+PSB1bmlmb3Jtcy5IKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IHdnTWF4ID0gbWluKHdnT2Zmc2V0ICsgdW5pZm9ybXMud2dfc2l6ZSwgdW5pZm9ybXMuSCk7XG5cbiAgICBsZXQgb2Zmc2V0ID0gY3VycmVudEltYWdlTnVtYmVyICogdW5pZm9ybXMuaW1hZ2Vfc2l6ZSArIGN1cnJlbnRDaGFubmVsTnVtYmVyO1xuICAgIHZhciBzdW0gPSAke2ZpbGxWZWN0b3IoJ2YzMicsIGNvbXBvbmVudHMpfTtcbiAgICB2YXIgc3F1YXJlZFN1bSA9ICR7ZmlsbFZlY3RvcignZjMyJywgY29tcG9uZW50cyl9O1xuICAgIGZvciAodmFyIGk6IHUzMiA9IHdnT2Zmc2V0OyBpIDwgd2dNYXg7IGkrKykge1xuICAgICAgICBsZXQgdmFsdWUgPSAke3N1bUNhc3RUeXBlfShpbnB1dFtvZmZzZXQgKyBpICogdW5pZm9ybXMuQ10pO1xuICAgICAgICBzdW0gKz0gdmFsdWU7XG4gICAgICAgIHNxdWFyZWRTdW0gKz0gdmFsdWUgKiB2YWx1ZTtcbiAgICB9XG4gICAgb3V0cHV0W2dsb2JhbF9pZHhdID0gJHtzZXRPdXRwdXRWYWx1ZSgnc3VtJywgJ3NxdWFyZWRTdW0nKX07XG4gIH1gO1xuICAgICAgfTtcblxuICAgICAgY29uc3QgbWVhblZhbHVlcyA9IGNvbnRleHQuY29tcHV0ZShcbiAgICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5zdGFuY2VOb3JtQ29tcHV0ZU1lYW4nLFxuICAgICAgICAgICAgc2hhZGVyQ2FjaGU6IHtoaW50OiBgJHtjb21wb25lbnRzfWAsIGlucHV0RGVwZW5kZW5jaWVzOiBtZWFuSW5wdXREZXBlbmRlbmNpZXN9LFxuICAgICAgICAgICAgZ2V0UnVuRGF0YTogKCkgPT4gKHtcbiAgICAgICAgICAgICAgb3V0cHV0czogW1xuICAgICAgICAgICAgICAgIHtkaW1zOiBbbiwgYywgV0csIDJdLCBkYXRhVHlwZTogRGF0YVR5cGUuZmxvYXR9LFxuICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICBkaXNwYXRjaEdyb3VwOiB7eDogbiAqIGMgLyBjb21wb25lbnRzfSxcbiAgICAgICAgICAgICAgcHJvZ3JhbVVuaWZvcm1zOiBtZWFuUHJvZ3JhbVVuaWZvcm1zXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGdldFNoYWRlclNvdXJjZTogZ2V0TWVhblNoYWRlclNvdXJjZSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIHtpbnB1dHM6IFtpbnB1dF0sIG91dHB1dHM6IFstMV19KVswXTtcblxuICAgICAgY29uc3QgcHJvZ3JhbVVuaWZvcm1zOiBQcm9ncmFtVW5pZm9ybVtdID0gW1xuICAgICAgICB7dHlwZTogJ3VpbnQzMicsIGRhdGE6IHVuaXRzT2ZXb3JrfSwge3R5cGU6ICd1aW50MzInLCBkYXRhOiBofSxcbiAgICAgICAge3R5cGU6ICd1aW50MzInLCBkYXRhOiBNYXRoLmZsb29yKGMgLyBjb21wb25lbnRzKX0sIHt0eXBlOiAndWludDMyJywgZGF0YTogTWF0aC5mbG9vcihXRyAqIGMgLyBjb21wb25lbnRzKX1cbiAgICAgIF07XG4gICAgICBjb25zdCBpbnB1dERlcGVuZGVuY2llczogUHJvZ3JhbUlucHV0VGVuc29ySW5mb0RlcGVuZGVuY3lbXSA9IFsndHlwZScsICd0eXBlJywgJ3R5cGUnXTtcbiAgICAgIGNvbnN0IGdldFNoYWRlclNvdXJjZSA9IChzaGFkZXJIZWxwZXI6IFNoYWRlckhlbHBlcikgPT4ge1xuICAgICAgICBjb25zdCBzY2FsZUhlbHBlciA9IGlucHV0VmFyaWFibGUoJ3NjYWxlJywgc2NhbGUuZGF0YVR5cGUsIHNjYWxlLmRpbXMsIGNvbXBvbmVudHMpO1xuICAgICAgICBjb25zdCBiaWFzSGVscGVyID0gaW5wdXRWYXJpYWJsZSgnYmlhcycsIGJpYXMuZGF0YVR5cGUsIGJpYXMuZGltcywgY29tcG9uZW50cyk7XG4gICAgICAgIHJldHVybiBgXG4gIEBncm91cCgwKSBAYmluZGluZygwKSB2YXI8c3RvcmFnZSwgcmVhZD4gaW5wdXQgOiBhcnJheTwke291dHB1dFR5cGV9PjtcbiAgQGdyb3VwKDApIEBiaW5kaW5nKDEpIHZhcjxzdG9yYWdlLCByZWFkPiBzY2FsZSA6IGFycmF5PCR7c2NhbGVIZWxwZXIudHlwZS5zdG9yYWdlfT47XG4gIEBncm91cCgwKSBAYmluZGluZygyKSB2YXI8c3RvcmFnZSwgcmVhZD4gYmlhcyA6IGFycmF5PCR7Ymlhc0hlbHBlci50eXBlLnN0b3JhZ2V9PjtcbiAgQGdyb3VwKDApIEBiaW5kaW5nKDMpIHZhcjxzdG9yYWdlLCByZWFkX3dyaXRlPiBvdXRwdXQgOiBhcnJheTwke291dHB1dFR5cGV9PjtcbiAgc3RydWN0IFVuaWZvcm1zIHt1bml0c19vZl93b3JrIDogdTMyLCBIOiB1MzIsIEMgOiB1MzIsIGltYWdlX3NpemUgOiB1MzJ9O1xuICBAZ3JvdXAoMCkgQGJpbmRpbmcoNCkgdmFyPHVuaWZvcm0+IHVuaWZvcm1zOiBVbmlmb3JtcztcblxuICAke3NoYWRlckhlbHBlci5tYWluU3RhcnQoKX1cbiAgICAke3NoYWRlckhlbHBlci5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKCd1bmlmb3Jtcy51bml0c19vZl93b3JrJyl9XG4gICAgbGV0IGN1cnJlbnRJbWFnZU51bWJlciA9IGdsb2JhbF9pZHggLyB1bmlmb3Jtcy5DO1xuICAgIGxldCBjdXJyZW50Q2hhbm5lbE51bWJlciA9IGdsb2JhbF9pZHggJSB1bmlmb3Jtcy5DO1xuXG4gICAgbGV0IG9mZnNldCA9IGN1cnJlbnRJbWFnZU51bWJlciAqIHVuaWZvcm1zLmltYWdlX3NpemU7XG4gICAgdmFyIHN1bSA9ICR7ZmlsbFZlY3RvcignZjMyJywgY29tcG9uZW50cyl9O1xuICAgIHZhciBzcXVhcmVkU3VtID0gJHtmaWxsVmVjdG9yKCdmMzInLCBjb21wb25lbnRzKX07XG4gICAgZm9yICh2YXIgaTogdTMyID0gMDsgaSA8ICR7V0d9OyBpKyspIHtcbiAgICAgICAgbGV0IHZhbHVlID0gaW5wdXRbb2Zmc2V0ICsgaSArIGN1cnJlbnRDaGFubmVsTnVtYmVyICogJHtXR31dO1xuICAgICAgICBzdW0gKz0gdmFsdWVbMF07XG4gICAgICAgIHNxdWFyZWRTdW0gKz0gdmFsdWVbMV07XG4gICAgfVxuICAgIHN1bSA9IHN1bSAvIGYzMih1bmlmb3Jtcy5IKTtcbiAgICBzcXVhcmVkU3VtID0gc3F1YXJlZFN1bSAvIGYzMih1bmlmb3Jtcy5IKTtcbiAgICBsZXQgaW52U3RkRGV2ID0gaW52ZXJzZVNxcnQoc3F1YXJlZFN1bSAtIHN1bSAqIHN1bSArIGYzMigke2Vwc2lsb259KSk7XG4gICAgbGV0IGNoYW5uZWxTY2FsZSA9IGludlN0ZERldiAqICR7c3VtQ2FzdFR5cGV9KHNjYWxlW2N1cnJlbnRDaGFubmVsTnVtYmVyXSk7XG4gICAgbGV0IGNoYW5uZWxTaGlmdCA9ICR7c3VtQ2FzdFR5cGV9KGJpYXNbY3VycmVudENoYW5uZWxOdW1iZXJdKSAtIHN1bSAqIGNoYW5uZWxTY2FsZTtcblxuICAgIG91dHB1dFtnbG9iYWxfaWR4XSA9ICR7c2V0T3V0cHV0VmFsdWUoJ2NoYW5uZWxTY2FsZScsICdjaGFubmVsU2hpZnQnKX07XG4gIH1gO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBjb250ZXh0LmNvbXB1dGUoXG4gICAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0luc3RhbmNlTm9ybUNvbXB1dGVDaGFubmVsU2NhbGVTaGlmdCcsXG4gICAgICAgICAgICAvLyBUT0RPOiB1c2UgZXBzaWxvbiBhcyB1bmlmb3JtLiBDdXJyZW50bHkgZXBzaWxvbiBhcyB1bmlmb3JtIGZhaWxzIHRlc3RfaW5zdGFuY2Vub3JtX2Vwc2lsb24uXG4gICAgICAgICAgICBzaGFkZXJDYWNoZToge2hpbnQ6IGAke2NvbXBvbmVudHN9OyR7ZXBzaWxvbn1gLCBpbnB1dERlcGVuZGVuY2llc30sXG4gICAgICAgICAgICBnZXRSdW5EYXRhOiAoKSA9PiAoe1xuICAgICAgICAgICAgICBvdXRwdXRzOiBbXG4gICAgICAgICAgICAgICAge2RpbXM6IFtuLCBjLCAyXSwgZGF0YVR5cGU6IERhdGFUeXBlLmZsb2F0fSxcbiAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgZGlzcGF0Y2hHcm91cDoge3g6IE1hdGguY2VpbCh1bml0c09mV29yayAvIDY0IC8qIHdvcmtncm91cCBzaXplICovKX0sXG4gICAgICAgICAgICAgIHByb2dyYW1Vbmlmb3Jtc1xuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBnZXRTaGFkZXJTb3VyY2UsXG4gICAgICAgICAgfSxcbiAgICAgICAgICB7aW5wdXRzOiBbbWVhblZhbHVlcywgc2NhbGUsIGJpYXNdLCBvdXRwdXRzOiBbLTFdfSlbMF07XG4gICAgfTtcblxuY29uc3QgY3JlYXRlSW5zdGFuY2VOb3JtTkhXQ1Byb2dyYW1JbmZvID1cbiAgICAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdLCBhdHRyaWJ1dGVzOiBJbnN0YW5jZU5vcm1BdHRyaWJ1dGVzKSA9PiB7XG4gICAgICBjb25zdCB4U2hhcGUgPSBpbnB1dHNbMF0uZGltcztcbiAgICAgIGNvbnN0IG91dHB1dFNoYXBlID0geFNoYXBlO1xuICAgICAgY29uc3QgTiA9IHhTaGFwZVswXTtcbiAgICAgIGNvbnN0IEMgPSB4U2hhcGVbeFNoYXBlLmxlbmd0aCAtIDFdO1xuICAgICAgY29uc3QgSCA9IFNoYXBlVXRpbC5zaXplRnJvbURpbWVuc2lvbih4U2hhcGUsIDEpIC8gQztcbiAgICAgIGNvbnN0IGNvbXBvbmVudHMgPSBnZXRNYXhDb21wb25lbnRzKEMpO1xuICAgICAgY29uc3Qgb3V0cHV0U2l6ZSA9IFNoYXBlVXRpbC5zaXplKG91dHB1dFNoYXBlKSAvIGNvbXBvbmVudHM7XG4gICAgICBjb25zdCBwcm9ncmFtVW5pZm9ybXM6IFByb2dyYW1Vbmlmb3JtW10gPVxuICAgICAgICAgIFt7dHlwZTogJ3VpbnQzMicsIGRhdGE6IEh9LCB7dHlwZTogJ3VpbnQzMicsIGRhdGE6IE1hdGguZmxvb3IoQyAvIGNvbXBvbmVudHMpfV07XG4gICAgICBjb25zdCBpbnB1dERlcGVuZGVuY2llczogUHJvZ3JhbUlucHV0VGVuc29ySW5mb0RlcGVuZGVuY3lbXSA9IFsndHlwZScsICd0eXBlJ107XG4gICAgICAvLyBmaXJzdCBjb21wdXRlIG1lYW5cbiAgICAgIGNvbnN0IGNoYW5uZWxTY2FsZVNoaWZ0ID0gY29tcHV0ZU1lYW4oY29udGV4dCwgaW5wdXRzWzBdLCBpbnB1dHNbMV0sIGlucHV0c1syXSwgTiwgSCwgQywgYXR0cmlidXRlcy5lcHNpbG9uKTtcbiAgICAgIGNvbnN0IGdldFNoYWRlclNvdXJjZSA9IChzaGFkZXJIZWxwZXI6IFNoYWRlckhlbHBlcikgPT4ge1xuICAgICAgICBjb25zdCBkYXRhVHlwZSA9IHRlbnNvclR5cGVUb1dzZ2xTdG9yYWdlVHlwZShpbnB1dHNbMF0uZGF0YVR5cGUpO1xuICAgICAgICBjb25zdCBzY2FsZVR5cGUgPSBjb21wb25lbnRzID09PSAxID8gJ3ZlYzJmJyA6IGBtYXQyeCR7Y29tcG9uZW50c31mYDtcbiAgICAgICAgY29uc3Qgc2NhbGVDYXN0VHlwZSA9IGNvbXBvbmVudHMgPT09IDEgPyBkYXRhVHlwZSA6IGB2ZWMke2NvbXBvbmVudHN9PCR7ZGF0YVR5cGV9PmA7XG5cbiAgICAgICAgY29uc3QgaW5wdXRIZWxwZXIgPSBpbnB1dFZhcmlhYmxlKCdpbnB1dCcsIGlucHV0c1swXS5kYXRhVHlwZSwgaW5wdXRzWzBdLmRpbXMsIGNvbXBvbmVudHMpO1xuICAgICAgICBjb25zdCBvdXRwdXRIZWxwZXIgPSBvdXRwdXRWYXJpYWJsZSgnb3V0cHV0JywgaW5wdXRzWzBdLmRhdGFUeXBlLCBvdXRwdXRTaGFwZSwgY29tcG9uZW50cyk7XG5cbiAgICAgICAgcmV0dXJuIGBcbiAgQGdyb3VwKDApIEBiaW5kaW5nKDApIHZhcjxzdG9yYWdlLCByZWFkPiBpbnB1dCA6IGFycmF5PCR7aW5wdXRIZWxwZXIudHlwZS5zdG9yYWdlfT47XG4gIEBncm91cCgwKSBAYmluZGluZygxKSB2YXI8c3RvcmFnZSwgcmVhZD4gc2NhbGVJbnB1dCA6IGFycmF5PCR7c2NhbGVUeXBlfT47XG4gIEBncm91cCgwKSBAYmluZGluZygyKSB2YXI8c3RvcmFnZSwgcmVhZF93cml0ZT4gb3V0cHV0IDogYXJyYXk8JHtvdXRwdXRIZWxwZXIudHlwZS5zdG9yYWdlfT47XG4gIHN0cnVjdCBVbmlmb3JtcyB7SDogdTMyLCBDIDogdTMyfTtcbiAgQGdyb3VwKDApIEBiaW5kaW5nKDMpIHZhcjx1bmlmb3JtPiB1bmlmb3JtczogVW5pZm9ybXM7XG5cbiAgJHtzaGFkZXJIZWxwZXIubWFpblN0YXJ0KCl9XG4gICAgbGV0IGN1cnJlbnRJbWFnZU51bWJlciA9IGdsb2JhbF9pZHggLyAodW5pZm9ybXMuQyAqIHVuaWZvcm1zLkgpO1xuICAgIGxldCBjdXJyZW50Q2hhbm5lbE51bWJlciA9IGdsb2JhbF9pZHggJSB1bmlmb3Jtcy5DO1xuXG4gICAgbGV0IHNjYWxlT2Zmc2V0ID0gY3VycmVudEltYWdlTnVtYmVyICogdW5pZm9ybXMuQyArIGN1cnJlbnRDaGFubmVsTnVtYmVyO1xuICAgIGxldCBzY2FsZSA9IHNjYWxlSW5wdXRbc2NhbGVPZmZzZXRdO1xuICAgIG91dHB1dFtnbG9iYWxfaWR4XSA9IGZtYShpbnB1dFtnbG9iYWxfaWR4XSwgJHtzY2FsZUNhc3RUeXBlfShzY2FsZVswXSksICR7c2NhbGVDYXN0VHlwZX0oc2NhbGVbMV0pKTtcbiAgfWA7XG4gICAgICB9O1xuICAgICAgY29udGV4dC5jb21wdXRlKFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJbnN0YW5jZU5vcm1hbGl6YXRpb25OSFdDJyxcbiAgICAgICAgICAgIHNoYWRlckNhY2hlOiB7aGludDogYCR7Y29tcG9uZW50c31gLCBpbnB1dERlcGVuZGVuY2llc30sXG4gICAgICAgICAgICBnZXRSdW5EYXRhOiAoKSA9PiAoe1xuICAgICAgICAgICAgICBvdXRwdXRzOiBbe2RpbXM6IG91dHB1dFNoYXBlLCBkYXRhVHlwZTogaW5wdXRzWzBdLmRhdGFUeXBlfV0sXG4gICAgICAgICAgICAgIGRpc3BhdGNoR3JvdXA6IHt4OiBNYXRoLmNlaWwob3V0cHV0U2l6ZSAvIDY0IC8qIHdvcmtncm91cCBzaXplICovKX0sXG4gICAgICAgICAgICAgIHByb2dyYW1Vbmlmb3Jtc1xuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBnZXRTaGFkZXJTb3VyY2UsXG4gICAgICAgICAgfSxcbiAgICAgICAgICB7aW5wdXRzOiBbaW5wdXRzWzBdLCBjaGFubmVsU2NhbGVTaGlmdF19KTtcbiAgICB9O1xuXG5leHBvcnQgY29uc3QgaW5zdGFuY2VOb3JtID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBJbnN0YW5jZU5vcm1BdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIGlmIChhdHRyaWJ1dGVzLmZvcm1hdCA9PT0gJ05IV0MnKSB7XG4gICAgY3JlYXRlSW5zdGFuY2VOb3JtTkhXQ1Byb2dyYW1JbmZvKGNvbnRleHQsIGNvbnRleHQuaW5wdXRzLCBhdHRyaWJ1dGVzKTtcbiAgfSBlbHNlIHtcbiAgICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlSW5zdGFuY2VOb3JtUHJvZ3JhbUluZm8oY29udGV4dC5pbnB1dHMsIGF0dHJpYnV0ZXMpKTtcbiAgfVxufTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtEYXRhVHlwZX0gZnJvbSAnLi4vLi4vLi4vd2FzbS1jb21tb24nO1xuaW1wb3J0IHtUZW5zb3JWaWV3fSBmcm9tICcuLi8uLi90ZW5zb3Itdmlldyc7XG5pbXBvcnQge1NoYXBlVXRpbH0gZnJvbSAnLi4vLi4vdXRpbCc7XG5pbXBvcnQge0NvbXB1dGVDb250ZXh0LCBQcm9ncmFtSW5mbywgUHJvZ3JhbUlucHV0VGVuc29ySW5mb0RlcGVuZGVuY3ksIFByb2dyYW1Vbmlmb3JtfSBmcm9tICcuLi90eXBlcyc7XG5cbmltcG9ydCB7Y2FzdFRvRjMyLCBmaWxsVmVjdG9yLCBnZXRNYXhDb21wb25lbnRzLCBpbnB1dFZhcmlhYmxlLCBvdXRwdXRWYXJpYWJsZSwgU2hhZGVySGVscGVyLCBzdW1WZWN0b3IsIHRlbnNvclR5cGVUb1dzZ2xTdG9yYWdlVHlwZSwgVW5pZm9ybXNBcnJheVR5cGUsfSBmcm9tICcuL2NvbW1vbic7XG5cbmludGVyZmFjZSBMYXllck5vcm1BdHRyaWJ1dGVzIHtcbiAgYXhpczogbnVtYmVyO1xuICBlcHNpbG9uOiBudW1iZXI7XG59XG5cbmNvbnN0IHZhbGlkYXRlSW5wdXRzID0gKGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdKTogdm9pZCA9PiB7XG4gIGlmICghaW5wdXRzIHx8IGlucHV0cy5sZW5ndGggPCAyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdsYXllck5vcm0gcmVxdWlyZXMgYXQgbGVhc3QgMiBpbnB1dHMuJyk7XG4gIH1cbn07XG5cbmNvbnN0IGNyZWF0ZUxheWVyTm9ybVByb2dyYW1JbmZvID1cbiAgICAoaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10sIGF0dHJpYnV0ZXM6IExheWVyTm9ybUF0dHJpYnV0ZXMsIG91dHB1dENvdW50OiBudW1iZXIpOiBQcm9ncmFtSW5mbyA9PiB7XG4gICAgICBjb25zdCB4U2hhcGUgPSBpbnB1dHNbMF0uZGltcztcbiAgICAgIGNvbnN0IHNjYWxlID0gaW5wdXRzWzFdO1xuICAgICAgY29uc3QgYmlhcyA9IGlucHV0c1syXTtcblxuICAgICAgY29uc3Qgb3V0cHV0U2hhcGUgPSB4U2hhcGU7XG4gICAgICBjb25zdCBheGlzID0gU2hhcGVVdGlsLm5vcm1hbGl6ZUF4aXMoYXR0cmlidXRlcy5heGlzLCB4U2hhcGUubGVuZ3RoKTtcbiAgICAgIGNvbnN0IG5vcm1Db3VudCA9IFNoYXBlVXRpbC5zaXplVG9EaW1lbnNpb24oeFNoYXBlLCBheGlzKTtcbiAgICAgIGNvbnN0IG5vcm1TaXplID0gU2hhcGVVdGlsLnNpemVGcm9tRGltZW5zaW9uKHhTaGFwZSwgYXhpcyk7XG5cbiAgICAgIGNvbnN0IHNjYWxlU2l6ZSA9IFNoYXBlVXRpbC5zaXplKHNjYWxlLmRpbXMpO1xuICAgICAgY29uc3QgYmlhc1NpemUgPSBiaWFzID8gU2hhcGVVdGlsLnNpemUoYmlhcy5kaW1zKSA6IDA7XG4gICAgICBpZiAoc2NhbGVTaXplICE9PSBub3JtU2l6ZSB8fCAoYmlhcyAmJiBiaWFzU2l6ZSAhPT0gbm9ybVNpemUpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgU2l6ZSBvZiBYLnNoYXBlKClbYXhpczpdID09ICR7bm9ybVNpemV9LlxuICAgICAgIFNpemUgb2Ygc2NhbGUgYW5kIGJpYXMgKGlmIHByb3ZpZGVkKSBtdXN0IG1hdGNoIHRoaXMuXG4gICAgICAgR290IHNjYWxlIHNpemUgb2YgJHtzY2FsZVNpemV9IGFuZCBiaWFzIHNpemUgb2YgJHtiaWFzU2l6ZX1gKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgbWVhbkludlN0ZERldkRpbTogbnVtYmVyW10gPSBbXTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgeFNoYXBlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGlmIChpIDwgYXhpcykge1xuICAgICAgICAgIG1lYW5JbnZTdGREZXZEaW0ucHVzaCh4U2hhcGVbaV0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1lYW5JbnZTdGREZXZEaW0ucHVzaCgxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgY29tcG9uZW50cyA9IGdldE1heENvbXBvbmVudHMobm9ybVNpemUpO1xuICAgICAgY29uc3QgaW5wdXREZXBlbmRlbmNpZXM6IFByb2dyYW1JbnB1dFRlbnNvckluZm9EZXBlbmRlbmN5W10gPSBbJ3R5cGUnLCAndHlwZSddO1xuICAgICAgY29uc3QgcHJvZ3JhbVVuaWZvcm1zOiBQcm9ncmFtVW5pZm9ybVtdID0gW1xuICAgICAgICB7dHlwZTogJ3VpbnQzMicsIGRhdGE6IG5vcm1Db3VudH0sIHt0eXBlOiAnZmxvYXQzMicsIGRhdGE6IG5vcm1TaXplfSxcbiAgICAgICAge3R5cGU6ICd1aW50MzInLCBkYXRhOiBNYXRoLmZsb29yKG5vcm1TaXplIC8gY29tcG9uZW50cyl9LCB7dHlwZTogJ2Zsb2F0MzInLCBkYXRhOiBhdHRyaWJ1dGVzLmVwc2lsb259XG4gICAgICBdO1xuICAgICAgaWYgKGJpYXMpIHtcbiAgICAgICAgaW5wdXREZXBlbmRlbmNpZXMucHVzaCgndHlwZScpO1xuICAgICAgfVxuICAgICAgY29uc3QgaGFzTWVhbkRhdGFPdXRwdXQgPSBvdXRwdXRDb3VudCA+IDE7XG4gICAgICBjb25zdCBoYXNJbnZTdGRPdXRwdXQgPSBvdXRwdXRDb3VudCA+IDI7XG5cbiAgICAgIGNvbnN0IGdldFNoYWRlclNvdXJjZSA9IChzaGFkZXJIZWxwZXI6IFNoYWRlckhlbHBlcikgPT4ge1xuICAgICAgICBjb25zdCBkYXRhVHlwZSA9IHRlbnNvclR5cGVUb1dzZ2xTdG9yYWdlVHlwZShpbnB1dHNbMF0uZGF0YVR5cGUpO1xuICAgICAgICBjb25zdCB2YXJpYWJsZXMgPSBbXG4gICAgICAgICAgaW5wdXRWYXJpYWJsZSgneCcsIGlucHV0c1swXS5kYXRhVHlwZSwgaW5wdXRzWzBdLmRpbXMsIGNvbXBvbmVudHMpLFxuICAgICAgICAgIGlucHV0VmFyaWFibGUoJ3NjYWxlJywgc2NhbGUuZGF0YVR5cGUsIHNjYWxlLmRpbXMsIGNvbXBvbmVudHMpLFxuICAgICAgICBdO1xuICAgICAgICBpZiAoYmlhcykge1xuICAgICAgICAgIHZhcmlhYmxlcy5wdXNoKGlucHV0VmFyaWFibGUoJ2JpYXMnLCBiaWFzLmRhdGFUeXBlLCBiaWFzLmRpbXMsIGNvbXBvbmVudHMpKTtcbiAgICAgICAgfVxuICAgICAgICB2YXJpYWJsZXMucHVzaChvdXRwdXRWYXJpYWJsZSgnb3V0cHV0JywgaW5wdXRzWzBdLmRhdGFUeXBlLCBvdXRwdXRTaGFwZSwgY29tcG9uZW50cykpO1xuICAgICAgICBpZiAoaGFzTWVhbkRhdGFPdXRwdXQpIHtcbiAgICAgICAgICB2YXJpYWJsZXMucHVzaChvdXRwdXRWYXJpYWJsZSgnbWVhbl9kYXRhX291dHB1dCcsIERhdGFUeXBlLmZsb2F0LCBtZWFuSW52U3RkRGV2RGltKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhhc0ludlN0ZE91dHB1dCkge1xuICAgICAgICAgIHZhcmlhYmxlcy5wdXNoKG91dHB1dFZhcmlhYmxlKCdpbnZfc3RkX291dHB1dCcsIERhdGFUeXBlLmZsb2F0LCBtZWFuSW52U3RkRGV2RGltKSk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB1bmlmb3JtczogVW5pZm9ybXNBcnJheVR5cGUgPSBbXG4gICAgICAgICAge25hbWU6ICdub3JtX2NvdW50JywgdHlwZTogJ3UzMid9LCB7bmFtZTogJ25vcm1fc2l6ZScsIHR5cGU6ICdmMzInfSxcbiAgICAgICAgICB7bmFtZTogJ25vcm1fc2l6ZV92ZWN0b3JpemVkJywgdHlwZTogJ3UzMid9LCB7bmFtZTogJ2Vwc2lsb24nLCB0eXBlOiAnZjMyJ31cbiAgICAgICAgXTtcbiAgICAgICAgcmV0dXJuIGBcbiAgJHtzaGFkZXJIZWxwZXIucmVnaXN0ZXJVbmlmb3Jtcyh1bmlmb3JtcykuZGVjbGFyZVZhcmlhYmxlcyguLi52YXJpYWJsZXMpfVxuICAke3NoYWRlckhlbHBlci5tYWluU3RhcnQoKX1cbiAgICAke3NoYWRlckhlbHBlci5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKCd1bmlmb3Jtcy5ub3JtX2NvdW50Jyl9XG4gICAgbGV0IG9mZnNldCA9IGdsb2JhbF9pZHggKiB1bmlmb3Jtcy5ub3JtX3NpemVfdmVjdG9yaXplZDtcbiAgICB2YXIgbWVhblZlY3RvciA9ICR7ZmlsbFZlY3RvcignZjMyJywgY29tcG9uZW50cyl9O1xuICAgIHZhciBtZWFuU3F1YXJlVmVjdG9yID0gJHtmaWxsVmVjdG9yKCdmMzInLCBjb21wb25lbnRzKX07XG5cbiAgICBmb3IgKHZhciBoOiB1MzIgPSAwdTsgaCA8IHVuaWZvcm1zLm5vcm1fc2l6ZV92ZWN0b3JpemVkOyBoKyspIHtcbiAgICAgIGxldCB2YWx1ZSA9ICR7Y2FzdFRvRjMyKGRhdGFUeXBlLCBjb21wb25lbnRzLCAneFtoICsgb2Zmc2V0XScpfTtcbiAgICAgIG1lYW5WZWN0b3IgKz0gdmFsdWU7XG4gICAgICBtZWFuU3F1YXJlVmVjdG9yICs9IHZhbHVlICogdmFsdWU7XG4gICAgfVxuICAgIGxldCBtZWFuID0gJHtzdW1WZWN0b3IoJ21lYW5WZWN0b3InLCBjb21wb25lbnRzKX0gLyB1bmlmb3Jtcy5ub3JtX3NpemU7XG4gICAgbGV0IGludlN0ZERldiA9XG4gICAgICAgIGludmVyc2VTcXJ0KCR7c3VtVmVjdG9yKCdtZWFuU3F1YXJlVmVjdG9yJywgY29tcG9uZW50cyl9IC8gdW5pZm9ybXMubm9ybV9zaXplIC0gbWVhbiAqIG1lYW4gKyB1bmlmb3Jtcy5lcHNpbG9uKTtcblxuICAgIGZvciAodmFyIGo6IHUzMiA9IDA7IGogPCB1bmlmb3Jtcy5ub3JtX3NpemVfdmVjdG9yaXplZDsgaisrKSB7XG4gICAgICBsZXQgZjMyaW5wdXQgPSAke2Nhc3RUb0YzMihkYXRhVHlwZSwgY29tcG9uZW50cywgJ3hbaiArIG9mZnNldF0nKX07XG4gICAgICBsZXQgZjMyc2NhbGUgPSAke2Nhc3RUb0YzMihkYXRhVHlwZSwgY29tcG9uZW50cywgJ3NjYWxlW2pdJyl9O1xuICAgICAgb3V0cHV0W2ogKyBvZmZzZXRdID0gJHt2YXJpYWJsZXNbMF0udHlwZS52YWx1ZX0oKGYzMmlucHV0IC0gbWVhbikgKiBpbnZTdGREZXYgKiBmMzJzY2FsZVxuICAgICAgICAke2JpYXMgPyBgKyAke2Nhc3RUb0YzMihkYXRhVHlwZSwgY29tcG9uZW50cywgJ2JpYXNbal0nKX1gIDogJyd9XG4gICAgICApO1xuICAgIH1cblxuICAgICR7aGFzTWVhbkRhdGFPdXRwdXQgPyAnbWVhbl9kYXRhX291dHB1dFtnbG9iYWxfaWR4XSA9IG1lYW4nIDogJyd9O1xuICAgICR7aGFzSW52U3RkT3V0cHV0ID8gJ2ludl9zdGRfb3V0cHV0W2dsb2JhbF9pZHhdID0gaW52U3RkRGV2JyA6ICcnfTtcbiAgfWA7XG4gICAgICB9O1xuICAgICAgY29uc3Qgb3V0cHV0cyA9IFt7ZGltczogb3V0cHV0U2hhcGUsIGRhdGFUeXBlOiBpbnB1dHNbMF0uZGF0YVR5cGV9XTtcbiAgICAgIGlmIChoYXNNZWFuRGF0YU91dHB1dCkge1xuICAgICAgICBvdXRwdXRzLnB1c2goe2RpbXM6IG1lYW5JbnZTdGREZXZEaW0sIGRhdGFUeXBlOiBEYXRhVHlwZS5mbG9hdH0pO1xuICAgICAgfVxuICAgICAgaWYgKGhhc0ludlN0ZE91dHB1dCkge1xuICAgICAgICBvdXRwdXRzLnB1c2goe2RpbXM6IG1lYW5JbnZTdGREZXZEaW0sIGRhdGFUeXBlOiBEYXRhVHlwZS5mbG9hdH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBuYW1lOiAnTGF5ZXJOb3JtYWxpemF0aW9uJyxcbiAgICAgICAgc2hhZGVyQ2FjaGU6IHtoaW50OiBgJHtjb21wb25lbnRzfTske291dHB1dENvdW50fWAsIGlucHV0RGVwZW5kZW5jaWVzfSxcbiAgICAgICAgZ2V0UnVuRGF0YTogKCkgPT5cbiAgICAgICAgICAgICh7b3V0cHV0cywgZGlzcGF0Y2hHcm91cDoge3g6IE1hdGguY2VpbChub3JtQ291bnQgLyA2NCAvKiB3b3JrZ3JvdXAgc2l6ZSAqLyl9LCBwcm9ncmFtVW5pZm9ybXN9KSxcbiAgICAgICAgZ2V0U2hhZGVyU291cmNlLFxuICAgICAgfTtcbiAgICB9O1xuXG5leHBvcnQgY29uc3QgbGF5ZXJOb3JtID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBMYXllck5vcm1BdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIHZhbGlkYXRlSW5wdXRzKGNvbnRleHQuaW5wdXRzKTtcbiAgY29udGV4dC5jb21wdXRlKGNyZWF0ZUxheWVyTm9ybVByb2dyYW1JbmZvKGNvbnRleHQuaW5wdXRzLCBhdHRyaWJ1dGVzLCBjb250ZXh0Lm91dHB1dENvdW50KSk7XG59O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge1RlbnNvclZpZXd9IGZyb20gJy4uLy4uL3RlbnNvci12aWV3JztcbmltcG9ydCB7U2hhcGVVdGlsfSBmcm9tICcuLi8uLi91dGlsJztcbmltcG9ydCB7Y3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5fSBmcm9tICcuLi9hdHRyaWJ1dGUtd2l0aC1jYWNoZS1rZXknO1xuaW1wb3J0IHtDb21wdXRlQ29udGV4dCwgR3B1RGF0YVR5cGUsIFByb2dyYW1Vbmlmb3JtfSBmcm9tICcuLi90eXBlcyc7XG5cbmltcG9ydCB7YXBwbHlBdHRlbnRpb24sIEF0dGVudGlvbkF0dHJzLCBBdHRlbnRpb25NYXNrVHlwZSwgQXR0ZW50aW9uUGFyYW1ldGVycywgQXR0ZW50aW9uUWt2Rm9ybWF0fSBmcm9tICcuL2F0dGVudGlvbic7XG5pbXBvcnQge2lucHV0VmFyaWFibGUsIG91dHB1dFZhcmlhYmxlLCBTaGFkZXJIZWxwZXIsIFVuaWZvcm1zQXJyYXlUeXBlfSBmcm9tICcuL2NvbW1vbic7XG5pbXBvcnQge2NyZWF0ZVRyYW5zcG9zZVByb2dyYW1JbmZvLCBUcmFuc3Bvc2VBdHRyaWJ1dGVzfSBmcm9tICcuL3RyYW5zcG9zZSc7XG5cbmNvbnN0IHZhbGlkYXRlSW5wdXRzID0gKGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdLCBhdHRyaWJ1dGVzOiBBdHRlbnRpb25BdHRycyk6IEF0dGVudGlvblBhcmFtZXRlcnMgPT4ge1xuICBjb25zdCBxdWVyeSA9IGlucHV0c1swXTtcbiAgY29uc3Qga2V5ID0gaW5wdXRzWzFdO1xuICBjb25zdCB2YWx1ZSA9IGlucHV0c1syXTtcbiAgY29uc3QgYmlhcyA9IGlucHV0c1szXTtcbiAgY29uc3Qga2V5UGFkZGluZ01hc2sgPSBpbnB1dHNbNF07XG4gIGNvbnN0IHJlbGF0aXZlUG9zaXRpb25CaWFzID0gaW5wdXRzWzVdO1xuICBjb25zdCBwYXN0S2V5ID0gaW5wdXRzWzZdO1xuICBjb25zdCBwYXN0VmFsdWUgPSBpbnB1dHNbN107XG5cbiAgLy8gQWJicmV2aWF0aW9uIGFuZCBNZWFuaW5nczpcbiAgLy8gICBCOiAgICBiYXRjaF9zaXplXG4gIC8vICAgUzogICAgc2VxdWVuY2VfbGVuZ3RoIChpbnB1dCBzZXF1ZW5jZSBsZW5ndGggb2YgcXVlcnkpXG4gIC8vICAgUDogICAgcGFzdF9zZXF1ZW5jZV9sZW5ndGggKHBhc3Qgc2VxdWVuY2UgbGVuZ3RoIG9mIGtleSBvciB2YWx1ZSlcbiAgLy8gICBMOiAgICBrdl9zZXF1ZW5jZV9sZW5ndGggKGlucHV0IHNlcXVlbmNlIGxlbmd0aCBvZiBrZXkgb3IgdmFsdWUpXG4gIC8vICAgTTogICAgbWF4X3NlcXVlbmNlX2xlbmd0aFxuICAvLyAgIFQ6ICAgIHRvdGFsX3NlcXVlbmNlX2xlbmd0aCA9IHBhc3Rfc2VxdWVuY2VfbGVuZ3RoICsga3Zfc2VxdWVuY2VfbGVuZ3RoXG4gIC8vICAgTjogICAgbnVtX2hlYWRzXG4gIC8vICAgSDogICAgaGVhZCBzaXplIGZvciBRIGFuZCBLLCBha2EgcV9oZWFkX3NpemUgb3Iga19oZWFkX3NpemUgb3IgcWtfaGVhZF9zaXplXG4gIC8vICAgSF92OiAgdl9oZWFkX3NpemVcbiAgLy8gICBEX2k6ICBpbnB1dCBoaWRkZW4gc2l6ZVxuICAvLyAgIEQ6ICAgIGhpZGRlbiBzaXplIGZvciBRIGFuZCBLIChEID0gTiAqIEgpLCBha2EgcV9oaWRkZW5fc2l6ZSBvciBrX2hpZGRlbl9zaXplIG9yIHFrX2hpZGRlbl9zaXplXG4gIC8vICAgRF92OiAgdl9oaWRkZW5fc2l6ZSA9IG51bV9oZWFkcyAqIHZfaGVhZF9zaXplXG5cbiAgLy8gICAgIGtleV9wYWRkaW5nX21hc2sgKEsvVikgICAgIDogKEIpIG9yICgyKkIgKyAxKSBvciAoQiwgTCkgb3IgTm9uZVxuICAvLyAgICAgcmVsYXRpdmVfcG9zaXRpb25fYmlhcyAgICAgOiAoQiwgMSwgUywgTClcbiAgLy8gICAgIHBhc3Rfa2V5ICAgICAgICAgICAgICAgICAgIDogKEIsIE4sIFMqLCBIKVxuICAvLyAgICAgcGFzdF92YWx1ZSAgICAgICAgICAgICAgICAgOiAoQiwgTiwgUyosIEgpXG4gIC8vIFdoZW4gbm8gcGFja2luZyBmb3IgcS9rL3Y6XG4gIC8vICAgICBxdWVyeSAgICAgICAgICAgIChRKSAgICAgICA6IChCLCBTLCBEKVxuICAvLyAgICAga2V5ICAgICAgICAgICAgICAoSykgICAgICAgOiAoQiwgTCwgRCkgb3IgKEIsIE4sIFMqLCBIKVxuICAvLyAgICAgdmFsdWUgICAgICAgICAgICAoVikgICAgICAgOiAoQiwgTCwgRF92KSBvciAoQiwgTiwgUyosIEgpXG4gIC8vICAgICBiaWFzICAgICAgICAgICAgIChRL0svVikgICA6IChEICsgRCArIERfdilcbiAgLy8gV2hlbiBwYWNrZWQga3YgaXMgdXNlZDpcbiAgLy8gICAgIHF1ZXJ5ICAgICAgICAgICAgKFEpICAgICAgIDogKEIsIFMsIEQpXG4gIC8vICAgICBrZXkgICAgICAgICAgICAgIChLKSAgICAgICA6IChCLCBMLCBOLCAyLCBIKVxuICAvLyAgICAgdmFsdWUgICAgICAgICAgICAoVikgICAgICAgOiBOb25lXG4gIC8vICAgICBiaWFzICAgICAgICAgICAgIChRL0svVikgICA6IE5vbmVcbiAgLy8gV2hlbiBwYWNrZWQgcWt2IGlzIHVzZWQ6XG4gIC8vICAgICBxdWVyeSAgICAgICAgICAgIChRKSAgICAgICA6IChCLCBMLCBOLCAzLCBIKSBvciAoQiwgUywgMypEKVxuICAvLyAgICAga2V5ICAgICAgICAgICAgICAoSykgICAgICAgOiBOb25lXG4gIC8vICAgICB2YWx1ZSAgICAgICAgICAgIChWKSAgICAgICA6IE5vbmVcbiAgLy8gICAgIGJpYXMgICAgICAgICAgICAgKFEvSy9WKSAgIDogTm9uZSBvciAoRCArIEQgKyBEX3YpXG5cbiAgaWYgKHF1ZXJ5LmRpbXMubGVuZ3RoICE9PSAzICYmIHF1ZXJ5LmRpbXMubGVuZ3RoICE9PSA1KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBxdWVyeSBpcyBleHBlY3RlZCB0byBoYXZlIDMgb3IgNSBkaW1lbnNpb25zJyk7XG4gIH1cblxuICBjb25zdCBkbW1oYVBhY2tpbmcgPSBmYWxzZTtcbiAgY29uc3QgYmF0Y2hTaXplID0gcXVlcnkuZGltc1swXTtcbiAgY29uc3Qgc2VxdWVuY2VMZW5ndGggPSBxdWVyeS5kaW1zWzFdO1xuICBjb25zdCBoaWRkZW5TaXplID0gcXVlcnkuZGltcy5sZW5ndGggPT09IDMgPyAoZG1taGFQYWNraW5nID8gcXVlcnkuZGltc1syXSAvIDMgOiBxdWVyeS5kaW1zWzJdKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXMubnVtSGVhZHMgKiBxdWVyeS5kaW1zWzRdO1xuICBsZXQga3ZTZXF1ZW5jZUxlbmd0aCA9IHNlcXVlbmNlTGVuZ3RoO1xuXG4gIGxldCBwYXN0U2VxdWVuY2VMZW5ndGggPSAwO1xuICBsZXQgbWF4U2VxdWVuY2VMZW5ndGggPSAwO1xuICBjb25zdCBoZWFkU2l6ZSA9IE1hdGguZmxvb3IoaGlkZGVuU2l6ZSAvIGF0dHJpYnV0ZXMubnVtSGVhZHMpO1xuICBpZiAocGFzdEtleSAmJiBwYXN0VmFsdWUpIHtcbiAgICBpZiAocGFzdEtleS5kaW1zLmxlbmd0aCAhPT0gNCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInBhc3Rfa2V5XCIgaXMgZXhwZWN0ZWQgdG8gaGF2ZSA0IGRpbWVuc2lvbnMnKTtcbiAgICB9XG4gICAgaWYgKHBhc3RWYWx1ZS5kaW1zLmxlbmd0aCAhPT0gNCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInBhc3RfdmFsdWVcIiBpcyBleHBlY3RlZCB0byBoYXZlIDQgZGltZW5zaW9ucycpO1xuICAgIH1cbiAgICBwYXN0U2VxdWVuY2VMZW5ndGggPSBwYXN0S2V5LmRpbXNbMl07XG4gICAgbWF4U2VxdWVuY2VMZW5ndGggPSBwYXN0S2V5LmRpbXNbMl07XG4gIH0gZWxzZSBpZiAocGFzdEtleSB8fCBwYXN0VmFsdWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwicGFzdF9rZXlcIiBhbmQgXCJwYXN0X3ZhbHVlXCIgc2hhbGwgYmUgYm90aCBwcmVzZW50IG9yIGJvdGggYWJzZW50Jyk7XG4gIH1cblxuICBsZXQgcWt2Rm9ybWF0OiBBdHRlbnRpb25Ra3ZGb3JtYXQ7XG4gIGlmIChrZXkpIHtcbiAgICBpZiAocXVlcnkuZGltcy5sZW5ndGggIT09IDMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgXCJxdWVyeVwiIGlzIGV4cGVjdGVkIHRvIGhhdmUgMyBkaW1lbnNpb25zIHdoZW4ga2V5IGlzIGdpdmVuJyk7XG4gICAgfVxuICAgIGlmIChrZXkuZGltcy5sZW5ndGggPCAzIHx8IGtleS5kaW1zLmxlbmd0aCA+IDUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgXCJrZXlcIiBpcyBleHBlY3RlZCB0byBoYXZlIDMsIDQsIG9yIDUgZGltZW5zaW9ucycpO1xuICAgIH1cbiAgICBpZiAocXVlcnkuZGltc1swXSAhPT0ga2V5LmRpbXNbMF0pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgXCJxdWVyeVwiIGFuZCBcImtleVwiIHNoYWxsIGhhdmUgc2FtZSBkaW0gMCAoYmF0Y2ggc2l6ZSknKTtcbiAgICB9XG5cbiAgICBpZiAoa2V5LmRpbXMubGVuZ3RoID09PSAzKSB7XG4gICAgICBpZiAoa2V5LmRpbXNbMl0gIT09IHF1ZXJ5LmRpbXNbMl0pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInF1ZXJ5XCIgYW5kIFwia2V5XCIgc2hhbGwgaGF2ZSBzYW1lIGRpbSAyIChoaWRkZW5fc2l6ZSknKTtcbiAgICAgIH1cbiAgICAgIHFrdkZvcm1hdCA9IEF0dGVudGlvblFrdkZvcm1hdC5xa3ZCU05IO1xuICAgICAga3ZTZXF1ZW5jZUxlbmd0aCA9IGtleS5kaW1zWzFdO1xuICAgIH0gZWxzZSBpZiAoa2V5LmRpbXMubGVuZ3RoID09PSA1KSB7XG4gICAgICBpZiAoa2V5LmRpbXNbMl0gIT09IGF0dHJpYnV0ZXMubnVtSGVhZHMgfHwga2V5LmRpbXNbM10gIT09IDIgfHwga2V5LmRpbXNbNF0gIT09IGhlYWRTaXplKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0IFwia2V5XCIgc2hhcGUgKGJhdGNoX3NpemUsIGt2X3NlcXVlbmNlX2xlbmd0aCwgbnVtX2hlYWRzLCAyLCBoZWFkX3NpemUpIGZvciBwYWNrZWQga3YnKTtcbiAgICAgIH1cbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdCBcInZhbHVlXCIgYmUgbm9uZSB3aGVuIFwia2V5XCIgaGFzIHBhY2tlZCBrdiBmb3JtYXQuJyk7XG4gICAgICB9XG4gICAgICBxa3ZGb3JtYXQgPSBBdHRlbnRpb25Ra3ZGb3JtYXQucUt2QlNOSHhCU04ySDtcbiAgICAgIGt2U2VxdWVuY2VMZW5ndGggPSBrZXkuZGltc1sxXTtcbiAgICB9IGVsc2UgeyAgLy8ga2V5X2RpbXMuc2l6ZSgpID09IDQgKGNyb3NzLWF0dGVudGlvbiB3aXRoIHBhc3Rfa2V5KVxuICAgICAgaWYgKGtleS5kaW1zWzFdICE9PSBhdHRyaWJ1dGVzLm51bUhlYWRzIHx8IGtleS5kaW1zWzNdICE9PSBoZWFkU2l6ZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdCBcImtleVwiIHNoYXBlIChiYXRjaF9zaXplLCBudW1faGVhZHMsIGt2X3NlcXVlbmNlX2xlbmd0aCwgaGVhZF9zaXplKSBmb3IgcGFzdF9rZXknKTtcbiAgICAgIH1cblxuICAgICAgcWt2Rm9ybWF0ID0gQXR0ZW50aW9uUWt2Rm9ybWF0LnVua25vd247XG4gICAgICBrdlNlcXVlbmNlTGVuZ3RoID0ga2V5LmRpbXNbMl07XG4gICAgfVxuICB9IGVsc2UgeyAgLy8gcGFja2VkIFFLVlxuICAgIGlmIChxdWVyeS5kaW1zLmxlbmd0aCAhPT0gMyAmJiBxdWVyeS5kaW1zLmxlbmd0aCAhPT0gNSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInF1ZXJ5XCIgaXMgZXhwZWN0ZWQgdG8gaGF2ZSAzIG9yIDUgZGltZW5zaW9ucyB3aGVuIGtleSBpcyBlbXB0eScpO1xuICAgIH1cbiAgICBpZiAocXVlcnkuZGltcy5sZW5ndGggPT09IDUgJiYgKHF1ZXJ5LmRpbXNbMl0gIT09IGF0dHJpYnV0ZXMubnVtSGVhZHMgfHwgcXVlcnkuZGltc1szXSAhPT0gMykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0IFwicXVlcnlcIiBzaGFwZSAoYmF0Y2hfc2l6ZSwga3Zfc2VxdWVuY2VfbGVuZ3RoLCBudW1faGVhZHMsIDMsIGhlYWRfc2l6ZSkgZm9yIHBhY2tlZCBrdicpO1xuICAgIH1cblxuICAgIHFrdkZvcm1hdCA9IEF0dGVudGlvblFrdkZvcm1hdC5xa3ZCU04zSDtcbiAgfVxuXG4gIGlmIChiaWFzKSB7XG4gICAgaWYgKGJpYXMuZGltcy5sZW5ndGggIT09IDEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgXCJiaWFzXCIgaXMgZXhwZWN0ZWQgdG8gaGF2ZSAxIGRpbWVuc2lvbicpO1xuICAgIH1cblxuICAgIGlmICh2YWx1ZSkge1xuICAgICAgaWYgKHF1ZXJ5LmRpbXMubGVuZ3RoID09PSA1ICYmIHF1ZXJ5LmRpbXNbM10gPT09IDIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiaWFzIGlzIG5vdCBhbGxvd2VkIGZvciBwYWNrZWQga3YuJyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgbGV0IG1hc2tUeXBlOiBBdHRlbnRpb25NYXNrVHlwZSA9IEF0dGVudGlvbk1hc2tUeXBlLm5vbmU7XG4gIGlmIChrZXlQYWRkaW5nTWFzaykge1xuICAgIG1hc2tUeXBlID0gQXR0ZW50aW9uTWFza1R5cGUubWFza1Vua25vd247XG4gICAgY29uc3QgbWFza0RpbXMgPSBrZXlQYWRkaW5nTWFzay5kaW1zO1xuICAgIGlmIChtYXNrRGltcy5sZW5ndGggPT09IDEpIHtcbiAgICAgIGlmIChtYXNrRGltc1swXSA9PT0gYmF0Y2hTaXplKSB7XG4gICAgICAgIG1hc2tUeXBlID0gQXR0ZW50aW9uTWFza1R5cGUubWFzazFkS2V5U2VxTGVuO1xuICAgICAgfSBlbHNlIGlmIChtYXNrRGltc1swXSA9PT0gMyAqIGJhdGNoU2l6ZSArIDIpIHtcbiAgICAgICAgbWFza1R5cGUgPSBBdHRlbnRpb25NYXNrVHlwZS5tYXNrMURLZXlTZXFMZW5TdGFydDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG1hc2tEaW1zLmxlbmd0aCA9PT0gMiAmJiBtYXNrRGltc1swXSA9PT0gYmF0Y2hTaXplICYmIG1hc2tEaW1zWzFdID09PSBrdlNlcXVlbmNlTGVuZ3RoKSB7XG4gICAgICBtYXNrVHlwZSA9IEF0dGVudGlvbk1hc2tUeXBlLm1hc2syZEtleVBhZGRpbmc7XG4gICAgfVxuICAgIGlmIChtYXNrVHlwZSA9PT0gQXR0ZW50aW9uTWFza1R5cGUubWFza1Vua25vd24pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgXCJrZXlfcGFkZGluZ19tYXNrXCIgc2hhcGUgc2hhbGwgYmUgKGJhdGNoX3NpemUpIG9yIChiYXRjaF9zaXplLCBrdl9zZXF1ZW5jZV9sZW5ndGgpJyk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcignTWFzayBub3Qgc3VwcG9ydGVkJyk7XG4gIH1cblxuICBsZXQgcGFzc1Bhc3RJbkt2ID0gZmFsc2U7XG4gIGxldCB2SGlkZGVuU2l6ZSA9IGhpZGRlblNpemU7XG4gIGlmICh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZS5kaW1zLmxlbmd0aCAhPT0gMyAmJiB2YWx1ZS5kaW1zLmxlbmd0aCAhPT0gNCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInZhbHVlXCIgaXMgZXhwZWN0ZWQgdG8gaGF2ZSAzIG9yIDQgZGltZW5zaW9ucycpO1xuICAgIH1cblxuICAgIGlmIChxdWVyeS5kaW1zWzBdICE9PSB2YWx1ZS5kaW1zWzBdKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwicXVlcnlcIiBhbmQgXCJ2YWx1ZVwiIHNoYWxsIGhhdmUgc2FtZSBkaW0gMCAoYmF0Y2hfc2l6ZSknKTtcbiAgICB9XG5cbiAgICBpZiAodmFsdWUuZGltcy5sZW5ndGggPT09IDMpIHtcbiAgICAgIGlmIChrdlNlcXVlbmNlTGVuZ3RoICE9PSB2YWx1ZS5kaW1zWzFdKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgXCJrZXlcIiBhbmQgXCJ2YWx1ZVwiIHNoYWxsIGhhdmUgdGhlIHNhbWUgZGltIDEgKGt2X3NlcXVlbmNlX2xlbmd0aCknKTtcbiAgICAgIH1cbiAgICAgIHZIaWRkZW5TaXplID0gdmFsdWUuZGltc1syXTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGt2U2VxdWVuY2VMZW5ndGggIT09IHZhbHVlLmRpbXNbMl0pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInBhc3Rfa2V5XCIgYW5kIFwicGFzdF92YWx1ZVwiIHNoYWxsIGhhdmUgdGhlIHNhbWUgZGltIDIgKGt2X3NlcXVlbmNlX2xlbmd0aCknKTtcbiAgICAgIH1cbiAgICAgIHZIaWRkZW5TaXplID0gdmFsdWUuZGltc1sxXSAqIHZhbHVlLmRpbXNbM107XG4gICAgICBwYXNzUGFzdEluS3YgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHRvdGFsU2VxdWVuY2VMZW5ndGggPSBwYXN0U2VxdWVuY2VMZW5ndGggKyBrdlNlcXVlbmNlTGVuZ3RoO1xuICBjb25zdCBicm9hZGNhc3RSZXNQb3NCaWFzID0gZmFsc2U7XG4gIC8vIGlmIChleHRyYUFkZFFrKSB7XG4gIC8vICAgaWYgKGV4dHJhQWRkUWsuZGltc1swXSA9PT0gMSkge1xuICAvLyAgICAgYnJvYWRjYXN0UmVzUG9zQmlhcyA9IHRydWU7XG4gIC8vICAgfVxuICAvLyB9XG5cbiAgaWYgKGtleVBhZGRpbmdNYXNrKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdLZXkgcGFkZGluZyBtYXNrIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbiAgfVxuICBpZiAocmVsYXRpdmVQb3NpdGlvbkJpYXMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4dHJhQWRkUWsgaXMgbm90IHN1cHBvcnRlZCcpO1xuICB9XG4gIGlmIChwYXN0S2V5KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwYXN0S2V5IGlzIG5vdCBzdXBwb3J0ZWQnKTtcbiAgfVxuICBpZiAocGFzdFZhbHVlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwYXN0VmFsdWUgaXMgbm90IHN1cHBvcnRlZCcpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBiYXRjaFNpemUsXG4gICAgc2VxdWVuY2VMZW5ndGgsXG4gICAgcGFzdFNlcXVlbmNlTGVuZ3RoLFxuICAgIGt2U2VxdWVuY2VMZW5ndGgsXG4gICAgdG90YWxTZXF1ZW5jZUxlbmd0aCxcbiAgICBtYXhTZXF1ZW5jZUxlbmd0aCxcbiAgICBpbnB1dEhpZGRlblNpemU6IDAsXG4gICAgaGlkZGVuU2l6ZSxcbiAgICB2SGlkZGVuU2l6ZSxcbiAgICBoZWFkU2l6ZSxcbiAgICB2SGVhZFNpemU6IE1hdGguZmxvb3IodkhpZGRlblNpemUgLyBhdHRyaWJ1dGVzLm51bUhlYWRzKSxcbiAgICBudW1IZWFkczogYXR0cmlidXRlcy5udW1IZWFkcyxcbiAgICBpc1VuaWRpcmVjdGlvbmFsOiBmYWxzZSxcbiAgICBwYXN0UHJlc2VudFNoYXJlQnVmZmVyOiBmYWxzZSxcbiAgICBtYXNrRmlsdGVyVmFsdWU6IGF0dHJpYnV0ZXMubWFza0ZpbHRlclZhbHVlLFxuICAgIG1hc2tUeXBlLFxuICAgIHNjYWxlOiBhdHRyaWJ1dGVzLnNjYWxlLFxuICAgIGJyb2FkY2FzdFJlc1Bvc0JpYXMsXG4gICAgcGFzc1Bhc3RJbkt2LFxuICAgIHFrdkZvcm1hdCxcbiAgfTtcbn07XG5cbmV4cG9ydCBjb25zdCBwYXJzZU11bHRpSGVhZEF0dGVudGlvbkF0dHJpYnV0ZXMgPSAoYXR0cmlidXRlczogQXR0ZW50aW9uQXR0cnMpOiBBdHRlbnRpb25BdHRycyA9PlxuICAgIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSh7Li4uYXR0cmlidXRlc30pO1xuXG5jb25zdCB3ZWlnaHRUcmFuc3Bvc2VBdHRyaWJ1dGU6IFRyYW5zcG9zZUF0dHJpYnV0ZXMgPSBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkoe3Blcm06IFswLCAyLCAxLCAzXX0pO1xuXG5jb25zdCBhZGRCaWFzVHJhbnNwb3NlID1cbiAgICAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIHFrdjogVGVuc29yVmlldywgYmlhczogVGVuc29yVmlldywgYmF0Y2hTaXplOiBudW1iZXIsIHNlcXVlbmNlTGVuZ3RoOiBudW1iZXIsXG4gICAgIGhpZGRlblNpemU6IG51bWJlciwgYmlhc09mZnNldDogbnVtYmVyKSA9PiB7XG4gICAgICBjb25zdCBvdXRwdXRTaGFwZSA9IFtiYXRjaFNpemUsIHNlcXVlbmNlTGVuZ3RoLCBoaWRkZW5TaXplXTtcbiAgICAgIGNvbnN0IG91dHB1dFNpemUgPSBTaGFwZVV0aWwuc2l6ZShvdXRwdXRTaGFwZSk7XG4gICAgICBjb25zdCBwcm9ncmFtVW5pZm9ybXM6IFByb2dyYW1Vbmlmb3JtW10gPVxuICAgICAgICAgIFt7dHlwZTogJ3VpbnQzMicsIGRhdGE6IG91dHB1dFNpemV9LCB7dHlwZTogJ3VpbnQzMicsIGRhdGE6IGJpYXNPZmZzZXR9LCB7dHlwZTogJ3VpbnQzMicsIGRhdGE6IGhpZGRlblNpemV9XTtcblxuICAgICAgY29uc3QgZ2V0U2hhZGVyU291cmNlID0gKHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyKSA9PiB7XG4gICAgICAgIGNvbnN0IG91dHB1dCA9IG91dHB1dFZhcmlhYmxlKCdxa3Zfd2l0aF9iaWFzJywgcWt2LmRhdGFUeXBlLCBvdXRwdXRTaGFwZSk7XG4gICAgICAgIGNvbnN0IHFrdklucHV0ID0gaW5wdXRWYXJpYWJsZSgncWt2JywgcWt2LmRhdGFUeXBlLCBvdXRwdXRTaGFwZSk7XG4gICAgICAgIGNvbnN0IGJpYXNJbnB1dCA9IGlucHV0VmFyaWFibGUoJ2JpYXMnLCBiaWFzLmRhdGFUeXBlLCBvdXRwdXRTaGFwZSk7XG5cbiAgICAgICAgY29uc3QgdW5pZm9ybXM6IFVuaWZvcm1zQXJyYXlUeXBlID0gW1xuICAgICAgICAgIHtuYW1lOiAnb3V0cHV0X3NpemUnLCB0eXBlOiAndTMyJ30sIHtuYW1lOiAnYmlhc19vZmZzZXQnLCB0eXBlOiAndTMyJ30sIHtuYW1lOiAnaGlkZGVuX3NpemUnLCB0eXBlOiAndTMyJ31cbiAgICAgICAgXTtcbiAgICAgICAgcmV0dXJuIGBcbiAgJHtzaGFkZXJIZWxwZXIucmVnaXN0ZXJVbmlmb3Jtcyh1bmlmb3JtcykuZGVjbGFyZVZhcmlhYmxlcyhxa3ZJbnB1dCwgYmlhc0lucHV0LCBvdXRwdXQpfVxuICAke3NoYWRlckhlbHBlci5tYWluU3RhcnQoKX1cbiAgICAke3NoYWRlckhlbHBlci5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKCd1bmlmb3Jtcy5vdXRwdXRfc2l6ZScpfVxuICAgIGxldCBiaWFzX29mZnNldF9pZHggPSAoZ2xvYmFsX2lkeCAlIHVuaWZvcm1zLmhpZGRlbl9zaXplKSArIHVuaWZvcm1zLmJpYXNfb2Zmc2V0O1xuXG4gICAgcWt2X3dpdGhfYmlhc1tnbG9iYWxfaWR4XSA9IHFrdltnbG9iYWxfaWR4XSArIGJpYXNbYmlhc19vZmZzZXRfaWR4XTtcbiAgfWA7XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gY29udGV4dC5jb21wdXRlKFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdNdWx0aUhlYWRBdHRlbnRpb25BZGRCaWFzJyxcbiAgICAgICAgICAgIHNoYWRlckNhY2hlOiB7aW5wdXREZXBlbmRlbmNpZXM6IFsndHlwZScsICd0eXBlJ119LFxuICAgICAgICAgICAgZ2V0UnVuRGF0YTogKCkgPT4gKHtcbiAgICAgICAgICAgICAgb3V0cHV0czogW3tkaW1zOiBvdXRwdXRTaGFwZSwgZGF0YVR5cGU6IHFrdi5kYXRhVHlwZSwgZ3B1RGF0YVR5cGU6IEdwdURhdGFUeXBlLmRlZmF1bHR9XSxcbiAgICAgICAgICAgICAgZGlzcGF0Y2hHcm91cDoge3g6IE1hdGguY2VpbChvdXRwdXRTaXplIC8gNjQgLyogd29ya2dyb3VwIHNpemUgKi8pfSxcbiAgICAgICAgICAgICAgcHJvZ3JhbVVuaWZvcm1zXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGdldFNoYWRlclNvdXJjZSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIHtpbnB1dHM6IFtxa3YsIGJpYXNdLCBvdXRwdXRzOiBbLTFdfSlbMF07XG4gICAgfTtcblxuY29uc3QgbWF5YmVUcmFuc3Bvc2VUb0JOU0hBbmRBZGRCaWFzID1cbiAgICAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGJhdGNoU2l6ZTogbnVtYmVyLCBudW1IZWFkczogbnVtYmVyLCBzZXF1ZW5jZUxlbmd0aDogbnVtYmVyLCBoZWFkU2l6ZTogbnVtYmVyLFxuICAgICBpbnB1dDogVGVuc29yVmlldywgYmlhcz86IFRlbnNvclZpZXcsIGJpYXNPZmZzZXQ/OiBudW1iZXIpID0+IHtcbiAgICAgIC8vIGNvbnN0IG5ld0RpbXMgPSBbXTtcblxuICAgICAgbGV0IHJlc2hhcGVkSW5wdXQgPSBpbnB1dDtcbiAgICAgIGlmICghYmlhcykge1xuICAgICAgICBpZiAoaW5wdXQuZGltcy5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgICByZXNoYXBlZElucHV0ID0gaW5wdXQucmVzaGFwZShbYmF0Y2hTaXplLCBzZXF1ZW5jZUxlbmd0aCwgbnVtSGVhZHMsIGhlYWRTaXplXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbnRleHQuY29tcHV0ZShcbiAgICAgICAgICAgIGNyZWF0ZVRyYW5zcG9zZVByb2dyYW1JbmZvKHJlc2hhcGVkSW5wdXQsIHdlaWdodFRyYW5zcG9zZUF0dHJpYnV0ZS5wZXJtKSxcbiAgICAgICAgICAgIHtpbnB1dHM6IFtyZXNoYXBlZElucHV0XSwgb3V0cHV0czogWy0xXX0pWzBdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHNlcXVlbmNlTGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBZGRCaWFzUmVzaGFwZSBpcyBub3QgaW1wbGVtZW50ZWQuIFBsZWFzZSBleHBvcnQgeW91ciBtb2RlbCB3aXRoIHBhY2tlZCBRS1Ygb3IgS1YnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXNoYXBlZElucHV0ID1cbiAgICAgICAgICAgICAgYWRkQmlhc1RyYW5zcG9zZShjb250ZXh0LCBpbnB1dCwgYmlhcywgYmF0Y2hTaXplLCBzZXF1ZW5jZUxlbmd0aCwgbnVtSGVhZHMgKiBoZWFkU2l6ZSwgYmlhc09mZnNldCEpO1xuICAgICAgICAgIHJlc2hhcGVkSW5wdXQgPSByZXNoYXBlZElucHV0LnJlc2hhcGUoW2JhdGNoU2l6ZSwgc2VxdWVuY2VMZW5ndGgsIG51bUhlYWRzLCBoZWFkU2l6ZV0pO1xuICAgICAgICAgIHJldHVybiBjb250ZXh0LmNvbXB1dGUoXG4gICAgICAgICAgICAgIGNyZWF0ZVRyYW5zcG9zZVByb2dyYW1JbmZvKHJlc2hhcGVkSW5wdXQsIHdlaWdodFRyYW5zcG9zZUF0dHJpYnV0ZS5wZXJtKSxcbiAgICAgICAgICAgICAge2lucHV0czogW3Jlc2hhcGVkSW5wdXRdLCBvdXRwdXRzOiBbLTFdfSlbMF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG5leHBvcnQgY29uc3QgbXVsdGlIZWFkQXR0ZW50aW9uID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBBdHRlbnRpb25BdHRycyk6IHZvaWQgPT4ge1xuICBjb25zdCBwYXJhbXMgPSB2YWxpZGF0ZUlucHV0cyhjb250ZXh0LmlucHV0cywgYXR0cmlidXRlcyk7XG5cbiAgaWYgKGNvbnRleHQuaW5wdXRzWzBdLmRpbXMubGVuZ3RoID09PSA1KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdQYWNrZWQgUUtWIGlzIG5vdCBpbXBsZW1lbnRlZCcpO1xuICB9XG5cbiAgaWYgKGNvbnRleHQuaW5wdXRzWzFdPy5kaW1zLmxlbmd0aCA9PT0gNSkge1xuICAgIHRocm93IG5ldyBFcnJvcignUGFja2VkIEtWIGlzIG5vdCBpbXBsZW1lbnRlZCcpO1xuICB9XG5cbiAgLy8gYXBwbHlBdHRlbnRpb24gZXhwZWN0cyBCTlNIIGlucHV0c1xuICBjb25zdCBrdkJOU0ggPSBjb250ZXh0LmlucHV0c1sxXSAmJiBjb250ZXh0LmlucHV0c1syXSAmJiBjb250ZXh0LmlucHV0c1sxXS5kaW1zLmxlbmd0aCA9PT0gNCAmJlxuICAgICAgY29udGV4dC5pbnB1dHNbMl0uZGltcy5sZW5ndGggPT09IDQ7XG5cbiAgY29uc3QgUSA9IG1heWJlVHJhbnNwb3NlVG9CTlNIQW5kQWRkQmlhcyhcbiAgICAgIGNvbnRleHQsIHBhcmFtcy5iYXRjaFNpemUsIHBhcmFtcy5udW1IZWFkcywgcGFyYW1zLnNlcXVlbmNlTGVuZ3RoLCBwYXJhbXMuaGVhZFNpemUsIGNvbnRleHQuaW5wdXRzWzBdLFxuICAgICAgY29udGV4dC5pbnB1dHNbM10sIDApO1xuXG4gIGlmIChrdkJOU0gpIHtcbiAgICByZXR1cm4gYXBwbHlBdHRlbnRpb24oXG4gICAgICAgIGNvbnRleHQsIFEsIGNvbnRleHQuaW5wdXRzWzFdLCBjb250ZXh0LmlucHV0c1syXSwgY29udGV4dC5pbnB1dHNbNF0sIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsXG4gICAgICAgIGNvbnRleHQuaW5wdXRzWzVdLCBwYXJhbXMsIGF0dHJpYnV0ZXMpO1xuICB9XG5cbiAgY29uc3QgSyA9IG1heWJlVHJhbnNwb3NlVG9CTlNIQW5kQWRkQmlhcyhcbiAgICAgIGNvbnRleHQsIHBhcmFtcy5iYXRjaFNpemUsIHBhcmFtcy5udW1IZWFkcywgcGFyYW1zLmt2U2VxdWVuY2VMZW5ndGgsIHBhcmFtcy5oZWFkU2l6ZSwgY29udGV4dC5pbnB1dHNbMV0sXG4gICAgICBjb250ZXh0LmlucHV0c1szXSwgcGFyYW1zLmhpZGRlblNpemUpO1xuXG4gIGNvbnN0IFYgPSBtYXliZVRyYW5zcG9zZVRvQk5TSEFuZEFkZEJpYXMoXG4gICAgICBjb250ZXh0LCBwYXJhbXMuYmF0Y2hTaXplLCBwYXJhbXMubnVtSGVhZHMsIHBhcmFtcy5rdlNlcXVlbmNlTGVuZ3RoLCBwYXJhbXMudkhlYWRTaXplLCBjb250ZXh0LmlucHV0c1syXSxcbiAgICAgIGNvbnRleHQuaW5wdXRzWzNdLCAyICogcGFyYW1zLmhpZGRlblNpemUpO1xuXG4gIGFwcGx5QXR0ZW50aW9uKFxuICAgICAgY29udGV4dCwgUSwgSywgViwgY29udGV4dC5pbnB1dHNbNF0sIHVuZGVmaW5lZCwgY29udGV4dC5pbnB1dHNbNl0sIGNvbnRleHQuaW5wdXRzWzddLCBjb250ZXh0LmlucHV0c1s1XSwgcGFyYW1zLFxuICAgICAgYXR0cmlidXRlcyk7XG59O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge0RhdGFUeXBlLCB0ZW5zb3JEYXRhVHlwZUVudW1Ub1N0cmluZ30gZnJvbSAnLi4vLi4vLi4vd2FzbS1jb21tb24nO1xuaW1wb3J0IHtUZW5zb3JWaWV3fSBmcm9tICcuLi8uLi90ZW5zb3Itdmlldyc7XG5pbXBvcnQge1NoYXBlVXRpbH0gZnJvbSAnLi4vLi4vdXRpbCc7XG5pbXBvcnQge0NvbXB1dGVDb250ZXh0LCBQcm9ncmFtSW5mbywgUHJvZ3JhbUlucHV0VGVuc29ySW5mb0RlcGVuZGVuY3ksIFByb2dyYW1Vbmlmb3JtfSBmcm9tICcuLi90eXBlcyc7XG5cbmltcG9ydCB7Y3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMsIGdldEVsZW1lbnRBdCwgSW5kaWNlc0hlbHBlciwgaW5wdXRWYXJpYWJsZSwgb3V0cHV0VmFyaWFibGUsIFNoYWRlckhlbHBlciwgVW5pZm9ybURhdGFFbGVtZW50VHlwZSwgVW5pZm9ybXNBcnJheVR5cGV9IGZyb20gJy4vY29tbW9uJztcblxuaW50ZXJmYWNlIFBhZEF0dHJpYnV0ZXMge1xuICAvLyAwLWNvbnN0YW50LCAxLXJlZmxlY3QsIDItZWRnZSwgMy13cmFwXG4gIHJlYWRvbmx5IG1vZGU6IG51bWJlcjtcbiAgcmVhZG9ubHkgdmFsdWU6IG51bWJlcjtcbiAgcmVhZG9ubHkgcGFkczogbnVtYmVyW107XG59XG5cbmNvbnN0IHZhbGlkYXRlSW5wdXRzID0gKGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdKTogdm9pZCA9PiB7XG4gIGlmICghaW5wdXRzIHx8IGlucHV0cy5sZW5ndGggPCAxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUb28gZmV3IGlucHV0cycpO1xuICB9XG4gIGlmIChpbnB1dHNbMF0uZGF0YVR5cGUgIT09IERhdGFUeXBlLmZsb2F0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCB0eXBlIG11c3QgYmUgZmxvYXQuJyk7XG4gIH1cblxuICBpZiAoaW5wdXRzLmxlbmd0aCA+PSAyKSB7XG4gICAgbGV0IHZhbGlkUGFkcyA9IGlucHV0c1swXS5kaW1zLmxlbmd0aCAqIDIgPT09IGlucHV0c1sxXS5kaW1zWzBdO1xuICAgIGlmIChpbnB1dHMubGVuZ3RoID09PSA0KSB7XG4gICAgICB2YWxpZFBhZHMgPSBpbnB1dHNbM10uZGltc1swXSAqIDIgPT09IGlucHV0c1sxXS5kaW1zWzBdO1xuICAgIH1cbiAgICBpZiAoIXZhbGlkUGFkcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgcGFkcyBzaG91bGQgYmUgYSAxRCB0ZW5zb3Igb2Ygc2hhcGUgWzIgKiBpbnB1dF9yYW5rXSBvciBbMiAqIG51bV9heGVzXS4nKTtcbiAgICB9XG4gIH1cbn07XG5cbmNvbnN0IGdldFBhZENvbnN0YW50ID0gKG91dHB1dDogSW5kaWNlc0hlbHBlciwgaW5wdXRSYW5rOiBudW1iZXIsIHBhZHNMZW5ndGg6IG51bWJlcik6IHN0cmluZyA9PiB7XG4gIGxldCBibG9jayA9ICcnO1xuICBmb3IgKGxldCBpID0gaW5wdXRSYW5rIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICBibG9jayArPSBgXG4gICAgICAgICAgICBrID0gaTMyKCR7b3V0cHV0LmluZGljZXNHZXQoJ2luZGljZXMnLCBpKX0pIC0gJHtnZXRFbGVtZW50QXQoJ3VuaWZvcm1zLnBhZHMnLCBpLCBwYWRzTGVuZ3RoKX07XG4gICAgICAgICAgICBpZiAoayA8IDApIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoayA+PSBpMzIoJHtnZXRFbGVtZW50QXQoJ3VuaWZvcm1zLnhfc2hhcGUnLCBpLCBpbnB1dFJhbmspfSkpIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvZmZzZXQgKz0gayAqIGkzMigke2dldEVsZW1lbnRBdCgndW5pZm9ybXMueF9zdHJpZGVzJywgaSwgaW5wdXRSYW5rKX0pO1xuICAgICAgICBgO1xuICB9XG5cbiAgcmV0dXJuIGBcbiAgICAgICAgICB2YWx1ZSA9ICR7b3V0cHV0LnR5cGUudmFsdWV9KHVuaWZvcm1zLmNvbnN0YW50X3ZhbHVlKTtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDE7IGkrKykge1xuICAgICAgICAgICAgdmFyIG9mZnNldCA9IDA7XG4gICAgICAgICAgICB2YXIgayA9IDA7XG4gICAgICAgICAgICAke2Jsb2NrfVxuICAgICAgICAgICAgdmFsdWUgPSB4W29mZnNldF07XG4gICAgICAgICAgfVxuICAgICAgYDtcbn07XG5cbmNvbnN0IGdldFBhZFJlZmxlY3QgPSAob3V0cHV0OiBJbmRpY2VzSGVscGVyLCBpbnB1dFJhbms6IG51bWJlciwgcGFkc0xlbmd0aDogbnVtYmVyKTogc3RyaW5nID0+IHtcbiAgbGV0IGJsb2NrID0gJyc7XG4gIGZvciAobGV0IGkgPSBpbnB1dFJhbmsgLSAxOyBpID49IDA7IC0taSkge1xuICAgIGJsb2NrICs9IGBcbiAgICAgICAgICAgICAgICBrID0gaTMyKCR7b3V0cHV0LmluZGljZXNHZXQoJ2luZGljZXMnLCBpKX0pIC0gJHtnZXRFbGVtZW50QXQoJ3VuaWZvcm1zLnBhZHMnLCBpLCBwYWRzTGVuZ3RoKX07XG4gICAgICAgICAgICAgICAgaWYgKGsgPCAwKSB7XG4gICAgICAgICAgICAgICAgICBrID0gLWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIGxldCBfMm5fMSA9IDIgKiAoaTMyKCR7Z2V0RWxlbWVudEF0KCd1bmlmb3Jtcy54X3NoYXBlJywgaSwgaW5wdXRSYW5rKX0pIC0gMSk7XG4gICAgICAgICAgICAgICAgICBrID0gayAlIF8ybl8xO1xuICAgICAgICAgICAgICAgICAgaWYoayA+PSBpMzIoJHtnZXRFbGVtZW50QXQoJ3VuaWZvcm1zLnhfc2hhcGUnLCBpLCBpbnB1dFJhbmspfSkpIHtcbiAgICAgICAgICAgICAgICAgICAgayA9IF8ybl8xIC0gaztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb2Zmc2V0ICs9IGsgKiBpMzIoJHtnZXRFbGVtZW50QXQoJ3VuaWZvcm1zLnhfc3RyaWRlcycsIGksIGlucHV0UmFuayl9KTtcbiAgICAgICAgICAgIGA7XG4gIH1cblxuICByZXR1cm4gYFxuICAgICAgICAgICAgICB2YXIgb2Zmc2V0ID0gMDtcbiAgICAgICAgICAgICAgdmFyIGsgPSAwO1xuICAgICAgICAgICAgICAke2Jsb2NrfVxuICAgICAgICAgICAgICB2YWx1ZSA9IHhbb2Zmc2V0XTtcbiAgICAgICAgICBgO1xufTtcblxuY29uc3QgZ2V0UGFkRWRnZSA9IChvdXRwdXQ6IEluZGljZXNIZWxwZXIsIGlucHV0UmFuazogbnVtYmVyLCBwYWRzTGVuZ3RoOiBudW1iZXIpOiBzdHJpbmcgPT4ge1xuICBsZXQgYmxvY2sgPSAnJztcbiAgZm9yIChsZXQgaSA9IGlucHV0UmFuayAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgYmxvY2sgKz0gYFxuICAgICAgICAgICAgICAgIGsgPSBpMzIoJHtvdXRwdXQuaW5kaWNlc0dldCgnaW5kaWNlcycsIGkpfSkgLSAke2dldEVsZW1lbnRBdCgndW5pZm9ybXMucGFkcycsIGksIHBhZHNMZW5ndGgpfTtcbiAgICAgICAgICAgICAgICBpZiAoayA8IDApIHtcbiAgICAgICAgICAgICAgICAgIGsgPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoayA+PSBpMzIoJHtnZXRFbGVtZW50QXQoJ3VuaWZvcm1zLnhfc2hhcGUnLCBpLCBpbnB1dFJhbmspfSkpIHtcbiAgICAgICAgICAgICAgICAgIGsgPSBpMzIoJHtnZXRFbGVtZW50QXQoJ3VuaWZvcm1zLnhfc2hhcGUnLCBpLCBpbnB1dFJhbmspfSkgLSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvZmZzZXQgKz0gayAqIGkzMigke2dldEVsZW1lbnRBdCgndW5pZm9ybXMueF9zdHJpZGVzJywgaSwgaW5wdXRSYW5rKX0pO1xuICAgICAgICAgICAgYDtcbiAgfVxuXG4gIHJldHVybiBgXG4gICAgICAgICAgICAgIHZhciBvZmZzZXQgPSAwO1xuICAgICAgICAgICAgICB2YXIgayA9IDA7XG4gICAgICAgICAgICAgICR7YmxvY2t9XG4gICAgICAgICAgICAgIHZhbHVlID0geFtvZmZzZXRdO1xuICAgICAgICAgIGA7XG59O1xuXG5jb25zdCBnZXRQYWRXcmFwID0gKG91dHB1dDogSW5kaWNlc0hlbHBlciwgaW5wdXRSYW5rOiBudW1iZXIsIHBhZHNMZW5ndGg6IG51bWJlcik6IHN0cmluZyA9PiB7XG4gIGxldCBibG9jayA9ICcnO1xuICBmb3IgKGxldCBpID0gaW5wdXRSYW5rIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICBibG9jayArPSBgXG4gICAgICAgICAgICAgICAgayA9IGkzMigke291dHB1dC5pbmRpY2VzR2V0KCdpbmRpY2VzJywgaSl9KSAtICR7Z2V0RWxlbWVudEF0KCd1bmlmb3Jtcy5wYWRzJywgaSwgcGFkc0xlbmd0aCl9O1xuICAgICAgICAgICAgICAgIGlmIChrIDwgMCkgIHtcbiAgICAgICAgICAgICAgICAgIGsgKz0gaTMyKCR7Z2V0RWxlbWVudEF0KCd1bmlmb3Jtcy54X3NoYXBlJywgaSwgaW5wdXRSYW5rKX1dKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGsgPj0gaTMyKCR7Z2V0RWxlbWVudEF0KCd1bmlmb3Jtcy54X3NoYXBlJywgaSwgaW5wdXRSYW5rKX0pKSB7XG4gICAgICAgICAgICAgICAgICBrIC09IGkzMigke2dldEVsZW1lbnRBdCgndW5pZm9ybXMueF9zaGFwZScsIGksIGlucHV0UmFuayl9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb2Zmc2V0ICs9IGsgKiBpMzIoJHtnZXRFbGVtZW50QXQoJ3VuaWZvcm1zLnhfc3RyaWRlcycsIGksIGlucHV0UmFuayl9KTtcbiAgICAgICAgICAgIGA7XG4gIH1cblxuICByZXR1cm4gYFxuICAgICAgICAgICAgICB2YXIgb2Zmc2V0ID0gMDtcbiAgICAgICAgICAgICAgdmFyIGsgPSAwO1xuICAgICAgICAgICAgICAke2Jsb2NrfVxuICAgICAgICAgICAgICB2YWx1ZSA9IHhbb2Zmc2V0XTtcbiAgICAgICAgICBgO1xufTtcblxuY29uc3QgZ2V0UGFkU25pcHBldCA9IChvdXRwdXQ6IEluZGljZXNIZWxwZXIsIGlucHV0UmFuazogbnVtYmVyLCBhdHRyaWJ1dGVzOiBQYWRBdHRyaWJ1dGVzKTogc3RyaW5nID0+IHtcbiAgc3dpdGNoIChhdHRyaWJ1dGVzLm1vZGUpIHtcbiAgICBjYXNlIDA6XG4gICAgICByZXR1cm4gZ2V0UGFkQ29uc3RhbnQob3V0cHV0LCBpbnB1dFJhbmssIGF0dHJpYnV0ZXMucGFkcy5sZW5ndGgpO1xuICAgIGNhc2UgMTpcbiAgICAgIHJldHVybiBnZXRQYWRSZWZsZWN0KG91dHB1dCwgaW5wdXRSYW5rLCBhdHRyaWJ1dGVzLnBhZHMubGVuZ3RoKTtcbiAgICBjYXNlIDI6XG4gICAgICByZXR1cm4gZ2V0UGFkRWRnZShvdXRwdXQsIGlucHV0UmFuaywgYXR0cmlidXRlcy5wYWRzLmxlbmd0aCk7XG4gICAgY2FzZSAzOlxuICAgICAgcmV0dXJuIGdldFBhZFdyYXAob3V0cHV0LCBpbnB1dFJhbmssIGF0dHJpYnV0ZXMucGFkcy5sZW5ndGgpO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbW9kZScpO1xuICB9XG59O1xuXG5jb25zdCBjcmVhdGVQYWRQcm9ncmFtSW5mbyA9IChpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSwgYXR0cmlidXRlczogUGFkQXR0cmlidXRlcyk6IFByb2dyYW1JbmZvID0+IHtcbiAgY29uc3Qgb3V0cHV0U2hhcGUgPSBTaGFwZVV0aWwucGFkU2hhcGUoaW5wdXRzWzBdLmRpbXMuc2xpY2UoKSwgYXR0cmlidXRlcy5wYWRzKTtcbiAgY29uc3QgaW5wdXREaW1zID0gaW5wdXRzWzBdLmRpbXM7XG4gIGNvbnN0IG91dHB1dFNpemUgPSBTaGFwZVV0aWwuc2l6ZShvdXRwdXRTaGFwZSk7XG4gIGNvbnN0IHByb2dyYW1Vbmlmb3JtczogUHJvZ3JhbVVuaWZvcm1bXSA9XG4gICAgICBbe3R5cGU6ICd1aW50MzInLCBkYXRhOiBvdXRwdXRTaXplfSwge3R5cGU6ICd1aW50MzInLCBkYXRhOiBhdHRyaWJ1dGVzLnBhZHN9XTtcbiAgaWYgKGF0dHJpYnV0ZXMubW9kZSA9PT0gMCkge1xuICAgIGNvbnN0IHRlbnNvckRhdGFUeXBlID0gdGVuc29yRGF0YVR5cGVFbnVtVG9TdHJpbmcoaW5wdXRzWzBdLmRhdGFUeXBlKSBhcyBQcm9ncmFtVW5pZm9ybVsndHlwZSddO1xuICAgIHByb2dyYW1Vbmlmb3Jtcy5wdXNoKHt0eXBlOiB0ZW5zb3JEYXRhVHlwZSwgZGF0YTogYXR0cmlidXRlcy52YWx1ZX0pO1xuICB9XG5cbiAgcHJvZ3JhbVVuaWZvcm1zLnB1c2goLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMoaW5wdXRzWzBdLmRpbXMpLCAuLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhvdXRwdXRTaGFwZSkpO1xuICBjb25zdCBpbnB1dERlcGVuZGVuY2llczogUHJvZ3JhbUlucHV0VGVuc29ySW5mb0RlcGVuZGVuY3lbXSA9IFsncmFuayddO1xuXG4gIGNvbnN0IGdldFNoYWRlclNvdXJjZSA9IChzaGFkZXJIZWxwZXI6IFNoYWRlckhlbHBlcikgPT4ge1xuICAgIGNvbnN0IG91dHB1dCA9IG91dHB1dFZhcmlhYmxlKCdvdXRwdXQnLCBpbnB1dHNbMF0uZGF0YVR5cGUsIG91dHB1dFNoYXBlLmxlbmd0aCk7XG4gICAgY29uc3QgaW5wdXQgPSBpbnB1dFZhcmlhYmxlKCd4JywgaW5wdXRzWzBdLmRhdGFUeXBlLCBpbnB1dERpbXMubGVuZ3RoKTtcbiAgICBjb25zdCBkYXRhVHlwZSA9IGlucHV0LnR5cGUudmFsdWU7XG4gICAgY29uc3QgcGFkU25pcHBldCA9IGdldFBhZFNuaXBwZXQob3V0cHV0LCBpbnB1dERpbXMubGVuZ3RoLCBhdHRyaWJ1dGVzKTtcbiAgICBjb25zdCB1bmlmb3JtczogVW5pZm9ybXNBcnJheVR5cGUgPVxuICAgICAgICBbe25hbWU6ICdvdXRwdXRfc2l6ZScsIHR5cGU6ICd1MzInfSwge25hbWU6ICdwYWRzJywgdHlwZTogJ2kzMicsIGxlbmd0aDogYXR0cmlidXRlcy5wYWRzLmxlbmd0aH1dO1xuICAgIGlmIChhdHRyaWJ1dGVzLm1vZGUgPT09IDApIHtcbiAgICAgIHVuaWZvcm1zLnB1c2goe25hbWU6ICdjb25zdGFudF92YWx1ZScsIHR5cGU6IGRhdGFUeXBlIGFzIFVuaWZvcm1EYXRhRWxlbWVudFR5cGV9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gYFxuICAgICAgICAgICAgJHtzaGFkZXJIZWxwZXIucmVnaXN0ZXJVbmlmb3Jtcyh1bmlmb3JtcykuZGVjbGFyZVZhcmlhYmxlcyhpbnB1dCwgb3V0cHV0KX1cbiAgICAgICAgICAgICR7c2hhZGVySGVscGVyLm1haW5TdGFydCgpfVxuICAgICAgICAgICAgJHtzaGFkZXJIZWxwZXIuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcygndW5pZm9ybXMub3V0cHV0X3NpemUnKX1cblxuICAgICAgICAgICAgbGV0IGluZGljZXMgPSAke291dHB1dC5vZmZzZXRUb0luZGljZXMoJ2dsb2JhbF9pZHgnKX07XG5cbiAgICAgICAgICAgIHZhciB2YWx1ZSA9ICR7ZGF0YVR5cGV9KDApO1xuICAgICAgICAgICAgJHtwYWRTbmlwcGV0fVxuICAgICAgICAgICAgb3V0cHV0W2dsb2JhbF9pZHhdID0gdmFsdWU7XG4gICAgICAgIH1gO1xuICB9O1xuXG4gIHJldHVybiB7XG4gICAgbmFtZTogJ1BhZCcsXG4gICAgc2hhZGVyQ2FjaGU6IHtoaW50OiBgJHthdHRyaWJ1dGVzLm1vZGV9YCwgaW5wdXREZXBlbmRlbmNpZXN9LFxuICAgIGdldFJ1bkRhdGE6ICgpID0+ICh7XG4gICAgICBvdXRwdXRzOiBbe2RpbXM6IG91dHB1dFNoYXBlLCBkYXRhVHlwZTogaW5wdXRzWzBdLmRhdGFUeXBlfV0sXG4gICAgICBkaXNwYXRjaEdyb3VwOiB7eDogTWF0aC5jZWlsKFNoYXBlVXRpbC5zaXplKG91dHB1dFNoYXBlKSAvIDY0IC8qIHdvcmtncm91cCBzaXplICovKX0sXG4gICAgICBwcm9ncmFtVW5pZm9ybXNcbiAgICB9KSxcbiAgICBnZXRTaGFkZXJTb3VyY2UsXG4gIH07XG59O1xuXG5jb25zdCBjcmVhdGVQYWRBdHRyaWJ1dGVzRnJvbUlucHV0cyA9IChpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSwgYXR0cmlidXRlczogUGFkQXR0cmlidXRlcyk6IFBhZEF0dHJpYnV0ZXMgPT4ge1xuICBpZiAoaW5wdXRzLmxlbmd0aCA+IDEpIHtcbiAgICBjb25zdCBiaWdJbnQ2NFBhZHMgPSBpbnB1dHNbMV0uZ2V0QmlnSW50NjRBcnJheSgpO1xuICAgIGNvbnN0IHZhbHVlID0gKGlucHV0cy5sZW5ndGggPj0gMyAmJiBpbnB1dHNbMl0uZGF0YSkgPyBpbnB1dHNbMl0uZ2V0RmxvYXQzMkFycmF5KClbMF0gOiAwLjA7XG5cbiAgICBjb25zdCBpbnB1dFJhbmsgPSBpbnB1dHNbMF0uZGltcy5sZW5ndGg7XG4gICAgY29uc3QgdXBkYXRlUGFkcyA9IG5ldyBJbnQzMkFycmF5KDIgKiBpbnB1dFJhbmspLmZpbGwoMCk7XG4gICAgaWYgKGlucHV0cy5sZW5ndGggPj0gNCkge1xuICAgICAgY29uc3QgYXhlcyA9IGlucHV0c1szXS5nZXRCaWdJbnQ2NEFycmF5KCk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGF4ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdXBkYXRlUGFkc1tOdW1iZXIoYXhlc1tpXSldID0gTnVtYmVyKGJpZ0ludDY0UGFkc1tpXSk7XG4gICAgICAgIHVwZGF0ZVBhZHNbTnVtYmVyKGF4ZXNbaV0pICsgaW5wdXRSYW5rXSA9IE51bWJlcihiaWdJbnQ2NFBhZHNbaSArIGF4ZXMubGVuZ3RoXSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGJpZ0ludDY0UGFkcy5mb3JFYWNoKCh2LCBpKSA9PiB1cGRhdGVQYWRzW051bWJlcihpKV0gPSAoTnVtYmVyKHYpKSk7XG4gICAgfVxuXG4gICAgY29uc3QgcGFkczogbnVtYmVyW10gPSBbXTtcbiAgICB1cGRhdGVQYWRzLmZvckVhY2godiA9PiBwYWRzLnB1c2godikpO1xuXG4gICAgcmV0dXJuIHttb2RlOiBhdHRyaWJ1dGVzLm1vZGUsIHZhbHVlLCBwYWRzfTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYXR0cmlidXRlcztcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IHBhZCA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogUGFkQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICB2YWxpZGF0ZUlucHV0cyhjb250ZXh0LmlucHV0cyk7XG4gIGNvbnN0IHVwZGF0ZWRBdHRyaWJ1dGVzID0gY3JlYXRlUGFkQXR0cmlidXRlc0Zyb21JbnB1dHMoY29udGV4dC5pbnB1dHMsIGF0dHJpYnV0ZXMpO1xuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlUGFkUHJvZ3JhbUluZm8oY29udGV4dC5pbnB1dHMsIHVwZGF0ZWRBdHRyaWJ1dGVzKSwge2lucHV0czogWzBdfSk7XG59O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge2Vudn0gZnJvbSAnb25ueHJ1bnRpbWUtY29tbW9uJztcblxuaW1wb3J0IHtUZW5zb3JWaWV3fSBmcm9tICcuLi8uLi90ZW5zb3Itdmlldyc7XG5pbXBvcnQge1Bvb2xDb252VXRpbCwgU2hhcGVVdGlsfSBmcm9tICcuLi8uLi91dGlsJztcbmltcG9ydCB7QXR0cmlidXRlV2l0aENhY2hlS2V5fSBmcm9tICcuLi9hdHRyaWJ1dGUtd2l0aC1jYWNoZS1rZXknO1xuaW1wb3J0IHtDb21wdXRlQ29udGV4dCwgUHJvZ3JhbUluZm8sIFByb2dyYW1JbnB1dFRlbnNvckluZm9EZXBlbmRlbmN5LCBQcm9ncmFtVW5pZm9ybX0gZnJvbSAnLi4vdHlwZXMnO1xuXG5pbXBvcnQge2NyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzLCBnZXRFbGVtZW50QXQsIEluZGljZXNIZWxwZXIsIGlucHV0VmFyaWFibGUsIG91dHB1dFZhcmlhYmxlLCBTaGFkZXJIZWxwZXIsIFVuaWZvcm1zQXJyYXlUeXBlfSBmcm9tICcuL2NvbW1vbic7XG5cbi8vIFRPRE86IHN1cHBvcnQ6XG4vLyAtIGNlaWxfbW9kZSAgICAgICAgICAgICAgICAgXCJ0ZXN0X21heHBvb2xfMmRfY2VpbFwiXG4vLyAtIHN0b3JhZ2Vfb3JkZXIgICAgICAgICAgICAgXCJ0ZXN0X21heHBvb2xfd2l0aF9hcmdtYXhfMmRfcHJlY29tcHV0ZWRfc3RyaWRlc1wiXG4vLyAtIFtNYXhQb29sXSBkaWxhdGlvbnMgICAgICAgXCJ0ZXN0X21heHBvb2xfMmRfZGlsYXRpb25zXCJcbi8vIC0gW01heFBvb2xdIG91dHB1dFsxXSAgICAgICBcInRlc3RfbWF4cG9vbF93aXRoX2FyZ21heF8yZF9wcmVjb21wdXRlZF9wYWRzXCJcblxuY29uc3QgdmFsaWRhdGVJbnB1dHMgPSAoaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10pOiB2b2lkID0+IHtcbiAgaWYgKGVudi53ZWJncHUudmFsaWRhdGVJbnB1dENvbnRlbnQgJiYgKCFpbnB1dHMgfHwgaW5wdXRzLmxlbmd0aCAhPT0gMSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Bvb2wgb3BzIHJlcXVpcmVzIDEgaW5wdXQuJyk7XG4gIH1cbn07XG5cbmNvbnN0IGdldEFkanVzdGVkUG9vbEF0dHJpYnV0ZXNBbmRPdXRwdXRTaGFwZSA9IDxBdHRyaWJ1dGVUeXBlIGV4dGVuZHMgQXZlcmFnZVBvb2xBdHRyaWJ1dGVzfE1heFBvb2xBdHRyaWJ1dGVzPihcbiAgICBpbnB1dDogVGVuc29yVmlldywgYXR0cmlidXRlczogQXR0cmlidXRlVHlwZSwgaXNHbG9iYWxPcGVyYXRvcjogYm9vbGVhbik6IFtBdHRyaWJ1dGVUeXBlLCBudW1iZXJbXV0gPT4ge1xuICBjb25zdCBpc0NoYW5uZWxzTGFzdCA9IGF0dHJpYnV0ZXMuZm9ybWF0ID09PSAnTkhXQyc7XG4gIGNvbnN0IGlucHV0U2hhcGVBc0NoYW5uZWxGaXJzdCA9IGlucHV0LmRpbXMuc2xpY2UoKTtcbiAgaWYgKGlzQ2hhbm5lbHNMYXN0KSB7XG4gICAgaW5wdXRTaGFwZUFzQ2hhbm5lbEZpcnN0LnNwbGljZSgxLCAwLCBpbnB1dFNoYXBlQXNDaGFubmVsRmlyc3QucG9wKCkhKTsgIC8vIE1vdmUgY2hhbm5lbCB0byB0aGUgc2Vjb25kIHBvc2l0aW9uLlxuICB9XG4gIGNvbnN0IGhhc0RpbGF0aW9ucyA9IE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKGF0dHJpYnV0ZXMsICdkaWxhdGlvbnMnKTtcbiAgY29uc3Qga2VybmVsU2hhcGUgPSBhdHRyaWJ1dGVzLmtlcm5lbFNoYXBlLnNsaWNlKCk7XG4gIGNvbnN0IHN0cmlkZXMgPSBhdHRyaWJ1dGVzLnN0cmlkZXMuc2xpY2UoKTtcbiAgY29uc3QgZGlsYXRpb25zOiBudW1iZXJbXSA9IGhhc0RpbGF0aW9ucyA/IChhdHRyaWJ1dGVzIGFzIE1heFBvb2xBdHRyaWJ1dGVzKS5kaWxhdGlvbnMuc2xpY2UoKSA6IFtdO1xuICBjb25zdCBwYWRzID0gYXR0cmlidXRlcy5wYWRzLnNsaWNlKCk7XG4gIFBvb2xDb252VXRpbC5hZGp1c3RQb29sQXR0cmlidXRlcyhpc0dsb2JhbE9wZXJhdG9yLCBpbnB1dFNoYXBlQXNDaGFubmVsRmlyc3QsIGtlcm5lbFNoYXBlLCBzdHJpZGVzLCBkaWxhdGlvbnMsIHBhZHMpO1xuXG4gIGNvbnN0IG91dHB1dFNoYXBlQXNDaGFubmVsRmlyc3QgPSBQb29sQ29udlV0aWwuY29tcHV0ZVBvb2xPdXRwdXRTaGFwZShcbiAgICAgIGlzR2xvYmFsT3BlcmF0b3IsIGlucHV0U2hhcGVBc0NoYW5uZWxGaXJzdCwgc3RyaWRlcywgZGlsYXRpb25zLCBrZXJuZWxTaGFwZSwgcGFkcywgYXR0cmlidXRlcy5hdXRvUGFkKTtcblxuICBjb25zdCBuZXdBdHRyaWJ1dGVzID0gT2JqZWN0LmFzc2lnbih7fSwgYXR0cmlidXRlcyk7XG4gIGlmIChoYXNEaWxhdGlvbnMpIHtcbiAgICBPYmplY3QuYXNzaWduKG5ld0F0dHJpYnV0ZXMsIHtrZXJuZWxTaGFwZSwgc3RyaWRlcywgcGFkcywgZGlsYXRpb25zLCBjYWNoZUtleTogYXR0cmlidXRlcy5jYWNoZUtleX0pO1xuICB9IGVsc2Uge1xuICAgIE9iamVjdC5hc3NpZ24obmV3QXR0cmlidXRlcywge2tlcm5lbFNoYXBlLCBzdHJpZGVzLCBwYWRzLCBjYWNoZUtleTogYXR0cmlidXRlcy5jYWNoZUtleX0pO1xuICB9XG4gIGNvbnN0IG91dHB1dFNoYXBlQXNDaGFubmVsTGFzdCA9IG91dHB1dFNoYXBlQXNDaGFubmVsRmlyc3Quc2xpY2UoKTtcbiAgb3V0cHV0U2hhcGVBc0NoYW5uZWxMYXN0LnB1c2gob3V0cHV0U2hhcGVBc0NoYW5uZWxMYXN0LnNwbGljZSgxLCAxKVswXSk7XG4gIHJldHVybiBbbmV3QXR0cmlidXRlcywgaXNDaGFubmVsc0xhc3QgPyBvdXRwdXRTaGFwZUFzQ2hhbm5lbExhc3QgOiBvdXRwdXRTaGFwZUFzQ2hhbm5lbEZpcnN0XTtcbn07XG5cbmNvbnN0IGdldFVuaWZvcm1BbmRQYWRJbmZvID0gPEF0dHJpYnV0ZVR5cGUgZXh0ZW5kcyBBdmVyYWdlUG9vbEF0dHJpYnV0ZXN8TWF4UG9vbEF0dHJpYnV0ZXM+KFxuICAgIG91dHB1dFNoYXBlOiByZWFkb25seSBudW1iZXJbXSxcbiAgICBhdHRyaWJ1dGVzOiBBdHRyaWJ1dGVUeXBlKTogW1Byb2dyYW1Vbmlmb3JtW10sIFVuaWZvcm1zQXJyYXlUeXBlLCBib29sZWFuLCBib29sZWFuLCBib29sZWFuXSA9PiB7XG4gIGNvbnN0IGlzQ2hhbm5lbHNMYXN0ID0gYXR0cmlidXRlcy5mb3JtYXQgPT09ICdOSFdDJztcbiAgY29uc3Qgb3V0cHV0U2l6ZSA9IFNoYXBlVXRpbC5zaXplKG91dHB1dFNoYXBlKTtcbiAgY29uc3Qga2VybmVsU2l6ZSA9IFNoYXBlVXRpbC5zaXplKGF0dHJpYnV0ZXMua2VybmVsU2hhcGUpO1xuICBjb25zdCBwcm9ncmFtVW5pZm9ybXM6IFByb2dyYW1Vbmlmb3JtW10gPSBbe3R5cGU6ICd1aW50MzInLCBkYXRhOiBvdXRwdXRTaXplfSwge3R5cGU6ICd1aW50MzInLCBkYXRhOiBrZXJuZWxTaXplfV07XG4gIGNvbnN0IHVuaWZvcm1zOiBVbmlmb3Jtc0FycmF5VHlwZSA9IFt7bmFtZTogJ291dHB1dFNpemUnLCB0eXBlOiAndTMyJ30sIHtuYW1lOiAna2VybmVsU2l6ZScsIHR5cGU6ICd1MzInfV07XG4gIGlmIChhdHRyaWJ1dGVzLmtlcm5lbFNoYXBlLmxlbmd0aCA8PSAyKSB7XG4gICAgY29uc3Qga3cgPSBhdHRyaWJ1dGVzLmtlcm5lbFNoYXBlW2F0dHJpYnV0ZXMua2VybmVsU2hhcGUubGVuZ3RoIC0gMV07XG4gICAgY29uc3Qgc3cgPSBhdHRyaWJ1dGVzLnN0cmlkZXNbYXR0cmlidXRlcy5zdHJpZGVzLmxlbmd0aCAtIDFdO1xuICAgIGNvbnN0IHB3U3RhcnQgPSBhdHRyaWJ1dGVzLnBhZHNbYXR0cmlidXRlcy5wYWRzLmxlbmd0aCAvIDIgLSAxXTtcbiAgICBjb25zdCBwd0VuZCA9IGF0dHJpYnV0ZXMucGFkc1thdHRyaWJ1dGVzLnBhZHMubGVuZ3RoIC0gMV07XG4gICAgY29uc3QgcHdTdGFydEVuZE5vdFplcm8gPSAhIShwd1N0YXJ0ICsgcHdFbmQpO1xuICAgIHByb2dyYW1Vbmlmb3Jtcy5wdXNoKFxuICAgICAgICB7dHlwZTogJ3VpbnQzMicsIGRhdGE6IGt3fSxcbiAgICAgICAge3R5cGU6ICd1aW50MzInLCBkYXRhOiBzd30sXG4gICAgICAgIHt0eXBlOiAndWludDMyJywgZGF0YTogcHdTdGFydH0sXG4gICAgICAgIHt0eXBlOiAndWludDMyJywgZGF0YTogcHdFbmR9LFxuICAgICk7XG4gICAgdW5pZm9ybXMucHVzaChcbiAgICAgICAge25hbWU6ICdrdycsIHR5cGU6ICd1MzInfSwge25hbWU6ICdzdycsIHR5cGU6ICd1MzInfSwge25hbWU6ICdwd1N0YXJ0JywgdHlwZTogJ3UzMid9LFxuICAgICAgICB7bmFtZTogJ3B3RW5kJywgdHlwZTogJ3UzMid9KTtcblxuICAgIGxldCBwaFN0YXJ0RW5kTm90WmVybyA9IGZhbHNlO1xuICAgIGlmIChhdHRyaWJ1dGVzLmtlcm5lbFNoYXBlLmxlbmd0aCA9PT0gMikge1xuICAgICAgY29uc3Qga2ggPSBhdHRyaWJ1dGVzLmtlcm5lbFNoYXBlW2F0dHJpYnV0ZXMua2VybmVsU2hhcGUubGVuZ3RoIC0gMl07XG4gICAgICBjb25zdCBzaCA9IGF0dHJpYnV0ZXMuc3RyaWRlc1thdHRyaWJ1dGVzLnN0cmlkZXMubGVuZ3RoIC0gMl07XG4gICAgICBjb25zdCBwaFN0YXJ0ID0gYXR0cmlidXRlcy5wYWRzW2F0dHJpYnV0ZXMucGFkcy5sZW5ndGggLyAyIC0gMl07XG4gICAgICBjb25zdCBwaEVuZCA9IGF0dHJpYnV0ZXMucGFkc1thdHRyaWJ1dGVzLnBhZHMubGVuZ3RoIC0gMl07XG4gICAgICBwaFN0YXJ0RW5kTm90WmVybyA9ICEhKHBoU3RhcnQgKyBwaEVuZCk7XG4gICAgICBwcm9ncmFtVW5pZm9ybXMucHVzaChcbiAgICAgICAgICB7dHlwZTogJ3VpbnQzMicsIGRhdGE6IGtofSwge3R5cGU6ICd1aW50MzInLCBkYXRhOiBzaH0sIHt0eXBlOiAndWludDMyJywgZGF0YTogcGhTdGFydH0sXG4gICAgICAgICAge3R5cGU6ICd1aW50MzInLCBkYXRhOiBwaEVuZH0pO1xuXG4gICAgICB1bmlmb3Jtcy5wdXNoKFxuICAgICAgICAgIHtuYW1lOiAna2gnLCB0eXBlOiAndTMyJ30sIHtuYW1lOiAnc2gnLCB0eXBlOiAndTMyJ30sIHtuYW1lOiAncGhTdGFydCcsIHR5cGU6ICd1MzInfSxcbiAgICAgICAgICB7bmFtZTogJ3BoRW5kJywgdHlwZTogJ3UzMid9KTtcbiAgICB9XG4gICAgcmV0dXJuIFtwcm9ncmFtVW5pZm9ybXMsIHVuaWZvcm1zLCB0cnVlLCBwd1N0YXJ0RW5kTm90WmVybywgcGhTdGFydEVuZE5vdFplcm9dO1xuICB9IGVsc2Uge1xuICAgIGlmIChpc0NoYW5uZWxzTGFzdCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdQb29saW5nIHdpdGgga2VybmVsU2hhcGUubGVuZ3RoID4gMiBpcyBub3Qgc3VwcG9ydGVkIGZvciBOSFdDIGZvcm1hdC4nKTtcbiAgICB9XG4gICAgY29uc3Qga2VybmVsU3RyaWRlcyA9IFNoYXBlVXRpbC5jb21wdXRlU3RyaWRlcyhhdHRyaWJ1dGVzLmtlcm5lbFNoYXBlKTtcbiAgICBwcm9ncmFtVW5pZm9ybXMucHVzaChcbiAgICAgICAge3R5cGU6ICd1aW50MzInLCBkYXRhOiBrZXJuZWxTdHJpZGVzfSwge3R5cGU6ICd1aW50MzInLCBkYXRhOiBhdHRyaWJ1dGVzLnBhZHN9LFxuICAgICAgICB7dHlwZTogJ3VpbnQzMicsIGRhdGE6IGF0dHJpYnV0ZXMuc3RyaWRlc30pO1xuICAgIHVuaWZvcm1zLnB1c2goXG4gICAgICAgIHtuYW1lOiAna2VybmVsU3RyaWRlcycsIHR5cGU6ICd1MzInLCBsZW5ndGg6IGtlcm5lbFN0cmlkZXMubGVuZ3RofSxcbiAgICAgICAge25hbWU6ICdwYWRzJywgdHlwZTogJ3UzMicsIGxlbmd0aDogYXR0cmlidXRlcy5wYWRzLmxlbmd0aH0sXG4gICAgICAgIHtuYW1lOiAnc3RyaWRlcycsIHR5cGU6ICd1MzInLCBsZW5ndGg6IGF0dHJpYnV0ZXMuc3RyaWRlcy5sZW5ndGh9KTtcblxuICAgIGNvbnN0IGhhc1BhZHMgPSBhdHRyaWJ1dGVzLnBhZHMucmVkdWNlKChzdW0sIGN1cikgPT4gc3VtICsgY3VyKTtcbiAgICByZXR1cm4gW3Byb2dyYW1Vbmlmb3JtcywgdW5pZm9ybXMsICEhaGFzUGFkcywgZmFsc2UsIGZhbHNlXTtcbiAgfVxufTtcblxuY29uc3QgZ2VuZXJhdGVQb29saW5nQ29kZSA9IDxBdHRyaWJ1dGVUeXBlIGV4dGVuZHMgQXZlcmFnZVBvb2xBdHRyaWJ1dGVzfE1heFBvb2xBdHRyaWJ1dGVzPihcbiAgICBzaGFkZXJIZWxwZXI6IFNoYWRlckhlbHBlciwgeDogSW5kaWNlc0hlbHBlciwgcmFuazogbnVtYmVyLCBvdXRwdXRTaGFwZVJhbms6IG51bWJlciwgYXR0cmlidXRlczogQXR0cmlidXRlVHlwZSxcbiAgICBvcDE6IHN0cmluZywgb3AyOiBzdHJpbmcsIHN0YXJ0OiBudW1iZXIsIHVuaWZvcm1zOiBVbmlmb3Jtc0FycmF5VHlwZSwgaGFzUGFkczogYm9vbGVhbiwgcHdTdGFydEVuZE5vdFplcm86IGJvb2xlYW4sXG4gICAgcGhTdGFydEVuZE5vdFplcm86IGJvb2xlYW4pOiBzdHJpbmcgPT4ge1xuICBjb25zdCBpc0NoYW5uZWxzTGFzdCA9IGF0dHJpYnV0ZXMuZm9ybWF0ID09PSAnTkhXQyc7XG4gIGNvbnN0IGRhdGFUeXBlID0geC50eXBlLnZhbHVlO1xuICBjb25zdCBvdXRwdXQgPSBvdXRwdXRWYXJpYWJsZSgnb3V0cHV0JywgeC50eXBlLnRlbnNvciwgb3V0cHV0U2hhcGVSYW5rKTtcblxuICBpZiAoYXR0cmlidXRlcy5rZXJuZWxTaGFwZS5sZW5ndGggPD0gMikge1xuICAgIGxldCBjb2RlVyA9ICcnO1xuICAgIGxldCBjb2RlSCA9ICcnO1xuICAgIGxldCBjb2RlSEVuZCA9ICcnO1xuICAgIGNvbnN0IGRpbUlkeFcgPSByYW5rIC0gKGlzQ2hhbm5lbHNMYXN0ID8gMiA6IDEpO1xuICAgIGlmIChwd1N0YXJ0RW5kTm90WmVybykge1xuICAgICAgY29kZVcgPSBgXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaTogdTMyID0gMHU7IGkgPCB1bmlmb3Jtcy5rdzsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICB4SW5kaWNlc1ske2RpbUlkeFd9XSA9IGluZGljZXNbJHtkaW1JZHhXfV0gKiB1bmlmb3Jtcy5zdyAtIHVuaWZvcm1zLnB3U3RhcnQgKyBpO1xuICAgICAgICAgICAgICAgICAgaWYgKHhJbmRpY2VzWyR7ZGltSWR4V31dIDwgMCB8fCB4SW5kaWNlc1ske2RpbUlkeFd9XVxuICAgICAgICAgICAgICAgICAgICAgID49IHVuaWZvcm1zLnhfc2hhcGVbJHtkaW1JZHhXfV0pIHtcbiAgICAgICAgICAgICAgICAgICAgcGFkKys7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgbGV0IHhfdmFsID0geFske3guaW5kaWNlc1RvT2Zmc2V0KCd4SW5kaWNlcycpfV07XG4gICAgICAgICAgICAgICAgICAke29wMX1cbiAgICAgICAgICAgICAgICB9YDtcbiAgICB9IGVsc2Uge1xuICAgICAgY29kZVcgPSBgXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaTogdTMyID0gMHU7IGkgPCB1bmlmb3Jtcy5rdzsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICB4SW5kaWNlc1ske2RpbUlkeFd9XSA9IGluZGljZXNbJHtkaW1JZHhXfV0gKiB1bmlmb3Jtcy5zdyAtIHVuaWZvcm1zLnB3U3RhcnQgKyBpO1xuICAgICAgICAgICAgICAgICAgbGV0IHhfdmFsID0geFske3guaW5kaWNlc1RvT2Zmc2V0KCd4SW5kaWNlcycpfV07XG4gICAgICAgICAgICAgICAgICAke29wMX1cbiAgICAgICAgICAgICAgICB9YDtcbiAgICB9XG5cbiAgICBpZiAoYXR0cmlidXRlcy5rZXJuZWxTaGFwZS5sZW5ndGggPT09IDIpIHtcbiAgICAgIGNvbnN0IGRpbUlkeEggPSByYW5rIC0gKGlzQ2hhbm5lbHNMYXN0ID8gMyA6IDIpO1xuICAgICAgaWYgKHBoU3RhcnRFbmROb3RaZXJvKSB7XG4gICAgICAgIGNvZGVIID0gYFxuICAgICAgICAgICAgICAgIGZvciAodmFyIGo6IHUzMiA9IDB1OyBqIDwgdW5pZm9ybXMua2g7IGorKykge1xuICAgICAgICAgICAgICAgICAgeEluZGljZXNbJHtkaW1JZHhIfV0gPSBpbmRpY2VzWyR7ZGltSWR4SH1dICogdW5pZm9ybXMuc2ggLSB1bmlmb3Jtcy5waFN0YXJ0ICsgajtcbiAgICAgICAgICAgICAgICAgIGlmICh4SW5kaWNlc1ske2RpbUlkeEh9XSA8IDAgfHwgeEluZGljZXNbJHtkaW1JZHhIfV0gPj0gdW5pZm9ybXMueF9zaGFwZVske2RpbUlkeEh9XSkge1xuICAgICAgICAgICAgICAgICAgICBwYWQgKz0gaTMyKHVuaWZvcm1zLmt3KTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb2RlSCA9IGBcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqOiB1MzIgPSAwdTsgaiA8IHVuaWZvcm1zLmtoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgIHhJbmRpY2VzWyR7ZGltSWR4SH1dID0gaW5kaWNlc1ske2RpbUlkeEh9XSAqIHVuaWZvcm1zLnNoIC0gdW5pZm9ybXMucGhTdGFydCArIGo7XG4gICAgICAgICAgICAgICAgYDtcbiAgICAgIH1cbiAgICAgIGNvZGVIRW5kID0gYFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBgO1xuICAgIH1cblxuICAgIGNvbnN0IHBvb2xpbmdDb2RlID0gYFxuICAgICAgICAgICAgJHtzaGFkZXJIZWxwZXIucmVnaXN0ZXJVbmlmb3Jtcyh1bmlmb3JtcykuZGVjbGFyZVZhcmlhYmxlcyh4LCBvdXRwdXQpfVxuXG4gICAgICAgICAgICAke3NoYWRlckhlbHBlci5tYWluU3RhcnQoKX1cbiAgICAgICAgICAgICAgJHtzaGFkZXJIZWxwZXIuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcygndW5pZm9ybXMub3V0cHV0U2l6ZScpfVxuXG4gICAgICAgICAgICAgIGxldCBpbmRpY2VzID0gJHtvdXRwdXQub2Zmc2V0VG9JbmRpY2VzKCdnbG9iYWxfaWR4Jyl9O1xuICAgICAgICAgICAgICB2YXIgeEluZGljZXMgPSAke291dHB1dC5vZmZzZXRUb0luZGljZXMoJ2dsb2JhbF9pZHgnKX07XG5cbiAgICAgICAgICAgICAgdmFyIHZhbHVlID0gJHtkYXRhVHlwZX0oJHtzdGFydH0pO1xuICAgICAgICAgICAgICB2YXIgcGFkID0gMDtcbiAgICAgICAgICAgICAgJHtjb2RlSH1cbiAgICAgICAgICAgICAgJHtjb2RlV31cbiAgICAgICAgICAgICAgJHtjb2RlSEVuZH1cbiAgICAgICAgICAgICAgJHtvcDJ9XG5cbiAgICAgICAgICAgICAgb3V0cHV0W2dsb2JhbF9pZHhdID0gdmFsdWU7XG4gICAgICAgICAgICB9YDtcbiAgICByZXR1cm4gcG9vbGluZ0NvZGU7XG4gIH0gZWxzZSB7XG4gICAgaWYgKGlzQ2hhbm5lbHNMYXN0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Bvb2xpbmcgd2l0aCBrZXJuZWxTaGFwZS5sZW5ndGggPiAyIGlzIG5vdCBzdXBwb3J0ZWQgZm9yIE5IV0MgZm9ybWF0LicpO1xuICAgIH1cbiAgICBjb25zdCBzdHJpZGVzUmFuayA9IGF0dHJpYnV0ZXMua2VybmVsU2hhcGUubGVuZ3RoO1xuICAgIGNvbnN0IHBhZHNSYW5rID0gYXR0cmlidXRlcy5wYWRzLmxlbmd0aDtcbiAgICBsZXQgcGFkQ29kZSA9ICcnO1xuICAgIGlmIChoYXNQYWRzKSB7XG4gICAgICBwYWRDb2RlID0gYFxuICAgICAgICAgICAgICAgIGlmICh4SW5kaWNlc1tqXSA+PSB1bmlmb3Jtcy54X3NoYXBlW2pdKSB7XG4gICAgICAgICAgICAgICAgICBwYWQrKztcbiAgICAgICAgICAgICAgICAgIGlzUGFkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoIWlzUGFkKSB7XG4gICAgICAgICAgICAgICAgbGV0IHhfdmFsID0geFske3guaW5kaWNlc1RvT2Zmc2V0KCd4SW5kaWNlcycpfV07XG4gICAgICAgICAgICAgICAgJHtvcDF9XG4gICAgICAgICAgICAgIH1gO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYWRDb2RlID0gYFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGxldCB4X3ZhbCA9IHhbJHt4LmluZGljZXNUb09mZnNldCgneEluZGljZXMnKX1dO1xuICAgICAgICAgICAgICAke29wMX1cbiAgICAgICAgICAgIGA7XG4gICAgfVxuICAgIGNvbnN0IHBvb2xpbmdDb2RlID0gYFxuICAgICAgICAgICAgJHtzaGFkZXJIZWxwZXIucmVnaXN0ZXJVbmlmb3Jtcyh1bmlmb3JtcykuZGVjbGFyZVZhcmlhYmxlcyh4LCBvdXRwdXQpfVxuXG4gICAgICAgICAgICAke3NoYWRlckhlbHBlci5tYWluU3RhcnQoKX1cbiAgICAgICAgICAgICAgJHtzaGFkZXJIZWxwZXIuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcygndW5pZm9ybXMub3V0cHV0U2l6ZScpfVxuICAgICAgICAgICAgICBsZXQgaW5kaWNlcyA9ICR7b3V0cHV0Lm9mZnNldFRvSW5kaWNlcygnZ2xvYmFsX2lkeCcpfTtcbiAgICAgICAgICAgICAgdmFyIHhJbmRpY2VzID0gJHtvdXRwdXQub2Zmc2V0VG9JbmRpY2VzKCdnbG9iYWxfaWR4Jyl9O1xuXG4gICAgICAgICAgICAgIHZhciBvZmZzZXRzOiBhcnJheTx1MzIsICR7c3RyaWRlc1Jhbmt9PjtcblxuICAgICAgICAgICAgICB2YXIgdmFsdWUgPSAke2RhdGFUeXBlfSgke3N0YXJ0fSk7XG4gICAgICAgICAgICAgIHZhciBwYWQgPSAwO1xuICAgICAgICAgICAgICB2YXIgaXNQYWQgPSBmYWxzZTtcblxuICAgICAgICAgICAgICBmb3IgKHZhciBpOiB1MzIgPSAwdTsgaSA8IHVuaWZvcm1zLmtlcm5lbFNpemU7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBvZmZzZXQgPSBpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwdTsgaiA8ICR7c3RyaWRlc1JhbmsgLSAxfXU7IGorKykge1xuICAgICAgICAgICAgICAgICAgb2Zmc2V0c1tqXSA9IG9mZnNldCAvICR7Z2V0RWxlbWVudEF0KCd1bmlmb3Jtcy5rZXJuZWxTdHJpZGVzJywgJ2onLCBzdHJpZGVzUmFuayl9O1xuICAgICAgICAgICAgICAgICAgb2Zmc2V0IC09IG9mZnNldHNbal0gKiAke2dldEVsZW1lbnRBdCgndW5pZm9ybXMua2VybmVsU3RyaWRlcycsICdqJywgc3RyaWRlc1JhbmspfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb2Zmc2V0c1ske3N0cmlkZXNSYW5rIC0gMX1dID0gb2Zmc2V0O1xuXG4gICAgICAgICAgICAgICAgaXNQYWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gJHtyYW5rIC0gc3RyaWRlc1Jhbmt9dTsgaiA8ICR7cmFua311OyBqKyspIHtcbiAgICAgICAgICAgICAgICAgIHhJbmRpY2VzW2pdID0gaW5kaWNlc1tqXSAqICR7XG4gICAgICAgIGdldEVsZW1lbnRBdCgndW5pZm9ybXMuc3RyaWRlcycsIGBqIC0gJHtyYW5rIC0gc3RyaWRlc1Jhbmt9dWAsIHN0cmlkZXNSYW5rKX1cbiAgICAgICAgICAgICAgICAgICAgKyBvZmZzZXRzW2ogLSAke3JhbmsgLSBzdHJpZGVzUmFua311XSAtICR7Z2V0RWxlbWVudEF0KCd1bmlmb3Jtcy5wYWRzJywgJ2ogLSAydScsIHBhZHNSYW5rKX07XG4gICAgICAgICAgICAgICAgICAke3BhZENvZGV9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgJHtvcDJ9XG5cbiAgICAgICAgICAgICAgb3V0cHV0W2dsb2JhbF9pZHhdID0gdmFsdWU7XG4gICAgICAgICAgICB9YDtcbiAgICByZXR1cm4gcG9vbGluZ0NvZGU7XG4gIH1cbn07XG5cbmV4cG9ydCBpbnRlcmZhY2UgRm9ybWF0QXR0cmlidXRlcyB7XG4gIHJlYWRvbmx5IGZvcm1hdDogJ05IV0MnfCdOQ0hXJztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBQb29sQ29tbW9uQXR0cmlidXRlcyBleHRlbmRzIEZvcm1hdEF0dHJpYnV0ZXMge1xuICByZWFkb25seSBhdXRvUGFkOiBzdHJpbmc7XG4gIHJlYWRvbmx5IGNlaWxNb2RlOiBudW1iZXI7XG4gIHJlYWRvbmx5IGtlcm5lbFNoYXBlOiByZWFkb25seSBudW1iZXJbXTtcbiAgcmVhZG9ubHkgc3RyaWRlczogcmVhZG9ubHkgbnVtYmVyW107XG4gIHJlYWRvbmx5IHBhZHM6IHJlYWRvbmx5IG51bWJlcltdO1xufVxuXG5jb25zdCBjcmVhdGVTaGFkZXJLZXlGcm9tQXR0cmlidXRlcyA9IChhdHRyaWJ1dGVzOiBQb29sQ29tbW9uQXR0cmlidXRlcyk6IHN0cmluZyA9PlxuICAgIChgJHthdHRyaWJ1dGVzLmZvcm1hdH07JHthdHRyaWJ1dGVzLmNlaWxNb2RlfTske2F0dHJpYnV0ZXMuYXV0b1BhZH07JHthdHRyaWJ1dGVzLmtlcm5lbFNoYXBlLmxlbmd0aH1gKTtcblxuY29uc3QgY3JlYXRlQXZlcmFnZVBvb2xTaGFkZXJLZXlGcm9tQXR0cmlidXRlcyA9IChhdHRyaWJ1dGVzOiBBdmVyYWdlUG9vbEF0dHJpYnV0ZXMpOiBzdHJpbmcgPT5cbiAgICAoYCR7Y3JlYXRlU2hhZGVyS2V5RnJvbUF0dHJpYnV0ZXMoYXR0cmlidXRlcyl9OyR7YXR0cmlidXRlcy5jb3VudEluY2x1ZGVQYWR9YCk7XG5cbmNvbnN0IGNyZWF0ZU1heFBvb2xTaGFkZXJLZXlGcm9tQXR0cmlidXRlcyA9IChhdHRyaWJ1dGVzOiBNYXhQb29sQXR0cmlidXRlcyk6IHN0cmluZyA9PlxuICAgIChgJHtjcmVhdGVTaGFkZXJLZXlGcm9tQXR0cmlidXRlcyhhdHRyaWJ1dGVzKX07JHthdHRyaWJ1dGVzLnN0b3JhZ2VPcmRlcn07JHthdHRyaWJ1dGVzLmRpbGF0aW9uc31gKTtcblxuY29uc3QgcGFyc2VQb29sQ29tbW9uQXR0cmlidXRlcyA9IChhdHRyaWJ1dGVzOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPik6IFBvb2xDb21tb25BdHRyaWJ1dGVzID0+ICh7XG4gIGZvcm1hdDogYXR0cmlidXRlcy5mb3JtYXQgYXMgRm9ybWF0QXR0cmlidXRlc1snZm9ybWF0J10sXG4gIGF1dG9QYWQ6IFsnTk9UU0VUJywgJ1ZBTElEJywgJ1NBTUVfVVBQRVInLCAnU0FNRV9MT1dFUiddW2F0dHJpYnV0ZXMuYXV0b19wYWQgYXMgbnVtYmVyXSxcbiAgY2VpbE1vZGU6IGF0dHJpYnV0ZXMuY2VpbF9tb2RlIGFzIG51bWJlcixcbiAga2VybmVsU2hhcGU6IGF0dHJpYnV0ZXMua2VybmVsX3NoYXBlIGFzIFtudW1iZXIsIG51bWJlcl0sXG4gIHN0cmlkZXM6IGF0dHJpYnV0ZXMuc3RyaWRlcyBhcyBbbnVtYmVyLCBudW1iZXJdLFxuICBwYWRzOiBhdHRyaWJ1dGVzLnBhZHMgYXMgW251bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlcl1cbn0pO1xuXG5leHBvcnQgaW50ZXJmYWNlIEF2ZXJhZ2VQb29sQXR0cmlidXRlcyBleHRlbmRzIFBvb2xDb21tb25BdHRyaWJ1dGVzLCBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkge1xuICByZWFkb25seSBjb3VudEluY2x1ZGVQYWQ6IGJvb2xlYW47XG59XG5cbmNvbnN0IGNyZWF0ZUF2ZXJhZ2VQb29sUHJvZ3JhbUluZm8gPVxuICAgIChuYW1lOiBzdHJpbmcsIGlucHV0OiBUZW5zb3JWaWV3LCBpc0dsb2JhbE9wZXJhdG9yOiBib29sZWFuLCBhdHRyaWJ1dGVzOiBBdmVyYWdlUG9vbEF0dHJpYnV0ZXMpOiBQcm9ncmFtSW5mbyA9PiB7XG4gICAgICBjb25zdCBbYWRqdXN0ZWRBdHRyaWJ1dGVzLCBvdXRwdXRTaGFwZV0gPVxuICAgICAgICAgIGdldEFkanVzdGVkUG9vbEF0dHJpYnV0ZXNBbmRPdXRwdXRTaGFwZShpbnB1dCwgYXR0cmlidXRlcywgaXNHbG9iYWxPcGVyYXRvcik7XG4gICAgICBjb25zdCB4ID0gaW5wdXRWYXJpYWJsZSgneCcsIGlucHV0LmRhdGFUeXBlLCBpbnB1dC5kaW1zLmxlbmd0aCk7XG4gICAgICBjb25zdCBkYXRhVHlwZSA9IHgudHlwZS52YWx1ZTtcblxuICAgICAgY29uc3Qgb3AxID0gJ3ZhbHVlICs9IHhfdmFsOyc7XG4gICAgICBsZXQgb3AyID0gJyc7XG4gICAgICBpZiAoYWRqdXN0ZWRBdHRyaWJ1dGVzLmNvdW50SW5jbHVkZVBhZCkge1xuICAgICAgICBvcDIgKz0gYHZhbHVlIC89ICR7ZGF0YVR5cGV9KHVuaWZvcm1zLmtlcm5lbFNpemUpO2A7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvcDIgKz0gYHZhbHVlIC89ICR7ZGF0YVR5cGV9KGkzMih1bmlmb3Jtcy5rZXJuZWxTaXplKSAtIHBhZCk7YDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IFtwcm9ncmFtVW5pZm9ybXMsIHVuaWZvcm1zLCBoYXNQYWRzLCBwd1N0YXJ0RW5kTm90WmVybywgcGhTdGFydEVuZE5vdFplcm9dID1cbiAgICAgICAgICBnZXRVbmlmb3JtQW5kUGFkSW5mbyhvdXRwdXRTaGFwZSwgYWRqdXN0ZWRBdHRyaWJ1dGVzKTtcbiAgICAgIHByb2dyYW1Vbmlmb3Jtcy5wdXNoKC4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKGlucHV0LmRpbXMpLCAuLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhvdXRwdXRTaGFwZSkpO1xuICAgICAgY29uc3QgaW5wdXREZXBlbmRlbmNpZXM6IFByb2dyYW1JbnB1dFRlbnNvckluZm9EZXBlbmRlbmN5W10gPSBbJ3JhbmsnXTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5hbWUsXG4gICAgICAgIHNoYWRlckNhY2hlOlxuICAgICAgICAgICAge2hpbnQ6IGAke2F0dHJpYnV0ZXMuY2FjaGVLZXl9OyR7aGFzUGFkc307JHtwd1N0YXJ0RW5kTm90WmVyb307JHtwaFN0YXJ0RW5kTm90WmVyb31gLCBpbnB1dERlcGVuZGVuY2llc30sXG4gICAgICAgIGdldFJ1bkRhdGE6ICgpID0+ICh7XG4gICAgICAgICAgb3V0cHV0czogW3tkaW1zOiBvdXRwdXRTaGFwZSwgZGF0YVR5cGU6IGlucHV0LmRhdGFUeXBlfV0sXG4gICAgICAgICAgZGlzcGF0Y2hHcm91cDoge3g6IE1hdGguY2VpbChTaGFwZVV0aWwuc2l6ZShvdXRwdXRTaGFwZSkgLyA2NCAvKiB3b3JrZ3JvdXAgc2l6ZSAqLyl9LFxuICAgICAgICAgIHByb2dyYW1Vbmlmb3Jtc1xuICAgICAgICB9KSxcbiAgICAgICAgZ2V0U2hhZGVyU291cmNlOiBzaGFkZXJIZWxwZXIgPT4gZ2VuZXJhdGVQb29saW5nQ29kZShcbiAgICAgICAgICAgIHNoYWRlckhlbHBlciwgeCwgaW5wdXQuZGltcy5sZW5ndGgsIG91dHB1dFNoYXBlLmxlbmd0aCwgYWRqdXN0ZWRBdHRyaWJ1dGVzLCBvcDEsIG9wMiwgMC4wLCB1bmlmb3JtcyxcbiAgICAgICAgICAgIGhhc1BhZHMsIHB3U3RhcnRFbmROb3RaZXJvLCBwaFN0YXJ0RW5kTm90WmVybyksXG4gICAgICB9O1xuICAgIH07XG5cbmV4cG9ydCBjb25zdCBwYXJzZUF2ZXJhZ2VQb29sQXR0cmlidXRlcyA9IChhdHRyaWJ1dGVzOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPik6IEF2ZXJhZ2VQb29sQXR0cmlidXRlcyA9PiB7XG4gIGNvbnN0IGNvdW50SW5jbHVkZVBhZCA9IChhdHRyaWJ1dGVzLmNvdW50X2luY2x1ZGVfcGFkIGFzIG51bWJlcikgPT09IDAgPyBmYWxzZSA6IHRydWU7XG5cbiAgY29uc3QgYXR0ciA9IHBhcnNlUG9vbENvbW1vbkF0dHJpYnV0ZXMoYXR0cmlidXRlcyk7XG4gIC8vIFRPRE86IHN1cHBvcnQgYXR0cmlidXRlICdjZWlsX21vZGUnXG4gIGlmIChhdHRyLmNlaWxNb2RlICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCd1c2luZyBjZWlsKCkgaW4gc2hhcGUgY29tcHV0YXRpb24gaXMgbm90IHlldCBzdXBwb3J0ZWQgZm9yIEF2ZXJhZ2VQb29sJyk7XG4gIH1cbiAgY29uc3QgYXZlcmFnZVBvb2xBdHRyaWJ1dGVzID0ge2NvdW50SW5jbHVkZVBhZCwgLi4uYXR0ciwgY2FjaGVLZXk6ICcnfTtcbiAgcmV0dXJuIHsuLi5hdmVyYWdlUG9vbEF0dHJpYnV0ZXMsIGNhY2hlS2V5OiBjcmVhdGVBdmVyYWdlUG9vbFNoYWRlcktleUZyb21BdHRyaWJ1dGVzKGF2ZXJhZ2VQb29sQXR0cmlidXRlcyl9O1xufTtcblxuZXhwb3J0IGNvbnN0IGF2ZXJhZ2VQb29sID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBBdmVyYWdlUG9vbEF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgdmFsaWRhdGVJbnB1dHMoY29udGV4dC5pbnB1dHMpO1xuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlQXZlcmFnZVBvb2xQcm9ncmFtSW5mbygnQXZlcmFnZVBvb2wnLCBjb250ZXh0LmlucHV0c1swXSwgZmFsc2UsIGF0dHJpYnV0ZXMpKTtcbn07XG5cbmNvbnN0IGdsb2JhbFBvb2xBdHRyaWJ1dGVzID0ge1xuICBhdXRvUGFkOiAnJyxcbiAgY2VpbE1vZGU6IDAsXG4gIGNvdW50SW5jbHVkZVBhZDogZmFsc2UsXG4gIGtlcm5lbFNoYXBlOiBbXSxcbiAgc3RyaWRlczogW10sXG4gIHBhZHM6IFtdLFxuICBzdG9yYWdlT3JkZXI6IDAsXG4gIGRpbGF0aW9uczogW11cbn07XG5cbmV4cG9ydCBjb25zdCBwYXJzZUdsb2JhbEF2ZXJhZ2VQb29sQXR0cmlidXRlcyA9IChhdHRyaWJ1dGVzOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPik6IEF2ZXJhZ2VQb29sQXR0cmlidXRlcyA9PiB7XG4gIGNvbnN0IGZvcm1hdCA9IGF0dHJpYnV0ZXMuZm9ybWF0IGFzIEZvcm1hdEF0dHJpYnV0ZXNbJ2Zvcm1hdCddO1xuICByZXR1cm4ge2Zvcm1hdCwgLi4uZ2xvYmFsUG9vbEF0dHJpYnV0ZXMsIGNhY2hlS2V5OiBmb3JtYXR9O1xufTtcblxuZXhwb3J0IGNvbnN0IGdsb2JhbEF2ZXJhZ2VQb29sID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBBdmVyYWdlUG9vbEF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgdmFsaWRhdGVJbnB1dHMoY29udGV4dC5pbnB1dHMpO1xuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlQXZlcmFnZVBvb2xQcm9ncmFtSW5mbygnR2xvYmFsQXZlcmFnZVBvb2wnLCBjb250ZXh0LmlucHV0c1swXSwgdHJ1ZSwgYXR0cmlidXRlcykpO1xufTtcblxuZXhwb3J0IGludGVyZmFjZSBNYXhQb29sQXR0cmlidXRlcyBleHRlbmRzIFBvb2xDb21tb25BdHRyaWJ1dGVzLCBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkge1xuICByZWFkb25seSBzdG9yYWdlT3JkZXI6IG51bWJlcjtcbiAgcmVhZG9ubHkgZGlsYXRpb25zOiBudW1iZXJbXTtcbn1cblxuY29uc3QgY3JlYXRlTWF4UG9vbFByb2dyYW1JbmZvID1cbiAgICAobmFtZTogc3RyaW5nLCBpbnB1dDogVGVuc29yVmlldywgaXNHbG9iYWxPcGVyYXRvcjogYm9vbGVhbiwgYXR0cmlidXRlczogTWF4UG9vbEF0dHJpYnV0ZXMpOiBQcm9ncmFtSW5mbyA9PiB7XG4gICAgICBjb25zdCBbYWRqdXN0ZWRBdHRyaWJ1dGVzLCBvdXRwdXRTaGFwZV0gPVxuICAgICAgICAgIGdldEFkanVzdGVkUG9vbEF0dHJpYnV0ZXNBbmRPdXRwdXRTaGFwZShpbnB1dCwgYXR0cmlidXRlcywgaXNHbG9iYWxPcGVyYXRvcik7XG4gICAgICBjb25zdCBvcDEgPSBgXG4gICAgICB2YWx1ZSA9IG1heCh4X3ZhbCwgdmFsdWUpO1xuICAgIGA7XG4gICAgICBjb25zdCBvcDIgPSAnJztcbiAgICAgIGNvbnN0IHggPSBpbnB1dFZhcmlhYmxlKCd4JywgaW5wdXQuZGF0YVR5cGUsIGlucHV0LmRpbXMubGVuZ3RoKTtcbiAgICAgIGNvbnN0IGlucHV0RGVwZW5kZW5jaWVzOiBQcm9ncmFtSW5wdXRUZW5zb3JJbmZvRGVwZW5kZW5jeVtdID0gWydyYW5rJ107XG4gICAgICBjb25zdCBbcHJvZ3JhbVVuaWZvcm1zLCB1bmlmb3JtcywgaGFzUGFkcywgcHdTdGFydEVuZE5vdFplcm8sIHBoU3RhcnRFbmROb3RaZXJvXSA9XG4gICAgICAgICAgZ2V0VW5pZm9ybUFuZFBhZEluZm8ob3V0cHV0U2hhcGUsIGFkanVzdGVkQXR0cmlidXRlcyk7XG4gICAgICBwcm9ncmFtVW5pZm9ybXMucHVzaCguLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhpbnB1dC5kaW1zKSwgLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMob3V0cHV0U2hhcGUpKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5hbWUsXG4gICAgICAgIHNoYWRlckNhY2hlOlxuICAgICAgICAgICAge2hpbnQ6IGAke2F0dHJpYnV0ZXMuY2FjaGVLZXl9OyR7aGFzUGFkc307JHtwd1N0YXJ0RW5kTm90WmVyb307JHtwaFN0YXJ0RW5kTm90WmVyb31gLCBpbnB1dERlcGVuZGVuY2llc30sXG4gICAgICAgIGdldFJ1bkRhdGE6ICgpID0+ICh7XG4gICAgICAgICAgb3V0cHV0czogW3tkaW1zOiBvdXRwdXRTaGFwZSwgZGF0YVR5cGU6IGlucHV0LmRhdGFUeXBlfV0sXG4gICAgICAgICAgZGlzcGF0Y2hHcm91cDoge3g6IE1hdGguY2VpbChTaGFwZVV0aWwuc2l6ZShvdXRwdXRTaGFwZSkgLyA2NCAvKiB3b3JrZ3JvdXAgc2l6ZSAqLyl9LFxuICAgICAgICAgIHByb2dyYW1Vbmlmb3Jtc1xuICAgICAgICB9KSxcbiAgICAgICAgZ2V0U2hhZGVyU291cmNlOiBzaGFkZXJIZWxwZXIgPT4gZ2VuZXJhdGVQb29saW5nQ29kZShcbiAgICAgICAgICAgIHNoYWRlckhlbHBlciwgeCwgaW5wdXQuZGltcy5sZW5ndGgsIG91dHB1dFNoYXBlLmxlbmd0aCwgYWRqdXN0ZWRBdHRyaWJ1dGVzLCBvcDEsIG9wMiwgLTFlNSwgdW5pZm9ybXMsXG4gICAgICAgICAgICBoYXNQYWRzLCBwd1N0YXJ0RW5kTm90WmVybywgcGhTdGFydEVuZE5vdFplcm8pLFxuICAgICAgfTtcbiAgICB9O1xuXG5leHBvcnQgY29uc3QgbWF4UG9vbCA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogTWF4UG9vbEF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgdmFsaWRhdGVJbnB1dHMoY29udGV4dC5pbnB1dHMpO1xuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlTWF4UG9vbFByb2dyYW1JbmZvKCdNYXhQb29sJywgY29udGV4dC5pbnB1dHNbMF0sIGZhbHNlLCBhdHRyaWJ1dGVzKSk7XG59O1xuXG5leHBvcnQgY29uc3QgcGFyc2VNYXhQb29sQXR0cmlidXRlcyA9IChhdHRyaWJ1dGVzOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPik6IE1heFBvb2xBdHRyaWJ1dGVzID0+IHtcbiAgY29uc3Qgc3RvcmFnZU9yZGVyID0gYXR0cmlidXRlcy5zdG9yYWdlX29yZGVyIGFzIG51bWJlcjtcbiAgY29uc3QgZGlsYXRpb25zID0gYXR0cmlidXRlcy5kaWxhdGlvbnMgYXMgW251bWJlciwgbnVtYmVyXTtcblxuICBjb25zdCBhdHRyID0gcGFyc2VQb29sQ29tbW9uQXR0cmlidXRlcyhhdHRyaWJ1dGVzKTtcbiAgLy8gVE9ETzogc3VwcG9ydCBhdHRyaWJ1dGUgJ2NlaWxfbW9kZScgYW5kICdzdG9yYWdlX29yZGVyJ1xuICBpZiAoc3RvcmFnZU9yZGVyICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjb2x1bW4gbWFqb3Igc3RvcmFnZSBvcmRlciBpcyBub3QgeWV0IHN1cHBvcnRlZCBmb3IgTWF4UG9vbCcpO1xuICB9XG4gIGlmIChhdHRyLmNlaWxNb2RlICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCd1c2luZyBjZWlsKCkgaW4gc2hhcGUgY29tcHV0YXRpb24gaXMgbm90IHlldCBzdXBwb3J0ZWQgZm9yIE1heFBvb2wnKTtcbiAgfVxuICBjb25zdCBtYXhQb29sQXR0cmlidXRlcyA9IHtzdG9yYWdlT3JkZXIsIGRpbGF0aW9ucywgLi4uYXR0ciwgY2FjaGVLZXk6ICcnfTtcbiAgcmV0dXJuIHsuLi5tYXhQb29sQXR0cmlidXRlcywgY2FjaGVLZXk6IGNyZWF0ZU1heFBvb2xTaGFkZXJLZXlGcm9tQXR0cmlidXRlcyhtYXhQb29sQXR0cmlidXRlcyl9O1xufTtcblxuZXhwb3J0IGNvbnN0IHBhcnNlR2xvYmFsTWF4UG9vbEF0dHJpYnV0ZXMgPSAoYXR0cmlidXRlczogUmVjb3JkPHN0cmluZywgdW5rbm93bj4pOiBNYXhQb29sQXR0cmlidXRlcyA9PiB7XG4gIGNvbnN0IGZvcm1hdCA9IGF0dHJpYnV0ZXMuZm9ybWF0IGFzIEZvcm1hdEF0dHJpYnV0ZXNbJ2Zvcm1hdCddO1xuICByZXR1cm4ge2Zvcm1hdCwgLi4uZ2xvYmFsUG9vbEF0dHJpYnV0ZXMsIGNhY2hlS2V5OiBmb3JtYXR9O1xufTtcblxuZXhwb3J0IGNvbnN0IGdsb2JhbE1heFBvb2wgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IE1heFBvb2xBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIHZhbGlkYXRlSW5wdXRzKGNvbnRleHQuaW5wdXRzKTtcbiAgY29udGV4dC5jb21wdXRlKGNyZWF0ZU1heFBvb2xQcm9ncmFtSW5mbygnR2xvYmFsTWF4UG9vbCcsIGNvbnRleHQuaW5wdXRzWzBdLCB0cnVlLCBhdHRyaWJ1dGVzKSk7XG59O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge2Vudn0gZnJvbSAnb25ueHJ1bnRpbWUtY29tbW9uJztcblxuaW1wb3J0IHtEYXRhVHlwZSwgdGVuc29yRGF0YVR5cGVFbnVtVG9TdHJpbmd9IGZyb20gJy4uLy4uLy4uL3dhc20tY29tbW9uJztcbmltcG9ydCB7Q29tcHV0ZUNvbnRleHQsIFByb2dyYW1JbmZvLCBQcm9ncmFtVW5pZm9ybX0gZnJvbSAnLi4vdHlwZXMnO1xuXG5pbXBvcnQge2NyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzLCBvdXRwdXRWYXJpYWJsZSwgU2hhZGVySGVscGVyLCBVbmlmb3JtRGF0YUVsZW1lbnRUeXBlLCBVbmlmb3Jtc0FycmF5VHlwZX0gZnJvbSAnLi9jb21tb24nO1xuXG5jb25zdCB2YWxpZGF0ZUlucHV0c0NvbnRlbnQgPSAoc3RhcnQ6IG51bWJlciwgbGltaXQ6IG51bWJlciwgZGVsdGE6IG51bWJlcik6IHZvaWQgPT4ge1xuICBjb25zdCBzYW1lU3RhcnRMaW1pdCA9IHN0YXJ0ID09PSBsaW1pdDtcbiAgY29uc3QgaW5jcmVhc2luZ1JhbmdlTmVnYXRpdmVTdGVwID0gc3RhcnQgPCBsaW1pdCAmJiBkZWx0YSA8IDA7XG4gIGNvbnN0IGRlY3JlYXNpbmdSYW5nZVBvc2l0aXZlU3RlcCA9IHN0YXJ0ID4gbGltaXQgJiYgZGVsdGEgPiAwO1xuXG4gIGlmIChzYW1lU3RhcnRMaW1pdCB8fCBpbmNyZWFzaW5nUmFuZ2VOZWdhdGl2ZVN0ZXAgfHwgZGVjcmVhc2luZ1JhbmdlUG9zaXRpdmVTdGVwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdSYW5nZSB0aGVzZSBpbnB1dHNcXCcgY29udGVudHMgYXJlIGludmFsaWQuJyk7XG4gIH1cbn07XG5cbmNvbnN0IGNyZWF0ZVJhbmdlUHJvZ3JhbUluZm8gPSAoc3RhcnQ6IG51bWJlciwgbGltaXQ6IG51bWJlciwgZGVsdGE6IG51bWJlciwgZGF0YVR5cGU6IERhdGFUeXBlKTogUHJvZ3JhbUluZm8gPT4ge1xuICBjb25zdCBudW1FbGVtZW50cyA9IE1hdGguYWJzKE1hdGguY2VpbCgobGltaXQgLSBzdGFydCkgLyBkZWx0YSkpO1xuICBjb25zdCBvdXRwdXRTaGFwZTogbnVtYmVyW10gPSBbbnVtRWxlbWVudHNdO1xuICBjb25zdCBvdXRwdXRTaXplID0gbnVtRWxlbWVudHM7XG4gIGNvbnN0IHRlbnNvckRhdGFUeXBlID0gdGVuc29yRGF0YVR5cGVFbnVtVG9TdHJpbmcoZGF0YVR5cGUpIGFzIFByb2dyYW1Vbmlmb3JtWyd0eXBlJ107XG4gIGNvbnN0IHByb2dyYW1Vbmlmb3JtczogUHJvZ3JhbVVuaWZvcm1bXSA9IFtcbiAgICB7dHlwZTogJ3VpbnQzMicsIGRhdGE6IG91dHB1dFNpemV9LCB7dHlwZTogdGVuc29yRGF0YVR5cGUsIGRhdGE6IHN0YXJ0fSwge3R5cGU6IHRlbnNvckRhdGFUeXBlLCBkYXRhOiBkZWx0YX0sXG4gICAgLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMob3V0cHV0U2hhcGUpXG4gIF07XG5cbiAgY29uc3QgZ2V0U2hhZGVyU291cmNlID0gKHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyKSA9PiB7XG4gICAgY29uc3Qgb3V0cHV0ID0gb3V0cHV0VmFyaWFibGUoJ291dHB1dCcsIGRhdGFUeXBlLCBvdXRwdXRTaGFwZS5sZW5ndGgpO1xuICAgIGNvbnN0IHdnc2xUeXBlID0gb3V0cHV0LnR5cGUudmFsdWU7XG4gICAgY29uc3QgdW5pZm9ybXM6IFVuaWZvcm1zQXJyYXlUeXBlID0gW1xuICAgICAge25hbWU6ICdvdXRwdXRTaXplJywgdHlwZTogJ3UzMid9LCB7bmFtZTogJ3N0YXJ0JywgdHlwZTogd2dzbFR5cGUgYXMgVW5pZm9ybURhdGFFbGVtZW50VHlwZX0sXG4gICAgICB7bmFtZTogJ2RlbHRhJywgdHlwZTogd2dzbFR5cGUgYXMgVW5pZm9ybURhdGFFbGVtZW50VHlwZX1cbiAgICBdO1xuICAgIHJldHVybiBgXG4gICAgICAgICR7c2hhZGVySGVscGVyLnJlZ2lzdGVyVW5pZm9ybXModW5pZm9ybXMpLmRlY2xhcmVWYXJpYWJsZXMob3V0cHV0KX1cbiAgICAgICAgJHtzaGFkZXJIZWxwZXIubWFpblN0YXJ0KCl9XG4gICAgICAgICR7c2hhZGVySGVscGVyLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoJ3VuaWZvcm1zLm91dHB1dFNpemUnKX1cbiAgICAgICAgb3V0cHV0W2dsb2JhbF9pZHhdID0gdW5pZm9ybXMuc3RhcnQgKyAke3dnc2xUeXBlfShnbG9iYWxfaWR4KSAqIHVuaWZvcm1zLmRlbHRhO1xuICAgICAgfWA7XG4gIH07XG5cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiAnUmFuZ2UnLFxuICAgIHNoYWRlckNhY2hlOiB7aGludDogYCR7ZGF0YVR5cGV9YH0sXG4gICAgZ2V0U2hhZGVyU291cmNlLFxuICAgIGdldFJ1bkRhdGE6ICgpID0+ICh7XG4gICAgICBvdXRwdXRzOiBbe2RpbXM6IG91dHB1dFNoYXBlLCBkYXRhVHlwZX1dLFxuICAgICAgZGlzcGF0Y2hHcm91cDoge3g6IE1hdGguY2VpbChvdXRwdXRTaXplIC8gNjQgLyogd29ya2dyb3VwIHNpemUgKi8pfSxcbiAgICAgIHByb2dyYW1Vbmlmb3Jtc1xuICAgIH0pXG4gIH07XG59O1xuXG5leHBvcnQgY29uc3QgcmFuZ2UgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQpOiB2b2lkID0+IHtcbiAgbGV0IHN0YXJ0ID0gMDtcbiAgbGV0IGxpbWl0ID0gMDtcbiAgbGV0IGRlbHRhID0gMDtcbiAgaWYgKGNvbnRleHQuaW5wdXRzWzBdLmRhdGFUeXBlID09PSBEYXRhVHlwZS5pbnQzMikge1xuICAgIHN0YXJ0ID0gY29udGV4dC5pbnB1dHNbMF0uZ2V0SW50MzJBcnJheSgpWzBdO1xuICAgIGxpbWl0ID0gY29udGV4dC5pbnB1dHNbMV0uZ2V0SW50MzJBcnJheSgpWzBdO1xuICAgIGRlbHRhID0gY29udGV4dC5pbnB1dHNbMl0uZ2V0SW50MzJBcnJheSgpWzBdO1xuICB9IGVsc2UgaWYgKGNvbnRleHQuaW5wdXRzWzBdLmRhdGFUeXBlID09PSBEYXRhVHlwZS5mbG9hdCkge1xuICAgIHN0YXJ0ID0gY29udGV4dC5pbnB1dHNbMF0uZ2V0RmxvYXQzMkFycmF5KClbMF07XG4gICAgbGltaXQgPSBjb250ZXh0LmlucHV0c1sxXS5nZXRGbG9hdDMyQXJyYXkoKVswXTtcbiAgICBkZWx0YSA9IGNvbnRleHQuaW5wdXRzWzJdLmdldEZsb2F0MzJBcnJheSgpWzBdO1xuICB9XG4gIGlmIChlbnYud2ViZ3B1LnZhbGlkYXRlSW5wdXRDb250ZW50KSB7XG4gICAgdmFsaWRhdGVJbnB1dHNDb250ZW50KHN0YXJ0LCBsaW1pdCwgZGVsdGEpO1xuICB9XG5cbiAgY29udGV4dC5jb21wdXRlKGNyZWF0ZVJhbmdlUHJvZ3JhbUluZm8oc3RhcnQsIGxpbWl0LCBkZWx0YSwgY29udGV4dC5pbnB1dHNbMF0uZGF0YVR5cGUpLCB7aW5wdXRzOiBbXX0pO1xufTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuXG5pbXBvcnQge1RlbnNvclZpZXd9IGZyb20gJy4uLy4uL3RlbnNvci12aWV3JztcbmltcG9ydCB7U2hhcGVVdGlsfSBmcm9tICcuLi8uLi91dGlsJztcbmltcG9ydCB7QXR0cmlidXRlV2l0aENhY2hlS2V5LCBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXl9IGZyb20gJy4uL2F0dHJpYnV0ZS13aXRoLWNhY2hlLWtleSc7XG5pbXBvcnQge0NvbXB1dGVDb250ZXh0LCBQcm9ncmFtSW5mb30gZnJvbSAnLi4vdHlwZXMnO1xuXG5pbXBvcnQge2NyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzLCBnZXRFbGVtZW50QXQsIEluZGljZXNIZWxwZXIsIGlucHV0VmFyaWFibGUsIG91dHB1dFZhcmlhYmxlLCBTaGFkZXJIZWxwZXJ9IGZyb20gJy4vY29tbW9uJztcblxudHlwZSBDb29yZGluYXRlVHJhbnNmb3JtTW9kZSA9ICdoYWxmX3BpeGVsJ3wnYXN5bW1ldHJpYyd8J3B5dG9yY2hfaGFsZl9waXhlbCd8J3RmX2hhbGZfcGl4ZWxfZm9yX25uJ3wnYWxpZ25fY29ybmVycyd8XG4gICAgJ3RmX2Nyb3BfYW5kX3Jlc2l6ZSd8J2hhbGZfcGl4ZWxfc3ltbWV0cmljJztcblxudHlwZSBLZWVwQXNwZWN0UmF0aW9Qb2xpY3kgPSAnc3RyZXRjaCd8J25vdF9zbWFsbGVyJ3wnbm90X2xhcmdlcic7XG5cbnR5cGUgTW9kZSA9ICduZWFyZXN0J3wnbGluZWFyJ3wnY3ViaWMnO1xuXG50eXBlIE5lYXJlc3RNb2RlID0gJ3JvdW5kX3ByZWZlcl9mbG9vcid8J3JvdW5kX3ByZWZlcl9jZWlsJ3wnZmxvb3InfCdjZWlsJ3wnc2ltcGxlJztcblxuZXhwb3J0IGludGVyZmFjZSBSZXNpemVBdHRyaWJ1dGVzIGV4dGVuZHMgQXR0cmlidXRlV2l0aENhY2hlS2V5IHtcbiAgYW50aWFsaWFzOiBudW1iZXI7XG4gIGF4ZXM6IG51bWJlcltdO1xuICBjb29yZGluYXRlVHJhbnNmb3JtTW9kZTogQ29vcmRpbmF0ZVRyYW5zZm9ybU1vZGU7XG4gIGN1YmljQ29lZmZBOiBudW1iZXI7XG4gIGV4Y2x1ZGVPdXRzaWRlOiBib29sZWFuO1xuICBleHRyYXBvbGF0aW9uVmFsdWU6IG51bWJlcjtcbiAga2VlcEFzcGVjdFJhdGlvUG9saWN5OiBLZWVwQXNwZWN0UmF0aW9Qb2xpY3k7XG4gIG1vZGU6IE1vZGU7XG4gIG5lYXJlc3RNb2RlOiBOZWFyZXN0TW9kZTtcbn1cblxuY29uc3QgdmFsaWRhdGVTY2FsZXMgPSAoc2NhbGVzOiBudW1iZXJbXSwgYXR0cmlidXRlczogUmVzaXplQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICBzY2FsZXMuZXZlcnkoKHZhbHVlKSA9PiB2YWx1ZSA+IDAgfHwgKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Jlc2l6ZSByZXF1aXJlcyBzY2FsZXMgaW5wdXQgdmFsdWVzIHRvIGJlIHBvc2l0aXZlJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgLy8gQ2hlY2sgc2NhbGVzIGRpbXMgYmFzZWQgb24gbW9kZTogTElORUFSLCBDVUJJQ1xuICBpZiAoc2NhbGVzLmxlbmd0aCA+IDApIHtcbiAgICBpZiAoYXR0cmlidXRlcy5tb2RlID09PSAnbGluZWFyJykge1xuICAgICAgaWYgKCEoc2NhbGVzLmxlbmd0aCA9PT0gMiB8fCBzY2FsZXMubGVuZ3RoID09PSAzIHx8IChzY2FsZXMubGVuZ3RoID09PSA0ICYmIHNjYWxlc1swXSA9PT0gMSAmJiBzY2FsZXNbMV0gPT09IDEpIHx8XG4gICAgICAgICAgICAoc2NhbGVzLmxlbmd0aCA9PT0gNCAmJiBzY2FsZXNbMF0gPT09IDEgJiYgc2NhbGVzWzNdID09PSAxKSB8fFxuICAgICAgICAgICAgKHNjYWxlcy5sZW5ndGggPT09IDUgJiYgc2NhbGVzWzBdID09PSAxICYmIHNjYWxlc1sxXSA9PT0gMSkpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGBGb3IgbGluZWFyIG1vZGUsIFJlc2l6ZSByZXF1aXJlcyBzY2FsZXMgdG8gYmUgMkQsIDNELCA0RCB3aXRoIGVpdGhlciB0d28gb3V0ZXJtb3N0IG9yIG9uZSBpbm5lcm1vc3QgYW5kXG4gICAgICAgICAgICBvbmUgb3V0ZXJtb3N0IHNjYWxlIHZhbHVlcyBlcXVhbCB0byAxLCBvciA1RCB3aXRoIHR3byBvdXRlcm1vc3Qgc2NhbGUgdmFsdWVzIGVxdWFsIHRvIDFgKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGF0dHJpYnV0ZXMubW9kZSA9PT0gJ2N1YmljJykge1xuICAgICAgaWYgKCEoc2NhbGVzLmxlbmd0aCA9PT0gMiB8fCAoc2NhbGVzLmxlbmd0aCA9PT0gNCAmJiBzY2FsZXNbMF0gPT09IDEgJiYgc2NhbGVzWzFdID09PSAxKSB8fFxuICAgICAgICAgICAgKHNjYWxlcy5sZW5ndGggPT09IDQgJiYgc2NhbGVzWzBdID09PSAxICYmIHNjYWxlc1szXSA9PT0gMSkpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUmVzaXplIHJlcXVpcmVzIHNjYWxlcyBpbnB1dCBzaXplIHRvIGJlIDIgb3IgNCBmb3IgY3ViaWMgbW9kZScpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuY29uc3QgdXBkYXRlU2NhbGVzID0gKHNjYWxlczogcmVhZG9ubHkgbnVtYmVyW10sIGF4ZXM6IHJlYWRvbmx5IG51bWJlcltdLCByYW5rOiBudW1iZXIpOiBudW1iZXJbXSA9PiB7XG4gIGF4ZXMuZXZlcnkoKHZhbHVlKSA9PiB2YWx1ZSA+PSAwICYmIHZhbHVlIDwgcmFuayB8fCAoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Jlc2l6ZSByZXF1aXJlcyBheGVzIGlucHV0IHZhbHVlcyB0byBiZSBwb3NpdGl2ZSBhbmQgbGVzcyB0aGFuIHJhbmsnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgY29uc3QgbmV3U2NhbGVzID0gbmV3IEFycmF5KHJhbmspLmZpbGwoMS4wKTtcbiAgYXhlcy5mb3JFYWNoKCh2YWx1ZSwgaW5kZXgpID0+IG5ld1NjYWxlc1t2YWx1ZV0gPSBzY2FsZXNbaW5kZXhdKTtcbiAgcmV0dXJuIG5ld1NjYWxlcztcbn07XG5cbmNvbnN0IHZhbGlkYXRlSW5wdXRzID1cbiAgICAoaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10sIGF0dHJpYnV0ZXM6IFJlc2l6ZUF0dHJpYnV0ZXMsIG9wc2V0VmVyc2lvbjogbnVtYmVyLCBzY2FsZXM6IG51bWJlcltdLFxuICAgICBzaXplczogbnVtYmVyW10sIHJvaTogbnVtYmVyW10pOiB2b2lkID0+IHtcbiAgICAgIGNvbnN0IFtyb2lJbnB1dEluZGV4LCBzY2FsZXNJbnB1dEluZGV4LCBzaXplc0lucHV0SW5kZXhdID1cbiAgICAgICAgICAob3BzZXRWZXJzaW9uID4gMTApID8gWzEsIDIsIDNdIDogWy0xLCAoaW5wdXRzLmxlbmd0aCA+IDEpID8gMSA6IC0xLCAtMV07XG4gICAgICBjb25zdCByYW5rID0gaW5wdXRzWzBdLmRpbXMubGVuZ3RoO1xuICAgICAgaWYgKHJvaUlucHV0SW5kZXggPiAwICYmIGlucHV0cy5sZW5ndGggPiByb2lJbnB1dEluZGV4ICYmIGlucHV0c1tyb2lJbnB1dEluZGV4XS5kaW1zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgaW5wdXRzW3JvaUlucHV0SW5kZXhdLmdldEZsb2F0MzJBcnJheSgpLmZvckVhY2goKHZhbHVlKSA9PiByb2kucHVzaCh2YWx1ZSkpO1xuICAgICAgfSBlbHNlIGlmIChhdHRyaWJ1dGVzLmNvb3JkaW5hdGVUcmFuc2Zvcm1Nb2RlID09PSAndGZfY3JvcF9hbmRfcmVzaXplJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Jlc2l6ZSByZXF1aXJlcyBSb0kgaW5wdXQgdG8gYmUgc3BlY2lmaWVkIHdoZW4gY29vcmRpbmF0ZVRyYW5zZm9ybU1vZGUgaXMgdGZDcm9wQW5kUmVzaXplJyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzY2FsZXNJbnB1dEluZGV4ID4gMCAmJiBpbnB1dHMubGVuZ3RoID4gc2NhbGVzSW5wdXRJbmRleCAmJiBpbnB1dHNbc2NhbGVzSW5wdXRJbmRleF0uZGltcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGlucHV0c1tzY2FsZXNJbnB1dEluZGV4XS5nZXRGbG9hdDMyQXJyYXkoKS5mb3JFYWNoKCh2YWx1ZSkgPT4gc2NhbGVzLnB1c2godmFsdWUpKTtcbiAgICAgICAgaWYgKHNjYWxlcy5sZW5ndGggIT09IDAgJiZcbiAgICAgICAgICAgIChzY2FsZXMubGVuZ3RoICE9PSByYW5rICYmIChvcHNldFZlcnNpb24gPj0gMTggJiYgc2NhbGVzLmxlbmd0aCAhPT0gYXR0cmlidXRlcy5heGVzLmxlbmd0aCkpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAnUmVzaXplIHJlcXVpcmVzIHNjYWxlcyBpbnB1dCBzaXplIHRvIGJlIHNhbWUgYXMgaW5wdXQgcmFuayBvciBheGVzIHNpemUgZm9yIG9wc2V0IDE4IGFuZCB1cCcpO1xuICAgICAgICB9XG4gICAgICAgIHZhbGlkYXRlU2NhbGVzKHNjYWxlcywgYXR0cmlidXRlcyk7XG4gICAgICAgIGlmIChhdHRyaWJ1dGVzLmF4ZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHVwZGF0ZVNjYWxlcyhzY2FsZXMsIGF0dHJpYnV0ZXMuYXhlcywgcmFuaykuZm9yRWFjaCgodmFsdWUsIGluZGV4KSA9PiBzY2FsZXNbaW5kZXhdID0gdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoc2l6ZXNJbnB1dEluZGV4ID4gMCAmJiBpbnB1dHMubGVuZ3RoID4gc2l6ZXNJbnB1dEluZGV4KSB7XG4gICAgICAgIGlucHV0c1tzaXplc0lucHV0SW5kZXhdLmdldEJpZ0ludDY0QXJyYXkoKS5mb3JFYWNoKCh2YWx1ZSkgPT4gc2l6ZXMucHVzaChOdW1iZXIodmFsdWUpKSk7XG4gICAgICAgIGlmIChzaXplcy5sZW5ndGggIT09IHJhbmsgfHwgKG9wc2V0VmVyc2lvbiA+PSAxOCAmJiBzaXplcy5sZW5ndGggPT09IGF0dHJpYnV0ZXMuYXhlcy5sZW5ndGgpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZXNpemUgcmVxdWlyZXMgc2l6ZXMgaW5wdXQgc2l6ZSB0byBiZSBzYW1lIGFzIGlucHV0IHJhbmsgb3IgYXhlcyBzaXplIGZvciBvcHNldCAxOCBhbmQgdXAnKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoYXR0cmlidXRlcy5heGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgaWYgKHNjYWxlcy5sZW5ndGggIT09IGF0dHJpYnV0ZXMuYXhlcy5sZW5ndGgpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Jlc2l6ZSByZXF1aXJlcyBcInNjYWxlc1wiIGlucHV0IHNpemUgdG8gYmUgb2YgYXhlcyByYW5rIHdoZW4gYXhlcyBhdHRyaWJ1dGVzIGlzIHNwZWNpZmllZCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzaXplcy5sZW5ndGggIT09IGF0dHJpYnV0ZXMuYXhlcy5sZW5ndGgpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICdSZXNpemUgcmVxdWlyZXMgXCJzaXplc1wiIGlucHV0IHNpemUgdG8gYmUgb2YgcmFuayBheGVzIHJhbmsgd2hlbiBheGVzIGF0dHJpYnV0ZXMgaXMgc3BlY2lmaWVkJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2Ygc2NhbGVzICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygc2l6ZXMgIT09ICd1bmRlZmluZWQnICYmIHNjYWxlcy5sZW5ndGggPiAwICYmIHNpemVzLmxlbmd0aCA+IHJhbmspIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZXNpemUgcmVxdWlyZXMgb25seSBvZiBzY2FsZXMgb3Igc2l6ZXMgdG8gYmUgc3BlY2lmaWVkJyk7XG4gICAgICB9XG4gICAgfTtcblxuY29uc3QgZ2V0T3JpZ2luYWxDb29yZGluYXRlRnJvbVJlc2l6ZWRDb29yZGluYXRlID1cbiAgICAoY29vcmRpbmF0ZVRyYW5zZmVyTW9kZTogQ29vcmRpbmF0ZVRyYW5zZm9ybU1vZGUsIGRUeXBlOiBzdHJpbmcpOiBzdHJpbmcgPT5cbiAgICAgICAgYGZuIGdldE9yaWdpbmFsQ29vcmRpbmF0ZUZyb21SZXNpemVkQ29vcmRpbmF0ZSh4UmVzaXplZDogdTMyLCB4U2NhbGU6IGYzMiwgbGVuZ3RoUmVzaXplZDogdTMyLFxuICAgICBsZW5ndGhPcmlnaW5hbDogdTMyLCByb2lTdGFydDogZjMyLCByb2lFbmQ6IGYzMikgLT4gJHtkVHlwZX0geyBgICtcbiAgICAoKCkgPT4ge1xuICAgICAgICAgIHN3aXRjaCAoY29vcmRpbmF0ZVRyYW5zZmVyTW9kZSkge1xuICAgICAgICAgICAgY2FzZSAnYXN5bW1ldHJpYyc6XG4gICAgICAgICAgICAgIHJldHVybiBgcmV0dXJuICR7ZFR5cGV9KHhSZXNpemVkKSAvICR7ZFR5cGV9KHhTY2FsZSk7YDtcbiAgICAgICAgICAgIGNhc2UgJ3B5dG9yY2hfaGFsZl9waXhlbCc6XG4gICAgICAgICAgICAgIHJldHVybiBgaWYgKGxlbmd0aFJlc2l6ZWQgPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoJHtkVHlwZX0oeFJlc2l6ZWQpICsgMC41KSAvICR7ZFR5cGV9KHhTY2FsZSkgLSAwLjU7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMC4wO1xuICAgICAgICAgICAgICAgICAgfWA7XG4gICAgICAgICAgICBjYXNlICd0Zl9oYWxmX3BpeGVsX2Zvcl9ubic6XG4gICAgICAgICAgICAgIHJldHVybiBgcmV0dXJuICgke2RUeXBlfSh4UmVzaXplZCkgKyAwLjUpIC8gJHtkVHlwZX0oeFNjYWxlKTtgO1xuICAgICAgICAgICAgY2FzZSAnYWxpZ25fY29ybmVycyc6XG4gICAgICAgICAgICAgIHJldHVybiBgaWYgKGxlbmd0aFJlc2l6ZWQgPT0gMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMC4wO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIHdob2xlIHBhcnQgYW5kIHRoZSBmcmFjdGlvbmFsIHBhcnQgYXJlIGNhbGN1bGF0ZWQgc2VwYXJhdGVseSBkdWUgdG8gaW5hY2N1cmFjeSBvZiBmbG9hdGluZ1xuICAgICAgICAgICAgICAgICAgICAvLyBwb2ludCBkaXZpc2lvbi4gQXMgYW4gZXhhbXBsZSwgZjMyKDIxKSAvIGYzMig3KSBtYXkgZXZhbHVhdGUgdG8gMi45OS4uLiBpbnN0ZWFkIG9mIDMsIGNhdXNpbmcgYW5cbiAgICAgICAgICAgICAgICAgICAgLy8gb2Zmc2V0LWJ5LW9uZSBlcnJvciBsYXRlciBpbiBmbG9vcigpLlxuICAgICAgICAgICAgICAgICAgICBsZXQgd2hvbGUgPSAke2RUeXBlfSh4UmVzaXplZCAqIChsZW5ndGhPcmlnaW5hbCAtIDEpIC8gKGxlbmd0aFJlc2l6ZWQgLSAxKSk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBmcmFjdCA9XG4gICAgICAgICAgICAgICAgICAgICAgICAke2RUeXBlfSh4UmVzaXplZCAqIChsZW5ndGhPcmlnaW5hbCAtIDEpICUgKGxlbmd0aFJlc2l6ZWQgLSAxKSkgLyAke2RUeXBlfShsZW5ndGhSZXNpemVkIC0gMSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB3aG9sZSArIGZyYWN0O1xuICAgICAgICAgICAgICAgICAgfWA7XG4gICAgICAgICAgICBjYXNlICd0Zl9jcm9wX2FuZF9yZXNpemUnOlxuICAgICAgICAgICAgICByZXR1cm4gYGlmIChsZW5ndGhSZXNpemVkID4gMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJHtkVHlwZX0ocm9pU3RhcnQpICogJHtkVHlwZX0obGVuZ3RoT3JpZ2luYWwgLSAxKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAoJHtkVHlwZX0oeFJlc2l6ZWQpICogJHtkVHlwZX0ocm9pRW5kIC0gcm9pU3RhcnQpICogJHtkVHlwZX0obGVuZ3RoT3JpZ2luYWwgLSAxKSkgL1xuICAgICAgICAgICAgICAgICAgICAgICAgJHtkVHlwZX0obGVuZ3RoUmVzaXplZCAtIDEpO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDAuNSAqICR7ZFR5cGV9KHJvaVN0YXJ0ICsgcm9pRW5kKSAqICR7ZFR5cGV9KGxlbmd0aE9yaWdpbmFsIC0gMSk7XG4gICAgICAgICAgICAgICAgICB9YDtcbiAgICAgICAgICAgIGNhc2UgJ2hhbGZfcGl4ZWxfc3ltbWV0cmljJzpcbiAgICAgICAgICAgICAgcmV0dXJuIGBjb25zdCBvdXRwdXRXaWR0aCA9ICR7ZFR5cGV9eFNjYWxlICogJHtkVHlwZX0obGVuZ3RoUmVzaXplZCk7XG4gICAgICAgICAgICAgICAgICBjb25zdCBhZGp1c3RtZW50ID0gJHtkVHlwZX0obGVuZ3RoUmVzaXplZCkgLyBvdXRwdXRXaWR0aDtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGNlbnRlciA9ICR7ZFR5cGV9KGxlbmd0aE9yaWdpbmFsKSAvIDI7XG4gICAgICAgICAgICAgICAgICBjb25zdCBvZmZzZXQgPSBjZW50ZXIgKiAoMSAtIGFkanVzdG1lbnQpO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIG9mZnNldCArICgoJHtkVHlwZX0oeFJlc2l6ZWQpICsgMC41KSAvICR7ZFR5cGV9KHhTY2FsZSkpIC0gMC41O2A7XG4gICAgICAgICAgICBjYXNlICdoYWxmX3BpeGVsJzpcbiAgICAgICAgICAgICAgcmV0dXJuIGByZXR1cm4gKCgke2RUeXBlfSh4UmVzaXplZCkgKyAwLjUpIC8gJHtkVHlwZX0oeFNjYWxlKSkgLSAwLjU7YDtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ29vcmRpbmF0ZSB0cmFuc2Zvcm0gbW9kZSAke2Nvb3JkaW5hdGVUcmFuc2Zlck1vZGV9IGlzIG5vdCBzdXBwb3J0ZWRgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pKCkgK1xuICAgICd9JztcblxuY29uc3QgZ2V0TmVhcmVzdFBpeGVsRnJvbU9yaWdpbmFsID0gKG5lYXJlc3RNb2RlOiBOZWFyZXN0TW9kZSwgb3BzZXRWZXJzaW9uOiBudW1iZXIsIGRUeXBlOiBzdHJpbmcpOiBzdHJpbmcgPT5cbiAgICBgZm4gZ2V0TmVhcmVzdFBpeGVsRnJvbU9yaWdpbmFsKHhPcmlnaW5hbDogJHtkVHlwZX0sIGlzRG93blNhbXBsZTogYm9vbCkgLT4gJHtkVHlwZX0ge2AgKyAoKCkgPT4ge1xuICAgICAgc3dpdGNoIChuZWFyZXN0TW9kZSkge1xuICAgICAgICBjYXNlICdyb3VuZF9wcmVmZXJfY2VpbCc6XG4gICAgICAgICAgcmV0dXJuICdpZiAoZnJhY3QoeE9yaWdpbmFsKSA9PSAwLjUpIHsgXFxcbiAgICAgICAgICAgIHJldHVybiBjZWlsKHhPcmlnaW5hbCk7IFxcXG4gICAgICAgICAgfSBlbHNlIHsgXFxcbiAgICAgICAgICAgIHJldHVybiByb3VuZCh4T3JpZ2luYWwpOyBcXFxuICAgICAgICAgIH0nO1xuICAgICAgICBjYXNlICdmbG9vcic6XG4gICAgICAgICAgcmV0dXJuICdyZXR1cm4gZmxvb3IoeE9yaWdpbmFsKTsnO1xuICAgICAgICBjYXNlICdjZWlsJzpcbiAgICAgICAgICByZXR1cm4gJ3JldHVybiBjZWlsKHhPcmlnaW5hbCk7JztcbiAgICAgICAgY2FzZSAncm91bmRfcHJlZmVyX2Zsb29yJzpcbiAgICAgICAgICByZXR1cm4gJ2lmIChmcmFjdCh4T3JpZ2luYWwpID09IDAuNSkgeyBcXFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmxvb3IoeE9yaWdpbmFsKTsgXFxcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7IFxcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByb3VuZCh4T3JpZ2luYWwpOyBcXFxuICAgICAgICAgICAgICAgICAgfSc7XG4gICAgICAgIGNhc2UgJ3NpbXBsZSc6XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgaWYgKG9wc2V0VmVyc2lvbiA8IDExKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2lmIChpc0Rvd25TYW1wbGUpIFxcXG4gICAgICAgICAgICAgICAgICAgIHsgXFxcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2VpbCh4T3JpZ2luYWwpOyBcXFxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgeyBcXFxuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB4T3JpZ2luYWw7IFxcXG4gICAgICAgICAgICAgICAgICAgIH0nO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5lYXJlc3QgbW9kZSAke25lYXJlc3RNb2RlfSBpcyBub3Qgc3VwcG9ydGVkYCk7XG4gICAgICB9XG4gICAgfSkoKSArXG4gICAgJ30nO1xuXG5jb25zdCB1cGRhdGVSb0kgPSAocm9pOiByZWFkb25seSBudW1iZXJbXSwgYXhlczogcmVhZG9ubHkgbnVtYmVyW10sIHJhbms6IG51bWJlcik6IG51bWJlcltdID0+IHtcbiAgY29uc3Qgcm9pVG1wID0gbmV3IEFycmF5KHJhbmspLmZpbGwoMCkuY29uY2F0KG5ldyBBcnJheShyYW5rKS5maWxsKDEpKTtcbiAgY29uc3Qgcm9pTG9jYWwgPSByb2kubGVuZ3RoID09PSAwID8gcm9pVG1wIDogcm9pLnNsaWNlKCk7XG4gIGlmIChheGVzLmxlbmd0aCA+IDApIHtcbiAgICBheGVzLmZvckVhY2goKHYsIGkpID0+IHtcbiAgICAgIHJvaVRtcFt2XSA9IHJvaUxvY2FsW2ldO1xuICAgICAgcm9pVG1wW2kgKyByYW5rXSA9IHJvaUxvY2FsW2F4ZXMubGVuZ3RoICsgaV07XG4gICAgfSk7XG4gICAgcmV0dXJuIHJvaVRtcDtcbiAgfVxuICByZXR1cm4gcm9pTG9jYWw7XG59O1xuXG5jb25zdCBpbml0T3V0cHV0U2hhcGUgPVxuICAgIChpbnB1dFNoYXBlOiByZWFkb25seSBudW1iZXJbXSwgc2NhbGVzOiByZWFkb25seSBudW1iZXJbXSwgc2l6ZXM6IHJlYWRvbmx5IG51bWJlcltdLCBheGVzOiByZWFkb25seSBudW1iZXJbXSk6XG4gICAgICAgIG51bWJlcltdID0+IHtcbiAgICAgICAgICBsZXQgb3V0cHV0U2hhcGU6IG51bWJlcltdID0gW107XG4gICAgICAgICAgaWYgKHNpemVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGlmIChheGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgaW5wdXRTaGFwZS5mb3JFYWNoKCh2KSA9PiBvdXRwdXRTaGFwZS5wdXNoKHYpKTtcbiAgICAgICAgICAgICAgaWYgKE1hdGgubWF4KC4uLmF4ZXMpID4gaW5wdXRTaGFwZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2F4ZXMgaXMgb3V0IG9mIGJvdW5kJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYXhlcy5mb3JFYWNoKCh2LCBpKSA9PiBvdXRwdXRTaGFwZVt2XSA9IHNpemVzW2ldKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHNpemVzLmZvckVhY2goKHYpID0+IG91dHB1dFNoYXBlLnB1c2godikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoc2NhbGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Jlc2l6ZSByZXF1aXJlcyBlaXRoZXIgc2NhbGVzIG9yIHNpemVzLicpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgb3V0cHV0U2hhcGUgPSBpbnB1dFNoYXBlLm1hcCgodmFsdWUsIGluZGV4KSA9PiBNYXRoLnJvdW5kKHZhbHVlICogc2NhbGVzW2luZGV4XSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gb3V0cHV0U2hhcGU7XG4gICAgICAgIH07XG5cbmNvbnN0IGFkanVzdE91dHB1dFNoYXBlID0gKGlucHV0U2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLCBzY2FsZXM6IG51bWJlcltdLCBhdHRyaWJ1dGVzOiBSZXNpemVBdHRyaWJ1dGVzKSA9PiB7XG4gIGNvbnN0IHNjYWxlSW5Qb2xpY3kgPSAoKCkgPT4ge1xuICAgIHN3aXRjaCAoYXR0cmlidXRlcy5rZWVwQXNwZWN0UmF0aW9Qb2xpY3kpIHtcbiAgICAgIGNhc2UgJ25vdF9sYXJnZXInOlxuICAgICAgICByZXR1cm4gYXR0cmlidXRlcy5heGVzLmxlbmd0aCA+IDAgPyBNYXRoLm1pbiguLi5hdHRyaWJ1dGVzLmF4ZXMubWFwKGkgPT4gc2NhbGVzW2ldKSwgTnVtYmVyLk1BWF9WQUxVRSkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBNYXRoLm1pbiguLi5zY2FsZXMsIE51bWJlci5NQVhfVkFMVUUpO1xuICAgICAgY2FzZSAnbm90X3NtYWxsZXInOlxuICAgICAgICByZXR1cm4gYXR0cmlidXRlcy5heGVzLmxlbmd0aCA+IDAgPyBNYXRoLm1heCguLi5hdHRyaWJ1dGVzLmF4ZXMubWFwKGkgPT4gc2NhbGVzW2ldKSwgTnVtYmVyLk1JTl9WQUxVRSkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBNYXRoLm1heCguLi5zY2FsZXMsIE51bWJlci5NSU5fVkFMVUUpO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBLZWVwIGFzcGVjdCByYXRpbyBwb2xpY3kgJHthdHRyaWJ1dGVzLmtlZXBBc3BlY3RSYXRpb1BvbGljeX0gaXMgbm90IHN1cHBvcnRlZGApO1xuICAgIH1cbiAgfSkoKTtcbiAgc2NhbGVzLmZpbGwoMS4wLCAwLCBzY2FsZXMubGVuZ3RoKTtcbiAgY29uc3QgYWRqdXN0ZWRPdXRwdXRTaGFwZSA9IGlucHV0U2hhcGUuc2xpY2UoKTtcbiAgaWYgKGF0dHJpYnV0ZXMuYXhlcy5sZW5ndGggPiAwKSB7XG4gICAgYXR0cmlidXRlcy5heGVzLmZvckVhY2goKHYpID0+IHNjYWxlc1t2XSA9IHNjYWxlSW5Qb2xpY3kpO1xuICAgIGF0dHJpYnV0ZXMuYXhlcy5mb3JFYWNoKCh2KSA9PiBhZGp1c3RlZE91dHB1dFNoYXBlW3ZdID0gTWF0aC5yb3VuZChpbnB1dFNoYXBlW3ZdICogc2NhbGVzW3ZdKSk7XG4gIH0gZWxzZSB7XG4gICAgc2NhbGVzLmZpbGwoc2NhbGVJblBvbGljeSwgMCwgc2NhbGVzLmxlbmd0aCk7XG4gICAgYWRqdXN0ZWRPdXRwdXRTaGFwZS5mb3JFYWNoKCh2LCBpKSA9PiBhZGp1c3RlZE91dHB1dFNoYXBlW2ldID0gTWF0aC5yb3VuZCh2ICogc2NhbGVzW2ldKSk7XG4gIH1cbiAgcmV0dXJuIGFkanVzdGVkT3V0cHV0U2hhcGU7XG59O1xuXG5jb25zdCBjYWxjdWxhdGVPcmlnaW5hbEluZGljZXNGcm9tT3V0cHV0SW5kaWNlcyA9XG4gICAgKG91dHB1dDogSW5kaWNlc0hlbHBlciwgaW5wdXRTaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sIG91dHB1dFNoYXBlOiByZWFkb25seSBudW1iZXJbXSwgc2NhbGVzTGVuZ3RoOiBudW1iZXIsXG4gICAgIHJvaUxlbmd0aDogbnVtYmVyKTogc3RyaW5nID0+IGBcbiAgICBmbiBjYWxjdWxhdGVPcmlnaW5hbEluZGljZXNGcm9tT3V0cHV0SW5kaWNlcyhvdXRwdXRfaW5kaWNlczogJHtvdXRwdXQudHlwZS5pbmRpY2VzfSkgLT4gYXJyYXk8JHtcbiAgICAgICAgb3V0cHV0LnR5cGUudmFsdWV9LCAke291dHB1dFNoYXBlLmxlbmd0aH0+IHtcbiAgICAgIHZhciBvcmlnaW5hbF9pbmRpY2VzOiBhcnJheTwke291dHB1dC50eXBlLnZhbHVlfSwgJHtvdXRwdXRTaGFwZS5sZW5ndGh9PjtcbiAgICAgIGZvciAodmFyIGk6dTMyID0gMDsgaSA8ICR7b3V0cHV0U2hhcGUubGVuZ3RofTsgaSsrKSB7XG4gICAgICAgIHZhciBvdXRwdXRfaW5kZXggPSAke291dHB1dC5pbmRpY2VzR2V0KCdvdXRwdXRfaW5kaWNlcycsICdpJyl9O1xuICAgICAgICB2YXIgc2NhbGUgPSAke2dldEVsZW1lbnRBdCgndW5pZm9ybXMuc2NhbGVzJywgJ2knLCBzY2FsZXNMZW5ndGgpfTtcbiAgICAgICAgdmFyIHJvaV9sb3cgPSAke2dldEVsZW1lbnRBdCgndW5pZm9ybXMucm9pJywgJ2knLCByb2lMZW5ndGgpfTtcbiAgICAgICAgdmFyIHJvaV9oaSA9ICR7Z2V0RWxlbWVudEF0KCd1bmlmb3Jtcy5yb2knLCBgaSArICR7aW5wdXRTaGFwZS5sZW5ndGh9YCwgcm9pTGVuZ3RoKX07XG4gICAgICAgIGlmIChzY2FsZSA9PSAxLjApIHtcbiAgICAgICAgICBvcmlnaW5hbF9pbmRpY2VzW2ldID0gJHtvdXRwdXQudHlwZS52YWx1ZX0ob3V0cHV0X2luZGV4KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgaW5wdXRfc2hhcGVfaSA9ICR7Z2V0RWxlbWVudEF0KCd1bmlmb3Jtcy5pbnB1dF9zaGFwZScsICdpJywgaW5wdXRTaGFwZS5sZW5ndGgpfTtcbiAgICAgICAgICB2YXIgb3V0cHV0X3NoYXBlX2kgPSAke2dldEVsZW1lbnRBdCgndW5pZm9ybXMub3V0cHV0X3NoYXBlJywgJ2knLCBvdXRwdXRTaGFwZS5sZW5ndGgpfTtcbiAgICAgICAgICBvcmlnaW5hbF9pbmRpY2VzW2ldID0gZ2V0T3JpZ2luYWxDb29yZGluYXRlRnJvbVJlc2l6ZWRDb29yZGluYXRlKG91dHB1dF9pbmRleCwgc2NhbGUsIG91dHB1dF9zaGFwZV9pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXRfc2hhcGVfaSwgcm9pX2xvdywgcm9pX2hpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG9yaWdpbmFsX2luZGljZXM7XG4gICAgfWA7XG5cbmNvbnN0IGNhbGN1bGF0ZUlucHV0SW5kaWNlc0Zyb21PdXRwdXRJbmRpY2VzID1cbiAgICAoaW5wdXQ6IEluZGljZXNIZWxwZXIsIG91dHB1dDogSW5kaWNlc0hlbHBlciwgaW5wdXRTaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sIG91dHB1dFNoYXBlOiByZWFkb25seSBudW1iZXJbXSxcbiAgICAgc2NhbGVzTGVuZ3RoOiBudW1iZXIsIHJvaUxlbmd0aDogbnVtYmVyLCB1c2VFeHRyYXBvbGF0aW9uOiBib29sZWFuKTogc3RyaW5nID0+IGBcbiAgICBmbiBjYWxjdWxhdGVJbnB1dEluZGljZXNGcm9tT3V0cHV0SW5kaWNlcyhvdXRwdXRfaW5kaWNlczogJHtvdXRwdXQudHlwZS5pbmRpY2VzfSkgLT4gJHtpbnB1dC50eXBlLmluZGljZXN9IHtcbiAgICAgIHZhciBpbnB1dF9pbmRpY2VzOiAke2lucHV0LnR5cGUuaW5kaWNlc307XG4gICAgICBmb3IgKHZhciBpOnUzMiA9IDA7IGkgPCAke291dHB1dFNoYXBlLmxlbmd0aH07IGkrKykge1xuICAgICAgICB2YXIgb3V0cHV0X2luZGV4ID0gJHtvdXRwdXQuaW5kaWNlc0dldCgnb3V0cHV0X2luZGljZXMnLCAnaScpfTtcbiAgICAgICAgdmFyIGlucHV0X2luZGV4OiB1MzI7XG4gICAgICAgIHZhciBzY2FsZSA9ICR7Z2V0RWxlbWVudEF0KCd1bmlmb3Jtcy5zY2FsZXMnLCAnaScsIHNjYWxlc0xlbmd0aCl9O1xuICAgICAgICBpZiAoc2NhbGUgPT0gMS4wKSB7XG4gICAgICAgICAgaW5wdXRfaW5kZXggPSBvdXRwdXRfaW5kZXg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHJvaV9sb3cgPSAke2dldEVsZW1lbnRBdCgndW5pZm9ybXMucm9pJywgJ2knLCByb2lMZW5ndGgpfTtcbiAgICAgICAgICB2YXIgcm9pX2hpID0gJHtnZXRFbGVtZW50QXQoJ3VuaWZvcm1zLnJvaScsIGBpICsgJHtpbnB1dFNoYXBlLmxlbmd0aH1gLCByb2lMZW5ndGgpfTtcbiAgICAgICAgICB2YXIgaW5wdXRfc2hhcGVfaSA9ICR7Z2V0RWxlbWVudEF0KCd1bmlmb3Jtcy5pbnB1dF9zaGFwZScsICdpJywgaW5wdXRTaGFwZS5sZW5ndGgpfTtcbiAgICAgICAgICB2YXIgb3V0cHV0X3NoYXBlX2kgPSAke2dldEVsZW1lbnRBdCgndW5pZm9ybXMub3V0cHV0X3NoYXBlJywgJ2knLCBvdXRwdXRTaGFwZS5sZW5ndGgpfTtcbiAgICAgICAgICB2YXIgb3JpZ2luYWxfaWR4ID0gZ2V0T3JpZ2luYWxDb29yZGluYXRlRnJvbVJlc2l6ZWRDb29yZGluYXRlKG91dHB1dF9pbmRleCwgc2NhbGUsIG91dHB1dF9zaGFwZV9pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXRfc2hhcGVfaSwgcm9pX2xvdywgcm9pX2hpKTtcbiAgICAgICAgICBpZiAoISR7dXNlRXh0cmFwb2xhdGlvbn0gfHwgKG9yaWdpbmFsX2lkeCA+PSAwICYmIG9yaWdpbmFsX2lkeCA8ICR7b3V0cHV0LnR5cGUudmFsdWV9KGlucHV0X3NoYXBlX2kpKSkge1xuICAgICAgICAgICAgaWYgKG9yaWdpbmFsX2lkeCA8IDApIHtcbiAgICAgICAgICAgICAgaW5wdXRfaW5kZXggPSAwO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChvcmlnaW5hbF9pZHggPiAke291dHB1dC50eXBlLnZhbHVlfShpbnB1dF9zaGFwZV9pIC0gMSkpIHtcbiAgICAgICAgICAgICAgaW5wdXRfaW5kZXggPSBpbnB1dF9zaGFwZV9pIC0gMTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlucHV0X2luZGV4ID0gdTMyKGdldE5lYXJlc3RQaXhlbEZyb21PcmlnaW5hbChvcmlnaW5hbF9pZHgsIHNjYWxlIDwgMSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpbnB1dF9pbmRleCA9IHUzMihvcmlnaW5hbF9pZHgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAke2lucHV0LmluZGljZXNTZXQoJ2lucHV0X2luZGljZXMnLCAnaScsICcgaW5wdXRfaW5kZXgnKX1cbiAgICAgIH1cbiAgICAgIHJldHVybiBpbnB1dF9pbmRpY2VzO1xuICAgIH1gO1xuY29uc3QgY2hlY2tJbnB1dEluZGljZXMgPSAoaW5wdXQ6IEluZGljZXNIZWxwZXIsIGlucHV0U2hhcGU6IHJlYWRvbmx5IG51bWJlcltdKTogc3RyaW5nID0+IGBcbiAgICBmbiBjaGVja0lucHV0SW5kaWNlcyhpbnB1dF9pbmRpY2VzOiAke2lucHV0LnR5cGUuaW5kaWNlc30pIC0+IGJvb2wge1xuICAgICAgZm9yICh2YXIgaTp1MzIgPSAwOyBpIDwgJHtpbnB1dFNoYXBlLmxlbmd0aH07IGkrKykge1xuICAgICAgICB2YXIgaW5wdXRfaW5kZXggPSAke2lucHV0LmluZGljZXNHZXQoJ2lucHV0X2luZGljZXMnLCAnaScpfTtcbiAgICAgICAgaWYgKGlucHV0X2luZGV4IDwgMCB8fCBpbnB1dF9pbmRleCA+PSAke2dldEVsZW1lbnRBdCgndW5pZm9ybXMuaW5wdXRfc2hhcGUnLCAnaScsIGlucHV0U2hhcGUubGVuZ3RoKX0pIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1gO1xuXG5jb25zdCBzZXRDaGFubmVsQW5kQmF0Y2hJbmRpY2VzID1cbiAgICAoaW5wdXQ6IEluZGljZXNIZWxwZXIsIGNoYW5uZWxJZHg6IG51bWJlciwgYmF0Y2hJZHg6IG51bWJlciwgc3BhY2lhbERpbXM6IG51bWJlcik6IHN0cmluZyA9PlxuICAgICAgICBpbnB1dC5yYW5rID4gc3BhY2lhbERpbXMgPyBgXG4gICAgJHtpbnB1dC5pbmRpY2VzU2V0KCdpbnB1dF9pbmRpY2VzJywgY2hhbm5lbElkeCwgJ2NoYW5uZWwnKX07XG4gICAgJHtpbnB1dC5pbmRpY2VzU2V0KCdpbnB1dF9pbmRpY2VzJywgYmF0Y2hJZHgsICdiYXRjaCcpfTtcbmAgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnJztcblxuY29uc3QgYmlsaW5lYXJJbnRlcnBvbGF0aW9uID1cbiAgICAoaW5wdXQ6IEluZGljZXNIZWxwZXIsIG91dHB1dDogSW5kaWNlc0hlbHBlciwgaW5wdXRTaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sIHVzZUV4dHJhcG9sYXRpb246IGJvb2xlYW4sXG4gICAgIGV4dHJhcG9sYXRpb25WYWx1ZTogbnVtYmVyKTogc3RyaW5nID0+IHtcbiAgICAgIGNvbnN0IGlzTmNodyA9IHRydWU7XG4gICAgICBjb25zdCBbYmF0Y2hJZHgsIGhlaWdodElkeCwgd2lkdGhJZHgsIGNoYW5uZWxJZHhdID1cbiAgICAgICAgICBpbnB1dFNoYXBlLmxlbmd0aCA9PT0gMiA/IFstMSwgMCwgMSwgLTFdIDogKGlzTmNodyA/IFswLCAyLCAzLCAxXSA6IFswLCAxLCAyLCAzXSk7XG4gICAgICBjb25zdCBkVHlwZSA9IGlucHV0LnR5cGUudmFsdWU7XG4gICAgICByZXR1cm4gYFxuICAgIGZuIGdldElucHV0VmFsdWUoYmF0Y2g6IHUzMiwgY2hhbm5lbDogdTMyLCByb3c6IHUzMiwgY29sOiB1MzIpIC0+ICR7ZFR5cGV9IHtcbiAgICAgIHZhciBpbnB1dF9pbmRpY2VzOiAke2lucHV0LnR5cGUuaW5kaWNlc307XG4gICAgICAke2lucHV0LmluZGljZXNTZXQoJ2lucHV0X2luZGljZXMnLCBoZWlnaHRJZHgsIGBtYXgoMCwgbWluKHJvdywgJHtpbnB1dFNoYXBlW2hlaWdodElkeF19IC0gMSkpYCl9O1xuICAgICAgJHtpbnB1dC5pbmRpY2VzU2V0KCdpbnB1dF9pbmRpY2VzJywgd2lkdGhJZHgsIGBtYXgoMCwgbWluKGNvbCwgJHtpbnB1dFNoYXBlW3dpZHRoSWR4XX0gLSAxKSlgKX07XG4gICAgICAke3NldENoYW5uZWxBbmRCYXRjaEluZGljZXMoaW5wdXQsIGNoYW5uZWxJZHgsIGJhdGNoSWR4LCAyKX1cbiAgICAgIHJldHVybiAke2lucHV0LmdldEJ5SW5kaWNlcygnaW5wdXRfaW5kaWNlcycpfTtcbiAgICB9XG5cbiAgICBmbiBiaWxpbmVhckludGVycG9sYXRpb24ob3V0cHV0X2luZGljZXM6ICR7b3V0cHV0LnR5cGUuaW5kaWNlc30pIC0+ICR7ZFR5cGV9IHtcbiAgICAgIHZhciBvcmlnaW5hbEluZGljZXMgPSBjYWxjdWxhdGVPcmlnaW5hbEluZGljZXNGcm9tT3V0cHV0SW5kaWNlcyhvdXRwdXRfaW5kaWNlcyk7XG4gICAgICB2YXIgcm93OiR7ZFR5cGV9ID0gb3JpZ2luYWxJbmRpY2VzWyR7aGVpZ2h0SWR4fV07XG4gICAgICB2YXIgY29sOiR7ZFR5cGV9ID0gb3JpZ2luYWxJbmRpY2VzWyR7d2lkdGhJZHh9XTtcbiAgICAgICR7XG4gICAgICAgICAgdXNlRXh0cmFwb2xhdGlvbiA/XG4gICAgICAgICAgICAgIGBpZiAocm93IDwgMCB8fCByb3cgPiAoJHtpbnB1dFNoYXBlW2hlaWdodElkeF19IC0gMSkgfHwgY29sIDwgMCB8fCBjb2wgPiAoJHtpbnB1dFNoYXBlW3dpZHRoSWR4XX0gLSAxKSkge1xuICAgICAgICByZXR1cm4gJHtleHRyYXBvbGF0aW9uVmFsdWV9O1xuICAgICAgfWAgOlxuICAgICAgICAgICAgICAnJ307XG4gICAgICByb3cgPSBtYXgoMCwgbWluKHJvdywgJHtpbnB1dFNoYXBlW2hlaWdodElkeF19IC0gMSkpO1xuICAgICAgY29sID0gbWF4KDAsIG1pbihjb2wsICR7aW5wdXRTaGFwZVt3aWR0aElkeF19IC0gMSkpO1xuICAgICAgdmFyIHJvdzE6IHUzMiA9IHUzMihyb3cpO1xuICAgICAgdmFyIGNvbDE6IHUzMiA9IHUzMihjb2wpO1xuICAgICAgdmFyIHJvdzI6IHUzMiA9IHUzMihyb3cgKyAxKTtcbiAgICAgIHZhciBjb2wyOiB1MzIgPSB1MzIoY29sICsgMSk7XG4gICAgICB2YXIgY2hhbm5lbDogdTMyID0gJHtpbnB1dFNoYXBlLmxlbmd0aCA+IDIgPyBgdTMyKG9yaWdpbmFsSW5kaWNlc1ske2NoYW5uZWxJZHh9XSlgIDogJzAnfTtcbiAgICAgIHZhciBiYXRjaDogdTMyID0gICR7aW5wdXRTaGFwZS5sZW5ndGggPiAyID8gYHUzMihvcmlnaW5hbEluZGljZXNbJHtiYXRjaElkeH1dKWAgOiAnMCd9O1xuICAgICAgdmFyIHgxMTogJHtkVHlwZX0gPSBnZXRJbnB1dFZhbHVlKGJhdGNoLCBjaGFubmVsLCByb3cxLCBjb2wxKTtcbiAgICAgIHZhciB4MTI6ICR7ZFR5cGV9ID0gZ2V0SW5wdXRWYWx1ZShiYXRjaCwgY2hhbm5lbCwgcm93MSwgY29sMik7XG4gICAgICB2YXIgeDIxOiAke2RUeXBlfSA9IGdldElucHV0VmFsdWUoYmF0Y2gsIGNoYW5uZWwsIHJvdzIsIGNvbDEpO1xuICAgICAgdmFyIHgyMjogJHtkVHlwZX0gPSBnZXRJbnB1dFZhbHVlKGJhdGNoLCBjaGFubmVsLCByb3cyLCBjb2wyKTtcbiAgICAgIHZhciBkeDE6ICR7ZFR5cGV9ID0gYWJzKHJvdyAtICR7ZFR5cGV9KHJvdzEpKTtcbiAgICAgIHZhciBkeDI6ICR7ZFR5cGV9ID0gYWJzKCR7ZFR5cGV9KHJvdzIpIC0gcm93KTtcbiAgICAgIHZhciBkeTE6ICR7ZFR5cGV9ID0gYWJzKGNvbCAtICR7ZFR5cGV9KGNvbDEpKTtcbiAgICAgIHZhciBkeTI6ICR7ZFR5cGV9ID0gYWJzKCR7ZFR5cGV9KGNvbDIpIC0gY29sKTtcbiAgICAgIGlmIChyb3cxID09IHJvdzIpIHtcbiAgICAgICAgZHgxID0gMC41O1xuICAgICAgICBkeDIgPSAwLjU7XG4gICAgICB9XG4gICAgICBpZiAoY29sMSA9PSBjb2wyKSB7XG4gICAgICAgIGR5MSA9IDAuNTtcbiAgICAgICAgZHkyID0gMC41O1xuICAgICAgfVxuICAgICAgcmV0dXJuICh4MTEgKiBkeDIgKiBkeTIgKyB4MTIgKiBkeDIgKiBkeTEgKyB4MjEgKiBkeDEgKiBkeTIgKyB4MjIgKiBkeDEgKiBkeTEpO1xuICAgIH1gO1xuICAgIH07XG5cbmNvbnN0IGJpY3ViaWNJbnRlcnBvbGF0aW9uID1cbiAgICAoaW5wdXQ6IEluZGljZXNIZWxwZXIsIG91dHB1dDogSW5kaWNlc0hlbHBlciwgaW5wdXRTaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sIG91dHB1dFNoYXBlOiByZWFkb25seSBudW1iZXJbXSxcbiAgICAgc2NhbGVzOiByZWFkb25seSBudW1iZXJbXSwgcm9pOiByZWFkb25seSBudW1iZXJbXSwgY3ViaWNDb2VmZkE6IG51bWJlciwgdXNlRXh0cmFwb2xhdGlvbjogYm9vbGVhbixcbiAgICAgZXh0cmFwb2xhdGlvblZhbHVlOiBudW1iZXIsIGV4Y2x1ZGVPdXRzaWRlOiBib29sZWFuKTogc3RyaW5nID0+IHtcbiAgICAgIGNvbnN0IGlzMkQgPSBpbnB1dFNoYXBlLmxlbmd0aCA9PT0gMjtcbiAgICAgIGNvbnN0IGlzTmNodyA9IHRydWU7XG4gICAgICBjb25zdCBbaGVpZ2h0SWR4LCB3aWR0aElkeF0gPSBpczJEID8gWzAsIDFdIDogaXNOY2h3ID8gWzIsIDNdIDogWzEsIDJdO1xuICAgICAgY29uc3QgZFR5cGUgPSBpbnB1dC50eXBlLnZhbHVlO1xuICAgICAgY29uc3QgY3JlYXRlQ3ViaWNJbnRlcnBvbGF0aW9uRnVuY3Rpb24gPSAoaWR4OiBudW1iZXIpOiBzdHJpbmcgPT4ge1xuICAgICAgICBjb25zdCBkaXJlY3Rpb24gPSBpZHggPT09IGhlaWdodElkeCA/ICdyb3cnIDogJ2NvbCc7XG4gICAgICAgIHJldHVybiBgXG4gICAgICBmbiAke2RpcmVjdGlvbn1DdWJpY0ludGVycG9sYXRpb24oaW5wdXRfaW5kaWNlczogJHtpbnB1dC50eXBlLmluZGljZXN9LCBvdXRwdXRfaW5kaWNlczogJHtcbiAgICAgICAgICAgIG91dHB1dC50eXBlLmluZGljZXN9KSAtPiAke2RUeXBlfSB7XG4gICAgICAgIHZhciBvdXRwdXRfaW5kZXggPSAke291dHB1dC5pbmRpY2VzR2V0KCdvdXRwdXRfaW5kaWNlcycsIGlkeCl9O1xuICAgICAgICB2YXIgb3JpZ2luYWxJZHg6ICR7ZFR5cGV9ID0gZ2V0T3JpZ2luYWxDb29yZGluYXRlRnJvbVJlc2l6ZWRDb29yZGluYXRlKG91dHB1dF9pbmRleCwgJHtzY2FsZXNbaWR4XX0sXG4gICAgICAgICR7b3V0cHV0U2hhcGVbaWR4XX0sICR7aW5wdXRTaGFwZVtpZHhdfSwgJHtyb2lbaWR4XX0sICR7cm9pW2lkeF19ICsgJHtpbnB1dFNoYXBlLmxlbmd0aH0pO1xuICAgICAgICB2YXIgZnJhY3RPcmlnaW5hbElkeDogJHtkVHlwZX0gPSBvcmlnaW5hbElkeCAtIGZsb29yKG9yaWdpbmFsSWR4KTtcbiAgICAgICAgdmFyIGNvZWZzID0gZ2V0Q3ViaWNJbnRlcnBvbGF0aW9uQ29lZnMoZnJhY3RPcmlnaW5hbElkeCk7XG5cbiAgICAgICAgaWYgKCR7dXNlRXh0cmFwb2xhdGlvbn0gJiYgKG9yaWdpbmFsSWR4IDwgMCB8fCBvcmlnaW5hbElkeCA+ICgke2lucHV0U2hhcGVbaWR4XX0gLSAxKSkpIHtcbiAgICAgICAgICByZXR1cm4gJHtleHRyYXBvbGF0aW9uVmFsdWV9O1xuICAgICAgICB9XG4gICAgICAgIHZhciBkYXRhOiBhcnJheTwke2RUeXBlfSwgND4gPSBhcnJheTwke2RUeXBlfSwgND4oMC4wLCAwLjAsIDAuMCwgMC4wKTtcbiAgICAgICAgZm9yICh2YXIgaTogaTMyID0gLTE7IGkgPCAzOyBpKyspIHtcbiAgICAgICAgICB2YXIgJHtkaXJlY3Rpb259OiAke2RUeXBlfSA9IG9yaWdpbmFsSWR4ICsgJHtkVHlwZX0oaSk7XG4gICAgICAgICAgaWYgKCR7ZGlyZWN0aW9ufSA8IDAgfHwgJHtkaXJlY3Rpb259ID49ICR7aW5wdXRTaGFwZVtpZHhdfSkge1xuICAgICAgICAgICAgJHsoKCkgPT4ge1xuICAgICAgICAgIGlmIChleGNsdWRlT3V0c2lkZSkge1xuICAgICAgICAgICAgcmV0dXJuIGBjb2Vmc1tpICsgMV0gPSAwLjA7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtgO1xuICAgICAgICAgIH0gZWxzZSBpZiAodXNlRXh0cmFwb2xhdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIGByZXR1cm4gJHtleHRyYXBvbGF0aW9uVmFsdWV9O2A7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBgJHtkaXJlY3Rpb259ID0gbWF4KDAsIG1pbigke2RpcmVjdGlvbn0sICR7aW5wdXRTaGFwZVtpZHhdfSAtIDEpKTtgO1xuICAgICAgICAgIH1cbiAgICAgICAgfSkoKX07XG4gICAgICAgICAgfVxuICAgICAgICB2YXIgaW5wdXRfaW5kaWNlc19jb3B5OiAke2lucHV0LnR5cGUuaW5kaWNlc30gPSBpbnB1dF9pbmRpY2VzO1xuICAgICAgICAgICR7aW5wdXQuaW5kaWNlc1NldCgnaW5wdXRfaW5kaWNlc19jb3B5JywgaWR4LCBgdTMyKCR7ZGlyZWN0aW9ufSlgKX07XG4gICAgICAgICAgZGF0YVtpICsgMV0gPSAke1xuICAgICAgICAgICAgaWR4ID09PSBoZWlnaHRJZHggPyBpbnB1dC5nZXRCeUluZGljZXMoJ2lucHV0X2luZGljZXNfY29weScpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3Jvd0N1YmljSW50ZXJwb2xhdGlvbihpbnB1dF9pbmRpY2VzX2NvcHksIG91dHB1dF9pbmRpY2VzKSd9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjdWJpY0ludGVycG9sYXRpb24xRChkYXRhLCBjb2Vmcyk7XG4gICAgICB9YDtcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBgXG4gICAgJHtjcmVhdGVDdWJpY0ludGVycG9sYXRpb25GdW5jdGlvbihoZWlnaHRJZHgpfTtcbiAgICAke2NyZWF0ZUN1YmljSW50ZXJwb2xhdGlvbkZ1bmN0aW9uKHdpZHRoSWR4KX07XG4gIGZuIGdldEN1YmljSW50ZXJwb2xhdGlvbkNvZWZzKHM6ICR7ZFR5cGV9KSAtPiBhcnJheTwke2RUeXBlfSwgND4ge1xuICAgIHZhciBhYnNTID0gYWJzKHMpO1xuICAgIHZhciBjb2VmZnM6IGFycmF5PCR7ZFR5cGV9LCA0PiA9IGFycmF5PCR7ZFR5cGV9LCA0PigwLjAsIDAuMCwgMC4wLCAwLjApO1xuICAgIHZhciBvbmVNaW51c0Fic1M6ICR7ZFR5cGV9ID0gMS4wIC0gYWJzUztcbiAgICB2YXIgdHdvTWludXNBYnNTOiAke2RUeXBlfSA9IDIuMCAtIGFic1M7XG4gICAgdmFyIG9uZVBsdXNBYnNTOiAke2RUeXBlfSA9IDEuMCArIGFic1M7XG4gICAgY29lZmZzWzBdID0gKCgke2N1YmljQ29lZmZBfSAqIG9uZVBsdXNBYnNTIC0gNSAqICR7Y3ViaWNDb2VmZkF9KSAqIG9uZVBsdXNBYnNTICsgOCAqICR7XG4gICAgICAgICAgY3ViaWNDb2VmZkF9KSAqIG9uZVBsdXNBYnNTIC0gNCAqICR7Y3ViaWNDb2VmZkF9O1xuICAgIGNvZWZmc1sxXSA9ICgoJHtjdWJpY0NvZWZmQX0gKyAyKSAqIGFic1MgLSAoJHtjdWJpY0NvZWZmQX0gKyAzKSkgKiBhYnNTICogYWJzUyArIDE7XG4gICAgY29lZmZzWzJdID0gKCgke2N1YmljQ29lZmZBfSArIDIpICogb25lTWludXNBYnNTIC0gKCR7Y3ViaWNDb2VmZkF9ICsgMykpICogb25lTWludXNBYnNTICogb25lTWludXNBYnNTICsgMTtcbiAgICBjb2VmZnNbM10gPSAoKCR7Y3ViaWNDb2VmZkF9ICogdHdvTWludXNBYnNTIC0gNSAqICR7Y3ViaWNDb2VmZkF9KSAqIHR3b01pbnVzQWJzUyArIDggKiAke1xuICAgICAgICAgIGN1YmljQ29lZmZBfSkgKiB0d29NaW51c0Fic1MgLSA0ICogJHtjdWJpY0NvZWZmQX07XG4gICAgcmV0dXJuIGNvZWZmcztcbiAgfVxuXG4gIGZuIGN1YmljSW50ZXJwb2xhdGlvbjFEKHg6IGFycmF5PCR7ZFR5cGV9LCA0PiwgY29lZnM6IGFycmF5PCR7ZFR5cGV9LCA0PikgLT4gJHtkVHlwZX0ge1xuICAgIHZhciBjb2Vmc1N1bTogJHtkVHlwZX0gPSBjb2Vmc1swXSArIGNvZWZzWzFdICsgY29lZnNbMl0gKyBjb2Vmc1szXTtcbiAgICByZXR1cm4gKHhbMF0gKiBjb2Vmc1swXSArIHhbMV0gKiBjb2Vmc1sxXSsgeFsyXSAqIGNvZWZzWzJdKyB4WzNdICogY29lZnNbM10pIC8gY29lZnNTdW07XG4gIH1cblxuICBmbiBiaWN1YmljSW50ZXJwb2xhdGlvbihvdXRwdXRfaW5kaWNlczogJHtvdXRwdXQudHlwZS5pbmRpY2VzfSkgLT4gJHtkVHlwZX0ge1xuICAgIHZhciBpbnB1dF9pbmRpY2VzOiAke2lucHV0LnR5cGUuaW5kaWNlc30gPSBvdXRwdXRfaW5kaWNlcztcbiAgICByZXR1cm4gY29sQ3ViaWNJbnRlcnBvbGF0aW9uKGlucHV0X2luZGljZXMsIG91dHB1dF9pbmRpY2VzKTtcbiAgfVxuICAgIGA7XG4gICAgfTtcblxuY29uc3QgdHJpbGluZWFySW50ZXJwb2xhdGlvbiA9XG4gICAgKGlucHV0OiBJbmRpY2VzSGVscGVyLCBvdXRwdXQ6IEluZGljZXNIZWxwZXIsIGlucHV0U2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLCB1c2VFeHRyYXBvbGF0aW9uOiBib29sZWFuLFxuICAgICBleHRyYXBvbGF0aW9uVmFsdWU6IG51bWJlcik6IHN0cmluZyA9PiB7XG4gICAgICBjb25zdCBpc05jaHcgPSB0cnVlO1xuICAgICAgY29uc3QgW2JhdGNoSWR4LCBkZXB0aElkeCwgaGVpZ2h0SWR4LCB3aWR0aElkeCwgY2hhbm5lbElkeF0gPVxuICAgICAgICAgIGlucHV0U2hhcGUubGVuZ3RoID09PSAzID8gWy0xLCAwLCAxLCAyLCAtMV0gOiAoaXNOY2h3ID8gWzAsIDIsIDMsIDQsIDFdIDogWzAsIDEsIDIsIDMsIDRdKTtcbiAgICAgIGNvbnN0IGRUeXBlID0gaW5wdXQudHlwZS52YWx1ZTtcbiAgICAgIHJldHVybiBgXG4gICAgZm4gZ2V0SW5wdXRWYWx1ZShiYXRjaDogdTMyLCBjaGFubmVsOiB1MzIsIGRlcHRoOnUzMiwgaGVpZ2h0OiB1MzIsIHdpZHRoOiB1MzIpIC0+ICR7ZFR5cGV9IHtcbiAgICAgIHZhciBpbnB1dF9pbmRpY2VzOiAke2lucHV0LnR5cGUuaW5kaWNlc307XG4gICAgICAke2lucHV0LmluZGljZXNTZXQoJ2lucHV0X2luZGljZXMnLCBkZXB0aElkeCwgYG1heCgwLCBtaW4oZGVwdGgsICR7aW5wdXRTaGFwZVtkZXB0aElkeF19IC0gMSkpYCl9O1xuICAgICAgJHtpbnB1dC5pbmRpY2VzU2V0KCdpbnB1dF9pbmRpY2VzJywgaGVpZ2h0SWR4LCBgbWF4KDAsIG1pbihoZWlnaHQsICR7aW5wdXRTaGFwZVtoZWlnaHRJZHhdfSAtIDEpKWApfTtcbiAgICAgICR7aW5wdXQuaW5kaWNlc1NldCgnaW5wdXRfaW5kaWNlcycsIHdpZHRoSWR4LCBgbWF4KDAsIG1pbih3aWR0aCwgJHtpbnB1dFNoYXBlW3dpZHRoSWR4XX0gLSAxKSlgKX07XG4gICAgICAke3NldENoYW5uZWxBbmRCYXRjaEluZGljZXMoaW5wdXQsIGNoYW5uZWxJZHgsIGJhdGNoSWR4LCAzKX1cbiAgICAgIHJldHVybiAke2lucHV0LmdldEJ5SW5kaWNlcygnaW5wdXRfaW5kaWNlcycpfTtcbiAgICB9XG5cbiAgICBmbiB0cmlsaW5lYXJJbnRlcnBvbGF0aW9uKG91dHB1dF9pbmRpY2VzOiAke291dHB1dC50eXBlLmluZGljZXN9KSAtPiAke2RUeXBlfSB7XG4gICAgICB2YXIgb3JpZ2luYWxJbmRpY2VzID0gY2FsY3VsYXRlT3JpZ2luYWxJbmRpY2VzRnJvbU91dHB1dEluZGljZXMob3V0cHV0X2luZGljZXMpO1xuICAgICAgdmFyIGRlcHRoOiR7ZFR5cGV9ID0gb3JpZ2luYWxJbmRpY2VzWyR7ZGVwdGhJZHh9XTtcbiAgICAgIHZhciBoZWlnaHQ6JHtkVHlwZX0gPSBvcmlnaW5hbEluZGljZXNbJHtoZWlnaHRJZHh9XTtcbiAgICAgIHZhciB3aWR0aDoke2RUeXBlfSA9IG9yaWdpbmFsSW5kaWNlc1ske3dpZHRoSWR4fV07XG4gICAgICAke1xuICAgICAgICAgIHVzZUV4dHJhcG9sYXRpb24gPyBgaWYgKGRlcHRoIDwgMCB8fCBkZXB0aCA+ICgke2lucHV0U2hhcGVbZGVwdGhJZHhdfSAtIDEpIHx8IGhlaWdodCA8IDAgfHwgaGVpZ2h0ID4gKCR7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnB1dFNoYXBlW2hlaWdodElkeF19IC0gMSkgfHwgd2lkdGggPCAwIHx8ICh3aWR0aCA+ICR7aW5wdXRTaGFwZVt3aWR0aElkeF19IC0gMSkpIHtcbiAgICAgIHJldHVybiAke2V4dHJhcG9sYXRpb25WYWx1ZX07XG4gICAgICAgIH1gIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJyd9O1xuXG4gICAgZGVwdGggPSBtYXgoMCwgbWluKGRlcHRoLCAke2lucHV0U2hhcGVbZGVwdGhJZHhdfSAtIDEpKTtcbiAgICAgIGhlaWdodCA9IG1heCgwLCBtaW4oaGVpZ2h0LCAke2lucHV0U2hhcGVbaGVpZ2h0SWR4XX0gLSAxKSk7XG4gICAgICB3aWR0aCA9IG1heCgwLCBtaW4od2lkdGgsICR7aW5wdXRTaGFwZVt3aWR0aElkeF19IC0gMSkpO1xuICAgICAgdmFyIGRlcHRoMTogdTMyID0gdTMyKGRlcHRoKTtcbiAgICAgIHZhciBoZWlnaHQxOiB1MzIgPSB1MzIoaGVpZ2h0KTtcbiAgICAgIHZhciB3aWR0aDE6IHUzMiA9IHUzMih3aWR0aCk7XG4gICAgICB2YXIgZGVwdGgyOiB1MzIgPSB1MzIoZGVwdGggKyAxKTtcbiAgICAgIHZhciBoZWlnaHQyOiB1MzIgPSB1MzIoaGVpZ2h0ICsgMSk7XG4gICAgICB2YXIgd2lkdGgyOiB1MzIgPSB1MzIod2lkdGggKyAxKTtcbiAgICAgIHZhciBjaGFubmVsOiB1MzIgPSAke2lucHV0U2hhcGUubGVuZ3RoID4gMyA/IGB1MzIob3JpZ2luYWxJbmRpY2VzWyR7Y2hhbm5lbElkeH1dKWAgOiAnMCd9O1xuICAgICAgdmFyIGJhdGNoOiB1MzIgPSAgJHtpbnB1dFNoYXBlLmxlbmd0aCA+IDMgPyBgdTMyKG9yaWdpbmFsSW5kaWNlc1ske2JhdGNoSWR4fV0pYCA6ICcwJ307XG5cbiAgICAgIHZhciB4MTExOiAke2RUeXBlfSA9IGdldElucHV0VmFsdWUoYmF0Y2gsIGNoYW5uZWwsIGRlcHRoMSwgaGVpZ2h0MSwgd2lkdGgxKTtcbiAgICAgIHZhciB4MTEyOiAke2RUeXBlfSA9IGdldElucHV0VmFsdWUoYmF0Y2gsIGNoYW5uZWwsIGRlcHRoMSwgaGVpZ2h0MSwgd2lkdGgyKTtcbiAgICAgIHZhciB4MTIxOiAke2RUeXBlfSA9IGdldElucHV0VmFsdWUoYmF0Y2gsIGNoYW5uZWwsIGRlcHRoMSwgaGVpZ2h0Miwgd2lkdGgxKTtcbiAgICAgIHZhciB4MTIyOiAke2RUeXBlfSA9IGdldElucHV0VmFsdWUoYmF0Y2gsIGNoYW5uZWwsIGRlcHRoMSwgaGVpZ2h0Miwgd2lkdGgyKTtcbiAgICAgIHZhciB4MjExOiAke2RUeXBlfSA9IGdldElucHV0VmFsdWUoYmF0Y2gsIGNoYW5uZWwsIGRlcHRoMiwgaGVpZ2h0MSwgd2lkdGgxKTtcbiAgICAgIHZhciB4MjEyOiAke2RUeXBlfSA9IGdldElucHV0VmFsdWUoYmF0Y2gsIGNoYW5uZWwsIGRlcHRoMiwgaGVpZ2h0MSwgd2lkdGgyKTtcbiAgICAgIHZhciB4MjIxOiAke2RUeXBlfSA9IGdldElucHV0VmFsdWUoYmF0Y2gsIGNoYW5uZWwsIGRlcHRoMiwgaGVpZ2h0Miwgd2lkdGgxKTtcbiAgICAgIHZhciB4MjIyOiAke2RUeXBlfSA9IGdldElucHV0VmFsdWUoYmF0Y2gsIGNoYW5uZWwsIGRlcHRoMiwgaGVpZ2h0Miwgd2lkdGgyKTtcbiAgICAgIHZhciBkeDE6ICR7ZFR5cGV9ID0gYWJzKGRlcHRoIC0gJHtkVHlwZX0oZGVwdGgxKSk7XG4gICAgICB2YXIgZHgyOiAke2RUeXBlfSA9IGFicygke2RUeXBlfShkZXB0aDIpIC0gZGVwdGgpO1xuICAgICAgdmFyIGR5MTogJHtkVHlwZX0gPSBhYnMoaGVpZ2h0IC0gJHtkVHlwZX0oaGVpZ2h0MSkpO1xuICAgICAgdmFyIGR5MjogJHtkVHlwZX0gPSBhYnMoJHtkVHlwZX0oaGVpZ2h0MikgLSBoZWlnaHQpO1xuICAgICAgdmFyIGR6MTogJHtkVHlwZX0gPSBhYnMod2lkdGggLSAke2RUeXBlfSh3aWR0aDEpKTtcbiAgICAgIHZhciBkejI6ICR7ZFR5cGV9ID0gYWJzKCR7ZFR5cGV9KHdpZHRoMikgLSB3aWR0aCk7XG4gICAgICBpZiAoZGVwdGgxID09IGRlcHRoMikge1xuICAgICAgICBkeDEgPSAwLjU7XG4gICAgICAgIGR4MiA9IDAuNTtcbiAgICAgIH1cbiAgICAgIGlmIChoZWlnaHQxID09IGhlaWdodDIpIHtcbiAgICAgICAgZHkxID0gMC41O1xuICAgICAgICBkeTIgPSAwLjU7XG4gICAgICB9XG4gICAgICBpZiAod2lkdGgxID09IHdpZHRoMikge1xuICAgICAgICBkejEgPSAwLjU7XG4gICAgICAgIGR6MiA9IDAuNTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAoeDExMSAqIGR4MiAqIGR5MiAqIGR6MiArIHgxMTIgKiBkeDIgKiBkeTIgKiBkejEgKyB4MTIxICogZHgyICogZHkxICpkejIgKyB4MTIyICogZHgyICogZHkxICogZHoxICtcbiAgICAgICAgICAgICAgeDIxMSAqIGR4MSAqIGR5MiAqIGR6MiArIHgyMTIgKiBkeDEgKiBkeTIgKiBkejEgKyB4MjIxICogZHgxICogZHkxICpkejIgKyB4MjIyICogZHgxICogZHkxICogZHoxKTtcbiAgICB9YDtcbiAgICB9O1xuXG5jb25zdCBjcmVhdGVSZXNpemVQcm9ncmFtSW5mbyA9XG4gICAgKGlucHV0VGVuc29yOiBUZW5zb3JWaWV3LCBhdHRyaWJ1dGVzOiBSZXNpemVBdHRyaWJ1dGVzLCBvcHNldFZlcnNpb246IG51bWJlciwgc2NhbGVzSW5wdXQ6IHJlYWRvbmx5IG51bWJlcltdLFxuICAgICBzaXplczogcmVhZG9ubHkgbnVtYmVyW10sIHJvaUlucHV0OiByZWFkb25seSBudW1iZXJbXSk6IFByb2dyYW1JbmZvID0+IHtcbiAgICAgIGNvbnN0IGlucHV0U2hhcGUgPSBpbnB1dFRlbnNvci5kaW1zO1xuICAgICAgY29uc3Qgcm9pID0gdXBkYXRlUm9JKHJvaUlucHV0LCBhdHRyaWJ1dGVzLmF4ZXMsIGlucHV0U2hhcGUubGVuZ3RoKTtcblxuICAgICAgbGV0IG91dHB1dFNoYXBlID0gaW5pdE91dHB1dFNoYXBlKGlucHV0U2hhcGUsIHNjYWxlc0lucHV0LCBzaXplcywgYXR0cmlidXRlcy5heGVzKTtcbiAgICAgIGxldCBzY2FsZXMgPSBzY2FsZXNJbnB1dC5zbGljZSgpO1xuICAgICAgaWYgKHNjYWxlc0lucHV0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBzY2FsZXMgPSBpbnB1dFNoYXBlLm1hcCgodmFsdWUsIGluZGV4KSA9PiB2YWx1ZSA9PT0gMCA/IDEuMCA6IG91dHB1dFNoYXBlW2luZGV4XSAvIHZhbHVlKTtcbiAgICAgICAgaWYgKGF0dHJpYnV0ZXMua2VlcEFzcGVjdFJhdGlvUG9saWN5ICE9PSAnc3RyZXRjaCcpIHtcbiAgICAgICAgICBvdXRwdXRTaGFwZSA9IGFkanVzdE91dHB1dFNoYXBlKGlucHV0U2hhcGUsIHNjYWxlcywgYXR0cmlidXRlcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IG91dHB1dCA9IG91dHB1dFZhcmlhYmxlKCdvdXRwdXQnLCBpbnB1dFRlbnNvci5kYXRhVHlwZSwgb3V0cHV0U2hhcGUubGVuZ3RoKTtcbiAgICAgIGNvbnN0IGlucHV0ID0gaW5wdXRWYXJpYWJsZSgnaW5wdXQnLCBpbnB1dFRlbnNvci5kYXRhVHlwZSwgaW5wdXRTaGFwZS5sZW5ndGgpO1xuICAgICAgY29uc3Qgb3V0cHV0U2l6ZSA9IFNoYXBlVXRpbC5zaXplKG91dHB1dFNoYXBlKTtcbiAgICAgIGNvbnN0IG5vU2NhbGUgPSBpbnB1dFNoYXBlLmxlbmd0aCA9PT0gb3V0cHV0U2hhcGUubGVuZ3RoICYmIGlucHV0U2hhcGUuZXZlcnkoKGQsIGkpID0+IGQgPT09IG91dHB1dFNoYXBlW2ldKTtcbiAgICAgIGNvbnN0IHVzZUV4dHJhcG9sYXRpb24gPSBhdHRyaWJ1dGVzLmNvb3JkaW5hdGVUcmFuc2Zvcm1Nb2RlID09PSAndGZfY3JvcF9hbmRfcmVzaXplJztcbiAgICAgIGNvbnN0IGV4dHJhcG9sYXRpb25WYWx1ZSA9IGF0dHJpYnV0ZXMuZXh0cmFwb2xhdGlvblZhbHVlO1xuICAgICAgY29uc3QgZGF0YVR5cGUgPSBpbnB1dC50eXBlLnZhbHVlO1xuICAgICAgY29uc3QgZ2V0U2hhZGVyU291cmNlID0gKHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyKSA9PiBgXG4gICAgICAke25vU2NhbGUgPyAnJyA6IGBcbiAgICAgICR7Z2V0T3JpZ2luYWxDb29yZGluYXRlRnJvbVJlc2l6ZWRDb29yZGluYXRlKGF0dHJpYnV0ZXMuY29vcmRpbmF0ZVRyYW5zZm9ybU1vZGUsIGRhdGFUeXBlKX07XG4gICAgICAkeygoKSA9PiB7XG4gICAgICAgIHN3aXRjaCAoYXR0cmlidXRlcy5tb2RlKSB7XG4gICAgICAgICAgY2FzZSAnbmVhcmVzdCc6XG4gICAgICAgICAgICByZXR1cm4gYFxuICAgICAgICAgICAgICAke2NoZWNrSW5wdXRJbmRpY2VzKGlucHV0LCBpbnB1dFNoYXBlKX07XG4gICAgICAgICAgICAgICR7Z2V0TmVhcmVzdFBpeGVsRnJvbU9yaWdpbmFsKGF0dHJpYnV0ZXMubmVhcmVzdE1vZGUsIG9wc2V0VmVyc2lvbiwgZGF0YVR5cGUpfTtcbiAgICAgICAgICAgICAgJHtcbiAgICAgICAgICAgICAgICBjYWxjdWxhdGVJbnB1dEluZGljZXNGcm9tT3V0cHV0SW5kaWNlcyhcbiAgICAgICAgICAgICAgICAgICAgaW5wdXQsIG91dHB1dCwgaW5wdXRTaGFwZSwgb3V0cHV0U2hhcGUsIHNjYWxlcy5sZW5ndGgsIHJvaS5sZW5ndGgsIHVzZUV4dHJhcG9sYXRpb24pfTtcbiAgICAgICAgICAgICAgYDtcbiAgICAgICAgICBjYXNlICdsaW5lYXInOlxuICAgICAgICAgICAgcmV0dXJuIGBcbiAgICAgICAgICAgICAgJHtjYWxjdWxhdGVPcmlnaW5hbEluZGljZXNGcm9tT3V0cHV0SW5kaWNlcyhvdXRwdXQsIGlucHV0U2hhcGUsIG91dHB1dFNoYXBlLCBzY2FsZXMubGVuZ3RoLCByb2kubGVuZ3RoKX07XG4gICAgICAgICAgICAgICR7KCgpID0+IHtcbiAgICAgICAgICAgICAgaWYgKGlucHV0U2hhcGUubGVuZ3RoID09PSAyIHx8IGlucHV0U2hhcGUubGVuZ3RoID09PSA0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGAke2JpbGluZWFySW50ZXJwb2xhdGlvbihpbnB1dCwgb3V0cHV0LCBpbnB1dFNoYXBlLCB1c2VFeHRyYXBvbGF0aW9uLCBleHRyYXBvbGF0aW9uVmFsdWUpfWA7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoaW5wdXRTaGFwZS5sZW5ndGggPT09IDMgfHwgaW5wdXRTaGFwZS5sZW5ndGggPT09IDUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYCR7dHJpbGluZWFySW50ZXJwb2xhdGlvbihpbnB1dCwgb3V0cHV0LCBpbnB1dFNoYXBlLCB1c2VFeHRyYXBvbGF0aW9uLCBleHRyYXBvbGF0aW9uVmFsdWUpfWA7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ0xpbmVhciBtb2RlIG9ubHkgc3VwcG9ydHMgaW5wdXQgZGltcyAyLCAzLCA0IGFuZCA1IGFyZSBzdXBwb3J0ZWQgaW4gbGluZWFyIG1vZGUuJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKCl9O1xuICAgICAgICAgICAgYDtcbiAgICAgICAgICBjYXNlICdjdWJpYyc6XG4gICAgICAgICAgICByZXR1cm4gYFxuICAgICAgICAgICAgJHsoKCkgPT4ge1xuICAgICAgICAgICAgICBpZiAoaW5wdXRTaGFwZS5sZW5ndGggPT09IDIgfHwgaW5wdXRTaGFwZS5sZW5ndGggPT09IDQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYCR7XG4gICAgICAgICAgICAgICAgICAgIGJpY3ViaWNJbnRlcnBvbGF0aW9uKFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXQsIG91dHB1dCwgaW5wdXRTaGFwZSwgb3V0cHV0U2hhcGUsIHNjYWxlcywgcm9pLCBhdHRyaWJ1dGVzLmN1YmljQ29lZmZBLCB1c2VFeHRyYXBvbGF0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlcy5leHRyYXBvbGF0aW9uVmFsdWUsIGF0dHJpYnV0ZXMuZXhjbHVkZU91dHNpZGUpfWA7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ0N1YmljIG1vZGUgb25seSBzdXBwb3J0cyBpbnB1dCBkaW1zIDIgYW5kIDQgYXJlIHN1cHBvcnRlZCBpbiBsaW5lYXIgbW9kZS4nKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkoKX07XG4gICAgICAgICAgICBgO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBFcnJvcignSW52YWxpZCByZXNpemUgbW9kZScpO1xuICAgICAgICB9XG4gICAgICB9KSgpfTtcbiAgICAgIGB9XG4gICAgICAke1xuICAgICAgICAgIHNoYWRlckhlbHBlci5yZWdpc3RlclVuaWZvcm0oJ291dHB1dF9zaXplJywgJ3UzMicpXG4gICAgICAgICAgICAgIC5yZWdpc3RlclVuaWZvcm0oJ3NjYWxlcycsICdmMzInLCBzY2FsZXMubGVuZ3RoKVxuICAgICAgICAgICAgICAucmVnaXN0ZXJVbmlmb3JtKCdyb2knLCAnZjMyJywgcm9pLmxlbmd0aClcbiAgICAgICAgICAgICAgLmRlY2xhcmVWYXJpYWJsZXMoaW5wdXQsIG91dHB1dCl9XG4gICAgICAke3NoYWRlckhlbHBlci5tYWluU3RhcnQoKX1cbiAgICAgICAgJHtzaGFkZXJIZWxwZXIuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcygndW5pZm9ybXMub3V0cHV0X3NpemUnKX1cbiAgICAgICAgJHtub1NjYWxlID8gJ291dHB1dFtnbG9iYWxfaWR4XSA9IGlucHV0W2dsb2JhbF9pZHhdOycgOiBgXG4gICAgICAgIGxldCBvdXRwdXRfaW5kaWNlcyA9ICR7b3V0cHV0Lm9mZnNldFRvSW5kaWNlcygnZ2xvYmFsX2lkeCcpfTtcbiAgICAgICAgdmFyIGlucHV0X2luZGljZXM6ICR7aW5wdXQudHlwZS5pbmRpY2VzfTtcbiAgICAgICAgJHsoKCkgPT4ge1xuICAgICAgICBzd2l0Y2ggKGF0dHJpYnV0ZXMubW9kZSkge1xuICAgICAgICAgIGNhc2UgJ25lYXJlc3QnOlxuICAgICAgICAgICAgcmV0dXJuIGBpbnB1dF9pbmRpY2VzID0gY2FsY3VsYXRlSW5wdXRJbmRpY2VzRnJvbU91dHB1dEluZGljZXMob3V0cHV0X2luZGljZXMpO1xuICAgICAgICAgICAgICAgIGlmIChjaGVja0lucHV0SW5kaWNlcyhpbnB1dF9pbmRpY2VzKSkge1xuICAgICAgICAgICAgICAgICAgb3V0cHV0W2dsb2JhbF9pZHhdID0gJHtpbnB1dC5nZXRCeUluZGljZXMoJ2lucHV0X2luZGljZXMnKX07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIG91dHB1dFtnbG9iYWxfaWR4XSA9ICR7YXR0cmlidXRlcy5leHRyYXBvbGF0aW9uVmFsdWV9O1xuICAgICAgICAgICAgICAgIH1gO1xuICAgICAgICAgIGNhc2UgJ2xpbmVhcic6XG4gICAgICAgICAgICByZXR1cm4gYG91dHB1dFtnbG9iYWxfaWR4XSA9ICR7XG4gICAgICAgICAgICAgICAgKGlucHV0U2hhcGUubGVuZ3RoID09PSAyIHx8IGlucHV0U2hhcGUubGVuZ3RoID09PSA0KSA/ICdiaWxpbmVhckludGVycG9sYXRpb24nIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3RyaWxpbmVhckludGVycG9sYXRpb24nfShvdXRwdXRfaW5kaWNlcyk7YDtcbiAgICAgICAgICBjYXNlICdjdWJpYyc6XG4gICAgICAgICAgICByZXR1cm4gJ291dHB1dFtnbG9iYWxfaWR4XSA9IGJpY3ViaWNJbnRlcnBvbGF0aW9uKG91dHB1dF9pbmRpY2VzKTsnO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihgVW5zdXBwb3J0ZWQgcmVzaXplIG1vZGU6ICR7YXR0cmlidXRlcy5tb2RlfWApO1xuICAgICAgICB9XG4gICAgICB9KSgpfTtcbmB9XG4gICAgICB9YDtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZTogJ1Jlc2l6ZScsXG4gICAgICAgIHNoYWRlckNhY2hlOiB7XG4gICAgICAgICAgaGludDogYCR7YXR0cmlidXRlcy5jYWNoZUtleX18JHtvcHNldFZlcnNpb259fCR7c2NhbGVzLmxlbmd0aCA+IDAgPyBzY2FsZXMgOiAnJ318JHtcbiAgICAgICAgICAgICAgc2l6ZXMubGVuZ3RoID4gMCA/IHNpemVzIDogJyd9fCR7cm9pLmxlbmd0aCA+IDAgPyByb2kgOiAnJ318JHtub1NjYWxlfXwke2lucHV0U2hhcGV9YCxcbiAgICAgICAgICBpbnB1dERlcGVuZGVuY2llczogWydyYW5rJ11cbiAgICAgICAgfSxcbiAgICAgICAgZ2V0U2hhZGVyU291cmNlLFxuICAgICAgICBnZXRSdW5EYXRhOiAoKSA9PiAoe1xuICAgICAgICAgIG91dHB1dHM6IFt7ZGltczogb3V0cHV0U2hhcGUsIGRhdGFUeXBlOiBpbnB1dFRlbnNvci5kYXRhVHlwZX1dLFxuICAgICAgICAgIGRpc3BhdGNoR3JvdXA6IHt4OiBNYXRoLmNlaWwob3V0cHV0U2l6ZSAvIDY0IC8qIHdvcmtncm91cCBzaXplICovKX0sXG4gICAgICAgICAgcHJvZ3JhbVVuaWZvcm1zOiBbXG4gICAgICAgICAgICB7dHlwZTogJ3VpbnQzMicsIGRhdGE6IG91dHB1dFNpemV9LFxuICAgICAgICAgICAge3R5cGU6ICdmbG9hdDMyJywgZGF0YTogc2NhbGVzfSxcbiAgICAgICAgICAgIHt0eXBlOiAnZmxvYXQzMicsIGRhdGE6IHJvaX0sXG4gICAgICAgICAgICAuLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhpbnB1dFNoYXBlKSxcbiAgICAgICAgICAgIC4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKG91dHB1dFNoYXBlKSxcbiAgICAgICAgICBdXG4gICAgICAgIH0pXG4gICAgICB9O1xuICAgIH07XG5cbmNvbnN0IGdldE9wc2V0VmVyc2lvbkZyb21DdXN0b21EYXRhQnVmZmVyID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0KTogbnVtYmVyID0+IHtcbiAgY29uc3QgY3VzdG9tRGF0YUJ1ZmZlciA9IGNvbnRleHQuY3VzdG9tRGF0YUJ1ZmZlcjtcbiAgY29uc3QgY3VzdG9tRGF0YUJ1ZmZlcjMyID0gbmV3IFVpbnQzMkFycmF5KGN1c3RvbURhdGFCdWZmZXIsIGN1c3RvbURhdGFCdWZmZXIuYnl0ZU9mZnNldCwgMSk7XG4gIGNvbnN0IG9wc2V0VmVyc2lvbiA9IGN1c3RvbURhdGFCdWZmZXIzMlswXTtcbiAgcmV0dXJuIG9wc2V0VmVyc2lvbjtcbn07XG5cbmV4cG9ydCBjb25zdCByZXNpemUgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IFJlc2l6ZUF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgY29uc3Qgc2NhbGVzOiBudW1iZXJbXSA9IFtdO1xuICBjb25zdCBzaXplczogbnVtYmVyW10gPSBbXTtcbiAgY29uc3Qgcm9pOiBudW1iZXJbXSA9IFtdO1xuXG4gIC8vIE5vdGUgdGhhdCBzY2FsZXMgaW4gcmVzaXplIGFyZSBhbHdheXMgZjMyLiByb2kgY2FuIGJlIGYzMiBvciBmMTYuXG4gIC8vIFRPRE86IEN1cnJlbnRseSB0aGlzIGNvZGUgZG9lcyBub3Qgc3VwcG9ydCBmMTYgZm9yIHJvaSB3aGVuIHBhc3NlZCBhcyBvcHRpb25hbCBpbnB1dC5cblxuICBjb25zdCBvcHNldFZlcnNpb24gPSBnZXRPcHNldFZlcnNpb25Gcm9tQ3VzdG9tRGF0YUJ1ZmZlcihjb250ZXh0KTtcbiAgaWYgKGF0dHJpYnV0ZXMuYW50aWFsaWFzICE9PSAwKSB7XG4gICAgdGhyb3cgRXJyb3IoJ09ubHkgZGVmYXVsdCB2YWx1ZSAoMCkgZm9yIEFudGlhbGlhcyBhdHRyaWJ1dGUgaXMgc3VwcG9ydGVkJyk7XG4gIH1cbiAgdmFsaWRhdGVJbnB1dHMoY29udGV4dC5pbnB1dHMsIGF0dHJpYnV0ZXMsIG9wc2V0VmVyc2lvbiwgc2NhbGVzLCBzaXplcywgcm9pKTtcbiAgY29udGV4dC5jb21wdXRlKFxuICAgICAgY3JlYXRlUmVzaXplUHJvZ3JhbUluZm8oY29udGV4dC5pbnB1dHNbMF0sIGF0dHJpYnV0ZXMsIG9wc2V0VmVyc2lvbiwgc2NhbGVzLCBzaXplcywgcm9pKSwge2lucHV0czogWzBdfSk7XG59O1xuXG5leHBvcnQgY29uc3QgcGFyc2VSZXNpemVBdHRyaWJ1dGVzID0gKGF0dHJpYnV0ZXM6IFJlY29yZDxzdHJpbmcsIHVua25vd24+KTogUmVzaXplQXR0cmlidXRlcyA9PiB7XG4gIGNvbnN0IGFudGlhbGlhcyA9IGF0dHJpYnV0ZXMuYW50aWFsaWFzIGFzIG51bWJlcjtcbiAgY29uc3QgYXhlcyA9IGF0dHJpYnV0ZXMuYXhlcyBhcyBudW1iZXJbXTtcbiAgY29uc3QgY29vcmRpbmF0ZVRyYW5zZm9ybU1vZGU6IENvb3JkaW5hdGVUcmFuc2Zvcm1Nb2RlID1cbiAgICAgIGF0dHJpYnV0ZXMuY29vcmRpbmF0ZVRyYW5zZm9ybU1vZGUgYXMgQ29vcmRpbmF0ZVRyYW5zZm9ybU1vZGU7XG4gIGNvbnN0IGN1YmljQ29lZmZBID0gYXR0cmlidXRlcy5jdWJpY0NvZWZmQSBhcyBudW1iZXI7XG4gIGNvbnN0IGV4Y2x1ZGVPdXRzaWRlID0gYXR0cmlidXRlcy5leGNsdWRlT3V0c2lkZSBhcyBudW1iZXIgIT09IDA7XG4gIGNvbnN0IGV4dHJhcG9sYXRpb25WYWx1ZSA9IGF0dHJpYnV0ZXMuZXh0cmFwb2xhdGlvblZhbHVlIGFzIG51bWJlcjtcbiAgY29uc3Qga2VlcEFzcGVjdFJhdGlvUG9saWN5OiBLZWVwQXNwZWN0UmF0aW9Qb2xpY3kgPSBhdHRyaWJ1dGVzLmtlZXBBc3BlY3RSYXRpb1BvbGljeSBhcyBLZWVwQXNwZWN0UmF0aW9Qb2xpY3k7XG4gIGNvbnN0IG1vZGU6IE1vZGUgPSBhdHRyaWJ1dGVzLm1vZGUgYXMgTW9kZTtcbiAgLy8gSWYgbmVhcmVzdE1vZGUgaXMgbm90IHNwZWNpZmllZCwgdXNlIHNpbXBsZSBtb2RlLlxuICBjb25zdCBuZWFyZXN0TW9kZTogTmVhcmVzdE1vZGUgPSAoYXR0cmlidXRlcy5uZWFyZXN0TW9kZSA9PT0gJycgPyAnc2ltcGxlJyA6IGF0dHJpYnV0ZXMubmVhcmVzdE1vZGUpIGFzIE5lYXJlc3RNb2RlO1xuICByZXR1cm4gY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KHtcbiAgICBhbnRpYWxpYXMsXG4gICAgYXhlcyxcbiAgICBjb29yZGluYXRlVHJhbnNmb3JtTW9kZSxcbiAgICBjdWJpY0NvZWZmQSxcbiAgICBleGNsdWRlT3V0c2lkZSxcbiAgICBleHRyYXBvbGF0aW9uVmFsdWUsXG4gICAga2VlcEFzcGVjdFJhdGlvUG9saWN5LFxuICAgIG1vZGUsXG4gICAgbmVhcmVzdE1vZGVcbiAgfSk7XG59O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge0RhdGFUeXBlfSBmcm9tICcuLi8uLi8uLi93YXNtLWNvbW1vbic7XG5pbXBvcnQge1RlbnNvclZpZXd9IGZyb20gJy4uLy4uL3RlbnNvci12aWV3JztcbmltcG9ydCB7U2hhcGVVdGlsfSBmcm9tICcuLi8uLi91dGlsJztcbmltcG9ydCB7QXR0cmlidXRlV2l0aENhY2hlS2V5LCBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXl9IGZyb20gJy4uL2F0dHJpYnV0ZS13aXRoLWNhY2hlLWtleSc7XG5pbXBvcnQge0NvbXB1dGVDb250ZXh0LCBQcm9ncmFtSW5mb30gZnJvbSAnLi4vdHlwZXMnO1xuXG5pbXBvcnQge2Nhc3RUb0YzMiwgZmlsbFZlY3RvciwgZ2V0TWF4Q29tcG9uZW50cywgaW5wdXRWYXJpYWJsZSwgb3V0cHV0VmFyaWFibGUsIFNoYWRlckhlbHBlciwgc3VtVmVjdG9yLCB0ZW5zb3JUeXBlVG9Xc2dsU3RvcmFnZVR5cGUsfSBmcm9tICcuL2NvbW1vbic7XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2tpcExheWVyTm9ybUF0dHJpYnV0ZXMgZXh0ZW5kcyBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkge1xuICBlcHNpbG9uOiBudW1iZXI7XG59XG5cbmNvbnN0IHZhbGlkYXRlSW5wdXRzID0gKGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdKTogdm9pZCA9PiB7XG4gIGlmICghaW5wdXRzIHx8IGlucHV0cy5sZW5ndGggPCAzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdsYXllck5vcm0gcmVxdWlyZXMgYXQgbGVhc3QgMyBpbnB1dHMuJyk7XG4gIH1cblxuICBjb25zdCBpbnB1dDogVGVuc29yVmlldyA9IGlucHV0c1swXTtcbiAgY29uc3Qgc2tpcDogVGVuc29yVmlldyA9IGlucHV0c1sxXTtcbiAgY29uc3QgZ2FtbWE6IFRlbnNvclZpZXcgPSBpbnB1dHNbMl07XG5cbiAgaWYgKGlucHV0LmRhdGFUeXBlICE9PSBza2lwLmRhdGFUeXBlIHx8IGlucHV0LmRhdGFUeXBlICE9PSBnYW1tYS5kYXRhVHlwZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignQWxsIGlucHV0cyBtdXN0IGhhdmUgdGhlIHNhbWUgZGF0YSB0eXBlJyk7XG4gIH1cblxuICBpZiAoaW5wdXQuZGltcy5sZW5ndGggIT09IDMgJiYgaW5wdXQuZGltcy5sZW5ndGggIT09IDIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IG11c3QgYmUgMkQgb3IgM0QnKTtcbiAgfVxuXG4gIGlmIChza2lwLmRpbXMubGVuZ3RoICE9PSAzICYmIHNraXAuZGltcy5sZW5ndGggIT09IDIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1NraXAgbXVzdCBiZSAyRCBvciAzRCcpO1xuICB9XG5cbiAgY29uc3QgaGlkZGVuU2l6ZSA9IGlucHV0LmRpbXNbaW5wdXQuZGltcy5sZW5ndGggLSAxXTtcbiAgY29uc3Qgc2VxdWVuY2VMZW5ndGggPSBpbnB1dC5kaW1zW2lucHV0LmRpbXMubGVuZ3RoIC0gMl07XG4gIGlmIChza2lwLmRpbXNbc2tpcC5kaW1zLmxlbmd0aCAtIDFdICE9PSBoaWRkZW5TaXplKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdTa2lwIG11c3QgaGF2ZSB0aGUgc2FtZSBoaWRkZW4gc2l6ZSBhcyBpbnB1dCcpO1xuICB9XG4gIGlmIChza2lwLmRpbXNbc2tpcC5kaW1zLmxlbmd0aCAtIDJdICE9PSBzZXF1ZW5jZUxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcignU2tpcCBtdXN0IGhhdmUgdGhlIHNhbWUgc2VxdWVuY2UgbGVuZ3RoIGFzIGlucHV0Jyk7XG4gIH1cblxuICBpZiAoZ2FtbWEuZGltcy5sZW5ndGggIT09IDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0dhbW1hIG11c3QgYmUgMUQnKTtcbiAgfVxuICBpZiAoZ2FtbWEuZGltc1tnYW1tYS5kaW1zLmxlbmd0aCAtIDFdICE9PSBoaWRkZW5TaXplKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdHYW1tYSBtdXN0IGhhdmUgdGhlIHNhbWUgaGlkZGVuIHNpemUgYXMgaW5wdXQnKTtcbiAgfVxuICBpZiAoaW5wdXRzLmxlbmd0aCA+IDMpIHtcbiAgICBjb25zdCBiZXRhOiBUZW5zb3JWaWV3ID0gaW5wdXRzWzNdO1xuICAgIGlmIChiZXRhLmRpbXMubGVuZ3RoICE9PSAxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0JldGEgbXVzdCBiZSAxRCcpO1xuICAgIH1cbiAgICBpZiAoYmV0YS5kaW1zW2JldGEuZGltcy5sZW5ndGggLSAxXSAhPT0gaGlkZGVuU2l6ZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdCZXRhIG11c3QgaGF2ZSB0aGUgc2FtZSBoaWRkZW4gc2l6ZSBhcyBpbnB1dCcpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChpbnB1dHMubGVuZ3RoID4gNCkge1xuICAgIGNvbnN0IGJpYXM6IFRlbnNvclZpZXcgPSBpbnB1dHNbNF07XG4gICAgaWYgKGJpYXMuZGltcy5sZW5ndGggIT09IDEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQmlhcyBtdXN0IGJlIDFEJyk7XG4gICAgfVxuICAgIGlmIChiaWFzLmRpbXNbYmlhcy5kaW1zLmxlbmd0aCAtIDFdICE9PSBoaWRkZW5TaXplKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0JpYXMgbXVzdCBoYXZlIHRoZSBzYW1lIGhpZGRlbiBzaXplIGFzIGlucHV0Jyk7XG4gICAgfVxuICB9XG59O1xuXG5jb25zdCBjcmVhdGVTa2lwTGF5ZXJOb3JtUHJvZ3JhbUluZm8gPVxuICAgIChpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSwgYXR0cmlidXRlczogU2tpcExheWVyTm9ybUF0dHJpYnV0ZXMsIG91dHB1dENvdW50OiBudW1iZXIsIGlzVHJhaW5pbmc6IGJvb2xlYW4pOlxuICAgICAgICBQcm9ncmFtSW5mbyA9PiB7XG4gICAgICAgICAgY29uc3QgaW5wdXRTaGFwZSA9IGlucHV0c1swXS5kaW1zO1xuICAgICAgICAgIGNvbnN0IGlucHV0U2l6ZSA9IFNoYXBlVXRpbC5zaXplKGlucHV0U2hhcGUpO1xuICAgICAgICAgIGNvbnN0IG91dHB1dFNoYXBlID0gaW5wdXRTaGFwZTtcbiAgICAgICAgICBjb25zdCBvdXRwdXRTaXplID0gaW5wdXRTaXplO1xuICAgICAgICAgIGNvbnN0IGhpZGRlblNpemUgPSBpbnB1dFNoYXBlLnNsaWNlKC0xKVswXTtcbiAgICAgICAgICBjb25zdCBtZWFuSW52U3RkRGV2RGltID0gaXNUcmFpbmluZyA/IGlucHV0U2hhcGUuc2xpY2UoMCwgLTEpLmNvbmNhdCgxKSA6IFtdO1xuICAgICAgICAgIGNvbnN0IGhhc0JldGFJbnB1dCA9IGlucHV0cy5sZW5ndGggPiAzO1xuICAgICAgICAgIGNvbnN0IGhhc0JpYXNJbnB1dCA9IGlucHV0cy5sZW5ndGggPiA0O1xuICAgICAgICAgIGNvbnN0IGhhc01lYW5PdXRwdXQgPSBpc1RyYWluaW5nICYmIG91dHB1dENvdW50ID4gMTtcbiAgICAgICAgICBjb25zdCBoYXNJbnZTdGREZXZPdXRwdXQgPSBpc1RyYWluaW5nICYmIG91dHB1dENvdW50ID4gMjtcbiAgICAgICAgICBjb25zdCBoYXNJbnB1dFNraXBCaWFzU3VtT3V0cHV0ID0gb3V0cHV0Q291bnQgPiAzO1xuXG4gICAgICAgICAgY29uc3QgY29tcG9uZW50cyA9IGdldE1heENvbXBvbmVudHMoaGlkZGVuU2l6ZSk7XG4gICAgICAgICAgY29uc3QgdmFyaWFibGVzID0gW1xuICAgICAgICAgICAgaW5wdXRWYXJpYWJsZSgneCcsIGlucHV0c1swXS5kYXRhVHlwZSwgaW5wdXRzWzBdLmRpbXMsIGNvbXBvbmVudHMpLFxuICAgICAgICAgICAgaW5wdXRWYXJpYWJsZSgnc2tpcCcsIGlucHV0c1sxXS5kYXRhVHlwZSwgaW5wdXRzWzFdLmRpbXMsIGNvbXBvbmVudHMpLFxuICAgICAgICAgICAgaW5wdXRWYXJpYWJsZSgnZ2FtbWEnLCBpbnB1dHNbMl0uZGF0YVR5cGUsIGlucHV0c1syXS5kaW1zLCBjb21wb25lbnRzKSxcbiAgICAgICAgICBdO1xuICAgICAgICAgIGlmIChoYXNCZXRhSW5wdXQpIHtcbiAgICAgICAgICAgIHZhcmlhYmxlcy5wdXNoKGlucHV0VmFyaWFibGUoJ2JldGEnLCBpbnB1dHNbM10uZGF0YVR5cGUsIGlucHV0c1szXS5kaW1zLCBjb21wb25lbnRzKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChoYXNCaWFzSW5wdXQpIHtcbiAgICAgICAgICAgIHZhcmlhYmxlcy5wdXNoKGlucHV0VmFyaWFibGUoJ2JpYXMnLCBpbnB1dHNbNF0uZGF0YVR5cGUsIGlucHV0c1s0XS5kaW1zLCBjb21wb25lbnRzKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhcmlhYmxlcy5wdXNoKG91dHB1dFZhcmlhYmxlKCdvdXRwdXQnLCBpbnB1dHNbMF0uZGF0YVR5cGUsIG91dHB1dFNoYXBlLCBjb21wb25lbnRzKSk7XG4gICAgICAgICAgaWYgKGhhc01lYW5PdXRwdXQpIHtcbiAgICAgICAgICAgIHZhcmlhYmxlcy5wdXNoKG91dHB1dFZhcmlhYmxlKCdtZWFuT3V0cHV0JywgRGF0YVR5cGUuZmxvYXQsIG1lYW5JbnZTdGREZXZEaW0pKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGhhc0ludlN0ZERldk91dHB1dCkge1xuICAgICAgICAgICAgdmFyaWFibGVzLnB1c2gob3V0cHV0VmFyaWFibGUoJ2ludlN0ZE91dHB1dCcsIERhdGFUeXBlLmZsb2F0LCBtZWFuSW52U3RkRGV2RGltKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChoYXNJbnB1dFNraXBCaWFzU3VtT3V0cHV0KSB7XG4gICAgICAgICAgICB2YXJpYWJsZXMucHVzaChvdXRwdXRWYXJpYWJsZSgnaW5wdXRTa2lwQmlhc1N1bScsIGlucHV0c1swXS5kYXRhVHlwZSwgb3V0cHV0U2hhcGUsIGNvbXBvbmVudHMpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgZGF0YVR5cGUgPSB0ZW5zb3JUeXBlVG9Xc2dsU3RvcmFnZVR5cGUoaW5wdXRzWzBdLmRhdGFUeXBlKTtcbiAgICAgICAgICBjb25zdCBnZXRTaGFkZXJTb3VyY2UgPSAoc2hhZGVySGVscGVyOiBTaGFkZXJIZWxwZXIpID0+IGBcbiAgICAgIGNvbnN0IGhpZGRlblNpemU6IGYzMiA9ICR7aGlkZGVuU2l6ZX07XG4gICAgICBjb25zdCBoaWRkZW5TaXplVmVjdG9yaXplZDogdTMyID0gJHtoaWRkZW5TaXplIC8gY29tcG9uZW50c307XG4gICAgICBjb25zdCBlcHNpbG9uOiBmMzIgPSAke2F0dHJpYnV0ZXMuZXBzaWxvbn07XG5cbiAgICAgICR7c2hhZGVySGVscGVyLmRlY2xhcmVWYXJpYWJsZXMoLi4udmFyaWFibGVzKX1cblxuICAgICAgJHtzaGFkZXJIZWxwZXIubWFpblN0YXJ0KCl9XG4gICAgICAgICR7c2hhZGVySGVscGVyLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMob3V0cHV0U2l6ZSAvIGhpZGRlblNpemUpfVxuICAgICAgICBsZXQgb2Zmc2V0ID0gZ2xvYmFsX2lkeCAqIGhpZGRlblNpemVWZWN0b3JpemVkO1xuICAgICAgICB2YXIgc3VtID0gJHtmaWxsVmVjdG9yKCdmMzInLCBjb21wb25lbnRzKX07XG4gICAgICAgIHZhciBzcXVhcmVTdW0gPSAke2ZpbGxWZWN0b3IoJ2YzMicsIGNvbXBvbmVudHMpfTtcbiAgICAgICAgZm9yICh2YXIgaTogdTMyID0gMDsgaSA8IGhpZGRlblNpemVWZWN0b3JpemVkOyBpKyspIHtcbiAgICAgICAgICBsZXQgc2tpcFZhbHVlID0gc2tpcFtvZmZzZXQgKyBpXTtcbiAgICAgICAgICBsZXQgYmlhc1ZhbHVlID0gJHtoYXNCaWFzSW5wdXQgPyAnYmlhc1tpXScgOiAnMC4wJ307XG4gICAgICAgICAgbGV0IGlucHV0VmFsdWUgPSB4W29mZnNldCArIGldO1xuICAgICAgICAgIGxldCB2YWx1ZSA9IGlucHV0VmFsdWUgKyBza2lwVmFsdWUgKyBiaWFzVmFsdWU7XG4gICAgICAgICAgJHtoYXNJbnB1dFNraXBCaWFzU3VtT3V0cHV0ID8gJ2lucHV0U2tpcEJpYXNTdW1bb2Zmc2V0ICsgaV0gPSB2YWx1ZTsnIDogJyd9XG4gICAgICAgICAgb3V0cHV0W29mZnNldCArIGldID0gdmFsdWU7XG4gICAgICAgICAgbGV0IGYzMlZhbHVlID0gJHtjYXN0VG9GMzIoZGF0YVR5cGUsIGNvbXBvbmVudHMsICd2YWx1ZScpfTtcbiAgICAgICAgICBzdW0gKz0gZjMyVmFsdWU7XG4gICAgICAgICAgc3F1YXJlU3VtICs9IGYzMlZhbHVlICogZjMyVmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG1lYW4gPSAke3N1bVZlY3Rvcignc3VtJywgY29tcG9uZW50cyl9IC8gaGlkZGVuU2l6ZTtcbiAgICAgICAgbGV0IGludlN0ZERldiA9IGludmVyc2VTcXJ0KCR7c3VtVmVjdG9yKCdzcXVhcmVTdW0nLCBjb21wb25lbnRzKX0gLyBoaWRkZW5TaXplIC0gbWVhbiAqIG1lYW4gKyBlcHNpbG9uKTtcbiAgICAgICAgJHtoYXNNZWFuT3V0cHV0ID8gJ21lYW5PdXRwdXRbZ2xvYmFsX2lkeF0gPSBtZWFuOycgOiAnJ31cbiAgICAgICAgJHtoYXNJbnZTdGREZXZPdXRwdXQgPyAnaW52U3RkT3V0cHV0W2dsb2JhbF9pZHhdID0gaW52U3RkRGV2OycgOiAnJ31cbiAgICAgICAgZm9yICh2YXIgaTogdTMyID0gMDsgaSA8IGhpZGRlblNpemVWZWN0b3JpemVkOyBpKyspIHtcbiAgICAgICAgICBvdXRwdXRbb2Zmc2V0ICsgaV0gPSAob3V0cHV0W29mZnNldCArIGldIC0gJHtkYXRhVHlwZX0obWVhbikpICogJHtkYXRhVHlwZX0oaW52U3RkRGV2KSAqIGdhbW1hW2ldXG4gICAgICAgICAgICsgJHtoYXNCZXRhSW5wdXQgPyAnYmV0YVtpXScgOiAnMC4wJ307XG4gICAgICAgIH1cbiAgICAgIH1gO1xuICAgICAgICAgIGNvbnN0IG91dHB1dHMgPSBbe2RpbXM6IG91dHB1dFNoYXBlLCBkYXRhVHlwZTogaW5wdXRzWzBdLmRhdGFUeXBlfV07XG4gICAgICAgICAgaWYgKG91dHB1dENvdW50ID4gMSkge1xuICAgICAgICAgICAgb3V0cHV0cy5wdXNoKHtkaW1zOiBtZWFuSW52U3RkRGV2RGltLCBkYXRhVHlwZTogRGF0YVR5cGUuZmxvYXR9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG91dHB1dENvdW50ID4gMikge1xuICAgICAgICAgICAgb3V0cHV0cy5wdXNoKHtkaW1zOiBtZWFuSW52U3RkRGV2RGltLCBkYXRhVHlwZTogRGF0YVR5cGUuZmxvYXR9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG91dHB1dENvdW50ID4gMykge1xuICAgICAgICAgICAgb3V0cHV0cy5wdXNoKHtkaW1zOiBpbnB1dFNoYXBlLCBkYXRhVHlwZTogaW5wdXRzWzBdLmRhdGFUeXBlfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5hbWU6ICdTa2lwTGF5ZXJOb3JtYWxpemF0aW9uJyxcbiAgICAgICAgICAgIHNoYWRlckNhY2hlOiB7aGludDogYXR0cmlidXRlcy5jYWNoZUtleX0sXG4gICAgICAgICAgICBnZXRTaGFkZXJTb3VyY2UsXG4gICAgICAgICAgICBnZXRSdW5EYXRhOiAoKSA9PiAoe291dHB1dHMsIGRpc3BhdGNoR3JvdXA6IHt4OiBNYXRoLmNlaWwob3V0cHV0U2l6ZSAvIGhpZGRlblNpemUgLyA2NCl9fSksXG4gICAgICAgICAgfTtcbiAgICAgICAgfTtcblxuZXhwb3J0IGNvbnN0IHNraXBMYXllck5vcm0gPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IFNraXBMYXllck5vcm1BdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIC8vIFRPRE86IGluaXRpYWxpemUgaXNUcmFpbmluZyBmcm9tIENvbXB1dGVDb250ZXh0XG4gIGNvbnN0IGlzVHJhaW5pbmcgPSBmYWxzZTtcbiAgdmFsaWRhdGVJbnB1dHMoY29udGV4dC5pbnB1dHMpO1xuICAvLyBNZWFuIGFuZCBJbnZTdGREZXYgYXJlIG9ubHkgdXNlZCBpbiB0cmFpbmluZyBtb2RlIGFuZCBhcmUgbm90IHJlcXVpcmVkIGZvciBpbmZlcmVuY2UuXG4gIC8vIFRoZXkgYXJlIGFkZGVkIGhlcmUgZm9yIGNvbXBsZXRlbmVzcyBvbmx5LlxuICBjb25zdCBvdXRwdXRzID0gWzBdO1xuICBpZiAoY29udGV4dC5vdXRwdXRDb3VudCA+IDEpIHtcbiAgICBvdXRwdXRzLnB1c2goaXNUcmFpbmluZyA/IDEgOiAtMyk7XG4gIH1cbiAgaWYgKGNvbnRleHQub3V0cHV0Q291bnQgPiAyKSB7XG4gICAgb3V0cHV0cy5wdXNoKGlzVHJhaW5pbmcgPyAyIDogLTMpO1xuICB9XG4gIGlmIChjb250ZXh0Lm91dHB1dENvdW50ID4gMykge1xuICAgIG91dHB1dHMucHVzaCgzKTtcbiAgfVxuICBjb250ZXh0LmNvbXB1dGUoXG4gICAgICBjcmVhdGVTa2lwTGF5ZXJOb3JtUHJvZ3JhbUluZm8oY29udGV4dC5pbnB1dHMsIGF0dHJpYnV0ZXMsIGNvbnRleHQub3V0cHV0Q291bnQsIGlzVHJhaW5pbmcpLCB7b3V0cHV0c30pO1xufTtcblxuZXhwb3J0IGNvbnN0IHBhcnNlU2tpcExheWVyTm9ybUF0dHJpYnV0ZXMgPSAoYXR0cmlidXRlczogUmVjb3JkPHN0cmluZywgdW5rbm93bj4pOiBTa2lwTGF5ZXJOb3JtQXR0cmlidXRlcyA9PiB7XG4gIGNvbnN0IGVwc2lsb24gPSBhdHRyaWJ1dGVzLmVwc2lsb24gYXMgbnVtYmVyO1xuICByZXR1cm4gY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KHtlcHNpbG9ufSk7XG59O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge0RhdGFUeXBlfSBmcm9tICcuLi8uLi8uLi93YXNtLWNvbW1vbic7XG5pbXBvcnQge1RlbnNvclZpZXd9IGZyb20gJy4uLy4uL3RlbnNvci12aWV3JztcbmltcG9ydCB7U2hhcGVVdGlsfSBmcm9tICcuLi8uLi91dGlsJztcbmltcG9ydCB7QXR0cmlidXRlV2l0aENhY2hlS2V5LCBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXl9IGZyb20gJy4uL2F0dHJpYnV0ZS13aXRoLWNhY2hlLWtleSc7XG5pbXBvcnQge0NvbXB1dGVDb250ZXh0LCBQcm9ncmFtSW5mbywgUHJvZ3JhbVVuaWZvcm0sIFRlbnNvckluZm99IGZyb20gJy4uL3R5cGVzJztcblxuaW1wb3J0IHtjcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcywgZ2V0RWxlbWVudEF0LCBJbmRpY2VzSGVscGVyLCBpbnB1dFZhcmlhYmxlLCBvdXRwdXRWYXJpYWJsZSwgU2hhZGVySGVscGVyLCBVbmlmb3Jtc0FycmF5VHlwZX0gZnJvbSAnLi9jb21tb24nO1xuXG5leHBvcnQgaW50ZXJmYWNlIFNsaWNlQXR0cmlidXRlcyBleHRlbmRzIEF0dHJpYnV0ZVdpdGhDYWNoZUtleSB7XG4gIHJlYWRvbmx5IHN0YXJ0czogbnVtYmVyW107XG4gIHJlYWRvbmx5IGVuZHM6IG51bWJlcltdO1xuICByZWFkb25seSBheGVzOiBudW1iZXJbXTtcbn1cblxuY29uc3QgdmFsaWRhdGVJbnB1dHMgPSAoaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10sIGF0dHJpYnV0ZXM6IFNsaWNlQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICBpZiAoIWlucHV0cyB8fCBpbnB1dHMubGVuZ3RoIDwgMSkge1xuICAgIHRocm93IG5ldyBFcnJvcigndG9vIGZldyBpbnB1dHMnKTtcbiAgfVxuICBpZiAoYXR0cmlidXRlcy5heGVzLmxlbmd0aCAhPT0gMCkge1xuICAgIGlmIChhdHRyaWJ1dGVzLmF4ZXMubGVuZ3RoICE9PSBhdHRyaWJ1dGVzLnN0YXJ0cy5sZW5ndGggfHwgYXR0cmlidXRlcy5heGVzLmxlbmd0aCAhPT0gYXR0cmlidXRlcy5lbmRzLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdheGVzLCBzdGFydHMgYW5kIGVuZHMgbXVzdCBoYXZlIHRoZSBzYW1lIGxlbmd0aCcpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChhdHRyaWJ1dGVzLnN0YXJ0cy5sZW5ndGggIT09IGF0dHJpYnV0ZXMuZW5kcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3N0YXJ0cyBhbmQgZW5kcyBtdXN0IGhhdmUgdGhlIHNhbWUgbGVuZ3RoJyk7XG4gIH1cbiAgaW5wdXRzLnNsaWNlKDEpLmZvckVhY2goKF8sIGlkeCkgPT4ge1xuICAgIGlmIChpbnB1dHNbaWR4ICsgMV0uZGF0YVR5cGUgIT09IERhdGFUeXBlLmludDMyICYmIGlucHV0c1tpZHggKyAxXS5kYXRhVHlwZSAhPT0gRGF0YVR5cGUuaW50NjQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW5wdXQgJHtpZHh9IG11c3QgYmUgYW4gYXJyYXkgb2YgaW50MzIgb3IgaW50NjRgKTtcbiAgICB9XG4gIH0pO1xufTtcblxuY29uc3QgcmVhZElucHV0ID0gKGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdLCBpZHg6IG51bWJlcik6IG51bWJlcltdID0+IHtcbiAgY29uc3QgaW5wdXQ6IG51bWJlcltdID0gW107XG4gIGlmIChpbnB1dHMubGVuZ3RoID4gaWR4KSB7XG4gICAgaWYgKGlucHV0c1tpZHhdLmRhdGFUeXBlID09PSBEYXRhVHlwZS5pbnQ2NCkge1xuICAgICAgaW5wdXRzW2lkeF0uZ2V0QmlnSW50NjRBcnJheSgpLmZvckVhY2godiA9PiBpbnB1dC5wdXNoKE51bWJlcih2KSkpO1xuICAgIH0gZWxzZSBpZiAoaW5wdXRzW2lkeF0uZGF0YVR5cGUgPT09IERhdGFUeXBlLmludDMyKSB7XG4gICAgICBpbnB1dHNbaWR4XS5nZXRJbnQzMkFycmF5KCkuZm9yRWFjaCh2ID0+IGlucHV0LnB1c2goTnVtYmVyKHYpKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW5wdXQgJHtpZHh9IG11c3QgYmUgYW4gYXJyYXkgb2YgaW50MzIgb3IgaW50NjRgKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGlucHV0O1xufTtcblxuY29uc3QgY3JlYXRlU2xpY2VBdHRyaWJ1dGVzRnJvbUlucHV0cyA9XG4gICAgKGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdLCBhdHRyaWJ1dGVzOiBTbGljZUF0dHJpYnV0ZXMpOiBTbGljZUF0dHJpYnV0ZXMgPT4ge1xuICAgICAgaWYgKGlucHV0cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0czogbnVtYmVyW10gPSByZWFkSW5wdXQoaW5wdXRzLCAxKTtcbiAgICAgICAgY29uc3QgZW5kczogbnVtYmVyW10gPSByZWFkSW5wdXQoaW5wdXRzLCAyKTtcbiAgICAgICAgbGV0IGF4ZXM6IG51bWJlcltdID0gcmVhZElucHV0KGlucHV0cywgMyk7XG4gICAgICAgIGlmIChheGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIGF4ZXMgPSBbLi4uQXJyYXkoaW5wdXRzWzBdLmRpbXMubGVuZ3RoKS5rZXlzKCldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkoe3N0YXJ0cywgZW5kcywgYXhlc30pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGF0dHJpYnV0ZXM7XG4gICAgICB9XG4gICAgfTtcblxuY29uc3QgZml4U3RhcnRFbmRWYWx1ZXMgPVxuICAgICh2YWx1ZTogbnVtYmVyLCBpbmRleDogbnVtYmVyLCBpbnB1dFNoYXBlOiByZWFkb25seSBudW1iZXJbXSwgYXhlczogcmVhZG9ubHkgbnVtYmVyW10sIHN0ZXBzOiByZWFkb25seSBudW1iZXJbXSk6XG4gICAgICAgIG51bWJlciA9PiB7XG4gICAgICAgICAgbGV0IG5ld1ZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgaWYgKHZhbHVlIDwgMCkge1xuICAgICAgICAgICAgbmV3VmFsdWUgKz0gaW5wdXRTaGFwZVtheGVzW2luZGV4XV07XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzdGVwc1tpbmRleF0gPCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5tYXgoMCwgTWF0aC5taW4obmV3VmFsdWUsIGlucHV0U2hhcGVbYXhlc1tpbmRleF1dIC0gMSkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5tYXgoMCwgTWF0aC5taW4obmV3VmFsdWUsIGlucHV0U2hhcGVbYXhlc1tpbmRleF1dKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG5jb25zdCBjYWxjdWxhdGVJbnB1dEluZGljZXNJbXBsID1cbiAgICAoaW5wdXQ6IEluZGljZXNIZWxwZXIsIG91dHB1dDogSW5kaWNlc0hlbHBlciwgaW5wdXRTaGFwZTogcmVhZG9ubHkgbnVtYmVyW10pOiBzdHJpbmcgPT5cbiAgICAgICAgYGZuIGNhbGN1bGF0ZUlucHV0SW5kaWNlcyhvdXRwdXRfaW5kaWNlczogJHtvdXRwdXQudHlwZS5pbmRpY2VzfSkgLT4gJHtpbnB1dC50eXBlLmluZGljZXN9IHtcbiAgICAgICAgICB2YXIgaW5wdXRfaW5kaWNlczogJHtpbnB1dC50eXBlLmluZGljZXN9O1xuICAgICAgICAgIHZhciBjYXJyeSA9IDB1O1xuICAgICAgICAgIGZvciAodmFyIGkgPSAke2lucHV0U2hhcGUubGVuZ3RofTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGxldCBpbnB1dF9zaGFwZV9pID0gJHtnZXRFbGVtZW50QXQoJ3VuaWZvcm1zLmlucHV0X3NoYXBlJywgJ2knLCBpbnB1dFNoYXBlLmxlbmd0aCl9O1xuICAgICAgICAgICAgbGV0IHN0ZXBzX2kgPSAke2dldEVsZW1lbnRBdCgndW5pZm9ybXMuc3RlcHMnLCAnaScsIGlucHV0U2hhcGUubGVuZ3RoKX07XG4gICAgICAgICAgICBsZXQgc2lnbnNfaSA9ICR7Z2V0RWxlbWVudEF0KCd1bmlmb3Jtcy5zaWducycsICdpJywgaW5wdXRTaGFwZS5sZW5ndGgpfTtcbiAgICAgICAgICAgIGxldCBzdGFydHNfaSA9ICR7Z2V0RWxlbWVudEF0KCd1bmlmb3Jtcy5zdGFydHMnLCAnaScsIGlucHV0U2hhcGUubGVuZ3RoKX07XG4gICAgICAgICAgICB2YXIgb3V0cHV0X2luZGV4ID0gJHtvdXRwdXQuaW5kaWNlc0dldCgnb3V0cHV0X2luZGljZXMnLCAnaScpfTtcbiAgICAgICAgICAgIHZhciBpbnB1dF9pbmRleCA9IG91dHB1dF9pbmRleCAqIHN0ZXBzX2kgKyBzdGFydHNfaSArIGNhcnJ5O1xuICAgICAgICAgICAgY2FycnkgPSBpbnB1dF9pbmRleCAvIGlucHV0X3NoYXBlX2k7XG4gICAgICAgICAgICBpbnB1dF9pbmRleCA9IGlucHV0X2luZGV4ICUgaW5wdXRfc2hhcGVfaTtcbiAgICAgICAgICAgIGlmIChzaWduc19pIDwgMCkge1xuICAgICAgICAgICAgICBpbnB1dF9pbmRleCA9IGlucHV0X3NoYXBlX2kgLSBpbnB1dF9pbmRleCAtIDF1ICsgc3RhcnRzX2k7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAke2lucHV0LmluZGljZXNTZXQoJ2lucHV0X2luZGljZXMnLCAnaScsICdpbnB1dF9pbmRleCcpfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGlucHV0X2luZGljZXM7XG4gICAgICB9YDtcblxuY29uc3QgY3JlYXRlU2xpY2VQcm9ncmFtSW5mbyA9IChpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSwgYXR0cmlidXRlczogU2xpY2VBdHRyaWJ1dGVzKTogUHJvZ3JhbUluZm8gPT4ge1xuICBjb25zdCBpbnB1dFNoYXBlID0gaW5wdXRzWzBdLmRpbXM7XG4gIGNvbnN0IGlucHV0U2l6ZSA9IFNoYXBlVXRpbC5zaXplKGlucHV0U2hhcGUpO1xuICBjb25zdCBheGVzID0gKGF0dHJpYnV0ZXMuYXhlcy5sZW5ndGggPiAwKSA/IFNoYXBlVXRpbC5ub3JtYWxpemVBeGVzKGF0dHJpYnV0ZXMuYXhlcywgaW5wdXRTaGFwZS5sZW5ndGgpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbLi4uQXJyYXkoaW5wdXRTaGFwZS5sZW5ndGgpLmtleXMoKV07XG4gIGxldCBzdGVwcyA9IHJlYWRJbnB1dChpbnB1dHMsIDQpO1xuICBzdGVwcy5mb3JFYWNoKChzdGVwKSA9PiBzdGVwICE9PSAwIHx8ICgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzdGVwIGNhbm5vdCBiZSAwJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgaWYgKHN0ZXBzLmxlbmd0aCA9PT0gMCkge1xuICAgIHN0ZXBzID0gQXJyYXkoYXhlcy5sZW5ndGgpLmZpbGwoMSk7XG4gIH1cbiAgY29uc3Qgc3RhcnRzID0gYXR0cmlidXRlcy5zdGFydHMubWFwKChzdGFydCwgaSkgPT4gZml4U3RhcnRFbmRWYWx1ZXMoc3RhcnQsIGksIGlucHV0U2hhcGUsIGF4ZXMsIHN0ZXBzKSk7XG5cbiAgY29uc3QgZW5kcyA9IGF0dHJpYnV0ZXMuZW5kcy5tYXAoKGVuZCwgaSkgPT4gZml4U3RhcnRFbmRWYWx1ZXMoZW5kLCBpLCBpbnB1dFNoYXBlLCBheGVzLCBzdGVwcykpO1xuXG4gIGlmIChheGVzLmxlbmd0aCAhPT0gc3RhcnRzLmxlbmd0aCB8fCBheGVzLmxlbmd0aCAhPT0gZW5kcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3N0YXJ0LCBlbmRzIGFuZCBheGVzIHNob3VsZCBoYXZlIHRoZSBzYW1lIG51bWJlciBvZiBlbGVtZW50cycpO1xuICB9XG5cbiAgaWYgKGF4ZXMubGVuZ3RoICE9PSBpbnB1dFNoYXBlLmxlbmd0aCkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5wdXRTaGFwZS5sZW5ndGg7ICsraSkge1xuICAgICAgaWYgKCFheGVzLmluY2x1ZGVzKGkpKSB7XG4gICAgICAgIHN0YXJ0cy5zcGxpY2UoaSwgMCwgMCk7XG4gICAgICAgIGVuZHMuc3BsaWNlKGksIDAsIGlucHV0U2hhcGVbaV0pO1xuICAgICAgICBzdGVwcy5zcGxpY2UoaSwgMCwgMSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNvbnN0IHNpZ25zID0gc3RlcHMubWFwKHN0ZXAgPT4gTWF0aC5zaWduKHN0ZXApKTtcbiAgLy8gQ29udmVydCBuZWdhdGl2ZSBzdGVwcyB0byBwb3NpdGl2ZSBzdGVwcyBhbmQgcmV2ZXJzZSBzdGFydHMgYW5kIGVuZHNcbiAgc3RlcHMuZm9yRWFjaCgoc3RlcCwgaSwgYXJyYXkpID0+IHtcbiAgICBpZiAoc3RlcCA8IDApIHtcbiAgICAgIGNvbnN0IG51bVN0ZXBzID0gKGVuZHNbaV0gLSBzdGFydHNbaV0pIC8gc3RlcDtcbiAgICAgIGNvbnN0IG5ld0VuZCA9IHN0YXJ0c1tpXTtcbiAgICAgIGNvbnN0IG5ld1N0YXJ0ID0gbmV3RW5kICsgbnVtU3RlcHMgKiBzdGVwc1tpXTtcbiAgICAgIHN0YXJ0c1tpXSA9IG5ld1N0YXJ0O1xuICAgICAgZW5kc1tpXSA9IG5ld0VuZDtcbiAgICAgIGFycmF5W2ldID0gLXN0ZXA7XG4gICAgfVxuICB9KTtcbiAgLy8gT3V0cHV0IHJhbmsgaXMgZXhwZWN0ZWQgdG8gYmUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHRoZSBpbnB1dCByYW5rLlxuICBjb25zdCBvdXRwdXRTaGFwZSA9IGlucHV0U2hhcGUuc2xpY2UoMCk7XG4gIGF4ZXMuZm9yRWFjaCgoYXhpcywgXykgPT4ge1xuICAgIG91dHB1dFNoYXBlW2F4aXNdID0gTWF0aC5jZWlsKChlbmRzW2F4aXNdIC0gc3RhcnRzW2F4aXNdKSAvIHN0ZXBzW2F4aXNdKTtcbiAgfSk7XG4gIGNvbnN0IG91dHB1dFRlbnNvckluZm86IFRlbnNvckluZm8gPSB7ZGltczogb3V0cHV0U2hhcGUsIGRhdGFUeXBlOiBpbnB1dHNbMF0uZGF0YVR5cGV9O1xuXG4gIGNvbnN0IG91dHB1dCA9IG91dHB1dFZhcmlhYmxlKCdvdXRwdXQnLCBpbnB1dHNbMF0uZGF0YVR5cGUsIG91dHB1dFNoYXBlLmxlbmd0aCk7XG4gIGNvbnN0IGlucHV0ID0gaW5wdXRWYXJpYWJsZSgnaW5wdXQnLCBpbnB1dHNbMF0uZGF0YVR5cGUsIGlucHV0c1swXS5kaW1zLmxlbmd0aCk7XG4gIGNvbnN0IG91dHB1dFNpemUgPSBTaGFwZVV0aWwuc2l6ZShvdXRwdXRTaGFwZSk7XG4gIGNvbnN0IHVuaWZvcm1zOiBVbmlmb3Jtc0FycmF5VHlwZSA9IFtcbiAgICB7bmFtZTogJ291dHB1dFNpemUnLCB0eXBlOiAndTMyJ30sIHtuYW1lOiAnc3RhcnRzJywgdHlwZTogJ3UzMicsIGxlbmd0aDogc3RhcnRzLmxlbmd0aH0sXG4gICAge25hbWU6ICdzaWducycsIHR5cGU6ICdpMzInLCBsZW5ndGg6IHNpZ25zLmxlbmd0aH0sIHtuYW1lOiAnc3RlcHMnLCB0eXBlOiAndTMyJywgbGVuZ3RoOiBzdGVwcy5sZW5ndGh9XG4gIF07XG5cbiAgY29uc3QgcHJvZ3JhbVVuaWZvcm1zOiBQcm9ncmFtVW5pZm9ybVtdID0gW1xuICAgIHt0eXBlOiAndWludDMyJywgZGF0YTogb3V0cHV0U2l6ZX0sIHt0eXBlOiAndWludDMyJywgZGF0YTogc3RhcnRzfSwge3R5cGU6ICdpbnQzMicsIGRhdGE6IHNpZ25zfSxcbiAgICB7dHlwZTogJ3VpbnQzMicsIGRhdGE6IHN0ZXBzfSwgLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMoaW5wdXRzWzBdLmRpbXMpLFxuICAgIC4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKG91dHB1dFNoYXBlKVxuICBdO1xuXG4gIGNvbnN0IGdldFNoYWRlclNvdXJjZSA9IChzaGFkZXJIZWxwZXI6IFNoYWRlckhlbHBlcikgPT4gYFxuICAgICAgJHtzaGFkZXJIZWxwZXIucmVnaXN0ZXJVbmlmb3Jtcyh1bmlmb3JtcykuZGVjbGFyZVZhcmlhYmxlcyhpbnB1dCwgb3V0cHV0KX1cbiAgICAgICAgJHtjYWxjdWxhdGVJbnB1dEluZGljZXNJbXBsKGlucHV0LCBvdXRwdXQsIGlucHV0U2hhcGUpfVxuICAgICAgICAke3NoYWRlckhlbHBlci5tYWluU3RhcnQoKX1cbiAgICAgICAgICAke3NoYWRlckhlbHBlci5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKCd1bmlmb3Jtcy5vdXRwdXRTaXplJyl9XG4gICAgICAgICAgbGV0IG91dHB1dF9pbmRpY2VzID0gJHtvdXRwdXQub2Zmc2V0VG9JbmRpY2VzKCdnbG9iYWxfaWR4Jyl9O1xuICAgICAgICAgIGxldCBpbnB1dF9pbmRpY2VzID0gY2FsY3VsYXRlSW5wdXRJbmRpY2VzKG91dHB1dF9pbmRpY2VzKTtcbiAgICAgICAgICAke291dHB1dC5zZXRCeU9mZnNldCgnZ2xvYmFsX2lkeCcsIGlucHV0LmdldEJ5SW5kaWNlcygnaW5wdXRfaW5kaWNlcycpKX1cbiAgICAgIH1gO1xuICByZXR1cm4ge1xuICAgIG5hbWU6ICdTbGljZScsXG4gICAgc2hhZGVyQ2FjaGU6IHtoaW50OiBgJHtzaWducy5sZW5ndGh9XyR7c3RhcnRzLmxlbmd0aH1fJHtzdGVwcy5sZW5ndGh9YCwgaW5wdXREZXBlbmRlbmNpZXM6IFsncmFuayddfSxcbiAgICBnZXRTaGFkZXJTb3VyY2UsXG4gICAgZ2V0UnVuRGF0YTogKCkgPT4gKHtcbiAgICAgIG91dHB1dHM6IFtvdXRwdXRUZW5zb3JJbmZvXSxcbiAgICAgIGRpc3BhdGNoR3JvdXA6IHt4OiBNYXRoLmNlaWwoaW5wdXRTaXplIC8gNjQgLyogd29ya2dyb3VwIHNpemUgKi8pfSxcbiAgICAgIHByb2dyYW1Vbmlmb3Jtc1xuICAgIH0pXG4gIH07XG59O1xuXG5leHBvcnQgY29uc3Qgc2xpY2UgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IFNsaWNlQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICB2YWxpZGF0ZUlucHV0cyhjb250ZXh0LmlucHV0cywgYXR0cmlidXRlcyk7XG4gIGNvbnN0IHVwZGF0ZWRBdHRyaWJ1dGVzID0gY3JlYXRlU2xpY2VBdHRyaWJ1dGVzRnJvbUlucHV0cyhjb250ZXh0LmlucHV0cywgYXR0cmlidXRlcyk7XG4gIGNvbnRleHQuY29tcHV0ZShjcmVhdGVTbGljZVByb2dyYW1JbmZvKGNvbnRleHQuaW5wdXRzLCB1cGRhdGVkQXR0cmlidXRlcyksIHtpbnB1dHM6IFswXX0pO1xuICAvLyBpZiAoU2hhcGVVdGlsLnNpemUocHJvZ3JhbS5vdXRwdXRzWzBdLmRpbXMpID4gMCkge1xuICAvLyAgIGNvbnRleHQuY29tcHV0ZShwcm9ncmFtSW5mb0xvYWRlciwge2lucHV0czogWzBdfSk7XG4gIC8vIH0gZWxzZSB7XG4gIC8vICAgLy8gVE9ETzogc3VwcG9ydCBlbXB0eSBvdXRwdXRcbiAgLy8gICB0aHJvdyBuZXcgRXJyb3IoJ3NsaWNlOiBvdXRwdXQgc2l6ZSBpcyAwJyk7XG4gIC8vIH1cbn07XG5cbmV4cG9ydCBjb25zdCBwYXJzZVNsaWNlQXR0cmlidXRlcyA9IChhdHRyaWJ1dGVzOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPik6IFNsaWNlQXR0cmlidXRlcyA9PiB7XG4gIGNvbnN0IHN0YXJ0cyA9IGF0dHJpYnV0ZXMuc3RhcnRzIGFzIG51bWJlcltdO1xuICBjb25zdCBlbmRzID0gYXR0cmlidXRlcy5lbmRzIGFzIG51bWJlcltdO1xuICBjb25zdCBheGVzID0gYXR0cmlidXRlcy5heGVzIGFzIG51bWJlcltdO1xuICByZXR1cm4gY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KHtzdGFydHMsIGVuZHMsIGF4ZXN9KTtcbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbi8vIFRPRE86IHRoaXMgaXMgdGhlIHNhbWUgbmFpdmUgaW1wbGVtZW50YXRpb24gd2UgdXNlIGZvciByZWR1Y2UgdGhhdCBoYXNcbi8vIHBlcmZvcm1hbmNlIGxpbWl0YXRpb25zIHdoZW4gdGhlIHJlZHVjZWQgYXhpcyBpcyBsb25nLiBOZWVkIHRvIGFkZFxuLy8gYSBvcHRpbWl6ZWQgY29kZXBhdGggZm9yIHRoaXMuXG5cbmltcG9ydCB7VGVuc29yVmlld30gZnJvbSAnLi4vLi4vdGVuc29yLXZpZXcnO1xuaW1wb3J0IHtTaGFwZVV0aWx9IGZyb20gJy4uLy4uL3V0aWwnO1xuaW1wb3J0IHtBdHRyaWJ1dGVXaXRoQ2FjaGVLZXksIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleX0gZnJvbSAnLi4vYXR0cmlidXRlLXdpdGgtY2FjaGUta2V5JztcbmltcG9ydCB7Q29tcHV0ZUNvbnRleHQsIFByb2dyYW1JbmZvfSBmcm9tICcuLi90eXBlcyc7XG5cbmltcG9ydCB7Z2V0TWF4Q29tcG9uZW50cywgaW5wdXRWYXJpYWJsZSwgb3V0cHV0VmFyaWFibGUsIFNoYWRlckhlbHBlciwgc3VtVmVjdG9yLCB0ZW5zb3JUeXBlVG9Xc2dsU3RvcmFnZVR5cGV9IGZyb20gJy4vY29tbW9uJztcblxuY29uc3QgdmFsaWRhdGVJbnB1dHMgPSAoaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10pOiB2b2lkID0+IHtcbiAgaWYgKCFpbnB1dHMgfHwgaW5wdXRzLmxlbmd0aCAhPT0gMSkge1xuICAgIHRocm93IG5ldyBFcnJvcignU29mdG1heCBvcCByZXF1aXJlcyAxIGlucHV0LicpO1xuICB9XG59O1xuXG5leHBvcnQgaW50ZXJmYWNlIFNvZnRtYXhBdHRyaWJ1dGVzIGV4dGVuZHMgQXR0cmlidXRlV2l0aENhY2hlS2V5IHtcbiAgcmVhZG9ubHkgYXhpczogbnVtYmVyO1xufVxuXG5jb25zdCBjcmVhdGVTb2Z0bWF4UHJvZ3JhbUluZm8gPSAoaW5wdXQ6IFRlbnNvclZpZXcsIGF0dHJpYnV0ZXM6IFNvZnRtYXhBdHRyaWJ1dGVzKTogUHJvZ3JhbUluZm8gPT4ge1xuICBjb25zdCBzaGFwZSA9IGlucHV0LmRpbXM7XG4gIGNvbnN0IG91dHB1dFNpemUgPSBTaGFwZVV0aWwuc2l6ZShzaGFwZSk7XG4gIGNvbnN0IFdHID0gNjQ7XG4gIGxldCBheGlzID0gYXR0cmlidXRlcy5heGlzO1xuICBpZiAoYXhpcyA8IDApIHtcbiAgICBheGlzID0gc2hhcGUubGVuZ3RoICsgYXhpcztcbiAgfVxuICBpZiAoYXhpcyA8IHNoYXBlLmxlbmd0aCAtIDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NvZnRtYXggb25seSBzdXBwb3J0cyBsYXN0IGF4aXMgZm9yIG5vdy4nKTtcbiAgfVxuXG4gIGNvbnN0IGNvbHMgPSBzaGFwZVtheGlzXTtcbiAgY29uc3Qgcm93cyA9IG91dHB1dFNpemUgLyBjb2xzO1xuICBjb25zdCBjb21wb25lbnRzID0gZ2V0TWF4Q29tcG9uZW50cyhjb2xzKTtcbiAgY29uc3QgcGFja2VkQ29scyA9IGNvbHMgLyBjb21wb25lbnRzO1xuXG4gIGNvbnN0IG1heFZlY3RvciA9IChuYW1lOiBzdHJpbmcsIGNvbXBvbmVudHM6IG51bWJlcikgPT4ge1xuICAgIGlmIChjb21wb25lbnRzID09PSA0KSB7XG4gICAgICByZXR1cm4gYG1heChtYXgoJHtuYW1lfS54LCAke25hbWV9LnkpLCBtYXgoJHtuYW1lfS56LCAke25hbWV9LncpKWA7XG4gICAgfSBlbHNlIGlmIChjb21wb25lbnRzID09PSAyKSB7XG4gICAgICByZXR1cm4gYG1heCgke25hbWV9LngsICR7bmFtZX0ueSlgO1xuICAgIH0gZWxzZSBpZiAoY29tcG9uZW50cyA9PT0gMykge1xuICAgICAgcmV0dXJuIGBtYXgobWF4KCR7bmFtZX0ueCwgJHtuYW1lfS55KSwgJHtuYW1lfS56KWA7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5hbWU7XG4gIH07XG4gIGNvbnN0IHggPSBpbnB1dFZhcmlhYmxlKCd4JywgaW5wdXQuZGF0YVR5cGUsIGlucHV0LmRpbXMsIGNvbXBvbmVudHMpO1xuICBjb25zdCBvdXRwdXQgPSBvdXRwdXRWYXJpYWJsZSgncmVzdWx0JywgaW5wdXQuZGF0YVR5cGUsIGlucHV0LmRpbXMsIGNvbXBvbmVudHMpO1xuICBjb25zdCB2YWx1ZVR5cGUgPSB4LnR5cGUudmFsdWU7XG4gIC8vIDYuMi40IGluIHdnc2wgc3BlY1xuICBjb25zdCB0aHJlYWRNYXhEZWNsID0gdGVuc29yVHlwZVRvV3NnbFN0b3JhZ2VUeXBlKGlucHV0LmRhdGFUeXBlKSA9PT0gJ2YzMicgP1xuICAgICAgYHZhciB0aHJlYWRNYXggPSAke3ZhbHVlVHlwZX0oLTMuNDAyODIzZSszOGYpO2AgOlxuICAgICAgYHZhciB0aHJlYWRNYXggPSAke3ZhbHVlVHlwZX0oLTY1NTA0LjBoKTtgO1xuICBjb25zdCBnZXRTaGFkZXJTb3VyY2UgPSAoc2hhZGVySGVscGVyOiBTaGFkZXJIZWxwZXIpID0+IGBcbiAgICAgIHZhcjx3b3JrZ3JvdXA+IHJvd01heFNoYXJlZCA6ICR7dmFsdWVUeXBlfTtcbiAgICAgIHZhcjx3b3JrZ3JvdXA+IHJvd1N1bVNoYXJlZCA6ICR7dmFsdWVUeXBlfTtcbiAgICAgIHZhcjx3b3JrZ3JvdXA+IHRocmVhZFNoYXJlZCA6IGFycmF5PCR7dmFsdWVUeXBlfSwgJHtXR30+O1xuXG4gICAgICBmbiBnZXRWYWx1ZShyb3c6IGkzMiwgY29sOiBpMzIsIHJvd19zdHJpZGU6IGkzMikgLT4gJHt2YWx1ZVR5cGV9IHtcbiAgICAgICAgbGV0IGluZGV4ID0gcm93ICogcm93X3N0cmlkZSArIGNvbDtcbiAgICAgICAgcmV0dXJuIHhbaW5kZXhdO1xuICAgICAgfVxuXG4gICAgICBmbiBzZXRWYWx1ZShyb3c6IGkzMiwgY29sOiBpMzIsIHJvd19zdHJpZGU6IGkzMiwgdmFsdWU6ICR7dmFsdWVUeXBlfSkge1xuICAgICAgICBsZXQgaW5kZXggPSByb3cgKiByb3dfc3RyaWRlICsgY29sO1xuICAgICAgICByZXN1bHRbaW5kZXhdID0gdmFsdWU7XG4gICAgICB9XG4gICAgICAke3NoYWRlckhlbHBlci5yZWdpc3RlclVuaWZvcm0oJ3BhY2tlZENvbHMnLCAnaTMyJykuZGVjbGFyZVZhcmlhYmxlcyh4LCBvdXRwdXQpfVxuICAgICAgJHtzaGFkZXJIZWxwZXIubWFpblN0YXJ0KCl9XG4gICAgICAgIGxldCBnaW5kZXggPSBpMzIoZ2xvYmFsX2lkeCk7XG4gICAgICAgIGxldCBsaW5kZXggPSBpMzIobG9jYWxfaWR4KTtcbiAgICAgICAgY29uc3Qgd2cgPSAke1dHfTtcbiAgICAgICAgbGV0IHJvdyA9IGdpbmRleCAvIHdnO1xuICAgICAgICBsZXQgY29scyA9IHVuaWZvcm1zLnBhY2tlZENvbHM7XG4gICAgICAgIGxldCByb3dfc3RyaWRlIDogaTMyID0gdW5pZm9ybXMucGFja2VkQ29scztcblxuICAgICAgICAvLyBmaW5kIHRoZSByb3dzIG1heFxuICAgICAgICAke3RocmVhZE1heERlY2x9XG4gICAgICAgIGZvciAodmFyIGNvbCA9IGxpbmRleDsgY29sIDwgY29sczsgY29sICs9IHdnKSB7XG4gICAgICAgICAgbGV0IHZhbHVlID0gZ2V0VmFsdWUocm93LCBjb2wsIHJvd19zdHJpZGUpO1xuICAgICAgICAgIHRocmVhZE1heCA9IG1heCh0aHJlYWRNYXgsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGluZGV4IDwgY29scykge1xuICAgICAgICAgIHRocmVhZFNoYXJlZFtsaW5kZXhdID0gdGhyZWFkTWF4O1xuICAgICAgICB9XG4gICAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcblxuICAgICAgICB2YXIgcmVkdWNlU2l6ZSA9IG1pbihjb2xzLCB3Zyk7XG4gICAgICAgIGZvciAodmFyIGN1cnJTaXplID0gcmVkdWNlU2l6ZSA+PiAxOyAgY3VyclNpemUgPiAwOyBjdXJyU2l6ZSA9IHJlZHVjZVNpemUgPj4gMSkge1xuICAgICAgICAgIHJlZHVjZVNpemUgPSBjdXJyU2l6ZSArIChyZWR1Y2VTaXplICYgMSk7XG4gICAgICAgICAgaWYgKGxpbmRleCA8IGN1cnJTaXplKSB7XG4gICAgICAgICAgICB0aHJlYWRTaGFyZWRbbGluZGV4XSA9IG1heCh0aHJlYWRTaGFyZWRbbGluZGV4XSwgdGhyZWFkU2hhcmVkW2xpbmRleCArIHJlZHVjZVNpemVdKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgd29ya2dyb3VwQmFycmllcigpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsaW5kZXggPT0gMCkge1xuICAgICAgICAgIHJvd01heFNoYXJlZCA9ICR7dmFsdWVUeXBlfSgke21heFZlY3RvcigndGhyZWFkU2hhcmVkWzBdJywgY29tcG9uZW50cyl9KTtcbiAgICAgICAgfVxuICAgICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG5cbiAgICAgICAgLy8gZmluZCB0aGUgcm93cyBzdW1cbiAgICAgICAgdmFyIHRocmVhZFN1bSA9ICR7dmFsdWVUeXBlfSgwLjApO1xuICAgICAgICBmb3IgKHZhciBjb2wgPSBsaW5kZXg7IGNvbCA8IGNvbHM7IGNvbCArPSB3Zykge1xuICAgICAgICAgIGxldCBzdWJFeHAgPSBleHAoZ2V0VmFsdWUocm93LCBjb2wsIHJvd19zdHJpZGUpIC0gcm93TWF4U2hhcmVkKTtcbiAgICAgICAgICB0aHJlYWRTdW0gKz0gc3ViRXhwO1xuICAgICAgICB9XG4gICAgICAgIHRocmVhZFNoYXJlZFtsaW5kZXhdID0gdGhyZWFkU3VtO1xuICAgICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG5cbiAgICAgICAgZm9yICh2YXIgY3VyclNpemUgPSB3ZyA+PiAxOyAgY3VyclNpemUgPiAwOyBjdXJyU2l6ZSA9IGN1cnJTaXplID4+IDEpIHtcbiAgICAgICAgICBpZiAobGluZGV4IDwgY3VyclNpemUpIHtcbiAgICAgICAgICAgIHRocmVhZFNoYXJlZFtsaW5kZXhdID0gdGhyZWFkU2hhcmVkW2xpbmRleF0gKyB0aHJlYWRTaGFyZWRbbGluZGV4ICsgY3VyclNpemVdO1xuICAgICAgICAgIH1cbiAgICAgICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxpbmRleCA9PSAwKSB7XG4gICAgICAgICAgcm93U3VtU2hhcmVkID0gJHt2YWx1ZVR5cGV9KCR7c3VtVmVjdG9yKCd0aHJlYWRTaGFyZWRbMF0nLCBjb21wb25lbnRzKX0pO1xuICAgICAgICB9XG4gICAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcblxuICAgICAgICAvLyBjYWxjdWxhdGUgZmluYWwgdmFsdWUgZm9yIGVhY2ggZWxlbWVudCBpbiB0aGUgcm93XG4gICAgICAgIGZvciAodmFyIGNvbCA9IGxpbmRleDsgY29sIDwgY29sczsgY29sICs9IHdnKSB7XG4gICAgICAgICAgbGV0IHZhbHVlID0gZXhwKGdldFZhbHVlKHJvdywgY29sLCByb3dfc3RyaWRlKSAtIHJvd01heFNoYXJlZCkgLyByb3dTdW1TaGFyZWQ7XG4gICAgICAgICAgc2V0VmFsdWUocm93LCBjb2wsIHJvd19zdHJpZGUsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfWA7XG4gIHJldHVybiB7XG4gICAgbmFtZTogJ1NvZnRtYXgnLFxuICAgIHNoYWRlckNhY2hlOiB7aGludDogYCR7Y29tcG9uZW50c31gLCBpbnB1dERlcGVuZGVuY2llczogWyd0eXBlJ119LFxuICAgIGdldFJ1bkRhdGE6ICgpID0+ICh7XG4gICAgICBvdXRwdXRzOiBbe2RpbXM6IHNoYXBlLCBkYXRhVHlwZTogaW5wdXQuZGF0YVR5cGV9XSxcbiAgICAgIGRpc3BhdGNoR3JvdXA6IHt4OiByb3dzfSxcbiAgICAgIHByb2dyYW1Vbmlmb3JtczogW3t0eXBlOiAndWludDMyJywgZGF0YTogcGFja2VkQ29sc31dXG4gICAgfSksXG4gICAgZ2V0U2hhZGVyU291cmNlLFxuICB9O1xufTtcblxuZXhwb3J0IGNvbnN0IHNvZnRtYXggPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IFNvZnRtYXhBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIHZhbGlkYXRlSW5wdXRzKGNvbnRleHQuaW5wdXRzKTtcbiAgY29udGV4dC5jb21wdXRlKGNyZWF0ZVNvZnRtYXhQcm9ncmFtSW5mbyhjb250ZXh0LmlucHV0c1swXSwgYXR0cmlidXRlcykpO1xufTtcblxuZXhwb3J0IGNvbnN0IHBhcnNlU29mdG1heEF0dHJpYnV0ZXMgPSAoYXR0cmlidXRlczogUmVjb3JkPHN0cmluZywgdW5rbm93bj4pOiBTb2Z0bWF4QXR0cmlidXRlcyA9PlxuICAgIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSh7YXhpczogYXR0cmlidXRlcy5heGlzIGFzIG51bWJlcn0pO1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge1RlbnNvclZpZXd9IGZyb20gJy4uLy4uL3RlbnNvci12aWV3JztcbmltcG9ydCB7U2hhcGVVdGlsfSBmcm9tICcuLi8uLi91dGlsJztcbmltcG9ydCB7QXR0cmlidXRlV2l0aENhY2hlS2V5LCBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXl9IGZyb20gJy4uL2F0dHJpYnV0ZS13aXRoLWNhY2hlLWtleSc7XG5pbXBvcnQge0NvbXB1dGVDb250ZXh0LCBQcm9ncmFtSW5mbywgUHJvZ3JhbVVuaWZvcm0sIFRlbnNvckluZm99IGZyb20gJy4uL3R5cGVzJztcblxuaW1wb3J0IHtjcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcywgZ2V0RWxlbWVudEF0LCBJbmRpY2VzSGVscGVyLCBpbnB1dFZhcmlhYmxlLCBvdXRwdXRWYXJpYWJsZSwgU2hhZGVySGVscGVyfSBmcm9tICcuL2NvbW1vbic7XG5cbmV4cG9ydCBpbnRlcmZhY2UgU3BsaXRBdHRyaWJ1dGVzIGV4dGVuZHMgQXR0cmlidXRlV2l0aENhY2hlS2V5IHtcbiAgcmVhZG9ubHkgYXhpczogbnVtYmVyO1xuICByZWFkb25seSBudW1PdXRwdXRzOiBudW1iZXI7XG4gIHJlYWRvbmx5IHNwbGl0U2l6ZXM6IG51bWJlcltdO1xufVxuXG5jb25zdCB2YWxpZGF0ZUlucHV0cyA9IChpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSk6IHZvaWQgPT4ge1xuICBpZiAoIWlucHV0cyB8fCBpbnB1dHMubGVuZ3RoIDwgMSkge1xuICAgIHRocm93IG5ldyBFcnJvcigndG9vIGZldyBpbnB1dHMnKTtcbiAgfVxufTtcblxuY29uc3QgY3JlYXRlU3BsaXRBdHRyaWJ1dGVzRnJvbUlucHV0cyA9XG4gICAgKGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdLCBhdHRyaWJ1dGVzOiBTcGxpdEF0dHJpYnV0ZXMpOiBTcGxpdEF0dHJpYnV0ZXMgPT4ge1xuICAgICAgY29uc3Qgc3BsaXRTaXplczogbnVtYmVyW10gPSBbXTtcbiAgICAgIGxldCBudW1PdXRwdXRzOiBudW1iZXIgPSBhdHRyaWJ1dGVzLm51bU91dHB1dHM7XG4gICAgICBpZiAoaW5wdXRzWzFdLmRpbXNbMF0gPiAwKSB7XG4gICAgICAgIGlucHV0c1sxXS5nZXRCaWdJbnQ2NEFycmF5KCkuZm9yRWFjaCh2ID0+IHNwbGl0U2l6ZXMucHVzaChOdW1iZXIodikpKTtcbiAgICAgICAgbnVtT3V0cHV0cyA9IHNwbGl0U2l6ZXMubGVuZ3RoO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSh7bnVtT3V0cHV0cywgYXhpczogYXR0cmlidXRlcy5heGlzLCBzcGxpdFNpemVzfSk7XG4gICAgfTtcblxuY29uc3QgY2FsY3VsYXRlT3V0cHV0SW5kZXhJbXBsID0gKG51bWJlck9mVGVuc29yczogbnVtYmVyKTogc3RyaW5nID0+IGBcbmZuIGNhbGN1bGF0ZU91dHB1dEluZGV4KGluZGV4OiB1MzIpIC0+IHUzMiB7XG4gICAgZm9yICh2YXIgaTogdTMyID0gMHU7IGkgPCAke251bWJlck9mVGVuc29yc311OyBpICs9IDF1ICkge1xuICAgIGlmIChpbmRleCA8ICR7Z2V0RWxlbWVudEF0KCd1bmlmb3Jtcy5zaXplX2luX3NwbGl0X2F4aXMnLCAnaScsIG51bWJlck9mVGVuc29ycyl9KSB7XG4gICAgICAgIHJldHVybiBpO1xuICAgIH1cbiAgICB9XG4gICAgcmV0dXJuICR7bnVtYmVyT2ZUZW5zb3JzfXU7XG59YDtcbmNvbnN0IHdyaXRlQnVmZmVyRGF0YUltcGwgPSAob3V0cHV0czogcmVhZG9ubHkgSW5kaWNlc0hlbHBlcltdKSA9PiB7XG4gIGNvbnN0IG51bWJlck9mVGVuc29ycyA9IG91dHB1dHMubGVuZ3RoO1xuICBjb25zdCBjb2RlTGluZXM6IHN0cmluZ1tdID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtYmVyT2ZUZW5zb3JzOyArK2kpIHtcbiAgICBjb25zdCByZXR1cm5TbmlwcGV0ID0gb3V0cHV0c1tpXS5zZXRCeUluZGljZXMoJ2luZGljZXMnLCAnaW5wdXRbZ2xvYmFsX2lkeF0nKTtcbiAgICBpZiAobnVtYmVyT2ZUZW5zb3JzID09PSAxKSB7XG4gICAgICBjb2RlTGluZXMucHVzaChyZXR1cm5TbmlwcGV0KTtcbiAgICB9IGVsc2UgaWYgKGkgPT09IDApIHtcbiAgICAgIGNvZGVMaW5lcy5wdXNoKGBpZiAob3V0cHV0X251bWJlciA9PSAke2l9dSkgeyAke3JldHVyblNuaXBwZXR9IH1gKTtcbiAgICB9IGVsc2UgaWYgKGkgPT09IG51bWJlck9mVGVuc29ycyAtIDEpIHtcbiAgICAgIGNvZGVMaW5lcy5wdXNoKGBlbHNlIHsgJHtyZXR1cm5TbmlwcGV0fSB9YCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvZGVMaW5lcy5wdXNoKGBlbHNlIGlmIChvdXRwdXRfbnVtYmVyID09ICR7aX0pIHsgJHtyZXR1cm5TbmlwcGV0fSB9YCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBgXG4gICAgICBmbiB3cml0ZUJ1ZmZlckRhdGEob3V0cHV0X251bWJlcjogdTMyLCBpbmRpY2VzOiAke291dHB1dHNbMF0udHlwZS5pbmRpY2VzfSwgZ2xvYmFsX2lkeDogdTMyKSB7XG4gICAgICAgICR7Y29kZUxpbmVzLmpvaW4oJ1xcbicpfVxuICAgICAgfWA7XG59O1xuXG5jb25zdCBjcmVhdGVTcGxpdFByb2dyYW1JbmZvID0gKGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdLCBhdHRyaWJ1dGVzOiBTcGxpdEF0dHJpYnV0ZXMpOiBQcm9ncmFtSW5mbyA9PiB7XG4gIGNvbnN0IGlucHV0U2hhcGUgPSBpbnB1dHNbMF0uZGltcztcbiAgY29uc3QgaW5wdXRTaXplID0gU2hhcGVVdGlsLnNpemUoaW5wdXRTaGFwZSk7XG4gIGNvbnN0IGRhdGFUeXBlID0gaW5wdXRzWzBdLmRhdGFUeXBlO1xuICBjb25zdCBheGlzID0gU2hhcGVVdGlsLm5vcm1hbGl6ZUF4aXMoYXR0cmlidXRlcy5heGlzLCBpbnB1dFNoYXBlLmxlbmd0aCk7XG4gIGNvbnN0IG91dHB1dHMgPSBuZXcgQXJyYXk8SW5kaWNlc0hlbHBlcj4oYXR0cmlidXRlcy5udW1PdXRwdXRzKTtcbiAgY29uc3QgaW5wdXQgPSBpbnB1dFZhcmlhYmxlKCdpbnB1dCcsIGRhdGFUeXBlLCBpbnB1dFNoYXBlKTtcbiAgY29uc3Qgc2l6ZUluU3BsaXRBeGlzID0gbmV3IEFycmF5PG51bWJlcj4oYXR0cmlidXRlcy5udW1PdXRwdXRzKTtcbiAgY29uc3Qgb3V0cHV0c1RlbnNvckluZm86IFRlbnNvckluZm9bXSA9IFtdO1xuICBjb25zdCBvdXRwdXRTaGFwZXM6IG51bWJlcltdW10gPSBbXTtcbiAgbGV0IHByZXZpb3VzU3VtID0gMDtcbiAgY29uc3QgcHJvZ3JhbVVuaWZvcm1zOiBQcm9ncmFtVW5pZm9ybVtdID0gW3t0eXBlOiAndWludDMyJywgZGF0YTogaW5wdXRTaXplfV07XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYXR0cmlidXRlcy5udW1PdXRwdXRzOyBpKyspIHtcbiAgICBwcmV2aW91c1N1bSArPSBhdHRyaWJ1dGVzLnNwbGl0U2l6ZXNbaV07XG4gICAgc2l6ZUluU3BsaXRBeGlzW2ldID0gcHJldmlvdXNTdW07XG4gICAgY29uc3Qgb3V0cHV0U2hhcGUgPSBpbnB1dFNoYXBlLnNsaWNlKCk7XG4gICAgb3V0cHV0U2hhcGVbYXR0cmlidXRlcy5heGlzXSA9IGF0dHJpYnV0ZXMuc3BsaXRTaXplc1tpXTtcbiAgICBvdXRwdXRTaGFwZXMucHVzaChvdXRwdXRTaGFwZSk7XG4gICAgb3V0cHV0c1tpXSA9IG91dHB1dFZhcmlhYmxlKGBvdXRwdXQke2l9YCwgZGF0YVR5cGUsIG91dHB1dFNoYXBlKTtcbiAgICBvdXRwdXRzVGVuc29ySW5mby5wdXNoKHtkaW1zOiBvdXRwdXRTaGFwZXNbaV0sIGRhdGFUeXBlOiBpbnB1dHNbMF0uZGF0YVR5cGV9KTtcbiAgfVxuICBwcm9ncmFtVW5pZm9ybXMucHVzaCh7dHlwZTogJ3VpbnQzMicsIGRhdGE6IHNpemVJblNwbGl0QXhpc30pO1xuICBwcm9ncmFtVW5pZm9ybXMucHVzaCguLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhpbnB1dFNoYXBlKSk7XG4gIG91dHB1dFNoYXBlcy5mb3JFYWNoKChvdXRwdXRTaGFwZSkgPT4gcHJvZ3JhbVVuaWZvcm1zLnB1c2goLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMob3V0cHV0U2hhcGUpKSk7XG4gIGNvbnN0IGdldFNoYWRlclNvdXJjZSA9IChzaGFkZXJIZWxwZXI6IFNoYWRlckhlbHBlcikgPT4gYFxuICAke1xuICAgICAgc2hhZGVySGVscGVyLnJlZ2lzdGVyVW5pZm9ybSgnaW5wdXRfc2l6ZScsICd1MzInKVxuICAgICAgICAgIC5yZWdpc3RlclVuaWZvcm0oJ3NpemVfaW5fc3BsaXRfYXhpcycsICd1MzInLCBzaXplSW5TcGxpdEF4aXMubGVuZ3RoKVxuICAgICAgICAgIC5kZWNsYXJlVmFyaWFibGVzKGlucHV0LCAuLi5vdXRwdXRzKX1cbiAgJHtjYWxjdWxhdGVPdXRwdXRJbmRleEltcGwoc2l6ZUluU3BsaXRBeGlzLmxlbmd0aCl9XG4gICR7d3JpdGVCdWZmZXJEYXRhSW1wbChvdXRwdXRzKX1cblxuICAke3NoYWRlckhlbHBlci5tYWluU3RhcnQoKX1cbiAgICAke3NoYWRlckhlbHBlci5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKCd1bmlmb3Jtcy5pbnB1dF9zaXplJyl9XG5cbiAgICB2YXIgaW5kaWNlcyA9ICR7aW5wdXQub2Zmc2V0VG9JbmRpY2VzKCdnbG9iYWxfaWR4Jyl9O1xuICAgIHZhciBpbmRleCA9ICR7aW5wdXQuaW5kaWNlc0dldCgnaW5kaWNlcycsIGF4aXMpfTtcbiAgICBsZXQgb3V0cHV0X251bWJlciA9IGNhbGN1bGF0ZU91dHB1dEluZGV4KGluZGV4KTtcbiAgICBpZiAob3V0cHV0X251bWJlciAhPSAwKSB7XG4gICAgICBpbmRleCAtPSAke2dldEVsZW1lbnRBdCgndW5pZm9ybXMuc2l6ZV9pbl9zcGxpdF9heGlzJywgJ291dHB1dF9udW1iZXIgLSAxdScsIHNpemVJblNwbGl0QXhpcy5sZW5ndGgpfTtcbiAgICAgICR7aW5wdXQuaW5kaWNlc1NldCgnaW5kaWNlcycsIGF4aXMsICdpbmRleCcpfTtcbiAgICB9XG4gICAgd3JpdGVCdWZmZXJEYXRhKG91dHB1dF9udW1iZXIsIGluZGljZXMsIGdsb2JhbF9pZHgpO1xuICB9YDtcbiAgcmV0dXJuIHtcbiAgICBuYW1lOiAnU3BsaXQnLFxuICAgIHNoYWRlckNhY2hlOiB7aGludDogYXR0cmlidXRlcy5jYWNoZUtleSwgaW5wdXREZXBlbmRlbmNpZXM6IFsncmFuayddfSxcbiAgICBnZXRTaGFkZXJTb3VyY2UsXG4gICAgZ2V0UnVuRGF0YTogKCkgPT4gKHtcbiAgICAgIG91dHB1dHM6IG91dHB1dHNUZW5zb3JJbmZvLFxuICAgICAgZGlzcGF0Y2hHcm91cDoge3g6IE1hdGguY2VpbChpbnB1dFNpemUgLyA2NCAvKiB3b3JrZ3JvdXAgc2l6ZSAqLyl9LFxuICAgICAgcHJvZ3JhbVVuaWZvcm1zXG4gICAgfSlcbiAgfTtcbn07XG5cbmV4cG9ydCBjb25zdCBzcGxpdCA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogU3BsaXRBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIHZhbGlkYXRlSW5wdXRzKGNvbnRleHQuaW5wdXRzKTtcbiAgY29uc3QgdXBkYXRlZEF0dHJpYnV0ZXMgPVxuICAgICAgY29udGV4dC5pbnB1dHMubGVuZ3RoID09PSAxID8gYXR0cmlidXRlcyA6IGNyZWF0ZVNwbGl0QXR0cmlidXRlc0Zyb21JbnB1dHMoY29udGV4dC5pbnB1dHMsIGF0dHJpYnV0ZXMpO1xuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlU3BsaXRQcm9ncmFtSW5mbyhjb250ZXh0LmlucHV0cywgdXBkYXRlZEF0dHJpYnV0ZXMpLCB7aW5wdXRzOiBbMF19KTtcbn07XG5cbmV4cG9ydCBjb25zdCBwYXJzZVNwbGl0QXR0cmlidXRlcyA9IChhdHRyaWJ1dGVzOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPik6IFNwbGl0QXR0cmlidXRlcyA9PiB7XG4gIGNvbnN0IGF4aXMgPSBhdHRyaWJ1dGVzLmF4aXMgYXMgbnVtYmVyO1xuICBjb25zdCBzcGxpdFNpemVzOiBudW1iZXJbXSA9IGF0dHJpYnV0ZXMuc3BsaXRTaXplcyBhcyBudW1iZXJbXTtcbiAgY29uc3QgbnVtT3V0cHV0cyA9IGF0dHJpYnV0ZXMubnVtT3V0cHV0cyBhcyBudW1iZXIgPCAwID8gc3BsaXRTaXplcy5sZW5ndGggOiBhdHRyaWJ1dGVzLm51bU91dHB1dHMgYXMgbnVtYmVyO1xuICBpZiAobnVtT3V0cHV0cyAhPT0gc3BsaXRTaXplcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ251bU91dHB1dHMgYW5kIHNwbGl0U2l6ZXMgbGVuZ2ggbXVzdCBiZSBlcXVhbCcpO1xuICB9XG4gIHJldHVybiBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkoe2F4aXMsIG51bU91dHB1dHMsIHNwbGl0U2l6ZXN9KTtcbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7RGF0YVR5cGV9IGZyb20gJy4uLy4uLy4uL3dhc20tY29tbW9uJztcbmltcG9ydCB7VGVuc29yVmlld30gZnJvbSAnLi4vLi4vdGVuc29yLXZpZXcnO1xuaW1wb3J0IHtTaGFwZVV0aWx9IGZyb20gJy4uLy4uL3V0aWwnO1xuaW1wb3J0IHtDb21wdXRlQ29udGV4dCwgUHJvZ3JhbUluZm99IGZyb20gJy4uL3R5cGVzJztcblxuaW1wb3J0IHtjcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcywgaW5wdXRWYXJpYWJsZSwgb3V0cHV0VmFyaWFibGUsIFNoYWRlckhlbHBlcn0gZnJvbSAnLi9jb21tb24nO1xuXG5jb25zdCBnZXRSZXBlYXRzID0gKHJlcGVhdHNUZW5zb3JWaWV3OiBUZW5zb3JWaWV3KTogcmVhZG9ubHkgbnVtYmVyW10gPT5cbiAgICBBcnJheS5mcm9tKHJlcGVhdHNUZW5zb3JWaWV3LmdldEJpZ0ludDY0QXJyYXkoKSwgTnVtYmVyKTtcblxuXG5jb25zdCB2YWxpZGF0ZUlucHV0cyA9IChpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSk6IHZvaWQgPT4ge1xuICBpZiAoIWlucHV0cyB8fCBpbnB1dHMubGVuZ3RoICE9PSAyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUaWxlIHJlcXVpcmVzIDIgaW5wdXRzLicpO1xuICB9XG5cbiAgaWYgKGlucHV0c1swXS5kYXRhVHlwZSAhPT0gRGF0YVR5cGUuZmxvYXQgJiYgaW5wdXRzWzBdLmRhdGFUeXBlICE9PSBEYXRhVHlwZS5pbnQzMiAmJlxuICAgICAgaW5wdXRzWzBdLmRhdGFUeXBlICE9PSBEYXRhVHlwZS51aW50MzIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RpbGUgb25seSBzdXBwb3J0IGZsb2F0LCBpbnQzMiwgYW5kIHVpbnQzMiBkYXRhIHR5cGVzJyk7XG4gIH1cblxuICBpZiAoaW5wdXRzWzFdLmRhdGFUeXBlICE9PSBEYXRhVHlwZS5pbnQ2NCkge1xuICAgIHRocm93IG5ldyBFcnJvcignVGlsZSBgcmVwZWF0c2AgaW5wdXQgc2hvdWxkIGJlIG9mIGludDY0IGRhdGEgdHlwZScpO1xuICB9XG5cbiAgaWYgKGlucHV0c1sxXS5kaW1zLmxlbmd0aCAhPT0gMSkge1xuICAgIHRocm93IG5ldyBFcnJvcignVGlsZSBgcmVwZWF0c2AgaW5wdXQgc2hvdWxkIGJlIDEtRCcpO1xuICB9XG5cbiAgY29uc3QgcmVwZWF0czogcmVhZG9ubHkgbnVtYmVyW10gPSBnZXRSZXBlYXRzKGlucHV0c1sxXSk7XG5cbiAgaWYgKHJlcGVhdHMubGVuZ3RoICE9PSBpbnB1dHNbMF0uZGltcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RpbGUgYHJlcGVhdHNgIGlucHV0IHNob3VsZCBoYXZlIHNhbWUgbnVtYmVyIG9mIGVsZW1lbnRzIGFzIHJhbmsgb2YgaW5wdXQgZGF0YSB0ZW5zb3InKTtcbiAgfVxufTtcblxuY29uc3QgZ2V0T3V0cHV0U2hhcGUgPSAoaW5wdXRTaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sIHJlcGVhdHM6IHJlYWRvbmx5IG51bWJlcltdKTogcmVhZG9ubHkgbnVtYmVyW10gPT4ge1xuICBjb25zdCBvdXRwdXRTaGFwZTogbnVtYmVyW10gPSBbXTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0U2hhcGUubGVuZ3RoOyArK2kpIHtcbiAgICBvdXRwdXRTaGFwZS5wdXNoKGlucHV0U2hhcGVbaV0gKiByZXBlYXRzW2ldKTtcbiAgfVxuXG4gIHJldHVybiBvdXRwdXRTaGFwZTtcbn07XG5cbmV4cG9ydCBjb25zdCBjcmVhdGVUaWxlUHJvZ3JhbUluZm8gPSAoaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10pOiBQcm9ncmFtSW5mbyA9PiB7XG4gIGNvbnN0IGlucHV0U2hhcGUgPSBpbnB1dHNbMF0uZGltcztcbiAgY29uc3QgcmVwZWF0czogcmVhZG9ubHkgbnVtYmVyW10gPSBnZXRSZXBlYXRzKGlucHV0c1sxXSk7XG4gIGNvbnN0IG91dHB1dFNoYXBlID0gZ2V0T3V0cHV0U2hhcGUoaW5wdXRTaGFwZSwgcmVwZWF0cyk7XG4gIGNvbnN0IG91dHB1dFNpemUgPSBTaGFwZVV0aWwuc2l6ZShvdXRwdXRTaGFwZSk7XG5cbiAgY29uc3QgZGF0YVR5cGUgPSBpbnB1dHNbMF0uZGF0YVR5cGU7XG4gIGNvbnN0IGlucHV0ID0gaW5wdXRWYXJpYWJsZSgnaW5wdXQnLCBkYXRhVHlwZSwgaW5wdXRTaGFwZS5sZW5ndGgpO1xuICBjb25zdCBvdXRwdXQgPSBvdXRwdXRWYXJpYWJsZSgnb3V0cHV0JywgZGF0YVR5cGUsIG91dHB1dFNoYXBlLmxlbmd0aCk7XG5cbiAgY29uc3QgZ2V0U2hhZGVyU291cmNlID0gKHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyKSA9PiBgXG4gICAgICBjb25zdCBpbnB1dFNoYXBlID0gJHtpbnB1dC5pbmRpY2VzKC4uLmlucHV0U2hhcGUpfTtcbiAgICAgICR7c2hhZGVySGVscGVyLnJlZ2lzdGVyVW5pZm9ybSgnb3V0cHV0X3NpemUnLCAndTMyJykuZGVjbGFyZVZhcmlhYmxlcyhpbnB1dCwgb3V0cHV0KX1cbiAgICAgICR7c2hhZGVySGVscGVyLm1haW5TdGFydCgpfVxuICAgICAgJHtzaGFkZXJIZWxwZXIuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcygndW5pZm9ybXMub3V0cHV0X3NpemUnKX1cbiAgICAgIGxldCBvdXRwdXRfaW5kaWNlcyA9ICR7b3V0cHV0Lm9mZnNldFRvSW5kaWNlcygnZ2xvYmFsX2lkeCcpfTtcbiAgICAgIHZhciBpbnB1dF9pbmRpY2VzOiAke2lucHV0LnR5cGUuaW5kaWNlc307XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8ICR7aW5wdXRTaGFwZS5sZW5ndGh9OyBpKyspIHtcbiAgICAgICAgbGV0IGlucHV0X2RpbV9pID0gJHtpbnB1dC5pbmRpY2VzR2V0KCd1bmlmb3Jtcy5pbnB1dF9zaGFwZScsICdpJyl9O1xuICAgICAgICBsZXQgaW5wdXRfZGltX3ZhbHVlID0gJHtvdXRwdXQuaW5kaWNlc0dldCgnb3V0cHV0X2luZGljZXMnLCAnaScpfSAgJSBpbnB1dF9kaW1faTtcblxuICAgICAgICAke2lucHV0LmluZGljZXNTZXQoJ2lucHV0X2luZGljZXMnLCAnaScsICdpbnB1dF9kaW1fdmFsdWUnKX1cbiAgICAgIH1cbiAgICAgICR7b3V0cHV0LnNldEJ5T2Zmc2V0KCdnbG9iYWxfaWR4JywgaW5wdXQuZ2V0QnlJbmRpY2VzKCdpbnB1dF9pbmRpY2VzJykpfVxuICAgIH1gO1xuXG4gIHJldHVybiB7XG4gICAgbmFtZTogJ1RpbGUnLFxuICAgIHNoYWRlckNhY2hlOiB7aGludDogYCR7cmVwZWF0c31gLCBpbnB1dERlcGVuZGVuY2llczogWydyYW5rJ119LFxuICAgIGdldFJ1bkRhdGE6ICgpID0+ICh7XG4gICAgICBvdXRwdXRzOiBbe2RpbXM6IG91dHB1dFNoYXBlLCBkYXRhVHlwZTogaW5wdXRzWzBdLmRhdGFUeXBlfV0sXG4gICAgICBkaXNwYXRjaEdyb3VwOiB7eDogTWF0aC5jZWlsKG91dHB1dFNpemUgLyA2NCAvKiB3b3JrZ3JvdXAgc2l6ZSAqLyl9LFxuICAgICAgcHJvZ3JhbVVuaWZvcm1zOiBbXG4gICAgICAgIHt0eXBlOiAndWludDMyJywgZGF0YTogb3V0cHV0U2l6ZX0sIC4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKGlucHV0c1swXS5kaW1zKSxcbiAgICAgICAgLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMob3V0cHV0U2hhcGUpXG4gICAgICBdLFxuICAgIH0pLFxuICAgIGdldFNoYWRlclNvdXJjZSxcbiAgfTtcbn07XG5cbmV4cG9ydCBjb25zdCB0aWxlID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0KTogdm9pZCA9PiB7XG4gIHZhbGlkYXRlSW5wdXRzKGNvbnRleHQuaW5wdXRzKTtcbiAgY29udGV4dC5jb21wdXRlKGNyZWF0ZVRpbGVQcm9ncmFtSW5mbyhjb250ZXh0LmlucHV0cyksIHtpbnB1dHM6IFswXX0pO1xufTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtEYXRhVHlwZX0gZnJvbSAnLi4vLi4vLi4vd2FzbS1jb21tb24nO1xuaW1wb3J0IHtUZW5zb3JWaWV3fSBmcm9tICcuLi8uLi90ZW5zb3Itdmlldyc7XG5pbXBvcnQge0Jyb2FkY2FzdFV0aWwsIFNoYXBlVXRpbH0gZnJvbSAnLi4vLi4vdXRpbCc7XG5pbXBvcnQge0NvbXB1dGVDb250ZXh0LCBQcm9ncmFtSW5mb30gZnJvbSAnLi4vdHlwZXMnO1xuXG5pbXBvcnQge2NyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzLCBpbnB1dFZhcmlhYmxlLCBvdXRwdXRWYXJpYWJsZSwgU2hhZGVySGVscGVyfSBmcm9tICcuL2NvbW1vbic7XG5cbmNvbnN0IGNyZWF0ZVdoZXJlT3BQcm9ncmFtU2hhZGVyID1cbiAgICAoc2hhZGVySGVscGVyOiBTaGFkZXJIZWxwZXIsIGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdLCBkaW1zT3V0cHV0OiByZWFkb25seSBudW1iZXJbXSwgaXNCcm9hZGNhc3Q6IGJvb2xlYW4sXG4gICAgIHR5cGVPdXRwdXQ6IG51bWJlcikgPT4ge1xuICAgICAgY29uc3Qgb3V0cHV0ID0gb3V0cHV0VmFyaWFibGUoJ291dHB1dF9kYXRhJywgdHlwZU91dHB1dCwgZGltc091dHB1dC5sZW5ndGgsIDQpO1xuICAgICAgY29uc3QgYSA9IGlucHV0VmFyaWFibGUoJ2FfZGF0YScsIGlucHV0c1sxXS5kYXRhVHlwZSwgaW5wdXRzWzFdLmRpbXMubGVuZ3RoLCA0KTtcbiAgICAgIGNvbnN0IGIgPSBpbnB1dFZhcmlhYmxlKCdiX2RhdGEnLCBpbnB1dHNbMl0uZGF0YVR5cGUsIGlucHV0c1syXS5kaW1zLmxlbmd0aCwgNCk7XG4gICAgICBjb25zdCBjID0gaW5wdXRWYXJpYWJsZSgnY19kYXRhJywgaW5wdXRzWzBdLmRhdGFUeXBlLCBpbnB1dHNbMF0uZGltcy5sZW5ndGgsIDQpO1xuXG4gICAgICBsZXQgYXNzaWdubWVudDogc3RyaW5nO1xuICAgICAgY29uc3QgZXhwcmVzc2lvbiA9IChhOiBzdHJpbmcsIGI6IHN0cmluZywgYzogc3RyaW5nKSA9PiBgc2VsZWN0KCR7Yn0sICR7YX0sICR7Y30pYDtcbiAgICAgIGlmICghaXNCcm9hZGNhc3QpIHtcbiAgICAgICAgYXNzaWdubWVudCA9IG91dHB1dC5zZXRCeU9mZnNldChcbiAgICAgICAgICAgICdnbG9iYWxfaWR4JyxcbiAgICAgICAgICAgIGV4cHJlc3Npb24oYS5nZXRCeU9mZnNldCgnZ2xvYmFsX2lkeCcpLCBiLmdldEJ5T2Zmc2V0KCdnbG9iYWxfaWR4JyksIGMuZ2V0QnlPZmZzZXQoJ2dsb2JhbF9pZHgnKSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3Qgc2luZ2xlQXNzaWdubWVudCA9IChyZXNTdHI6IHN0cmluZywgeDogbnVtYmVyLCB0eXBlQ2FzdCA9ICcnKSA9PiB7XG4gICAgICAgICAgY29uc3QgZXhwcmVzc2lvbkEgPSBgYV9kYXRhW2luZGV4X2Eke3h9XVtjb21wb25lbnRfYSR7eH1dYDtcbiAgICAgICAgICBjb25zdCBleHByZXNzaW9uQiA9IGBiX2RhdGFbaW5kZXhfYiR7eH1dW2NvbXBvbmVudF9iJHt4fV1gO1xuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1iaXR3aXNlXG4gICAgICAgICAgY29uc3QgZXhwcmVzc2lvbkMgPSBgYm9vbChjX2RhdGFbaW5kZXhfYyR7eH1dICYgJHsweGZmMDAwMDAwID4+PiAoKDMgLSB4KSAqIDgpfXUpYDtcbiAgICAgICAgICByZXR1cm4gYFxuICAgICAgICAgICAgbGV0IG91dHB1dF9pbmRpY2VzJHt4fSA9ICR7b3V0cHV0Lm9mZnNldFRvSW5kaWNlcyhgZ2xvYmFsX2lkeCAqIDR1ICsgJHt4fXVgKX07XG4gICAgICAgICAgICBsZXQgb2Zmc2V0X2Eke3h9ID0gJHthLmJyb2FkY2FzdGVkSW5kaWNlc1RvT2Zmc2V0KGBvdXRwdXRfaW5kaWNlcyR7eH1gLCBvdXRwdXQpfTtcbiAgICAgICAgICAgIGxldCBvZmZzZXRfYiR7eH0gPSAke2IuYnJvYWRjYXN0ZWRJbmRpY2VzVG9PZmZzZXQoYG91dHB1dF9pbmRpY2VzJHt4fWAsIG91dHB1dCl9O1xuICAgICAgICAgICAgbGV0IG9mZnNldF9jJHt4fSA9ICR7Yy5icm9hZGNhc3RlZEluZGljZXNUb09mZnNldChgb3V0cHV0X2luZGljZXMke3h9YCwgb3V0cHV0KX07XG4gICAgICAgICAgICBsZXQgaW5kZXhfYSR7eH0gPSBvZmZzZXRfYSR7eH0gLyA0dTtcbiAgICAgICAgICAgIGxldCBpbmRleF9iJHt4fSA9IG9mZnNldF9iJHt4fSAvIDR1O1xuICAgICAgICAgICAgbGV0IGluZGV4X2Mke3h9ID0gb2Zmc2V0X2Mke3h9IC8gNHU7XG4gICAgICAgICAgICBsZXQgY29tcG9uZW50X2Eke3h9ID0gb2Zmc2V0X2Eke3h9ICUgNHU7XG4gICAgICAgICAgICBsZXQgY29tcG9uZW50X2Ike3h9ID0gb2Zmc2V0X2Ike3h9ICUgNHU7XG4gICAgICAgICAgICAke3Jlc1N0cn1bJHt4fV0gPSAke3R5cGVDYXN0fSgke2V4cHJlc3Npb24oZXhwcmVzc2lvbkEsIGV4cHJlc3Npb25CLCBleHByZXNzaW9uQyl9KTtcbiAgICAgICAgICBgO1xuICAgICAgICB9O1xuICAgICAgICBpZiAodHlwZU91dHB1dCA9PT0gRGF0YVR5cGUuYm9vbCkge1xuICAgICAgICAgIGFzc2lnbm1lbnQgPSBgXG4gICAgICAgICAgICB2YXIgZGF0YSA9IHZlYzQ8dTMyPigwKTtcbiAgICAgICAgICAgICR7c2luZ2xlQXNzaWdubWVudCgnZGF0YScsIDAsICd1MzInKX1cbiAgICAgICAgICAgICR7c2luZ2xlQXNzaWdubWVudCgnZGF0YScsIDEsICd1MzInKX1cbiAgICAgICAgICAgICR7c2luZ2xlQXNzaWdubWVudCgnZGF0YScsIDIsICd1MzInKX1cbiAgICAgICAgICAgICR7c2luZ2xlQXNzaWdubWVudCgnZGF0YScsIDMsICd1MzInKX1cbiAgICAgICAgICAgIG91dHB1dF9kYXRhW2dsb2JhbF9pZHhdID0gZG90KHZlYzQ8dTMyPigweDEsIDB4MTAwLCAweDEwMDAwLCAweDEwMDAwMDApLCB2ZWM0PHUzMj4oZGF0YSkpO2A7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYXNzaWdubWVudCA9IGBcbiAgICAgICAgICAgICR7c2luZ2xlQXNzaWdubWVudCgnb3V0cHV0X2RhdGFbZ2xvYmFsX2lkeF0nLCAwKX1cbiAgICAgICAgICAgICR7c2luZ2xlQXNzaWdubWVudCgnb3V0cHV0X2RhdGFbZ2xvYmFsX2lkeF0nLCAxKX1cbiAgICAgICAgICAgICR7c2luZ2xlQXNzaWdubWVudCgnb3V0cHV0X2RhdGFbZ2xvYmFsX2lkeF0nLCAyKX1cbiAgICAgICAgICAgICR7c2luZ2xlQXNzaWdubWVudCgnb3V0cHV0X2RhdGFbZ2xvYmFsX2lkeF0nLCAzKX1cbiAgICAgICAgICBgO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBgXG4gICAgICAgICR7c2hhZGVySGVscGVyLnJlZ2lzdGVyVW5pZm9ybSgndmVjX3NpemUnLCAndTMyJykuZGVjbGFyZVZhcmlhYmxlcyhjLCBhLCBiLCBvdXRwdXQpfVxuICAgICAgICAke3NoYWRlckhlbHBlci5tYWluU3RhcnQoKX1cbiAgICAgICAgJHtzaGFkZXJIZWxwZXIuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcygndW5pZm9ybXMudmVjX3NpemUnKX1cbiAgICAgICAgJHthc3NpZ25tZW50fVxuICAgICAgfWA7XG4gICAgfTtcblxuY29uc3QgY3JlYXRlV2hlcmVPcFByb2dyYW1JbmZvID0gKGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdKTogUHJvZ3JhbUluZm8gPT4ge1xuICBjb25zdCBkaW1zQSA9IGlucHV0c1sxXS5kaW1zO1xuICBjb25zdCBkaW1zQiA9IGlucHV0c1syXS5kaW1zO1xuICBjb25zdCBkaW1zQyA9IGlucHV0c1swXS5kaW1zO1xuICBjb25zdCBvdXRwdXREYXRhVHlwZSA9IGlucHV0c1sxXS5kYXRhVHlwZTtcblxuICBjb25zdCBpc0Jyb2FkY2FzdCA9ICEoU2hhcGVVdGlsLmFyZUVxdWFsKGRpbXNBLCBkaW1zQikgJiYgU2hhcGVVdGlsLmFyZUVxdWFsKGRpbXNCLCBkaW1zQykpO1xuICBsZXQgb3V0cHV0U2hhcGUgPSBkaW1zQTtcbiAgbGV0IG91dHB1dFNpemUgPSBTaGFwZVV0aWwuc2l6ZShkaW1zQSk7XG4gIC8vIFRPRE86IGRlYWwgd2l0aCB6ZXJvLXNpemVkIHRlbnNvcnMgKGVnLiBkaW1zPVsxLDBdKVxuXG4gIGlmIChpc0Jyb2FkY2FzdCkge1xuICAgIGNvbnN0IGNhbGN1bGF0ZWRTaGFwZSA9IEJyb2FkY2FzdFV0aWwuY2FsY1NoYXBlKEJyb2FkY2FzdFV0aWwuY2FsY1NoYXBlKGRpbXNBLCBkaW1zQiwgZmFsc2UpISwgZGltc0MsIGZhbHNlKTtcbiAgICBpZiAoIWNhbGN1bGF0ZWRTaGFwZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5cXCd0IHBlcmZvcm0gd2hlcmUgb3Agb24gdGhlIGdpdmVuIHRlbnNvcnMnKTtcbiAgICB9XG4gICAgb3V0cHV0U2hhcGUgPSBjYWxjdWxhdGVkU2hhcGU7XG4gICAgb3V0cHV0U2l6ZSA9IFNoYXBlVXRpbC5zaXplKG91dHB1dFNoYXBlKTtcbiAgfVxuXG4gIGNvbnN0IHZlY1NpemUgPSBNYXRoLmNlaWwob3V0cHV0U2l6ZSAvIDQpO1xuXG4gIHJldHVybiB7XG4gICAgbmFtZTogJ1doZXJlJyxcbiAgICBzaGFkZXJDYWNoZToge2lucHV0RGVwZW5kZW5jaWVzOiBbJ3JhbmsnLCAncmFuaycsICdyYW5rJ119LFxuICAgIGdldFNoYWRlclNvdXJjZTogKHNoYWRlckhlbHBlcikgPT5cbiAgICAgICAgY3JlYXRlV2hlcmVPcFByb2dyYW1TaGFkZXIoc2hhZGVySGVscGVyLCBpbnB1dHMsIG91dHB1dFNoYXBlLCBpc0Jyb2FkY2FzdCwgb3V0cHV0RGF0YVR5cGUpLFxuICAgIGdldFJ1bkRhdGE6ICgpID0+ICh7XG4gICAgICBvdXRwdXRzOiBbe2RpbXM6IG91dHB1dFNoYXBlLCBkYXRhVHlwZTogb3V0cHV0RGF0YVR5cGV9XSxcbiAgICAgIGRpc3BhdGNoR3JvdXA6IHt4OiBNYXRoLmNlaWwob3V0cHV0U2l6ZSAvIDY0IC8qIHdvcmtncm91cCBzaXplICovIC8gNCAvKiB2ZWMgc2l6ZSAqLyl9LFxuICAgICAgcHJvZ3JhbVVuaWZvcm1zOiBbXG4gICAgICAgIHt0eXBlOiAndWludDMyJywgZGF0YTogdmVjU2l6ZX0sIC4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKGRpbXNDKSwgLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMoZGltc0EpLFxuICAgICAgICAuLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhkaW1zQiksIC4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKG91dHB1dFNoYXBlKVxuICAgICAgXSxcbiAgICB9KSxcbiAgfTtcbn07XG5cbmV4cG9ydCBjb25zdCB3aGVyZSA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCk6IHZvaWQgPT4ge1xuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlV2hlcmVPcFByb2dyYW1JbmZvKGNvbnRleHQuaW5wdXRzKSk7XG59O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge2FyZ01heCwgYXJnTWluLCBwYXJzZUFyZ01pbk1heEF0dHJpYnV0ZXN9IGZyb20gJy4vb3BzL2FyZ21pbm1heCc7XG5pbXBvcnQge2F0dGVudGlvbn0gZnJvbSAnLi9vcHMvYXR0ZW50aW9uJztcbmltcG9ydCB7YmF0Y2hOb3JtfSBmcm9tICcuL29wcy9iYXRjaC1ub3JtJztcbmltcG9ydCB7Ymlhc0FkZH0gZnJvbSAnLi9vcHMvYmlhcy1hZGQnO1xuaW1wb3J0IHtiaWFzU3BsaXRHZWx1fSBmcm9tICcuL29wcy9iaWFzLXNwbGl0LWdlbHUnO1xuaW1wb3J0ICogYXMgYmluYXJ5T3BzIGZyb20gJy4vb3BzL2JpbmFyeS1vcCc7XG5pbXBvcnQge2NvbmNhdCwgcGFyc2VDb25jYXRBdHRyaWJ1dGVzfSBmcm9tICcuL29wcy9jb25jYXQnO1xuaW1wb3J0IHtjb252LCBwYXJzZUNvbnZBdHRyaWJ1dGVzfSBmcm9tICcuL29wcy9jb252JztcbmltcG9ydCB7Y29udlRyYW5zcG9zZSwgcGFyc2VDb252VHJhbnNwb3NlQXR0cmlidXRlc30gZnJvbSAnLi9vcHMvY29udi10cmFuc3Bvc2UnO1xuaW1wb3J0IHtjdW1zdW0sIHBhcnNlQ3VtU3VtQXR0cmlidXRlc30gZnJvbSAnLi9vcHMvY3Vtc3VtJztcbmltcG9ydCB7ZWluc3VtLCBwYXJzZUVpbnN1bUF0dHJpYnV0ZXN9IGZyb20gJy4vb3BzL2VpbnN1bSc7XG5pbXBvcnQge2V4cGFuZH0gZnJvbSAnLi9vcHMvZXhwYW5kJztcbmltcG9ydCB7Z2F0aGVyLCBwYXJzZUdhdGhlckF0dHJpYnV0ZXN9IGZyb20gJy4vb3BzL2dhdGhlcic7XG5pbXBvcnQge2dhdGhlckVsZW1lbnRzLCBwYXJzZUdhdGhlckVsZW1lbnRzQXR0cmlidXRlc30gZnJvbSAnLi9vcHMvZ2F0aGVyLWVsZW1lbnRzJztcbmltcG9ydCB7Z2VtbSwgcGFyc2VHZW1tQXR0cmlidXRlc30gZnJvbSAnLi9vcHMvZ2VtbSc7XG5pbXBvcnQge2luc3RhbmNlTm9ybX0gZnJvbSAnLi9vcHMvaW5zdGFuY2Utbm9ybSc7XG5pbXBvcnQge2xheWVyTm9ybX0gZnJvbSAnLi9vcHMvbGF5ZXItbm9ybSc7XG5pbXBvcnQge21hdE11bH0gZnJvbSAnLi9vcHMvbWF0bXVsJztcbmltcG9ydCB7bXVsdGlIZWFkQXR0ZW50aW9uLCBwYXJzZU11bHRpSGVhZEF0dGVudGlvbkF0dHJpYnV0ZXN9IGZyb20gJy4vb3BzL211bHRpLWhlYWQtYXR0ZW50aWlvbic7XG5pbXBvcnQge3BhZH0gZnJvbSAnLi9vcHMvcGFkJztcbmltcG9ydCAqIGFzIHBvb2wgZnJvbSAnLi9vcHMvcG9vbCc7XG5pbXBvcnQge3JhbmdlfSBmcm9tICcuL29wcy9yYW5nZSc7XG5pbXBvcnQge3JlZHVjZUwxLCByZWR1Y2VMMiwgcmVkdWNlTG9nU3VtLCByZWR1Y2VMb2dTdW1FeHAsIHJlZHVjZU1heCwgcmVkdWNlTWVhbiwgcmVkdWNlTWluLCByZWR1Y2VQcm9kLCByZWR1Y2VTdW0sIHJlZHVjZVN1bVNxdWFyZX0gZnJvbSAnLi9vcHMvcmVkdWNlJztcbmltcG9ydCB7cGFyc2VSZXNpemVBdHRyaWJ1dGVzLCByZXNpemV9IGZyb20gJy4vb3BzL3Jlc2l6ZSc7XG5pbXBvcnQge3BhcnNlU2tpcExheWVyTm9ybUF0dHJpYnV0ZXMsIHNraXBMYXllck5vcm19IGZyb20gJy4vb3BzL3NraXAtbGF5ZXItbm9ybSc7XG5pbXBvcnQge3BhcnNlU2xpY2VBdHRyaWJ1dGVzLCBzbGljZX0gZnJvbSAnLi9vcHMvc2xpY2UnO1xuaW1wb3J0IHtwYXJzZVNvZnRtYXhBdHRyaWJ1dGVzLCBzb2Z0bWF4fSBmcm9tICcuL29wcy9zb2Z0bWF4JztcbmltcG9ydCB7cGFyc2VTcGxpdEF0dHJpYnV0ZXMsIHNwbGl0fSBmcm9tICcuL29wcy9zcGxpdCc7XG5pbXBvcnQge3RpbGV9IGZyb20gJy4vb3BzL3RpbGUnO1xuaW1wb3J0IHtwYXJzZVRyYW5zcG9zZUF0dHJpYnV0ZXMsIHRyYW5zcG9zZX0gZnJvbSAnLi9vcHMvdHJhbnNwb3NlJztcbmltcG9ydCAqIGFzIHVuYXJ5T3BzIGZyb20gJy4vb3BzL3VuYXJ5LW9wJztcbmltcG9ydCB7d2hlcmV9IGZyb20gJy4vb3BzL3doZXJlJztcbmltcG9ydCB7Q29tcHV0ZUNvbnRleHR9IGZyb20gJy4vdHlwZXMnO1xuXG5leHBvcnQgdHlwZSBSdW5GdW5jdGlvbiA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlPzogdW5rbm93bikgPT4gdm9pZDtcbmV4cG9ydCB0eXBlIFBhcnNlQXR0cmlidXRlRnVuY3Rpb24gPSAoYXR0cmlidXRlUmF3OiB1bmtub3duKSA9PiB1bmtub3duO1xuZXhwb3J0IHR5cGUgT3BlcmF0b3JJbXBsZW1lbnRhdGlvbiA9IFtSdW5GdW5jdGlvbl18W1J1bkZ1bmN0aW9uLCBQYXJzZUF0dHJpYnV0ZUZ1bmN0aW9uXTtcblxuZXhwb3J0IGNvbnN0IFdFQkdQVV9PUF9SRVNPTFZFX1JVTEVTOiBNYXA8c3RyaW5nLCBPcGVyYXRvckltcGxlbWVudGF0aW9uPiA9IG5ldyBNYXAoW1xuICBbJ0FicycsIFt1bmFyeU9wcy5hYnNdXSxcbiAgWydBY29zJywgW3VuYXJ5T3BzLmFjb3NdXSxcbiAgWydBY29zaCcsIFt1bmFyeU9wcy5hY29zaF1dLFxuICBbJ0FkZCcsIFtiaW5hcnlPcHMuYWRkXV0sXG4gIFsnQXJnTWF4JywgW2FyZ01heCwgcGFyc2VBcmdNaW5NYXhBdHRyaWJ1dGVzXV0sXG4gIFsnQXJnTWluJywgW2FyZ01pbiwgcGFyc2VBcmdNaW5NYXhBdHRyaWJ1dGVzXV0sXG4gIFsnQXNpbicsIFt1bmFyeU9wcy5hc2luXV0sXG4gIFsnQXNpbmgnLCBbdW5hcnlPcHMuYXNpbmhdXSxcbiAgWydBdGFuJywgW3VuYXJ5T3BzLmF0YW5dXSxcbiAgWydBdGFuaCcsIFt1bmFyeU9wcy5hdGFuaF1dLFxuICBbJ0F0dGVudGlvbicsIFthdHRlbnRpb25dXSxcbiAgLy8gVE9ETzogc3VwcG9ydCBuZXcgYXR0cmlidXRlcyBmb3IgQXZlcmFnZVBvb2wtMTBcbiAgWydBdmVyYWdlUG9vbCcsIFtwb29sLmF2ZXJhZ2VQb29sLCBwb29sLnBhcnNlQXZlcmFnZVBvb2xBdHRyaWJ1dGVzXV0sXG4gIFsnQmF0Y2hOb3JtYWxpemF0aW9uJywgW2JhdGNoTm9ybV1dLFxuICBbJ0JpYXNBZGQnLCBbYmlhc0FkZF1dLFxuICBbJ0JpYXNTcGxpdEdlbHUnLCBbYmlhc1NwbGl0R2VsdV1dLFxuICBbJ0Nhc3QnLCBbdW5hcnlPcHMuY2FzdCwgdW5hcnlPcHMucGFyc2VDYXN0QXR0cmlidXRlc11dLFxuICBbJ0NlaWwnLCBbdW5hcnlPcHMuY2VpbF1dLFxuICBbJ0NsaXAnLCBbdW5hcnlPcHMuY2xpcF1dLFxuICBbJ0NvbmNhdCcsIFtjb25jYXQsIHBhcnNlQ29uY2F0QXR0cmlidXRlc11dLFxuICBbJ0NvbnYnLCBbY29udiwgcGFyc2VDb252QXR0cmlidXRlc11dLFxuICBbJ0NvbnZUcmFuc3Bvc2UnLCBbY29udlRyYW5zcG9zZSwgcGFyc2VDb252VHJhbnNwb3NlQXR0cmlidXRlc11dLFxuICBbJ0NvcycsIFt1bmFyeU9wcy5jb3NdXSxcbiAgWydDb3NoJywgW3VuYXJ5T3BzLmNvc2hdXSxcbiAgWydDdW1TdW0nLCBbY3Vtc3VtLCBwYXJzZUN1bVN1bUF0dHJpYnV0ZXNdXSxcbiAgWydEaXYnLCBbYmluYXJ5T3BzLmRpdl1dLFxuICBbJ0VpbnN1bScsIFtlaW5zdW0sIHBhcnNlRWluc3VtQXR0cmlidXRlc11dLFxuICBbJ0VsdScsIFt1bmFyeU9wcy5lbHUsIHVuYXJ5T3BzLnBhcnNlQWxwaGFBdHRyaWJ1dGVzXV0sXG4gIFsnRXF1YWwnLCBbYmluYXJ5T3BzLmVxdWFsXV0sXG4gIFsnRXJmJywgW3VuYXJ5T3BzLmVyZl1dLFxuICBbJ0V4cCcsIFt1bmFyeU9wcy5leHBdXSxcbiAgWydFeHBhbmQnLCBbZXhwYW5kXV0sXG4gIFsnRmxvb3InLCBbdW5hcnlPcHMuZmxvb3JdXSxcbiAgWydGdXNlZENvbnYnLCBbY29udiwgcGFyc2VDb252QXR0cmlidXRlc11dLFxuICBbJ0dhdGhlcicsIFtnYXRoZXIsIHBhcnNlR2F0aGVyQXR0cmlidXRlc11dLFxuICBbJ0dhdGhlckVsZW1lbnRzJywgW2dhdGhlckVsZW1lbnRzLCBwYXJzZUdhdGhlckVsZW1lbnRzQXR0cmlidXRlc11dLFxuICBbJ0dlbHUnLCBbdW5hcnlPcHMuZ2VsdV1dLFxuICBbJ0dlbW0nLCBbZ2VtbSwgcGFyc2VHZW1tQXR0cmlidXRlc11dLFxuICBbJ0dsb2JhbEF2ZXJhZ2VQb29sJywgW3Bvb2wuZ2xvYmFsQXZlcmFnZVBvb2wsIHBvb2wucGFyc2VHbG9iYWxBdmVyYWdlUG9vbEF0dHJpYnV0ZXNdXSxcbiAgWydHbG9iYWxNYXhQb29sJywgW3Bvb2wuZ2xvYmFsTWF4UG9vbCwgcG9vbC5wYXJzZUdsb2JhbE1heFBvb2xBdHRyaWJ1dGVzXV0sXG4gIFsnR3JlYXRlcicsIFtiaW5hcnlPcHMuZ3JlYXRlcl1dLFxuICBbJ0dyZWF0ZXJPckVxdWFsJywgW2JpbmFyeU9wcy5ncmVhdGVyT3JFcXVhbF1dLFxuICBbJ0luc3RhbmNlTm9ybWFsaXphdGlvbicsIFtpbnN0YW5jZU5vcm1dXSxcbiAgWydMYXllck5vcm1hbGl6YXRpb24nLCBbbGF5ZXJOb3JtXV0sXG4gIFsnTGVha3lSZWx1JywgW3VuYXJ5T3BzLmxlYWt5UmVsdSwgdW5hcnlPcHMucGFyc2VBbHBoYUF0dHJpYnV0ZXNdXSxcbiAgWydMZXNzJywgW2JpbmFyeU9wcy5sZXNzXV0sXG4gIFsnTGVzc09yRXF1YWwnLCBbYmluYXJ5T3BzLmxlc3NPckVxdWFsXV0sXG4gIFsnTG9nJywgW3VuYXJ5T3BzLmxvZ11dLFxuICBbJ01hdE11bCcsIFttYXRNdWxdXSxcbiAgLy8gVE9ETzogc3VwcG9ydCBuZXcgYXR0cmlidXRlcyBmb3IgTWF4UG9vbC04IGFuZCBNYXhQb29sLTEwXG4gIFsnTWF4UG9vbCcsIFtwb29sLm1heFBvb2wsIHBvb2wucGFyc2VNYXhQb29sQXR0cmlidXRlc11dLFxuICBbJ011bCcsIFtiaW5hcnlPcHMubXVsXV0sXG4gIFsnTXVsdGlIZWFkQXR0ZW50aW9uJywgW211bHRpSGVhZEF0dGVudGlvbiwgcGFyc2VNdWx0aUhlYWRBdHRlbnRpb25BdHRyaWJ1dGVzXV0sXG4gIFsnTmVnJywgW3VuYXJ5T3BzLm5lZ11dLFxuICBbJ05vdCcsIFt1bmFyeU9wcy5ub3RdXSxcbiAgWydQYWQnLCBbcGFkXV0sXG4gIFsnUG93JywgW2JpbmFyeU9wcy5wb3ddXSxcbiAgWydSYW5nZScsIFtyYW5nZV1dLFxuICBbJ1JlY2lwcm9jYWwnLCBbdW5hcnlPcHMucmVjaXByb2NhbF1dLFxuICBbJ1JlZHVjZU1pbicsIFtyZWR1Y2VNaW5dXSxcbiAgWydSZWR1Y2VNZWFuJywgW3JlZHVjZU1lYW5dXSxcbiAgWydSZWR1Y2VNYXgnLCBbcmVkdWNlTWF4XV0sXG4gIFsnUmVkdWNlU3VtJywgW3JlZHVjZVN1bV1dLFxuICBbJ1JlZHVjZVByb2QnLCBbcmVkdWNlUHJvZF1dLFxuICBbJ1JlZHVjZUwxJywgW3JlZHVjZUwxXV0sXG4gIFsnUmVkdWNlTDInLCBbcmVkdWNlTDJdXSxcbiAgWydSZWR1Y2VMb2dTdW0nLCBbcmVkdWNlTG9nU3VtXV0sXG4gIFsnUmVkdWNlTG9nU3VtRXhwJywgW3JlZHVjZUxvZ1N1bUV4cF1dLFxuICBbJ1JlZHVjZVN1bVNxdWFyZScsIFtyZWR1Y2VTdW1TcXVhcmVdXSxcbiAgWydSZWx1JywgW3VuYXJ5T3BzLnJlbHVdXSxcbiAgWydSZXNpemUnLCBbcmVzaXplLCBwYXJzZVJlc2l6ZUF0dHJpYnV0ZXNdXSxcbiAgWydTaWdtb2lkJywgW3VuYXJ5T3BzLnNpZ21vaWRdXSxcbiAgWydTaW4nLCBbdW5hcnlPcHMuc2luXV0sXG4gIFsnU2luaCcsIFt1bmFyeU9wcy5zaW5oXV0sXG4gIFsnU2xpY2UnLCBbc2xpY2UsIHBhcnNlU2xpY2VBdHRyaWJ1dGVzXV0sXG4gIFsnU2tpcExheWVyTm9ybWFsaXphdGlvbicsIFtza2lwTGF5ZXJOb3JtLCBwYXJzZVNraXBMYXllck5vcm1BdHRyaWJ1dGVzXV0sXG4gIFsnU3BsaXQnLCBbc3BsaXQsIHBhcnNlU3BsaXRBdHRyaWJ1dGVzXV0sXG4gIFsnU3FydCcsIFt1bmFyeU9wcy5zcXJ0XV0sXG4gIFsnU29mdG1heCcsIFtzb2Z0bWF4LCBwYXJzZVNvZnRtYXhBdHRyaWJ1dGVzXV0sXG4gIFsnU3ViJywgW2JpbmFyeU9wcy5zdWJdXSxcbiAgWydUYW4nLCBbdW5hcnlPcHMudGFuXV0sXG4gIFsnVGFuaCcsIFt1bmFyeU9wcy50YW5oXV0sXG4gIFsnVGhyZXNob2xkZWRSZWx1JywgW3VuYXJ5T3BzLnRocmVzaG9sZGVkUmVsdSwgdW5hcnlPcHMucGFyc2VBbHBoYUF0dHJpYnV0ZXNdXSxcbiAgWydUaWxlJywgW3RpbGVdXSxcbiAgWydUcmFuc3Bvc2UnLCBbdHJhbnNwb3NlLCBwYXJzZVRyYW5zcG9zZUF0dHJpYnV0ZXNdXSxcbiAgWydXaGVyZScsIFt3aGVyZV1dLFxuXSk7XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7VFJBQ0VfRlVOQ19CRUdJTiwgVFJBQ0VfRlVOQ19FTkR9IGZyb20gJ29ubnhydW50aW1lLWNvbW1vbic7XG5cbmltcG9ydCB7V2ViR3B1QmFja2VuZH0gZnJvbSAnLi4vYmFja2VuZC13ZWJncHUnO1xuaW1wb3J0IHtMT0dfREVCVUd9IGZyb20gJy4uL2xvZyc7XG5cbmltcG9ydCB7Y3JlYXRlU2hhZGVySGVscGVyfSBmcm9tICcuL29wcy9jb21tb24nO1xuaW1wb3J0IHtBcnRpZmFjdCwgR3B1RGF0YSwgUHJvZ3JhbUluZm99IGZyb20gJy4vdHlwZXMnO1xuXG4vKipcbiAqIFByb2dyYW1NYW5hZ2VyIGlzIHRoZSBtYWluIGNsYXNzIGJlaGluZCBydW5uaW5nIGNvbXB1dGF0aW9uc1xuICogSXQgYnVpbGRzIFByb2dyYW1JbmZvJ3MgaW50byBBcnRpZmFjdHNcbiAqIEl0IGNvbXBpbGVzIGdpdmVuIFByb2dyYW1JbmZvJ3MgaW50byBXZWJHTCBQcm9yYW1zIChjYWNoZWQgYXMgQXJ0aWZhY3RzKVxuICogVXNlcyB0aGUgYXJ0aWZhY3QgdG8gcnVuIHRoZSBjb21wdXRhdGlvbiBieSBjYWxsaW5nIERyYXcgb25cbiAqIHRoZSBXZWJHTCBkcmF3aW5nIGJ1ZmZlclxuICogUHJvZ3JhbU1hbmFnZXIgYXV0b21hdGljYWxseSBtYXBzIChiaW5kcykgaW5wdXQgdmFyaWFibGVzIHRvIHRoZWlyXG4gKiBjb3JyZXNwb25kaW5nIExvY2F0aW9uJ3MgaW4gdGhlIGJpbmFyeSBwcm9ncmFtXG4gKi9cbmV4cG9ydCBjbGFzcyBQcm9ncmFtTWFuYWdlciB7XG4gIHJlcG86IE1hcDx1bmtub3duLCBBcnRpZmFjdD47ICAvLyB0aGlzIHNob3VsZCBiZSBwZXItc2Vzc2lvbiBvYmplY3RcbiAgYXR0cmlidXRlc0JvdW5kOiBib29sZWFuO1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgYmFja2VuZDogV2ViR3B1QmFja2VuZCkge1xuICAgIHRoaXMucmVwbyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLmF0dHJpYnV0ZXNCb3VuZCA9IGZhbHNlO1xuICB9XG4gIGdldEFydGlmYWN0KGtleTogdW5rbm93bik6IEFydGlmYWN0fHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIHRoaXMucmVwby5nZXQoa2V5KTtcbiAgfVxuICBzZXRBcnRpZmFjdChrZXk6IHVua25vd24sIGFydGlmYWN0OiBBcnRpZmFjdCk6IHZvaWQge1xuICAgIHRoaXMucmVwby5zZXQoa2V5LCBhcnRpZmFjdCk7XG4gIH1cbiAgcnVuKGJ1aWxkQXJ0aWZhY3Q6IEFydGlmYWN0LCBpbnB1dHM6IEdwdURhdGFbXSwgb3V0cHV0czogR3B1RGF0YVtdLCBkaXNwYXRjaEdyb3VwOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl0sXG4gICAgICB1bmlmb3JtQnVmZmVyQmluZGluZzogR1BVQmluZGluZ1Jlc291cmNlfHVuZGVmaW5lZCk6IHZvaWQge1xuICAgIFRSQUNFX0ZVTkNfQkVHSU4oYnVpbGRBcnRpZmFjdC5wcm9ncmFtSW5mby5uYW1lKTtcbiAgICBjb25zdCBkZXZpY2UgPSB0aGlzLmJhY2tlbmQuZGV2aWNlO1xuICAgIGNvbnN0IGNvbXB1dGVQYXNzRW5jb2RlciA9IHRoaXMuYmFja2VuZC5nZXRDb21wdXRlUGFzc0VuY29kZXIoKTtcbiAgICB0aGlzLmJhY2tlbmQud3JpdGVUaW1lc3RhbXAodGhpcy5iYWNrZW5kLnBlbmRpbmdEaXNwYXRjaE51bWJlciAqIDIpO1xuICAgIGNvbXB1dGVQYXNzRW5jb2Rlci5zZXRQaXBlbGluZShidWlsZEFydGlmYWN0LmNvbXB1dGVQaXBlbGluZSk7XG4gICAgY29uc3QgZW50cmllcyA9IFtdO1xuICAgIGZvciAoY29uc3QgaW5wdXQgb2YgaW5wdXRzKSB7XG4gICAgICBlbnRyaWVzLnB1c2goe2JpbmRpbmc6IGVudHJpZXMubGVuZ3RoLCByZXNvdXJjZToge2J1ZmZlcjogaW5wdXQuYnVmZmVyfX0pO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IG91dHB1dCBvZiBvdXRwdXRzKSB7XG4gICAgICBlbnRyaWVzLnB1c2goe2JpbmRpbmc6IGVudHJpZXMubGVuZ3RoLCByZXNvdXJjZToge2J1ZmZlcjogb3V0cHV0LmJ1ZmZlcn19KTtcbiAgICB9XG4gICAgaWYgKHVuaWZvcm1CdWZmZXJCaW5kaW5nKSB7XG4gICAgICBlbnRyaWVzLnB1c2goe2JpbmRpbmc6IGVudHJpZXMubGVuZ3RoLCByZXNvdXJjZTogdW5pZm9ybUJ1ZmZlckJpbmRpbmd9KTtcbiAgICB9XG4gICAgY29uc3QgYmluZEdyb3VwID0gZGV2aWNlLmNyZWF0ZUJpbmRHcm91cChcbiAgICAgICAge2xheW91dDogYnVpbGRBcnRpZmFjdC5jb21wdXRlUGlwZWxpbmUuZ2V0QmluZEdyb3VwTGF5b3V0KDApLCBlbnRyaWVzLCBsYWJlbDogYnVpbGRBcnRpZmFjdC5wcm9ncmFtSW5mby5uYW1lfSk7XG4gICAgY29tcHV0ZVBhc3NFbmNvZGVyLnNldEJpbmRHcm91cCgwLCBiaW5kR3JvdXApO1xuXG4gICAgY29tcHV0ZVBhc3NFbmNvZGVyLmRpc3BhdGNoV29ya2dyb3VwcyguLi5kaXNwYXRjaEdyb3VwKTtcbiAgICB0aGlzLmJhY2tlbmQud3JpdGVUaW1lc3RhbXAodGhpcy5iYWNrZW5kLnBlbmRpbmdEaXNwYXRjaE51bWJlciAqIDIgKyAxKTtcbiAgICB0aGlzLmJhY2tlbmQucGVuZGluZ0Rpc3BhdGNoTnVtYmVyKys7XG5cbiAgICBpZiAodGhpcy5iYWNrZW5kLnBlbmRpbmdEaXNwYXRjaE51bWJlciA+PSB0aGlzLmJhY2tlbmQubWF4RGlzcGF0Y2hOdW1iZXIgfHxcbiAgICAgICAgdGhpcy5iYWNrZW5kLnF1ZXJ5VHlwZSA9PT0gJ2F0LXBhc3NlcycpIHtcbiAgICAgIHRoaXMuYmFja2VuZC5lbmRDb21wdXRlUGFzcygpO1xuICAgIH1cbiAgICBpZiAodGhpcy5iYWNrZW5kLnBlbmRpbmdEaXNwYXRjaE51bWJlciA+PSB0aGlzLmJhY2tlbmQubWF4RGlzcGF0Y2hOdW1iZXIpIHtcbiAgICAgIHRoaXMuYmFja2VuZC5mbHVzaCgpO1xuICAgIH1cbiAgICBUUkFDRV9GVU5DX0VORChidWlsZEFydGlmYWN0LnByb2dyYW1JbmZvLm5hbWUpO1xuICB9XG4gIGRpc3Bvc2UoKTogdm9pZCB7XG4gICAgLy8gdGhpcy5yZXBvLmZvckVhY2goYSA9PiB0aGlzLmdsQ29udGV4dC5kZWxldGVQcm9ncmFtKGEucHJvZ3JhbSkpO1xuICB9XG4gIGJ1aWxkKHByb2dyYW1JbmZvOiBQcm9ncmFtSW5mbywgbm9ybWFsaXplZERpc3BhdGNoR3JvdXBTaXplOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl0pOiBBcnRpZmFjdCB7XG4gICAgVFJBQ0VfRlVOQ19CRUdJTihwcm9ncmFtSW5mby5uYW1lKTtcbiAgICBjb25zdCBkZXZpY2UgPSB0aGlzLmJhY2tlbmQuZGV2aWNlO1xuICAgIGNvbnN0IGV4dGVuc2lvbnM6IHN0cmluZ1tdID0gW107XG4gICAgaWYgKGRldmljZS5mZWF0dXJlcy5oYXMoJ3NoYWRlci1mMTYnKSkge1xuICAgICAgZXh0ZW5zaW9ucy5wdXNoKCdlbmFibGUgZjE2OycpO1xuICAgIH1cbiAgICBjb25zdCBzaGFkZXJIZWxwZXIgPSBjcmVhdGVTaGFkZXJIZWxwZXIobm9ybWFsaXplZERpc3BhdGNoR3JvdXBTaXplKTtcbiAgICBjb25zdCB1c2VyQ29kZSA9IHByb2dyYW1JbmZvLmdldFNoYWRlclNvdXJjZShzaGFkZXJIZWxwZXIpO1xuICAgIGNvbnN0IGNvZGUgPSBgJHtleHRlbnNpb25zLmpvaW4oJ1xcbicpfVxcbiR7c2hhZGVySGVscGVyLmFkZGl0aW9uYWxJbXBsZW1lbnRhdGlvbnN9XFxuJHt1c2VyQ29kZX1gO1xuICAgIGNvbnN0IHNoYWRlck1vZHVsZSA9IGRldmljZS5jcmVhdGVTaGFkZXJNb2R1bGUoe2NvZGUsIGxhYmVsOiBwcm9ncmFtSW5mby5uYW1lfSk7XG4gICAgTE9HX0RFQlVHKCd2ZXJib3NlJywgKCkgPT4gYFtXZWJHUFVdICR7cHJvZ3JhbUluZm8ubmFtZX0gc2hhZGVyIGNvZGU6ICR7Y29kZX1gKTtcblxuICAgIGNvbnN0IGNvbXB1dGVQaXBlbGluZSA9IGRldmljZS5jcmVhdGVDb21wdXRlUGlwZWxpbmUoXG4gICAgICAgIHtjb21wdXRlOiB7bW9kdWxlOiBzaGFkZXJNb2R1bGUsIGVudHJ5UG9pbnQ6ICdtYWluJ30sIGxheW91dDogJ2F1dG8nLCBsYWJlbDogcHJvZ3JhbUluZm8ubmFtZX0pO1xuXG4gICAgVFJBQ0VfRlVOQ19FTkQocHJvZ3JhbUluZm8ubmFtZSk7XG4gICAgcmV0dXJuIHtwcm9ncmFtSW5mbywgY29tcHV0ZVBpcGVsaW5lfTtcbiAgfVxuXG4gIG5vcm1hbGl6ZURpc3BhdGNoR3JvdXBTaXplKGRpc3BhdGNoR3JvdXA6IFJldHVyblR5cGU8UHJvZ3JhbUluZm9bJ2dldFJ1bkRhdGEnXT5bJ2Rpc3BhdGNoR3JvdXAnXSk6XG4gICAgICBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl0ge1xuICAgIGNvbnN0IHggPSB0eXBlb2YgZGlzcGF0Y2hHcm91cCA9PT0gJ251bWJlcicgPyBkaXNwYXRjaEdyb3VwIDogZGlzcGF0Y2hHcm91cC54O1xuICAgIGNvbnN0IHkgPSB0eXBlb2YgZGlzcGF0Y2hHcm91cCA9PT0gJ251bWJlcicgPyAxIDogKGRpc3BhdGNoR3JvdXAueSB8fCAxKTtcbiAgICBjb25zdCB6ID0gdHlwZW9mIGRpc3BhdGNoR3JvdXAgPT09ICdudW1iZXInID8gMSA6IChkaXNwYXRjaEdyb3VwLnogfHwgMSk7XG4gICAgY29uc3QgbGltaXRQZXJEaW1lbnNpb24gPSB0aGlzLmJhY2tlbmQuZGV2aWNlLmxpbWl0cy5tYXhDb21wdXRlV29ya2dyb3Vwc1BlckRpbWVuc2lvbjtcbiAgICBpZiAoeCA8PSBsaW1pdFBlckRpbWVuc2lvbiAmJiB5IDw9IGxpbWl0UGVyRGltZW5zaW9uICYmIHogPD0gbGltaXRQZXJEaW1lbnNpb24pIHtcbiAgICAgIHJldHVybiBbeCwgeSwgel07XG4gICAgfVxuICAgIGNvbnN0IHNpemUgPSB4ICogeSAqIHo7XG4gICAgbGV0IGRpc3BhdGNoQXZlcmFnZSA9IE1hdGguY2VpbChNYXRoLnNxcnQoc2l6ZSkpO1xuICAgIGlmIChkaXNwYXRjaEF2ZXJhZ2UgPiBsaW1pdFBlckRpbWVuc2lvbikge1xuICAgICAgZGlzcGF0Y2hBdmVyYWdlID0gTWF0aC5jZWlsKE1hdGguY2JydChzaXplKSk7XG4gICAgICBpZiAoZGlzcGF0Y2hBdmVyYWdlID4gbGltaXRQZXJEaW1lbnNpb24pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUb3RhbCBkaXNwYXRjaCBzaXplIGV4Y2VlZHMgV2ViR1BVIG1heGltdW0uJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gW2Rpc3BhdGNoQXZlcmFnZSwgZGlzcGF0Y2hBdmVyYWdlLCBkaXNwYXRjaEF2ZXJhZ2VdO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gW2Rpc3BhdGNoQXZlcmFnZSwgZGlzcGF0Y2hBdmVyYWdlLCAxXTtcbiAgICB9XG4gIH1cbn1cbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtFbnYsIFRlbnNvciwgVFJBQ0UsIFRSQUNFX0ZVTkNfQkVHSU4sIFRSQUNFX0ZVTkNfRU5EfSBmcm9tICdvbm54cnVudGltZS1jb21tb24nO1xuXG5pbXBvcnQge3RlbnNvckRhdGFUeXBlRW51bVRvU3RyaW5nfSBmcm9tICcuLi93YXNtLWNvbW1vbic7XG5cbmltcG9ydCB7Y29uZmlndXJlTG9nZ2VyLCBMT0dfREVCVUd9IGZyb20gJy4vbG9nJztcbmltcG9ydCB7Y3JlYXRlVmlldywgVGVuc29yVmlld30gZnJvbSAnLi90ZW5zb3Itdmlldyc7XG5pbXBvcnQge2NyZWF0ZUdwdURhdGFNYW5hZ2VyLCBkb3dubG9hZEdwdURhdGEsIEdwdURhdGFNYW5hZ2VyfSBmcm9tICcuL3dlYmdwdS9ncHUtZGF0YS1tYW5hZ2VyJztcbmltcG9ydCB7UnVuRnVuY3Rpb24sIFdFQkdQVV9PUF9SRVNPTFZFX1JVTEVTfSBmcm9tICcuL3dlYmdwdS9vcC1yZXNvbHZlLXJ1bGVzJztcbmltcG9ydCB7UHJvZ3JhbU1hbmFnZXJ9IGZyb20gJy4vd2ViZ3B1L3Byb2dyYW0tbWFuYWdlcic7XG5pbXBvcnQge0NvbXB1dGVDb250ZXh0LCBHcHVEYXRhLCBQcm9ncmFtSW5mbywgUHJvZ3JhbUlucHV0VGVuc29ySW5mb0RlcGVuZGVuY3ksIFRpbWVzdGFtcFF1ZXJ5fSBmcm9tICcuL3dlYmdwdS90eXBlcyc7XG5cbmludGVyZmFjZSBLZXJuZWxJbmZvIHtcbiAgcmVhZG9ubHkga2VybmVsVHlwZTogc3RyaW5nO1xuICByZWFkb25seSBrZXJuZWxOYW1lOiBzdHJpbmc7XG4gIHJlYWRvbmx5IGtlcm5lbEVudHJ5OiBSdW5GdW5jdGlvbjtcbiAgcmVhZG9ubHkgYXR0cmlidXRlczogWygoYXR0cmlidXRlOiB1bmtub3duKSA9PiB1bmtub3duKXx1bmRlZmluZWQsIHVua25vd25dO1xufVxuXG5pbnRlcmZhY2UgUGVuZGluZ0tlcm5lbEluZm8ge1xuICByZWFkb25seSBrZXJuZWxJZDogbnVtYmVyO1xuICByZWFkb25seSBwcm9ncmFtTmFtZTogc3RyaW5nO1xuICByZWFkb25seSBpbnB1dFRlbnNvclZpZXdzOiByZWFkb25seSBUZW5zb3JWaWV3W107XG4gIHJlYWRvbmx5IG91dHB1dFRlbnNvclZpZXdzOiByZWFkb25seSBUZW5zb3JWaWV3W107XG59XG5cbmNvbnN0IGdldFByb2dyYW1JbnB1dFRlbnNvckluZm9EZXBlbmRlbmN5S2V5ID1cbiAgICAoaW5wdXRUZW5zb3JzOiByZWFkb25seSBUZW5zb3JWaWV3W10sIGlucHV0RGVwZW5kZW5jaWVzOiByZWFkb25seSBQcm9ncmFtSW5wdXRUZW5zb3JJbmZvRGVwZW5kZW5jeVtdKTogc3RyaW5nID0+IHtcbiAgICAgIGlmIChpbnB1dERlcGVuZGVuY2llcy5sZW5ndGggIT09IGlucHV0VGVuc29ycy5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnB1dERlcGVuZGVuY2llcyBsZW5ndGggJHtpbnB1dERlcGVuZGVuY2llcy5sZW5ndGh9IGlzIG5vdCBlcXVhbCB0byBpbnB1dFRlbnNvcnMgbGVuZ3RoICR7XG4gICAgICAgICAgICBpbnB1dFRlbnNvcnMubGVuZ3RofS5gKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgaW5wdXRJbmZvczogc3RyaW5nW10gPSBbXTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5wdXRUZW5zb3JzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbnN0IHR5cGUgPSBpbnB1dFRlbnNvcnNbaV0uZGF0YVR5cGU7XG4gICAgICAgIHN3aXRjaCAoaW5wdXREZXBlbmRlbmNpZXNbaV0pIHtcbiAgICAgICAgICBjYXNlICdub25lJzoge1xuICAgICAgICAgICAgaW5wdXRJbmZvcy5wdXNoKCcnKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlICd0eXBlJzoge1xuICAgICAgICAgICAgaW5wdXRJbmZvcy5wdXNoKGAke3R5cGV9YCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAncmFuayc6IHtcbiAgICAgICAgICAgIGNvbnN0IHJhbmsgPSBpbnB1dFRlbnNvcnNbaV0uZGltcy5sZW5ndGg7XG4gICAgICAgICAgICBpbnB1dEluZm9zLnB1c2goYCR7dHlwZX07JHtyYW5rfWApO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgJ2RpbXMnOiB7XG4gICAgICAgICAgICBjb25zdCBkaW1zID0gaW5wdXRUZW5zb3JzW2ldLmRpbXMuam9pbignLCcpO1xuICAgICAgICAgICAgaW5wdXRJbmZvcy5wdXNoKGAke3R5cGV9OyR7ZGltc31gKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCBpbnB1dCBkZXBlbmRlbmN5OiAke2lucHV0RGVwZW5kZW5jaWVzW2ldfWApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBpbnB1dEluZm9zLmpvaW4oJ3wnKTtcbiAgICB9O1xuXG4vKipcbiAqIGdldCBhIHVuaXF1ZSBrZXkgcmVwcmVzZW50aW5nIHRoZSBwcm9ncmFtIGZyb20gdGhlIHByb2dyYW0gaW5mbywgaW5wdXQgc2hhcGVzIGFuZCB0eXBlcy5cbiAqXG4gKiBAcmV0dXJucyBhIHVuaXF1ZSBrZXkgaXMgYSBzaG9ydGVyIHN0cmluZyB0aGFuIHRoZSBzaGFkZXIgc291cmNlLCB3aGljaCBjb250YWlucyBhbGwgdGhlIGluZm9ybWF0aW9uIHRvIGlkZW50aWZ5IGFcbiAqIHByb2dyYW0uIGlmIHRoZSBrZXkgaXMgdGhlIHNhbWUsIHRoZSBwcm9ncmFtIHNoYWRlciBzb3VyY2Ugc2hvdWxkIGJlIHRoZSBzYW1lLCBzbyB3ZSBjYW4gcmV1c2UgdGhlIHByb2dyYW0uXG4gKlxuICovXG5jb25zdCBnZXRQcm9ncmFtSW5mb1VuaXF1ZUtleSA9XG4gICAgKHByb2dyYW1JbmZvOiBQcm9ncmFtSW5mbywgaW5wdXRUZW5zb3JzOiByZWFkb25seSBUZW5zb3JWaWV3W10sIGlzMURpbWVuc2lvbkRpc3BhdGNoOiBib29sZWFuKTogc3RyaW5nID0+IHtcbiAgICAgIC8vIGZpbmFsIGtleSBmb3JtYXQ6XG4gICAgICAvLyA8UFJPR1JBTV9OQU1FPls8UFJPR1JBTV9DVVNUT01fQ0FDSEVfSElOVD5dOmlzMURpbWVuc2lvbkRpc3BhdGNoOjxJTlBVVFNfSU5GT18wPnw8SU5QVVRTX0lORk9fMT58Li4uXG4gICAgICBsZXQga2V5ID0gcHJvZ3JhbUluZm8ubmFtZTtcbiAgICAgIGlmIChwcm9ncmFtSW5mby5zaGFkZXJDYWNoZT8uaGludCkge1xuICAgICAgICBrZXkgKz0gJ1snICsgcHJvZ3JhbUluZm8uc2hhZGVyQ2FjaGUuaGludCArICddJztcbiAgICAgIH1cbiAgICAgIGtleSArPSAnOicgKyBpczFEaW1lbnNpb25EaXNwYXRjaCArXG4gICAgICAgICAgYDoke1xuICAgICAgICAgICAgICAgICBnZXRQcm9ncmFtSW5wdXRUZW5zb3JJbmZvRGVwZW5kZW5jeUtleShcbiAgICAgICAgICAgICAgICAgICAgIGlucHV0VGVuc29ycyxcbiAgICAgICAgICAgICAgICAgICAgIHByb2dyYW1JbmZvLnNoYWRlckNhY2hlPy5pbnB1dERlcGVuZGVuY2llcyA/P1xuICAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBBcnJheTxQcm9ncmFtSW5wdXRUZW5zb3JJbmZvRGVwZW5kZW5jeT4oaW5wdXRUZW5zb3JzLmxlbmd0aCkuZmlsbCgnZGltcycpKX1gO1xuICAgICAgcmV0dXJuIGtleTtcbiAgICB9O1xuXG4vKipcbiAqIHRoaXMgY2xhc3MgaXMgZGVzaWduZWQgdG8gc3RvcmUgc3RhdHVzIGFuZCBiZWluZyB1c2VkIGFzIGEgc2luZ2xldG9uIGZvciBKU0VQLiBJdCB3aWxsIGJlIHBhc3NlZCB0byBqc2VwSW5pdCgpIGFzXG4gKiB0aGUgZmlyc3QgcGFyYW1ldGVyIHNvIHRoYXQgaXQgaXMgc3RvcmVkIGZvciBmdXR1cmUgdXNlLlxuICovXG5leHBvcnQgY2xhc3MgV2ViR3B1QmFja2VuZCB7XG4gIGRldmljZTogR1BVRGV2aWNlO1xuICAvKipcbiAgICogYW4gaW5zdGFuY2Ugb2YgR3B1RGF0YU1hbmFnZXIgdG8gbWFuYWdlIGEgR3B1RGF0YUlkIC0+IEdwdUJ1ZmZlciBtYXBwaW5nXG4gICAqL1xuICBncHVEYXRhTWFuYWdlcjogR3B1RGF0YU1hbmFnZXI7XG4gIC8qKlxuICAgKiBhbiBpbnN0YW5jZSBvZiBQcm9ncmFtTWFuYWdlciB0byBidWlsZCBhbmQgcnVuIFdlYkdQVSBjb21wdXRlIHNoYWRlciBwcm9ncmFtLCBhbmQgbWFuYWdlIGEgUHJvZ3JhbUtleSAtPiBQcm9ncmFtXG4gICAqIGFydGlmYWN0cyBtYXBwaW5nXG4gICAqL1xuICBwcm9ncmFtTWFuYWdlcjogUHJvZ3JhbU1hbmFnZXI7XG5cbiAgLyoqXG4gICAqIHJlcHJlc2VudGluZyB0aGUga2VybmVsIElEIG9mIHdoaWNoIGlzIGN1cnJlbnRseSBiZWluZyBjb21wdXRlZCAoQ1BVIGNvZGUgcGVyc3BlY3RpdmUpLlxuICAgKiBgbnVsbGAgbWVhbnMgbm8ga2VybmVsIGlzIGJlaW5nIGNvbXB1dGVkLlxuICAgKiBvbmx5IG9uZSBrZXJuZWwgY2FuIGJlIGNvbXB1dGVkIGF0IGEgbW9tZW50LlxuICAgKi9cbiAgY3VycmVudEtlcm5lbElkOiBudW1iZXJ8bnVsbCA9IG51bGw7XG4gIC8qKlxuICAgKiBhIGxpc3Qgb2YgdGVtcG9yYXJ5IEdQVSBkYXRhIGZvciB0aGUgY3VycmVudCBrZXJuZWwuIHNob3VsZCByZWxlYXNlIHdoZW4gdGhlIGtlcm5lbCBkb25lIGNvbXB1dGF0aW9uLlxuICAgKi9cbiAgcHJpdmF0ZSB0ZW1wb3JhcnlEYXRhOiBHcHVEYXRhW107XG4gIC8qKlxuICAgKiBhIEtlcm5lbElEIC0+IGEgR1BVIGRhdGEgbGlzdCwgd2hpY2ggc3RvcmVzIHBlcnNpc3RlbnQgR1BVIGRhdGEgb3duZWQgYnkgdGhlIHNwZWNpZmljIGtlcm5lbC5cbiAgICovXG4gIHByaXZhdGUga2VybmVsUGVyc2lzdGVudERhdGE6IE1hcDxudW1iZXIsIEdwdURhdGFbXT47XG4gIC8qKlxuICAgKiBhIEtlcm5lbElEIC0+IGEgY3VzdG9tIGRhdGEsIHdoaWNoIHN0b3JlcyBjdXN0b20gZGF0YSBvd25lZCBieSB0aGUgc3BlY2lmaWMga2VybmVsLlxuICAgKi9cbiAgcHJpdmF0ZSBrZXJuZWxDdXN0b21EYXRhOiBNYXA8bnVtYmVyLCB7W2tleTogc3RyaW5nXTogdW5rbm93bn0+O1xuICAvKipcbiAgICogZ2V0IHRoZSBjdXN0b20gZGF0YSBvZiB0aGUgY3VycmVudCBrZXJuZWxcbiAgICovXG4gIGdldCBjdXJyZW50S2VybmVsQ3VzdG9tRGF0YSgpOiB7W2tleTogc3RyaW5nXTogdW5rbm93bn0ge1xuICAgIGlmICh0aGlzLmN1cnJlbnRLZXJuZWxJZCA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdjdXJyZW50S2VybmVsQ3VzdG9tRGF0YSgpOiBjdXJyZW50S2VybmVsSWQgaXMgbnVsbC4gKHNob3VsZCBub3QgaGFwcGVuKScpO1xuICAgIH1cblxuICAgIGxldCBkYXRhID0gdGhpcy5rZXJuZWxDdXN0b21EYXRhLmdldCh0aGlzLmN1cnJlbnRLZXJuZWxJZCk7XG4gICAgaWYgKCFkYXRhKSB7XG4gICAgICBkYXRhID0ge307XG4gICAgICB0aGlzLmtlcm5lbEN1c3RvbURhdGEuc2V0KHRoaXMuY3VycmVudEtlcm5lbElkLCBkYXRhKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuXG4gIC8vIEtlcm5lbElEIC0+IGtlcm5lbEluZm8gbWFwcGluZ1xuICBrZXJuZWxzOiBNYXA8bnVtYmVyLCBLZXJuZWxJbmZvPjtcbiAgcHJpdmF0ZSBjb21tYW5kRW5jb2RlcjogR1BVQ29tbWFuZEVuY29kZXJ8bnVsbCA9IG51bGw7XG4gIHByaXZhdGUgY29tcHV0ZVBhc3NFbmNvZGVyOiBHUFVDb21wdXRlUGFzc0VuY29kZXJ8bnVsbCA9IG51bGw7XG4gIG1heERpc3BhdGNoTnVtYmVyID0gMTY7XG4gIHBlbmRpbmdEaXNwYXRjaE51bWJlciA9IDA7XG5cbiAgLy8gaW5mbyBvZiBrZXJuZWxzIHBlbmRpbmcgc3VibWlzc2lvbiBmb3IgYSBzaW5nbGUgYmF0Y2hcbiAgcHJpdmF0ZSBwZW5kaW5nS2VybmVsczogUGVuZGluZ0tlcm5lbEluZm9bXSA9IFtdO1xuICAvLyBxdWVyeVJlYWRCdWZmZXIgLT4gcGVuZGluZ0tlcm5lbHMgbWFwcGluZyBmb3IgYWxsIHRoZSBiYXRjaGVzXG4gIHByaXZhdGUgcGVuZGluZ1F1ZXJpZXM6IE1hcDxHUFVCdWZmZXIsIFBlbmRpbmdLZXJuZWxJbmZvW10+ID0gbmV3IE1hcCgpO1xuICBwcml2YXRlIHF1ZXJ5UmVzb2x2ZUJ1ZmZlcj86IEdQVUJ1ZmZlcjtcbiAgcHJpdmF0ZSBxdWVyeVNldD86IEdQVVF1ZXJ5U2V0O1xuICBwcml2YXRlIHF1ZXJ5VGltZUJhc2U/OiBiaWdpbnQ7XG4gIHF1ZXJ5VHlwZTogVGltZXN0YW1wUXVlcnk7XG5cbiAgZW52OiBFbnY7XG5cbiAgLyoqXG4gICAqIGEgU2Vzc2lvbklEIC0+IGEgTWFwIG9mIChJbnB1dE91dHB1dEluZGV4IC0+IFtJRCwgR1BVQnVmZmVyXSkgbWFwcGluZy5cbiAgICovXG4gIHNlc3Npb25FeHRlcm5hbERhdGFNYXBwaW5nOiBNYXA8bnVtYmVyLCBNYXA8bnVtYmVyLCBbbnVtYmVyLCBHUFVCdWZmZXJdPj4gPSBuZXcgTWFwKCk7XG5cbiAgYXN5bmMgaW5pdGlhbGl6ZShlbnY6IEVudiwgYWRhcHRlcjogR1BVQWRhcHRlcik6IFByb21pc2U8dm9pZD4ge1xuICAgIHRoaXMuZW52ID0gZW52O1xuICAgIGNvbnN0IHJlcXVpcmVkRmVhdHVyZXM6IEdQVUZlYXR1cmVOYW1lW10gPSBbXTtcbiAgICBjb25zdCBkZXZpY2VEZXNjcmlwdG9yOiBHUFVEZXZpY2VEZXNjcmlwdG9yID0ge1xuICAgICAgcmVxdWlyZWRMaW1pdHM6IHtcbiAgICAgICAgbWF4Q29tcHV0ZVdvcmtncm91cFN0b3JhZ2VTaXplOiBhZGFwdGVyLmxpbWl0cy5tYXhDb21wdXRlV29ya2dyb3VwU3RvcmFnZVNpemUsXG4gICAgICAgIG1heENvbXB1dGVXb3JrZ3JvdXBzUGVyRGltZW5zaW9uOiBhZGFwdGVyLmxpbWl0cy5tYXhDb21wdXRlV29ya2dyb3Vwc1BlckRpbWVuc2lvbixcbiAgICAgICAgbWF4U3RvcmFnZUJ1ZmZlckJpbmRpbmdTaXplOiBhZGFwdGVyLmxpbWl0cy5tYXhTdG9yYWdlQnVmZmVyQmluZGluZ1NpemUsXG4gICAgICAgIG1heEJ1ZmZlclNpemU6IGFkYXB0ZXIubGltaXRzLm1heEJ1ZmZlclNpemUsXG4gICAgICAgIG1heENvbXB1dGVJbnZvY2F0aW9uc1Blcldvcmtncm91cDogYWRhcHRlci5saW1pdHMubWF4Q29tcHV0ZUludm9jYXRpb25zUGVyV29ya2dyb3VwLFxuICAgICAgICBtYXhDb21wdXRlV29ya2dyb3VwU2l6ZVg6IGFkYXB0ZXIubGltaXRzLm1heENvbXB1dGVXb3JrZ3JvdXBTaXplWCxcbiAgICAgICAgbWF4Q29tcHV0ZVdvcmtncm91cFNpemVZOiBhZGFwdGVyLmxpbWl0cy5tYXhDb21wdXRlV29ya2dyb3VwU2l6ZVksXG4gICAgICAgIG1heENvbXB1dGVXb3JrZ3JvdXBTaXplWjogYWRhcHRlci5saW1pdHMubWF4Q29tcHV0ZVdvcmtncm91cFNpemVaLFxuICAgICAgfSxcbiAgICAgIHJlcXVpcmVkRmVhdHVyZXMsXG4gICAgfTtcblxuICAgIGlmIChhZGFwdGVyLmZlYXR1cmVzLmhhcygnY2hyb21pdW0tZXhwZXJpbWVudGFsLXRpbWVzdGFtcC1xdWVyeS1pbnNpZGUtcGFzc2VzJykpIHtcbiAgICAgIHJlcXVpcmVkRmVhdHVyZXMucHVzaCgnY2hyb21pdW0tZXhwZXJpbWVudGFsLXRpbWVzdGFtcC1xdWVyeS1pbnNpZGUtcGFzc2VzJyBhcyBHUFVGZWF0dXJlTmFtZSk7XG4gICAgfSBlbHNlIGlmIChhZGFwdGVyLmZlYXR1cmVzLmhhcygndGltZXN0YW1wLXF1ZXJ5JykpIHtcbiAgICAgIHJlcXVpcmVkRmVhdHVyZXMucHVzaCgndGltZXN0YW1wLXF1ZXJ5Jyk7XG4gICAgfVxuICAgIGlmIChhZGFwdGVyLmZlYXR1cmVzLmhhcygnc2hhZGVyLWYxNicpKSB7XG4gICAgICByZXF1aXJlZEZlYXR1cmVzLnB1c2goJ3NoYWRlci1mMTYnKTtcbiAgICB9XG5cbiAgICB0aGlzLmRldmljZSA9IGF3YWl0IGFkYXB0ZXIucmVxdWVzdERldmljZShkZXZpY2VEZXNjcmlwdG9yKTtcbiAgICB0aGlzLmdwdURhdGFNYW5hZ2VyID0gY3JlYXRlR3B1RGF0YU1hbmFnZXIodGhpcyk7XG4gICAgdGhpcy5wcm9ncmFtTWFuYWdlciA9IG5ldyBQcm9ncmFtTWFuYWdlcih0aGlzKTtcbiAgICB0aGlzLmtlcm5lbHMgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5rZXJuZWxQZXJzaXN0ZW50RGF0YSA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLmtlcm5lbEN1c3RvbURhdGEgPSBuZXcgTWFwKCk7XG5cbiAgICAvLyBzZXQgdXAgZmxhZ3MgZm9yIGxvZ2dlclxuICAgIGNvbmZpZ3VyZUxvZ2dlcihlbnYubG9nTGV2ZWwhLCAhIWVudi5kZWJ1Zyk7XG5cbiAgICAvLyBUT0RPOiBzZXQgdXAgZmxhZ3NcblxuICAgIHRoaXMuZGV2aWNlLm9udW5jYXB0dXJlZGVycm9yID0gZXYgPT4ge1xuICAgICAgaWYgKGV2LmVycm9yIGluc3RhbmNlb2YgR1BVVmFsaWRhdGlvbkVycm9yKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYEFuIHVuY2F1Z2h0IFdlYkdQVSB2YWxpZGF0aW9uIGVycm9yIHdhcyByYWlzZWQ6ICR7ZXYuZXJyb3IubWVzc2FnZX1gKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMuZW52LndlYmdwdSwgJ2RldmljZScsIHt2YWx1ZTogdGhpcy5kZXZpY2V9KTtcblxuICAgIC8vIGluaXQgcXVlcnlUeXBlLCB3aGljaCBpcyBuZWNlc3NhcnkgZm9yIGNyZWF0ZUtlcm5lbFxuICAgIHRoaXMuc2V0UXVlcnlUeXBlKCk7XG4gIH1cblxuICBkaXNwb3NlKCk6IHZvaWQge1xuICAgIGlmICh0eXBlb2YgdGhpcy5xdWVyeVNldCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRoaXMucXVlcnlTZXQuZGVzdHJveSgpO1xuICAgIH1cbiAgICB0aGlzLmdwdURhdGFNYW5hZ2VyLmRpc3Bvc2UoKTtcbiAgfVxuXG4gIGdldENvbW1hbmRFbmNvZGVyKCk6IEdQVUNvbW1hbmRFbmNvZGVyIHtcbiAgICBpZiAoIXRoaXMuY29tbWFuZEVuY29kZXIpIHtcbiAgICAgIHRoaXMuY29tbWFuZEVuY29kZXIgPSB0aGlzLmRldmljZS5jcmVhdGVDb21tYW5kRW5jb2RlcigpO1xuXG4gICAgICAvLyByZWZyZXNoIHF1ZXJ5VHlwZSwgYXMgc29tZXRpbWVzIHdlIG9ubHkgbmVlZCB0byBlbmFibGUgcXVlcnkgZm9yIGEgc3BlY2lmaWMgcnVuXG4gICAgICB0aGlzLnNldFF1ZXJ5VHlwZSgpO1xuICAgICAgaWYgKHRoaXMucXVlcnlUeXBlICE9PSAnbm9uZScgJiYgdHlwZW9mIHRoaXMucXVlcnlTZXQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRoaXMucXVlcnlTZXQgPSB0aGlzLmRldmljZS5jcmVhdGVRdWVyeVNldCh7XG4gICAgICAgICAgdHlwZTogJ3RpbWVzdGFtcCcsXG4gICAgICAgICAgY291bnQ6IHRoaXMubWF4RGlzcGF0Y2hOdW1iZXIgKiAyLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5xdWVyeVJlc29sdmVCdWZmZXIgPSB0aGlzLmRldmljZS5jcmVhdGVCdWZmZXIoXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYml0d2lzZVxuICAgICAgICAgICAge3NpemU6IHRoaXMubWF4RGlzcGF0Y2hOdW1iZXIgKiAyICogOCwgdXNhZ2U6IEdQVUJ1ZmZlclVzYWdlLkNPUFlfU1JDIHwgR1BVQnVmZmVyVXNhZ2UuUVVFUllfUkVTT0xWRX0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jb21tYW5kRW5jb2RlcjtcbiAgfVxuXG4gIGdldENvbXB1dGVQYXNzRW5jb2RlcigpOiBHUFVDb21wdXRlUGFzc0VuY29kZXIge1xuICAgIGlmICghdGhpcy5jb21wdXRlUGFzc0VuY29kZXIpIHtcbiAgICAgIGNvbnN0IGNvbXB1dGVQYXNzRGVzY3JpcHRvcjogR1BVQ29tcHV0ZVBhc3NEZXNjcmlwdG9yID0ge307XG5cbiAgICAgIGlmICh0aGlzLnF1ZXJ5VHlwZSA9PT0gJ2F0LXBhc3NlcycpIHtcbiAgICAgICAgY29tcHV0ZVBhc3NEZXNjcmlwdG9yLnRpbWVzdGFtcFdyaXRlcyA9IHtcbiAgICAgICAgICBxdWVyeVNldDogdGhpcy5xdWVyeVNldCEsXG4gICAgICAgICAgYmVnaW5uaW5nT2ZQYXNzV3JpdGVJbmRleDogdGhpcy5wZW5kaW5nRGlzcGF0Y2hOdW1iZXIgKiAyLFxuICAgICAgICAgIGVuZE9mUGFzc1dyaXRlSW5kZXg6IHRoaXMucGVuZGluZ0Rpc3BhdGNoTnVtYmVyICogMiArIDEsXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY29tcHV0ZVBhc3NFbmNvZGVyID0gdGhpcy5nZXRDb21tYW5kRW5jb2RlcigpLmJlZ2luQ29tcHV0ZVBhc3MoY29tcHV0ZVBhc3NEZXNjcmlwdG9yKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY29tcHV0ZVBhc3NFbmNvZGVyO1xuICB9XG5cbiAgZW5kQ29tcHV0ZVBhc3MoKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuY29tcHV0ZVBhc3NFbmNvZGVyKSB7XG4gICAgICB0aGlzLmNvbXB1dGVQYXNzRW5jb2Rlci5lbmQoKTtcbiAgICAgIHRoaXMuY29tcHV0ZVBhc3NFbmNvZGVyID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICBmbHVzaCgpOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMuY29tbWFuZEVuY29kZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBUUkFDRV9GVU5DX0JFR0lOKCk7XG5cbiAgICB0aGlzLmVuZENvbXB1dGVQYXNzKCk7XG4gICAgbGV0IHF1ZXJ5UmVhZEJ1ZmZlcjogR1BVQnVmZmVyO1xuICAgIGlmICh0aGlzLnF1ZXJ5VHlwZSAhPT0gJ25vbmUnKSB7XG4gICAgICB0aGlzLmNvbW1hbmRFbmNvZGVyLnJlc29sdmVRdWVyeVNldChcbiAgICAgICAgICB0aGlzLnF1ZXJ5U2V0ISwgMCwgdGhpcy5wZW5kaW5nRGlzcGF0Y2hOdW1iZXIgKiAyLCB0aGlzLnF1ZXJ5UmVzb2x2ZUJ1ZmZlciEsIDApO1xuXG4gICAgICBxdWVyeVJlYWRCdWZmZXIgPSB0aGlzLmRldmljZS5jcmVhdGVCdWZmZXIoXG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWJpdHdpc2VcbiAgICAgICAgICB7c2l6ZTogdGhpcy5wZW5kaW5nRGlzcGF0Y2hOdW1iZXIgKiAyICogOCwgdXNhZ2U6IEdQVUJ1ZmZlclVzYWdlLk1BUF9SRUFEIHwgR1BVQnVmZmVyVXNhZ2UuQ09QWV9EU1R9KTtcblxuICAgICAgdGhpcy5wZW5kaW5nUXVlcmllcy5zZXQocXVlcnlSZWFkQnVmZmVyLCB0aGlzLnBlbmRpbmdLZXJuZWxzKTtcbiAgICAgIHRoaXMucGVuZGluZ0tlcm5lbHMgPSBbXTtcbiAgICAgIHRoaXMuY29tbWFuZEVuY29kZXIuY29weUJ1ZmZlclRvQnVmZmVyKFxuICAgICAgICAgIHRoaXMucXVlcnlSZXNvbHZlQnVmZmVyISwgMCwgcXVlcnlSZWFkQnVmZmVyLCAwLCB0aGlzLnBlbmRpbmdEaXNwYXRjaE51bWJlciAqIDIgKiA4KTtcbiAgICB9XG5cbiAgICB0aGlzLmRldmljZS5xdWV1ZS5zdWJtaXQoW3RoaXMuY29tbWFuZEVuY29kZXIuZmluaXNoKCldKTtcbiAgICB0aGlzLmdwdURhdGFNYW5hZ2VyLnJlZnJlc2hQZW5kaW5nQnVmZmVycygpO1xuICAgIHRoaXMuY29tbWFuZEVuY29kZXIgPSBudWxsO1xuICAgIHRoaXMucGVuZGluZ0Rpc3BhdGNoTnVtYmVyID0gMDtcblxuICAgIGlmICh0aGlzLnF1ZXJ5VHlwZSAhPT0gJ25vbmUnKSB7XG4gICAgICB2b2lkIHF1ZXJ5UmVhZEJ1ZmZlciEubWFwQXN5bmMoR1BVTWFwTW9kZS5SRUFEKS50aGVuKCgpID0+IHtcbiAgICAgICAgY29uc3QgbWFwcGVkRGF0YSA9IG5ldyBCaWdVaW50NjRBcnJheShxdWVyeVJlYWRCdWZmZXIuZ2V0TWFwcGVkUmFuZ2UoKSk7XG4gICAgICAgIGNvbnN0IHBlbmRpbmdLZXJuZWxzID0gdGhpcy5wZW5kaW5nUXVlcmllcy5nZXQocXVlcnlSZWFkQnVmZmVyKSE7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWFwcGVkRGF0YS5sZW5ndGggLyAyOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBwZW5kaW5nS2VybmVsSW5mbyA9IHBlbmRpbmdLZXJuZWxzW2ldO1xuICAgICAgICAgIGNvbnN0IGtlcm5lbElkID0gcGVuZGluZ0tlcm5lbEluZm8ua2VybmVsSWQ7XG4gICAgICAgICAgY29uc3Qga2VybmVsSW5mbyA9IHRoaXMua2VybmVscy5nZXQoa2VybmVsSWQpITtcbiAgICAgICAgICBjb25zdCBrZXJuZWxUeXBlID0ga2VybmVsSW5mby5rZXJuZWxUeXBlO1xuICAgICAgICAgIGNvbnN0IGtlcm5lbE5hbWUgPSBrZXJuZWxJbmZvLmtlcm5lbE5hbWU7XG4gICAgICAgICAgY29uc3QgcHJvZ3JhbU5hbWUgPSBwZW5kaW5nS2VybmVsSW5mby5wcm9ncmFtTmFtZTtcbiAgICAgICAgICBjb25zdCBpbnB1dFRlbnNvclZpZXdzID0gcGVuZGluZ0tlcm5lbEluZm8uaW5wdXRUZW5zb3JWaWV3cztcbiAgICAgICAgICBjb25zdCBvdXRwdXRUZW5zb3JWaWV3cyA9IHBlbmRpbmdLZXJuZWxJbmZvLm91dHB1dFRlbnNvclZpZXdzO1xuICAgICAgICAgIGNvbnN0IHN0YXJ0VGltZVU2NCA9IG1hcHBlZERhdGFbaSAqIDJdO1xuICAgICAgICAgIGNvbnN0IGVuZFRpbWVVNjQgPSBtYXBwZWREYXRhW2kgKiAyICsgMV07XG5cbiAgICAgICAgICBpZiAodHlwZW9mIHRoaXMucXVlcnlUaW1lQmFzZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRoaXMucXVlcnlUaW1lQmFzZSA9IHN0YXJ0VGltZVU2NDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCBzdGFydFRpbWUgPSBOdW1iZXIoc3RhcnRUaW1lVTY0IC0gdGhpcy5xdWVyeVRpbWVCYXNlKTtcbiAgICAgICAgICBjb25zdCBlbmRUaW1lID0gTnVtYmVyKGVuZFRpbWVVNjQgLSB0aGlzLnF1ZXJ5VGltZUJhc2UpO1xuXG4gICAgICAgICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihzdGFydFRpbWUpIHx8ICFOdW1iZXIuaXNTYWZlSW50ZWdlcihlbmRUaW1lKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2luY29ycmVjdCB0aW1lc3RhbXAgcmFuZ2UnKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodGhpcy5lbnYud2ViZ3B1LnByb2ZpbGluZz8ub25kYXRhKSB7XG4gICAgICAgICAgICB0aGlzLmVudi53ZWJncHUucHJvZmlsaW5nLm9uZGF0YSh7XG4gICAgICAgICAgICAgIHZlcnNpb246IDEsXG4gICAgICAgICAgICAgIGlucHV0c01ldGFkYXRhOiBpbnB1dFRlbnNvclZpZXdzLm1hcChcbiAgICAgICAgICAgICAgICAgIHZhbHVlID0+ICh7ZGltczogdmFsdWUuZGltcywgZGF0YVR5cGU6IHRlbnNvckRhdGFUeXBlRW51bVRvU3RyaW5nKHZhbHVlLmRhdGFUeXBlKX0pKSxcbiAgICAgICAgICAgICAgb3V0cHV0c01ldGFkYXRhOiBvdXRwdXRUZW5zb3JWaWV3cy5tYXAoXG4gICAgICAgICAgICAgICAgICB2YWx1ZSA9PiAoe2RpbXM6IHZhbHVlLmRpbXMsIGRhdGFUeXBlOiB0ZW5zb3JEYXRhVHlwZUVudW1Ub1N0cmluZyh2YWx1ZS5kYXRhVHlwZSl9KSksXG4gICAgICAgICAgICAgIGtlcm5lbElkLFxuICAgICAgICAgICAgICBrZXJuZWxUeXBlLFxuICAgICAgICAgICAgICBrZXJuZWxOYW1lLFxuICAgICAgICAgICAgICBwcm9ncmFtTmFtZSxcbiAgICAgICAgICAgICAgc3RhcnRUaW1lLFxuICAgICAgICAgICAgICBlbmRUaW1lLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGlmIG5vIGNhbGxiYWNrIGlzIHByb3ZpZGVkLCBwcmludCB0aGUgcHJvZmlsaW5nIG1lc3NhZ2UgdG8gY29uc29sZVxuICAgICAgICAgICAgbGV0IGlucHV0U2hhcGVzID0gJyc7XG4gICAgICAgICAgICBpbnB1dFRlbnNvclZpZXdzLmZvckVhY2goKHZhbHVlLCBpKSA9PiB7XG4gICAgICAgICAgICAgIGlucHV0U2hhcGVzICs9IGBpbnB1dFske2l9XTogWyR7dmFsdWUuZGltc31dIHwgJHt0ZW5zb3JEYXRhVHlwZUVudW1Ub1N0cmluZyh2YWx1ZS5kYXRhVHlwZSl9LCBgO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBsZXQgb3V0cHV0U2hhcGVzID0gJyc7XG4gICAgICAgICAgICBvdXRwdXRUZW5zb3JWaWV3cy5mb3JFYWNoKCh2YWx1ZSwgaSkgPT4ge1xuICAgICAgICAgICAgICBvdXRwdXRTaGFwZXMgKz0gYG91dHB1dFske2l9XTogWyR7dmFsdWUuZGltc31dIHwgJHt0ZW5zb3JEYXRhVHlwZUVudW1Ub1N0cmluZyh2YWx1ZS5kYXRhVHlwZSl9LCBgO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgICAgICAgY29uc29sZS5sb2coYFtwcm9maWxpbmddIGtlcm5lbCBcIiR7a2VybmVsSWR9fCR7a2VybmVsVHlwZX18JHtrZXJuZWxOYW1lfXwke3Byb2dyYW1OYW1lfVwiICR7aW5wdXRTaGFwZXN9JHtcbiAgICAgICAgICAgICAgICBvdXRwdXRTaGFwZXN9ZXhlY3V0aW9uIHRpbWU6ICR7ZW5kVGltZSAtIHN0YXJ0VGltZX0gbnNgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgVFJBQ0UoJ0dQVScsIGAke3Byb2dyYW1OYW1lfTo6JHtzdGFydFRpbWVVNjR9Ojoke2VuZFRpbWVVNjR9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcXVlcnlSZWFkQnVmZmVyLnVubWFwKCk7XG4gICAgICAgIHRoaXMucGVuZGluZ1F1ZXJpZXMuZGVsZXRlKHF1ZXJ5UmVhZEJ1ZmZlcik7XG4gICAgICB9KTtcbiAgICB9XG4gICAgVFJBQ0VfRlVOQ19FTkQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBydW4gYSBXZWJHUFUgcHJvZ3JhbS5cbiAgICogQHBhcmFtIHByb2dyYW0gYSBQcm9ncmFtSW5mbyBpbnN0YW5jZVxuICAgKiBAcGFyYW0gaW5wdXRUZW5zb3JWaWV3cyBhIFRlbnNvclZpZXcgYXJyYXkuIGVhY2ggZWxlbWVudCByZXByZXNlbnRzIGEgdmFsdWUgYWxyZWFkeSBleGlzdHMgaW4gR1BVLlxuICAgKiBAcGFyYW0gb3V0cHV0SW5kaWNlcyBhbiBpbmRpY2VzIGFycmF5LiBlYWNoIGVsZW1lbnQgY2FuIGJlIGVpdGhlciAtMSAodGVtcG9yYXJ5IGRhdGEpLCAtMiAocGVyc2lzdGVudCBkYXRhKSBvciBhblxuICAgKiBpbmRleCB0byB0aGUga2VybmVsJ3Mgb3V0cHV0LlxuICAgKiBAcGFyYW0gY3JlYXRlS2VybmVsT3V0cHV0IGEgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBjcmVhdGUgYSB2YWx1ZSB0byBrZXJuZWwncyBvdXRwdXQgd2l0aCB0aGUgZ2l2ZW4gaW5kZXhcbiAgICogQHBhcmFtIGNyZWF0ZUludGVybWVkaWF0ZU91dHB1dCBhIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgY3JlYXRlIGEgdmFsdWUgYXMgYSBpbnRlcm1lZGlhdGUgdmFsdWUsIGVpdGhlciB0ZW1wb3JhcnlcbiAgICogb3IgcGVyc2lzdGVudCAob3duZWQgYnkgdGhlIGN1cnJlbnQga2VybmVsKVxuICAgKiBAcmV0dXJucyBhIFRlbnNvclZpZXcgYXJyYXkgcmVwcmVzZW50aW5nIHRoZSByZXN1bHQuXG4gICAqL1xuICBydW4ocHJvZ3JhbTogUHJvZ3JhbUluZm8sIGlucHV0VGVuc29yVmlld3M6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSwgb3V0cHV0SW5kaWNlczogcmVhZG9ubHkgbnVtYmVyW10sXG4gICAgICBjcmVhdGVLZXJuZWxPdXRwdXQ6IChpbmRleDogbnVtYmVyLCBkYXRhVHlwZTogbnVtYmVyLCBkaW1zOiByZWFkb25seSBudW1iZXJbXSkgPT4gVGVuc29yVmlldyxcbiAgICAgIGNyZWF0ZUludGVybWVkaWF0ZU91dHB1dDogKGRhdGFUeXBlOiBudW1iZXIsIGRpbXM6IHJlYWRvbmx5IG51bWJlcltdKSA9PiBUZW5zb3JWaWV3KTogVGVuc29yVmlld1tdIHtcbiAgICBUUkFDRV9GVU5DX0JFR0lOKHByb2dyYW0ubmFtZSk7XG4gICAgLy8gY3JlYXRlIGluZm8gZm9yIGlucHV0c1xuICAgIGNvbnN0IGlucHV0RGF0YXM6IEdwdURhdGFbXSA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5wdXRUZW5zb3JWaWV3cy5sZW5ndGg7ICsraSkge1xuICAgICAgY29uc3QgZ3B1RGF0YSA9IHRoaXMuZ3B1RGF0YU1hbmFnZXIuZ2V0KGlucHV0VGVuc29yVmlld3NbaV0uZGF0YSk7XG4gICAgICBpZiAoIWdwdURhdGEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBubyBHUFUgZGF0YSBmb3IgaW5wdXQ6ICR7aW5wdXRUZW5zb3JWaWV3c1tpXS5kYXRhfWApO1xuICAgICAgfVxuICAgICAgaW5wdXREYXRhc1tpXSA9IGdwdURhdGE7XG4gICAgfVxuXG4gICAgY29uc3Qge291dHB1dHMsIGRpc3BhdGNoR3JvdXAsIHByb2dyYW1Vbmlmb3Jtc30gPSBwcm9ncmFtLmdldFJ1bkRhdGEoaW5wdXRUZW5zb3JWaWV3cyk7XG5cbiAgICAvLyBjaGVjayBvdXRwdXQgaW5kaWNlc1xuICAgIGNvbnN0IHZhbGlkYXRlZE91dHB1dEluZGljZXMgPSBvdXRwdXRJbmRpY2VzLmxlbmd0aCA9PT0gMCA/IG91dHB1dHMubWFwKChfLCBpKSA9PiBpKSA6IG91dHB1dEluZGljZXM7XG4gICAgaWYgKHZhbGlkYXRlZE91dHB1dEluZGljZXMubGVuZ3RoICE9PSBvdXRwdXRzLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBPdXRwdXQgc2l6ZSAke3ZhbGlkYXRlZE91dHB1dEluZGljZXMubGVuZ3RofSBtdXN0IGJlIGVxdWFsIHRvICR7b3V0cHV0cy5sZW5ndGh9LmApO1xuICAgIH1cblxuICAgIC8vIGNyZWF0ZSBpbmZvIGZvciBvdXRwdXRzXG4gICAgY29uc3Qgb3V0cHV0VGVuc29yVmlld3M6IFRlbnNvclZpZXdbXSA9IFtdO1xuICAgIGNvbnN0IG91dHB1dERhdGFzOiBHcHVEYXRhW10gPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG91dHB1dHMubGVuZ3RoOyArK2kpIHtcbiAgICAgIC8vIHZhbHVlIC0xIGFuZCAtMiBhcmUgdXNlZCBmb3IgY3JlYXRpbmcgdGVtcG9yYXJ5IGFuZCBwZXJzaXN0ZW50IG91dHB1dHMuXG4gICAgICAvLyB2YWx1ZSAtMyBpcyB1c2VkIGZvciBwbGFjZWhvbGRlciBvdXRwdXQuIFNvIC0zLCAtMiwgLTEgYW5kIDAsIDEsIDIsIC4uLiBhcmUgdmFsaWRcbiAgICAgIC8vIG91dHB1dCBpbmRpY2VzLiBzZWUgdHlwZSBkZWZpbml0aW9uIG9mIENvbXB1dGVDb250ZXh0SW5wdXRzT3V0cHV0c01hcHBpbmcgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcih2YWxpZGF0ZWRPdXRwdXRJbmRpY2VzW2ldKSB8fCB2YWxpZGF0ZWRPdXRwdXRJbmRpY2VzW2ldIDwgLTMgfHxcbiAgICAgICAgICB2YWxpZGF0ZWRPdXRwdXRJbmRpY2VzW2ldID49IG91dHB1dHMubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBvdXRwdXQgaW5kZXg6ICR7dmFsaWRhdGVkT3V0cHV0SW5kaWNlc1tpXX1gKTtcbiAgICAgIH1cbiAgICAgIGlmICh2YWxpZGF0ZWRPdXRwdXRJbmRpY2VzW2ldID09PSAtMykge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGlzVGVtcG9yYXJ5ID0gdmFsaWRhdGVkT3V0cHV0SW5kaWNlc1tpXSA9PT0gLTE7XG4gICAgICBjb25zdCBpc1BlcnNpc3RlbnQgPSB2YWxpZGF0ZWRPdXRwdXRJbmRpY2VzW2ldID09PSAtMjtcbiAgICAgIGNvbnN0IHRlbnNvclZpZXcgPSAoaXNUZW1wb3JhcnkgfHwgaXNQZXJzaXN0ZW50KSA/XG4gICAgICAgICAgY3JlYXRlSW50ZXJtZWRpYXRlT3V0cHV0KG91dHB1dHNbaV0uZGF0YVR5cGUsIG91dHB1dHNbaV0uZGltcykgOlxuICAgICAgICAgIGNyZWF0ZUtlcm5lbE91dHB1dCh2YWxpZGF0ZWRPdXRwdXRJbmRpY2VzW2ldLCBvdXRwdXRzW2ldLmRhdGFUeXBlLCBvdXRwdXRzW2ldLmRpbXMpO1xuICAgICAgY29uc3QgZ3B1RGF0YSA9IHRoaXMuZ3B1RGF0YU1hbmFnZXIuZ2V0KHRlbnNvclZpZXcuZGF0YSk7XG4gICAgICBpZiAoIWdwdURhdGEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBubyBHUFUgZGF0YSBmb3Igb3V0cHV0OiAke3RlbnNvclZpZXcuZGF0YX1gKTtcbiAgICAgIH1cbiAgICAgIGlmIChpc1RlbXBvcmFyeSkge1xuICAgICAgICB0aGlzLnRlbXBvcmFyeURhdGEucHVzaChncHVEYXRhKTtcbiAgICAgIH1cbiAgICAgIGlmIChpc1BlcnNpc3RlbnQpIHtcbiAgICAgICAgbGV0IHBlcnNpc3RlbnREYXRhID0gdGhpcy5rZXJuZWxQZXJzaXN0ZW50RGF0YS5nZXQodGhpcy5jdXJyZW50S2VybmVsSWQhKTtcbiAgICAgICAgaWYgKCFwZXJzaXN0ZW50RGF0YSkge1xuICAgICAgICAgIHBlcnNpc3RlbnREYXRhID0gW107XG4gICAgICAgICAgdGhpcy5rZXJuZWxQZXJzaXN0ZW50RGF0YS5zZXQodGhpcy5jdXJyZW50S2VybmVsSWQhLCBwZXJzaXN0ZW50RGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgcGVyc2lzdGVudERhdGEucHVzaChncHVEYXRhKTtcbiAgICAgIH1cbiAgICAgIG91dHB1dFRlbnNvclZpZXdzLnB1c2godGVuc29yVmlldyk7XG4gICAgICBvdXRwdXREYXRhcy5wdXNoKGdwdURhdGEpO1xuICAgIH1cblxuXG4gICAgLy8gbG9hZCB1bmlmb3Jtc1xuICAgIC8vIFRPRE86IGFkZCBjYWNoZSBmb3IgdW5pZm9ybSAoaXMgaXQgbmVjZXNzYXJ5PylcbiAgICAvL1xuICAgIGxldCB1bmlmb3JtQnVmZmVyQmluZGluZzogR1BVQmluZGluZ1Jlc291cmNlfHVuZGVmaW5lZDtcbiAgICBpZiAocHJvZ3JhbVVuaWZvcm1zKSB7XG4gICAgICBsZXQgY3VycmVudE9mZnNldCA9IDA7XG4gICAgICBjb25zdCBvZmZzZXRzOiBudW1iZXJbXSA9IFtdO1xuXG4gICAgICBwcm9ncmFtVW5pZm9ybXMuZm9yRWFjaCh2ID0+IHtcbiAgICAgICAgY29uc3QgZGF0YSA9IHR5cGVvZiB2LmRhdGEgPT09ICdudW1iZXInID8gW3YuZGF0YV0gOiB2LmRhdGE7XG4gICAgICAgIGlmIChkYXRhLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBodHRwczovL3d3dy53My5vcmcvVFIvV0dTTC8jYWxpZ25vZlxuICAgICAgICBjb25zdCBiYXNlQWxpZ25tZW50ID0gZGF0YS5sZW5ndGggPD0gMiA/IGRhdGEubGVuZ3RoICogNCA6IDE2O1xuICAgICAgICBjdXJyZW50T2Zmc2V0ID0gTWF0aC5jZWlsKGN1cnJlbnRPZmZzZXQgLyBiYXNlQWxpZ25tZW50KSAqIGJhc2VBbGlnbm1lbnQ7XG4gICAgICAgIG9mZnNldHMucHVzaChjdXJyZW50T2Zmc2V0KTtcbiAgICAgICAgLy8gV2hlbiBkYXRhLmxlbmd0aCA+IDQsIHRoZSB1bmlmb3JtIHZhcmlhYmxlIGlzIG9mIHR5cGUgYXJyYXk8dmVjNDxpMzJ8dTMyfGYzMj4sTj4sIHdoZXJlIE4gPVxuICAgICAgICAvLyBNYXRoLmNlaWwoZGF0YS5sZW5ndGggLyA0KSBhbmQgU2l6ZU9mKHZlYzQ8aTMyfHUzMnxmMzI+KSA9IDE2LiBUaGUgdG90YWwgYnl0ZSBsZW5ndGggaXMgTiAqXG4gICAgICAgIC8vIFNpemVPZih2ZWM0PGkzMnx1MzJ8ZjMyPikuXG4gICAgICAgIGN1cnJlbnRPZmZzZXQgKz0gZGF0YS5sZW5ndGggPiA0ID8gTWF0aC5jZWlsKGRhdGEubGVuZ3RoIC8gNCkgKiAxNiA6IGRhdGEubGVuZ3RoICogNDtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBNZWV0IGFsaWdubWVudCBvZiBzdHJ1Y3QgaGVyZTogaHR0cHM6Ly93d3cudzMub3JnL1RSL1dHU0wvI2FsaWdubWVudC1hbmQtc2l6ZS4gRm9yIHNpbXBsaWNpdHksIHNldFxuICAgICAgLy8gbWF4QWxpZ25tZW50T2ZGaWVsZCB0byAxNiBzaW5jZSB0aGUgdW5kZXJseWluZyBidWZmZXIgaGFzIGJlZW4gcm91bmRlZCB1cCB0byAxNi5cbiAgICAgIGNvbnN0IG1heEFsaWdubWVudE9mRmllbGQgPSAxNjtcbiAgICAgIGN1cnJlbnRPZmZzZXQgPSBNYXRoLmNlaWwoY3VycmVudE9mZnNldCAvIG1heEFsaWdubWVudE9mRmllbGQpICogbWF4QWxpZ25tZW50T2ZGaWVsZDtcbiAgICAgIGNvbnN0IGFycmF5QnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKGN1cnJlbnRPZmZzZXQpO1xuICAgICAgcHJvZ3JhbVVuaWZvcm1zLmZvckVhY2goKHYsIGkpID0+IHtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gb2Zmc2V0c1tpXTtcbiAgICAgICAgY29uc3QgZGF0YSA9IHR5cGVvZiB2LmRhdGEgPT09ICdudW1iZXInID8gW3YuZGF0YV0gOiB2LmRhdGE7XG4gICAgICAgIGlmICh2LnR5cGUgPT09ICdpbnQzMicpIHtcbiAgICAgICAgICBuZXcgSW50MzJBcnJheShhcnJheUJ1ZmZlciwgb2Zmc2V0LCBkYXRhLmxlbmd0aCkuc2V0KGRhdGEpO1xuICAgICAgICB9IGVsc2UgaWYgKHYudHlwZSA9PT0gJ3VpbnQzMicpIHtcbiAgICAgICAgICBuZXcgVWludDMyQXJyYXkoYXJyYXlCdWZmZXIsIG9mZnNldCwgZGF0YS5sZW5ndGgpLnNldChkYXRhKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXcgRmxvYXQzMkFycmF5KGFycmF5QnVmZmVyLCBvZmZzZXQsIGRhdGEubGVuZ3RoKS5zZXQoZGF0YSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCB1bmlmb3JtQnVmZmVyRGF0YSA9XG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWJpdHdpc2VcbiAgICAgICAgICB0aGlzLmdwdURhdGFNYW5hZ2VyLmNyZWF0ZShjdXJyZW50T2Zmc2V0LCBHUFVCdWZmZXJVc2FnZS5DT1BZX0RTVCB8IEdQVUJ1ZmZlclVzYWdlLlVOSUZPUk0pO1xuICAgICAgdGhpcy5kZXZpY2UucXVldWUud3JpdGVCdWZmZXIodW5pZm9ybUJ1ZmZlckRhdGEuYnVmZmVyLCAwLCBhcnJheUJ1ZmZlciwgMCwgY3VycmVudE9mZnNldCk7XG4gICAgICB0aGlzLmdwdURhdGFNYW5hZ2VyLnJlbGVhc2UodW5pZm9ybUJ1ZmZlckRhdGEuaWQpO1xuICAgICAgdW5pZm9ybUJ1ZmZlckJpbmRpbmcgPSB7b2Zmc2V0OiAwLCBzaXplOiBjdXJyZW50T2Zmc2V0LCBidWZmZXI6IHVuaWZvcm1CdWZmZXJEYXRhLmJ1ZmZlcn07XG4gICAgfVxuXG4gICAgY29uc3Qgbm9ybWFsaXplZERpc3BhdGNoR3JvdXAgPSB0aGlzLnByb2dyYW1NYW5hZ2VyLm5vcm1hbGl6ZURpc3BhdGNoR3JvdXBTaXplKGRpc3BhdGNoR3JvdXApO1xuICAgIGNvbnN0IGlzMURpbWVuc2lvbkRpc3BhdGNoID0gbm9ybWFsaXplZERpc3BhdGNoR3JvdXBbMV0gPT09IDEgJiYgbm9ybWFsaXplZERpc3BhdGNoR3JvdXBbMl0gPT09IDE7XG4gICAgLy8gZ2V0IHByb2dyYW0gaW5mb1xuICAgIGNvbnN0IGtleSA9IGdldFByb2dyYW1JbmZvVW5pcXVlS2V5KHByb2dyYW0sIGlucHV0VGVuc29yVmlld3MsIGlzMURpbWVuc2lvbkRpc3BhdGNoKTtcbiAgICBsZXQgYXJ0aWZhY3QgPSB0aGlzLnByb2dyYW1NYW5hZ2VyLmdldEFydGlmYWN0KGtleSk7XG4gICAgaWYgKCFhcnRpZmFjdCkge1xuICAgICAgYXJ0aWZhY3QgPSB0aGlzLnByb2dyYW1NYW5hZ2VyLmJ1aWxkKHByb2dyYW0sIG5vcm1hbGl6ZWREaXNwYXRjaEdyb3VwKTtcbiAgICAgIHRoaXMucHJvZ3JhbU1hbmFnZXIuc2V0QXJ0aWZhY3Qoa2V5LCBhcnRpZmFjdCk7XG4gICAgICBMT0dfREVCVUcoJ2luZm8nLCAoKSA9PiBgW2FydGlmYWN0XSBrZXk6ICR7a2V5fSwgcHJvZ3JhbU5hbWU6ICR7cHJvZ3JhbS5uYW1lfWApO1xuICAgIH1cblxuICAgIExPR19ERUJVRyhcbiAgICAgICAgJ2luZm8nLFxuICAgICAgICAoKSA9PiBgW1Byb2dyYW1NYW5hZ2VyXSBydW4gXCIke3Byb2dyYW0ubmFtZX1cIiAoa2V5PSR7a2V5fSkgd2l0aCAke25vcm1hbGl6ZWREaXNwYXRjaEdyb3VwWzBdfXgke1xuICAgICAgICAgICAgbm9ybWFsaXplZERpc3BhdGNoR3JvdXBbMV19eCR7bm9ybWFsaXplZERpc3BhdGNoR3JvdXBbMl19YCk7XG5cbiAgICBpZiAodGhpcy5xdWVyeVR5cGUgIT09ICdub25lJykge1xuICAgICAgY29uc3QgcGVuZGluZ0tlcm5lbEluZm86IFBlbmRpbmdLZXJuZWxJbmZvID0ge1xuICAgICAgICBrZXJuZWxJZDogdGhpcy5jdXJyZW50S2VybmVsSWQhLFxuICAgICAgICBwcm9ncmFtTmFtZTogYXJ0aWZhY3QucHJvZ3JhbUluZm8ubmFtZSxcbiAgICAgICAgaW5wdXRUZW5zb3JWaWV3cyxcbiAgICAgICAgb3V0cHV0VGVuc29yVmlld3MsXG4gICAgICB9O1xuICAgICAgdGhpcy5wZW5kaW5nS2VybmVscy5wdXNoKHBlbmRpbmdLZXJuZWxJbmZvKTtcbiAgICB9XG5cbiAgICB0aGlzLnByb2dyYW1NYW5hZ2VyLnJ1bihhcnRpZmFjdCwgaW5wdXREYXRhcywgb3V0cHV0RGF0YXMsIG5vcm1hbGl6ZWREaXNwYXRjaEdyb3VwLCB1bmlmb3JtQnVmZmVyQmluZGluZyk7XG5cbiAgICBUUkFDRV9GVU5DX0VORChwcm9ncmFtLm5hbWUpO1xuICAgIHJldHVybiBvdXRwdXRUZW5zb3JWaWV3cztcbiAgfVxuXG4gIHVwbG9hZChncHVEYXRhSWQ6IG51bWJlciwgZGF0YTogVWludDhBcnJheSk6IHZvaWQge1xuICAgIHRoaXMuZ3B1RGF0YU1hbmFnZXIudXBsb2FkKGdwdURhdGFJZCwgZGF0YSk7XG4gIH1cblxuICBtZW1jcHkoc3JjOiBudW1iZXIsIGRzdDogbnVtYmVyKTogdm9pZCB7XG4gICAgdGhpcy5ncHVEYXRhTWFuYWdlci5tZW1jcHkoc3JjLCBkc3QpO1xuICB9XG5cbiAgYXN5bmMgZG93bmxvYWQoZ3B1RGF0YUlkOiBudW1iZXIsIGdldFRhcmdldEJ1ZmZlcjogKCkgPT4gVWludDhBcnJheSk6IFByb21pc2U8dm9pZD4ge1xuICAgIC8vIHRoZSB1bmRlcmx5aW5nIGJ1ZmZlciBtYXkgYmUgY2hhbmdlZCBhZnRlciB0aGUgYXN5bmMgZnVuY3Rpb24gaXMgY2FsbGVkLiBzbyB3ZSB1c2UgYSBnZXR0ZXIgZnVuY3Rpb24gdG8gbWFrZSBzdXJlXG4gICAgLy8gdGhlIGJ1ZmZlciBpcyB1cC10by1kYXRlLlxuICAgIGF3YWl0IHRoaXMuZ3B1RGF0YU1hbmFnZXIuZG93bmxvYWQoZ3B1RGF0YUlkLCBnZXRUYXJnZXRCdWZmZXIpO1xuICB9XG5cbiAgYWxsb2Moc2l6ZTogbnVtYmVyKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5ncHVEYXRhTWFuYWdlci5jcmVhdGUoc2l6ZSkuaWQ7XG4gIH1cblxuICBmcmVlKHB0cjogbnVtYmVyKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5ncHVEYXRhTWFuYWdlci5yZWxlYXNlKHB0cik7XG4gIH1cblxuICBjcmVhdGVLZXJuZWwoa2VybmVsVHlwZTogc3RyaW5nLCBrZXJuZWxJZDogbnVtYmVyLCBhdHRyaWJ1dGU6IHVua25vd24sIGtlcm5lbE5hbWU6IHN0cmluZyk6IHZvaWQge1xuICAgIGNvbnN0IG9wID0gV0VCR1BVX09QX1JFU09MVkVfUlVMRVMuZ2V0KGtlcm5lbFR5cGUpO1xuICAgIGlmICghb3ApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihga2VybmVsIG5vdCBpbXBsZW1lbnRlZDogJHtrZXJuZWxUeXBlfWApO1xuICAgIH1cblxuICAgIGNvbnN0IGtlcm5lbEluZm86IEtlcm5lbEluZm8gPSB7XG4gICAgICBrZXJuZWxUeXBlLFxuICAgICAga2VybmVsTmFtZSxcbiAgICAgIGtlcm5lbEVudHJ5OiBvcFswXSxcbiAgICAgIGF0dHJpYnV0ZXM6IFtvcFsxXSwgYXR0cmlidXRlXSxcbiAgICB9O1xuICAgIHRoaXMua2VybmVscy5zZXQoa2VybmVsSWQsIGtlcm5lbEluZm8pO1xuICB9XG5cbiAgcmVsZWFzZUtlcm5lbChrZXJuZWxJZDogbnVtYmVyKTogdm9pZCB7XG4gICAgY29uc3QgcGVyc2lzdGVudERhdGEgPSB0aGlzLmtlcm5lbFBlcnNpc3RlbnREYXRhLmdldChrZXJuZWxJZCk7XG4gICAgaWYgKHBlcnNpc3RlbnREYXRhKSB7XG4gICAgICBmb3IgKGNvbnN0IGRhdGEgb2YgcGVyc2lzdGVudERhdGEpIHtcbiAgICAgICAgdGhpcy5ncHVEYXRhTWFuYWdlci5yZWxlYXNlKGRhdGEuaWQpO1xuICAgICAgfVxuICAgICAgdGhpcy5rZXJuZWxQZXJzaXN0ZW50RGF0YS5kZWxldGUoa2VybmVsSWQpO1xuICAgIH1cblxuICAgIHRoaXMua2VybmVsQ3VzdG9tRGF0YS5kZWxldGUoa2VybmVsSWQpO1xuICAgIHRoaXMua2VybmVscy5kZWxldGUoa2VybmVsSWQpO1xuICB9XG5cbiAgY29tcHV0ZUtlcm5lbChrZXJuZWxJZDogbnVtYmVyLCBjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgZXJyb3JzOiBBcnJheTxQcm9taXNlPHN0cmluZ3xudWxsPj4pOiBudW1iZXIge1xuICAgIGNvbnN0IGtlcm5lbCA9IHRoaXMua2VybmVscy5nZXQoa2VybmVsSWQpO1xuICAgIGlmICgha2VybmVsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGtlcm5lbCBub3QgY3JlYXRlZDogJHtrZXJuZWxJZH1gKTtcbiAgICB9XG4gICAgY29uc3Qga2VybmVsVHlwZSA9IGtlcm5lbC5rZXJuZWxUeXBlO1xuICAgIGNvbnN0IGtlcm5lbE5hbWUgPSBrZXJuZWwua2VybmVsTmFtZTtcbiAgICBjb25zdCBrZXJuZWxFbnRyeSA9IGtlcm5lbC5rZXJuZWxFbnRyeTtcbiAgICBjb25zdCBhdHRyaWJ1dGVzID0ga2VybmVsLmF0dHJpYnV0ZXM7XG4gICAgaWYgKHRoaXMuY3VycmVudEtlcm5lbElkICE9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGtlcm5lbCBcIlske2tlcm5lbFR5cGV9XSAke2tlcm5lbE5hbWV9XCIgaXMgbm90IGFsbG93ZWQgdG8gYmUgY2FsbGVkIHJlY3Vyc2l2ZWx5YCk7XG4gICAgfVxuICAgIHRoaXMuY3VycmVudEtlcm5lbElkID0ga2VybmVsSWQ7XG5cbiAgICAvLyBwYXJzZSBhdHRyaWJ1dGVzIGlmIG5lY2Vzc2FyeVxuICAgIGlmIChhdHRyaWJ1dGVzWzBdKSB7XG4gICAgICBhdHRyaWJ1dGVzWzFdID0gYXR0cmlidXRlc1swXShhdHRyaWJ1dGVzWzFdKTtcbiAgICAgIGF0dHJpYnV0ZXNbMF0gPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgTE9HX0RFQlVHKCdpbmZvJywgKCkgPT4gYFtXZWJHUFVdIFN0YXJ0IHRvIHJ1biBrZXJuZWwgXCJbJHtrZXJuZWxUeXBlfV0gJHtrZXJuZWxOYW1lfVwiLi4uYCk7XG5cbiAgICBjb25zdCB1c2VFcnJvclNjb3BlID0gdGhpcy5lbnYuZGVidWc7XG5cbiAgICB0aGlzLnRlbXBvcmFyeURhdGEgPSBbXTtcbiAgICB0cnkge1xuICAgICAgaWYgKHVzZUVycm9yU2NvcGUpIHtcbiAgICAgICAgdGhpcy5kZXZpY2UucHVzaEVycm9yU2NvcGUoJ3ZhbGlkYXRpb24nKTtcbiAgICAgIH1cblxuICAgICAga2VybmVsRW50cnkoY29udGV4dCwgYXR0cmlidXRlc1sxXSk7XG4gICAgICByZXR1cm4gMDsgIC8vIE9SVF9PS1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGVycm9ycy5wdXNoKFByb21pc2UucmVzb2x2ZShgW1dlYkdQVV0gS2VybmVsIFwiWyR7a2VybmVsVHlwZX1dICR7a2VybmVsTmFtZX1cIiBmYWlsZWQuICR7ZX1gKSk7XG4gICAgICByZXR1cm4gMTsgIC8vIE9SVF9GQUlMXG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmICh1c2VFcnJvclNjb3BlKSB7XG4gICAgICAgIGVycm9ycy5wdXNoKHRoaXMuZGV2aWNlLnBvcEVycm9yU2NvcGUoKS50aGVuKFxuICAgICAgICAgICAgZXJyID0+IGVyciA/IGBHUFUgdmFsaWRhdGlvbiBlcnJvciBmb3Iga2VybmVsIFwiWyR7a2VybmVsVHlwZX1dICR7a2VybmVsTmFtZX1cIjogJHtlcnIubWVzc2FnZX1gIDogbnVsbCkpO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGNvbnN0IGRhdGEgb2YgdGhpcy50ZW1wb3JhcnlEYXRhKSB7XG4gICAgICAgIHRoaXMuZ3B1RGF0YU1hbmFnZXIucmVsZWFzZShkYXRhLmlkKTtcbiAgICAgIH1cbiAgICAgIHRoaXMudGVtcG9yYXJ5RGF0YSA9IFtdO1xuICAgICAgdGhpcy5jdXJyZW50S2VybmVsSWQgPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIC8vICNyZWdpb24gZXh0ZXJuYWwgYnVmZmVyXG4gIHJlZ2lzdGVyQnVmZmVyKHNlc3Npb25JZDogbnVtYmVyLCBpbmRleDogbnVtYmVyLCBidWZmZXI6IEdQVUJ1ZmZlciwgc2l6ZTogbnVtYmVyKTogbnVtYmVyIHtcbiAgICBsZXQgc2Vzc2lvbklucHV0T3V0cHV0TWFwcGluZyA9IHRoaXMuc2Vzc2lvbkV4dGVybmFsRGF0YU1hcHBpbmcuZ2V0KHNlc3Npb25JZCk7XG4gICAgaWYgKCFzZXNzaW9uSW5wdXRPdXRwdXRNYXBwaW5nKSB7XG4gICAgICBzZXNzaW9uSW5wdXRPdXRwdXRNYXBwaW5nID0gbmV3IE1hcCgpO1xuICAgICAgdGhpcy5zZXNzaW9uRXh0ZXJuYWxEYXRhTWFwcGluZy5zZXQoc2Vzc2lvbklkLCBzZXNzaW9uSW5wdXRPdXRwdXRNYXBwaW5nKTtcbiAgICB9XG5cbiAgICBjb25zdCBwcmV2aW91c0J1ZmZlciA9IHNlc3Npb25JbnB1dE91dHB1dE1hcHBpbmcuZ2V0KGluZGV4KTtcbiAgICBjb25zdCBpZCA9IHRoaXMuZ3B1RGF0YU1hbmFnZXIucmVnaXN0ZXJFeHRlcm5hbEJ1ZmZlcihidWZmZXIsIHNpemUsIHByZXZpb3VzQnVmZmVyPy5bMV0pO1xuICAgIHNlc3Npb25JbnB1dE91dHB1dE1hcHBpbmcuc2V0KGluZGV4LCBbaWQsIGJ1ZmZlcl0pO1xuICAgIHJldHVybiBpZDtcbiAgfVxuICB1bnJlZ2lzdGVyQnVmZmVycyhzZXNzaW9uSWQ6IG51bWJlcik6IHZvaWQge1xuICAgIGNvbnN0IHNlc3Npb25JbnB1dE91dHB1dE1hcHBpbmcgPSB0aGlzLnNlc3Npb25FeHRlcm5hbERhdGFNYXBwaW5nLmdldChzZXNzaW9uSWQpO1xuICAgIGlmIChzZXNzaW9uSW5wdXRPdXRwdXRNYXBwaW5nKSB7XG4gICAgICBzZXNzaW9uSW5wdXRPdXRwdXRNYXBwaW5nLmZvckVhY2goYnVmZmVySW5mbyA9PiB0aGlzLmdwdURhdGFNYW5hZ2VyLnVucmVnaXN0ZXJFeHRlcm5hbEJ1ZmZlcihidWZmZXJJbmZvWzFdKSk7XG4gICAgICB0aGlzLnNlc3Npb25FeHRlcm5hbERhdGFNYXBwaW5nLmRlbGV0ZShzZXNzaW9uSWQpO1xuICAgIH1cbiAgfVxuICBnZXRCdWZmZXIoZ3B1RGF0YUlkOiBudW1iZXIpOiBHUFVCdWZmZXIge1xuICAgIGNvbnN0IGdwdURhdGEgPSB0aGlzLmdwdURhdGFNYW5hZ2VyLmdldChncHVEYXRhSWQpO1xuICAgIGlmICghZ3B1RGF0YSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBubyBHUFUgZGF0YSBmb3IgYnVmZmVyOiAke2dwdURhdGFJZH1gKTtcbiAgICB9XG4gICAgcmV0dXJuIGdwdURhdGEuYnVmZmVyO1xuICB9XG4gIGNyZWF0ZURvd25sb2FkZXIoZ3B1QnVmZmVyOiBHUFVCdWZmZXIsIHNpemU6IG51bWJlciwgdHlwZTogVGVuc29yLkdwdUJ1ZmZlckRhdGFUeXBlcyk6XG4gICAgICAoKSA9PiBQcm9taXNlPFRlbnNvci5EYXRhVHlwZT4ge1xuICAgIHJldHVybiBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgZG93bmxvYWRHcHVEYXRhKHRoaXMsIGdwdUJ1ZmZlciwgc2l6ZSk7XG4gICAgICByZXR1cm4gY3JlYXRlVmlldyhkYXRhLmJ1ZmZlciwgdHlwZSk7XG4gICAgfTtcbiAgfVxuICB3cml0ZVRpbWVzdGFtcChpbmRleDogbnVtYmVyKTogdm9pZCB7XG4gICAgaWYgKHRoaXMucXVlcnlUeXBlICE9PSAnaW5zaWRlLXBhc3NlcycpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICh0aGlzLmNvbXB1dGVQYXNzRW5jb2RlciBhcyBhbnkpLndyaXRlVGltZXN0YW1wKHRoaXMucXVlcnlTZXQsIGluZGV4KTtcbiAgfVxuICBzZXRRdWVyeVR5cGUoKTogdm9pZCB7XG4gICAgdGhpcy5xdWVyeVR5cGUgPSAnbm9uZSc7XG4gICAgaWYgKHRoaXMuZW52LndlYmdwdS5wcm9maWxpbmc/Lm1vZGUgPT09ICdkZWZhdWx0JyB8fCB0aGlzLmVudi53YXNtLnRyYWNlKSB7XG4gICAgICBpZiAodGhpcy5kZXZpY2UuZmVhdHVyZXMuaGFzKCdjaHJvbWl1bS1leHBlcmltZW50YWwtdGltZXN0YW1wLXF1ZXJ5LWluc2lkZS1wYXNzZXMnKSkge1xuICAgICAgICB0aGlzLnF1ZXJ5VHlwZSA9ICdpbnNpZGUtcGFzc2VzJztcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5kZXZpY2UuZmVhdHVyZXMuaGFzKCd0aW1lc3RhbXAtcXVlcnknKSkge1xuICAgICAgICB0aGlzLnF1ZXJ5VHlwZSA9ICdhdC1wYXNzZXMnO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvLyAjZW5kcmVnaW9uXG59XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7RW52fSBmcm9tICdvbm54cnVudGltZS1jb21tb24nO1xuXG5pbXBvcnQge09ydFdhc21Nb2R1bGV9IGZyb20gJy4uL2JpbmRpbmcvb3J0LXdhc20nO1xuaW1wb3J0IHtEYXRhVHlwZSwgZ2V0VGVuc29yRWxlbWVudFNpemV9IGZyb20gJy4uL3dhc20tY29tbW9uJztcblxuaW1wb3J0IHtXZWJHcHVCYWNrZW5kfSBmcm9tICcuL2JhY2tlbmQtd2ViZ3B1JztcbmltcG9ydCB7TE9HX0RFQlVHfSBmcm9tICcuL2xvZyc7XG5pbXBvcnQge1RlbnNvclZpZXd9IGZyb20gJy4vdGVuc29yLXZpZXcnO1xuaW1wb3J0IHtTaGFwZVV0aWx9IGZyb20gJy4vdXRpbCc7XG5pbXBvcnQge0NvbXB1dGVDb250ZXh0LCBDb21wdXRlQ29udGV4dElucHV0c091dHB1dHNNYXBwaW5nLCBQcm9ncmFtSW5mb30gZnJvbSAnLi93ZWJncHUvdHlwZXMnO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1iaXR3aXNlICovXG5cbmNsYXNzIFRlbnNvclZpZXdJbXBsIGltcGxlbWVudHMgVGVuc29yVmlldyB7XG4gIGNvbnN0cnVjdG9yKFxuICAgICAgcHJpdmF0ZSBtb2R1bGU6IE9ydFdhc21Nb2R1bGUsIHB1YmxpYyByZWFkb25seSBkYXRhVHlwZTogbnVtYmVyLCBwdWJsaWMgcmVhZG9ubHkgZGF0YTogbnVtYmVyLFxuICAgICAgcHVibGljIHJlYWRvbmx5IGRpbXM6IHJlYWRvbmx5IG51bWJlcltdKSB7fVxuXG4gIGdldEZsb2F0MzJBcnJheSgpOiBGbG9hdDMyQXJyYXkge1xuICAgIGlmICh0aGlzLmRhdGFUeXBlICE9PSBEYXRhVHlwZS5mbG9hdCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGRhdGEgdHlwZScpO1xuICAgIH1cbiAgICBjb25zdCBlbGVtZW50Q291bnQgPSBTaGFwZVV0aWwuc2l6ZSh0aGlzLmRpbXMpO1xuICAgIHJldHVybiBlbGVtZW50Q291bnQgPT09IDAgPyBuZXcgRmxvYXQzMkFycmF5KCkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXcgRmxvYXQzMkFycmF5KHRoaXMubW9kdWxlLkhFQVA4LmJ1ZmZlciwgdGhpcy5kYXRhLCBlbGVtZW50Q291bnQpO1xuICB9XG5cbiAgZ2V0QmlnSW50NjRBcnJheSgpOiBCaWdJbnQ2NEFycmF5IHtcbiAgICBpZiAodGhpcy5kYXRhVHlwZSAhPT0gRGF0YVR5cGUuaW50NjQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBkYXRhIHR5cGUnKTtcbiAgICB9XG4gICAgY29uc3QgZWxlbWVudENvdW50ID0gU2hhcGVVdGlsLnNpemUodGhpcy5kaW1zKTtcbiAgICByZXR1cm4gZWxlbWVudENvdW50ID09PSAwID8gbmV3IEJpZ0ludDY0QXJyYXkoKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBCaWdJbnQ2NEFycmF5KHRoaXMubW9kdWxlLkhFQVA4LmJ1ZmZlciwgdGhpcy5kYXRhLCBlbGVtZW50Q291bnQpO1xuICB9XG5cbiAgZ2V0SW50MzJBcnJheSgpOiBJbnQzMkFycmF5IHtcbiAgICBpZiAodGhpcy5kYXRhVHlwZSAhPT0gRGF0YVR5cGUuaW50MzIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBkYXRhIHR5cGUnKTtcbiAgICB9XG4gICAgY29uc3QgZWxlbWVudENvdW50ID0gU2hhcGVVdGlsLnNpemUodGhpcy5kaW1zKTtcbiAgICByZXR1cm4gZWxlbWVudENvdW50ID09PSAwID8gbmV3IEludDMyQXJyYXkoKSA6IG5ldyBJbnQzMkFycmF5KHRoaXMubW9kdWxlLkhFQVA4LmJ1ZmZlciwgdGhpcy5kYXRhLCBlbGVtZW50Q291bnQpO1xuICB9XG5cbiAgcmVzaGFwZShuZXdEaW1zOiByZWFkb25seSBudW1iZXJbXSk6IFRlbnNvclZpZXcge1xuICAgIGlmIChTaGFwZVV0aWwuc2l6ZShuZXdEaW1zKSAhPT0gU2hhcGVVdGlsLnNpemUodGhpcy5kaW1zKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG5ldyBzaGFwZScpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFRlbnNvclZpZXdJbXBsKHRoaXMubW9kdWxlLCB0aGlzLmRhdGFUeXBlLCB0aGlzLmRhdGEsIG5ld0RpbXMpO1xuICB9XG59XG5cbmNsYXNzIENvbXB1dGVDb250ZXh0SW1wbCBpbXBsZW1lbnRzIENvbXB1dGVDb250ZXh0IHtcbiAgcmVhZG9ubHkgb3BLZXJuZWxDb250ZXh0OiBudW1iZXI7XG4gIHJlYWRvbmx5IGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdO1xuICByZWFkb25seSBvdXRwdXRDb3VudDogbnVtYmVyO1xuICBnZXQga2VybmVsQ3VzdG9tRGF0YSgpOiB7W2tleTogc3RyaW5nXTogdW5rbm93bn0ge1xuICAgIHJldHVybiB0aGlzLmJhY2tlbmQuY3VycmVudEtlcm5lbEN1c3RvbURhdGE7XG4gIH1cbiAgZ2V0IGN1c3RvbURhdGFCdWZmZXIoKTogVWludDhBcnJheSB7XG4gICAgcmV0dXJuIHRoaXMubW9kdWxlLkhFQVBVOC5zdWJhcnJheSh0aGlzLmN1c3RvbURhdGFPZmZzZXQsIHRoaXMuY3VzdG9tRGF0YU9mZnNldCArIHRoaXMuY3VzdG9tRGF0YVNpemUpO1xuICB9XG4gIHByaXZhdGUgY3VzdG9tRGF0YU9mZnNldCA9IDA7XG4gIHByaXZhdGUgY3VzdG9tRGF0YVNpemUgPSAwO1xuICBjb25zdHJ1Y3Rvcihwcml2YXRlIG1vZHVsZTogT3J0V2FzbU1vZHVsZSwgcHJpdmF0ZSBiYWNrZW5kOiBXZWJHcHVCYWNrZW5kLCBjb250ZXh0RGF0YU9mZnNldDogbnVtYmVyKSB7XG4gICAgY29uc3QgaGVhcFUzMiA9IG1vZHVsZS5IRUFQVTMyO1xuXG4gICAgLy8gZXh0cmFjdCBjb250ZXh0IGRhdGFcbiAgICBsZXQgZGF0YUluZGV4ID0gKGNvbnRleHREYXRhT2Zmc2V0ID4+PiAyKTtcbiAgICB0aGlzLm9wS2VybmVsQ29udGV4dCA9IGhlYXBVMzJbZGF0YUluZGV4KytdO1xuICAgIGNvbnN0IGlucHV0Q291bnQgPSBoZWFwVTMyW2RhdGFJbmRleCsrXTtcbiAgICB0aGlzLm91dHB1dENvdW50ID0gaGVhcFUzMltkYXRhSW5kZXgrK107XG4gICAgdGhpcy5jdXN0b21EYXRhT2Zmc2V0ID0gaGVhcFUzMltkYXRhSW5kZXgrK107XG4gICAgdGhpcy5jdXN0b21EYXRhU2l6ZSA9IGhlYXBVMzJbZGF0YUluZGV4KytdO1xuXG4gICAgY29uc3QgaW5wdXRzOiBUZW5zb3JWaWV3W10gPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0Q291bnQ7IGkrKykge1xuICAgICAgY29uc3QgZGF0YVR5cGUgPSBoZWFwVTMyW2RhdGFJbmRleCsrXTtcbiAgICAgIGNvbnN0IGRhdGEgPSBoZWFwVTMyW2RhdGFJbmRleCsrXTtcbiAgICAgIGNvbnN0IGRpbSA9IGhlYXBVMzJbZGF0YUluZGV4KytdO1xuICAgICAgY29uc3QgZGltczogbnVtYmVyW10gPSBbXTtcbiAgICAgIGZvciAobGV0IGQgPSAwOyBkIDwgZGltOyBkKyspIHtcbiAgICAgICAgZGltcy5wdXNoKGhlYXBVMzJbZGF0YUluZGV4KytdKTtcbiAgICAgIH1cbiAgICAgIGlucHV0cy5wdXNoKG5ldyBUZW5zb3JWaWV3SW1wbChtb2R1bGUsIGRhdGFUeXBlLCBkYXRhLCBkaW1zKSk7XG4gICAgfVxuICAgIHRoaXMuaW5wdXRzID0gaW5wdXRzO1xuICB9XG5cbiAgY29tcHV0ZShwcm9ncmFtOiBQcm9ncmFtSW5mbywgaW5wdXRzT3V0cHV0c01hcHBpbmc/OiBDb21wdXRlQ29udGV4dElucHV0c091dHB1dHNNYXBwaW5nKTogVGVuc29yVmlld1tdIHtcbiAgICAvLyBwcmVwYXJlIGlucHV0cy4gaW5wdXRzIHNob3VsZCBhbHdheXMgYmUgdmFsaWQgZGF0YS5cbiAgICBjb25zdCBtYXBwZWRJbnB1dHMgPVxuICAgICAgICBpbnB1dHNPdXRwdXRzTWFwcGluZz8uaW5wdXRzPy5tYXAoaSA9PiB0eXBlb2YgaSA9PT0gJ251bWJlcicgPyB0aGlzLmlucHV0c1tpXSA6IGkpID8/IHRoaXMuaW5wdXRzO1xuICAgIC8vIHByZXBhcmUgb3V0cHV0cy5cbiAgICBjb25zdCBvdXRwdXRJbmRpY2VzID0gaW5wdXRzT3V0cHV0c01hcHBpbmc/Lm91dHB1dHMgPz8gW107XG4gICAgY29uc3QgY3JlYXRlS2VybmVsT3V0cHV0ID0gKGluZGV4OiBudW1iZXIsIGRhdGFUeXBlOiBudW1iZXIsIGRpbXM6IHJlYWRvbmx5IG51bWJlcltdKTogVGVuc29yVmlldyA9PlxuICAgICAgICBuZXcgVGVuc29yVmlld0ltcGwodGhpcy5tb2R1bGUsIGRhdGFUeXBlLCB0aGlzLm91dHB1dChpbmRleCwgZGltcyksIGRpbXMpO1xuICAgIGNvbnN0IGNyZWF0ZVRlbXBvcmFyeU91dHB1dCA9IChkYXRhVHlwZTogbnVtYmVyLCBkaW1zOiByZWFkb25seSBudW1iZXJbXSk6IFRlbnNvclZpZXcgPT4ge1xuICAgICAgY29uc3QgZWxlbWVudFNpemUgPSBnZXRUZW5zb3JFbGVtZW50U2l6ZShkYXRhVHlwZSk7XG4gICAgICBpZiAoIWVsZW1lbnRTaXplKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgZGF0YSB0eXBlOiAke2RhdGFUeXBlfWApO1xuICAgICAgfVxuICAgICAgY29uc3QgYnVmZmVyU2l6ZSA9IGVsZW1lbnRTaXplICogU2hhcGVVdGlsLnNpemUoZGltcyk7XG4gICAgICByZXR1cm4gbmV3IFRlbnNvclZpZXdJbXBsKHRoaXMubW9kdWxlLCBkYXRhVHlwZSwgdGhpcy5iYWNrZW5kLmdwdURhdGFNYW5hZ2VyLmNyZWF0ZShidWZmZXJTaXplKS5pZCwgZGltcyk7XG4gICAgfTtcbiAgICByZXR1cm4gdGhpcy5iYWNrZW5kLnJ1bihwcm9ncmFtLCBtYXBwZWRJbnB1dHMsIG91dHB1dEluZGljZXMsIGNyZWF0ZUtlcm5lbE91dHB1dCwgY3JlYXRlVGVtcG9yYXJ5T3V0cHV0KTtcbiAgfVxuXG4gIG91dHB1dChpbmRleDogbnVtYmVyLCBkaW1zOiByZWFkb25seSBudW1iZXJbXSk6IG51bWJlciB7XG4gICAgY29uc3Qgc3RhY2sgPSB0aGlzLm1vZHVsZS5zdGFja1NhdmUoKTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgZGF0YSA9IHRoaXMubW9kdWxlLnN0YWNrQWxsb2MoKDEgKyBkaW1zLmxlbmd0aCkgKiA0IC8qIHNpemVvZihzaXplX3QpICovKTtcbiAgICAgIGxldCBvZmZzZXQgPSBkYXRhID4+IDI7XG4gICAgICB0aGlzLm1vZHVsZS5IRUFQVTMyW29mZnNldCsrXSA9IGRpbXMubGVuZ3RoO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkaW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMubW9kdWxlLkhFQVBVMzJbb2Zmc2V0KytdID0gZGltc1tpXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLm1vZHVsZS5fSnNlcE91dHB1dCh0aGlzLm9wS2VybmVsQ29udGV4dCwgaW5kZXgsIGRhdGEpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgRmFpbGVkIHRvIGdlbmVyYXRlIGtlcm5lbCdzIG91dHB1dFske2luZGV4fV0gd2l0aCBkaW1zIFske2RpbXN9XS4gYCArXG4gICAgICAgICAgJ0lmIHlvdSBhcmUgcnVubmluZyB3aXRoIHByZS1hbGxvY2F0ZWQgb3V0cHV0LCBwbGVhc2UgbWFrZSBzdXJlIHRoZSBvdXRwdXQgdHlwZS9kaW1zIGFyZSBjb3JyZWN0LiAnICtcbiAgICAgICAgICBgRXJyb3I6ICR7ZX1gKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdGhpcy5tb2R1bGUuc3RhY2tSZXN0b3JlKHN0YWNrKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBJbml0aWFsaXplIEpTRVAgd2l0aCBXZWJHUFUgYmFja2VuZC5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIG9ubHkgb25jZSBhZnRlciB0aGUgV2ViQXNzZW1ibHkgbW9kdWxlIGlzIGxvYWRlZCBhbmQgaW5pdGlhbGl6ZWQgKFwiX09ydEluaXRcIiBpcyBjYWxsZWQpLlxuICogVGhpcyBmdW5jdGlvbiBleHBlY3RzOlxuICogIC0gV2ViR1BVIGlzIGVuYWJsZWQgaW4gYnVpbGQgKEJVSUxEX0RFRlMuRElTQUJMRV9XRUJHUFUgPT09IGZhbHNlKS5cbiAqICAtIFdlYkdQVSBpcyBhdmFpbGFibGUgaW4gY3VycmVudCBlbnZpcm9ubWVudC4gKGEgdmFsaWQgR1BVQWRhcHRlciBpcyBwYXNzZWQgaW4pXG4gKiBJZiB0aGUgV2ViQXNzZW1ibHkgbW9kdWxlIGlzIG5vdCBidWlsdCB3aXRoIEpTRVAgc3VwcG9ydCwgdGhpcyBmdW5jdGlvbiB3aWxsIHRocm93IGFuIGVycm9yLiBUaGlzIHdpbGwgaW52YWxpZGF0ZVxuICogJ3dlYmdwdScgYmFja2VuZC5cbiAqXG4gKiBAcGFyYW0gbW9kdWxlIC0gdGhlIE9SVCBXZWJBc3NlbWJseSBtb2R1bGVcbiAqIEBwYXJhbSBlbnYgLSB0aGUgT1JUIGVudmlyb25tZW50IHZhcmlhYmxlIChvcnQuZW52KVxuICogQHBhcmFtIGdwdUFkYXB0ZXIgLSB0aGUgcHJlLWNyZWF0ZWQgR1BVIGFkYXB0ZXJcbiAqL1xuZXhwb3J0IGNvbnN0IGluaXQgPSBhc3luYyhtb2R1bGU6IE9ydFdhc21Nb2R1bGUsIGVudjogRW52LCBncHVBZGFwdGVyOiBHUFVBZGFwdGVyKTogUHJvbWlzZTx2b2lkPiA9PiB7XG4gIGNvbnN0IGpzZXBJbml0ID0gbW9kdWxlLmpzZXBJbml0O1xuICBpZiAoIWpzZXBJbml0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gaW5pdGlhbGl6ZSBKU0VQLiBUaGUgV2ViQXNzZW1ibHkgbW9kdWxlIGlzIG5vdCBidWlsdCB3aXRoIEpTRVAgc3VwcG9ydC4nKTtcbiAgfVxuXG4gIGNvbnN0IGJhY2tlbmQgPSBuZXcgV2ViR3B1QmFja2VuZCgpO1xuICBhd2FpdCBiYWNrZW5kLmluaXRpYWxpemUoZW52LCBncHVBZGFwdGVyKTtcblxuICBqc2VwSW5pdChcbiAgICAgIC8vIGJhY2tlbmRcbiAgICAgIGJhY2tlbmQsXG5cbiAgICAgIC8vIGpzZXBBbGxvYygpXG4gICAgICAoc2l6ZTogbnVtYmVyKSA9PiBiYWNrZW5kLmFsbG9jKHNpemUpLFxuXG4gICAgICAvLyBqc2VwRnJlZSgpXG4gICAgICAocHRyOiBudW1iZXIpID0+IGJhY2tlbmQuZnJlZShwdHIpLFxuXG4gICAgICAvLyBqc2VwQ29weShzcmMsIGRzdCwgc2l6ZSwgaXNTb3VyY2VHcHUpXG4gICAgICAoc3JjOiBudW1iZXIsIGRzdDogbnVtYmVyLCBzaXplOiBudW1iZXIsIGlzU291cmNlR3B1ID0gZmFsc2UpID0+IHtcbiAgICAgICAgaWYgKGlzU291cmNlR3B1KSB7XG4gICAgICAgICAgTE9HX0RFQlVHKCd2ZXJib3NlJywgKCkgPT4gYFtXZWJHUFVdIGpzZXBDb3B5R3B1VG9HcHU6IHNyYz0ke3NyY30sIGRzdD0ke2RzdH0sIHNpemU9JHtzaXplfWApO1xuICAgICAgICAgIGJhY2tlbmQubWVtY3B5KHNyYywgZHN0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBMT0dfREVCVUcoJ3ZlcmJvc2UnLCAoKSA9PiBgW1dlYkdQVV0ganNlcENvcHlDcHVUb0dwdTogZGF0YU9mZnNldD0ke3NyY30sIGdwdURhdGFJZD0ke2RzdH0sIHNpemU9JHtzaXplfWApO1xuICAgICAgICAgIGNvbnN0IGRhdGEgPSBtb2R1bGUuSEVBUFU4LnN1YmFycmF5KHNyYyA+Pj4gMCwgKHNyYyA+Pj4gMCkgKyBzaXplKTtcbiAgICAgICAgICBiYWNrZW5kLnVwbG9hZChkc3QsIGRhdGEpO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICAvLyBqc2VwQ29weUFzeW5jKHNyYywgZHN0LCBzaXplKVxuICAgICAgYXN5bmMoZ3B1RGF0YUlkOiBudW1iZXIsIGRhdGFPZmZzZXQ6IG51bWJlciwgc2l6ZTogbnVtYmVyKTpcbiAgICAgICAgICBQcm9taXNlPHZvaWQ+ID0+IHtcbiAgICAgICAgICAgIExPR19ERUJVRyhcbiAgICAgICAgICAgICAgICAndmVyYm9zZScsXG4gICAgICAgICAgICAgICAgKCkgPT4gYFtXZWJHUFVdIGpzZXBDb3B5R3B1VG9DcHU6IGdwdURhdGFJZD0ke2dwdURhdGFJZH0sIGRhdGFPZmZzZXQ9JHtkYXRhT2Zmc2V0fSwgc2l6ZT0ke3NpemV9YCk7XG5cbiAgICAgICAgICAgIGF3YWl0IGJhY2tlbmQuZG93bmxvYWQoXG4gICAgICAgICAgICAgICAgZ3B1RGF0YUlkLCAoKSA9PiBtb2R1bGUuSEVBUFU4LnN1YmFycmF5KGRhdGFPZmZzZXQgPj4+IDAsIChkYXRhT2Zmc2V0ID4+PiAwKSArIHNpemUpKTtcbiAgICAgICAgICB9LFxuXG4gICAgICAvLyBqc2VwQ3JlYXRlS2VybmVsXG4gICAgICAoa2VybmVsVHlwZTogc3RyaW5nLCBrZXJuZWxJZDogbnVtYmVyLCBhdHRyaWJ1dGU6IHVua25vd24pID0+XG4gICAgICAgICAgYmFja2VuZC5jcmVhdGVLZXJuZWwoa2VybmVsVHlwZSwga2VybmVsSWQsIGF0dHJpYnV0ZSwgbW9kdWxlLlVURjhUb1N0cmluZyhtb2R1bGUuX0pzZXBHZXROb2RlTmFtZShrZXJuZWxJZCkpKSxcblxuICAgICAgLy8ganNlcFJlbGVhc2VLZXJuZWxcbiAgICAgIChrZXJuZWw6IG51bWJlcikgPT4gYmFja2VuZC5yZWxlYXNlS2VybmVsKGtlcm5lbCksXG5cbiAgICAgIC8vIGpzZXBSdW5cbiAgICAgIChrZXJuZWw6IG51bWJlciwgY29udGV4dERhdGFPZmZzZXQ6IG51bWJlciwgc2Vzc2lvbkhhbmRsZTogbnVtYmVyLCBlcnJvcnM6IEFycmF5PFByb21pc2U8c3RyaW5nfG51bGw+PikgPT4ge1xuICAgICAgICBMT0dfREVCVUcoXG4gICAgICAgICAgICAndmVyYm9zZScsXG4gICAgICAgICAgICAoKSA9PiBgW1dlYkdQVV0ganNlcFJ1bjogc2Vzc2lvbkhhbmRsZT0ke3Nlc3Npb25IYW5kbGV9LCBrZXJuZWw9JHtrZXJuZWx9LCBjb250ZXh0RGF0YU9mZnNldD0ke1xuICAgICAgICAgICAgICAgIGNvbnRleHREYXRhT2Zmc2V0fWApO1xuICAgICAgICBjb25zdCBjb250ZXh0ID0gbmV3IENvbXB1dGVDb250ZXh0SW1wbChtb2R1bGUsIGJhY2tlbmQsIGNvbnRleHREYXRhT2Zmc2V0KTtcbiAgICAgICAgcmV0dXJuIGJhY2tlbmQuY29tcHV0ZUtlcm5lbChrZXJuZWwsIGNvbnRleHQsIGVycm9ycyk7XG4gICAgICB9KTtcbn07XG4iLCAiZXhwb3J0IGNvbnN0IGpvaW4gPSB1bmRlZmluZWQ7IiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQgKiBhcyBwYXRoIGZyb20gJ25vZGU6cGF0aCc7XG5pbXBvcnQge0Vudn0gZnJvbSAnb25ueHJ1bnRpbWUtY29tbW9uJztcblxuaW1wb3J0IHtPcnRXYXNtTW9kdWxlfSBmcm9tICcuL2JpbmRpbmcvb3J0LXdhc20nO1xuaW1wb3J0IHtPcnRXYXNtVGhyZWFkZWRNb2R1bGV9IGZyb20gJy4vYmluZGluZy9vcnQtd2FzbS10aHJlYWRlZCc7XG5cbi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1yZXF1aXJlLWltcG9ydHMgKi9cbmxldCBvcnRXYXNtRmFjdG9yeTogRW1zY3JpcHRlbk1vZHVsZUZhY3Rvcnk8T3J0V2FzbU1vZHVsZT47XG5cbmlmICghQlVJTERfREVGUy5ESVNBQkxFX1RSQUlOSU5HKSB7XG4gIG9ydFdhc21GYWN0b3J5ID0gcmVxdWlyZSgnLi9iaW5kaW5nL29ydC10cmFpbmluZy13YXNtLXNpbWQuanMnKTtcbn0gZWxzZSB7XG4gIG9ydFdhc21GYWN0b3J5ID1cbiAgICAgIEJVSUxEX0RFRlMuRElTQUJMRV9XRUJHUFUgPyByZXF1aXJlKCcuL2JpbmRpbmcvb3J0LXdhc20uanMnKSA6IHJlcXVpcmUoJy4vYmluZGluZy9vcnQtd2FzbS1zaW1kLmpzZXAuanMnKTtcbn1cblxuY29uc3Qgb3J0V2FzbUZhY3RvcnlUaHJlYWRlZDogRW1zY3JpcHRlbk1vZHVsZUZhY3Rvcnk8T3J0V2FzbU1vZHVsZT4gPSAhQlVJTERfREVGUy5ESVNBQkxFX1dBU01fVEhSRUFEID9cbiAgICAoQlVJTERfREVGUy5ESVNBQkxFX1dFQkdQVSA/IHJlcXVpcmUoJy4vYmluZGluZy9vcnQtd2FzbS10aHJlYWRlZC5qcycpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVpcmUoJy4vYmluZGluZy9vcnQtd2FzbS1zaW1kLXRocmVhZGVkLmpzZXAuanMnKSkgOlxuICAgIG9ydFdhc21GYWN0b3J5O1xuLyogZXNsaW50LWVuYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tcmVxdWlyZS1pbXBvcnRzICovXG5cbmxldCB3YXNtOiBPcnRXYXNtTW9kdWxlfHVuZGVmaW5lZDtcbmxldCBpbml0aWFsaXplZCA9IGZhbHNlO1xubGV0IGluaXRpYWxpemluZyA9IGZhbHNlO1xubGV0IGFib3J0ZWQgPSBmYWxzZTtcblxuY29uc3QgaXNNdWx0aVRocmVhZFN1cHBvcnRlZCA9IChudW1UaHJlYWRzOiBudW1iZXIpOiBib29sZWFuID0+IHtcbiAgLy8gV2ViQXNzZW1ibHkgdGhyZWFkcyBhcmUgc2V0IHRvIDEgKHNpbmdsZSB0aHJlYWQpLlxuICBpZiAobnVtVGhyZWFkcyA9PT0gMSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIElmICdTaGFyZWRBcnJheUJ1ZmZlcicgaXMgbm90IGF2YWlsYWJsZSwgV2ViQXNzZW1ibHkgdGhyZWFkcyB3aWxsIG5vdCB3b3JrLlxuICBpZiAodHlwZW9mIFNoYXJlZEFycmF5QnVmZmVyID09PSAndW5kZWZpbmVkJykge1xuICAgIGlmICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgJiYgIXNlbGYuY3Jvc3NPcmlnaW5Jc29sYXRlZCkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAnZW52Lndhc20ubnVtVGhyZWFkcyBpcyBzZXQgdG8gJyArIG51bVRocmVhZHMgK1xuICAgICAgICAgICcsIGJ1dCB0aGlzIHdpbGwgbm90IHdvcmsgdW5sZXNzIHlvdSBlbmFibGUgY3Jvc3NPcmlnaW5Jc29sYXRlZCBtb2RlLiAnICtcbiAgICAgICAgICAnU2VlIGh0dHBzOi8vd2ViLmRldi9jcm9zcy1vcmlnaW4taXNvbGF0aW9uLWd1aWRlLyBmb3IgbW9yZSBpbmZvLicpO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBvbm54cnVudGltZS13ZWIgZG9lcyBub3Qgc3VwcG9ydCBtdWx0aS10aHJlYWRzIGluIE5vZGUuanMuXG4gIGlmICh0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgcHJvY2Vzcy52ZXJzaW9ucyAmJiBwcm9jZXNzLnZlcnNpb25zLm5vZGUpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgJ2Vudi53YXNtLm51bVRocmVhZHMgaXMgc2V0IHRvICcgKyBudW1UaHJlYWRzICtcbiAgICAgICAgJywgaG93ZXZlciwgY3VycmVudGx5IG9ubnhydW50aW1lLXdlYiBkb2VzIG5vdCBzdXBwb3J0IG11bHRpLXRocmVhZHMgaW4gTm9kZS5qcy4gJyArXG4gICAgICAgICdQbGVhc2UgY29uc2lkZXIgdXNpbmcgb25ueHJ1bnRpbWUtbm9kZSBmb3IgcGVyZm9ybWFuY2UgY3JpdGljYWwgc2NlbmFyaW9zLicpO1xuICB9XG5cbiAgdHJ5IHtcbiAgICAvLyBUZXN0IGZvciB0cmFuc2ZlcmFiaWxpdHkgb2YgU0FCcyAoZm9yIGJyb3dzZXJzLiBuZWVkZWQgZm9yIEZpcmVmb3gpXG4gICAgLy8gaHR0cHM6Ly9ncm91cHMuZ29vZ2xlLmNvbS9mb3J1bS8jIW1zZy9tb3ppbGxhLmRldi5wbGF0Zm9ybS9JSGtCWmxIRVRwQS9kd3NNTmNoV0VRQUpcbiAgICBpZiAodHlwZW9mIE1lc3NhZ2VDaGFubmVsICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgbmV3IE1lc3NhZ2VDaGFubmVsKCkucG9ydDEucG9zdE1lc3NhZ2UobmV3IFNoYXJlZEFycmF5QnVmZmVyKDEpKTtcbiAgICB9XG5cbiAgICAvLyBUZXN0IGZvciBXZWJBc3NlbWJseSB0aHJlYWRzIGNhcGFiaWxpdHkgKGZvciBib3RoIGJyb3dzZXJzIGFuZCBOb2RlLmpzKVxuICAgIC8vIFRoaXMgdHlwZWQgYXJyYXkgaXMgYSBXZWJBc3NlbWJseSBwcm9ncmFtIGNvbnRhaW5pbmcgdGhyZWFkZWQgaW5zdHJ1Y3Rpb25zLlxuICAgIHJldHVybiBXZWJBc3NlbWJseS52YWxpZGF0ZShuZXcgVWludDhBcnJheShbXG4gICAgICAwLCA5NywgMTE1LCAxMDksIDEsIDAsICAwLCAgMCwgMSwgNCwgMSwgIDk2LCAwLCAgIDAsICAzLCAyLCAxLCAgMCwgNSxcbiAgICAgIDQsIDEsICAzLCAgIDEsICAgMSwgMTAsIDExLCAxLCA5LCAwLCA2NSwgMCwgIDI1NCwgMTYsIDIsIDAsIDI2LCAxMVxuICAgIF0pKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcblxuY29uc3QgaXNTaW1kU3VwcG9ydGVkID0gKCk6IGJvb2xlYW4gPT4ge1xuICB0cnkge1xuICAgIC8vIFRlc3QgZm9yIFdlYkFzc2VtYmx5IFNJTUQgY2FwYWJpbGl0eSAoZm9yIGJvdGggYnJvd3NlcnMgYW5kIE5vZGUuanMpXG4gICAgLy8gVGhpcyB0eXBlZCBhcnJheSBpcyBhIFdlYkFzc2VtYmx5IHByb2dyYW0gY29udGFpbmluZyBTSU1EIGluc3RydWN0aW9ucy5cblxuICAgIC8vIFRoZSBiaW5hcnkgZGF0YSBpcyBnZW5lcmF0ZWQgZnJvbSB0aGUgZm9sbG93aW5nIGNvZGUgYnkgd2F0Mndhc206XG4gICAgLy9cbiAgICAvLyAobW9kdWxlXG4gICAgLy8gICAodHlwZSAkdDAgKGZ1bmMpKVxuICAgIC8vICAgKGZ1bmMgJGYwICh0eXBlICR0MClcbiAgICAvLyAgICAgKGRyb3BcbiAgICAvLyAgICAgICAoaTMyeDQuZG90X2kxNng4X3NcbiAgICAvLyAgICAgICAgIChpOHgxNi5zcGxhdFxuICAgIC8vICAgICAgICAgICAoaTMyLmNvbnN0IDApKVxuICAgIC8vICAgICAgICAgKHYxMjguY29uc3QgaTMyeDQgMHgwMDAwMDAwMCAweDAwMDAwMDAwIDB4MDAwMDAwMDAgMHgwMDAwMDAwMCkpKSkpXG5cbiAgICByZXR1cm4gV2ViQXNzZW1ibHkudmFsaWRhdGUobmV3IFVpbnQ4QXJyYXkoW1xuICAgICAgMCwgICA5NywgMTE1LCAxMDksIDEsIDAsIDAsIDAsIDEsIDQsIDEsIDk2LCAwLCAwLCAzLCAyLCAxLCAwLCAxMCwgMzAsIDEsICAgMjgsICAwLCA2NSwgMCxcbiAgICAgIDI1MywgMTUsIDI1MywgMTIsICAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAgMCwgMCwgMCwgMCwgMCwgMCwgMCwgIDAsICAyNTMsIDE4NiwgMSwgMjYsIDExXG4gICAgXSkpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuXG5jb25zdCBnZXRXYXNtRmlsZU5hbWUgPSAodXNlU2ltZDogYm9vbGVhbiwgdXNlVGhyZWFkczogYm9vbGVhbikgPT4ge1xuICBpZiAodXNlU2ltZCkge1xuICAgIGlmICghQlVJTERfREVGUy5ESVNBQkxFX1RSQUlOSU5HKSB7XG4gICAgICByZXR1cm4gJ29ydC10cmFpbmluZy13YXNtLXNpbWQud2FzbSc7XG4gICAgfVxuICAgIHJldHVybiB1c2VUaHJlYWRzID8gJ29ydC13YXNtLXNpbWQtdGhyZWFkZWQud2FzbScgOiAnb3J0LXdhc20tc2ltZC53YXNtJztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdXNlVGhyZWFkcyA/ICdvcnQtd2FzbS10aHJlYWRlZC53YXNtJyA6ICdvcnQtd2FzbS53YXNtJztcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IGluaXRpYWxpemVXZWJBc3NlbWJseSA9IGFzeW5jKGZsYWdzOiBFbnYuV2ViQXNzZW1ibHlGbGFncyk6IFByb21pc2U8dm9pZD4gPT4ge1xuICBpZiAoaW5pdGlhbGl6ZWQpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gIH1cbiAgaWYgKGluaXRpYWxpemluZykge1xuICAgIHRocm93IG5ldyBFcnJvcignbXVsdGlwbGUgY2FsbHMgdG8gXFwnaW5pdGlhbGl6ZVdlYkFzc2VtYmx5KClcXCcgZGV0ZWN0ZWQuJyk7XG4gIH1cbiAgaWYgKGFib3J0ZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3ByZXZpb3VzIGNhbGwgdG8gXFwnaW5pdGlhbGl6ZVdlYkFzc2VtYmx5KClcXCcgZmFpbGVkLicpO1xuICB9XG5cbiAgaW5pdGlhbGl6aW5nID0gdHJ1ZTtcblxuICAvLyB3YXNtIGZsYWdzIGFyZSBhbHJlYWR5IGluaXRpYWxpemVkXG4gIGNvbnN0IHRpbWVvdXQgPSBmbGFncy5pbml0VGltZW91dCE7XG4gIGNvbnN0IG51bVRocmVhZHMgPSBmbGFncy5udW1UaHJlYWRzITtcbiAgY29uc3Qgc2ltZCA9IGZsYWdzLnNpbWQhO1xuXG4gIGNvbnN0IHVzZVRocmVhZHMgPSBpc011bHRpVGhyZWFkU3VwcG9ydGVkKG51bVRocmVhZHMpO1xuICBjb25zdCB1c2VTaW1kID0gc2ltZCAmJiBpc1NpbWRTdXBwb3J0ZWQoKTtcblxuICBjb25zdCB3YXNtUGF0aHMgPSBmbGFncy53YXNtUGF0aHM7XG4gIGNvbnN0IHdhc21QcmVmaXhPdmVycmlkZSA9IHR5cGVvZiB3YXNtUGF0aHMgPT09ICdzdHJpbmcnID8gd2FzbVBhdGhzIDogdW5kZWZpbmVkO1xuICBjb25zdCB3YXNtRmlsZU5hbWUgPSBnZXRXYXNtRmlsZU5hbWUodXNlU2ltZCwgdXNlVGhyZWFkcyk7XG4gIGNvbnN0IHdhc21QYXRoT3ZlcnJpZGUgPSB0eXBlb2Ygd2FzbVBhdGhzID09PSAnb2JqZWN0JyA/IHdhc21QYXRoc1t3YXNtRmlsZU5hbWVdIDogdW5kZWZpbmVkO1xuXG4gIGxldCBpc1RpbWVvdXQgPSBmYWxzZTtcblxuICBjb25zdCB0YXNrczogQXJyYXk8UHJvbWlzZTx2b2lkPj4gPSBbXTtcblxuICAvLyBwcm9taXNlIGZvciB0aW1lb3V0XG4gIGlmICh0aW1lb3V0ID4gMCkge1xuICAgIHRhc2tzLnB1c2gobmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBpc1RpbWVvdXQgPSB0cnVlO1xuICAgICAgICByZXNvbHZlKCk7XG4gICAgICB9LCB0aW1lb3V0KTtcbiAgICB9KSk7XG4gIH1cblxuICAvLyBwcm9taXNlIGZvciBtb2R1bGUgaW5pdGlhbGl6YXRpb25cbiAgdGFza3MucHVzaChuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgY29uc3QgZmFjdG9yeSA9IHVzZVRocmVhZHMgPyBvcnRXYXNtRmFjdG9yeVRocmVhZGVkIDogb3J0V2FzbUZhY3Rvcnk7XG4gICAgY29uc3QgY29uZmlnOiBQYXJ0aWFsPE9ydFdhc21Nb2R1bGU+ID0ge1xuICAgICAgbG9jYXRlRmlsZTogKGZpbGVOYW1lOiBzdHJpbmcsIHNjcmlwdERpcmVjdG9yeTogc3RyaW5nKSA9PiB7XG4gICAgICAgIGlmICghQlVJTERfREVGUy5ESVNBQkxFX1dBU01fVEhSRUFEICYmIHVzZVRocmVhZHMgJiYgZmlsZU5hbWUuZW5kc1dpdGgoJy53b3JrZXIuanMnKSAmJlxuICAgICAgICAgICAgdHlwZW9mIEJsb2IgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgcmV0dXJuIFVSTC5jcmVhdGVPYmplY3RVUkwobmV3IEJsb2IoXG4gICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAvLyBUaGlzIHJlcXVpcmUoKSBmdW5jdGlvbiBpcyBoYW5kbGVkIGJ5IGVzYnVpbGQgcGx1Z2luIHRvIGxvYWQgZmlsZSBjb250ZW50IGFzIHN0cmluZy5cbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXJlcXVpcmUtaW1wb3J0c1xuICAgICAgICAgICAgICAgIHJlcXVpcmUoJy4vYmluZGluZy9vcnQtd2FzbS10aHJlYWRlZC53b3JrZXIuanMnKVxuICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICB7dHlwZTogJ3RleHQvamF2YXNjcmlwdCd9KSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZmlsZU5hbWUuZW5kc1dpdGgoJy53YXNtJykpIHtcbiAgICAgICAgICBpZiAod2FzbVBhdGhPdmVycmlkZSkge1xuICAgICAgICAgICAgcmV0dXJuIHdhc21QYXRoT3ZlcnJpZGU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgcHJlZml4ID0gd2FzbVByZWZpeE92ZXJyaWRlID8/IHNjcmlwdERpcmVjdG9yeTtcblxuICAgICAgICAgIGlmICghQlVJTERfREVGUy5ESVNBQkxFX1dFQkdQVSkge1xuICAgICAgICAgICAgaWYgKHdhc21GaWxlTmFtZSA9PT0gJ29ydC13YXNtLXNpbWQud2FzbScpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHByZWZpeCArICdvcnQtd2FzbS1zaW1kLmpzZXAud2FzbSc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHdhc21GaWxlTmFtZSA9PT0gJ29ydC13YXNtLXNpbWQtdGhyZWFkZWQud2FzbScpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHByZWZpeCArICdvcnQtd2FzbS1zaW1kLXRocmVhZGVkLmpzZXAud2FzbSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHByZWZpeCArIHdhc21GaWxlTmFtZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzY3JpcHREaXJlY3RvcnkgKyBmaWxlTmFtZTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgaWYgKCFCVUlMRF9ERUZTLkRJU0FCTEVfV0FTTV9USFJFQUQgJiYgdXNlVGhyZWFkcykge1xuICAgICAgY29uZmlnLm51bVRocmVhZHMgPSBudW1UaHJlYWRzO1xuICAgICAgaWYgKHR5cGVvZiBCbG9iID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBjb25maWcubWFpblNjcmlwdFVybE9yQmxvYiA9IHBhdGguam9pbihfX2Rpcm5hbWUsICdvcnQtd2FzbS10aHJlYWRlZC5qcycpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3Qgc2NyaXB0U291cmNlQ29kZSA9IGB2YXIgb3J0V2FzbVRocmVhZGVkPSR7ZmFjdG9yeS50b1N0cmluZygpfTtgO1xuICAgICAgICBjb25maWcubWFpblNjcmlwdFVybE9yQmxvYiA9IG5ldyBCbG9iKFtzY3JpcHRTb3VyY2VDb2RlXSwge3R5cGU6ICd0ZXh0L2phdmFzY3JpcHQnfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZmFjdG9yeShjb25maWcpLnRoZW4oXG4gICAgICAgIC8vIHdhc20gbW9kdWxlIGluaXRpYWxpemVkIHN1Y2Nlc3NmdWxseVxuICAgICAgICBtb2R1bGUgPT4ge1xuICAgICAgICAgIGluaXRpYWxpemluZyA9IGZhbHNlO1xuICAgICAgICAgIGluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgICAgICB3YXNtID0gbW9kdWxlO1xuICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gd2FzbSBtb2R1bGUgZmFpbGVkIHRvIGluaXRpYWxpemVcbiAgICAgICAgKHdoYXQpID0+IHtcbiAgICAgICAgICBpbml0aWFsaXppbmcgPSBmYWxzZTtcbiAgICAgICAgICBhYm9ydGVkID0gdHJ1ZTtcbiAgICAgICAgICByZWplY3Qod2hhdCk7XG4gICAgICAgIH0pO1xuICB9KSk7XG5cbiAgYXdhaXQgUHJvbWlzZS5yYWNlKHRhc2tzKTtcblxuICBpZiAoaXNUaW1lb3V0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBXZWJBc3NlbWJseSBiYWNrZW5kIGluaXRpYWxpemluZyBmYWlsZWQgZHVlIHRvIHRpbWVvdXQ6ICR7dGltZW91dH1tc2ApO1xuICB9XG59O1xuXG5leHBvcnQgY29uc3QgZ2V0SW5zdGFuY2UgPSAoKTogT3J0V2FzbU1vZHVsZSA9PiB7XG4gIGlmIChpbml0aWFsaXplZCAmJiB3YXNtKSB7XG4gICAgcmV0dXJuIHdhc207XG4gIH1cblxuICB0aHJvdyBuZXcgRXJyb3IoJ1dlYkFzc2VtYmx5IGlzIG5vdCBpbml0aWFsaXplZCB5ZXQuJyk7XG59O1xuXG5leHBvcnQgY29uc3QgZGlzcG9zZSA9ICgpOiB2b2lkID0+IHtcbiAgaWYgKGluaXRpYWxpemVkICYmICFpbml0aWFsaXppbmcgJiYgIWFib3J0ZWQpIHtcbiAgICBpbml0aWFsaXppbmcgPSB0cnVlO1xuXG4gICAgKHdhc20gYXMgT3J0V2FzbVRocmVhZGVkTW9kdWxlKS5QVGhyZWFkPy50ZXJtaW5hdGVBbGxUaHJlYWRzKCk7XG4gICAgd2FzbSA9IHVuZGVmaW5lZDtcblxuICAgIGluaXRpYWxpemluZyA9IGZhbHNlO1xuICAgIGluaXRpYWxpemVkID0gZmFsc2U7XG4gICAgYWJvcnRlZCA9IHRydWU7XG4gIH1cbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7Z2V0SW5zdGFuY2V9IGZyb20gJy4vd2FzbS1mYWN0b3J5JztcblxuZXhwb3J0IGNvbnN0IGFsbG9jV2FzbVN0cmluZyA9IChkYXRhOiBzdHJpbmcsIGFsbG9jczogbnVtYmVyW10pOiBudW1iZXIgPT4ge1xuICBjb25zdCB3YXNtID0gZ2V0SW5zdGFuY2UoKTtcblxuICBjb25zdCBkYXRhTGVuZ3RoID0gd2FzbS5sZW5ndGhCeXRlc1VURjgoZGF0YSkgKyAxO1xuICBjb25zdCBkYXRhT2Zmc2V0ID0gd2FzbS5fbWFsbG9jKGRhdGFMZW5ndGgpO1xuICB3YXNtLnN0cmluZ1RvVVRGOChkYXRhLCBkYXRhT2Zmc2V0LCBkYXRhTGVuZ3RoKTtcbiAgYWxsb2NzLnB1c2goZGF0YU9mZnNldCk7XG5cbiAgcmV0dXJuIGRhdGFPZmZzZXQ7XG59O1xuXG5pbnRlcmZhY2UgRXh0cmFPcHRpb25zSGFuZGxlciB7XG4gIChuYW1lOiBzdHJpbmcsIHZhbHVlOiBzdHJpbmcpOiB2b2lkO1xufVxuXG5leHBvcnQgY29uc3QgaXRlcmF0ZUV4dHJhT3B0aW9ucyA9XG4gICAgKG9wdGlvbnM6IFJlY29yZDxzdHJpbmcsIHVua25vd24+LCBwcmVmaXg6IHN0cmluZywgc2VlbjogV2Vha1NldDxSZWNvcmQ8c3RyaW5nLCB1bmtub3duPj4sXG4gICAgIGhhbmRsZXI6IEV4dHJhT3B0aW9uc0hhbmRsZXIpOiB2b2lkID0+IHtcbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PSAnb2JqZWN0JyAmJiBvcHRpb25zICE9PSBudWxsKSB7XG4gICAgICAgIGlmIChzZWVuLmhhcyhvcHRpb25zKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2lyY3VsYXIgcmVmZXJlbmNlIGluIG9wdGlvbnMnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZWVuLmFkZChvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBPYmplY3QuZW50cmllcyhvcHRpb25zKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgY29uc3QgbmFtZSA9IChwcmVmaXgpID8gcHJlZml4ICsga2V5IDoga2V5O1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgIGl0ZXJhdGVFeHRyYU9wdGlvbnModmFsdWUgYXMgUmVjb3JkPHN0cmluZywgdW5rbm93bj4sIG5hbWUgKyAnLicsIHNlZW4sIGhhbmRsZXIpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgICAgIGhhbmRsZXIobmFtZSwgdmFsdWUudG9TdHJpbmcoKSk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICBoYW5kbGVyKG5hbWUsICh2YWx1ZSkgPyAnMScgOiAnMCcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2FuJ3QgaGFuZGxlIGV4dHJhIGNvbmZpZyB0eXBlOiAke3R5cGVvZiB2YWx1ZX1gKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcblxuLyoqXG4gKiBjaGVjayB3ZWIgYXNzZW1ibHkgQVBJJ3MgbGFzdCBlcnJvciBhbmQgdGhyb3cgZXJyb3IgaWYgYW55IGVycm9yIG9jY3VycmVkLlxuICogQHBhcmFtIG1lc3NhZ2UgYSBtZXNzYWdlIHVzZWQgd2hlbiBhbiBlcnJvciBvY2N1cnJlZC5cbiAqL1xuZXhwb3J0IGNvbnN0IGNoZWNrTGFzdEVycm9yID0gKG1lc3NhZ2U6IHN0cmluZyk6IHZvaWQgPT4ge1xuICBjb25zdCB3YXNtID0gZ2V0SW5zdGFuY2UoKTtcblxuICBjb25zdCBzdGFjayA9IHdhc20uc3RhY2tTYXZlKCk7XG4gIHRyeSB7XG4gICAgY29uc3QgcGFyYW1zT2Zmc2V0ID0gd2FzbS5zdGFja0FsbG9jKDgpO1xuICAgIHdhc20uX09ydEdldExhc3RFcnJvcihwYXJhbXNPZmZzZXQsIHBhcmFtc09mZnNldCArIDQpO1xuICAgIGNvbnN0IGVycm9yQ29kZSA9IHdhc20uSEVBUDMyW3BhcmFtc09mZnNldCAvIDRdO1xuICAgIGNvbnN0IGVycm9yTWVzc2FnZVBvaW50ZXIgPSB3YXNtLkhFQVBVMzJbcGFyYW1zT2Zmc2V0IC8gNCArIDFdO1xuICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IGVycm9yTWVzc2FnZVBvaW50ZXIgPyB3YXNtLlVURjhUb1N0cmluZyhlcnJvck1lc3NhZ2VQb2ludGVyKSA6ICcnO1xuICAgIHRocm93IG5ldyBFcnJvcihgJHttZXNzYWdlfSBFUlJPUl9DT0RFOiAke2Vycm9yQ29kZX0sIEVSUk9SX01FU1NBR0U6ICR7ZXJyb3JNZXNzYWdlfWApO1xuICB9IGZpbmFsbHkge1xuICAgIHdhc20uc3RhY2tSZXN0b3JlKHN0YWNrKTtcbiAgfVxufTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtJbmZlcmVuY2VTZXNzaW9ufSBmcm9tICdvbm54cnVudGltZS1jb21tb24nO1xuXG5pbXBvcnQge2dldEluc3RhbmNlfSBmcm9tICcuL3dhc20tZmFjdG9yeSc7XG5pbXBvcnQge2FsbG9jV2FzbVN0cmluZywgY2hlY2tMYXN0RXJyb3IsIGl0ZXJhdGVFeHRyYU9wdGlvbnN9IGZyb20gJy4vd2FzbS11dGlscyc7XG5cbmV4cG9ydCBjb25zdCBzZXRSdW5PcHRpb25zID0gKG9wdGlvbnM6IEluZmVyZW5jZVNlc3Npb24uUnVuT3B0aW9ucyk6IFtudW1iZXIsIG51bWJlcltdXSA9PiB7XG4gIGNvbnN0IHdhc20gPSBnZXRJbnN0YW5jZSgpO1xuICBsZXQgcnVuT3B0aW9uc0hhbmRsZSA9IDA7XG4gIGNvbnN0IGFsbG9jczogbnVtYmVyW10gPSBbXTtcblxuICBjb25zdCBydW5PcHRpb25zOiBJbmZlcmVuY2VTZXNzaW9uLlJ1bk9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIHRyeSB7XG4gICAgaWYgKG9wdGlvbnM/LmxvZ1NldmVyaXR5TGV2ZWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcnVuT3B0aW9ucy5sb2dTZXZlcml0eUxldmVsID0gMjsgIC8vIERlZmF1bHQgdG8gd2FybmluZ1xuICAgIH0gZWxzZSBpZiAoXG4gICAgICAgIHR5cGVvZiBvcHRpb25zLmxvZ1NldmVyaXR5TGV2ZWwgIT09ICdudW1iZXInIHx8ICFOdW1iZXIuaXNJbnRlZ2VyKG9wdGlvbnMubG9nU2V2ZXJpdHlMZXZlbCkgfHxcbiAgICAgICAgb3B0aW9ucy5sb2dTZXZlcml0eUxldmVsIDwgMCB8fCBvcHRpb25zLmxvZ1NldmVyaXR5TGV2ZWwgPiA0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGxvZyBzZXJ2ZXJpdHkgbGV2ZWwgaXMgbm90IHZhbGlkOiAke29wdGlvbnMubG9nU2V2ZXJpdHlMZXZlbH1gKTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucz8ubG9nVmVyYm9zaXR5TGV2ZWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcnVuT3B0aW9ucy5sb2dWZXJib3NpdHlMZXZlbCA9IDA7ICAvLyBEZWZhdWx0IHRvIDBcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBvcHRpb25zLmxvZ1ZlcmJvc2l0eUxldmVsICE9PSAnbnVtYmVyJyB8fCAhTnVtYmVyLmlzSW50ZWdlcihvcHRpb25zLmxvZ1ZlcmJvc2l0eUxldmVsKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBsb2cgdmVyYm9zaXR5IGxldmVsIGlzIG5vdCB2YWxpZDogJHtvcHRpb25zLmxvZ1ZlcmJvc2l0eUxldmVsfWApO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zPy50ZXJtaW5hdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcnVuT3B0aW9ucy50ZXJtaW5hdGUgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBsZXQgdGFnRGF0YU9mZnNldCA9IDA7XG4gICAgaWYgKG9wdGlvbnM/LnRhZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0YWdEYXRhT2Zmc2V0ID0gYWxsb2NXYXNtU3RyaW5nKG9wdGlvbnMudGFnLCBhbGxvY3MpO1xuICAgIH1cblxuICAgIHJ1bk9wdGlvbnNIYW5kbGUgPSB3YXNtLl9PcnRDcmVhdGVSdW5PcHRpb25zKFxuICAgICAgICBydW5PcHRpb25zLmxvZ1NldmVyaXR5TGV2ZWwhLCBydW5PcHRpb25zLmxvZ1ZlcmJvc2l0eUxldmVsISwgISFydW5PcHRpb25zLnRlcm1pbmF0ZSEsIHRhZ0RhdGFPZmZzZXQpO1xuICAgIGlmIChydW5PcHRpb25zSGFuZGxlID09PSAwKSB7XG4gICAgICBjaGVja0xhc3RFcnJvcignQ2FuXFwndCBjcmVhdGUgcnVuIG9wdGlvbnMuJyk7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnM/LmV4dHJhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGl0ZXJhdGVFeHRyYU9wdGlvbnMob3B0aW9ucy5leHRyYSwgJycsIG5ldyBXZWFrU2V0PFJlY29yZDxzdHJpbmcsIHVua25vd24+PigpLCAoa2V5LCB2YWx1ZSkgPT4ge1xuICAgICAgICBjb25zdCBrZXlEYXRhT2Zmc2V0ID0gYWxsb2NXYXNtU3RyaW5nKGtleSwgYWxsb2NzKTtcbiAgICAgICAgY29uc3QgdmFsdWVEYXRhT2Zmc2V0ID0gYWxsb2NXYXNtU3RyaW5nKHZhbHVlLCBhbGxvY3MpO1xuXG4gICAgICAgIGlmICh3YXNtLl9PcnRBZGRSdW5Db25maWdFbnRyeShydW5PcHRpb25zSGFuZGxlLCBrZXlEYXRhT2Zmc2V0LCB2YWx1ZURhdGFPZmZzZXQpICE9PSAwKSB7XG4gICAgICAgICAgY2hlY2tMYXN0RXJyb3IoYENhbid0IHNldCBhIHJ1biBjb25maWcgZW50cnk6ICR7a2V5fSAtICR7dmFsdWV9LmApO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gW3J1bk9wdGlvbnNIYW5kbGUsIGFsbG9jc107XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAocnVuT3B0aW9uc0hhbmRsZSAhPT0gMCkge1xuICAgICAgd2FzbS5fT3J0UmVsZWFzZVJ1bk9wdGlvbnMocnVuT3B0aW9uc0hhbmRsZSk7XG4gICAgfVxuICAgIGFsbG9jcy5mb3JFYWNoKGFsbG9jID0+IHdhc20uX2ZyZWUoYWxsb2MpKTtcbiAgICB0aHJvdyBlO1xuICB9XG59O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge0luZmVyZW5jZVNlc3Npb259IGZyb20gJ29ubnhydW50aW1lLWNvbW1vbic7XG5cbmltcG9ydCB7Z2V0SW5zdGFuY2V9IGZyb20gJy4vd2FzbS1mYWN0b3J5JztcbmltcG9ydCB7YWxsb2NXYXNtU3RyaW5nLCBjaGVja0xhc3RFcnJvciwgaXRlcmF0ZUV4dHJhT3B0aW9uc30gZnJvbSAnLi93YXNtLXV0aWxzJztcblxuY29uc3QgZ2V0R3JhcGhPcHRpbXphdGlvbkxldmVsID0gKGdyYXBoT3B0aW1pemF0aW9uTGV2ZWw6IHN0cmluZ3x1bmtub3duKTogbnVtYmVyID0+IHtcbiAgc3dpdGNoIChncmFwaE9wdGltaXphdGlvbkxldmVsKSB7XG4gICAgY2FzZSAnZGlzYWJsZWQnOlxuICAgICAgcmV0dXJuIDA7XG4gICAgY2FzZSAnYmFzaWMnOlxuICAgICAgcmV0dXJuIDE7XG4gICAgY2FzZSAnZXh0ZW5kZWQnOlxuICAgICAgcmV0dXJuIDI7XG4gICAgY2FzZSAnYWxsJzpcbiAgICAgIHJldHVybiA5OTtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCBncmFwaCBvcHRpbWl6YXRpb24gbGV2ZWw6ICR7Z3JhcGhPcHRpbWl6YXRpb25MZXZlbH1gKTtcbiAgfVxufTtcblxuY29uc3QgZ2V0RXhlY3V0aW9uTW9kZSA9IChleGVjdXRpb25Nb2RlOiAnc2VxdWVudGlhbCd8J3BhcmFsbGVsJyk6IG51bWJlciA9PiB7XG4gIHN3aXRjaCAoZXhlY3V0aW9uTW9kZSkge1xuICAgIGNhc2UgJ3NlcXVlbnRpYWwnOlxuICAgICAgcmV0dXJuIDA7XG4gICAgY2FzZSAncGFyYWxsZWwnOlxuICAgICAgcmV0dXJuIDE7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgZXhlY3V0aW9uIG1vZGU6ICR7ZXhlY3V0aW9uTW9kZX1gKTtcbiAgfVxufTtcblxuY29uc3QgYXBwZW5kRGVmYXVsdE9wdGlvbnMgPSAob3B0aW9uczogSW5mZXJlbmNlU2Vzc2lvbi5TZXNzaW9uT3B0aW9ucyk6IHZvaWQgPT4ge1xuICBpZiAoIW9wdGlvbnMuZXh0cmEpIHtcbiAgICBvcHRpb25zLmV4dHJhID0ge307XG4gIH1cbiAgaWYgKCFvcHRpb25zLmV4dHJhLnNlc3Npb24pIHtcbiAgICBvcHRpb25zLmV4dHJhLnNlc3Npb24gPSB7fTtcbiAgfVxuICBjb25zdCBzZXNzaW9uID0gb3B0aW9ucy5leHRyYS5zZXNzaW9uIGFzIFJlY29yZDxzdHJpbmcsIHN0cmluZz47XG4gIGlmICghc2Vzc2lvbi51c2Vfb3J0X21vZGVsX2J5dGVzX2RpcmVjdGx5KSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNhbWVsY2FzZVxuICAgIHNlc3Npb24udXNlX29ydF9tb2RlbF9ieXRlc19kaXJlY3RseSA9ICcxJztcbiAgfVxuXG4gIC8vIGlmIHVzaW5nIEpTRVAgd2l0aCBXZWJHUFUsIGFsd2F5cyBkaXNhYmxlIG1lbW9yeSBwYXR0ZXJuXG4gIGlmIChvcHRpb25zLmV4ZWN1dGlvblByb3ZpZGVycyAmJlxuICAgICAgb3B0aW9ucy5leGVjdXRpb25Qcm92aWRlcnMuc29tZShlcCA9PiAodHlwZW9mIGVwID09PSAnc3RyaW5nJyA/IGVwIDogZXAubmFtZSkgPT09ICd3ZWJncHUnKSkge1xuICAgIG9wdGlvbnMuZW5hYmxlTWVtUGF0dGVybiA9IGZhbHNlO1xuICB9XG59O1xuXG5jb25zdCBzZXRFeGVjdXRpb25Qcm92aWRlcnMgPVxuICAgIChzZXNzaW9uT3B0aW9uc0hhbmRsZTogbnVtYmVyLCBleGVjdXRpb25Qcm92aWRlcnM6IHJlYWRvbmx5IEluZmVyZW5jZVNlc3Npb24uRXhlY3V0aW9uUHJvdmlkZXJDb25maWdbXSxcbiAgICAgYWxsb2NzOiBudW1iZXJbXSk6IHZvaWQgPT4ge1xuICAgICAgZm9yIChjb25zdCBlcCBvZiBleGVjdXRpb25Qcm92aWRlcnMpIHtcbiAgICAgICAgbGV0IGVwTmFtZSA9IHR5cGVvZiBlcCA9PT0gJ3N0cmluZycgPyBlcCA6IGVwLm5hbWU7XG5cbiAgICAgICAgLy8gY2hlY2sgRVAgbmFtZVxuICAgICAgICBzd2l0Y2ggKGVwTmFtZSkge1xuICAgICAgICAgIGNhc2UgJ3dlYm5uJzpcbiAgICAgICAgICAgIGVwTmFtZSA9ICdXRUJOTic7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGVwICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICBjb25zdCB3ZWJubk9wdGlvbnMgPSBlcCBhcyBJbmZlcmVuY2VTZXNzaW9uLldlYk5ORXhlY3V0aW9uUHJvdmlkZXJPcHRpb247XG4gICAgICAgICAgICAgIGlmICh3ZWJubk9wdGlvbnM/LmRldmljZVR5cGUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBrZXlEYXRhT2Zmc2V0ID0gYWxsb2NXYXNtU3RyaW5nKCdkZXZpY2VUeXBlJywgYWxsb2NzKTtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZURhdGFPZmZzZXQgPSBhbGxvY1dhc21TdHJpbmcod2Vibm5PcHRpb25zLmRldmljZVR5cGUsIGFsbG9jcyk7XG4gICAgICAgICAgICAgICAgaWYgKGdldEluc3RhbmNlKCkuX09ydEFkZFNlc3Npb25Db25maWdFbnRyeShzZXNzaW9uT3B0aW9uc0hhbmRsZSwga2V5RGF0YU9mZnNldCwgdmFsdWVEYXRhT2Zmc2V0KSAhPT1cbiAgICAgICAgICAgICAgICAgICAgMCkge1xuICAgICAgICAgICAgICAgICAgY2hlY2tMYXN0RXJyb3IoYENhbid0IHNldCBhIHNlc3Npb24gY29uZmlnIGVudHJ5OiAnZGV2aWNlVHlwZScgLSAke3dlYm5uT3B0aW9ucy5kZXZpY2VUeXBlfS5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHdlYm5uT3B0aW9ucz8ubnVtVGhyZWFkcykge1xuICAgICAgICAgICAgICAgIGxldCBudW1UaHJlYWRzID0gd2Vibm5PcHRpb25zLm51bVRocmVhZHM7XG4gICAgICAgICAgICAgICAgLy8gSnVzdCBpZ25vcmUgaW52YWxpZCB3ZWJubk9wdGlvbnMubnVtVGhyZWFkcy5cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG51bVRocmVhZHMgIT0gJ251bWJlcicgfHwgIU51bWJlci5pc0ludGVnZXIobnVtVGhyZWFkcykgfHwgbnVtVGhyZWFkcyA8IDApIHtcbiAgICAgICAgICAgICAgICAgIG51bVRocmVhZHMgPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBrZXlEYXRhT2Zmc2V0ID0gYWxsb2NXYXNtU3RyaW5nKCdudW1UaHJlYWRzJywgYWxsb2NzKTtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZURhdGFPZmZzZXQgPSBhbGxvY1dhc21TdHJpbmcobnVtVGhyZWFkcy50b1N0cmluZygpLCBhbGxvY3MpO1xuICAgICAgICAgICAgICAgIGlmIChnZXRJbnN0YW5jZSgpLl9PcnRBZGRTZXNzaW9uQ29uZmlnRW50cnkoc2Vzc2lvbk9wdGlvbnNIYW5kbGUsIGtleURhdGFPZmZzZXQsIHZhbHVlRGF0YU9mZnNldCkgIT09XG4gICAgICAgICAgICAgICAgICAgIDApIHtcbiAgICAgICAgICAgICAgICAgIGNoZWNrTGFzdEVycm9yKGBDYW4ndCBzZXQgYSBzZXNzaW9uIGNvbmZpZyBlbnRyeTogJ251bVRocmVhZHMnIC0gJHt3ZWJubk9wdGlvbnMubnVtVGhyZWFkc30uYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICh3ZWJubk9wdGlvbnM/LnBvd2VyUHJlZmVyZW5jZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGtleURhdGFPZmZzZXQgPSBhbGxvY1dhc21TdHJpbmcoJ3Bvd2VyUHJlZmVyZW5jZScsIGFsbG9jcyk7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWVEYXRhT2Zmc2V0ID0gYWxsb2NXYXNtU3RyaW5nKHdlYm5uT3B0aW9ucy5wb3dlclByZWZlcmVuY2UsIGFsbG9jcyk7XG4gICAgICAgICAgICAgICAgaWYgKGdldEluc3RhbmNlKCkuX09ydEFkZFNlc3Npb25Db25maWdFbnRyeShzZXNzaW9uT3B0aW9uc0hhbmRsZSwga2V5RGF0YU9mZnNldCwgdmFsdWVEYXRhT2Zmc2V0KSAhPT1cbiAgICAgICAgICAgICAgICAgICAgMCkge1xuICAgICAgICAgICAgICAgICAgY2hlY2tMYXN0RXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICAgYENhbid0IHNldCBhIHNlc3Npb24gY29uZmlnIGVudHJ5OiAncG93ZXJQcmVmZXJlbmNlJyAtICR7d2Vibm5PcHRpb25zLnBvd2VyUHJlZmVyZW5jZX0uYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICd3ZWJncHUnOlxuICAgICAgICAgICAgZXBOYW1lID0gJ0pTJztcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZXAgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHdlYmdwdU9wdGlvbnMgPSBlcCBhcyBJbmZlcmVuY2VTZXNzaW9uLldlYkdwdUV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uO1xuICAgICAgICAgICAgICBpZiAod2ViZ3B1T3B0aW9ucz8ucHJlZmVycmVkTGF5b3V0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHdlYmdwdU9wdGlvbnMucHJlZmVycmVkTGF5b3V0ICE9PSAnTkNIVycgJiYgd2ViZ3B1T3B0aW9ucy5wcmVmZXJyZWRMYXlvdXQgIT09ICdOSFdDJykge1xuICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBwcmVmZXJyZWRMYXlvdXQgbXVzdCBiZSBlaXRoZXIgJ05DSFcnIG9yICdOSFdDJzogJHt3ZWJncHVPcHRpb25zLnByZWZlcnJlZExheW91dH1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3Qga2V5RGF0YU9mZnNldCA9IGFsbG9jV2FzbVN0cmluZygncHJlZmVycmVkTGF5b3V0JywgYWxsb2NzKTtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZURhdGFPZmZzZXQgPSBhbGxvY1dhc21TdHJpbmcod2ViZ3B1T3B0aW9ucy5wcmVmZXJyZWRMYXlvdXQsIGFsbG9jcyk7XG4gICAgICAgICAgICAgICAgaWYgKGdldEluc3RhbmNlKCkuX09ydEFkZFNlc3Npb25Db25maWdFbnRyeShzZXNzaW9uT3B0aW9uc0hhbmRsZSwga2V5RGF0YU9mZnNldCwgdmFsdWVEYXRhT2Zmc2V0KSAhPT1cbiAgICAgICAgICAgICAgICAgICAgMCkge1xuICAgICAgICAgICAgICAgICAgY2hlY2tMYXN0RXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICAgYENhbid0IHNldCBhIHNlc3Npb24gY29uZmlnIGVudHJ5OiAncHJlZmVycmVkTGF5b3V0JyAtICR7d2ViZ3B1T3B0aW9ucy5wcmVmZXJyZWRMYXlvdXR9LmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnd2FzbSc6XG4gICAgICAgICAgY2FzZSAnY3B1JzpcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYG5vdCBzdXBwb3J0ZWQgZXhlY3V0aW9uIHByb3ZpZGVyOiAke2VwTmFtZX1gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGVwTmFtZURhdGFPZmZzZXQgPSBhbGxvY1dhc21TdHJpbmcoZXBOYW1lLCBhbGxvY3MpO1xuICAgICAgICBpZiAoZ2V0SW5zdGFuY2UoKS5fT3J0QXBwZW5kRXhlY3V0aW9uUHJvdmlkZXIoc2Vzc2lvbk9wdGlvbnNIYW5kbGUsIGVwTmFtZURhdGFPZmZzZXQpICE9PSAwKSB7XG4gICAgICAgICAgY2hlY2tMYXN0RXJyb3IoYENhbid0IGFwcGVuZCBleGVjdXRpb24gcHJvdmlkZXI6ICR7ZXBOYW1lfS5gKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbmV4cG9ydCBjb25zdCBzZXRTZXNzaW9uT3B0aW9ucyA9IChvcHRpb25zPzogSW5mZXJlbmNlU2Vzc2lvbi5TZXNzaW9uT3B0aW9ucyk6IFtudW1iZXIsIG51bWJlcltdXSA9PiB7XG4gIGNvbnN0IHdhc20gPSBnZXRJbnN0YW5jZSgpO1xuICBsZXQgc2Vzc2lvbk9wdGlvbnNIYW5kbGUgPSAwO1xuICBjb25zdCBhbGxvY3M6IG51bWJlcltdID0gW107XG5cbiAgY29uc3Qgc2Vzc2lvbk9wdGlvbnM6IEluZmVyZW5jZVNlc3Npb24uU2Vzc2lvbk9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBhcHBlbmREZWZhdWx0T3B0aW9ucyhzZXNzaW9uT3B0aW9ucyk7XG5cbiAgdHJ5IHtcbiAgICBjb25zdCBncmFwaE9wdGltaXphdGlvbkxldmVsID0gZ2V0R3JhcGhPcHRpbXphdGlvbkxldmVsKHNlc3Npb25PcHRpb25zLmdyYXBoT3B0aW1pemF0aW9uTGV2ZWwgPz8gJ2FsbCcpO1xuICAgIGNvbnN0IGV4ZWN1dGlvbk1vZGUgPSBnZXRFeGVjdXRpb25Nb2RlKHNlc3Npb25PcHRpb25zLmV4ZWN1dGlvbk1vZGUgPz8gJ3NlcXVlbnRpYWwnKTtcbiAgICBjb25zdCBsb2dJZERhdGFPZmZzZXQgPVxuICAgICAgICB0eXBlb2Ygc2Vzc2lvbk9wdGlvbnMubG9nSWQgPT09ICdzdHJpbmcnID8gYWxsb2NXYXNtU3RyaW5nKHNlc3Npb25PcHRpb25zLmxvZ0lkLCBhbGxvY3MpIDogMDtcblxuICAgIGNvbnN0IGxvZ1NldmVyaXR5TGV2ZWwgPSBzZXNzaW9uT3B0aW9ucy5sb2dTZXZlcml0eUxldmVsID8/IDI7ICAvLyBEZWZhdWx0IHRvIDIgLSB3YXJuaW5nXG4gICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKGxvZ1NldmVyaXR5TGV2ZWwpIHx8IGxvZ1NldmVyaXR5TGV2ZWwgPCAwIHx8IGxvZ1NldmVyaXR5TGV2ZWwgPiA0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGxvZyBzZXJ2ZXJpdHkgbGV2ZWwgaXMgbm90IHZhbGlkOiAke2xvZ1NldmVyaXR5TGV2ZWx9YCk7XG4gICAgfVxuXG4gICAgY29uc3QgbG9nVmVyYm9zaXR5TGV2ZWwgPSBzZXNzaW9uT3B0aW9ucy5sb2dWZXJib3NpdHlMZXZlbCA/PyAwOyAgLy8gRGVmYXVsdCB0byAwIC0gdmVyYm9zZVxuICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihsb2dWZXJib3NpdHlMZXZlbCkgfHwgbG9nVmVyYm9zaXR5TGV2ZWwgPCAwIHx8IGxvZ1ZlcmJvc2l0eUxldmVsID4gNCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBsb2cgdmVyYm9zaXR5IGxldmVsIGlzIG5vdCB2YWxpZDogJHtsb2dWZXJib3NpdHlMZXZlbH1gKTtcbiAgICB9XG5cbiAgICBjb25zdCBvcHRpbWl6ZWRNb2RlbEZpbGVQYXRoT2Zmc2V0ID0gdHlwZW9mIHNlc3Npb25PcHRpb25zLm9wdGltaXplZE1vZGVsRmlsZVBhdGggPT09ICdzdHJpbmcnID9cbiAgICAgICAgYWxsb2NXYXNtU3RyaW5nKHNlc3Npb25PcHRpb25zLm9wdGltaXplZE1vZGVsRmlsZVBhdGgsIGFsbG9jcykgOlxuICAgICAgICAwO1xuXG4gICAgc2Vzc2lvbk9wdGlvbnNIYW5kbGUgPSB3YXNtLl9PcnRDcmVhdGVTZXNzaW9uT3B0aW9ucyhcbiAgICAgICAgZ3JhcGhPcHRpbWl6YXRpb25MZXZlbCwgISFzZXNzaW9uT3B0aW9ucy5lbmFibGVDcHVNZW1BcmVuYSwgISFzZXNzaW9uT3B0aW9ucy5lbmFibGVNZW1QYXR0ZXJuLCBleGVjdXRpb25Nb2RlLFxuICAgICAgICAhIXNlc3Npb25PcHRpb25zLmVuYWJsZVByb2ZpbGluZywgMCwgbG9nSWREYXRhT2Zmc2V0LCBsb2dTZXZlcml0eUxldmVsLCBsb2dWZXJib3NpdHlMZXZlbCxcbiAgICAgICAgb3B0aW1pemVkTW9kZWxGaWxlUGF0aE9mZnNldCk7XG4gICAgaWYgKHNlc3Npb25PcHRpb25zSGFuZGxlID09PSAwKSB7XG4gICAgICBjaGVja0xhc3RFcnJvcignQ2FuXFwndCBjcmVhdGUgc2Vzc2lvbiBvcHRpb25zLicpO1xuICAgIH1cblxuICAgIGlmIChzZXNzaW9uT3B0aW9ucy5leGVjdXRpb25Qcm92aWRlcnMpIHtcbiAgICAgIHNldEV4ZWN1dGlvblByb3ZpZGVycyhzZXNzaW9uT3B0aW9uc0hhbmRsZSwgc2Vzc2lvbk9wdGlvbnMuZXhlY3V0aW9uUHJvdmlkZXJzLCBhbGxvY3MpO1xuICAgIH1cblxuICAgIGlmIChzZXNzaW9uT3B0aW9ucy5mcmVlRGltZW5zaW9uT3ZlcnJpZGVzKSB7XG4gICAgICBmb3IgKGNvbnN0IFtuYW1lLCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoc2Vzc2lvbk9wdGlvbnMuZnJlZURpbWVuc2lvbk92ZXJyaWRlcykpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgZnJlZSBkaW1lbnNpb24gb3ZlcnJpZGUgbmFtZSBtdXN0IGJlIGEgc3RyaW5nOiAke25hbWV9YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicgfHwgIU51bWJlci5pc0ludGVnZXIodmFsdWUpIHx8IHZhbHVlIDwgMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgZnJlZSBkaW1lbnNpb24gb3ZlcnJpZGUgdmFsdWUgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBpbnRlZ2VyOiAke3ZhbHVlfWApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5hbWVPZmZzZXQgPSBhbGxvY1dhc21TdHJpbmcobmFtZSwgYWxsb2NzKTtcbiAgICAgICAgaWYgKHdhc20uX09ydEFkZEZyZWVEaW1lbnNpb25PdmVycmlkZShzZXNzaW9uT3B0aW9uc0hhbmRsZSwgbmFtZU9mZnNldCwgdmFsdWUpICE9PSAwKSB7XG4gICAgICAgICAgY2hlY2tMYXN0RXJyb3IoYENhbid0IHNldCBhIGZyZWUgZGltZW5zaW9uIG92ZXJyaWRlOiAke25hbWV9IC0gJHt2YWx1ZX0uYCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc2Vzc2lvbk9wdGlvbnMuZXh0cmEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaXRlcmF0ZUV4dHJhT3B0aW9ucyhzZXNzaW9uT3B0aW9ucy5leHRyYSwgJycsIG5ldyBXZWFrU2V0PFJlY29yZDxzdHJpbmcsIHVua25vd24+PigpLCAoa2V5LCB2YWx1ZSkgPT4ge1xuICAgICAgICBjb25zdCBrZXlEYXRhT2Zmc2V0ID0gYWxsb2NXYXNtU3RyaW5nKGtleSwgYWxsb2NzKTtcbiAgICAgICAgY29uc3QgdmFsdWVEYXRhT2Zmc2V0ID0gYWxsb2NXYXNtU3RyaW5nKHZhbHVlLCBhbGxvY3MpO1xuXG4gICAgICAgIGlmICh3YXNtLl9PcnRBZGRTZXNzaW9uQ29uZmlnRW50cnkoc2Vzc2lvbk9wdGlvbnNIYW5kbGUsIGtleURhdGFPZmZzZXQsIHZhbHVlRGF0YU9mZnNldCkgIT09IDApIHtcbiAgICAgICAgICBjaGVja0xhc3RFcnJvcihgQ2FuJ3Qgc2V0IGEgc2Vzc2lvbiBjb25maWcgZW50cnk6ICR7a2V5fSAtICR7dmFsdWV9LmApO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gW3Nlc3Npb25PcHRpb25zSGFuZGxlLCBhbGxvY3NdO1xuICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKHNlc3Npb25PcHRpb25zSGFuZGxlICE9PSAwKSB7XG4gICAgICB3YXNtLl9PcnRSZWxlYXNlU2Vzc2lvbk9wdGlvbnMoc2Vzc2lvbk9wdGlvbnNIYW5kbGUpO1xuICAgIH1cbiAgICBhbGxvY3MuZm9yRWFjaChhbGxvYyA9PiB3YXNtLl9mcmVlKGFsbG9jKSk7XG4gICAgdGhyb3cgZTtcbiAgfVxufTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtFbnYsIEluZmVyZW5jZVNlc3Npb24sIFRlbnNvcn0gZnJvbSAnb25ueHJ1bnRpbWUtY29tbW9uJztcblxuaW1wb3J0IHtTZXJpYWxpemFibGVJbnRlcm5hbEJ1ZmZlciwgU2VyaWFsaXphYmxlU2Vzc2lvbk1ldGFkYXRhLCBTZXJpYWxpemFibGVUZW5zb3JNZXRhZGF0YSwgVGVuc29yTWV0YWRhdGF9IGZyb20gJy4vcHJveHktbWVzc2FnZXMnO1xuaW1wb3J0IHtzZXRSdW5PcHRpb25zfSBmcm9tICcuL3J1bi1vcHRpb25zJztcbmltcG9ydCB7c2V0U2Vzc2lvbk9wdGlvbnN9IGZyb20gJy4vc2Vzc2lvbi1vcHRpb25zJztcbmltcG9ydCB7ZGF0YUxvY2F0aW9uU3RyaW5nVG9FbnVtLCBnZXRUZW5zb3JFbGVtZW50U2l6ZSwgaXNHcHVCdWZmZXJTdXBwb3J0ZWRUeXBlLCBsb2dMZXZlbFN0cmluZ1RvRW51bSwgdGVuc29yRGF0YVR5cGVFbnVtVG9TdHJpbmcsIHRlbnNvckRhdGFUeXBlU3RyaW5nVG9FbnVtLCB0ZW5zb3JUeXBlVG9UeXBlZEFycmF5Q29uc3RydWN0b3J9IGZyb20gJy4vd2FzbS1jb21tb24nO1xuaW1wb3J0IHtnZXRJbnN0YW5jZX0gZnJvbSAnLi93YXNtLWZhY3RvcnknO1xuaW1wb3J0IHthbGxvY1dhc21TdHJpbmcsIGNoZWNrTGFzdEVycm9yfSBmcm9tICcuL3dhc20tdXRpbHMnO1xuaW1wb3J0IHtsb2FkRmlsZX0gZnJvbSAnLi93YXNtLXV0aWxzLWxvYWQtZmlsZSc7XG5cbi8vICNyZWdpb24gSW5pdGlhbGl6YXRpb25zXG5cbi8qKlxuICogVGhlcmUgYXJlIDQgZGlmZmVyZW50IFwiaW5pdGlhbGl6YXRpb25cIiBzdGVwcyBmb3IgT1JULiBUaGV5IGhhcHBlbiBpbiBkaWZmZXJlbnQgcGxhY2VzIGFuZCBkaWZmZXJlbnQgdGltZS5cbiAqXG4gKiAxLiBKYXZhU2NyaXB0IGluaXRpYWxpemF0aW9uIGZvciBvbm54cnVudGltZS1jb21tb24gYW5kIG9ubnhydW50aW1lLXdlYi5cbiAqICAgIFRoaXMgaXMgdGhlIGZpcnN0IGluaXRpYWxpemF0aW9uIHN0ZXAuIEluIHRoaXMgc3RlcCwgb25ueHJ1bnRpbWUtd2ViIGNhbGxzIG9ubnhydW50aW1lLWNvbW1vbidzIHJlZ2lzdGVyQmFja2VuZCgpXG4gKiBmdW5jdGlvbiBtdWx0aXBsZSB0aW1lcyB0byByZWdpc3RlciBhbGwgdGhlIGF2YWlsYWJsZSBiYWNrZW5kcy4gVGhlIGJhY2tlbmQgcmVnaXN0cmF0aW9uIGlzIHZlcnkgZmFzdC4gSXQgb25seVxuICogcmVnaXN0ZXJzIHRoZSBiYWNrZW5kIG5hbWUgd2l0aCB0aGUgdW5pbml0aWFsaXplZCBiYWNrZW5kIG9iamVjdC4gTm8gaGVhdnkgaW5pdGlhbGl6YXRpb24gaXMgZG9uZSBpbiB0aGlzIHN0ZXAuXG4gKiAgICBSZWZlciB0byB3ZWIvbGliL2luZGV4LnRzIGZvciB0aGUgYmFja2VuZCByZWdpc3RyYXRpb24uXG4gKlxuICogMi4gV2ViQXNzZW1ibHkgYXJ0aWZhY3QgaW5pdGlhbGl6YXRpb24uXG4gKiAgICBUaGlzIGhhcHBlbnMgd2hlbiBhbnkgcmVnaXN0ZXJlZCB3YXNtIGJhY2tlbmQgaXMgdXNlZCBmb3IgdGhlIGZpcnN0IHRpbWUgKGllLiBgb3J0LkluZmVyZW5jZVNlc3Npb24uY3JlYXRlKClgIG9yXG4gKiBgb3J0LlRyYWluaW5nU2Vzc2lvbi5jcmVhdGUoKWAgaXMgY2FsbGVkKS4gSW4gdGhpcyBzdGVwLCBvbm54cnVudGltZS13ZWIgZG9lcyB0aGUgZm9sbG93aW5nczpcbiAqICAgICAtIGNyZWF0ZSBhIHByb3h5IHdvcmtlciBhbmQgbWFrZSBzdXJlIHRoZSBwcm94eSB3b3JrZXIgaXMgcmVhZHkgdG8gcmVjZWl2ZSBtZXNzYWdlcywgaWYgcHJveHkgaXMgZW5hYmxlZC5cbiAqICAgICAtIHBlcmZvcm0gZmVhdHVyZSBkZXRlY3Rpb24sIGxvY2F0ZSBjb3JyZWN0IFdlYkFzc2VtYmx5IGFydGlmYWN0IHBhdGggYW5kIGNhbGwgdGhlIEVtc2NyaXB0ZW4gZ2VuZXJhdGVkXG4gKiBKYXZhU2NyaXB0IGNvZGUgdG8gaW5pdGlhbGl6ZSB0aGUgV2ViQXNzZW1ibHkgcnVudGltZS5cbiAqICAgICAgICAgLSBpZiBwcm94eSBpcyBlbmFibGVkLCB0aGlzIHN0ZXAgaGFwcGVucyBpbiB0aGUgcHJveHkgd29ya2VyIHVzaW5nIG1lc3NhZ2UgJ2luaXQtd2FzbScuXG4gKiAgICAgICAgIC0gZG93bmxvYWRpbmcgdGhlICdvcnQtd2FzbXsuLi59Lndhc20nIGZpbGUgaXMgZG9uZSBpbiB0aGlzIHN0ZXAuXG4gKiAgICAgICAgIC0gaWYgbXVsdGktdGhyZWFkIGlzIGVuYWJsZWQsIG9uZSBvciBtb3JlIHdlYndvcmtlciB3aWxsIGJlIGNyZWF0ZWQgdG8gaW5pdGlhbGl6ZSB0aGUgUFRocmVhZCB0aHJlYWRwb29sLlxuICpcbiAqIDMuIE9SVCBlbnZpcm9ubWVudCBpbml0aWFsaXphdGlvbi5cbiAqICAgIFRoaXMgaGFwcGVucyBhZnRlciBzdGVwIDIuIEluIHRoaXMgc3RlcCwgb25ueHJ1bnRpbWUtd2ViIHBlcmZvcm1zIE9OTlggUnVudGltZSBlbnZpcm9ubWVudCBpbml0aWFsaXphdGlvbi5cbiAqIEZ1bmN0aW9uIGBfT3J0SW5pdCgpYCBpcyBjYWxsZWQgaW4gdGhpcyBzdGVwLlxuICogICAgIC0gaWYgcHJveHkgaXMgZW5hYmxlZCwgdGhpcyBzdGVwIGhhcHBlbnMgaW4gdGhlIHByb3h5IHdvcmtlciB1c2luZyBtZXNzYWdlICdpbml0LW9ydCcuXG4gKiAgICAgLSBsb2dnaW5nIGxldmVsIChvcnQuZW52LmxvZ0xldmVsKSBhbmQgdGhyZWFkIG51bWJlciAob3J0LmVudi53YXNtLm51bVRocmVhZHMpIGFyZSBzZXQgaW4gdGhpcyBzdGVwLlxuICpcbiAqIDQuIFNlc3Npb24gaW5pdGlhbGl6YXRpb24uXG4gKiAgICBUaGlzIGhhcHBlbnMgd2hlbiBgb3J0LkluZmVyZW5jZVNlc3Npb24uY3JlYXRlKClgIG9yIGBvcnQuVHJhaW5pbmdTZXNzaW9uLmNyZWF0ZSgpYCBpcyBjYWxsZWQuIFVubGlrZSB0aGUgZmlyc3QgM1xuICogc3RlcHMgKHRoZXkgb25seSBjYWxsZWQgb25jZSksIHRoaXMgc3RlcCB3aWxsIGJlIGRvbmUgZm9yIGVhY2ggc2Vzc2lvbi4gSW4gdGhpcyBzdGVwLCBvbm54cnVudGltZS13ZWIgZG9lcyB0aGVcbiAqIGZvbGxvd2luZ3M6XG4gKiAgICBJZiB0aGUgcGFyYW1ldGVyIGlzIGEgVVJMOlxuICogICAgLSBkb3dubG9hZCB0aGUgbW9kZWwgZGF0YSBmcm9tIHRoZSBVUkwuXG4gKiAgICAtIGNvcHkgdGhlIG1vZGVsIGRhdGEgdG8gdGhlIFdBU00gaGVhcC4gKHByb3h5OiAnY29weS1mcm9tJylcbiAqICAgIC0gZGVyZWZlcmVuY2UgdGhlIG1vZGVsIGJ1ZmZlci4gVGhpcyBzdGVwIGFsbG93cyB0aGUgb3JpZ2luYWwgQXJyYXlCdWZmZXIgdG8gYmUgZ2FyYmFnZSBjb2xsZWN0ZWQuXG4gKiAgICAtIGNhbGwgYF9PcnRDcmVhdGVTZXNzaW9uKClgIHRvIGNyZWF0ZSB0aGUgc2Vzc2lvbi4gKHByb3h5OiAnY3JlYXRlJylcbiAqXG4gKiAgICBJZiB0aGUgcGFyYW1ldGVyIGlzIGEgVWludDhBcnJheSBvYmplY3Q6XG4gKiAgICAtIGNvcHkgdGhlIG1vZGVsIGRhdGEgdG8gdGhlIFdBU00gaGVhcC4gKHByb3h5OiAnY29weS1mcm9tJylcbiAqICAgIC0gY2FsbCBgX09ydENyZWF0ZVNlc3Npb24oKWAgdG8gY3JlYXRlIHRoZSBzZXNzaW9uLiAocHJveHk6ICdjcmVhdGUnKVxuICpcbiAqXG4gKi9cblxuLyoqXG4gKiBpbml0aWFsaXplIE9SVCBlbnZpcm9ubWVudC5cbiAqXG4gKiBAcGFyYW0gbnVtVGhyZWFkcyBTZXRHbG9iYWxJbnRyYU9wTnVtVGhyZWFkcyhudW1UaHJlYWRzKVxuICogQHBhcmFtIGxvZ2dpbmdMZXZlbCBDcmVhdGVFbnYoc3RhdGljX2Nhc3Q8T3J0TG9nZ2luZ0xldmVsPihsb2dnaW5nX2xldmVsKSlcbiAqL1xuY29uc3QgaW5pdE9ydCA9IChudW1UaHJlYWRzOiBudW1iZXIsIGxvZ2dpbmdMZXZlbDogbnVtYmVyKTogdm9pZCA9PiB7XG4gIGNvbnN0IGVycm9yQ29kZSA9IGdldEluc3RhbmNlKCkuX09ydEluaXQobnVtVGhyZWFkcywgbG9nZ2luZ0xldmVsKTtcbiAgaWYgKGVycm9yQ29kZSAhPT0gMCkge1xuICAgIGNoZWNrTGFzdEVycm9yKCdDYW5cXCd0IGluaXRpYWxpemUgb25ueHJ1bnRpbWUuJyk7XG4gIH1cbn07XG5cbi8qKlxuICogaW50aWFsaXplIHJ1bnRpbWUgZW52aXJvbm1lbnQuXG4gKiBAcGFyYW0gZW52IHBhc3NlZCBpbiB0aGUgZW52aXJvbm1lbnQgY29uZmlnIG9iamVjdC5cbiAqL1xuZXhwb3J0IGNvbnN0IGluaXRSdW50aW1lID0gYXN5bmMoZW52OiBFbnYpOiBQcm9taXNlPHZvaWQ+ID0+IHtcbiAgLy8gaW5pdCBPUlRcbiAgaW5pdE9ydChlbnYud2FzbS5udW1UaHJlYWRzISwgbG9nTGV2ZWxTdHJpbmdUb0VudW0oZW52LmxvZ0xldmVsKSk7XG59O1xuXG4vKipcbiAqIHBlcmZvcm0gRVAgc3BlY2lmaWMgaW5pdGlhbGl6YXRpb24uXG4gKlxuICogQHBhcmFtIGVudlxuICogQHBhcmFtIGVwTmFtZVxuICovXG5leHBvcnQgY29uc3QgaW5pdEVwID0gYXN5bmMoZW52OiBFbnYsIGVwTmFtZTogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiA9PiB7XG4gIGlmICghQlVJTERfREVGUy5ESVNBQkxFX1dFQkdQVSAmJiBlcE5hbWUgPT09ICd3ZWJncHUnKSB7XG4gICAgLy8gcGVyZm9ybSBXZWJHUFUgYXZhaWxhYmlsaXR5IGNoZWNrXG4gICAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgPT09ICd1bmRlZmluZWQnIHx8ICFuYXZpZ2F0b3IuZ3B1KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dlYkdQVSBpcyBub3Qgc3VwcG9ydGVkIGluIGN1cnJlbnQgZW52aXJvbm1lbnQnKTtcbiAgICB9XG4gICAgY29uc3QgYWRhcHRlciA9IGF3YWl0IG5hdmlnYXRvci5ncHUucmVxdWVzdEFkYXB0ZXIoKTtcbiAgICBpZiAoIWFkYXB0ZXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAnRmFpbGVkIHRvIGdldCBHUFUgYWRhcHRlci4gWW91IG1heSBuZWVkIHRvIGVuYWJsZSBmbGFnIFwiLS1lbmFibGUtdW5zYWZlLXdlYmdwdVwiIGlmIHlvdSBhcmUgdXNpbmcgQ2hyb21lLicpO1xuICAgIH1cblxuICAgIGlmICghZW52Lndhc20uc2ltZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICdOb3Qgc3VwcG9ydGVkIGZvciBXZWJHUFU9T04gYW5kIFNJTUQ9T0ZGLiBQbGVhc2Ugc2V0IGBlbnYud2FzbS5zaW1kYCB0byB0cnVlIHdoZW4gdXNpbmcgYHdlYmdwdWAgRVAnKTtcbiAgICB9XG5cbiAgICAvLyBpbml0IEpTRVAgaWYgYXZhaWxhYmxlXG5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXJlcXVpcmUtaW1wb3J0cywgQHR5cGVzY3JpcHQtZXNsaW50L25vLXZhci1yZXF1aXJlc1xuICAgIGNvbnN0IGluaXRKc2VwID0gcmVxdWlyZSgnLi9qc2VwL2luaXQnKS5pbml0O1xuICAgIGF3YWl0IGluaXRKc2VwKGdldEluc3RhbmNlKCksIGVudiwgYWRhcHRlcik7XG4gIH1cbn07XG5cbi8vICNlbmRyZWdpb24gSW5pdGlhbGl6YXRpb25zXG5cbi8qKlxuICogdmFsaWQgZGF0YSBsb2NhdGlvbnMgZm9yIGlucHV0L291dHB1dCB0ZW5zb3JzLlxuICovXG50eXBlIFN1cHBvcnRlZFRlbnNvckRhdGFMb2NhdGlvbkZvcklucHV0T3V0cHV0ID0gJ2NwdSd8J2NwdS1waW5uZWQnfCdncHUtYnVmZmVyJztcblxudHlwZSBJT0JpbmRpbmdTdGF0ZSA9IHtcbiAgLyoqXG4gICAqIHRoZSBoYW5kbGUgb2YgSU8gYmluZGluZy5cbiAgICovXG4gIHJlYWRvbmx5IGhhbmRsZTogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiB0aGUgcHJlZmVycmVkIGxvY2F0aW9uIGZvciBlYWNoIG91dHB1dCB0ZW5zb3IuXG4gICAqXG4gICAqIHZhbHVlIGlzIG9uZSBvZiAnY3B1JywgJ2NwdS1waW5uZWQnLCAnZ3B1LWJ1ZmZlcicuXG4gICAqL1xuICByZWFkb25seSBvdXRwdXRQcmVmZXJyZWRMb2NhdGlvbnM6IHJlYWRvbmx5IFN1cHBvcnRlZFRlbnNvckRhdGFMb2NhdGlvbkZvcklucHV0T3V0cHV0W107XG5cbiAgLyoqXG4gICAqIGVudW0gdmFsdWUgb2YgdGhlIHByZWZlcnJlZCBsb2NhdGlvbiBmb3IgZWFjaCBvdXRwdXQgdGVuc29yLlxuICAgKi9cbiAgcmVhZG9ubHkgb3V0cHV0UHJlZmVycmVkTG9jYXRpb25zRW5jb2RlZDogcmVhZG9ubHkgbnVtYmVyW107XG59O1xuXG4vKipcbiAqICB0dXBsZSBlbGVtZW50cyBhcmU6IEluZmVyZW5jZVNlc3Npb24gSUQ7IGlucHV0TmFtZXNVVEY4RW5jb2RlZDsgb3V0cHV0TmFtZXNVVEY4RW5jb2RlZDsgYmluZGluZ1N0YXRlXG4gKi9cbnR5cGUgU2Vzc2lvbk1ldGFkYXRhID0gW1xuICBpbmZlcmVuY2VTZXNzaW9uSWQ6IG51bWJlciwgaW5wdXROYW1lc1VURjhFbmNvZGVkOiBudW1iZXJbXSwgb3V0cHV0TmFtZXNVVEY4RW5jb2RlZDogbnVtYmVyW10sXG4gIGJpbmRpbmdTdGF0ZTogSU9CaW5kaW5nU3RhdGV8bnVsbFxuXTtcblxuY29uc3QgYWN0aXZlU2Vzc2lvbnMgPSBuZXcgTWFwPG51bWJlciwgU2Vzc2lvbk1ldGFkYXRhPigpO1xuXG4vKipcbiAqIGdldCB0aGUgaW5wdXQvb3V0cHV0IGNvdW50IG9mIHRoZSBzZXNzaW9uLlxuICogQHBhcmFtIHNlc3Npb25IYW5kbGUgdGhlIGhhbmRsZSByZXByZXNlbnRpbmcgdGhlIHNlc3Npb24uIHNob3VsZCBiZSBub24temVyby5cbiAqIEByZXR1cm5zIGEgdHVwbGUgaW5jbHVkaW5nIDIgbnVtYmVycywgcmVwcmVzZW50aW5nIHRoZSBpbnB1dCBjb3VudCBhbmQgb3V0cHV0IGNvdW50LlxuICovXG5jb25zdCBnZXRTZXNzaW9uSW5wdXRPdXRwdXRDb3VudCA9IChzZXNzaW9uSGFuZGxlOiBudW1iZXIpOiBbbnVtYmVyLCBudW1iZXJdID0+IHtcbiAgY29uc3Qgd2FzbSA9IGdldEluc3RhbmNlKCk7XG4gIGNvbnN0IHN0YWNrID0gd2FzbS5zdGFja1NhdmUoKTtcbiAgdHJ5IHtcbiAgICBjb25zdCBkYXRhT2Zmc2V0ID0gd2FzbS5zdGFja0FsbG9jKDgpO1xuICAgIGNvbnN0IGVycm9yQ29kZSA9IHdhc20uX09ydEdldElucHV0T3V0cHV0Q291bnQoc2Vzc2lvbkhhbmRsZSwgZGF0YU9mZnNldCwgZGF0YU9mZnNldCArIDQpO1xuICAgIGlmIChlcnJvckNvZGUgIT09IDApIHtcbiAgICAgIGNoZWNrTGFzdEVycm9yKCdDYW5cXCd0IGdldCBzZXNzaW9uIGlucHV0L291dHB1dCBjb3VudC4nKTtcbiAgICB9XG4gICAgcmV0dXJuIFt3YXNtLkhFQVAzMltkYXRhT2Zmc2V0IC8gNF0sIHdhc20uSEVBUDMyW2RhdGFPZmZzZXQgLyA0ICsgMV1dO1xuICB9IGZpbmFsbHkge1xuICAgIHdhc20uc3RhY2tSZXN0b3JlKHN0YWNrKTtcbiAgfVxufTtcblxuLyoqXG4gKiBhbGxvY2F0ZSB0aGUgbWVtb3J5IGFuZCBtZW1jcHkgdGhlIGV4dGVybmFsIGJ1ZmZlci5cbiAqXG4gKiBAcGFyYW0gbW9kZWwgLSB0aGUgZXh0ZXJuYWwgYnVmZmVyIGNvbnRhaW5pbmcgdGhlIG1vZGVsIGRhdGEuIE11c3Qgbm90IGJlIHRoZSBzYW1lIGJ1ZmZlciBhcyB0aGUgV0FTTSBoZWFwLlxuICogQHJldHVybnMgYSAyLWVsZW1lbnRzIHR1cGxlIC0gdGhlIHBvaW50ZXIgYW5kIHNpemUgb2YgdGhlIGFsbG9jYXRlZCBidWZmZXJcbiAqL1xuZXhwb3J0IGNvbnN0IGNvcHlGcm9tRXh0ZXJuYWxCdWZmZXIgPSAobW9kZWw6IFVpbnQ4QXJyYXkpOiBbbnVtYmVyLCBudW1iZXJdID0+IHtcbiAgY29uc3Qgd2FzbSA9IGdldEluc3RhbmNlKCk7XG4gIGNvbnN0IG1vZGVsRGF0YU9mZnNldCA9IHdhc20uX21hbGxvYyhtb2RlbC5ieXRlTGVuZ3RoKTtcbiAgaWYgKG1vZGVsRGF0YU9mZnNldCA9PT0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgQ2FuJ3QgY3JlYXRlIGEgc2Vzc2lvbi4gZmFpbGVkIHRvIGFsbG9jYXRlIGEgYnVmZmVyIG9mIHNpemUgJHttb2RlbC5ieXRlTGVuZ3RofS5gKTtcbiAgfVxuICB3YXNtLkhFQVBVOC5zZXQobW9kZWwsIG1vZGVsRGF0YU9mZnNldCk7XG4gIHJldHVybiBbbW9kZWxEYXRhT2Zmc2V0LCBtb2RlbC5ieXRlTGVuZ3RoXTtcbn07XG5cbi8qKlxuICogY3JlYXRlIGFuIGluZmVyZW5jZSBzZXNzaW9uIGZyb20gYSBtb2RlbCBkYXRhIGJ1ZmZlci5cbiAqXG4gKiBAcGFyYW0gbW9kZWxEYXRhIC0gZWl0aGVyIGEgVWludDhBcnJheSBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBtb2RlbCBkYXRhLCBvciBhIDItZWxlbWVudHMgdHVwbGUgY29udGFpbmluZyB0aGVcbiAqICAgICBwb2ludGVyIGFuZCBzaXplIG9mIHRoZSBtb2RlbCBkYXRhIGJ1ZmZlci5cbiAqIEBwYXJhbSBvcHRpb25zIGFuIG9wdGlvbmFsIHNlc3Npb24gb3B0aW9ucyBvYmplY3QuXG4gKiBAcmV0dXJucyBhIDMtZWxlbWVudHMgdHVwbGUgY29udGFpbmluZyBbc2Vzc2lvbiBoYW5kbGUsIGlucHV0IG5hbWVzLCBvdXRwdXQgbmFtZXNdXG4gKi9cbmV4cG9ydCBjb25zdCBjcmVhdGVTZXNzaW9uID0gYXN5bmMoXG4gICAgbW9kZWxEYXRhOiBVaW50OEFycmF5fFNlcmlhbGl6YWJsZUludGVybmFsQnVmZmVyLFxuICAgIG9wdGlvbnM/OiBJbmZlcmVuY2VTZXNzaW9uLlNlc3Npb25PcHRpb25zKTogUHJvbWlzZTxTZXJpYWxpemFibGVTZXNzaW9uTWV0YWRhdGE+ID0+IHtcbiAgbGV0IG1vZGVsRGF0YU9mZnNldDogbnVtYmVyLCBtb2RlbERhdGFMZW5ndGg6IG51bWJlcjtcbiAgY29uc3Qgd2FzbSA9IGdldEluc3RhbmNlKCk7XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkobW9kZWxEYXRhKSkge1xuICAgIC8vIGlmIG1vZGVsIGRhdGEgaXMgYW4gYXJyYXksIGl0IG11c3QgYmUgYSAyLWVsZW1lbnRzIHR1cGxlIGNvbnRhaW5pbmcgdGhlIHBvaW50ZXIgYW5kIHNpemUgb2YgdGhlIG1vZGVsIGRhdGFcbiAgICBbbW9kZWxEYXRhT2Zmc2V0LCBtb2RlbERhdGFMZW5ndGhdID0gbW9kZWxEYXRhO1xuICB9IGVsc2UgaWYgKG1vZGVsRGF0YS5idWZmZXIgPT09IHdhc20uSEVBUFU4LmJ1ZmZlcikge1xuICAgIC8vIGlmIG1vZGVsIGRhdGEgdXNlcyB0aGUgc2FtZSBidWZmZXIgYXMgdGhlIFdBU00gaGVhcCwgd2UgZG9uJ3QgbmVlZCB0byBjb3B5IGl0LlxuICAgIFttb2RlbERhdGFPZmZzZXQsIG1vZGVsRGF0YUxlbmd0aF0gPSBbbW9kZWxEYXRhLmJ5dGVPZmZzZXQsIG1vZGVsRGF0YS5ieXRlTGVuZ3RoXTtcbiAgfSBlbHNlIHtcbiAgICAvLyBvdGhlcndpc2UsIGNvcHkgdGhlIG1vZGVsIGRhdGEgdG8gdGhlIFdBU00gaGVhcC5cbiAgICBbbW9kZWxEYXRhT2Zmc2V0LCBtb2RlbERhdGFMZW5ndGhdID0gY29weUZyb21FeHRlcm5hbEJ1ZmZlcihtb2RlbERhdGEpO1xuICB9XG5cbiAgbGV0IHNlc3Npb25IYW5kbGUgPSAwO1xuICBsZXQgc2Vzc2lvbk9wdGlvbnNIYW5kbGUgPSAwO1xuICBsZXQgaW9CaW5kaW5nSGFuZGxlID0gMDtcbiAgbGV0IGFsbG9jczogbnVtYmVyW10gPSBbXTtcbiAgY29uc3QgaW5wdXROYW1lc1VURjhFbmNvZGVkID0gW107XG4gIGNvbnN0IG91dHB1dE5hbWVzVVRGOEVuY29kZWQgPSBbXTtcblxuICB0cnkge1xuICAgIFtzZXNzaW9uT3B0aW9uc0hhbmRsZSwgYWxsb2NzXSA9IHNldFNlc3Npb25PcHRpb25zKG9wdGlvbnMpO1xuXG4gICAgaWYgKG9wdGlvbnM/LmV4dGVybmFsRGF0YSAmJiB3YXNtLm1vdW50RXh0ZXJuYWxEYXRhKSB7XG4gICAgICBjb25zdCBsb2FkaW5nUHJvbWlzZXMgPSBbXTtcbiAgICAgIGZvciAoY29uc3QgZmlsZSBvZiBvcHRpb25zLmV4dGVybmFsRGF0YSkge1xuICAgICAgICBjb25zdCBwYXRoID0gdHlwZW9mIGZpbGUgPT09ICdzdHJpbmcnID8gZmlsZSA6IGZpbGUucGF0aDtcbiAgICAgICAgbG9hZGluZ1Byb21pc2VzLnB1c2gobG9hZEZpbGUodHlwZW9mIGZpbGUgPT09ICdzdHJpbmcnID8gZmlsZSA6IGZpbGUuZGF0YSkudGhlbihkYXRhID0+IHtcbiAgICAgICAgICB3YXNtLm1vdW50RXh0ZXJuYWxEYXRhIShwYXRoLCBkYXRhKTtcbiAgICAgICAgfSkpO1xuICAgICAgfVxuXG4gICAgICAvLyB3YWl0IGZvciBhbGwgZXh0ZXJuYWwgZGF0YSBmaWxlcyB0byBiZSBsb2FkZWRcbiAgICAgIGF3YWl0IFByb21pc2UuYWxsKGxvYWRpbmdQcm9taXNlcyk7XG4gICAgfVxuXG4gICAgc2Vzc2lvbkhhbmRsZSA9IHdhc20uX09ydENyZWF0ZVNlc3Npb24obW9kZWxEYXRhT2Zmc2V0LCBtb2RlbERhdGFMZW5ndGgsIHNlc3Npb25PcHRpb25zSGFuZGxlKTtcbiAgICBpZiAoc2Vzc2lvbkhhbmRsZSA9PT0gMCkge1xuICAgICAgY2hlY2tMYXN0RXJyb3IoJ0NhblxcJ3QgY3JlYXRlIGEgc2Vzc2lvbi4nKTtcbiAgICB9XG5cbiAgICBjb25zdCBbaW5wdXRDb3VudCwgb3V0cHV0Q291bnRdID0gZ2V0U2Vzc2lvbklucHV0T3V0cHV0Q291bnQoc2Vzc2lvbkhhbmRsZSk7XG5cbiAgICBjb25zdCBpbnB1dE5hbWVzID0gW107XG4gICAgY29uc3Qgb3V0cHV0TmFtZXMgPSBbXTtcbiAgICBjb25zdCBvdXRwdXRQcmVmZXJyZWRMb2NhdGlvbnM6IFN1cHBvcnRlZFRlbnNvckRhdGFMb2NhdGlvbkZvcklucHV0T3V0cHV0W10gPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0Q291bnQ7IGkrKykge1xuICAgICAgY29uc3QgbmFtZSA9IHdhc20uX09ydEdldElucHV0TmFtZShzZXNzaW9uSGFuZGxlLCBpKTtcbiAgICAgIGlmIChuYW1lID09PSAwKSB7XG4gICAgICAgIGNoZWNrTGFzdEVycm9yKCdDYW5cXCd0IGdldCBhbiBpbnB1dCBuYW1lLicpO1xuICAgICAgfVxuICAgICAgaW5wdXROYW1lc1VURjhFbmNvZGVkLnB1c2gobmFtZSk7XG4gICAgICBpbnB1dE5hbWVzLnB1c2god2FzbS5VVEY4VG9TdHJpbmcobmFtZSkpO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG91dHB1dENvdW50OyBpKyspIHtcbiAgICAgIGNvbnN0IG5hbWUgPSB3YXNtLl9PcnRHZXRPdXRwdXROYW1lKHNlc3Npb25IYW5kbGUsIGkpO1xuICAgICAgaWYgKG5hbWUgPT09IDApIHtcbiAgICAgICAgY2hlY2tMYXN0RXJyb3IoJ0NhblxcJ3QgZ2V0IGFuIG91dHB1dCBuYW1lLicpO1xuICAgICAgfVxuICAgICAgb3V0cHV0TmFtZXNVVEY4RW5jb2RlZC5wdXNoKG5hbWUpO1xuICAgICAgY29uc3QgbmFtZVN0cmluZyA9IHdhc20uVVRGOFRvU3RyaW5nKG5hbWUpO1xuICAgICAgb3V0cHV0TmFtZXMucHVzaChuYW1lU3RyaW5nKTtcblxuICAgICAgaWYgKCFCVUlMRF9ERUZTLkRJU0FCTEVfV0VCR1BVKSB7XG4gICAgICAgIGNvbnN0IGxvY2F0aW9uID0gdHlwZW9mIG9wdGlvbnM/LnByZWZlcnJlZE91dHB1dExvY2F0aW9uID09PSAnc3RyaW5nJyA/XG4gICAgICAgICAgICBvcHRpb25zLnByZWZlcnJlZE91dHB1dExvY2F0aW9uIDpcbiAgICAgICAgICAgIG9wdGlvbnM/LnByZWZlcnJlZE91dHB1dExvY2F0aW9uPy5bbmFtZVN0cmluZ10gPz8gJ2NwdSc7XG4gICAgICAgIGlmIChsb2NhdGlvbiAhPT0gJ2NwdScgJiYgbG9jYXRpb24gIT09ICdjcHUtcGlubmVkJyAmJiBsb2NhdGlvbiAhPT0gJ2dwdS1idWZmZXInKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBOb3Qgc3VwcG9ydGVkIHByZWZlcnJlZCBvdXRwdXQgbG9jYXRpb246ICR7bG9jYXRpb259LmApO1xuICAgICAgICB9XG4gICAgICAgIG91dHB1dFByZWZlcnJlZExvY2F0aW9ucy5wdXNoKGxvY2F0aW9uKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyB1c2UgSU8gYmluZGluZyBvbmx5IHdoZW4gYXQgbGVhc3Qgb25lIG91dHB1dCBpcyBwcmVmZmVyZWQgdG8gYmUgb24gR1BVLlxuICAgIGxldCBiaW5kaW5nU3RhdGU6IElPQmluZGluZ1N0YXRlfG51bGwgPSBudWxsO1xuICAgIGlmICghQlVJTERfREVGUy5ESVNBQkxFX1dFQkdQVSAmJiBvdXRwdXRQcmVmZXJyZWRMb2NhdGlvbnMuc29tZShsID0+IGwgPT09ICdncHUtYnVmZmVyJykpIHtcbiAgICAgIGlvQmluZGluZ0hhbmRsZSA9IHdhc20uX09ydENyZWF0ZUJpbmRpbmcoc2Vzc2lvbkhhbmRsZSk7XG4gICAgICBpZiAoaW9CaW5kaW5nSGFuZGxlID09PSAwKSB7XG4gICAgICAgIGNoZWNrTGFzdEVycm9yKCdDYW5cXCd0IGNyZWF0ZSBJTyBiaW5kaW5nLicpO1xuICAgICAgfVxuXG4gICAgICBiaW5kaW5nU3RhdGUgPSB7XG4gICAgICAgIGhhbmRsZTogaW9CaW5kaW5nSGFuZGxlLFxuICAgICAgICBvdXRwdXRQcmVmZXJyZWRMb2NhdGlvbnMsXG4gICAgICAgIG91dHB1dFByZWZlcnJlZExvY2F0aW9uc0VuY29kZWQ6IG91dHB1dFByZWZlcnJlZExvY2F0aW9ucy5tYXAobCA9PiBkYXRhTG9jYXRpb25TdHJpbmdUb0VudW0obCkpLFxuICAgICAgfTtcbiAgICB9XG5cbiAgICBhY3RpdmVTZXNzaW9ucy5zZXQoc2Vzc2lvbkhhbmRsZSwgW3Nlc3Npb25IYW5kbGUsIGlucHV0TmFtZXNVVEY4RW5jb2RlZCwgb3V0cHV0TmFtZXNVVEY4RW5jb2RlZCwgYmluZGluZ1N0YXRlXSk7XG4gICAgcmV0dXJuIFtzZXNzaW9uSGFuZGxlLCBpbnB1dE5hbWVzLCBvdXRwdXROYW1lc107XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBpbnB1dE5hbWVzVVRGOEVuY29kZWQuZm9yRWFjaChidWYgPT4gd2FzbS5fT3J0RnJlZShidWYpKTtcbiAgICBvdXRwdXROYW1lc1VURjhFbmNvZGVkLmZvckVhY2goYnVmID0+IHdhc20uX09ydEZyZWUoYnVmKSk7XG5cbiAgICBpZiAoaW9CaW5kaW5nSGFuZGxlICE9PSAwKSB7XG4gICAgICB3YXNtLl9PcnRSZWxlYXNlQmluZGluZyhpb0JpbmRpbmdIYW5kbGUpO1xuICAgIH1cblxuICAgIGlmIChzZXNzaW9uSGFuZGxlICE9PSAwKSB7XG4gICAgICB3YXNtLl9PcnRSZWxlYXNlU2Vzc2lvbihzZXNzaW9uSGFuZGxlKTtcbiAgICB9XG4gICAgdGhyb3cgZTtcbiAgfSBmaW5hbGx5IHtcbiAgICB3YXNtLl9mcmVlKG1vZGVsRGF0YU9mZnNldCk7XG4gICAgaWYgKHNlc3Npb25PcHRpb25zSGFuZGxlICE9PSAwKSB7XG4gICAgICB3YXNtLl9PcnRSZWxlYXNlU2Vzc2lvbk9wdGlvbnMoc2Vzc2lvbk9wdGlvbnNIYW5kbGUpO1xuICAgIH1cbiAgICBhbGxvY3MuZm9yRWFjaChhbGxvYyA9PiB3YXNtLl9mcmVlKGFsbG9jKSk7XG5cbiAgICAvLyB1bm1vdW50IGV4dGVybmFsIGRhdGEgaWYgbmVjZXNzYXJ5XG4gICAgd2FzbS51bm1vdW50RXh0ZXJuYWxEYXRhPy4oKTtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IHJlbGVhc2VTZXNzaW9uID0gKHNlc3Npb25JZDogbnVtYmVyKTogdm9pZCA9PiB7XG4gIGNvbnN0IHdhc20gPSBnZXRJbnN0YW5jZSgpO1xuICBjb25zdCBzZXNzaW9uID0gYWN0aXZlU2Vzc2lvbnMuZ2V0KHNlc3Npb25JZCk7XG4gIGlmICghc2Vzc2lvbikge1xuICAgIHRocm93IG5ldyBFcnJvcihgY2Fubm90IHJlbGVhc2Ugc2Vzc2lvbi4gaW52YWxpZCBzZXNzaW9uIGlkOiAke3Nlc3Npb25JZH1gKTtcbiAgfVxuICBjb25zdCBbc2Vzc2lvbkhhbmRsZSwgaW5wdXROYW1lc1VURjhFbmNvZGVkLCBvdXRwdXROYW1lc1VURjhFbmNvZGVkLCBpb0JpbmRpbmdTdGF0ZV0gPSBzZXNzaW9uO1xuXG4gIGlmIChpb0JpbmRpbmdTdGF0ZSkge1xuICAgIHdhc20uX09ydFJlbGVhc2VCaW5kaW5nKGlvQmluZGluZ1N0YXRlLmhhbmRsZSk7XG4gIH1cblxuICB3YXNtLmpzZXBVbnJlZ2lzdGVyQnVmZmVycz8uKHNlc3Npb25JZCk7XG5cbiAgaW5wdXROYW1lc1VURjhFbmNvZGVkLmZvckVhY2goYnVmID0+IHdhc20uX09ydEZyZWUoYnVmKSk7XG4gIG91dHB1dE5hbWVzVVRGOEVuY29kZWQuZm9yRWFjaChidWYgPT4gd2FzbS5fT3J0RnJlZShidWYpKTtcbiAgd2FzbS5fT3J0UmVsZWFzZVNlc3Npb24oc2Vzc2lvbkhhbmRsZSk7XG4gIGFjdGl2ZVNlc3Npb25zLmRlbGV0ZShzZXNzaW9uSWQpO1xufTtcblxuZXhwb3J0IGNvbnN0IHByZXBhcmVJbnB1dE91dHB1dFRlbnNvciA9XG4gICAgKHRlbnNvcjogVGVuc29yTWV0YWRhdGF8bnVsbCwgdGVuc29ySGFuZGxlczogbnVtYmVyW10sIGFsbG9jczogbnVtYmVyW10sIHNlc3Npb25JZDogbnVtYmVyLCBpbmRleDogbnVtYmVyKTpcbiAgICAgICAgdm9pZCA9PiB7XG4gICAgICAgICAgaWYgKCF0ZW5zb3IpIHtcbiAgICAgICAgICAgIHRlbnNvckhhbmRsZXMucHVzaCgwKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCB3YXNtID0gZ2V0SW5zdGFuY2UoKTtcblxuICAgICAgICAgIGNvbnN0IGRhdGFUeXBlID0gdGVuc29yWzBdO1xuICAgICAgICAgIGNvbnN0IGRpbXMgPSB0ZW5zb3JbMV07XG4gICAgICAgICAgY29uc3QgbG9jYXRpb24gPSB0ZW5zb3JbM107XG5cbiAgICAgICAgICBsZXQgcmF3RGF0YTogbnVtYmVyO1xuICAgICAgICAgIGxldCBkYXRhQnl0ZUxlbmd0aDogbnVtYmVyO1xuXG4gICAgICAgICAgaWYgKGRhdGFUeXBlID09PSAnc3RyaW5nJyAmJiBsb2NhdGlvbiA9PT0gJ2dwdS1idWZmZXInKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1N0cmluZyB0ZW5zb3IgaXMgbm90IHN1cHBvcnRlZCBvbiBHUFUuJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGxvY2F0aW9uID09PSAnZ3B1LWJ1ZmZlcicpIHtcbiAgICAgICAgICAgIGNvbnN0IGdwdUJ1ZmZlciA9IHRlbnNvclsyXS5ncHVCdWZmZXIgYXMgR1BVQnVmZmVyO1xuICAgICAgICAgICAgY29uc3QgZWxlbWVudFNpemVJbkJ5dGVzID0gZ2V0VGVuc29yRWxlbWVudFNpemUodGVuc29yRGF0YVR5cGVTdHJpbmdUb0VudW0oZGF0YVR5cGUpKSE7XG4gICAgICAgICAgICBkYXRhQnl0ZUxlbmd0aCA9IGRpbXMucmVkdWNlKChhLCBiKSA9PiBhICogYiwgMSkgKiBlbGVtZW50U2l6ZUluQnl0ZXM7XG4gICAgICAgICAgICByYXdEYXRhID0gd2FzbS5qc2VwUmVnaXN0ZXJCdWZmZXIoc2Vzc2lvbklkLCBpbmRleCwgZ3B1QnVmZmVyLCBkYXRhQnl0ZUxlbmd0aCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSB0ZW5zb3JbMl07XG5cbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgICAgICAgICAgIC8vIHN0cmluZyB0ZW5zb3JcbiAgICAgICAgICAgICAgZGF0YUJ5dGVMZW5ndGggPSA0ICogZGF0YS5sZW5ndGg7XG4gICAgICAgICAgICAgIHJhd0RhdGEgPSB3YXNtLl9tYWxsb2MoZGF0YUJ5dGVMZW5ndGgpO1xuICAgICAgICAgICAgICBhbGxvY3MucHVzaChyYXdEYXRhKTtcbiAgICAgICAgICAgICAgbGV0IGRhdGFJbmRleCA9IHJhd0RhdGEgLyA0O1xuICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGRhdGFbaV0gIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGB0ZW5zb3IgZGF0YSBhdCBpbmRleCAke2l9IGlzIG5vdCBhIHN0cmluZ2ApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB3YXNtLkhFQVBVMzJbZGF0YUluZGV4KytdID0gYWxsb2NXYXNtU3RyaW5nKGRhdGFbaV0sIGFsbG9jcyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGRhdGFCeXRlTGVuZ3RoID0gZGF0YS5ieXRlTGVuZ3RoO1xuICAgICAgICAgICAgICByYXdEYXRhID0gd2FzbS5fbWFsbG9jKGRhdGFCeXRlTGVuZ3RoKTtcbiAgICAgICAgICAgICAgYWxsb2NzLnB1c2gocmF3RGF0YSk7XG4gICAgICAgICAgICAgIHdhc20uSEVBUFU4LnNldChuZXcgVWludDhBcnJheShkYXRhLmJ1ZmZlciwgZGF0YS5ieXRlT2Zmc2V0LCBkYXRhQnl0ZUxlbmd0aCksIHJhd0RhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IHN0YWNrID0gd2FzbS5zdGFja1NhdmUoKTtcbiAgICAgICAgICBjb25zdCBkaW1zT2Zmc2V0ID0gd2FzbS5zdGFja0FsbG9jKDQgKiBkaW1zLmxlbmd0aCk7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGxldCBkaW1JbmRleCA9IGRpbXNPZmZzZXQgLyA0O1xuICAgICAgICAgICAgZGltcy5mb3JFYWNoKGQgPT4gd2FzbS5IRUFQMzJbZGltSW5kZXgrK10gPSBkKTtcbiAgICAgICAgICAgIGNvbnN0IHRlbnNvciA9IHdhc20uX09ydENyZWF0ZVRlbnNvcihcbiAgICAgICAgICAgICAgICB0ZW5zb3JEYXRhVHlwZVN0cmluZ1RvRW51bShkYXRhVHlwZSksIHJhd0RhdGEsIGRhdGFCeXRlTGVuZ3RoLCBkaW1zT2Zmc2V0LCBkaW1zLmxlbmd0aCxcbiAgICAgICAgICAgICAgICBkYXRhTG9jYXRpb25TdHJpbmdUb0VudW0obG9jYXRpb24pKTtcbiAgICAgICAgICAgIGlmICh0ZW5zb3IgPT09IDApIHtcbiAgICAgICAgICAgICAgY2hlY2tMYXN0RXJyb3IoYENhbid0IGNyZWF0ZSB0ZW5zb3IgZm9yIGlucHV0L291dHB1dC4gc2Vzc2lvbj0ke3Nlc3Npb25JZH0sIGluZGV4PSR7aW5kZXh9LmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGVuc29ySGFuZGxlcy5wdXNoKHRlbnNvcik7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uc3RhY2tSZXN0b3JlKHN0YWNrKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbi8qKlxuICogcGVyZm9ybSBpbmZlcmVuY2UgcnVuXG4gKi9cbmV4cG9ydCBjb25zdCBydW4gPSBhc3luYyhcbiAgICBzZXNzaW9uSWQ6IG51bWJlciwgaW5wdXRJbmRpY2VzOiBudW1iZXJbXSwgaW5wdXRUZW5zb3JzOiBUZW5zb3JNZXRhZGF0YVtdLCBvdXRwdXRJbmRpY2VzOiBudW1iZXJbXSxcbiAgICBvdXRwdXRUZW5zb3JzOiBBcnJheTxUZW5zb3JNZXRhZGF0YXxudWxsPiwgb3B0aW9uczogSW5mZXJlbmNlU2Vzc2lvbi5SdW5PcHRpb25zKTogUHJvbWlzZTxUZW5zb3JNZXRhZGF0YVtdPiA9PiB7XG4gIGNvbnN0IHdhc20gPSBnZXRJbnN0YW5jZSgpO1xuICBjb25zdCBzZXNzaW9uID0gYWN0aXZlU2Vzc2lvbnMuZ2V0KHNlc3Npb25JZCk7XG4gIGlmICghc2Vzc2lvbikge1xuICAgIHRocm93IG5ldyBFcnJvcihgY2Fubm90IHJ1biBpbmZlcmVuY2UuIGludmFsaWQgc2Vzc2lvbiBpZDogJHtzZXNzaW9uSWR9YCk7XG4gIH1cbiAgY29uc3QgW3Nlc3Npb25IYW5kbGUsIGlucHV0TmFtZXNVVEY4RW5jb2RlZCwgb3V0cHV0TmFtZXNVVEY4RW5jb2RlZCwgaW9CaW5kaW5nU3RhdGVdID0gc2Vzc2lvbjtcblxuICBjb25zdCBpbnB1dENvdW50ID0gaW5wdXRJbmRpY2VzLmxlbmd0aDtcbiAgY29uc3Qgb3V0cHV0Q291bnQgPSBvdXRwdXRJbmRpY2VzLmxlbmd0aDtcblxuICBsZXQgcnVuT3B0aW9uc0hhbmRsZSA9IDA7XG4gIGxldCBydW5PcHRpb25zQWxsb2NzOiBudW1iZXJbXSA9IFtdO1xuXG4gIGNvbnN0IGlucHV0VGVuc29ySGFuZGxlczogbnVtYmVyW10gPSBbXTtcbiAgY29uc3Qgb3V0cHV0VGVuc29ySGFuZGxlczogbnVtYmVyW10gPSBbXTtcbiAgY29uc3QgaW5wdXRPdXRwdXRBbGxvY3M6IG51bWJlcltdID0gW107XG5cbiAgY29uc3QgYmVmb3JlUnVuU3RhY2sgPSB3YXNtLnN0YWNrU2F2ZSgpO1xuICBjb25zdCBpbnB1dFZhbHVlc09mZnNldCA9IHdhc20uc3RhY2tBbGxvYyhpbnB1dENvdW50ICogNCk7XG4gIGNvbnN0IGlucHV0TmFtZXNPZmZzZXQgPSB3YXNtLnN0YWNrQWxsb2MoaW5wdXRDb3VudCAqIDQpO1xuICBjb25zdCBvdXRwdXRWYWx1ZXNPZmZzZXQgPSB3YXNtLnN0YWNrQWxsb2Mob3V0cHV0Q291bnQgKiA0KTtcbiAgY29uc3Qgb3V0cHV0TmFtZXNPZmZzZXQgPSB3YXNtLnN0YWNrQWxsb2Mob3V0cHV0Q291bnQgKiA0KTtcblxuICB0cnkge1xuICAgIFtydW5PcHRpb25zSGFuZGxlLCBydW5PcHRpb25zQWxsb2NzXSA9IHNldFJ1bk9wdGlvbnMob3B0aW9ucyk7XG5cbiAgICAvLyBjcmVhdGUgaW5wdXQgdGVuc29yc1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5wdXRDb3VudDsgaSsrKSB7XG4gICAgICBwcmVwYXJlSW5wdXRPdXRwdXRUZW5zb3IoaW5wdXRUZW5zb3JzW2ldLCBpbnB1dFRlbnNvckhhbmRsZXMsIGlucHV0T3V0cHV0QWxsb2NzLCBzZXNzaW9uSWQsIGlucHV0SW5kaWNlc1tpXSk7XG4gICAgfVxuXG4gICAgLy8gY3JlYXRlIG91dHB1dCB0ZW5zb3JzXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvdXRwdXRDb3VudDsgaSsrKSB7XG4gICAgICBwcmVwYXJlSW5wdXRPdXRwdXRUZW5zb3IoXG4gICAgICAgICAgb3V0cHV0VGVuc29yc1tpXSwgb3V0cHV0VGVuc29ySGFuZGxlcywgaW5wdXRPdXRwdXRBbGxvY3MsIHNlc3Npb25JZCwgaW5wdXRDb3VudCArIG91dHB1dEluZGljZXNbaV0pO1xuICAgIH1cblxuICAgIGxldCBpbnB1dFZhbHVlc0luZGV4ID0gaW5wdXRWYWx1ZXNPZmZzZXQgLyA0O1xuICAgIGxldCBpbnB1dE5hbWVzSW5kZXggPSBpbnB1dE5hbWVzT2Zmc2V0IC8gNDtcbiAgICBsZXQgb3V0cHV0VmFsdWVzSW5kZXggPSBvdXRwdXRWYWx1ZXNPZmZzZXQgLyA0O1xuICAgIGxldCBvdXRwdXROYW1lc0luZGV4ID0gb3V0cHV0TmFtZXNPZmZzZXQgLyA0O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5wdXRDb3VudDsgaSsrKSB7XG4gICAgICB3YXNtLkhFQVBVMzJbaW5wdXRWYWx1ZXNJbmRleCsrXSA9IGlucHV0VGVuc29ySGFuZGxlc1tpXTtcbiAgICAgIHdhc20uSEVBUFUzMltpbnB1dE5hbWVzSW5kZXgrK10gPSBpbnB1dE5hbWVzVVRGOEVuY29kZWRbaW5wdXRJbmRpY2VzW2ldXTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvdXRwdXRDb3VudDsgaSsrKSB7XG4gICAgICB3YXNtLkhFQVBVMzJbb3V0cHV0VmFsdWVzSW5kZXgrK10gPSBvdXRwdXRUZW5zb3JIYW5kbGVzW2ldO1xuICAgICAgd2FzbS5IRUFQVTMyW291dHB1dE5hbWVzSW5kZXgrK10gPSBvdXRwdXROYW1lc1VURjhFbmNvZGVkW291dHB1dEluZGljZXNbaV1dO1xuICAgIH1cblxuICAgIGlmICghQlVJTERfREVGUy5ESVNBQkxFX1dFQkdQVSAmJiBpb0JpbmRpbmdTdGF0ZSkge1xuICAgICAgY29uc3Qge2hhbmRsZSwgb3V0cHV0UHJlZmVycmVkTG9jYXRpb25zLCBvdXRwdXRQcmVmZXJyZWRMb2NhdGlvbnNFbmNvZGVkfSA9IGlvQmluZGluZ1N0YXRlO1xuXG4gICAgICBpZiAoaW5wdXROYW1lc1VURjhFbmNvZGVkLmxlbmd0aCAhPT0gaW5wdXRDb3VudCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGlucHV0IGNvdW50IGZyb20gZmVlZHMgKCR7XG4gICAgICAgICAgICBpbnB1dENvdW50fSkgaXMgZXhwZWN0ZWQgdG8gYmUgYWx3YXlzIGVxdWFsIHRvIG1vZGVsJ3MgaW5wdXQgY291bnQgKCR7aW5wdXROYW1lc1VURjhFbmNvZGVkLmxlbmd0aH0pLmApO1xuICAgICAgfVxuXG4gICAgICAvLyBwcm9jZXNzIGlucHV0c1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnB1dENvdW50OyBpKyspIHtcbiAgICAgICAgY29uc3QgaW5kZXggPSBpbnB1dEluZGljZXNbaV07XG4gICAgICAgIGNvbnN0IGVycm9yQ29kZSA9IGF3YWl0IHdhc20uX09ydEJpbmRJbnB1dChoYW5kbGUsIGlucHV0TmFtZXNVVEY4RW5jb2RlZFtpbmRleF0sIGlucHV0VGVuc29ySGFuZGxlc1tpXSk7XG4gICAgICAgIGlmIChlcnJvckNvZGUgIT09IDApIHtcbiAgICAgICAgICBjaGVja0xhc3RFcnJvcihgQ2FuJ3QgYmluZCBpbnB1dFske2l9XSBmb3Igc2Vzc2lvbj0ke3Nlc3Npb25JZH0uYCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gcHJvY2VzcyBwcmUtYWxsb2NhdGVkIG91dHB1dHNcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3V0cHV0Q291bnQ7IGkrKykge1xuICAgICAgICBjb25zdCBpbmRleCA9IG91dHB1dEluZGljZXNbaV07XG4gICAgICAgIGNvbnN0IGxvY2F0aW9uID0gb3V0cHV0VGVuc29yc1tpXT8uWzNdOyAgLy8gdW5kZWZpbmVkIG1lYW5zIG91dHB1dCBpcyBub3QgcHJlLWFsbG9jYXRlZC5cblxuICAgICAgICBpZiAobG9jYXRpb24pIHtcbiAgICAgICAgICAvLyBvdXRwdXQgaXMgcHJlLWFsbG9jYXRlZC4gYmluZCB0aGUgdGVuc29yLlxuICAgICAgICAgIGNvbnN0IGVycm9yQ29kZSA9IHdhc20uX09ydEJpbmRPdXRwdXQoaGFuZGxlLCBvdXRwdXROYW1lc1VURjhFbmNvZGVkW2luZGV4XSwgb3V0cHV0VGVuc29ySGFuZGxlc1tpXSwgMCk7XG4gICAgICAgICAgaWYgKGVycm9yQ29kZSAhPT0gMCkge1xuICAgICAgICAgICAgY2hlY2tMYXN0RXJyb3IoYENhbid0IGJpbmQgcHJlLWFsbG9jYXRlZCBvdXRwdXRbJHtpfV0gZm9yIHNlc3Npb249JHtzZXNzaW9uSWR9LmApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBvdXRwdXQgaXMgbm90IHByZS1hbGxvY2F0ZWQuIHJlc2V0IHByZWZlcnJlZCBsb2NhdGlvbi5cbiAgICAgICAgICBjb25zdCBlcnJvckNvZGUgPVxuICAgICAgICAgICAgICB3YXNtLl9PcnRCaW5kT3V0cHV0KGhhbmRsZSwgb3V0cHV0TmFtZXNVVEY4RW5jb2RlZFtpbmRleF0sIDAsIG91dHB1dFByZWZlcnJlZExvY2F0aW9uc0VuY29kZWRbaW5kZXhdKTtcbiAgICAgICAgICBpZiAoZXJyb3JDb2RlICE9PSAwKSB7XG4gICAgICAgICAgICBjaGVja0xhc3RFcnJvcihgQ2FuJ3QgYmluZCBvdXRwdXRbJHtpfV0gdG8gJHtvdXRwdXRQcmVmZXJyZWRMb2NhdGlvbnNbaV19IGZvciBzZXNzaW9uPSR7c2Vzc2lvbklkfS5gKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQgZXJyb3JDb2RlOiBudW1iZXI7XG5cbiAgICBpZiAoIUJVSUxEX0RFRlMuRElTQUJMRV9XRUJHUFUgJiYgaW9CaW5kaW5nU3RhdGUpIHtcbiAgICAgIGVycm9yQ29kZSA9IGF3YWl0IHdhc20uX09ydFJ1bldpdGhCaW5kaW5nKFxuICAgICAgICAgIHNlc3Npb25IYW5kbGUsIGlvQmluZGluZ1N0YXRlLmhhbmRsZSwgb3V0cHV0Q291bnQsIG91dHB1dFZhbHVlc09mZnNldCwgcnVuT3B0aW9uc0hhbmRsZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVycm9yQ29kZSA9IGF3YWl0IHdhc20uX09ydFJ1bihcbiAgICAgICAgICBzZXNzaW9uSGFuZGxlLCBpbnB1dE5hbWVzT2Zmc2V0LCBpbnB1dFZhbHVlc09mZnNldCwgaW5wdXRDb3VudCwgb3V0cHV0TmFtZXNPZmZzZXQsIG91dHB1dENvdW50LFxuICAgICAgICAgIG91dHB1dFZhbHVlc09mZnNldCwgcnVuT3B0aW9uc0hhbmRsZSk7XG4gICAgfVxuXG4gICAgaWYgKGVycm9yQ29kZSAhPT0gMCkge1xuICAgICAgY2hlY2tMYXN0RXJyb3IoJ2ZhaWxlZCB0byBjYWxsIE9ydFJ1bigpLicpO1xuICAgIH1cblxuICAgIGNvbnN0IG91dHB1dDogVGVuc29yTWV0YWRhdGFbXSA9IFtdO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvdXRwdXRDb3VudDsgaSsrKSB7XG4gICAgICBjb25zdCB0ZW5zb3IgPSB3YXNtLkhFQVBVMzJbb3V0cHV0VmFsdWVzT2Zmc2V0IC8gNCArIGldO1xuICAgICAgaWYgKHRlbnNvciA9PT0gb3V0cHV0VGVuc29ySGFuZGxlc1tpXSkge1xuICAgICAgICAvLyBvdXRwdXQgdGVuc29yIGlzIHByZS1hbGxvY2F0ZWQuIG5vIG5lZWQgdG8gY29weSBkYXRhLlxuICAgICAgICBvdXRwdXQucHVzaChvdXRwdXRUZW5zb3JzW2ldISk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBiZWZvcmVHZXRUZW5zb3JEYXRhU3RhY2sgPSB3YXNtLnN0YWNrU2F2ZSgpO1xuICAgICAgLy8gc3RhY2sgYWxsb2NhdGUgNCBwb2ludGVyIHZhbHVlXG4gICAgICBjb25zdCB0ZW5zb3JEYXRhT2Zmc2V0ID0gd2FzbS5zdGFja0FsbG9jKDQgKiA0KTtcblxuICAgICAgbGV0IGtlZXBPdXRwdXRUZW5zb3IgPSBmYWxzZTtcbiAgICAgIGxldCB0eXBlOiBUZW5zb3IuVHlwZXx1bmRlZmluZWQsIGRhdGFPZmZzZXQgPSAwO1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgZXJyb3JDb2RlID0gd2FzbS5fT3J0R2V0VGVuc29yRGF0YShcbiAgICAgICAgICAgIHRlbnNvciwgdGVuc29yRGF0YU9mZnNldCwgdGVuc29yRGF0YU9mZnNldCArIDQsIHRlbnNvckRhdGFPZmZzZXQgKyA4LCB0ZW5zb3JEYXRhT2Zmc2V0ICsgMTIpO1xuICAgICAgICBpZiAoZXJyb3JDb2RlICE9PSAwKSB7XG4gICAgICAgICAgY2hlY2tMYXN0RXJyb3IoYENhbid0IGFjY2VzcyBvdXRwdXQgdGVuc29yIGRhdGEgb24gaW5kZXggJHtpfS5gKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdGVuc29yRGF0YUluZGV4ID0gdGVuc29yRGF0YU9mZnNldCAvIDQ7XG4gICAgICAgIGNvbnN0IGRhdGFUeXBlID0gd2FzbS5IRUFQVTMyW3RlbnNvckRhdGFJbmRleCsrXTtcbiAgICAgICAgZGF0YU9mZnNldCA9IHdhc20uSEVBUFUzMlt0ZW5zb3JEYXRhSW5kZXgrK107XG4gICAgICAgIGNvbnN0IGRpbXNPZmZzZXQgPSB3YXNtLkhFQVBVMzJbdGVuc29yRGF0YUluZGV4KytdO1xuICAgICAgICBjb25zdCBkaW1zTGVuZ3RoID0gd2FzbS5IRUFQVTMyW3RlbnNvckRhdGFJbmRleCsrXTtcbiAgICAgICAgY29uc3QgZGltcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRpbXNMZW5ndGg7IGkrKykge1xuICAgICAgICAgIGRpbXMucHVzaCh3YXNtLkhFQVBVMzJbZGltc09mZnNldCAvIDQgKyBpXSk7XG4gICAgICAgIH1cbiAgICAgICAgd2FzbS5fT3J0RnJlZShkaW1zT2Zmc2V0KTtcblxuICAgICAgICBjb25zdCBzaXplID0gZGltcy5yZWR1Y2UoKGEsIGIpID0+IGEgKiBiLCAxKTtcbiAgICAgICAgdHlwZSA9IHRlbnNvckRhdGFUeXBlRW51bVRvU3RyaW5nKGRhdGFUeXBlKTtcblxuICAgICAgICBjb25zdCBwcmVmZXJyZWRMb2NhdGlvbiA9IGlvQmluZGluZ1N0YXRlPy5vdXRwdXRQcmVmZXJyZWRMb2NhdGlvbnNbb3V0cHV0SW5kaWNlc1tpXV07XG5cbiAgICAgICAgaWYgKHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgaWYgKHByZWZlcnJlZExvY2F0aW9uID09PSAnZ3B1LWJ1ZmZlcicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignU3RyaW5nIHRlbnNvciBpcyBub3Qgc3VwcG9ydGVkIG9uIEdQVS4nKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3Qgc3RyaW5nRGF0YTogc3RyaW5nW10gPSBbXTtcbiAgICAgICAgICBsZXQgZGF0YUluZGV4ID0gZGF0YU9mZnNldCAvIDQ7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaXplOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IG9mZnNldCA9IHdhc20uSEVBUFUzMltkYXRhSW5kZXgrK107XG4gICAgICAgICAgICBjb25zdCBtYXhCeXRlc1RvUmVhZCA9IGkgPT09IHNpemUgLSAxID8gdW5kZWZpbmVkIDogd2FzbS5IRUFQVTMyW2RhdGFJbmRleF0gLSBvZmZzZXQ7XG4gICAgICAgICAgICBzdHJpbmdEYXRhLnB1c2god2FzbS5VVEY4VG9TdHJpbmcob2Zmc2V0LCBtYXhCeXRlc1RvUmVhZCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvdXRwdXQucHVzaChbdHlwZSwgZGltcywgc3RyaW5nRGF0YSwgJ2NwdSddKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBJZiBhIGNlcnRhaW4gb3V0cHV0J3MgcHJlZmVycmVkIGxvY2F0aW9uIGlzIEdQVSBidXQgdGhlIHRlbnNvciBpcyBlbXB0eSwgd2Ugc3RpbGwgbmVlZCB0byBjcmVhdGUgYSBDUFVcbiAgICAgICAgICAvLyB0ZW5zb3IgZm9yIGl0LiBUaGVyZSBpcyBubyBtYXBwaW5nIEdQVSBidWZmZXIgZm9yIGFuIGVtcHR5IHRlbnNvci5cbiAgICAgICAgICBpZiAocHJlZmVycmVkTG9jYXRpb24gPT09ICdncHUtYnVmZmVyJyAmJiBzaXplID4gMCkge1xuICAgICAgICAgICAgY29uc3QgZ3B1QnVmZmVyID0gd2FzbS5qc2VwR2V0QnVmZmVyKGRhdGFPZmZzZXQpO1xuICAgICAgICAgICAgY29uc3QgZWxlbWVudFNpemUgPSBnZXRUZW5zb3JFbGVtZW50U2l6ZShkYXRhVHlwZSk7XG4gICAgICAgICAgICBpZiAoZWxlbWVudFNpemUgPT09IHVuZGVmaW5lZCB8fCAhaXNHcHVCdWZmZXJTdXBwb3J0ZWRUeXBlKHR5cGUpKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgZGF0YSB0eXBlOiAke3R5cGV9YCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGRvIG5vdCByZWxlYXNlIHRoZSB0ZW5zb3IgcmlnaHQgbm93LiBpdCB3aWxsIGJlIHJlbGVhc2VkIHdoZW4gdXNlciBjYWxscyB0ZW5zb3IuZGlzcG9zZSgpLlxuICAgICAgICAgICAga2VlcE91dHB1dFRlbnNvciA9IHRydWU7XG5cbiAgICAgICAgICAgIG91dHB1dC5wdXNoKFtcbiAgICAgICAgICAgICAgdHlwZSwgZGltcywge1xuICAgICAgICAgICAgICAgIGdwdUJ1ZmZlcixcbiAgICAgICAgICAgICAgICBkb3dubG9hZDogd2FzbS5qc2VwQ3JlYXRlRG93bmxvYWRlcihncHVCdWZmZXIsIHNpemUgKiBlbGVtZW50U2l6ZSwgdHlwZSksXG4gICAgICAgICAgICAgICAgZGlzcG9zZTogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgd2FzbS5fT3J0UmVsZWFzZVRlbnNvcih0ZW5zb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgJ2dwdS1idWZmZXInXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgdHlwZWRBcnJheUNvbnN0cnVjdG9yID0gdGVuc29yVHlwZVRvVHlwZWRBcnJheUNvbnN0cnVjdG9yKHR5cGUpO1xuICAgICAgICAgICAgY29uc3QgZGF0YSA9IG5ldyB0eXBlZEFycmF5Q29uc3RydWN0b3Ioc2l6ZSk7XG4gICAgICAgICAgICBuZXcgVWludDhBcnJheShkYXRhLmJ1ZmZlciwgZGF0YS5ieXRlT2Zmc2V0LCBkYXRhLmJ5dGVMZW5ndGgpXG4gICAgICAgICAgICAgICAgLnNldCh3YXNtLkhFQVBVOC5zdWJhcnJheShkYXRhT2Zmc2V0LCBkYXRhT2Zmc2V0ICsgZGF0YS5ieXRlTGVuZ3RoKSk7XG4gICAgICAgICAgICBvdXRwdXQucHVzaChbdHlwZSwgZGltcywgZGF0YSwgJ2NwdSddKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHdhc20uc3RhY2tSZXN0b3JlKGJlZm9yZUdldFRlbnNvckRhdGFTdGFjayk7XG4gICAgICAgIGlmICh0eXBlID09PSAnc3RyaW5nJyAmJiBkYXRhT2Zmc2V0KSB7XG4gICAgICAgICAgd2FzbS5fZnJlZShkYXRhT2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWtlZXBPdXRwdXRUZW5zb3IpIHtcbiAgICAgICAgICB3YXNtLl9PcnRSZWxlYXNlVGVuc29yKHRlbnNvcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaW9CaW5kaW5nU3RhdGUpIHtcbiAgICAgIHdhc20uX09ydENsZWFyQm91bmRPdXRwdXRzKGlvQmluZGluZ1N0YXRlLmhhbmRsZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dHB1dDtcbiAgfSBmaW5hbGx5IHtcbiAgICB3YXNtLnN0YWNrUmVzdG9yZShiZWZvcmVSdW5TdGFjayk7XG5cbiAgICBpbnB1dFRlbnNvckhhbmRsZXMuZm9yRWFjaCh2ID0+IHdhc20uX09ydFJlbGVhc2VUZW5zb3IodikpO1xuICAgIG91dHB1dFRlbnNvckhhbmRsZXMuZm9yRWFjaCh2ID0+IHdhc20uX09ydFJlbGVhc2VUZW5zb3IodikpO1xuICAgIGlucHV0T3V0cHV0QWxsb2NzLmZvckVhY2gocCA9PiB3YXNtLl9mcmVlKHApKTtcblxuICAgIGlmIChydW5PcHRpb25zSGFuZGxlICE9PSAwKSB7XG4gICAgICB3YXNtLl9PcnRSZWxlYXNlUnVuT3B0aW9ucyhydW5PcHRpb25zSGFuZGxlKTtcbiAgICB9XG4gICAgcnVuT3B0aW9uc0FsbG9jcy5mb3JFYWNoKHAgPT4gd2FzbS5fZnJlZShwKSk7XG4gIH1cbn07XG5cbi8qKlxuICogZW5kIHByb2ZpbGluZ1xuICovXG5leHBvcnQgY29uc3QgZW5kUHJvZmlsaW5nID0gKHNlc3Npb25JZDogbnVtYmVyKTogdm9pZCA9PiB7XG4gIGNvbnN0IHdhc20gPSBnZXRJbnN0YW5jZSgpO1xuICBjb25zdCBzZXNzaW9uID0gYWN0aXZlU2Vzc2lvbnMuZ2V0KHNlc3Npb25JZCk7XG4gIGlmICghc2Vzc2lvbikge1xuICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBzZXNzaW9uIGlkJyk7XG4gIH1cbiAgY29uc3Qgc2Vzc2lvbkhhbmRsZSA9IHNlc3Npb25bMF07XG5cbiAgLy8gcHJvZmlsZSBmaWxlIG5hbWUgaXMgbm90IHVzZWQgeWV0LCBidXQgaXQgbXVzdCBiZSBmcmVlZC5cbiAgY29uc3QgcHJvZmlsZUZpbGVOYW1lID0gd2FzbS5fT3J0RW5kUHJvZmlsaW5nKHNlc3Npb25IYW5kbGUpO1xuICBpZiAocHJvZmlsZUZpbGVOYW1lID09PSAwKSB7XG4gICAgY2hlY2tMYXN0RXJyb3IoJ0NhblxcJ3QgZ2V0IGFuIHByb2ZpbGUgZmlsZSBuYW1lLicpO1xuICB9XG4gIHdhc20uX09ydEZyZWUocHJvZmlsZUZpbGVOYW1lKTtcbn07XG5cbmV4cG9ydCBjb25zdCBleHRyYWN0VHJhbnNmZXJhYmxlQnVmZmVycyA9ICh0ZW5zb3JzOiByZWFkb25seSBTZXJpYWxpemFibGVUZW5zb3JNZXRhZGF0YVtdKTogQXJyYXlCdWZmZXJMaWtlW10gPT4ge1xuICBjb25zdCBidWZmZXJzOiBBcnJheUJ1ZmZlckxpa2VbXSA9IFtdO1xuICBmb3IgKGNvbnN0IHRlbnNvciBvZiB0ZW5zb3JzKSB7XG4gICAgY29uc3QgZGF0YSA9IHRlbnNvclsyXTtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoZGF0YSkgJiYgJ2J1ZmZlcicgaW4gZGF0YSkge1xuICAgICAgYnVmZmVycy5wdXNoKGRhdGEuYnVmZmVyKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGJ1ZmZlcnM7XG59O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQgKiBhcyBmcyBmcm9tICdmcyc7XG5pbXBvcnQge3JlYWRGaWxlfSBmcm9tICdub2RlOmZzL3Byb21pc2VzJztcblxuLyoqXG4gKiBMb2FkIGEgZmlsZSBpbnRvIGEgVWludDhBcnJheS5cbiAqXG4gKiBAcGFyYW0gZmlsZSAtIHRoZSBmaWxlIHRvIGxvYWQuIENhbiBiZSBhIFVSTC9wYXRoLCBhIEJsb2IsIGFuIEFycmF5QnVmZmVyLCBvciBhIFVpbnQ4QXJyYXkuXG4gKiBAcmV0dXJucyBhIFVpbnQ4QXJyYXkgY29udGFpbmluZyB0aGUgZmlsZSBkYXRhLlxuICovXG5leHBvcnQgY29uc3QgbG9hZEZpbGUgPSBhc3luYyhmaWxlOiBzdHJpbmd8QmxvYnxBcnJheUJ1ZmZlckxpa2V8VWludDhBcnJheSk6IFByb21pc2U8VWludDhBcnJheT4gPT4ge1xuICBpZiAodHlwZW9mIGZpbGUgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiBwcm9jZXNzLnZlcnNpb25zICYmIHByb2Nlc3MudmVyc2lvbnMubm9kZSkge1xuICAgICAgLy8gbG9hZCBmaWxlIGludG8gQXJyYXlCdWZmZXIgaW4gTm9kZS5qc1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGF3YWl0IHJlYWRGaWxlKGZpbGUpKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKGUuY29kZSA9PT0gJ0VSUl9GU19GSUxFX1RPT19MQVJHRScpIHtcbiAgICAgICAgICAvLyBmaWxlIGlzIHRvbyBsYXJnZSwgdXNlIGZzLmNyZWF0ZVJlYWRTdHJlYW0gaW5zdGVhZFxuICAgICAgICAgIGNvbnN0IHN0cmVhbSA9IGZzLmNyZWF0ZVJlYWRTdHJlYW0oZmlsZSk7XG4gICAgICAgICAgY29uc3QgY2h1bmtzOiBVaW50OEFycmF5W10gPSBbXTtcbiAgICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIHN0cmVhbSkge1xuICAgICAgICAgICAgY2h1bmtzLnB1c2goY2h1bmspO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoQnVmZmVyLmNvbmNhdChjaHVua3MpKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBsb2FkIGZpbGUgaW50byBBcnJheUJ1ZmZlciBpbiBicm93c2Vyc1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChmaWxlKTtcbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBmYWlsZWQgdG8gbG9hZCBleHRlcm5hbCBkYXRhIGZpbGU6ICR7ZmlsZX1gKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNvbnRlbnRMZW5ndGhIZWFkZXIgPSByZXNwb25zZS5oZWFkZXJzLmdldCgnQ29udGVudC1MZW5ndGgnKTtcbiAgICAgIGNvbnN0IGZpbGVTaXplID0gY29udGVudExlbmd0aEhlYWRlciA/IHBhcnNlSW50KGNvbnRlbnRMZW5ndGhIZWFkZXIsIDEwKSA6IDA7XG4gICAgICBpZiAoZmlsZVNpemUgPCAxMDczNzQxODI0IC8qIDFHQiAqLykge1xuICAgICAgICAvLyB3aGVuIENvbnRlbnQtTGVuZ3RoIGhlYWRlciBpcyBub3Qgc2V0LCB3ZSBjYW5ub3QgZGV0ZXJtaW5lIHRoZSBmaWxlIHNpemUuIFdlIGFzc3VtZSBpdCBpcyBzbWFsbCBlbm91Z2ggdG9cbiAgICAgICAgLy8gbG9hZCBpbnRvIG1lbW9yeS5cbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGF3YWl0IHJlc3BvbnNlLmFycmF5QnVmZmVyKCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZmlsZSBpcyB0b28gbGFyZ2UsIHVzZSBzdHJlYW0gaW5zdGVhZFxuICAgICAgICBpZiAoIXJlc3BvbnNlLmJvZHkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGZhaWxlZCB0byBsb2FkIGV4dGVybmFsIGRhdGEgZmlsZTogJHtmaWxlfSwgbm8gcmVzcG9uc2UgYm9keS5gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZWFkZXIgPSByZXNwb25zZS5ib2R5LmdldFJlYWRlcigpO1xuXG4gICAgICAgIGxldCBidWZmZXI7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gdHJ5IHRvIGNyZWF0ZSBBcnJheUJ1ZmZlciBkaXJlY3RseVxuICAgICAgICAgIGJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcihmaWxlU2l6ZSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIFJhbmdlRXJyb3IpIHtcbiAgICAgICAgICAgIC8vIHVzZSBXZWJBc3NlbWJseSBNZW1vcnkgdG8gYWxsb2NhdGUgbGFyZ2VyIEFycmF5QnVmZmVyXG4gICAgICAgICAgICBjb25zdCBwYWdlcyA9IE1hdGguY2VpbChmaWxlU2l6ZSAvIDY1NTM2KTtcbiAgICAgICAgICAgIGJ1ZmZlciA9IG5ldyBXZWJBc3NlbWJseS5NZW1vcnkoe2luaXRpYWw6IHBhZ2VzLCBtYXhpbXVtOiBwYWdlc30pLmJ1ZmZlcjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnN0YW50LWNvbmRpdGlvblxuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgIGNvbnN0IHtkb25lLCB2YWx1ZX0gPSBhd2FpdCByZWFkZXIucmVhZCgpO1xuICAgICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgY2h1bmtTaXplID0gdmFsdWUuYnl0ZUxlbmd0aDtcbiAgICAgICAgICBjb25zdCBjaHVuayA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlciwgb2Zmc2V0LCBjaHVua1NpemUpO1xuICAgICAgICAgIGNodW5rLnNldCh2YWx1ZSk7XG4gICAgICAgICAgb2Zmc2V0ICs9IGNodW5rU2l6ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyLCAwLCBmaWxlU2l6ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gIH0gZWxzZSBpZiAoZmlsZSBpbnN0YW5jZW9mIEJsb2IpIHtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYXdhaXQgZmlsZS5hcnJheUJ1ZmZlcigpKTtcbiAgfSBlbHNlIGlmIChmaWxlIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgIHJldHVybiBmaWxlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShmaWxlKTtcbiAgfVxufTtcbiIsICJleHBvcnQgY29uc3QgcmVhZEZpbGUgPSB1bmRlZmluZWQ7ZXhwb3J0IGNvbnN0IHJlYWRGaWxlU3luYyA9IHVuZGVmaW5lZDtleHBvcnQgY29uc3QgY3JlYXRlUmVhZFN0cmVhbSA9IHVuZGVmaW5lZDsiLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbi8vLyA8cmVmZXJlbmNlIGxpYj1cIndlYndvcmtlclwiIC8+XG5cbi8vXG4vLyAqIHR5cGUgaGFjayBmb3IgXCJIVE1MSW1hZ2VFbGVtZW50XCJcbi8vXG4vLyBpbiB0eXBlc2NyaXB0LCB0aGUgdHlwZSBvZiBcIkhUTUxJbWFnZUVsZW1lbnRcIiBpcyBkZWZpbmVkIGluIGxpYi5kb20uZC50cywgd2hpY2ggaXMgY29uZmxpY3Qgd2l0aCBsaWIud2Vid29ya2VyLmQudHMuXG4vLyB3aGVuIHdlIHVzZSB3ZWJ3b3JrZXIsIHRoZSBsaWIud2Vid29ya2VyLmQudHMgd2lsbCBiZSB1c2VkLCB3aGljaCBkb2VzIG5vdCBoYXZlIEhUTUxJbWFnZUVsZW1lbnQgZGVmaW5lZC5cbi8vXG4vLyB3ZSB3aWxsIGdldCB0aGUgZm9sbG93aW5nIGVycm9ycyBjb21wbGFpbmluZyB0aGF0IEhUTUxJbWFnZUVsZW1lbnQgaXMgbm90IGRlZmluZWQ6XG4vL1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vXG4vLyAuLi9jb21tb24vZGlzdC9janMvdGVuc29yLWZhY3RvcnkuZC50czoxODc6MjkgLSBlcnJvciBUUzI1NTI6IENhbm5vdCBmaW5kIG5hbWUgJ0hUTUxJbWFnZUVsZW1lbnQnLiBEaWQgeW91IG1lYW5cbi8vICdIVE1MTElFbGVtZW50Jz9cbi8vXG4vLyAxODcgICAgIGZyb21JbWFnZShpbWFnZUVsZW1lbnQ6IEhUTUxJbWFnZUVsZW1lbnQsIG9wdGlvbnM/OiBUZW5zb3JGcm9tSW1hZ2VFbGVtZW50T3B0aW9ucyk6XG4vLyBQcm9taXNlPFR5cGVkVGVuc29yPCdmbG9hdDMyJz4gfCBUeXBlZFRlbnNvcjwndWludDgnPj47XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH5+fn5+fn5+fn5+fn5+fn5cbi8vXG4vLyBub2RlX21vZHVsZXMvQHdlYmdwdS90eXBlcy9kaXN0L2luZGV4LmQudHM6ODM6NyAtIGVycm9yIFRTMjU1MjogQ2Fubm90IGZpbmQgbmFtZSAnSFRNTEltYWdlRWxlbWVudCcuIERpZCB5b3UgbWVhblxuLy8gJ0hUTUxMSUVsZW1lbnQnP1xuLy9cbi8vIDgzICAgICB8IEhUTUxJbWFnZUVsZW1lbnRcbi8vICAgICAgICAgIH5+fn5+fn5+fn5+fn5+fn5cbi8vXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy9cbi8vIGBIVE1MSW1hZ2VFbGVtZW50YCBpcyBvbmx5IHVzZWQgaW4gdHlwZSBkZWNsYXJhdGlvbiBhbmQgbm90IGluIHJlYWwgY29kZS4gU28gd2UgZGVmaW5lIGl0IGFzIGB1bmtub3duYCBoZXJlIHRvXG4vLyBieXBhc3MgdGhlIHR5cGUgY2hlY2suXG4vL1xuZGVjbGFyZSBnbG9iYWwge1xuICB0eXBlIEhUTUxJbWFnZUVsZW1lbnQgPSB1bmtub3duO1xufVxuXG5pbXBvcnQge09ydFdhc21NZXNzYWdlLCBTZXJpYWxpemFibGVUZW5zb3JNZXRhZGF0YX0gZnJvbSAnLi4vcHJveHktbWVzc2FnZXMnO1xuaW1wb3J0IHtjcmVhdGVTZXNzaW9uLCBjb3B5RnJvbUV4dGVybmFsQnVmZmVyLCBlbmRQcm9maWxpbmcsIGV4dHJhY3RUcmFuc2ZlcmFibGVCdWZmZXJzLCBpbml0RXAsIGluaXRSdW50aW1lLCByZWxlYXNlU2Vzc2lvbiwgcnVufSBmcm9tICcuLi93YXNtLWNvcmUtaW1wbCc7XG5pbXBvcnQge2luaXRpYWxpemVXZWJBc3NlbWJseX0gZnJvbSAnLi4vd2FzbS1mYWN0b3J5Jztcblxuc2VsZi5vbm1lc3NhZ2UgPSAoZXY6IE1lc3NhZ2VFdmVudDxPcnRXYXNtTWVzc2FnZT4pOiB2b2lkID0+IHtcbiAgY29uc3Qge3R5cGUsIGluIDogbWVzc2FnZX0gPSBldi5kYXRhO1xuICB0cnkge1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSAnaW5pdC13YXNtJzpcbiAgICAgICAgaW5pdGlhbGl6ZVdlYkFzc2VtYmx5KG1lc3NhZ2UhLndhc20pXG4gICAgICAgICAgICAudGhlbihcbiAgICAgICAgICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICBpbml0UnVudGltZShtZXNzYWdlISkudGhlbihcbiAgICAgICAgICAgICAgICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3N0TWVzc2FnZSh7dHlwZX0pO1xuICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgZXJyID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc3RNZXNzYWdlKHt0eXBlLCBlcnJ9KTtcbiAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGVyciA9PiB7XG4gICAgICAgICAgICAgICAgICBwb3N0TWVzc2FnZSh7dHlwZSwgZXJyfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnaW5pdC1lcCc6IHtcbiAgICAgICAgY29uc3Qge2VwTmFtZSwgZW52fSA9IG1lc3NhZ2UhO1xuICAgICAgICBpbml0RXAoZW52LCBlcE5hbWUpXG4gICAgICAgICAgICAudGhlbihcbiAgICAgICAgICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICBwb3N0TWVzc2FnZSh7dHlwZX0pO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZXJyID0+IHtcbiAgICAgICAgICAgICAgICAgIHBvc3RNZXNzYWdlKHt0eXBlLCBlcnJ9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlICdjb3B5LWZyb20nOiB7XG4gICAgICAgIGNvbnN0IHtidWZmZXJ9ID0gbWVzc2FnZSE7XG4gICAgICAgIGNvbnN0IGJ1ZmZlckRhdGEgPSBjb3B5RnJvbUV4dGVybmFsQnVmZmVyKGJ1ZmZlcik7XG4gICAgICAgIHBvc3RNZXNzYWdlKHt0eXBlLCBvdXQ6IGJ1ZmZlckRhdGF9IGFzIE9ydFdhc21NZXNzYWdlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlICdjcmVhdGUnOiB7XG4gICAgICAgIGNvbnN0IHttb2RlbCwgb3B0aW9uc30gPSBtZXNzYWdlITtcbiAgICAgICAgY3JlYXRlU2Vzc2lvbihtb2RlbCwgb3B0aW9ucylcbiAgICAgICAgICAgIC50aGVuKFxuICAgICAgICAgICAgICAgIHNlc3Npb25NZXRhZGF0YSA9PiB7XG4gICAgICAgICAgICAgICAgICBwb3N0TWVzc2FnZSh7dHlwZSwgb3V0OiBzZXNzaW9uTWV0YWRhdGF9IGFzIE9ydFdhc21NZXNzYWdlKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGVyciA9PiB7XG4gICAgICAgICAgICAgICAgICBwb3N0TWVzc2FnZSh7dHlwZSwgZXJyfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSAncmVsZWFzZSc6XG4gICAgICAgIHJlbGVhc2VTZXNzaW9uKG1lc3NhZ2UhKTtcbiAgICAgICAgcG9zdE1lc3NhZ2Uoe3R5cGV9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdydW4nOiB7XG4gICAgICAgIGNvbnN0IHtzZXNzaW9uSWQsIGlucHV0SW5kaWNlcywgaW5wdXRzLCBvdXRwdXRJbmRpY2VzLCBvcHRpb25zfSA9IG1lc3NhZ2UhO1xuICAgICAgICBydW4oc2Vzc2lvbklkLCBpbnB1dEluZGljZXMsIGlucHV0cywgb3V0cHV0SW5kaWNlcywgbmV3IEFycmF5KG91dHB1dEluZGljZXMubGVuZ3RoKS5maWxsKG51bGwpLCBvcHRpb25zKVxuICAgICAgICAgICAgLnRoZW4oXG4gICAgICAgICAgICAgICAgb3V0cHV0cyA9PiB7XG4gICAgICAgICAgICAgICAgICBpZiAob3V0cHV0cy5zb21lKG8gPT4gb1szXSAhPT0gJ2NwdScpKSB7XG4gICAgICAgICAgICAgICAgICAgIHBvc3RNZXNzYWdlKHt0eXBlLCBlcnI6ICdQcm94eSBkb2VzIG5vdCBzdXBwb3J0IG5vbi1jcHUgdGVuc29yIGxvY2F0aW9uLid9KTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHBvc3RNZXNzYWdlKFxuICAgICAgICAgICAgICAgICAgICAgICAge3R5cGUsIG91dDogb3V0cHV0c30gYXMgT3J0V2FzbU1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBleHRyYWN0VHJhbnNmZXJhYmxlQnVmZmVycyhvdXRwdXRzIGFzIFNlcmlhbGl6YWJsZVRlbnNvck1ldGFkYXRhW10pKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGVyciA9PiB7XG4gICAgICAgICAgICAgICAgICBwb3N0TWVzc2FnZSh7dHlwZSwgZXJyfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSAnZW5kLXByb2ZpbGluZyc6XG4gICAgICAgIGVuZFByb2ZpbGluZyhtZXNzYWdlISk7XG4gICAgICAgIHBvc3RNZXNzYWdlKHt0eXBlfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHBvc3RNZXNzYWdlKHt0eXBlLCBlcnJ9IGFzIE9ydFdhc21NZXNzYWdlKTtcbiAgfVxufTtcbiJdLAogICJtYXBwaW5ncyI6ICI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFBYSxVQUFrQyxjQUFzQztBQUFyRjtBQUFBO0FBQU8sTUFBTSxXQUFXO0FBQWlCLE1BQU0sZUFBZTtBQUFpQixNQUFNLG1CQUFtQjtBQUFBO0FBQUE7OztBQ0F4RztBQUFBO0FBQUEsZ0JBQUFBO0FBQUE7QUFBQSxNQUFhQTtBQUFiO0FBQUE7QUFBTyxNQUFNQSxRQUFPO0FBQUE7QUFBQTs7O0FDQXBCO0FBQUE7QUFBQTtBQUNBLFVBQUksV0FBVyxNQUFNO0FBQ25CLFlBQUksYUFBYSxPQUFPLGFBQWEsZUFBZSxTQUFTLGdCQUFnQixTQUFTLGNBQWMsTUFBTTtBQUMxRyxZQUFJLE9BQU8sZUFBZTtBQUFhLHVCQUFhLGNBQWM7QUFDbEUsZUFD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LFFBQU8sR0FBRSxNQUFNO0FBQUEsWUFBQztBQUFBLFlBQUUsUUFBTyxPQUFHO0FBQUMsZ0JBQUUsR0FBRyxPQUFNLEdBQUUsTUFBTTtBQUFBLFlBQUM7QUFBQSxZQUFFLFFBQU8sT0FBRztBQUFDLGdCQUFFLEdBQUcsT0FBTSxHQUFFLE1BQU07QUFBQSxZQUFDO0FBQUEsWUFBRSxRQUFPLE9BQUc7QUFBQyxnQkFBRSxHQUFHLFdBQVUsR0FBRSxNQUFNO0FBQUEsWUFBQztBQUFBLFlBQUUsUUFBTyxPQUFHO0FBQUMsZ0JBQUUsR0FBRyxPQUFNLEdBQUUsTUFBTTtBQUFBLFlBQUM7QUFBQSxZQUFFLFFBQU8sT0FBRztBQUFDLGdCQUFFLEdBQUcsT0FBTSxHQUFFLE1BQU07QUFBQSxZQUFDO0FBQUEsWUFBRSxRQUFPLE9BQUc7QUFBQyxnQkFBRSxHQUFHLE9BQU0sR0FBRSxNQUFNO0FBQUEsWUFBQztBQUFBLFlBQUUsUUFBTyxPQUFHO0FBQUMsZ0JBQUUsR0FBRyxPQUFNLEdBQUUsTUFBTTtBQUFBLFlBQUM7QUFBQSxZQUFFLFFBQU8sT0FBRztBQUFDLGdCQUFFLEdBQUcsUUFBTyxHQUFFLE1BQU07QUFBQSxZQUFDO0FBQUEsWUFBRSxRQUFPLE9BQUc7QUFBQyxnQkFBRSxHQUFHLFFBQU8sR0FBRSxNQUFNO0FBQUEsWUFBQztBQUFBLFlBQUUsUUFBTyxPQUFHO0FBQUMsZ0JBQUUsR0FBRyxRQUFPLEdBQUUsTUFBTTtBQUFBLFlBQUM7QUFBQSxZQUFFLFFBQU8sT0FBRztBQUFDLGdCQUFFLEdBQUcsUUFBTyxHQUFFLE1BQU07QUFBQSxZQUFDO0FBQUEsWUFBRSxRQUFPLE9BQUc7QUFBQyxnQkFBRSxHQUFHLFFBQU8sR0FBRSxNQUFNO0FBQUEsWUFBQztBQUFBLFlBQUUsUUFBTyxPQUFHO0FBQUMsZ0JBQUUsR0FBRyxTQUFRLEdBQUUsTUFBTTtBQUFBLFlBQUM7QUFBQSxZQUN0ZixRQUFPLE9BQUc7QUFBQyxnQkFBRSxHQUFHLFNBQVEsR0FBRSxNQUFNO0FBQUEsWUFBQztBQUFBLFlBQUUsUUFBTyxPQUFH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QUM7QUFBQSxZQUFDO0FBQUEsWUFBRSxRQUFPLENBQUMsR0FBRSxHQUFFLEdBQUUsR0FBRSxHQUFFLEdBQUUsR0FBRSxHQUFFLEdBQUUsR0FBRSxHQUFFLEdBQUUsR0FBRSxHQUFFLE1BQUk7QUFBQyxnQkFBRSxHQUFHLGlCQUFnQixHQUFFLEVBQUMsUUFBTyxJQUFFLFNBQU8sUUFBTyxTQUFRLEdBQUUsV0FBVSxDQUFDLENBQUMsR0FBRSxPQUFNLEdBQUUsY0FBYSxDQUFDLENBQUMsR0FBRSxNQUFLLENBQUMsR0FBRSxDQUFDLEdBQUUsU0FBUSxDQUFDLENBQUMsR0FBRSxVQUFTLE1BQUksQ0FBQyxDQUFDLEVBQUUsTUFBSSxDQUFDLEdBQUUsZUFBYyxJQUFFLE1BQU0sS0FBSyxFQUFFLFNBQVMsTUFBSSxHQUFFLE1BQUksQ0FBQyxDQUFDLElBQUUsQ0FBQyxHQUFFLGFBQVksSUFBRSxNQUFNLEtBQUssRUFBRSxTQUFTLE1BQUksR0FBRSxNQUFJLENBQUMsQ0FBQyxJQUFFLENBQUMsR0FBRSxZQUFXLEVBQUUsQ0FBQyxFQUFDLENBQUM7QUFBQSxZQUFDO0FBQUEsWUFBRSxRQUFPLENBQUMsR0FBRSxHQUFFLEdBQUUsR0FBRSxHQUFFLEdBQUUsR0FBRSxHQUFFLEdBQUUsR0FBRSxHQUFFLEdBQUUsR0FBRSxNQUFJO0FBQUMsZ0JBQUU7QUFBQSxnQkFBRztBQUFBLGdCQUM1ZTtBQUFBLGdCQUFFLEVBQUMsUUFBTyxJQUFFLFNBQU8sUUFBTyxTQUFRLEdBQUUsV0FBVSxNQUFNLEtBQUssRUFBRSxTQUFTLE1BQUksSUFBRyxNQUFJLEtBQUcsTUFBSSxDQUFDLENBQUMsR0FBRSxPQUFNLEdBQUUsYUFBWSxNQUFNLEtBQUssRUFBRSxTQUFTLE1BQUksSUFBRyxNQUFJLEtBQUcsTUFBSSxDQUFDLENBQUMsR0FBRSxNQUFLLE1BQU0sS0FBSyxFQUFFLFNBQVMsTUFBSSxJQUFHLE1BQUksS0FBRyxNQUFJLENBQUMsQ0FBQyxHQUFFLFNBQVEsTUFBTSxLQUFLLEVBQUUsU0FBUyxNQUFJLElBQUcsTUFBSSxLQUFH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QUUsR0FBRyxHQUFFLEVBQUUsQ0FBQyxDQUFDO0FBQUUsZ0JBQUksSUFBRSwyREFBMkQsTUFBTSxHQUFHLEdBQUUsSUFBRSx3RkFBd0YsTUFBTSxHQUFHO0FBQUUsZ0JBQUUsRUFBQyxNQUFLLE9BQUcsRUFBRSxFQUFFLEVBQUUsRUFBRSxVQUFVLEdBQUUsQ0FBQyxHQUFFLE1BQUssT0FBRyxFQUFFLEVBQUUsRUFBRSxHQUFFLE1BQUssT0FDemYsRUFBRSxFQUFFLEVBQUUsRUFBRSxVQUFVLEdBQUUsQ0FBQyxHQUFFLE1BQUssT0FBRyxFQUFFLEVBQUUsRUFBRSxHQUFFLE1BQUssT0FBRyxHQUFHLEVBQUUsS0FBRyxRQUFNLE1BQUksR0FBRSxDQUFDLEdBQUUsTUFBSyxPQUFHLEVBQUUsRUFBRSxJQUFHLENBQUMsR0FBRSxNQUFLLE9BQUcsRUFBRSxFQUFFLElBQUcsR0FBRSxHQUFHLEdBQUUsTUFBSyxPQUFHLEVBQUUsQ0FBQyxFQUFFLFNBQVMsRUFBRSxVQUFVLENBQUMsR0FBRSxNQUFLLE9BQUcsRUFBRSxDQUFDLEdBQUUsTUFBSyxPQUFHLEVBQUUsRUFBRSxJQUFHLENBQUMsR0FBRSxNQUFLLE9BQUc7QUFBQyxrQkFBRSxFQUFFO0FBQUcsbUJBQUcsSUFBRSxJQUFFLEtBQUcsS0FBRyxNQUFJLEtBQUc7QUFBSSxxQkFBTyxFQUFFLEdBQUUsQ0FBQztBQUFBLFlBQUMsR0FBRSxNQUFLLE9BQUc7QUFBQyx1QkFBUSxJQUFFLEdBQUUsSUFBRSxHQUFFLEtBQUcsRUFBRSxLQUFHLEdBQUUsTUFBSSxFQUFFLEVBQUUsS0FBRyxJQUFJLElBQUUsS0FBRyxJQUFJLEdBQUc7QUFBRTtBQUFDLHFCQUFPLEVBQUUsRUFBRSxLQUFHLEdBQUUsQ0FBQztBQUFBLFlBQUMsR0FBRSxNQUFLLE9BQUcsRUFBRSxFQUFFLEtBQUcsR0FBRSxDQUFDLEdBQUUsTUFBSyxPQUFHLEVBQUUsRUFBRSxJQUFHLENBQUMsR0FBRSxNQUFLLE1BQUksTUFBSyxNQUFLLE9BQUcsS0FBRyxFQUFFLE1BQUksS0FBRyxFQUFFLEtBQUcs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QUFJLE1BQUksQ0FBQyxJQUFFLEtBQUcsS0FBSyxJQUFJLEdBQUUsQ0FBQztBQUFFLGNBQUUsTUFDdGYsTUFBSSxNQUFJLENBQUMsSUFBRSxPQUFPLEtBQUcsQ0FBQztBQUFFLGdCQUFFLEVBQUUsQ0FBQztBQUFFLGdCQUFFLEVBQUUsQ0FBQztBQUFFLGdCQUFFLEdBQUcsQ0FBQztBQUFFLGdCQUFFLEdBQUcsQ0FBQztBQUFFLGdCQUFFLEtBQUcsRUFBRSxNQUFJLE1BQUksQ0FBQyxJQUFFLEdBQUUsRUFBRSxJQUFFLE1BQUksTUFBSSxDQUFDLElBQUUsTUFBSSxFQUFFLE1BQUksTUFBSSxDQUFDLElBQUUsR0FBRSxFQUFFLElBQUUsTUFBSSxNQUFJLENBQUMsSUFBRTtBQUFBLFVBQUUsR0FBRSxHQUFFLE1BQUk7QUFBQyxjQUFFLEVBQUU7QUFBQSxVQUFDLEdBQUUsR0FBRSxTQUFTLEdBQUUsR0FBRSxHQUFFO0FBQUMsbUJBQUs7QUFBRSxnQkFBRSxHQUFHLE1BQUksR0FBRSxNQUFJLENBQUM7QUFBRSxtQkFBTyxHQUFHLENBQUMsRUFBRSxNQUFNLE1BQUssQ0FBQztBQUFBLFVBQUMsR0FBRSxHQUFFLFNBQVMsR0FBRSxHQUFFLEdBQUU7QUFBQyxtQkFBSztBQUFFLGdCQUFFLEdBQUcsTUFBSSxHQUFFLE1BQUksQ0FBQztBQUFFLG1CQUFPLEdBQUcsQ0FBQyxFQUFFLE1BQU0sTUFBSyxDQUFDO0FBQUEsVUFBQyxHQUFFLEdBQUUsTUFBSSxLQUFLLElBQUksR0FBRSxHQUFFLFdBQVU7QUFBQyxtQkFBTztBQUFBLFVBQVUsR0FBRSxHQUFFLE1BQUksWUFBWSxJQUFJLEdBQUUsR0FBRSxTQUFTLEdBQUUsR0FBRSxHQUFFO0FBQUMsbUJBQUs7QUFBRSxtQkFBTyxFQUFFLFdBQVcsTUFBSSxNQUFJLEdBQUUsTUFBSSxHQUFFLEtBQUcsTUFBSSxPQUFLLENBQUM7QUFBQSxVQUFDLEdBQUUsR0FBRSxTQUFTLEdBQUU7QUFBQyxtQkFBSztBQUFFLGdCQUFJLElBQUUsRUFBRTtBQUFPLGdCQUFHLGFBQVc7QUFB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R0FBRSxNQUFNO0FBQUEsWUFBQztBQUFBLFlBQUUsUUFBTyxPQUFHO0FBQUMsZ0JBQUUsR0FBRyxRQUFPLEdBQUUsTUFBTTtBQUFBLFlBQUM7QUFBQSxZQUFFLFFBQU8sT0FBRztBQUFDLGdCQUFFLEdBQUcsT0FBTSxHQUFFLE1BQU07QUFBQSxZQUFDO0FBQUEsWUFBRSxRQUFPLE9BQUc7QUFBQyxnQkFBRSxHQUFHLE9BQU0sR0FBRSxNQUFNO0FBQUEsWUFBQztBQUFBLFlBQUUsUUFBTyxPQUFHO0FBQUMsZ0JBQUUsR0FBRyxXQUFVLEdBQUUsTUFBTTtBQUFBLFlBQUM7QUFBQSxZQUFFLFFBQU8sT0FBRztBQUFDLGdCQUFFLEdBQUcsT0FBTSxHQUFFLE1BQU07QUFBQSxZQUFDO0FBQUEsWUFBRSxRQUFPLE9BQUc7QUFBQyxnQkFBRSxHQUFHLE9BQU0sR0FBRSxNQUFNO0FBQUEsWUFBQztBQUFBLFlBQUUsUUFBTyxPQUFHO0FBQUMsZ0JBQUUsR0FBRyxPQUFNLEdBQUUsTUFBTTtBQUFBLFlBQUM7QUFBQSxZQUFFLFFBQU8sT0FBRztBQUFDLGdCQUFFLEdBQUcsT0FBTSxHQUFFLE1BQU07QUFBQSxZQUFDO0FBQUEsWUFBRSxRQUFPLE9BQUc7QUFBQyxnQkFBRSxHQUFHLFFBQU8sR0FBRSxNQUFNO0FBQUEsWUFBQztBQUFBLFlBQUUsUUFBTyxPQUFHO0FBQUMsZ0JBQUUsR0FBRyxRQUFPLEdBQUUsTUFBTTtBQUFBLFlBQUM7QUFBQSxZQUFFLFFBQU8sT0FBRztBQUFDLGdCQUFFLEdBQUcsUUFBTyxHQUFFLE1BQU07QUFBQSxZQUFDO0FBQUEsWUFBRSxRQUFPLE9BQUc7QUFBQyxnQkFBRSxHQUFHLFFBQU8sR0FBRSxNQUFNO0FBQUEsWUFBQztBQUFBLFlBQUUsUUFBTyxPQUFHO0FBQUMsZ0JBQUUsR0FBRyxRQUFPLEdBQUUsTUFBTTtBQUFBLFlBQUM7QUFBQSxZQUFFLFFBQU8sT0FBRztBQUFDLGdCQUFFLEdBQUcsU0FBUSxHQUFFLE1BQU07QUFBQSxZQUFDO0FBQUEsWUFDdGYsUUFBTyxPQUFHO0FBQUMsZ0JBQUUsR0FBRyxTQUFRLEdBQUUsTUFBTTtBQUFBLFlBQUM7QUFBQSxZQUFFLFFBQU8sT0FBRztBQUFDLGdCQUFFLEdBQUcsU0FBUSxHQUFFLE1BQU07QUFBQSxZQUFDO0FBQUEsWUFBRSxRQUFPLE9BQUc7QUFBQyxnQkFBRSxHQUFHLFFBQU8sR0FBRSxNQUFNO0FBQUEsWUFBQztBQUFBLFlBQUUsUUFBTyxPQUFHO0FBQUMsZ0JBQUUsR0FBRyxPQUFNLEdBQUUsTUFBTTtBQUFBLFlBQUM7QUFBQSxZQUFFLFFBQU8sQ0FBQyxHQUFFLEdBQUUsTUFBSTtBQUFDLGdCQUFFLEdBQUcsUUFBTyxHQUFFLEVBQUMsS0FBSSxHQUFFLEtBQUksRUFBQyxDQUFDO0FBQUEsWUFBQztBQUFBLFlBQUUsUUFBTyxPQUFHO0FBQUMsZ0JBQUUsR0FBRyxRQUFPLEdBQUUsTUFBTTtBQUFBLFlBQUM7QUFBQSxZQUFFLFFBQU8sQ0FBQyxHQUFFLE1BQUk7QUFBQyxnQkFBRSxHQUFHLE9BQU0sR0FBRSxFQUFDLE9BQU0sRUFBQyxDQUFDO0FBQUEsWUFBQztBQUFBLFlBQUUsUUFBTyxPQUFHO0FBQUMsZ0JBQUUsR0FBRyxRQUFPLEdBQUUsTUFBTTtBQUFBLFlBQUM7QUFBQSxZQUFFLFFBQU8sQ0FBQyxHQUFFLE1BQUk7QUFBQyxnQkFBRSxHQUFHLGFBQVksR0FBRSxFQUFDLE9BQU0sRUFBQyxDQUFDO0FBQUEsWUFBQztBQUFBLFlBQUUsUUFBTyxDQUFDLEdBQUUsTUFBSTtBQUFDLGdCQUFFLEdBQUcsbUJBQWtCLEdBQUUsRUFBQyxPQUFNLEVBQUMsQ0FBQztBQUFBLFlBQUM7QUFBQSxZQUFFLFFBQU8sQ0FBQyxHQUFFLE1BQUk7QUFBQyxnQkFBRSxHQUFHLFFBQU8sR0FBRSxFQUFDLElBQUcsRUFBQyxDQUFDO0FBQUEsWUFBQztBQUFBLFlBQUUsUUFBTyxPQUFHO0FBQUMsZ0JBQUUsR0FBRyxPQUFNLEdBQUUsTUFBTTtBQUFBLFlBQUM7QUFBQSxZQUFFLFFBQU8sT0FBRztBQUFDLGdCQUFFLEdBQUcsT0FBTSxHQUFFLE1BQU07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QU8sRUFBRSxHQUFFLEdBQUUsR0FBRSxHQUFFLENBQUM7QUFBQSxVQUFDO0FBQUMsbUJBQVMsR0FBRyxHQUFFLEdBQUUsR0FBRTtBQUFDLG1CQUFPLElBQUUsRUFBRSxHQUFFLEdBQUUsR0FBRSxHQUFFLENBQUMsSUFBRTtBQUFBLFVBQUM7QUFBQyxtQkFBUyxHQUFHLEdBQUUsR0FBRTtBQUFDLGdCQUFHO0FBQUUscUJBQU8sRUFBRSxHQUFFLEdBQUUsR0FBRSxDQUFDO0FBQUEsVUFBQztBQUFDLG1CQUFTLEdBQUcsR0FBRSxHQUFFLEdBQUU7QUFBQyxnQkFBRztBQUFFLHFCQUFPLEVBQUUsR0FBRSxHQUFFLEdBQUUsR0FBRSxDQUFDO0FBQUEsVUFBQztBQUFDLG1CQUFTLEdBQUcsR0FBRSxHQUFFLEdBQUUsR0FBRTtBQUFDLGdCQUFHO0FBQUUscUJBQU8sRUFBRSxJQUFHLEdBQUUsR0FBRSxHQUFFLEdBQUUsQ0FBQztBQUFBLFVBQUM7QUFBQyxtQkFBUyxHQUFHLEdBQUUsR0FBRSxHQUFFLEdBQUU7QUFBQyxnQkFBRztBQUFFLHFCQUFPLEVBQUUsSUFBRyxHQUFFLEdBQUUsR0FBRSxHQUFFLENBQUM7QUFBQSxVQUFDO0FBQUMsbUJBQVMsR0FBRyxHQUFFLEdBQUUsR0FBRSxHQUFFO0FBQUMsZ0JBQUc7QUFBRSxxQkFBTyxFQUFFLElBQUcsR0FBRSxHQUFFLEdBQUUsR0FBRSxDQUFDO0FBQUEsVUFBQztBQUM3ZCxtQkFBUyxHQUFHLEdBQUU7QUFBQyxnQkFBRztBQUFFLHFCQUFPLEVBQUUsSUFBRyxHQUFFLENBQUM7QUFBQSxVQUFDO0FBQUMsbUJBQVMsR0FBRyxHQUFFLEdBQUU7QUFBQyxnQkFBRztBQUFFLHFCQUFPLEVBQUUsSUFBRyxHQUFFLEdBQUUsQ0FBQztBQUFBLFVBQUM7QUFBQyxtQkFBUyxHQUFHLEdBQUUsR0FBRSxHQUFFO0FBQUMsZ0JBQUc7QUFBRSxxQkFBTyxFQUFFLElBQUcsR0FBRSxHQUFFLEdBQUUsQ0FBQztBQUFBLFVBQUM7QUFBQyxjQUFJLEtBQUcsTUFBSTtBQUFDLGdCQUFH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SSxLQUFLO0FBQUUsa0JBQUUsS0FBSyxHQUFHLENBQUMsSUFBSSxFQUFFLENBQUMsQ0FBQyxFQUFFO0FBQUUsbUJBQUc7QUFBQSxZQUFDO0FBQUMsbUJBQU87QUFBQSxVQUFFLEdBQUU7QUFBRyxtQkFBUyxHQUFHLEdBQUUsR0FBRTtBQUFDLGdCQUFHO0FBQUUscUJBQU8sRUFBRSxJQUFHLEdBQUUsR0FBRSxDQUFDO0FBQUUsbUJBQUs7QUFBRSxtQkFBSztBQUFFLGdCQUFJLElBQUU7QUFBRSxlQUFHLEVBQUUsUUFBUSxDQUFDLEdBQUUsTUFBSTtBQUFDLGtCQUFJLElBQUUsSUFBRTtBQUFFLGtCQUFFLEVBQUUsRUFBRSxJQUFFLElBQUUsTUFBSSxNQUFJLENBQUMsSUFBRTtBQUFFLG1CQUFJLElBQUUsR0FBRSxJQUFFLEVBQUUsUUFBTyxFQUFFO0FBQUUsa0JBQUUsRUFBRSxRQUFNLE1BQUksQ0FBQyxJQUFFLEVBQUUsV0FBVyxDQUFDO0FBQUUsZ0JBQUUsRUFBRSxNQUFJLE1BQUksQ0FBQyxJQUFFO0FBQUUsbUJBQUcsRUFBRSxTQUFPO0FBQUEsWUFBQyxDQUFDO0FBQUUsbUJBQU87QUFBQSxVQUFDO0FBQUMsbUJBQVMsR0FBRyxHQUFFLEdBQUU7QUFBQyxnQkFBRztBQUFFLHFCQUFPLEVBQUUsSUFBRyxHQUFFLEdBQUUsQ0FBQztBQUFFLG1CQUFLO0FBQUUsbUJBQUs7QUFBRSxnQkFBSSxJQUFFLEdBQUc7QUFBRSxjQUFFLEVBQUUsTUFBSSxNQUFJLENBQUMsSUFBRSxFQUFFO0FBQU8sZ0JBQUksSUFBRTtBQUFFLGNBQUUsUUFBUSxPQUFHLEtBQUcsRUFBRSxTQUFPLENBQUM7QUFBRSxjQUFFLEVBQUUsTUFBSSxNQUFJLENBQUMsSUFBRTtBQUFFLG1CQUFPO0FBQUEsVUFBQztBQUFDLG1CQUFTLEdBQUcsR0FBRTtBQUFDLG1CQUFPLElBQUUsRUFBRSxJQUFHLEdBQUUsQ0FBQyxJQUFFO0FBQUEsVUFBRTtBQUN4ZSxtQkFBUyxHQUFHLEdBQUUsR0FBRSxHQUFFLEdBQUU7QUFBQyxtQkFBTyxJQUFFLEVBQUUsSUFBRyxHQUFFLEdBQUUsR0FBRSxHQUFFLENBQUMsSUFBRTtBQUFBLFVBQUU7QUFBQyxtQkFBUyxHQUFHLEdBQUUsR0FBRSxHQUFFLEdBQUUsR0FBRTtBQUFDLG1CQUFPLElBQUUsRUFBRSxJQUFHLEdBQUUsR0FBRSxHQUFFLEdBQUUsR0FBRSxDQUFDLElBQUU7QUFBQSxVQUFFO0FBQUMsY0FBSSxLQUFHLENBQUMsTUFBSyxDQUFDLEdBQUUsQ0FBQyxDQUFDO0FBQUUsbUJBQVMsR0FBRyxHQUFFLEdBQUUsR0FBRSxHQUFFO0FBQUMsZ0JBQUc7QUFBRSxxQkFBTyxFQUFFLElBQUcsR0FBRSxHQUFFLEdBQUUsR0FBRSxDQUFDO0FBQUUsbUJBQUs7QUFBRSxtQkFBSztBQUFFLG1CQUFLO0FBQUUscUJBQVEsSUFBRSxHQUFFLElBQUUsR0FBRSxJQUFFLEdBQUUsS0FBSTtBQUFDLGtCQUFJLElBQUUsRUFBRSxFQUFFLE1BQUksTUFBSSxDQUFDLEdBQUUsSUFBRSxFQUFFLEVBQUUsSUFBRSxNQUFJLE1BQUksQ0FBQztBQUFFLG1CQUFHO0FBQUUsdUJBQVEsSUFBRSxHQUFFLElBQUUsR0FBRSxLQUFJO0FBQUMsb0JBQUksSUFBRSxFQUFFLEVBQUUsSUFBRSxNQUFJLENBQUMsR0FBRSxJQUFFLEdBQUcsQ0FBQztBQUFFLHNCQUFJLEtBQUcsT0FBSyxNQUFJLE1BQUksSUFBRSxLQUFHLEdBQUcsR0FBRyxHQUFFLENBQUMsQ0FBQyxHQUFFLEVBQUUsU0FBTyxLQUFHLEVBQUUsS0FBSyxDQUFDO0FBQUEsY0FBQztBQUFDLG1CQUFHO0FBQUEsWUFBQztBQUFDLGNBQUUsRUFBRSxNQUFJLE1BQUksQ0FBQyxJQUFFO0FBQUUsbUJBQU87QUFBQSxVQUFDO0FBQUMsY0FBSSxLQUFHLENBQUMsSUFBRyxJQUFHLElBQUcsSUFBRyxJQUFHLElBQUcsSUFBRyxJQUFHLElBQUcsSUFBRyxJQUFHLEVBQUUsR0FBRSxLQUFHLENBQUMsSUFBRyxJQUFHLElBQUcsSUFBRyxJQUFHLElBQUcsSUFBRyxJQUFHLElBQUcsSUFB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QUssT0FBTTtBQUFBLGNBQVcsT0FBTTtBQUFBLGNBQVcsT0FBTTtBQUFBLGNBQUssT0FBTTtBQUFBLGNBQUssT0FBTTtBQUFBLGNBQUssT0FBTTtBQUFBLGNBQUssT0FBTTtBQUFBLGNBQUssT0FBTTtBQUFBLGNBQUssT0FBTTtBQUFBLGNBQUssT0FBTTtBQUFBLGNBQUssT0FBTTtBQUFBLGNBQUssT0FBTTtBQUFBLGNBQUssT0FBTTtBQUFBLGNBQUssT0FBTTtBQUFBLGNBQUssT0FBTTtBQUFBLGNBQUssT0FBTTtBQUFBLGNBQUssT0FBTTtBQUFBLFlBQUk7QUFBRSxxQkFBUSxLQUFLO0FBQUUsa0JBQUUsRUFBRSxRQUFRLElBQUksT0FBTyxHQUFFLEdBQUcsR0FBRSxFQUFFLENBQUMsQ0FBQztBQUFFLGdCQUFJLElBQUUsMkRBQTJELE1BQU0sR0FBRyxHQUFFLElBQUUsd0ZBQXdGLE1BQU0sR0FBRztBQUFFLGdCQUFFLEVBQUMsTUFBSyxPQUFHLEVBQUUsRUFBRSxFQUFFLEVBQUUsVUFBVSxHQUFFLENBQUMsR0FBRSxNQUFLLE9BQ3pmLEVBQUUsRUFBRSxFQUFFLEdBQUUsTUFBSyxPQUFHLEVBQUUsRUFBRSxFQUFFLEVBQUUsVUFBVSxHQUFFLENBQUMsR0FBRSxNQUFLLE9BQUcsRUFBRSxFQUFFLEVBQUUsR0FBRSxNQUFLLE9BQUcsR0FBRyxFQUFFLEtBQUcsUUFBTSxNQUFJLEdBQUUsQ0FBQyxHQUFFLE1BQUssT0FBRyxFQUFFLEVBQUUsSUFBRyxDQUFDLEdBQUUsTUFBSyxPQUFHLEVBQUUsRUFBRSxJQUFHLEdBQUUsR0FBRyxHQUFFLE1BQUssT0FBRyxFQUFFLENBQUMsRUFBRSxTQUFTLEVBQUUsVUFBVSxDQUFDLEdBQUUsTUFBSyxPQUFHLEVBQUUsQ0FBQyxHQUFFLE1BQUssT0FBRyxFQUFFLEVBQUUsSUFBRyxDQUFDLEdBQUUsTUFBSyxPQUFHO0FBQUMsa0JBQUUsRUFBRTtBQUFHLG1CQUFHLElBQUUsSUFBRSxLQUFHLEtBQUcsTUFBSSxLQUFHO0FBQUkscUJBQU8sRUFBRSxHQUFFLENBQUM7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QUFTLEdBQUcsR0FBRTtBQUFDLG1CQUFPLEdBQUcsT0FBRztBQUFDLGdCQUFFLEVBQUUsS0FBSyxDQUFDO0FBQUEsWUFBQyxDQUFDO0FBQUEsVUFBQztBQUFDLFlBQUUsR0FBRztBQUNoRCxjQUFJLEtBQUcsQ0FBQyxJQUFHLElBQUcsSUFBRyxJQUFHLElBQUcsSUFBRyxJQUFHLElBQUcsSUFBRyxJQUFHLElBQUcsSUFBRyxJQUFHLElBQUcsSUFBRyxJQUFHLElBQUcsSUFBRyxJQUFHLElBQUcsSUFBRyxJQUFHLElBQUcsRUFBRSxHQUFFLEtBQUcsRUFBQyxHQUFFLFNBQVMsR0FBRSxHQUFFLEdBQUU7QUFBQyxtQkFBTyxHQUFHLFlBQVM7QUFBQyxvQkFBTSxFQUFFLEdBQUcsR0FBRSxHQUFFLENBQUM7QUFBQSxZQUFDLENBQUM7QUFBQSxVQUFDLEdBQUUsR0FBRSxTQUFTLEdBQUUsR0FBRSxHQUFFO0FBQUMsbUJBQUs7QUFBRSxZQUFDLElBQUksR0FBRyxDQUFDLEVBQUcsR0FBRyxNQUFJLEdBQUUsTUFBSSxDQUFDO0FBQUUsaUJBQUc7QUFBRTtBQUFLLGtCQUFNO0FBQUEsVUFBRyxHQUFFLEdBQUUsU0FBUyxHQUFFO0FBQUMsZUFBRyxNQUFJLEdBQUUsQ0FBQyxHQUFFLEdBQUUsQ0FBQyxJQUFHLFFBQU8sS0FBRTtBQUFFLGNBQUUsR0FBRztBQUFBLFVBQUMsR0FBRSxHQUFFLFNBQVMsR0FBRTtBQUFDLG1CQUFLO0FBQUUsZ0JBQUUsWUFBWSxFQUFDLEtBQUksaUJBQWdCLFFBQU8sRUFBQyxDQUFDLElBQUUsRUFBRSxHQUFHLEVBQUUsR0FBRyxDQUFDLENBQUM7QUFBQSxVQUFDLEdBQUUsR0FBRSxJQUFHLEdBQUUsSUFBRyxHQUFFLElBQUcsR0FBRSxJQUFHLEdBQUUsSUFBRyxHQUFFLElBQUcsR0FBRSxJQUFHLEdBQUUsSUFBRyxHQUFFLElBQUcsR0FBRSxJQUFHLEdBQUUsSUFBRyxHQUFFLElBQUcsR0FBRSxJQUFHLEdBQUUsSUFBRyxHQUFFLE1BQUksR0FBRSxHQUFFLFNBQVMsR0FBRSxHQUFFO0FBQUMsbUJBQUs7QUFBRSxpQkFBRyxNQUFJLElBQUUsV0FBVyxNQUFJLEdBQUcsQ0FBQyxJQUFFLElBQUUsWUFBWTtBQUFBLGNBQUMsY0FBYTtBQUFBLGNBQzlmLEtBQUk7QUFBQSxZQUFjLENBQUMsS0FBRyxJQUFFLEVBQUUsR0FBRyxDQUFDLE1BQUksRUFBRSxZQUFZLEVBQUMsS0FBSSxlQUFjLENBQUM7QUFBQSxVQUFDLEdBQUUsR0FBRSxTQUFTLEdBQUUsR0FBRSxHQUFFLEdBQUU7QUFBQyxtQkFBSztBQUFFLGVBQUcsU0FBTztBQUFFLGdCQUFFLE1BQUksTUFBSTtBQUFFLHFCQUFRLElBQUUsR0FBRSxJQUFFLEdBQUU7QUFBSSxpQkFBRyxDQUFDLElBQUUsR0FBRyxFQUFFLElBQUUsTUFBSSxDQUFDO0FBQUUsZ0JBQUUsSUFBRSxJQUFFLEdBQUcsQ0FBQyxJQUFFLENBQUMsSUFBRSxHQUFHLENBQUM7QUFBRSxjQUFFLEtBQUc7QUFBRSxnQkFBRSxFQUFFLE1BQU0sTUFBSyxFQUFFO0FBQUUsY0FBRSxLQUFHO0FBQUUsbUJBQU87QUFBQSxVQUFDLEdBQUUsR0FBRSxJQUFHLEdBQUUsU0FBUyxHQUFFO0FBQUMsaUJBQUcsRUFBRSxHQUFHLE1BQUksQ0FBQyxFQUFFLElBQUk7QUFBQSxVQUFDLEdBQUUsR0FBRSxTQUFTLEdBQUUsR0FBRSxHQUFFO0FBQUMsZ0JBQUUsSUFBRSxZQUFVLElBQUUsVUFBUSxDQUFDLENBQUMsS0FBRyxNQUFJLEtBQUcsYUFBVyxJQUFFO0FBQUksbUJBQUs7QUFBRSxnQkFBRSxJQUFJLEtBQUssTUFBSSxDQUFDO0FBQUUsY0FBRSxFQUFFLE1BQUksTUFBSSxDQUFDLElBQUUsRUFBRSxjQUFjO0FBQUUsY0FBRSxFQUFFLElBQUUsTUFBSSxNQUFJLENBQUMsSUFBRSxFQUFFLGNBQWM7QUFBRSxjQUFFLEVBQUUsSUFBRSxNQUFJLE1BQUksQ0FBQyxJQUFFLEVBQUUsWUFBWTtBQUFFLGNBQUUsRUFBRSxJQUFFLE9BQUssTUFBSSxDQUFDLElBQUUsRUFBRSxXQUFXO0FBQUUsY0FBRSxFQUFFLElBQ3JmLE9BQUssTUFBSSxDQUFDLElBQUUsRUFBRSxZQUFZO0FBQUUsY0FBRSxFQUFFLElBQUUsT0FBSyxNQUFJLENBQUMsSUFBRSxFQUFFLGVBQWUsSUFBRTtBQUFLLGNBQUUsRUFBRSxJQUFFLE9BQUssTUFBSSxDQUFDLElBQUUsRUFBRSxVQUFVO0FBQUUsaUJBQUcsRUFBRSxRQUFRLElBQUUsS0FBSyxJQUFJLEVBQUUsZUFBZSxHQUFFLEdBQUUsR0FBRSxHQUFFLEdBQUUsR0FBRSxDQUFDLEtBQUcsUUFBTTtBQUFFLGNBQUUsRUFBRSxJQUFFLE9BQUssTUFBSSxDQUFDLElBQUU7QUFBQSxVQUFDLEdBQUUsR0FBRSxTQUFTLEdBQUUsR0FBRSxHQUFFO0FBQUMsZ0JBQUUsSUFBRSxZQUFVLElBQUUsVUFBUSxDQUFDLENBQUMsS0FBRyxNQUFJLEtBQUcsYUFBVyxJQUFFO0FBQUksbUJBQUs7QUFBRSxnQkFBRSxJQUFJLEtBQUssTUFBSSxDQUFDO0FBQUUsY0FBRSxFQUFFLE1BQUksTUFBSSxDQUFDLElBQUUsRUFBRSxXQUFXO0FBQUUsY0FBRSxFQUFFLElBQUUsTUFBSSxNQUFJLENBQUMsSUFBRSxFQUFFLFdBQVc7QUFBRSxjQUFFLEVBQUUsSUFBRSxNQUFJLE1BQUksQ0FBQyxJQUFFLEVBQUUsU0FBUztBQUFFLGNBQUUsRUFBRSxJQUFFLE9BQUssTUFBSSxDQUFDLElBQUUsRUFBRSxRQUFRO0FBQUUsY0FBRSxFQUFFLElBQUUsT0FBSyxNQUFJLENBQUMsSUFBRSxFQUFFLFNBQVM7QUFBRSxjQUFFLEVBQUUsSUFBRSxPQUFLLE1BQUksQ0FBQyxJQUFFLEVBQUUsWUFBWSxJQUFFO0FBQUssY0FBRSxFQUFFLElBQUUsT0FBSyxNQUFJLENBQUMsSUFBRSxFQUFFLE9BQU87QUFDdmYsaUJBQUcsRUFBRSxFQUFFLFlBQVksQ0FBQyxJQUFFLEtBQUcsSUFBSSxFQUFFLFNBQVMsQ0FBQyxJQUFFLEVBQUUsUUFBUSxJQUFFLElBQUU7QUFBRSxjQUFFLEVBQUUsSUFBRSxPQUFLLE1BQUksQ0FBQyxJQUFFO0FBQUUsY0FBRSxFQUFFLElBQUUsT0FBSyxNQUFJLENBQUMsSUFBRSxFQUFFLEtBQUcsRUFBRSxrQkFBa0I7QUFBRyxnQkFBRyxJQUFJLEtBQUssRUFBRSxZQUFZLEdBQUUsR0FBRSxDQUFDLEVBQUcsa0JBQWtCO0FBQUUsZ0JBQUksSUFBRyxJQUFJLEtBQUssRUFBRSxZQUFZLEdBQUUsR0FBRSxDQUFDLEVBQUcsa0JBQWtCO0FBQUUsaUJBQUcsS0FBRyxLQUFHLEVBQUUsa0JBQWtCLEtBQUcsS0FBSyxJQUFJLEdBQUUsQ0FBQyxLQUFHO0FBQUUsY0FBRSxFQUFFLElBQUUsT0FBSyxNQUFJLENBQUMsSUFBRTtBQUFBLFVBQUMsR0FBRSxHQUFFLFNBQVMsR0FBRTtBQUFDLG1CQUFLO0FBQUUsZ0JBQUksSUFBRSxJQUFJLEtBQUssRUFBRSxFQUFFLElBQUUsT0FBSyxNQUFJLENBQUMsSUFBRSxNQUFLLEVBQUUsRUFBRSxJQUFFLE9BQUssTUFBSSxDQUFDLEdBQUUsRUFBRSxFQUFFLElBQUUsT0FBSyxNQUFJLENBQUMsR0FBRSxFQUFFLEVBQUUsSUFBRSxNQUFJLE1BQUksQ0FBQyxHQUFFLEVBQUUsRUFBRSxJQUFFLE1BQUksTUFBSSxDQUFDLEdBQUUsRUFBRSxFQUFFLE1BQUksTUFBSSxDQUFDLEdBQUUsQ0FBQyxHQUFFLElBQUUsRUFBRSxFQUFFLElBQUUsT0FBSyxNQUFJLENBQUMsR0FBRSxJQUFFLEVBQUUsa0JBQWtCLEdBQUUsSUFBRyxJQUFJO0FBQUEsY0FBSyxFQUFFLFlBQVk7QUFBQSxjQUM1Z0I7QUFBQSxjQUFFO0FBQUEsWUFBQyxFQUFHLGtCQUFrQixHQUFFLElBQUcsSUFBSSxLQUFLLEVBQUUsWUFBWSxHQUFFLEdBQUUsQ0FBQyxFQUFHLGtCQUFrQixHQUFFLElBQUUsS0FBSyxJQUFJLEdBQUUsQ0FBQztBQUFFLGdCQUFFLElBQUUsRUFBRSxFQUFFLElBQUUsT0FBSyxNQUFJLENBQUMsSUFBRSxPQUFPLEtBQUcsS0FBRyxLQUFHLENBQUMsSUFBRSxJQUFFLE1BQUksS0FBRyxPQUFLLElBQUUsS0FBSyxJQUFJLEdBQUUsQ0FBQyxHQUFFLEVBQUUsUUFBUSxFQUFFLFFBQVEsSUFBRSxRQUFNLElBQUUsSUFBRSxJQUFFLEtBQUcsRUFBRTtBQUFHLGNBQUUsRUFBRSxJQUFFLE9BQUssTUFBSSxDQUFDLElBQUUsRUFBRSxPQUFPO0FBQUUsaUJBQUcsRUFBRSxFQUFFLFlBQVksQ0FBQyxJQUFFLEtBQUcsSUFBSSxFQUFFLFNBQVMsQ0FBQyxJQUFFLEVBQUUsUUFBUSxJQUFFLElBQUU7QUFBRSxjQUFFLEVBQUUsSUFBRSxPQUFLLE1BQUksQ0FBQyxJQUFFO0FBQUUsY0FBRSxFQUFFLE1BQUksTUFBSSxDQUFDLElBQUUsRUFBRSxXQUFXO0FBQUUsY0FBRSxFQUFFLElBQUUsTUFBSSxNQUFJLENBQUMsSUFBRSxFQUFFLFdBQVc7QUFBRSxjQUFFLEVBQUUsSUFBRSxNQUFJLE1BQUksQ0FBQyxJQUFFLEVBQUUsU0FBUztBQUFFLGNBQUUsRUFBRSxJQUFFLE9BQUssTUFBSSxDQUFDLElBQUUsRUFBRSxRQUFRO0FBQUUsY0FBRSxFQUFFLElBQUUsT0FBSyxNQUFJLENBQUMsSUFBRSxFQUFFLFNBQVM7QUFBRSxjQUFFLEVBQUUsSUFBRSxPQUFLLE1BQUksQ0FBQyxJQUFFLEVBQUUsUUFBUTtBQUFFLGdCQUNwZixFQUFFLFFBQVE7QUFBRSxrQkFBTSxDQUFDLEtBQUcsRUFBRSxFQUFFLEdBQUcsTUFBSSxNQUFJLENBQUMsSUFBRSxJQUFHLElBQUUsTUFBSSxLQUFHO0FBQUksbUJBQU8sSUFBSSxJQUFFLEdBQUUsS0FBRyxDQUFDLEtBQUssSUFBSSxDQUFDLElBQUUsSUFBRSxJQUFFLENBQUMsS0FBSyxNQUFNLElBQUUsVUFBVSxNQUFJLElBQUUsQ0FBQyxDQUFDLENBQUMsS0FBSyxNQUFNLElBQUUsRUFBRSxDQUFDLENBQUMsTUFBSSxNQUFJLFVBQVUsTUFBSSxJQUFFLEVBQUUsR0FBRSxNQUFJO0FBQUEsVUFBQyxHQUFFLEdBQUUsSUFBRyxHQUFFLElBQUcsR0FBRSxTQUFTLEdBQUUsR0FBRSxHQUFFO0FBQUMscUJBQVMsRUFBRSxHQUFFO0FBQUMsc0JBQU8sSUFBRSxFQUFFLGFBQWEsRUFBRSxNQUFNLG1CQUFtQixLQUFHLEVBQUUsQ0FBQyxJQUFFO0FBQUEsWUFBSztBQUFDLG1CQUFLO0FBQUUsbUJBQUs7QUFBRSxtQkFBSztBQUFFLGdCQUFJLEtBQUcsb0JBQUksUUFBTSxZQUFZLEdBQUUsSUFBRSxJQUFJLEtBQUssR0FBRSxHQUFFLENBQUMsR0FBRSxJQUFFLElBQUksS0FBSyxHQUFFLEdBQUUsQ0FBQztBQUFFLGdCQUFFLEVBQUUsa0JBQWtCO0FBQUUsZ0JBQUksSUFBRSxFQUFFLGtCQUFrQixHQUFFLElBQUUsS0FBSyxJQUFJLEdBQUUsQ0FBQztBQUFFLGNBQUUsRUFBRSxNQUFJLE1BQUksQ0FBQyxJQUFFLEtBQUc7QUFBRSxjQUFFLEVBQUUsTUFBSSxNQUFJLENBQUMsSUFBRSxPQUFPLEtBQUcsQ0FBQztBQUFFLGdCQUFFLEVBQUUsQ0FBQztBQUFFLGdCQUFFLEVBQUUsQ0FBQztBQUNuZixnQkFBRSxHQUFHLENBQUM7QUFBRSxnQkFBRSxHQUFHLENBQUM7QUFBRSxnQkFBRSxLQUFHLEVBQUUsRUFBRSxNQUFJLE1BQUksQ0FBQyxJQUFFLEdBQUUsRUFBRSxFQUFFLElBQUUsTUFBSSxNQUFJLENBQUMsSUFBRSxNQUFJLEVBQUUsRUFBRSxNQUFJLE1BQUksQ0FBQyxJQUFFLEdBQUUsRUFBRSxFQUFFLElBQUUsTUFBSSxNQUFJLENBQUMsSUFBRTtBQUFBLFVBQUUsR0FBRSxHQUFFLE1BQUk7QUFBQyxjQUFFLEVBQUU7QUFBQSxVQUFDLEdBQUUsR0FBRSxTQUFTLEdBQUUsR0FBRSxHQUFFO0FBQUMsbUJBQUs7QUFBRSxnQkFBRSxHQUFHLE1BQUksR0FBRSxNQUFJLENBQUM7QUFBRSxtQkFBTyxHQUFHLENBQUMsRUFBRSxNQUFNLE1BQUssQ0FBQztBQUFBLFVBQUMsR0FBRSxHQUFFLFNBQVMsR0FBRSxHQUFFLEdBQUU7QUFBQyxtQkFBSztBQUFFLGdCQUFFLEdBQUcsTUFBSSxHQUFFLE1BQUksQ0FBQztBQUFFLG1CQUFPLEdBQUcsQ0FBQyxFQUFFLE1BQU0sTUFBSyxDQUFDO0FBQUEsVUFBQyxHQUFFLEdBQUUsTUFBSTtBQUFBLFVBQUMsR0FBRSxHQUFFLE1BQUksS0FBSyxJQUFJLEdBQUUsR0FBRSxNQUFJO0FBQUMsaUJBQUc7QUFBRSxrQkFBSztBQUFBLFVBQVMsR0FBRSxHQUFFLFdBQVU7QUFBQyxtQkFBTztBQUFBLFVBQVUsR0FBRSxHQUFFLE1BQUksWUFBWSxhQUFXLFlBQVksSUFBSSxHQUFFLEdBQUUsTUFBSSxJQUFFLHNDQUFjLEtBQUssRUFBRSxTQUFPLFVBQVUscUJBQW9CLEdBQUUsU0FBUyxHQUFFO0FBQUMsbUJBQUs7QUFBRSxnQkFBSSxJQUFFLEVBQUUsRUFBRTtBQUFPLGdCQUFHLEtBQUcsS0FBRyxhQUNuZjtBQUFFLHFCQUFNO0FBQUcscUJBQVEsSUFBRSxHQUFFLEtBQUcsR0FBRSxLQUFHLEdBQUU7QUFBQyxrQkFBSSxJQUFFLEtBQUcsSUFBRSxNQUFHO0FBQUcsa0JBQUUsS0FBSyxJQUFJLEdBQUUsSUFBRSxTQUFTO0FBQUUsa0JBQUksSUFBRTtBQUFLLGtCQUFFLEtBQUssSUFBSSxHQUFFLENBQUM7QUFBRSxpQkFBRTtBQUFDLHFCQUFHLEVBQUUsSUFBSSxLQUFLLEdBQUUsWUFBVyxLQUFHLFFBQU0sSUFBRSxTQUFPLEtBQUssSUFBRSxFQUFFLE9BQU8sYUFBVyxTQUFPO0FBQU0sb0JBQUc7QUFBQyxvQkFBRSxLQUFLLENBQUM7QUFBRSxvQkFBRTtBQUFFLHNCQUFJLElBQUU7QUFBRSx3QkFBTTtBQUFBLGdCQUFDLFNBQU8sR0FBRTtBQUFBLGdCQUFDO0FBQUMsb0JBQUU7QUFBQSxjQUFNO0FBQUMsa0JBQUc7QUFBRSx1QkFBTTtBQUFBLFlBQUU7QUFBQyxtQkFBTTtBQUFBLFVBQUUsR0FBRSxHQUFFLElBQUcsR0FBRSxJQUFHLEdBQUUsSUFBRyxHQUFFLElBQUcsR0FBRSxJQUFHLEdBQUUsSUFBRyxHQUFFLElBQUcsR0FBRSxLQUFHLEVBQUUsWUFBVyxHQUFFLElBQUcsR0FBRSxTQUFTLEdBQUUsR0FBRSxHQUFFLEdBQUU7QUFBQyxtQkFBTyxHQUFHLE1BQUksR0FBRSxNQUFJLEdBQUUsTUFBSSxHQUFFLE1BQUksQ0FBQztBQUFBLFVBQUMsRUFBQyxHQUFFLElBQUUsV0FBVTtBQUFDLHFCQUFTLEVBQUUsR0FBRSxHQUFFO0FBQUMsa0JBQUUsRUFBRTtBQUFRLGtCQUFFLEdBQUc7QUFBRSxrQkFBRSxHQUFHO0FBQUUsZ0JBQUUsR0FBRyxLQUFLLEVBQUUsRUFBRTtBQUFFLGlCQUFHLFFBQVEsRUFBRSxDQUFDO0FBQUUsbUJBQUc7QUFBRSxpQkFBRztBQUFFLHFCQUFPO0FBQUEsWUFBQztBQUFDLGdCQUFJLElBQUUsRUFBQyxHQUFFLEdBQUU7QUFDcmY7QUFBSSxnQkFBRyxFQUFFO0FBQWdCLGtCQUFHO0FBQUMsdUJBQU8sRUFBRSxnQkFBZ0IsR0FBRSxDQUFDO0FBQUEsY0FBQyxTQUFPLEdBQUU7QUFBQyxrQkFBRSxzREFBc0QsQ0FBQyxFQUFFLEdBQUUsRUFBRSxDQUFDO0FBQUEsY0FBQztBQUFDLGVBQUcsR0FBRSxTQUFTLEdBQUU7QUFBQyxnQkFBRSxFQUFFLFVBQVMsRUFBRSxNQUFNO0FBQUEsWUFBQyxDQUFDLEVBQUUsTUFBTSxDQUFDO0FBQUUsbUJBQU0sQ0FBQztBQUFBLFVBQUMsRUFBRTtBQUFFLFlBQUUsV0FBUyxDQUFDLEdBQUUsT0FBSyxFQUFFLFdBQVMsRUFBRSxHQUFHLEdBQUUsQ0FBQztBQUFFLFlBQUUsbUJBQWlCLENBQUMsR0FBRSxPQUFLLEVBQUUsbUJBQWlCLEVBQUUsR0FBRyxHQUFFLENBQUM7QUFBRSxZQUFFLDJCQUF5QixDQUFDLEdBQUUsR0FBRSxHQUFFLEdBQUUsR0FBRSxHQUFFLEdBQUUsR0FBRSxHQUFFLE9BQUssRUFBRSwyQkFBeUIsRUFBRSxHQUFHLEdBQUUsR0FBRSxHQUFFLEdBQUUsR0FBRSxHQUFFLEdBQUUsR0FBRSxHQUFFLENBQUM7QUFBRSxZQUFFLDhCQUE0QixDQUFDLEdBQUUsT0FBSyxFQUFFLDhCQUE0QixFQUFFLEdBQUcsR0FBRSxDQUFDO0FBQ3pkLFlBQUUsK0JBQTZCLENBQUMsR0FBRSxHQUFFLE9BQUssRUFBRSwrQkFBNkIsRUFBRSxJQUFJLEdBQUUsR0FBRSxDQUFDO0FBQUUsWUFBRSw0QkFBMEIsQ0FBQyxHQUFFLEdBQUUsT0FBSyxFQUFFLDRCQUEwQixFQUFFLElBQUksR0FBRSxHQUFFLENBQUM7QUFBRSxZQUFFLDRCQUEwQixRQUFJLEVBQUUsNEJBQTBCLEVBQUUsSUFBSSxDQUFDO0FBQUUsWUFBRSxvQkFBa0IsQ0FBQyxHQUFFLEdBQUUsT0FBSyxFQUFFLG9CQUFrQixFQUFFLElBQUksR0FBRSxHQUFFLENBQUM7QUFBRSxZQUFFLHFCQUFtQixRQUFJLEVBQUUscUJBQW1CLEVBQUUsSUFBSSxDQUFDO0FBQUUsWUFBRSwwQkFBd0IsQ0FBQyxHQUFFLEdBQUUsT0FBSyxFQUFFLDBCQUF3QixFQUFFLElBQUksR0FBRSxHQUFFLENBQUM7QUFBRSxZQUFFLG1CQUFpQixDQUFDLEdBQUUsT0FBSyxFQUFFLG1CQUFpQixFQUFFLElBQUksR0FBRSxDQUFDO0FBQ2plLFlBQUUsb0JBQWtCLENBQUMsR0FBRSxPQUFLLEVBQUUsb0JBQWtCLEVBQUUsSUFBSSxHQUFFLENBQUM7QUFBRSxZQUFFLFdBQVMsUUFBSSxFQUFFLFdBQVMsRUFBRSxJQUFJLENBQUM7QUFBRSxZQUFFLG1CQUFpQixDQUFDLEdBQUUsR0FBRSxHQUFFLEdBQUUsR0FBRSxPQUFLLEVBQUUsbUJBQWlCLEVBQUUsSUFBSSxHQUFFLEdBQUUsR0FBRSxHQUFFLEdBQUUsQ0FBQztBQUFFLFlBQUUsb0JBQWtCLENBQUMsR0FBRSxHQUFFLEdBQUUsR0FBRSxPQUFLLEVBQUUsb0JBQWtCLEVBQUUsSUFBSSxHQUFFLEdBQUUsR0FBRSxHQUFFLENBQUM7QUFBRSxZQUFFLG9CQUFrQixRQUFJLEVBQUUsb0JBQWtCLEVBQUUsSUFBSSxDQUFDO0FBQUUsWUFBRSx1QkFBcUIsQ0FBQyxHQUFFLEdBQUUsR0FBRSxPQUFLLEVBQUUsdUJBQXFCLEVBQUUsSUFBSSxHQUFFLEdBQUUsR0FBRSxDQUFDO0FBQUUsWUFBRSx3QkFBc0IsQ0FBQyxHQUFFLEdBQUUsT0FBSyxFQUFFLHdCQUFzQixFQUFFLElBQUksR0FBRSxHQUFFLENBQUM7QUFBRSxZQUFFLHdCQUFzQixRQUFJLEVBQUUsd0JBQXNCLEVBQUUsSUFBSSxDQUFDO0FBQzllLFlBQUUsb0JBQWtCLFFBQUksRUFBRSxvQkFBa0IsRUFBRSxJQUFJLENBQUM7QUFBRSxZQUFFLGdCQUFjLENBQUMsR0FBRSxHQUFFLE9BQUssRUFBRSxnQkFBYyxFQUFFLElBQUksR0FBRSxHQUFFLENBQUM7QUFBRSxZQUFFLGlCQUFlLENBQUMsR0FBRSxHQUFFLEdBQUUsT0FBSyxFQUFFLGlCQUFlLEVBQUUsSUFBSSxHQUFFLEdBQUUsR0FBRSxDQUFDO0FBQUUsWUFBRSx3QkFBc0IsUUFBSSxFQUFFLHdCQUFzQixFQUFFLElBQUksQ0FBQztBQUFFLFlBQUUscUJBQW1CLFFBQUksRUFBRSxxQkFBbUIsRUFBRSxJQUFJLENBQUM7QUFBRSxZQUFFLHFCQUFtQixDQUFDLEdBQUUsR0FBRSxHQUFFLEdBQUUsT0FBSyxFQUFFLHFCQUFtQixFQUFFLElBQUksR0FBRSxHQUFFLEdBQUUsR0FBRSxDQUFDO0FBQUUsWUFBRSxVQUFRLENBQUMsR0FBRSxHQUFFLEdBQUUsR0FBRSxHQUFFLEdBQUUsR0FBRSxPQUFLLEVBQUUsVUFBUSxFQUFFLElBQUksR0FBRSxHQUFFLEdBQUUsR0FBRSxHQUFFLEdBQUUsR0FBRSxDQUFDO0FBQUUsWUFBRSxtQkFBaUIsUUFBSSxFQUFFLG1CQUFpQixFQUFFLElBQUksQ0FBQztBQUN0ZCxZQUFFLGNBQVksQ0FBQyxHQUFFLEdBQUUsT0FBSyxFQUFFLGNBQVksRUFBRSxJQUFJLEdBQUUsR0FBRSxDQUFDO0FBQUUsWUFBRSxtQkFBaUIsUUFBSSxFQUFFLG1CQUFpQixFQUFFLElBQUksQ0FBQztBQUFFLGNBQUksS0FBRyxPQUFLLEtBQUcsRUFBRSxJQUFJLEdBQUUsS0FBRyxFQUFFLGdCQUFjLE9BQUssS0FBRyxFQUFFLGdCQUFjLEVBQUUsSUFBSSxHQUFFLEtBQUcsRUFBRSxVQUFRLFFBQUksS0FBRyxFQUFFLFVBQVEsRUFBRSxJQUFJLENBQUMsR0FBRSxLQUFHLEVBQUUsUUFBTSxRQUFJLEtBQUcsRUFBRSxRQUFNLEVBQUUsSUFBSSxDQUFDO0FBQUUsWUFBRSx3QkFBc0IsT0FBSyxFQUFFLHdCQUFzQixFQUFFLElBQUk7QUFBRSxjQUFJLEtBQUcsRUFBRSwyQkFBeUIsQ0FBQyxHQUFFLEdBQUUsR0FBRSxHQUFFLEdBQUUsT0FBSyxLQUFHLEVBQUUsMkJBQXlCLEVBQUUsSUFBSSxHQUFFLEdBQUUsR0FBRSxHQUFFLEdBQUUsQ0FBQztBQUFFLFlBQUUsOEJBQTRCLE9BQUssRUFBRSw4QkFBNEIsRUFBRSxJQUFJO0FBQ2plLGNBQUksS0FBRyxDQUFDLEdBQUUsR0FBRSxHQUFFLE9BQUssS0FBRyxFQUFFLElBQUksR0FBRSxHQUFFLEdBQUUsQ0FBQyxHQUFFLEtBQUcsUUFBSSxLQUFHLEVBQUUsSUFBSSxDQUFDLEdBQUUsS0FBRyxFQUFFLDJCQUF5QixRQUFJLEtBQUcsRUFBRSwyQkFBeUIsRUFBRSxJQUFJLENBQUMsR0FBRSxLQUFHLE9BQUssS0FBRyxFQUFFLElBQUksR0FBRSxLQUFHLFFBQUksS0FBRyxFQUFFLElBQUksQ0FBQyxHQUFFLEtBQUcsQ0FBQyxHQUFFLE9BQUssS0FBRyxFQUFFLElBQUksR0FBRSxDQUFDLEdBQUUsS0FBRyxPQUFLLEtBQUcsRUFBRSxJQUFJLEdBQUUsS0FBRyxRQUFJLEtBQUcsRUFBRSxJQUFJLENBQUMsR0FBRSxLQUFHLFFBQUksS0FBRyxFQUFFLElBQUksQ0FBQyxHQUFFLEtBQUcsRUFBRSxhQUFXLENBQUMsR0FBRSxPQUFLLEtBQUcsRUFBRSxhQUFXLEVBQUUsSUFBSSxHQUFFLENBQUMsR0FBRSxLQUFHLFFBQUksS0FBRyxFQUFFLElBQUksQ0FBQyxHQUFFLEtBQUcsT0FBSyxLQUFHLEVBQUUsSUFBSSxHQUFFLEtBQUcsUUFBSSxLQUFHLEVBQUUsSUFBSSxDQUFDLEdBQUUsS0FBRyxPQUFLLEtBQUcsRUFBRSxJQUFJO0FBQUUsWUFBRSxpQkFBZTtBQUFPLFlBQUUsZ0JBQWM7QUFDaGEsbUJBQVMsS0FBSTtBQUFDLGdCQUFJLElBQUU7QUFBRSxnQkFBRSxPQUFPLE9BQU8sQ0FBQyxHQUFFLENBQUM7QUFBRSxnQkFBSSxJQUFFLE9BQUcsTUFBSSxFQUFFLE1BQUksR0FBRSxJQUFFLE9BQUcsT0FBRyxFQUFFLENBQUMsTUFBSTtBQUFFLGNBQUUsS0FBRyxFQUFFLEVBQUUsRUFBRTtBQUFFLGNBQUUsS0FBRyxFQUFFLEVBQUUsRUFBRTtBQUFFLGNBQUUsS0FBRyxFQUFFLEVBQUUsRUFBRTtBQUFFLGNBQUUsb0NBQWtDLEVBQUUsRUFBRSxpQ0FBaUM7QUFBRSxjQUFFLEtBQUcsRUFBRSxFQUFFLEVBQUU7QUFBRSxjQUFFLEtBQUcsRUFBRSxFQUFFLEVBQUU7QUFBRSxtQkFBTztBQUFBLFVBQUM7QUFBQyxZQUFFLGFBQVc7QUFBRSxZQUFFLGFBQVc7QUFBRyxZQUFFLFlBQVU7QUFBRyxZQUFFLGVBQWE7QUFBRyxZQUFFLG1CQUFpQixNQUFJLElBQUU7QUFBRSxZQUFFLGVBQWE7QUFBRSxZQUFFLGVBQWE7QUFBRyxZQUFFLGtCQUFnQjtBQUFHLFlBQUUsYUFBVztBQUFHLFlBQUUsVUFBUTtBQUFFLGNBQUk7QUFBRyxjQUFFLFNBQVMsS0FBSTtBQUFDLGtCQUFJLEdBQUc7QUFBRSxtQkFBSyxJQUFFO0FBQUEsVUFBRztBQUNoYyxtQkFBUyxLQUFJO0FBQUMsZ0JBQUcsRUFBRSxJQUFFO0FBQUcsa0JBQUc7QUFBRSxtQkFBRyxDQUFDLEdBQUUsS0FBRyxHQUFHLEVBQUUsR0FBRSxZQUFZLENBQUM7QUFBQSxtQkFBTTtBQUFDLG9CQUFHLEVBQUU7QUFBTyx1QkFBSSxjQUFZLE9BQU8sRUFBRSxXQUFTLEVBQUUsU0FBTyxDQUFDLEVBQUUsTUFBTSxJQUFHLEVBQUUsT0FBTztBQUFRLHVCQUFHLFFBQVEsRUFBRSxPQUFPLE1BQU0sQ0FBQztBQUFFLG1CQUFHLEVBQUU7QUFBRSxvQkFBRSxLQUFHLE9BQUssS0FBRyxNQUFHLEVBQUUsWUFBVSxNQUFHLE1BQUksS0FBRyxHQUFHLEVBQUUsR0FBRSxHQUFHLENBQUMsR0FBRSxLQUFHLEdBQUcsRUFBRTtBQUFBLGNBQUc7QUFBQSxVQUFDO0FBQUMsYUFBRztBQUcxUCxpQkFBTyxVQUFVO0FBQUEsUUFDbkI7QUFBQSxNQUVBLEdBQUc7QUFFSCxVQUFJLE9BQU8sWUFBWSxZQUFZLE9BQU8sV0FBVztBQUNuRCxlQUFPLFVBQVU7QUFBQSxlQUNWLE9BQU8sV0FBVyxjQUFjLE9BQU8sS0FBSztBQUNuRCxlQUFPLENBQUMsR0FBRyxNQUFNLGVBQWU7QUFBQTtBQUFBOzs7QUMzRmxDO0FBQUE7QUFBQTtBQUFBO0FBQUE7OztBQ0FBLE1BaUNhLDRCQXFDQSw0QkFzQ0Esc0JBTUEsbUNBb0NBLHNCQW9CQSwwQkFNQTtBQWhMYjtBQUFBO0FBQUE7QUFpQ08sTUFBTSw2QkFBNkIsQ0FBQyxTQUEyQjtBQUNwRSxnQkFBUSxNQUFNO0FBQUEsVUFDWixLQUFLO0FBQ0gsbUJBQU87QUFBQSxVQUNULEtBQUs7QUFDSCxtQkFBTztBQUFBLFVBQ1QsS0FBSztBQUNILG1CQUFPO0FBQUEsVUFDVCxLQUFLO0FBQ0gsbUJBQU87QUFBQSxVQUNULEtBQUs7QUFDSCxtQkFBTztBQUFBLFVBQ1QsS0FBSztBQUNILG1CQUFPO0FBQUEsVUFDVCxLQUFLO0FBQ0gsbUJBQU87QUFBQSxVQUNULEtBQUs7QUFDSCxtQkFBTztBQUFBLFVBQ1QsS0FBSztBQUNILG1CQUFPO0FBQUEsVUFDVCxLQUFLO0FBQ0gsbUJBQU87QUFBQSxVQUNULEtBQUs7QUFDSCxtQkFBTztBQUFBLFVBQ1QsS0FBSztBQUNILG1CQUFPO0FBQUEsVUFDVCxLQUFLO0FBQ0gsbUJBQU87QUFBQSxVQUVUO0FBQ0Usa0JBQU0sSUFBSSxNQUFNLDBCQUEwQixJQUFJLEVBQUU7QUFBQSxRQUNwRDtBQUFBLE1BQ0Y7QUFLTyxNQUFNLDZCQUE2QixDQUFDLGNBQXFDO0FBQzlFLGdCQUFRLFdBQVc7QUFBQSxVQUNqQixLQUFLO0FBQ0gsbUJBQU87QUFBQSxVQUNULEtBQUs7QUFDSCxtQkFBTztBQUFBLFVBQ1QsS0FBSztBQUNILG1CQUFPO0FBQUEsVUFDVCxLQUFLO0FBQ0gsbUJBQU87QUFBQSxVQUNULEtBQUs7QUFDSCxtQkFBTztBQUFBLFVBQ1QsS0FBSztBQUNILG1CQUFPO0FBQUEsVUFDVCxLQUFLO0FBQ0gsbUJBQU87QUFBQSxVQUNULEtBQUs7QUFDSCxtQkFBTztBQUFBLFVBQ1QsS0FBSztBQUNILG1CQUFPO0FBQUEsVUFDVCxLQUFLO0FBQ0gsbUJBQU87QUFBQSxVQUNULEtBQUs7QUFDSCxtQkFBTztBQUFBLFVBQ1QsS0FBSztBQUNILG1CQUFPO0FBQUEsVUFDVCxLQUFLO0FBQ0gsbUJBQU87QUFBQSxVQUVUO0FBQ0Usa0JBQU0sSUFBSSxNQUFNLDBCQUEwQixTQUFTLEVBQUU7QUFBQSxRQUN6RDtBQUFBLE1BQ0Y7QUFNTyxNQUFNLHVCQUF1QixDQUFDLGFBQ3BCLENBQUMsUUFBVyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLFFBQVcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLFFBQVcsUUFBVyxNQUFTLEVBQUUsUUFBUTtBQUs5RyxNQUFNLG9DQUFvQyxDQUFDLFNBRW9EO0FBQ2hHLGdCQUFRLE1BQU07QUFBQSxVQUNaLEtBQUs7QUFDSCxtQkFBTztBQUFBLFVBQ1QsS0FBSztBQUNILG1CQUFPO0FBQUEsVUFDVCxLQUFLO0FBQ0gsbUJBQU87QUFBQSxVQUNULEtBQUs7QUFDSCxtQkFBTztBQUFBLFVBQ1QsS0FBSztBQUNILG1CQUFPO0FBQUEsVUFDVCxLQUFLO0FBQ0gsbUJBQU87QUFBQSxVQUNULEtBQUs7QUFDSCxtQkFBTztBQUFBLFVBQ1QsS0FBSztBQUNILG1CQUFPO0FBQUEsVUFDVCxLQUFLO0FBQ0gsbUJBQU87QUFBQSxVQUNULEtBQUs7QUFDSCxtQkFBTztBQUFBLFVBQ1QsS0FBSztBQUNILG1CQUFPO0FBQUEsVUFDVCxLQUFLO0FBQ0gsbUJBQU87QUFBQSxVQUNUO0FBQ0Usa0JBQU0sSUFBSSxNQUFNLHFCQUFxQixJQUFJLEVBQUU7QUFBQSxRQUMvQztBQUFBLE1BQ0Y7QUFLRyxNQUFNLHVCQUF1QixDQUFDLGFBQWtFO0FBQ3JHLGdCQUFRLFVBQVU7QUFBQSxVQUNoQixLQUFLO0FBQ0gsbUJBQU87QUFBQSxVQUNULEtBQUs7QUFDSCxtQkFBTztBQUFBLFVBQ1QsS0FBSztBQUNILG1CQUFPO0FBQUEsVUFDVCxLQUFLO0FBQ0gsbUJBQU87QUFBQSxVQUNULEtBQUs7QUFDSCxtQkFBTztBQUFBLFVBQ1Q7QUFDRSxrQkFBTSxJQUFJLE1BQU0sOEJBQThCLFFBQVEsRUFBRTtBQUFBLFFBQzVEO0FBQUEsTUFDRjtBQUtPLE1BQU0sMkJBQTJCLENBQUMsU0FBeUQsU0FBUyxhQUN2RyxTQUFTLFdBQVcsU0FBUyxXQUFXLFNBQVMsVUFBVSxTQUFTLGFBQWEsU0FBUztBQUt2RixNQUFNLDJCQUEyQixDQUFDLGFBQTBDO0FBQ2pGLGdCQUFRLFVBQVU7QUFBQSxVQUNoQixLQUFLO0FBQ0gsbUJBQU87QUFBQSxVQUNULEtBQUs7QUFDSCxtQkFBTztBQUFBLFVBQ1QsS0FBSztBQUNILG1CQUFPO0FBQUEsVUFDVCxLQUFLO0FBQ0gsbUJBQU87QUFBQSxVQUNULEtBQUs7QUFDSCxtQkFBTztBQUFBLFVBQ1Q7QUFDRSxrQkFBTSxJQUFJLE1BQU0sOEJBQThCLFFBQVEsRUFBRTtBQUFBLFFBQzVEO0FBQUEsTUFDRjtBQUFBO0FBQUE7OztBQy9MQTs7Ozs7OztBQ0FBOzs7QUFvRkE7Ozs7O0FDcEZBLE1BTWE7QUFOYjs7O0FBTU8sTUFBTSxVQUFVOzs7OztBQ052QixNQVFJLGVBRVM7QUFWYjs7O0FBSUE7QUFJQSxNQUFJLGdCQUF3QztBQUVyQyxNQUFNLE1BQVc7UUFDdEIsTUFBTSxDQUFBO1FBQ04sT0FBTyxDQUFBO1FBQ1AsUUFBUSxDQUFBO1FBQ1IsVUFBVSxFQUFDLFFBQVEsUUFBTztRQUUxQixJQUFJLFNBQVMsT0FBbUI7QUFDOUIsY0FBSSxVQUFVLFFBQVc7QUFDdkI7O0FBRUYsY0FBSSxPQUFPLFVBQVUsWUFBWSxDQUFDLFdBQVcsUUFBUSxXQUFXLFNBQVMsT0FBTyxFQUFFLFFBQVEsS0FBSyxNQUFNLElBQUk7QUFDdkcsa0JBQU0sSUFBSSxNQUFNLDhCQUE4QixLQUFLLEVBQUU7O0FBRXZELDBCQUFnQjtRQUNsQjtRQUNBLElBQUksV0FBUTtBQUNWLGlCQUFPO1FBQ1Q7O0FBSUYsYUFBTyxlQUFlLEtBQUssWUFBWSxFQUFDLFlBQVksS0FBSSxDQUFDOzs7OztBQy9CekQsTUFnTmFDO0FBaE5iOzs7QUFHQTtBQTZNTyxNQUFNQSxPQUFXOzs7OztBQ2hOeEI7Ozs7Ozs7QUNBQTs7O0FBSUE7Ozs7O0FDSkE7Ozs7Ozs7QUNBQTs7O0FBSUE7Ozs7O0FDSkE7OztBQUdBO0FBRUE7QUFFQTtBQUNBOzs7OztBQ1JBOzs7QUFJQTs7Ozs7QUNKQSxNQUthLE9BUVAsWUFrQk8sa0JBT0E7QUF0Q2I7OztBQUdBO0FBRU8sTUFBTSxRQUFRLENBQUMsWUFBb0IsVUFBaUI7QUFDekQsWUFBSSxDQUFDLElBQUksS0FBSyxPQUFPO0FBQ25COztBQUdGLGdCQUFRLFVBQVUsR0FBRyxVQUFVLFVBQVUsS0FBSyxFQUFFO01BQ2xEO0FBRUEsTUFBTSxhQUFhLENBQUMsS0FBYSxhQUFxQjtBQUNwRCxjQUFNLFFBQVEsSUFBSSxNQUFLLEVBQUcsT0FBTyxNQUFNLGFBQWEsS0FBSyxDQUFBO0FBQ3pELFlBQUksZUFBZTtBQUNuQixpQkFBUyxJQUFJLEdBQUcsSUFBSSxNQUFNLFFBQVEsS0FBSztBQUNyQyxjQUFJLGdCQUFnQixDQUFDLE1BQU0sQ0FBQyxFQUFFLFNBQVMsWUFBWSxHQUFHO0FBQ3BELGdCQUFJLFFBQVEsUUFBUSxHQUFHLEtBQUssTUFBTSxDQUFDLEVBQUUsS0FBSSxFQUFHLE1BQU0sR0FBRyxFQUFFLENBQUMsQ0FBQztBQUN6RCxnQkFBSSxVQUFVO0FBQ1osdUJBQVMsS0FBSyxRQUFROztBQUV4QixrQkFBTSxPQUFPLEtBQUs7QUFDbEI7O0FBRUYsY0FBSSxNQUFNLENBQUMsRUFBRSxTQUFTLFlBQVksR0FBRztBQUNuQywyQkFBZTs7O01BR3JCO0FBRU8sTUFBTSxtQkFBbUIsQ0FBQyxhQUFxQjtBQUNwRCxZQUFJLENBQUMsSUFBSSxLQUFLLE9BQU87QUFDbkI7O0FBRUYsbUJBQVcsU0FBUyxRQUFRO01BQzlCO0FBRU8sTUFBTSxpQkFBaUIsQ0FBQyxhQUFxQjtBQUNsRCxZQUFJLENBQUMsSUFBSSxLQUFLLE9BQU87QUFDbkI7O0FBRUYsbUJBQVcsT0FBTyxRQUFRO01BQzVCOzs7OztBQzNDQTs7O0FBR0E7QUFJQTtBQUNBOzs7OztBQ1JBOzs7QUFHQTs7Ozs7QUNIQTs7Ozs7OztBQ0FBOzs7QUFHQTtBQUlBOzs7OztBQ1BBOzs7QUFLQTs7Ozs7QUNMQTs7O0FBbUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3pCQSxNQVlNLGdCQUVBLE9BS0YsZ0JBQ0EsT0FFUyxpQkFRQSxLQVdBO0FBekNiO0FBQUE7QUFBQTtBQUtBO0FBT0EsTUFBTSxpQkFBaUIsQ0FBQyxLQUFLLEtBQUssS0FBSyxLQUFLLEdBQUc7QUFFL0MsTUFBTSxRQUFRLENBQUMsT0FBZSxZQUEwQjtBQUV0RCxnQkFBUSxJQUFJLElBQUksZUFBZSxLQUFLLENBQUMsS0FBSSxvQkFBSSxLQUFLLEdBQUUsWUFBWSxDQUFDLElBQUksT0FBTyxFQUFFO0FBQUEsTUFDaEY7QUFLTyxNQUFNLGtCQUFrQixDQUFDLGlCQUEyQixXQUEwQjtBQUNuRix5QkFBaUI7QUFDakIsZ0JBQVE7QUFBQSxNQUNWO0FBS08sTUFBTSxNQUFNLENBQUMsVUFBb0IsUUFBdUI7QUFDN0QsY0FBTSxlQUFlLHFCQUFxQixRQUFRO0FBQ2xELGNBQU0sY0FBYyxxQkFBcUIsY0FBYztBQUN2RCxZQUFJLGdCQUFnQixhQUFhO0FBQy9CLGdCQUFNLGNBQWMsT0FBTyxRQUFRLGFBQWEsSUFBSSxJQUFJLEdBQUc7QUFBQSxRQUM3RDtBQUFBLE1BQ0Y7QUFLTyxNQUFNLFlBQXdCLElBQUksU0FBaUM7QUFDeEUsWUFBSSxPQUFPO0FBQ1QsY0FBSSxHQUFHLElBQUk7QUFBQSxRQUNiO0FBQUEsTUFDRjtBQUFBO0FBQUE7OztBQzdDQSxNQU9hO0FBUGI7QUFBQTtBQUFBO0FBS0E7QUFFTyxNQUFNLGFBQWEsQ0FBQyxZQUF5QixTQUU1QyxLQUFLLGtDQUFrQyxJQUFJLEdBQUcsVUFBVTtBQUFBO0FBQUE7OztBQ1RoRTtBQUFBO0FBQUE7QUFBQTtBQUFBOzs7QUNBQSxNQTJFTSwwQkFFRixNQUNFLG9CQVlPLGlCQWtDUCxvQkFvT087QUFoV2I7QUFBQTtBQUFBO0FBSUE7QUFFQTtBQXFFQSxNQUFNLDJCQUEyQixDQUFDLFNBQWlCLEtBQUssS0FBSyxPQUFPLEVBQUUsSUFBSTtBQUUxRSxNQUFJLE9BQU87QUFDWCxNQUFNLHFCQUFxQixNQUFNO0FBWTFCLE1BQU0sa0JBQ1QsT0FBTSxTQUF3QixXQUFzQixjQUFzQixvQkFDL0M7QUFDckIsY0FBTSxhQUFhLHlCQUF5QixZQUFZO0FBQ3hELGNBQU0sZ0JBQWdCLFFBQVEsT0FBTztBQUFBO0FBQUEsVUFFakMsRUFBQyxNQUFNLFlBQVksT0FBTyxlQUFlLFdBQVcsZUFBZSxTQUFRO0FBQUEsUUFBQztBQUNoRixZQUFJO0FBQ0YsZ0JBQU0saUJBQWlCLFFBQVEsa0JBQWtCO0FBQ2pELGtCQUFRLGVBQWU7QUFDdkIseUJBQWU7QUFBQSxZQUNYO0FBQUEsWUFBK0I7QUFBQSxZQUF1QjtBQUFBLFlBQ3REO0FBQUEsWUFBNEI7QUFBQTtBQUFBLFVBQ2hDO0FBQ0Esa0JBQVEsTUFBTTtBQUVkLGdCQUFNLGNBQWMsU0FBUyxXQUFXLElBQUk7QUFFNUMsZ0JBQU0sY0FBYyxjQUFjLGVBQWU7QUFDakQsY0FBSSxpQkFBaUI7QUFFbkIsa0JBQU0sZUFBZSxnQkFBZ0I7QUFDckMseUJBQWEsSUFBSSxJQUFJLFdBQVcsYUFBYSxHQUFHLFlBQVksQ0FBQztBQUM3RCxtQkFBTztBQUFBLFVBQ1QsT0FBTztBQUdMLG1CQUFPLElBQUksV0FBVyxZQUFZLE1BQU0sR0FBRyxZQUFZLENBQUM7QUFBQSxVQUMxRDtBQUFBLFFBQ0YsVUFBRTtBQUNBLHdCQUFjLFFBQVE7QUFBQSxRQUN4QjtBQUFBLE1BQ0Y7QUFFUixNQUFNLHFCQUFOLE1BQW1EO0FBQUEsUUFpQmpELFlBQW9CLFNBQXdCO0FBQXhCO0FBQ2xCLGVBQUssZUFBZSxvQkFBSSxJQUFJO0FBQzVCLGVBQUssY0FBYyxvQkFBSSxJQUFJO0FBQzNCLGVBQUsscUJBQXFCLG9CQUFJLElBQUk7QUFDbEMsZUFBSyw2QkFBNkIsQ0FBQztBQUNuQyxlQUFLLGlCQUFpQixDQUFDO0FBQ3ZCLGVBQUssa0JBQWtCLG9CQUFJLElBQUk7QUFBQSxRQUNqQztBQUFBLFFBRUEsT0FBTyxJQUFlLE1BQXdCO0FBQzVDLGdCQUFNLGlCQUFpQixLQUFLO0FBQzVCLGdCQUFNLFlBQVksS0FBSztBQUN2QixnQkFBTSxZQUFZLEtBQUs7QUFDdkIsZ0JBQU0sT0FBTyx5QkFBeUIsU0FBUztBQUcvQyxnQkFBTSxlQUFlLEtBQUssYUFBYSxJQUFJLEVBQUU7QUFDN0MsY0FBSSxDQUFDLGNBQWM7QUFDakIsa0JBQU0sSUFBSSxNQUFNLHVDQUF1QztBQUFBLFVBQ3pEO0FBQ0EsY0FBSSxhQUFhLGlCQUFpQixXQUFXO0FBQzNDLGtCQUFNLElBQUksTUFBTSx5Q0FBeUMsYUFBYSxZQUFZLGVBQWUsU0FBUyxFQUFFO0FBQUEsVUFDOUc7QUFHQSxnQkFBTSx3QkFBd0IsS0FBSyxRQUFRLE9BQU87QUFBQTtBQUFBLFlBRTlDLEVBQUMsa0JBQWtCLE1BQU0sTUFBTSxPQUFPLGVBQWUsWUFBWSxlQUFlLFNBQVE7QUFBQSxVQUFDO0FBRzdGLGdCQUFNLGNBQWMsc0JBQXNCLGVBQWU7QUFDekQsY0FBSSxXQUFXLFdBQVcsRUFBRSxJQUFJLElBQUksV0FBVyxnQkFBZ0IsV0FBVyxTQUFTLENBQUM7QUFDcEYsZ0NBQXNCLE1BQU07QUFJNUIsZ0JBQU0saUJBQWlCLEtBQUssUUFBUSxrQkFBa0I7QUFDdEQsZUFBSyxRQUFRLGVBQWU7QUFDNUIseUJBQWUsbUJBQW1CLHVCQUF1QixHQUFHLGFBQWEsUUFBUSxRQUFRLEdBQUcsSUFBSTtBQUVoRyxvQkFBVSxXQUFXLE1BQU0scUNBQXFDLEVBQUUsR0FBRztBQUVyRSxlQUFLLDJCQUEyQixLQUFLLHFCQUFxQjtBQUFBLFFBQzVEO0FBQUEsUUFFQSxPQUFPLFVBQXFCLGVBQWdDO0FBRTFELGdCQUFNLHFCQUFxQixLQUFLLGFBQWEsSUFBSSxRQUFRO0FBQ3pELGNBQUksQ0FBQyxvQkFBb0I7QUFDdkIsa0JBQU0sSUFBSSxNQUFNLDJDQUEyQztBQUFBLFVBQzdEO0FBRUEsZ0JBQU0sMEJBQTBCLEtBQUssYUFBYSxJQUFJLGFBQWE7QUFDbkUsY0FBSSxDQUFDLHlCQUF5QjtBQUM1QixrQkFBTSxJQUFJLE1BQU0sZ0RBQWdEO0FBQUEsVUFDbEU7QUFDQSxjQUFJLG1CQUFtQixpQkFBaUIsd0JBQXdCLGNBQWM7QUFDNUUsa0JBQU0sSUFBSSxNQUFNLG1EQUFtRDtBQUFBLFVBQ3JFO0FBQ0EsZ0JBQU0sT0FBTyx5QkFBeUIsbUJBQW1CLFlBQVk7QUFHckUsZ0JBQU0saUJBQWlCLEtBQUssUUFBUSxrQkFBa0I7QUFDdEQsZUFBSyxRQUFRLGVBQWU7QUFDNUIseUJBQWU7QUFBQSxZQUNYLG1CQUFtQixRQUFRO0FBQUEsWUFBUTtBQUFBLFlBQUcsd0JBQXdCLFFBQVE7QUFBQSxZQUFRO0FBQUEsWUFBRztBQUFBLFVBQUk7QUFBQSxRQUMzRjtBQUFBLFFBRUEsdUJBQXVCLFFBQW1CLGNBQXNCLGdCQUFvQztBQUNsRyxjQUFJO0FBQ0osY0FBSSxnQkFBZ0I7QUFDbEIsaUJBQUssS0FBSyxnQkFBZ0IsSUFBSSxjQUFjO0FBQzVDLGdCQUFJLE9BQU8sUUFBVztBQUNwQixvQkFBTSxJQUFJLE1BQU0sbUNBQW1DO0FBQUEsWUFDckQ7QUFDQSxnQkFBSSxXQUFXLGdCQUFnQjtBQUM3QjtBQUFBLGdCQUNJO0FBQUEsZ0JBQ0EsTUFBTSx1REFBdUQsWUFBWSxXQUNyRSxFQUFFO0FBQUEsY0FBNkI7QUFDdkMscUJBQU87QUFBQSxZQUNUO0FBQ0EsaUJBQUssZ0JBQWdCLE9BQU8sY0FBYztBQUFBLFVBQzVDLE9BQU87QUFDTCxpQkFBSyxtQkFBbUI7QUFBQSxVQUMxQjtBQUVBLGVBQUssYUFBYSxJQUFJLElBQUksRUFBQyxTQUFTLEVBQUMsSUFBSSx1QkFBMkIsT0FBTSxHQUFHLGFBQVksQ0FBQztBQUMxRixlQUFLLGdCQUFnQixJQUFJLFFBQVEsRUFBRTtBQUNuQztBQUFBLFlBQ0k7QUFBQSxZQUNBLE1BQU0sdURBQXVELFlBQVksV0FBVyxFQUFFO0FBQUEsVUFBZTtBQUN6RyxpQkFBTztBQUFBLFFBQ1Q7QUFBQSxRQUVBLHlCQUF5QixRQUF5QjtBQUNoRCxnQkFBTSxLQUFLLEtBQUssZ0JBQWdCLElBQUksTUFBTTtBQUMxQyxjQUFJLE9BQU8sUUFBVztBQUNwQixpQkFBSyxhQUFhLE9BQU8sRUFBRTtBQUMzQixpQkFBSyxnQkFBZ0IsT0FBTyxNQUFNO0FBQ2xDLHNCQUFVLFdBQVcsTUFBTSw0REFBNEQsRUFBRSxFQUFFO0FBQUEsVUFDN0Y7QUFBQSxRQUNGO0FBQUE7QUFBQSxRQUdBLE9BQU8sTUFBYyxRQUFRLGVBQWUsVUFBVSxlQUFlLFdBQVcsZUFBZSxVQUFtQjtBQUNoSCxnQkFBTSxhQUFhLHlCQUF5QixJQUFJO0FBRWhELGNBQUk7QUFHSixnQkFBTSxhQUFhLFFBQVEsZUFBZSxhQUFhLGVBQWU7QUFFdEUsZ0JBQU0sYUFBYSxRQUFRLGVBQWUsYUFBYSxlQUFlO0FBQ3RFLGNBQUksYUFBYSxXQUFXO0FBQzFCLGtCQUFNLGNBQWMsWUFBWSxLQUFLLGNBQWMsS0FBSztBQUN4RCxnQkFBSSxVQUFVLFlBQVksSUFBSSxVQUFVO0FBQ3hDLGdCQUFJLENBQUMsU0FBUztBQUNaLHdCQUFVLENBQUM7QUFDWCwwQkFBWSxJQUFJLFlBQVksT0FBTztBQUFBLFlBQ3JDO0FBQ0EsZ0JBQUksUUFBUSxTQUFTLEdBQUc7QUFDdEIsMEJBQVksUUFBUSxJQUFJO0FBQUEsWUFDMUIsT0FBTztBQUVMLDBCQUFZLEtBQUssUUFBUSxPQUFPLGFBQWEsRUFBQyxNQUFNLFlBQVksTUFBSyxDQUFDO0FBQUEsWUFDeEU7QUFBQSxVQUNGLE9BQU87QUFFTCx3QkFBWSxLQUFLLFFBQVEsT0FBTyxhQUFhLEVBQUMsTUFBTSxZQUFZLE1BQUssQ0FBQztBQUFBLFVBQ3hFO0FBRUEsZ0JBQU0sVUFBVSxFQUFDLElBQUksbUJBQW1CLEdBQUcsdUJBQTJCLFFBQVEsVUFBUztBQUN2RixlQUFLLGFBQWEsSUFBSSxRQUFRLElBQUksRUFBQyxTQUFTLGNBQWMsS0FBSSxDQUFDO0FBRS9ELG9CQUFVLFdBQVcsTUFBTSx1Q0FBdUMsSUFBSSxXQUFXLFFBQVEsRUFBRSxFQUFFO0FBQzdGLGlCQUFPO0FBQUEsUUFDVDtBQUFBLFFBRUEsSUFBSSxJQUFrQztBQUNwQyxpQkFBTyxLQUFLLGFBQWEsSUFBSSxFQUFFLEdBQUc7QUFBQSxRQUNwQztBQUFBLFFBRUEsUUFBUSxJQUF1QjtBQUM3QixnQkFBTSxhQUFhLEtBQUssYUFBYSxJQUFJLEVBQUU7QUFDM0MsY0FBSSxDQUFDLFlBQVk7QUFDZixrQkFBTSxJQUFJLE1BQU0sK0JBQStCO0FBQUEsVUFDakQ7QUFFQSxvQkFBVSxXQUFXLE1BQU0sc0NBQXNDLEVBQUUsZ0JBQWdCLFdBQVcsUUFBUSxFQUFFLEVBQUU7QUFFMUcsZUFBSyxhQUFhLE9BQU8sRUFBRTtBQUMzQixlQUFLLGVBQWUsS0FBSyxXQUFXLFFBQVEsTUFBTTtBQUdsRCxpQkFBTyxXQUFXO0FBQUEsUUFDcEI7QUFBQSxRQUVBLE1BQU0sU0FBUyxJQUFlLGlCQUFrRDtBQUM5RSxnQkFBTSxhQUFhLEtBQUssYUFBYSxJQUFJLEVBQUU7QUFDM0MsY0FBSSxDQUFDLFlBQVk7QUFDZixrQkFBTSxJQUFJLE1BQU0scUJBQXFCO0FBQUEsVUFDdkM7QUFFQSxnQkFBTSxnQkFBZ0IsS0FBSyxTQUFTLFdBQVcsUUFBUSxRQUFRLFdBQVcsY0FBYyxlQUFlO0FBQUEsUUFDekc7QUFBQSxRQUVBLHdCQUE4QjtBQUM1QixxQkFBVyxVQUFVLEtBQUssNEJBQTRCO0FBRXBELG1CQUFPLFFBQVE7QUFBQSxVQUNqQjtBQUNBLGVBQUssNkJBQTZCLENBQUM7QUFDbkMscUJBQVcsVUFBVSxLQUFLLGdCQUFnQjtBQUV4QyxpQkFBSyxPQUFPLFFBQVEsZUFBZSxhQUFhLGVBQWUsU0FBUztBQUV0RSxtQkFBSyxZQUFZLElBQUksT0FBTyxJQUFJLEVBQUcsS0FBSyxNQUFNO0FBQUEsWUFFaEQsWUFBWSxPQUFPLFFBQVEsZUFBZSxhQUFhLGVBQWUsU0FBUztBQUU3RSxtQkFBSyxtQkFBbUIsSUFBSSxPQUFPLElBQUksRUFBRyxLQUFLLE1BQU07QUFBQSxZQUN2RCxPQUFPO0FBQ0wscUJBQU8sUUFBUTtBQUFBLFlBQ2pCO0FBQUEsVUFDRjtBQUNBLGVBQUssaUJBQWlCLENBQUM7QUFBQSxRQUN6QjtBQUFBLFFBRUEsVUFBVTtBQUNSLGVBQUssWUFBWSxRQUFRLENBQUMsWUFBWTtBQUNwQyxvQkFBUSxRQUFRLFlBQVU7QUFDeEIscUJBQU8sUUFBUTtBQUFBLFlBQ2pCLENBQUM7QUFBQSxVQUNILENBQUM7QUFDRCxlQUFLLG1CQUFtQixRQUFRLENBQUMsWUFBWTtBQUMzQyxvQkFBUSxRQUFRLFlBQVU7QUFDeEIscUJBQU8sUUFBUTtBQUFBLFlBQ2pCLENBQUM7QUFBQSxVQUNILENBQUM7QUFFRCxlQUFLLGFBQWEsUUFBUSxDQUFDLFlBQVk7QUFDckMsb0JBQVEsUUFBUSxPQUFPLFFBQVE7QUFBQSxVQUNqQyxDQUFDO0FBRUQsZUFBSyxlQUFlLG9CQUFJLElBQUk7QUFDNUIsZUFBSyxjQUFjLG9CQUFJLElBQUk7QUFDM0IsZUFBSyxxQkFBcUIsb0JBQUksSUFBSTtBQUFBLFFBQ3BDO0FBQUEsTUFDRjtBQUVPLE1BQU0sdUJBQXVCLElBQUksU0FDcEMsSUFBSSxtQkFBbUIsR0FBRyxJQUFJO0FBQUE7QUFBQTs7O0FDaldsQyxNQUdNLDJCQXNCTztBQXpCYjtBQUFBO0FBQUE7QUFHQSxNQUFNLDRCQUFOLE1BQWdDO0FBQUEsUUFDOUIsWUFBWSxXQUFvQztBQUM5QyxpQkFBTyxPQUFPLE1BQU0sU0FBUztBQUFBLFFBQy9CO0FBQUEsUUFHQSxJQUFXLFdBQW1CO0FBQzVCLGNBQUksQ0FBQyxLQUFLLEtBQUs7QUFDYixpQkFBSyxNQUNELE9BQU8sb0JBQW9CLElBQUksRUFBRSxLQUFLLEVBQUUsSUFBSSxVQUFRLEdBQUksS0FBaUMsSUFBSSxDQUFDLEVBQUUsRUFBRSxLQUFLLEdBQUc7QUFBQSxVQUNoSDtBQUNBLGlCQUFPLEtBQUs7QUFBQSxRQUNkO0FBQUEsTUFDRjtBQVNPLE1BQU0sOEJBQThCLENBQW9DLGNBQzNFLElBQUksMEJBQTBCLFNBQVM7QUFBQTtBQUFBOzs7QUMxQjNDLE1BS2EsWUFhQSxlQW9FQSxXQWlIQSxjQTBNQSxVQWtEQSxVQUNBO0FBcGNiO0FBQUE7QUFBQTtBQUtPLE1BQU0sYUFBTixNQUFpQjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFFBT3RCLE9BQU8sZ0JBQWdCLEdBQXFCLEdBQWlEO0FBQzNGLGlCQUFRLEVBQUUsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxJQUFLLFNBQVksQ0FBQyxFQUFFLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQztBQUFBLFFBQ2xEO0FBQUEsTUFDRjtBQUdPLE1BQU0sZ0JBQU4sTUFBb0I7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFFBUXpCLE9BQU8sVUFBVSxPQUEwQixPQUEwQixXQUFXLE9BQW9DO0FBQ2xILGdCQUFNLFFBQVEsTUFBTTtBQUNwQixnQkFBTSxRQUFRLE1BQU07QUFDcEIsY0FBSSxVQUFVLEdBQUc7QUFDZixtQkFBTztBQUFBLFVBQ1Q7QUFDQSxjQUFJLFVBQVUsR0FBRztBQUNmLG1CQUFPO0FBQUEsVUFDVDtBQUNBLGdCQUFNLFFBQVEsS0FBSyxJQUFJLE1BQU0sUUFBUSxNQUFNLE1BQU07QUFDakQsZ0JBQU0sUUFBUSxJQUFJLE1BQWMsS0FBSztBQUdyQyxjQUFJLFVBQVU7QUFDWixnQkFBSSxRQUFRLEtBQUssUUFBUSxHQUFHO0FBQzFCLHFCQUFPO0FBQUEsWUFDVDtBQUNBLGtCQUFNLGVBQ0YsV0FBVyxnQkFBZ0IsQ0FBQyxNQUFNLFFBQVEsQ0FBQyxHQUFHLE1BQU0sUUFBUSxDQUFDLENBQUMsR0FBRyxDQUFDLE1BQU0sUUFBUSxDQUFDLEdBQUcsTUFBTSxRQUFRLENBQUMsQ0FBQyxDQUFDO0FBQ3pHLGdCQUFJLGlCQUFpQixRQUFXO0FBQzlCLHFCQUFPO0FBQUEsWUFDVDtBQUNBLGFBQUMsTUFBTSxRQUFRLENBQUMsR0FBRyxNQUFNLFFBQVEsQ0FBQyxDQUFDLElBQUk7QUFBQSxVQUN6QztBQUVBLG1CQUFTLElBQUksV0FBVyxJQUFJLEdBQUcsS0FBSyxPQUFPLEtBQUs7QUFDOUMsa0JBQU0sT0FBTyxRQUFRLElBQUksSUFBSSxJQUFJLE1BQU0sUUFBUSxDQUFDO0FBQ2hELGtCQUFNLE9BQU8sUUFBUSxJQUFJLElBQUksSUFBSSxNQUFNLFFBQVEsQ0FBQztBQUVoRCxnQkFBSSxTQUFTLFFBQVEsT0FBTyxLQUFLLE9BQU8sR0FBRztBQUN6QyxxQkFBTztBQUFBLFlBQ1Q7QUFDQSxrQkFBTSxRQUFRLENBQUMsSUFBSSxLQUFLLElBQUksTUFBTSxJQUFJO0FBQUEsVUFDeEM7QUFFQSxpQkFBTztBQUFBLFFBQ1Q7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsUUFPQSxPQUFPLGlCQUFpQixPQUEwQixZQUF3QztBQUV4RixnQkFBTSxZQUFZLE1BQU07QUFDeEIsZ0JBQU0sWUFBWSxXQUFXO0FBQzdCLGNBQUksWUFBWSxXQUFXO0FBQ3pCLG1CQUFPO0FBQUEsVUFDVDtBQUNBLG1CQUFTLElBQUksR0FBRyxLQUFLLFdBQVcsS0FBSztBQUNuQyxnQkFBSSxNQUFNLFlBQVksQ0FBQyxNQUFNLEtBQUssTUFBTSxZQUFZLENBQUMsTUFBTSxXQUFXLFlBQVksQ0FBQyxHQUFHO0FBQ3BGLHFCQUFPO0FBQUEsWUFDVDtBQUFBLFVBQ0Y7QUFDQSxpQkFBTztBQUFBLFFBQ1Q7QUFBQSxNQUNGO0FBR08sTUFBTSxZQUFOLE1BQU0sV0FBVTtBQUFBO0FBQUE7QUFBQTtBQUFBLFFBSXJCLE9BQU8sS0FBSyxNQUFpQztBQUMzQyxpQkFBTyxXQUFVLDBCQUEwQixNQUFNLEdBQUcsS0FBSyxNQUFNO0FBQUEsUUFDakU7QUFBQTtBQUFBO0FBQUE7QUFBQSxRQUtBLE9BQU8sa0JBQWtCLE1BQXlCLE1BQXNCO0FBQ3RFLGNBQUksT0FBTyxLQUFLLE9BQU8sS0FBSyxRQUFRO0FBQ2xDLGtCQUFNLElBQUksTUFBTSx3QkFBd0IsSUFBSSx3Q0FBd0MsS0FBSyxNQUFNLGNBQWM7QUFBQSxVQUMvRztBQUNBLGlCQUFPLFdBQVUsMEJBQTBCLE1BQU0sTUFBTSxLQUFLLE1BQU07QUFBQSxRQUNwRTtBQUFBO0FBQUE7QUFBQTtBQUFBLFFBS0EsT0FBTyxnQkFBZ0IsTUFBeUIsTUFBc0I7QUFDcEUsY0FBSSxPQUFPLEtBQUssT0FBTyxLQUFLLFFBQVE7QUFDbEMsa0JBQU0sSUFBSSxNQUFNLHdCQUF3QixJQUFJLHNDQUFzQyxLQUFLLE1BQU0sY0FBYztBQUFBLFVBQzdHO0FBQ0EsaUJBQU8sV0FBVSwwQkFBMEIsTUFBTSxHQUFHLElBQUk7QUFBQSxRQUMxRDtBQUFBO0FBQUE7QUFBQTtBQUFBLFFBS0EsT0FBTywwQkFBMEIsTUFBeUIsT0FBZSxLQUFxQjtBQUM1RixjQUFJLE9BQU87QUFDWCxtQkFBUyxJQUFJLE9BQU8sSUFBSSxLQUFLLEtBQUs7QUFHaEMsZ0JBQUksS0FBSyxDQUFDLElBQUksR0FBRztBQUNmLG9CQUFNLElBQUk7QUFBQTtBQUFBLGdCQUVOO0FBQUEsY0FBK0c7QUFBQSxZQUNySDtBQUNBLG9CQUFRLEtBQUssQ0FBQztBQUFBLFVBQ2hCO0FBQ0EsaUJBQU87QUFBQSxRQUNUO0FBQUEsUUFFQSxPQUFPLGVBQWUsTUFBNEM7QUFDaEUsZ0JBQU0sT0FBTyxLQUFLO0FBQ2xCLGNBQUksU0FBUyxHQUFHO0FBQ2QsbUJBQU8sQ0FBQztBQUFBLFVBQ1YsV0FBVyxTQUFTLEdBQUc7QUFDckIsbUJBQU8sQ0FBQyxDQUFDO0FBQUEsVUFDWDtBQUNBLGdCQUFNLFVBQVUsSUFBSSxNQUFNLElBQUk7QUFDOUIsa0JBQVEsT0FBTyxDQUFDLElBQUk7QUFDcEIsa0JBQVEsT0FBTyxDQUFDLElBQUksS0FBSyxPQUFPLENBQUM7QUFDakMsbUJBQVMsSUFBSSxPQUFPLEdBQUcsS0FBSyxHQUFHLEVBQUUsR0FBRztBQUNsQyxvQkFBUSxDQUFDLElBQUksUUFBUSxJQUFJLENBQUMsSUFBSSxLQUFLLElBQUksQ0FBQztBQUFBLFVBQzFDO0FBQ0EsaUJBQU87QUFBQSxRQUNUO0FBQUE7QUFBQTtBQUFBO0FBQUEsUUFLQSxPQUFPLGNBQWMsTUFBYyxZQUE0QjtBQUM3RCxjQUFJLE9BQU8sQ0FBQyxjQUFjLFFBQVEsWUFBWTtBQUM1QyxrQkFBTSxJQUFJLE1BQU0sc0NBQXNDO0FBQUEsVUFDeEQ7QUFDQSxpQkFBTyxPQUFPLElBQUksT0FBTyxhQUFhO0FBQUEsUUFDeEM7QUFBQSxRQUVBLE9BQU8sY0FBYyxNQUF5QixZQUErQjtBQUMzRSxpQkFBTyxLQUFLLElBQUksT0FBSyxLQUFLLGNBQWMsR0FBRyxjQUFjLEtBQUssTUFBTSxDQUFDO0FBQUEsUUFDdkU7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxRQVFBLE9BQU8sZ0JBQWdCLEdBQXNCLE1BQTZDO0FBQ3hGLGNBQUksTUFBTTtBQUNSLG1CQUFPLEtBQUssSUFBSSxDQUFDLE1BQU0sRUFBRSxDQUFDLENBQUM7QUFBQSxVQUM3QixPQUFPO0FBQ0wsbUJBQU8sRUFBRSxNQUFNLEVBQUUsUUFBUTtBQUFBLFVBQzNCO0FBQUEsUUFDRjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxRQU9BLE9BQU8sU0FBUyxNQUF5QkMsTUFBMkM7QUFDbEYsZ0JBQU0sT0FBTyxLQUFLO0FBQ2xCLGlCQUFPLEtBQUssSUFBSSxDQUFDLEdBQUcsTUFBTSxJQUFJQSxLQUFJLENBQUMsSUFBSUEsS0FBSSxJQUFJLElBQUksQ0FBQztBQUFBLFFBQ3REO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFFBT0EsT0FBTyxTQUFTLFFBQTJCLFFBQW9DO0FBQzdFLGNBQUksT0FBTyxXQUFXLE9BQU8sUUFBUTtBQUNuQyxtQkFBTztBQUFBLFVBQ1Q7QUFDQSxpQkFBTyxPQUFPLE1BQU0sQ0FBQyxHQUFHLE1BQU0sTUFBTSxPQUFPLENBQUMsQ0FBQztBQUFBLFFBQy9DO0FBQUEsTUFDRjtBQUVPLE1BQU0sZUFBTixNQUFNLGNBQWE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxRQVV4QixPQUFPLHFCQUNILGtCQUEyQixXQUE4QixhQUF1QixTQUNoRixXQUFxQixNQUFzQjtBQUM3QyxjQUFJLENBQUMsb0JBQW9CLFlBQVksV0FBVyxVQUFVLFNBQVMsR0FBRztBQUNwRSxrQkFBTSxJQUFJLE1BQU0sb0ZBQW9GO0FBQUEsVUFDdEc7QUFFQSxjQUFJLGtCQUFrQjtBQUVwQixxQkFBUyxNQUFNLEdBQUcsTUFBTSxVQUFVLFNBQVMsR0FBRyxPQUFPO0FBQ25ELGtCQUFJLE9BQU8sWUFBWSxRQUFRO0FBQzdCLDRCQUFZLEtBQUssVUFBVSxNQUFNLENBQUMsQ0FBQztBQUFBLGNBQ3JDLE9BQU87QUFDTCw0QkFBWSxHQUFHLElBQUksVUFBVSxNQUFNLENBQUM7QUFBQSxjQUN0QztBQUFBLFlBQ0Y7QUFBQSxVQUNGO0FBR0EsbUJBQVMsTUFBTSxHQUFHLE1BQU0sWUFBWSxRQUFRLE9BQU87QUFDakQsZ0JBQUksTUFBTSxRQUFRLFFBQVE7QUFDeEIsa0JBQUksUUFBUSxHQUFHLElBQUksR0FBRztBQUNwQixzQkFBTSxJQUFJLE1BQU0sOENBQThDO0FBQUEsY0FDaEU7QUFBQSxZQUNGLE9BQU87QUFDTCxzQkFBUSxLQUFLLENBQUM7QUFBQSxZQUNoQjtBQUFBLFVBQ0Y7QUFHQSxtQkFBUyxNQUFNLEdBQUcsTUFBTSxZQUFZLFFBQVEsT0FBTztBQUNqRCxnQkFBSSxNQUFNLFVBQVUsUUFBUTtBQUMxQixrQkFBSSxVQUFVLEdBQUcsSUFBSSxHQUFHO0FBQ3RCLHNCQUFNLElBQUksTUFBTSxnREFBZ0Q7QUFBQSxjQUNsRTtBQUFBLFlBQ0YsT0FBTztBQUNMLHdCQUFVLEtBQUssQ0FBQztBQUFBLFlBQ2xCO0FBQUEsVUFDRjtBQUdBLG1CQUFTLE1BQU0sR0FBRyxNQUFNLFlBQVksU0FBUyxHQUFHLE9BQU87QUFDckQsZ0JBQUksTUFBTSxLQUFLLFFBQVE7QUFDckIsa0JBQUksS0FBSyxHQUFHLElBQUksR0FBRztBQUNqQixzQkFBTSxJQUFJLE1BQU0sMENBQTBDO0FBQUEsY0FDNUQ7QUFBQSxZQUNGLE9BQU87QUFDTCxtQkFBSyxLQUFLLENBQUM7QUFBQSxZQUNiO0FBQUEsVUFDRjtBQUdBLG1CQUFTLE1BQU0sR0FBRyxNQUFNLFlBQVksUUFBUSxPQUFPO0FBQ2pELGdCQUFJLFlBQVksR0FBRyxLQUFLLEdBQUc7QUFDekIsb0JBQU0sSUFBSSxNQUFNLHlDQUF5QztBQUFBLFlBQzNEO0FBRUEsZ0JBQUksS0FBSyxHQUFHLEtBQUssWUFBWSxHQUFHLEtBQUssS0FBSyxNQUFNLFlBQVksTUFBTSxLQUFLLFlBQVksR0FBRyxHQUFHO0FBQ3ZGLG9CQUFNLElBQUksTUFBTSxvQ0FBb0M7QUFBQSxZQUN0RDtBQUFBLFVBQ0Y7QUFBQSxRQUNGO0FBQUE7QUFBQSxRQUdBLE9BQU8seUJBQ0gsV0FBOEIsU0FBNEIsV0FDMUQsYUFBZ0MsTUFBZ0IsZUFBd0IsU0FBd0I7QUFDbEcsY0FBSSxDQUFDLFNBQVM7QUFDWjtBQUFBLFVBQ0Y7QUFFQSxjQUFJLEtBQUssV0FBVyxLQUFLLFVBQVUsU0FBUyxJQUFJO0FBQzlDLGtCQUFNLElBQUksTUFBTSw4REFBOEQ7QUFBQSxVQUNoRjtBQUVBLGNBQUksUUFBUSxXQUFZLFVBQVUsU0FBUyxHQUFJO0FBQzdDLGtCQUFNLElBQUksTUFBTSwyREFBMkQ7QUFBQSxVQUM3RTtBQUVBLGNBQUksWUFBWSxXQUFZLFVBQVUsU0FBUyxHQUFJO0FBQ2pELGtCQUFNLElBQUksTUFBTSxpRUFBaUU7QUFBQSxVQUNuRjtBQUVBLG1CQUFTLE1BQU0sR0FBRyxNQUFNLFVBQVUsU0FBUyxHQUFHLE9BQU87QUFDbkQsMEJBQWE7QUFBQSxjQUNULFVBQVUsT0FBTyxnQkFBZ0IsSUFBSSxFQUFFO0FBQUEsY0FBRyxRQUFRLEdBQUc7QUFBQSxjQUFHLFVBQVUsR0FBRztBQUFBLGNBQUcsWUFBWSxHQUFHO0FBQUEsY0FBRztBQUFBLGNBQU07QUFBQSxjQUNoRyxNQUFNLFVBQVUsU0FBUztBQUFBLGNBQUc7QUFBQSxZQUFPO0FBQUEsVUFDekM7QUFBQSxRQUNGO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFFBYUEsT0FBTyx1QkFDSCxrQkFBMkIsV0FBOEIsU0FBbUIsV0FDNUUsYUFBdUIsTUFBZ0IsU0FBNEI7QUFDckUsY0FBSSxVQUFVLFVBQVUsR0FBRztBQUN6QixrQkFBTSxJQUFJLE1BQU0sNENBQTRDO0FBQUEsVUFDOUQ7QUFHQSxnQkFBTSxhQUFhLENBQUMsVUFBVSxDQUFDLEdBQUcsVUFBVSxDQUFDLENBQUM7QUFFOUMsd0JBQWE7QUFBQSxZQUNUO0FBQUEsWUFBa0I7QUFBQSxZQUFXO0FBQUEsWUFBWTtBQUFBLFlBQVM7QUFBQSxZQUFXO0FBQUEsWUFBYTtBQUFBLFlBQU07QUFBQSxVQUFPO0FBQzNGLGlCQUFPO0FBQUEsUUFDVDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsUUFZQSxPQUFPLHVCQUNILFdBQThCLFlBQStCLFNBQW1CLFdBQ2hGLGFBQXVCLE1BQWdCLFNBQTRCO0FBQ3JFLGNBQUksVUFBVSxVQUFVLEtBQUssV0FBVyxVQUFVLEdBQUc7QUFDbkQsa0JBQU0sSUFBSSxNQUFNLHlEQUF5RDtBQUFBLFVBQzNFO0FBR0EsZ0JBQU0sYUFBYSxDQUFDLFVBQVUsQ0FBQyxHQUFHLFdBQVcsQ0FBQyxDQUFDO0FBRS9DLHdCQUFhLG1CQUFtQixPQUFPLFdBQVcsWUFBWSxTQUFTLFdBQVcsYUFBYSxNQUFNLE9BQU87QUFDNUcsaUJBQU87QUFBQSxRQUNUO0FBQUE7QUFBQTtBQUFBO0FBQUEsUUFLQSxPQUFlLG1CQUNYLGtCQUEyQixXQUE4QixZQUFzQixTQUMvRSxXQUE4QixhQUFnQyxNQUFnQixTQUFrQjtBQUNsRyxjQUFJLGtCQUFrQjtBQUNwQixxQkFBUyxNQUFNLEdBQUcsTUFBTSxVQUFVLFNBQVMsR0FBRyxPQUFPO0FBQ25ELHlCQUFXLEtBQUssQ0FBQztBQUFBLFlBQ25CO0FBQUEsVUFDRixPQUFPO0FBQ0wscUJBQVMsTUFBTSxHQUFHLE1BQU0sVUFBVSxTQUFTLEdBQUcsT0FBTztBQUNuRCx5QkFBVyxLQUFLLGNBQWE7QUFBQSxnQkFDekIsVUFBVSxNQUFNLENBQUM7QUFBQSxnQkFBRyxRQUFRLEdBQUc7QUFBQSxnQkFBRyxVQUFVLEdBQUc7QUFBQSxnQkFBRyxZQUFZLEdBQUc7QUFBQSxnQkFBRztBQUFBLGdCQUFNO0FBQUEsZ0JBQUssTUFBTSxVQUFVLFNBQVM7QUFBQSxnQkFDeEc7QUFBQSxjQUFPLENBQUM7QUFBQSxZQUNkO0FBQUEsVUFDRjtBQUFBLFFBQ0Y7QUFBQTtBQUFBO0FBQUEsUUFJQSxPQUFlLHdCQUNYLFFBQWdCLFFBQWdCLFVBQWtCLFFBQWdCLE1BQWdCLGNBQ2xGLGNBQXNCLFNBQTBCO0FBQ2xELGdCQUFNLFVBQVUsWUFBWSxTQUFTLEtBQUs7QUFDMUMsY0FBSSxXQUFXLFlBQVksVUFBVTtBQUNuQyxvQkFBUSxTQUFTO0FBQUEsY0FDZixLQUFLO0FBQ0gscUJBQUssWUFBWSxJQUFJO0FBQ3JCLHFCQUFLLFlBQVksSUFBSTtBQUNyQix1QkFBTyxLQUFLLE9BQVEsU0FBUyxXQUFXLFNBQVUsQ0FBQztBQUFBLGNBQ3JELEtBQUs7QUFBQSxjQUNMLEtBQUs7QUFDSCxvQkFBSSxhQUFhLEdBQUc7QUFDbEIsd0JBQU0sSUFBSSxNQUFNLHFEQUFxRDtBQUFBLGdCQUN2RSxPQUFPO0FBQ0wsd0JBQU0sb0JBQW9CLFNBQVMsU0FBUyxLQUFLO0FBQ2pELHdCQUFNLGFBQWEsbUJBQW1CLEtBQUssU0FBUyxTQUFTO0FBQzdELHVCQUFLLFlBQVksSUFDWixZQUFZLGVBQWdCLEtBQUssT0FBTyxZQUFZLEtBQUssQ0FBQyxJQUFJLEtBQUssTUFBTSxZQUFZLENBQUM7QUFDM0YsdUJBQUssWUFBWSxJQUFJLFlBQVksS0FBSyxZQUFZO0FBQ2xELHlCQUFPLEtBQUssT0FBUSxTQUFTLFlBQVksVUFBVSxTQUFVLENBQUM7QUFBQSxnQkFDaEU7QUFBQSxjQUNGO0FBQ0Usc0JBQU0sSUFBSSxNQUFNLDBCQUEwQjtBQUFBLFlBQzlDO0FBQUEsVUFDRixPQUFPO0FBQ0wsbUJBQU8sS0FBSyxPQUFRLFNBQVMsS0FBSyxZQUFZLElBQUksS0FBSyxZQUFZLElBQUksV0FBVyxTQUFVLENBQUM7QUFBQSxVQUMvRjtBQUFBLFFBQ0Y7QUFBQSxNQUNGO0FBRU8sTUFBTSxXQUFOLE1BQWU7QUFBQTtBQUFBO0FBQUE7QUFBQSxRQUlwQixPQUFPLHFCQUNILFdBQThCLFdBQW9CLFlBQStCLFlBQ2pGLFdBQWtEO0FBQ3BELGNBQUksVUFBVSxXQUFXLEtBQUssV0FBVyxXQUFXLEdBQUc7QUFDckQsa0JBQU0sSUFBSSxNQUFNLDRCQUE0QjtBQUFBLFVBQzlDO0FBRUEsY0FBSTtBQUNKLGNBQUk7QUFDSixjQUFJO0FBRUosY0FBSSxXQUFXO0FBQ2IsZ0JBQUksVUFBVSxDQUFDO0FBQ2YsZ0JBQUksVUFBVSxDQUFDO0FBQUEsVUFDakIsT0FBTztBQUNMLGdCQUFJLFVBQVUsQ0FBQztBQUNmLGdCQUFJLFVBQVUsQ0FBQztBQUFBLFVBQ2pCO0FBRUEsY0FBSSxPQUFPO0FBRVgsY0FBSSxZQUFZO0FBQ2QsZ0JBQUksV0FBVyxDQUFDO0FBQ2hCLG1CQUFPO0FBQUEsVUFDVCxPQUFPO0FBQ0wsZ0JBQUksV0FBVyxDQUFDO0FBQ2hCLG1CQUFPO0FBQUEsVUFDVDtBQUVBLGNBQUksV0FBVyxJQUFJLE1BQU0sR0FBRztBQUMxQixrQkFBTSxJQUFJLE1BQU0sb0JBQW9CO0FBQUEsVUFDdEM7QUFFQSxjQUFJLEtBQUssS0FBSyxLQUFLLEtBQUssS0FBSyxHQUFHO0FBQzlCLGtCQUFNLElBQUksTUFBTSx5QkFBeUI7QUFBQSxVQUMzQztBQUVBLGNBQUksYUFBYSxDQUFDLGNBQWMsaUJBQWlCLFdBQVcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHO0FBQ25FLGtCQUFNLElBQUksTUFBTSx3Q0FBd0M7QUFBQSxVQUMxRDtBQUVBLGlCQUFPLENBQUMsR0FBRyxHQUFHLENBQUM7QUFBQSxRQUNqQjtBQUFBLE1BQ0Y7QUFHTyxNQUFNLFdBQVc7QUFDakIsTUFBTSxXQUFXO0FBQUE7QUFBQTs7O0FDcGN4QixNQWlCYSxnQkFzTVAsbUJBb0NPLDZCQUtBLDJCQUtBLDRCQU9BLGtCQWlCQSxZQWNBLFdBZ0JBLFdBa0JBLGNBc0JQLHFCQWlUTyxlQWFBLGdCQWFBLGtCQWdGUCxrQkF1SE8sb0JBWUEsa0JBZUE7QUFoNUJiO0FBQUE7QUFBQTtBQUdBO0FBQ0E7QUFhTyxNQUFNLGlCQUFpQjtBQXNNOUIsTUFBTSxvQkFBb0IsQ0FBQyxNQUFjLGVBQWlEO0FBQ3hGLFlBQUksZUFBZSxHQUFHO0FBQ3BCLGdCQUFNLElBQUksTUFBTSxtREFBbUQ7QUFBQSxRQUNyRTtBQUdBLGdCQUFRLE1BQU07QUFBQSxVQUNaO0FBQ0UsbUJBQU8sYUFBYSxJQUFJLE1BQU0sVUFBVSxVQUFVO0FBQUEsVUFDcEQ7QUFDRSxtQkFBTyxhQUFhLElBQUksTUFBTSxVQUFVLFVBQVU7QUFBQSxVQUNwRDtBQUNFLG1CQUFPLGFBQWEsSUFBSSxNQUFNLFVBQVUsVUFBVTtBQUFBLFVBQ3BEO0FBQ0UsbUJBQU8sYUFBYSxJQUFJLE1BQU0sVUFBVSxVQUFVO0FBQUEsVUFDcEQ7QUFDRSxnQkFBSSxhQUFhLEdBQUc7QUFDbEIsb0JBQU0sSUFBSSxNQUFNLDRDQUE0QztBQUFBLFlBQzlEO0FBQ0EsbUJBQU8sQ0FBQyxhQUFhLEtBQUs7QUFBQSxVQUM1QjtBQUNFLGdCQUFJLGFBQWEsR0FBRztBQUNsQixvQkFBTSxJQUFJLE1BQU0sNENBQTRDO0FBQUEsWUFDOUQ7QUFDQSxtQkFBTyxDQUFDLGFBQWEsS0FBSztBQUFBLFVBQzVCO0FBQ0UsZ0JBQUksZUFBZSxHQUFHO0FBQ3BCLG9CQUFNLElBQUksTUFBTSxtQkFBbUI7QUFBQSxZQUNyQztBQUNBLG1CQUFPLENBQUMsT0FBTyxZQUFZO0FBQUEsVUFFN0I7QUFDRSxrQkFBTSxJQUFJLE1BQU0sc0JBQXNCLElBQUksRUFBRTtBQUFBLFFBQ2hEO0FBQUEsTUFDRjtBQUVPLE1BQU0sOEJBQThCLENBQUMsTUFBZ0IsYUFBc0IsTUFBTTtBQUN0RixjQUFNLGFBQWEsa0JBQWtCLE1BQU0sVUFBVTtBQUNyRCxlQUFPLE9BQU8sZUFBZSxXQUFXLGFBQWEsV0FBVyxDQUFDO0FBQUEsTUFDbkU7QUFFTyxNQUFNLDRCQUE0QixDQUFDLE1BQWdCLGFBQXNCLE1BQU07QUFDcEYsY0FBTSxhQUFhLGtCQUFrQixNQUFNLFVBQVU7QUFDckQsZUFBTyxPQUFPLGVBQWUsV0FBVyxhQUFhLFdBQVcsQ0FBQztBQUFBLE1BQ25FO0FBRU8sTUFBTSw2QkFBNkIsQ0FBQyxTQUN2QyxLQUFLLFdBQVcsSUFBSSxDQUFDLElBQUksQ0FBQyxFQUFDLE1BQU0sVUFBVSxNQUFNLEtBQUksR0FBRyxFQUFDLE1BQU0sVUFBVSxNQUFNLFVBQVUsZUFBZSxJQUFJLEVBQUMsQ0FBQztBQU0zRyxNQUFNLG1CQUFtQixDQUFDLFNBQWlCO0FBRWhELFlBQUksT0FBTyxNQUFNLEdBQUc7QUFDbEIsaUJBQU87QUFBQSxRQUNULFdBQVcsT0FBTyxNQUFNLEdBQUc7QUFDekIsaUJBQU87QUFBQSxRQUNUO0FBRUEsZUFBTztBQUFBLE1BQ1Q7QUFRTyxNQUFNLGFBQWEsQ0FBQyxXQUFXLE9BQU8sWUFBcUIsUUFBUSxRQUFRO0FBQ2hGLFlBQUksQ0FBQyxjQUFjLGVBQWUsR0FBRztBQUNuQyxpQkFBTyxHQUFHLFFBQVEsSUFBSSxLQUFLO0FBQUEsUUFDN0I7QUFFQSxlQUFPLE1BQU0sVUFBVSxJQUFJLFFBQVEsS0FBSyxLQUFLO0FBQUEsTUFDL0M7QUFRTyxNQUFNLFlBQVksQ0FBQyxVQUFrQixZQUFvQixVQUFrQjtBQUNoRixZQUFJLGFBQWEsT0FBTztBQUN0QixpQkFBTztBQUFBLFFBQ1Q7QUFDQSxZQUFJLGVBQWUsR0FBRztBQUNwQixpQkFBTyxPQUFPLEtBQUs7QUFBQSxRQUNyQjtBQUVBLGVBQU8sTUFBTSxVQUFVLEtBQUssS0FBSztBQUFBLE1BQ25DO0FBT08sTUFBTSxZQUFZLENBQUMsTUFBYyxlQUF1QjtBQUM3RCxZQUFJLGVBQWUsR0FBRztBQUNwQixpQkFBTyxJQUFJLElBQUksUUFBUSxJQUFJLFFBQVEsSUFBSSxRQUFRLElBQUk7QUFBQSxRQUNyRCxXQUFXLGVBQWUsR0FBRztBQUMzQixpQkFBTyxJQUFJLElBQUksUUFBUSxJQUFJO0FBQUEsUUFDN0IsV0FBVyxlQUFlLEdBQUc7QUFDM0IsaUJBQU8sSUFBSSxJQUFJLFFBQVEsSUFBSSxRQUFRLElBQUk7QUFBQSxRQUN6QztBQUVBLGVBQU87QUFBQSxNQUNUO0FBUU8sTUFBTSxlQUFlLENBQUMsTUFBYyxPQUFzQixXQUEyQjtBQUMxRixZQUFJLEtBQUssV0FBVyxXQUFXLEtBQUssU0FBUyxHQUFHO0FBQzlDLGNBQUksT0FBUSxVQUFXLFVBQVU7QUFDL0IsbUJBQU8sR0FBRyxJQUFJLEtBQUssS0FBSyxXQUFXLEtBQUs7QUFBQSxVQUMxQyxPQUFPO0FBQ0wsbUJBQU8sR0FBRyxJQUFJLElBQUksS0FBSyxNQUFNLFFBQVEsQ0FBQyxDQUFDLEtBQUssUUFBUSxDQUFDO0FBQUEsVUFDdkQ7QUFBQSxRQUNGLE9BQU87QUFDTCxpQkFBTyxTQUFTLElBQUksR0FBRyxJQUFJLElBQUksS0FBSyxNQUFNO0FBQUEsUUFDNUM7QUFBQSxNQUNGO0FBWUEsTUFBTSxzQkFDRixDQUFDLE1BQWMsWUFBb0IsYUFBdUMsT0FDekUsZUFBdUM7QUFDdEMsY0FBTSxhQUFhLE9BQU8sZ0JBQWdCO0FBQzFDLGNBQU0sT0FBTyxhQUFhLGNBQWMsWUFBWTtBQUNwRCxjQUFNLGVBQWUsQ0FBQyxHQUFHLElBQUksTUFBTSxJQUFJLEVBQUUsS0FBSyxDQUFDO0FBQy9DLGNBQU0sY0FBYyxPQUFPLElBQUksUUFBUSxRQUFRLElBQUksTUFBTSxJQUFJLFVBQVUsY0FBYyxJQUFJO0FBQ3pGLGNBQU0sYUFBYSxrQkFBa0IsWUFBWSxVQUFVO0FBQzNELGNBQU0sWUFBWSxPQUFPLGVBQWUsV0FBVyxhQUFhLFdBQVcsQ0FBQztBQUM1RSxjQUFNLGNBQWMsT0FBTyxlQUFlLFdBQVcsYUFBYSxXQUFXLENBQUM7QUFDOUUsY0FBTSxPQUFPLEVBQUMsU0FBUyxhQUFhLE9BQU8sV0FBVyxTQUFTLGFBQWEsUUFBUSxXQUFVO0FBRTlGLGNBQU0sZUFBZSxDQUFDLFFBQStCLE9BQU8sUUFBUSxXQUFXLE1BQU0sR0FBRyxHQUFHO0FBRTNGLGNBQU0scUJBQXFCO0FBQUEsVUFDekIsaUJBQWlCO0FBQUEsVUFDakIsaUJBQWlCO0FBQUEsVUFDakIsNEJBQTRCO0FBQUEsVUFDNUIsS0FBSztBQUFBLFVBQ0wsY0FBYztBQUFBLFVBQ2QsS0FBSztBQUFBLFVBQ0wsY0FBYztBQUFBLFFBQ2hCO0FBRUEsY0FBTSxnQkFBZ0IsYUFBYSxjQUFjO0FBQ2pELGNBQU0sUUFBUSxHQUFHLGFBQWEsR0FBRyxJQUFJO0FBQ3JDLGNBQU0sVUFBVSxHQUFHLGFBQWEsR0FBRyxJQUFJO0FBRXZDLFlBQUksYUFBYTtBQUNqQixpQkFBUyxJQUFJLEdBQUcsSUFBSSxPQUFPLEdBQUcsS0FBSztBQUNqQyx3QkFBYztBQUFBLGFBQ1QsQ0FBQyxnQkFBZ0IsYUFBYSxTQUFTLEdBQUcsSUFBSSxDQUFDO0FBQUEsY0FDOUMsQ0FBQyxnQkFBZ0IsYUFBYSxTQUFTLEdBQUcsSUFBSSxDQUFDO0FBQUEsY0FDL0MsQ0FBQyxVQUFVLENBQUM7QUFBQSxvQkFDTixDQUFDO0FBQUE7QUFBQSxRQUVmO0FBQ0Esc0JBQWMsV0FBVyxPQUFPLENBQUM7QUFFakMsY0FBTSxnQ0FBZ0MsT0FBTyxJQUFJLEtBQUs7QUFBQSxXQUNqRCxJQUFJLG9CQUFvQixLQUFLLE9BQU87QUFBQSxtQkFDNUIsS0FBSyxPQUFPO0FBQUE7QUFBQSxNQUV6QixVQUFVO0FBQUE7QUFBQTtBQUlWLGNBQU0sa0JBQWtCLENBQUMsY0FBc0I7QUFDN0MsNkJBQW1CLGtCQUFrQjtBQUNyQyxpQkFBTyxPQUFPLElBQUksWUFBWSxPQUFPLElBQUksSUFBSSxTQUFTO0FBQUEsUUFDeEQ7QUFFQSxjQUFNLFVBQW9CLENBQUM7QUFDM0IsWUFBSSxRQUFRLEdBQUc7QUFDYixtQkFBUyxJQUFJLE9BQU8sR0FBRyxLQUFLLEdBQUcsS0FBSztBQUNsQyxvQkFBUSxLQUFLLEdBQUcsYUFBYSxTQUFTLEdBQUcsSUFBSSxDQUFDLGVBQWUsQ0FBQyxJQUFJO0FBQUEsVUFDcEU7QUFBQSxRQUNGO0FBRUEsY0FBTSxnQ0FBZ0MsT0FBTyxJQUFJLEtBQUs7QUFBQSxXQUNqRCxJQUFJLGFBQWEsS0FBSyxPQUFPO0FBQUEsYUFDM0IsUUFBUSxLQUFLLEdBQUcsQ0FBQztBQUFBO0FBR3hCLGNBQU0sa0JBQWtCLENBQUMsZUFBdUI7QUFDOUMsNkJBQW1CLGtCQUFrQjtBQUNyQyxpQkFBTyxPQUFPLElBQUksYUFBYSxPQUFPLElBQUksSUFBSSxVQUFVO0FBQUEsUUFDMUQ7QUFFQSxjQUFNLFVBQVUsSUFBSUMsVUFDaEIsU0FBUyxJQUFJLE9BQU8sR0FBRyxLQUFLLE9BQU8sSUFBSUEsTUFBSyxJQUFJLFlBQVksRUFBRSxLQUFLLEdBQUcsQ0FBQztBQUUzRSxjQUFNLGFBQWEsQ0FBQyxZQUFvQixRQUF1QjtBQUM3RCxjQUFJLE9BQU8sR0FBRztBQUNaLG1CQUFPLEdBQUcsVUFBVTtBQUFBLFVBQ3RCLE9BQU87QUFDTCxtQkFBTyxHQUFHLGFBQWEsWUFBWSxLQUFLLElBQUksQ0FBQztBQUFBLFVBQy9DO0FBQUEsUUFDRjtBQUVBLGNBQU0sYUFBYSxDQUFDLFlBQW9CLEtBQW9CLFVBQWtCO0FBQzVFLGNBQUksT0FBTyxHQUFHO0FBQ1osbUJBQU8sR0FBRyxVQUFVLElBQUksS0FBSztBQUFBLFVBQy9CLE9BQU87QUFDTCxtQkFBTyxHQUFHLGFBQWEsWUFBWSxLQUFLLElBQUksQ0FBQyxJQUFJLEtBQUs7QUFBQSxVQUN4RDtBQUFBLFFBQ0Y7QUFFQSxjQUFNLDJDQUFvRSxDQUFDO0FBQzNFLGNBQU0sNkJBQTZCLENBQUMsWUFBb0IsV0FBMEI7QUFDaEYsNkJBQW1CLDZCQUE2QjtBQUNoRCxnQkFBTSxVQUFVLEdBQUcsT0FBTyxJQUFJLHVCQUF1QixJQUFJO0FBQ3pELGNBQUksV0FBVywwQ0FBMEM7QUFDdkQsbUJBQU8sR0FBRyxPQUFPLElBQUksVUFBVTtBQUFBLFVBQ2pDO0FBQ0EsZ0JBQU1DLFdBQVUsQ0FBQztBQUNqQixtQkFBUyxJQUFJLE9BQU8sR0FBRyxLQUFLLEdBQUcsS0FBSztBQUNsQyxrQkFBTSxNQUFNLE9BQU8sV0FBVyxpQkFBaUIsSUFBSSxPQUFPLE9BQU8sSUFBSTtBQUNyRSxZQUFBQSxTQUFRLEtBQUssR0FBRyxXQUFXLFNBQVMsQ0FBQyxDQUFDLE9BQU8sR0FBRyxNQUFNLFdBQVcsT0FBTyxDQUFDLENBQUMsR0FBRztBQUFBLFVBQy9FO0FBQ0EsbURBQXlDLE9BQU8sSUFDNUMsTUFBTSxPQUFPLG1CQUFtQixPQUFPLEtBQUssT0FBTztBQUFBLHNCQUN6Q0EsU0FBUSxTQUFTLElBQUlBLFNBQVEsS0FBSyxHQUFHLElBQUksSUFBSTtBQUFBO0FBRzNELGlCQUFPLEdBQUcsT0FBTyxJQUFJLFVBQVU7QUFBQSxRQUNqQztBQUVBLGNBQU0sY0FBYyxDQUFDLFFBQXVCLFdBQW1CLE1BQU07QUFDbkUsY0FBSSxLQUFLLFlBQVksS0FBSyxPQUFPO0FBQy9CLG1CQUFPLEdBQUcsSUFBSSxJQUFJLE1BQU0sS0FBSyxLQUFLO0FBQUEsVUFDcEMsV0FBVyxLQUFLLFlBQVksZUFBZSxLQUFLLFVBQVUsT0FBTztBQUUvRCxtQkFBTyxHQUFHLElBQUksSUFBSSxNQUFNLG1CQUFtQixLQUFLLDhCQUE4QixLQUFLO0FBQUEsVUFDckYsV0FBVyxLQUFLLFlBQVksZUFBZSxLQUFLLFVBQVUsT0FBTztBQUUvRCxtQkFBTyxHQUFHLElBQUksSUFBSSxNQUFNLG1CQUFtQixLQUFLO0FBQUEsVUFDbEQsV0FBVyxLQUFLLFlBQVksU0FBUyxLQUFLLFVBQVUsY0FBYztBQUVoRSxtQkFBTyxHQUFHLElBQUksSUFBSSxNQUFNLDhEQUE4RCxLQUFLO0FBQUEsVUFDN0YsT0FBTztBQUNMLGtCQUFNLElBQUksTUFBTSw2Q0FBNkMsS0FBSyxPQUFPLG1CQUFtQixLQUFLLEtBQUssTUFBTTtBQUFBLFVBQzlHO0FBQUEsUUFDRixHQUFHO0FBRUgsY0FBTSxjQUFjLENBQUMsWUFBMkIsTUFBTTtBQUNwRCxjQUFJLEtBQUssWUFBWSxLQUFLLE9BQU87QUFDL0IsbUJBQU8sR0FBRyxJQUFJLElBQUksTUFBTTtBQUFBLFVBQzFCLFdBQVcsS0FBSyxZQUFZLGVBQWUsS0FBSyxVQUFVLE9BQU87QUFFL0QsbUJBQU8sT0FBTyxJQUFJLElBQUksTUFBTTtBQUFBLFVBQzlCLFdBQVcsS0FBSyxZQUFZLGVBQWUsS0FBSyxVQUFVLE9BQU87QUFFL0QsbUJBQU8sT0FBTyxJQUFJLElBQUksTUFBTTtBQUFBLFVBQzlCLFdBQVcsS0FBSyxZQUFZLFNBQVMsS0FBSyxVQUFVLGNBQWM7QUFFaEUsbUJBQU8sbUJBQW1CLElBQUksSUFBSSxNQUFNLG9CQUFvQixJQUFJLElBQUksTUFBTSxzQkFBc0IsSUFBSSxJQUNoRyxNQUFNLHdCQUF3QixJQUFJLElBQUksTUFBTTtBQUFBLFVBQ2xELE9BQU87QUFDTCxrQkFBTSxJQUFJLE1BQU0sNkNBQTZDLEtBQUssT0FBTyxtQkFBbUIsS0FBSyxLQUFLLE1BQU07QUFBQSxVQUM5RztBQUFBLFFBQ0YsR0FBRztBQUVILGNBQU0sNkJBQTZCLE9BQU8sSUFBSSxLQUFLO0FBQUEsV0FDOUMsSUFBSSxzQkFBc0IsS0FBSyxPQUFPLFFBQVEsU0FBUztBQUFBLGFBQ3JELFlBQVksT0FBTyxJQUFJLFdBQVcsQ0FBQztBQUFBO0FBRzFDLGNBQU0sb0JBQW9CLE9BQU8sSUFBSSxNQUFNLE1BQU07QUFDL0MsZ0JBQU0saUJBQWlCLGFBQWEsSUFBSSxPQUFLLElBQUksQ0FBQyxPQUFPLEVBQUUsS0FBSyxJQUFJO0FBQ3BFLGdCQUFNLGFBQWEsYUFBYSxJQUFJLE9BQUssSUFBSSxDQUFDLEVBQUUsRUFBRSxLQUFLLElBQUk7QUFDM0QsaUJBQU87QUFBQSxXQUNKLElBQUksSUFBSSxjQUFjLFFBQVEsU0FBUztBQUFBLGlCQUNqQyxJQUFJLGFBQWEsUUFBUSxVQUFVLENBQUM7QUFBQTtBQUFBLFFBRS9DLEdBQUc7QUFFSCxjQUFNLE1BQU0sSUFBSUMsYUFBMEM7QUFDeEQsY0FBSUEsU0FBUSxXQUFXLE1BQU07QUFDM0Isa0JBQU0sSUFBSSxNQUFNLDBCQUEwQixJQUFJLEVBQUU7QUFBQSxVQUNsRDtBQUVBLGdCQUFNLG9CQUFvQkEsU0FBUSxJQUFJLFlBQVksRUFBRSxLQUFLLEdBQUc7QUFFNUQsY0FBSSxTQUFTLEdBQUc7QUFDZCxtQkFBTyxZQUFZLElBQUk7QUFBQSxVQUN6QixXQUFXLFNBQVMsR0FBRztBQUNyQixtQkFBTyxZQUFZLGtCQUFrQixDQUFDLENBQUM7QUFBQSxVQUN6QyxPQUFPO0FBQ0wsK0JBQW1CLE1BQU07QUFDekIsK0JBQW1CLGVBQWU7QUFDbEMsK0JBQW1CLGtCQUFrQjtBQUNyQyxtQkFBTyxPQUFPLElBQUksSUFBSSxpQkFBaUI7QUFBQSxVQUN6QztBQUFBLFFBQ0Y7QUFFQSxjQUFNLGVBQWUsQ0FBQyxlQUF1QjtBQUMzQyxjQUFJLE9BQU8sR0FBRztBQUNaLG1CQUFPLFlBQVksVUFBVTtBQUFBLFVBQy9CLE9BQU87QUFDTCwrQkFBbUIsZUFBZTtBQUNsQywrQkFBbUIsa0JBQWtCO0FBQ3JDLG1CQUFPLE9BQU8sSUFBSSxhQUFhLFVBQVU7QUFBQSxVQUMzQztBQUFBLFFBQ0Y7QUFFQSxjQUFNLDZCQUE2QixPQUFPLElBQUksS0FBSztBQUFBLFdBQzlDLElBQUksc0JBQXNCLEtBQUssT0FBTyxZQUFZLFNBQVM7QUFBQSxNQUNoRSxZQUFZLE9BQU8sSUFBSSxhQUFhLE9BQU8sQ0FBQztBQUFBO0FBRzVDLGNBQU0sb0JBQW9CLE9BQU8sSUFBSSxNQUFNLE1BQU07QUFDL0MsZ0JBQU0saUJBQWlCLGFBQWEsSUFBSSxPQUFLLElBQUksQ0FBQyxPQUFPLEVBQUUsS0FBSyxJQUFJO0FBQ3BFLGdCQUFNLGFBQWEsYUFBYSxJQUFJLE9BQUssSUFBSSxDQUFDLEVBQUUsRUFBRSxLQUFLLElBQUk7QUFDM0QsaUJBQU87QUFBQSxXQUNKLElBQUksSUFBSSxjQUFjLFlBQVksU0FBUztBQUFBLFVBQzVDLElBQUksYUFBYSxRQUFRLFVBQVUsQ0FBQztBQUFBO0FBQUEsUUFFeEMsR0FBRztBQUVILGNBQU0sTUFBTSxJQUFJLG9CQUFrRDtBQUNoRSxjQUFJLGdCQUFnQixXQUFXLE9BQU8sR0FBRztBQUN2QyxrQkFBTSxJQUFJLE1BQU0sMEJBQTBCLElBQUksRUFBRTtBQUFBLFVBQ2xEO0FBQ0EsZ0JBQU0sUUFBUSxnQkFBZ0IsSUFBSTtBQUNsQyxjQUFJLE9BQU8sVUFBVSxVQUFVO0FBQzdCLGtCQUFNLElBQUksTUFBTSxzQkFBc0I7QUFBQSxVQUN4QztBQUVBLGdCQUFNLG9CQUFvQixnQkFBZ0IsTUFBTSxHQUFHLElBQUksRUFBRSxJQUFJLFlBQVksRUFBRSxLQUFLLEdBQUc7QUFFbkYsY0FBSSxTQUFTLEdBQUc7QUFDZCxtQkFBTyxZQUFZLE1BQU0sS0FBSztBQUFBLFVBQ2hDLFdBQVcsU0FBUyxHQUFHO0FBQ3JCLG1CQUFPLFlBQVksa0JBQWtCLENBQUMsR0FBRyxLQUFLO0FBQUEsVUFDaEQsT0FBTztBQUNMLCtCQUFtQixNQUFNO0FBQ3pCLCtCQUFtQixlQUFlO0FBQ2xDLCtCQUFtQixrQkFBa0I7QUFDckMsbUJBQU8sT0FBTyxJQUFJLElBQUksaUJBQWlCLEtBQUssS0FBSztBQUFBLFVBQ25EO0FBQUEsUUFDRjtBQUVBLGNBQU0sZUFBZSxDQUFDLFlBQW9CLFVBQWtCO0FBQzFELGNBQUksT0FBTyxHQUFHO0FBQ1osbUJBQU8sWUFBWSxZQUFZLEtBQUs7QUFBQSxVQUN0QyxPQUFPO0FBQ0wsK0JBQW1CLGVBQWU7QUFDbEMsK0JBQW1CLGtCQUFrQjtBQUNyQyxtQkFBTyxPQUFPLElBQUksYUFBYSxVQUFVLEtBQUssS0FBSztBQUFBLFVBQ3JEO0FBQUEsUUFDRjtBQUVBLGNBQU0sT0FBTyxNQUFNO0FBQ2pCLGdCQUFNLFFBQVEsQ0FBQztBQUNmLGNBQUksbUJBQW1CO0FBQ3ZCLGNBQUksbUJBQW1CLGlCQUFpQjtBQUN0QyxrQkFBTSxLQUFLLDZCQUE2QjtBQUN4QywrQkFBbUI7QUFBQSxVQUNyQjtBQUNBLGNBQUksbUJBQW1CLGlCQUFpQjtBQUN0QyxrQkFBTSxLQUFLLDZCQUE2QjtBQUN4QywrQkFBbUI7QUFBQSxVQUNyQjtBQUNBLGNBQUksbUJBQW1CLDRCQUE0QjtBQUNqRCxtQkFBTyxPQUFPLHdDQUF3QyxFQUFFLFFBQVEsQ0FBQUMsVUFBUSxNQUFNLEtBQUtBLEtBQUksQ0FBQztBQUN4RiwrQkFBbUI7QUFBQSxVQUNyQjtBQUNBLGNBQUksbUJBQW1CLEtBQUs7QUFDMUIsa0JBQU0sS0FBSyxpQkFBaUI7QUFDNUIsK0JBQW1CO0FBQUEsVUFDckI7QUFDQSxjQUFJLG1CQUFtQixjQUFjO0FBQ25DLGtCQUFNLEtBQUssMEJBQTBCO0FBQ3JDLCtCQUFtQjtBQUFBLFVBQ3JCO0FBQ0EsY0FBSSxtQkFBbUIsS0FBSztBQUMxQixrQkFBTSxLQUFLLGlCQUFpQjtBQUM1QiwrQkFBbUI7QUFBQSxVQUNyQjtBQUNBLGNBQUksbUJBQW1CLGNBQWM7QUFDbkMsa0JBQU0sS0FBSywwQkFBMEI7QUFDckMsK0JBQW1CO0FBQUEsVUFDckI7QUFDQSxjQUFJLENBQUMsY0FBYyxrQkFBa0I7QUFDbkMsa0JBQU07QUFBQSxjQUNGLFNBQVMsS0FBSyxNQUFNLEtBQUssT0FBTyxJQUFJLFlBQVksS0FBSyxHQUFHLENBQUM7QUFBQSxjQUN6RCxTQUFTLE9BQU8sTUFBTSxLQUFLLE9BQU8sSUFBSSxVQUFVLGVBQWUsV0FBVyxFQUFFLEtBQUssR0FBRyxDQUFDO0FBQUEsWUFBSTtBQUFBLFVBQy9GO0FBQ0EsaUJBQU8sTUFBTSxLQUFLLElBQUk7QUFBQSxRQUN4QjtBQUVBLGVBQU87QUFBQSxVQUNMO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBO0FBQUEsVUFFQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxRQUNGO0FBQUEsTUFDRjtBQVdHLE1BQU0sZ0JBQ1QsQ0FBQyxNQUFjLE1BQWMsYUFBdUMsYUFBc0IsTUFDdEYsb0JBQW9CLE1BQU0sTUFBTSxhQUFhLFNBQVMsVUFBVTtBQVdqRSxNQUFNLGlCQUNULENBQUMsTUFBYyxNQUFjLGFBQXVDLGFBQXNCLE1BQ3RGLG9CQUFvQixNQUFNLE1BQU0sYUFBYSxVQUFVLFVBQVU7QUFXbEUsTUFBTSxtQkFDVCxDQUFDLE1BQWMsTUFBYyxhQUF1QyxhQUFzQixNQUN0RixvQkFBb0IsTUFBTSxNQUFNLGFBQWEsWUFBWSxVQUFVO0FBOEUzRSxNQUFNLG1CQUFOLE1BQStDO0FBQUEsUUFDN0MsWUFBb0IseUJBQW1EO0FBQW5EO0FBcUZwQixlQUFRLG9CQUFxQyxDQUFDO0FBQzlDLGVBQVEsWUFBNkIsQ0FBQztBQUN0QyxlQUFRLFdBQThCLENBQUM7QUFvQnZDLGVBQVEsZ0JBQWdCO0FBQUEsUUEzR2dEO0FBQUEsUUFFeEUsc0NBQXNDLE1BQTZCO0FBRWpFLGdCQUFNLGFBQWEsT0FBTyxTQUFTLFdBQVcsR0FBRyxJQUFJLE1BQU07QUFDM0QsaUJBQU8scUJBQXFCLFVBQVU7QUFBQSxRQUN4QztBQUFBLFFBRUEsVUFBVSxnQkFBaUQsZ0JBQWdCO0FBQ3pFLGdCQUFNLGlCQUFpQixPQUFPLGtCQUFrQixXQUFXLGdCQUFnQixjQUFjLENBQUM7QUFDMUYsZ0JBQU0saUJBQWlCLE9BQU8sa0JBQWtCLFdBQVcsSUFBSSxjQUFjLENBQUM7QUFDOUUsZ0JBQU0saUJBQWlCLE9BQU8sa0JBQWtCLFdBQVcsSUFBSSxjQUFjLENBQUM7QUFFOUUsZ0JBQU0sdUJBQXVCLEtBQUssd0JBQXdCLENBQUMsTUFBTSxLQUFLLEtBQUssd0JBQXdCLENBQUMsTUFBTTtBQUMxRyxnQkFBTSxZQUFZLHVCQUF1QjtBQUFBO0FBQUEsMERBR0E7QUFBQTtBQUFBO0FBQUE7QUFJekMsZ0JBQU0sc0JBQXNCLHVCQUN4Qiw4REFDQTtBQUFBLG1FQUVJLGlCQUFpQixpQkFBaUIsY0FBYztBQUV4RCxpQkFBTyw0QkFBNEIsY0FBYyxLQUFLLGNBQWMsS0FBSyxjQUFjO0FBQUEsWUFDL0UsU0FBUztBQUFBLE1BQ2YsbUJBQW1CO0FBQUE7QUFBQSxRQUV2QjtBQUFBLFFBRVEsdUJBQXVCLFVBQStCO0FBQzVELGNBQUksU0FBUyxTQUFTLEdBQUc7QUFDdkIsZ0JBQUksU0FBUyxNQUFNLFdBQVcsV0FBVyxHQUFHO0FBQzFDLG1CQUFLLFNBQVMsS0FBSyxFQUFDLE1BQU0sU0FBUyxNQUFNLFFBQVEsYUFBYSxFQUFFLEdBQUcsTUFBTSxPQUFPLFFBQVEsU0FBUyxLQUFJLENBQUM7QUFBQSxZQUN4RztBQUNBLGdCQUFJLFNBQVMsUUFBUSxXQUFXLFdBQVcsR0FBRztBQUM1QyxtQkFBSyxTQUFTLEtBQUssRUFBQyxNQUFNLFNBQVMsUUFBUSxRQUFRLGFBQWEsRUFBRSxHQUFHLE1BQU0sT0FBTyxRQUFRLFNBQVMsS0FBSSxDQUFDO0FBQUEsWUFDMUc7QUFBQSxVQUNGO0FBQUEsUUFDRjtBQUFBLFFBRVEsZ0JBQWdCLFVBQXlCLGNBQThCO0FBQzdFLGNBQUksU0FBUyxVQUFVLFlBQVk7QUFDakMsa0JBQU0sSUFBSSxNQUFNLCtGQUErRjtBQUFBLFVBQ2pIO0FBQ0EsZUFBSyxVQUFVLEtBQUssUUFBUTtBQUM1QixlQUFLLHVCQUF1QixRQUFRO0FBRXBDLGdCQUFNLFNBQVMsU0FBUyxVQUFVLFVBQVUsU0FBUztBQUNyRCxnQkFBTSxjQUFjLFNBQVMsS0FBSztBQUNsQyxpQkFBTyxzQkFBc0IsWUFBWSxrQkFBa0IsTUFBTSxLQUFLLFNBQVMsSUFBSSxXQUFXLFdBQVc7QUFBQSxRQUMzRztBQUFBLFFBRUEsb0JBQW9CLFdBQW9DO0FBQ3RELGlCQUFPLFVBQVUsSUFBSSxPQUFLLEtBQUssZ0JBQWdCLEdBQUcsS0FBSyxlQUFlLENBQUMsRUFBRSxLQUFLLElBQUk7QUFBQSxRQUNwRjtBQUFBLFFBRVEseUJBQXlCLFVBQStCO0FBQzlELGNBQUksU0FBUyxVQUFVLFlBQVk7QUFDakMsa0JBQU0sSUFBSTtBQUFBLGNBQ047QUFBQSxZQUFzRztBQUFBLFVBQzVHO0FBRUEsZUFBSyxrQkFBa0IsS0FBSyxRQUFRO0FBQ3BDLGVBQUssdUJBQXVCLFFBQVE7QUFBQSxRQUN0QztBQUFBLFFBRUEsNkJBQTZCLFdBQTBDO0FBQ3JFLG9CQUFVLFFBQVEsT0FBSyxLQUFLLHlCQUF5QixDQUFDLENBQUM7QUFDdkQsaUJBQU87QUFBQSxRQUNUO0FBQUEsUUFFQSxnQkFBZ0IsTUFBYyxNQUE4QixTQUFTLEdBQWlCO0FBQ3BGLGVBQUssU0FBUyxLQUFLLEVBQUMsTUFBTSxNQUFNLE9BQU0sQ0FBQztBQUN2QyxpQkFBTztBQUFBLFFBQ1Q7QUFBQSxRQUVBLGlCQUFpQixvQkFBcUQ7QUFDcEUsZUFBSyxXQUFXLEtBQUssU0FBUyxPQUFPLGtCQUFrQjtBQUN2RCxpQkFBTztBQUFBLFFBQ1Q7QUFBQSxRQUtRLHFCQUE2QjtBQUNuQyxjQUFJLEtBQUssU0FBUyxXQUFXLEdBQUc7QUFDOUIsbUJBQU87QUFBQSxVQUNUO0FBRUEsZ0JBQU0sa0JBQTRCLENBQUM7QUFDbkMscUJBQVcsRUFBQyxNQUFNLE1BQU0sT0FBTSxLQUFLLEtBQUssVUFBVTtBQUNoRCxnQkFBSSxVQUFVLFNBQVMsR0FBRztBQUN4Qiw4QkFBZ0IsS0FBSyxHQUFHLElBQUksZUFBZSxJQUFJLE1BQU0sS0FBSyxLQUFLLFNBQVMsQ0FBQyxDQUFDLEdBQUc7QUFBQSxZQUMvRSxPQUFPO0FBQ0wsb0JBQU0sV0FBVyxVQUFVLFFBQVEsV0FBVyxJQUFJLE9BQU8sTUFBTSxNQUFNLElBQUksSUFBSTtBQUM3RSw4QkFBZ0IsS0FBSyxHQUFHLElBQUksSUFBSSxRQUFRLEVBQUU7QUFBQSxZQUM1QztBQUFBLFVBQ0Y7QUFFQSxpQkFBTztBQUFBLDBCQUNlLGdCQUFnQixLQUFLLElBQUksQ0FBQztBQUFBLDJCQUN6QixLQUFLLGFBQWE7QUFBQSxRQUMzQztBQUFBO0FBQUE7QUFBQTtBQUFBLFFBTUEsSUFBSSw0QkFBb0M7QUFDdEMsaUJBQU8sS0FBSyxtQkFBbUIsSUFBSSxLQUFLLFVBQVUsSUFBSSxPQUFLLEVBQUUsS0FBSyxDQUFDLEVBQUUsS0FBSyxJQUFJLElBQzFFLEtBQUssa0JBQWtCLElBQUksT0FBSyxFQUFFLEtBQUssQ0FBQyxFQUFFLEtBQUssSUFBSTtBQUFBLFFBQ3pEO0FBQUEsTUFDRjtBQUVPLE1BQU0scUJBQXFCLENBQUMsa0JBQTRDLElBQUksaUJBQWlCLGFBQWE7QUFZMUcsTUFBTSxtQkFBbUIsQ0FBQyxTQUE0QixhQUEwQztBQUNyRyxjQUFNLFNBQVMsUUFBUTtBQUN2QixjQUFNLE9BQWlCLENBQUM7QUFDeEIsaUJBQVMsSUFBSSxHQUFHLElBQUksUUFBUSxLQUFLO0FBQy9CLGdCQUFNLE1BQU0sU0FBUyxJQUFJO0FBQ3pCLGdCQUFNLElBQUksUUFBUSxHQUFHLEtBQUs7QUFDMUIsZ0JBQU0sSUFBSSxTQUFTLFNBQVMsU0FBUyxJQUFJLENBQUMsS0FBSztBQUMvQyxjQUFJLElBQUksS0FBSyxNQUFNLEdBQUc7QUFDcEIsaUJBQUssUUFBUSxHQUFHO0FBQUEsVUFDbEI7QUFBQSxRQUNGO0FBQ0EsZUFBTztBQUFBLE1BQ1Q7QUFHTyxNQUFNLHVCQUF1QixDQUFDLFVBQTJCO0FBQUE7QUFBQTs7O0FDaDVCaEUsTUFjTSxnQkFNQSxpQkFHQSxnQkFHQSxrQkFXTyw0QkErQ0EsV0FLQTtBQXpGYjtBQUFBO0FBQUE7QUFJQTtBQUNBO0FBR0E7QUFNQSxNQUFNLGlCQUFpQixDQUFDLFdBQXdDO0FBQzlELFlBQUksQ0FBQyxVQUFVLE9BQU8sV0FBVyxHQUFHO0FBQ2xDLGdCQUFNLElBQUksTUFBTSw2QkFBNkI7QUFBQSxRQUMvQztBQUFBLE1BQ0Y7QUFFQSxNQUFNLGtCQUFrQixDQUFDLFdBQW1CLFNBQ3ZDLFFBQVEsS0FBSyxXQUFXLFlBQWEsQ0FBQyxHQUFJLElBQUksTUFBTSxTQUFTLEVBQUUsS0FBSyxDQUFFLEVBQUUsUUFBUSxJQUFJO0FBRXpGLE1BQU0saUJBQWlCLENBQUMsWUFBK0IsU0FDbkQsVUFBVSxnQkFBZ0IsWUFBWSxnQkFBZ0IsV0FBVyxRQUFRLElBQUksQ0FBQztBQUVsRixNQUFNLG1CQUFtQixDQUFDLE1BQWdCLE1BQWMsT0FBc0IsV0FBa0M7QUFDOUcsY0FBTSxjQUFjLENBQUM7QUFDckIsb0JBQVksS0FBSyxjQUFjLE9BQU8sS0FBSyxPQUFPLFFBQVEsTUFBTSxLQUFLLE9BQU87QUFBQSxhQUNqRSxNQUFNLEtBQUssT0FBTyxHQUFHO0FBQ2hDLGlCQUFTLElBQUksR0FBRyxJQUFJLE1BQU0sRUFBRSxHQUFHO0FBQzdCLHNCQUFZLEtBQUssTUFBTSxXQUFXLEtBQUssS0FBSyxDQUFDLEdBQUcsS0FBSyxDQUFDLEdBQUcsQ0FBQztBQUFBLFFBQzVEO0FBQ0Esb0JBQVksS0FBSyxZQUFZO0FBQzdCLGVBQU8sWUFBWSxLQUFLLElBQUk7QUFBQSxNQUM5QjtBQUVPLE1BQU0sNkJBQTZCLENBQUMsYUFBeUIsYUFBb0M7QUFDdEcsY0FBTSxnQkFBZ0IsWUFBWTtBQUNsQyxjQUFNLFlBQVksWUFBWSxLQUFLO0FBQ25DLGNBQU0sT0FBTyxnQkFBZ0IsV0FBVyxRQUFRO0FBQ2hELGNBQU0sb0JBQW9CLHFCQUFxQixTQUFTO0FBQ3hELGNBQU0sY0FBYyxlQUFlLFlBQVksTUFBTSxJQUFJO0FBQ3pELGNBQU0saUJBQWlCLG9CQUFvQixZQUFZLFNBQVM7QUFDaEUsY0FBTSxnQkFBZ0Isb0JBQW9CLFlBQVksWUFBWTtBQUNsRSxjQUFNLFNBQVMsZUFBZSxVQUFVLGVBQWUsY0FBYztBQUNyRSxjQUFNLFFBQVEsY0FBYyxLQUFLLGVBQWUsYUFBYTtBQUU3RCxjQUFNLGtCQUFrQixDQUFDLGlCQUErQjtBQUFBLElBQ3RELGFBQWEsZ0JBQWdCLGVBQWUsS0FBSyxFQUFFLGlCQUFpQixPQUFPLE1BQU0sQ0FBQztBQUFBO0FBQUEsSUFFbEYsaUJBQWlCLE1BQU0sV0FBVyxPQUFPLE1BQU0sQ0FBQztBQUFBO0FBQUEsSUFFaEQsYUFBYSxVQUFVLENBQUM7QUFBQSxNQUN0QixhQUFhLHNDQUFzQyxzQkFBc0IsQ0FBQztBQUFBO0FBQUEsb0JBRTVELE9BQU8sZ0JBQWdCLFlBQVksQ0FBQztBQUFBO0FBQUE7QUFBQSxNQUdsRCxPQUFPLFlBQVksY0FBYyxNQUFNLGFBQWEsVUFBVSxDQUFDLENBQUM7QUFBQTtBQUVwRSxlQUFPO0FBQUEsVUFDTCxNQUFNO0FBQUEsVUFDTixhQUFhLEVBQUMsTUFBTSxHQUFHLFFBQVEsSUFBSSxtQkFBbUIsb0JBQW9CLENBQUMsTUFBTSxJQUFJLENBQUMsTUFBTSxFQUFDO0FBQUEsVUFDN0YsWUFBWSxDQUFDLFdBQVc7QUFDdEIsa0JBQU0sYUFBYSxVQUFVLEtBQUssV0FBVztBQUM3QyxtQkFBTztBQUFBLGNBQ0wsU0FBUyxDQUFDLEVBQUMsTUFBTSxhQUFhLFVBQVUsT0FBTyxDQUFDLEVBQUUsU0FBUSxDQUFDO0FBQUEsY0FDM0QsZUFBZSxFQUFDLEdBQUcsS0FBSztBQUFBLGdCQUFLLGFBQWE7QUFBQTtBQUFBLGNBQXVCLEVBQUM7QUFBQSxjQUNsRSxpQkFBaUIsb0JBQ2I7QUFBQSxnQkFDRSxFQUFDLE1BQU0sVUFBVSxNQUFNLFdBQVU7QUFBQSxnQkFDakMsR0FBRywyQkFBMkIsT0FBTyxDQUFDLEVBQUUsSUFBSTtBQUFBLGdCQUM1QyxHQUFHLDJCQUEyQixXQUFXO0FBQUEsY0FDM0MsSUFDQTtBQUFBLGdCQUNFLEVBQUMsTUFBTSxVQUFVLE1BQU0sV0FBVTtBQUFBLGNBQ25DO0FBQUEsWUFDTjtBQUFBLFVBQ0Y7QUFBQSxVQUNBO0FBQUEsUUFDRjtBQUFBLE1BQ0Y7QUFFTyxNQUFNLFlBQVksQ0FBQyxTQUF5QixlQUEwQztBQUMzRix1QkFBZSxRQUFRLE1BQU07QUFDN0IsZ0JBQVEsUUFBUSwyQkFBMkIsUUFBUSxPQUFPLENBQUMsR0FBRyxXQUFXLElBQUksQ0FBQztBQUFBLE1BQ2hGO0FBRU8sTUFBTSwyQkFBMkIsQ0FBQyxlQUNyQyw0QkFBNEIsRUFBQyxNQUFNLFdBQVcsS0FBZ0IsQ0FBQztBQUFBO0FBQUE7OztBQzFGbkUsTUFZTSxXQWFBLGlCQWFBLGtCQWFBLG9CQVlBLGtCQVFBLDJCQVlBLHNCQWNBLHNCQVNBLG9CQWFPLCtCQXlFUCxjQWtDTyxrQkFJQSxnQkFJQSxnQkFJQSx1QkFJQSxpQkFJQSxpQkFJQSxrQkFJQSxpQkFJQSx1QkFJQTtBQXRRYjtBQUFBO0FBQUE7QUFLQTtBQUdBO0FBQ0E7QUFDQTtBQUVBLE1BQU0sWUFBcUM7QUFBQSxRQUN6QyxLQUFLO0FBQUEsUUFDTCxLQUFLO0FBQUEsUUFDTCxNQUFNO0FBQUEsUUFDTixLQUFLO0FBQUEsUUFDTCxNQUFNO0FBQUEsUUFDTixXQUFXO0FBQUEsUUFDWCxXQUFXO0FBQUEsUUFDWCxJQUFJO0FBQUEsUUFDSixJQUFJO0FBQUEsUUFDSixRQUFRO0FBQUEsTUFDVjtBQUVBLE1BQU0sa0JBQTJDO0FBQUEsUUFDL0MsS0FBSztBQUFBLFFBQ0wsS0FBSztBQUFBLFFBQ0wsTUFBTTtBQUFBLFFBQ04sS0FBSztBQUFBLFFBQ0wsTUFBTTtBQUFBLFFBQ04sV0FBVztBQUFBLFFBQ1gsV0FBVztBQUFBLFFBQ1gsSUFBSTtBQUFBLFFBQ0osSUFBSTtBQUFBLFFBQ0osUUFBUTtBQUFBLE1BQ1Y7QUFFQSxNQUFNLG1CQUE0QztBQUFBLFFBQ2hELEtBQUs7QUFBQSxRQUNMLEtBQUs7QUFBQSxRQUNMLE1BQU07QUFBQSxRQUNOLEtBQUs7QUFBQSxRQUNMLE1BQU07QUFBQSxRQUNOLFdBQVc7QUFBQSxRQUNYLFdBQVc7QUFBQSxRQUNYLElBQUk7QUFBQSxRQUNKLElBQUk7QUFBQSxRQUNKLFFBQVE7QUFBQSxNQUNWO0FBRUEsTUFBTSxxQkFBOEM7QUFBQSxRQUNsRCxLQUFLO0FBQUEsUUFDTCxLQUFLO0FBQUEsUUFDTCxLQUFLO0FBQUEsUUFDTCxNQUFNO0FBQUEsUUFDTixXQUFXO0FBQUEsUUFDWCxXQUFXO0FBQUEsUUFDWCxJQUFJO0FBQUEsUUFDSixJQUFJO0FBQUEsUUFDSixRQUFRO0FBQUEsTUFDVjtBQUVBLE1BQU0sbUJBQW1CLENBQUMsY0FBc0IsU0FBMkI7QUFDekUsY0FBTSxNQUFNLENBQUM7QUFDYixpQkFBUyxJQUFJLE9BQU8sY0FBYyxJQUFJLE1BQU0sRUFBRSxHQUFHO0FBQy9DLGNBQUksS0FBSyxDQUFDO0FBQUEsUUFDWjtBQUNBLGVBQU87QUFBQSxNQUNUO0FBRUEsTUFBTSw0QkFBNEIsQ0FBQyxPQUEwQixTQUFrRDtBQUM3RyxjQUFNLGNBQWMsQ0FBQztBQUNyQixjQUFNLE9BQU8sTUFBTTtBQUNuQixpQkFBUyxNQUFNLEdBQUcsTUFBTSxNQUFNLE9BQU87QUFDbkMsY0FBSSxLQUFLLFFBQVEsR0FBRyxNQUFNLElBQUk7QUFDNUIsd0JBQVksS0FBSyxNQUFNLEdBQUcsQ0FBQztBQUFBLFVBQzdCO0FBQUEsUUFDRjtBQUNBLGNBQU0sY0FBYyxLQUFLLElBQUksU0FBTyxNQUFNLEdBQUcsQ0FBQztBQUM5QyxlQUFPLENBQUMsYUFBYSxXQUFXO0FBQUEsTUFDbEM7QUFFQSxNQUFNLHVCQUF1QixDQUFDLE9BQWlCLFNBQTZCO0FBQzFFLGNBQU0sT0FBTyxNQUFNLFNBQVMsS0FBSztBQUNqQyxjQUFNLGNBQWMsQ0FBQztBQUNyQixZQUFJLFdBQVc7QUFDZixpQkFBUyxNQUFNLEdBQUcsTUFBTSxNQUFNLE9BQU87QUFDbkMsY0FBSSxLQUFLLFFBQVEsR0FBRyxNQUFNLElBQUk7QUFDNUIsd0JBQVksS0FBSyxNQUFNLFVBQVUsQ0FBQztBQUFBLFVBQ3BDLE9BQU87QUFDTCx3QkFBWSxLQUFLLENBQUM7QUFBQSxVQUNwQjtBQUFBLFFBQ0Y7QUFDQSxlQUFPO0FBQUEsTUFDVDtBQUVBLE1BQU0sdUJBQXVCLENBQUMsTUFBZ0IsU0FBMEI7QUFDdEUsaUJBQVMsSUFBSSxHQUFHLElBQUksS0FBSyxRQUFRLEVBQUUsR0FBRztBQUNwQyxjQUFJLEtBQUssS0FBSyxTQUFTLElBQUksQ0FBQyxNQUFNLE9BQU8sSUFBSSxHQUFHO0FBQzlDLG1CQUFPO0FBQUEsVUFDVDtBQUFBLFFBQ0Y7QUFDQSxlQUFPO0FBQUEsTUFDVDtBQUVBLE1BQU0scUJBQXFCLENBQUMsTUFBZ0IsU0FBMkI7QUFDckUsY0FBTSxNQUFNLENBQUM7QUFDYixZQUFJLENBQUMscUJBQXFCLE1BQU0sSUFBSSxHQUFHO0FBQ3JDLG1CQUFTLElBQUksR0FBRyxJQUFJLE1BQU0sRUFBRSxHQUFHO0FBQzdCLGdCQUFJLEtBQUssUUFBUSxDQUFDLE1BQU0sSUFBSTtBQUMxQixrQkFBSSxLQUFLLENBQUM7QUFBQSxZQUNaO0FBQUEsVUFDRjtBQUNBLGVBQUssUUFBUSxVQUFRLElBQUksS0FBSyxJQUFJLENBQUM7QUFBQSxRQUNyQztBQUNBLGVBQU87QUFBQSxNQUNUO0FBRU8sTUFBTSxnQ0FDVCxDQUFDLE1BQWMsYUFBcUMsUUFBK0IsWUFDbEYsZ0JBQTBCLGFBQXVCLGdCQUF1QztBQUN2RixjQUFNLGFBQWEsT0FBTyxDQUFDLEVBQUU7QUFFN0IsY0FBTSxhQUFhLFVBQVUsS0FBSyxXQUFXO0FBQzdDLGNBQU0sYUFBYSxVQUFVLEtBQUssV0FBVztBQUU3QyxjQUFNLFFBQVEsY0FBYyxNQUFNLE9BQU8sQ0FBQyxFQUFFLFVBQVUsVUFBVTtBQUNoRSxjQUFNLFNBQVMsZUFBZSxVQUFVLGdCQUFnQixXQUFXO0FBRW5FLGNBQU0sZ0JBQWdCO0FBRXRCLGNBQU0sc0JBQXNCO0FBQUEsK0NBQ2EsT0FBTyxLQUFLLE9BQU8sS0FBSyxhQUFhO0FBQUE7QUFHOUUsY0FBTSxrQkFBa0IsQ0FBQyxpQkFBK0I7QUFBQSxVQUNwRCxhQUFhLGdCQUFnQixjQUFjLEtBQUssRUFBRSxpQkFBaUIsT0FBTyxNQUFNLENBQUM7QUFBQSxVQUNqRixtQkFBbUI7QUFBQTtBQUFBO0FBQUE7QUFBQSxXQUlsQixhQUFhLFVBQVUsYUFBYSxDQUFDO0FBQUE7QUFBQSwyQ0FFTCxhQUFhO0FBQUE7QUFBQTtBQUFBLDRCQUc1QixPQUFPLEtBQUssT0FBTyxJQUFJLGlCQUFpQixVQUFVLENBQUM7QUFBQTtBQUFBLHdEQUV2QixhQUFhO0FBQUEsNkJBQ3hDLE9BQU8sS0FBSyxPQUFPLElBQUksTUFBTSxZQUFZLFlBQVksQ0FBQztBQUFBLHlCQUMxRCxVQUFVLFVBQVUsQ0FBQztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsd0NBS04sYUFBYTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSwwQkFNM0IsZ0JBQWdCLFVBQVUsQ0FBQztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFTM0MsT0FBTztBQUFBLFVBQ0g7QUFBQSxVQUNBLEdBQ0ksZUFBZSxTQUFTLGVBQWUsT0FBTyxLQUFLLE9BQU8sMEJBQ2xDLEdBQUcsbUJBQW1CLFVBQVUsQ0FBQyxFQUFFO0FBQUEsUUFBRSxDQUFDO0FBQUE7QUFBQTtBQUsxRSxlQUFPO0FBQUEsVUFDTDtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQSxZQUFZLE9BQU87QUFBQSxZQUNqQixTQUFTLENBQUMsRUFBQyxNQUFNLGFBQWEsVUFBVSxlQUFjLENBQUM7QUFBQSxZQUN2RCxlQUFlLEVBQUMsR0FBRyxXQUFVO0FBQUEsWUFDN0IsaUJBQWlCLENBQUMsRUFBQyxNQUFNLFVBQVUsTUFBTSxXQUFVLENBQUM7QUFBQSxVQUN0RDtBQUFBLFFBQ0Y7QUFBQSxNQUNGO0FBRUosTUFBTSxlQUNGLENBQUMsU0FBeUIsTUFBYyxZQUN2QyxlQUFpRztBQUNoRyxjQUFNLG9CQUNGLFFBQVEsT0FBTyxXQUFXLElBQUksYUFBYSxpQ0FBaUMsUUFBUSxRQUFRLFVBQVU7QUFFMUcsWUFBSSxjQUFjLGtCQUFrQjtBQUNwQyxZQUFJLFlBQVksV0FBVyxLQUFLLENBQUMsa0JBQWtCLG1CQUFtQjtBQUNwRSx3QkFBYyxRQUFRLE9BQU8sQ0FBQyxFQUFFLEtBQUssSUFBSSxDQUFDLE1BQU0sTUFBTSxDQUFDO0FBQUEsUUFDekQ7QUFDQSxjQUFNLGdCQUFnQixVQUFVLGNBQWMsYUFBYSxRQUFRLE9BQU8sQ0FBQyxFQUFFLEtBQUssTUFBTTtBQUV4RixZQUFJLE9BQU87QUFDWCxZQUFJLFFBQVEsUUFBUSxPQUFPLENBQUM7QUFDNUIsY0FBTSxlQUFlLG1CQUFtQixNQUFNLFFBQVEsT0FBTyxDQUFDLEVBQUUsS0FBSyxNQUFNO0FBQzNFLFlBQUksYUFBYSxTQUFTLEdBQUc7QUFDM0Isa0JBQVEsUUFBUTtBQUFBLFlBQ1osMkJBQTJCLFFBQVEsT0FBTyxDQUFDLEdBQUcsWUFBWTtBQUFBLFlBQUcsRUFBQyxRQUFRLENBQUMsQ0FBQyxHQUFHLFNBQVMsQ0FBQyxFQUFFLEVBQUM7QUFBQSxVQUFDLEVBQUUsQ0FBQztBQUNoRyxpQkFBTyxpQkFBaUIsS0FBSyxRQUFRLE1BQU0sS0FBSyxNQUFNO0FBQUEsUUFDeEQ7QUFFQSxjQUFNLENBQUMsYUFBYSxXQUFXLElBQUksMEJBQTBCLE1BQU0sTUFBTSxJQUFJO0FBQzdFLFlBQUksbUJBQW1CO0FBQ3ZCLFlBQUksa0JBQWtCLFVBQVU7QUFDOUIsNkJBQW1CLHFCQUFxQixhQUFhLGFBQWE7QUFBQSxRQUNwRTtBQUVBLGdCQUFRO0FBQUEsVUFDSjtBQUFBLFlBQ0k7QUFBQSxZQUFNLEVBQUMsTUFBTSxrQkFBa0IsVUFBVSxtQkFBbUIsQ0FBQyxNQUFNLEVBQUM7QUFBQSxZQUFHLENBQUMsS0FBSztBQUFBLFlBQUc7QUFBQSxZQUNoRixRQUFRLE9BQU8sQ0FBQyxFQUFFO0FBQUEsWUFBVTtBQUFBLFlBQWtCO0FBQUEsVUFBVztBQUFBLFVBQzdELEVBQUMsUUFBUSxDQUFDLEtBQUssRUFBQztBQUFBLFFBQUM7QUFBQSxNQUN2QjtBQUVHLE1BQU0sbUJBQW1CLENBQUMsU0FBeUIsZUFBdUM7QUFDL0YscUJBQWEsU0FBUyxvQkFBb0IsWUFBWSxNQUFNO0FBQUEsTUFDOUQ7QUFFTyxNQUFNLGlCQUFpQixDQUFDLFNBQXlCLGVBQXVDO0FBQzdGLHFCQUFhLFNBQVMsa0JBQWtCLFlBQVksSUFBSTtBQUFBLE1BQzFEO0FBRU8sTUFBTSxpQkFBaUIsQ0FBQyxTQUF5QixlQUF1QztBQUM3RixxQkFBYSxTQUFTLGtCQUFrQixZQUFZLElBQUk7QUFBQSxNQUMxRDtBQUVPLE1BQU0sd0JBQXdCLENBQUMsU0FBeUIsZUFBdUM7QUFDcEcscUJBQWEsU0FBUyx5QkFBeUIsWUFBWSxXQUFXO0FBQUEsTUFDeEU7QUFFTyxNQUFNLGtCQUFrQixDQUFDLFNBQXlCLGVBQXVDO0FBQzlGLHFCQUFhLFNBQVMsbUJBQW1CLFlBQVksS0FBSztBQUFBLE1BQzVEO0FBRU8sTUFBTSxrQkFBa0IsQ0FBQyxTQUF5QixlQUF1QztBQUM5RixxQkFBYSxTQUFTLG1CQUFtQixZQUFZLEtBQUs7QUFBQSxNQUM1RDtBQUVPLE1BQU0sbUJBQW1CLENBQUMsU0FBeUIsZUFBdUM7QUFDL0YscUJBQWEsU0FBUyxvQkFBb0IsWUFBWSxNQUFNO0FBQUEsTUFDOUQ7QUFFTyxNQUFNLGtCQUFrQixDQUFDLFNBQXlCLGVBQXVDO0FBQzlGLHFCQUFhLFNBQVMsbUJBQW1CLFlBQVksS0FBSztBQUFBLE1BQzVEO0FBRU8sTUFBTSx3QkFBd0IsQ0FBQyxTQUF5QixlQUF1QztBQUNwRyxxQkFBYSxTQUFTLHlCQUF5QixZQUFZLFdBQVc7QUFBQSxNQUN4RTtBQUVPLE1BQU0scUJBQXFCLENBQUMsU0FBeUIsZUFBdUM7QUFDakcscUJBQWEsU0FBUyxzQkFBc0IsWUFBWSxRQUFRO0FBQUEsTUFDbEU7QUFBQTtBQUFBOzs7QUN4UUEsTUFZTUMsaUJBb0JBLE1BQ08seUJBNkVBLGtDQVVQLGtCQWVBLG1CQVdBLGVBV0EsZUFXQSxzQkFXQSxnQkFvQkEsaUJBcUJBLGdCQW9CQSxpQkFXQSxnQkFXQSxzQkFXQSxzQkFzQk8sWUFRQSxVQVFBLFVBUUEsaUJBUUEsV0FRQSxXQVFBLFlBUUEsV0FRQSxpQkFRQTtBQS9XYjtBQUFBO0FBQUE7QUFLQTtBQUNBO0FBR0E7QUFDQTtBQUVBLE1BQU1BLGtCQUFpQixDQUFDLFdBQXdDO0FBQzlELFlBQUksQ0FBQyxVQUFVLE9BQU8sV0FBVyxLQUFLLE9BQU8sU0FBUyxHQUFHO0FBQ3ZELGdCQUFNLElBQUksTUFBTSxtQ0FBbUM7QUFBQSxRQUNyRDtBQUVBLFlBQUksT0FBTyxXQUFXLEtBQUssT0FBTyxDQUFDLEVBQUUsS0FBSyxXQUFXLEdBQUc7QUFDdEQsZ0JBQU0sSUFBSSxNQUFNLDBCQUEwQjtBQUFBLFFBQzVDO0FBQUEsTUFDRjtBQVlBLE1BQU0sT0FBaUIsQ0FBQyxVQUFVLENBQUMsSUFBSSxJQUFJLGVBQWUsTUFBTSxhQUFhLGVBQWUsQ0FBQyxLQUFLLEVBQUU7QUFDN0YsTUFBTSwwQkFDVCxDQUFDLE1BQWMsYUFBcUMsUUFBK0IsVUFDbEYsV0FBcUIsZ0JBQTBCLFdBQVcsT0FBTyxvQkFBb0IsVUFBdUI7QUFDM0csY0FBTSxjQUF3QixDQUFDO0FBQy9CLGNBQU0sYUFBYSxPQUFPLENBQUMsRUFBRTtBQUM3QixjQUFNLFlBQVksV0FBVztBQUM3QixjQUFNLE9BQU8sVUFBVSxjQUFjLFdBQVcsU0FBUztBQUN6RCxjQUFNLGtCQUFrQixDQUFDLHFCQUFxQixLQUFLLFdBQVc7QUFDOUQsbUJBQVcsUUFBUSxDQUFDLEdBQUcsTUFBTTtBQUMzQixjQUFJLG1CQUFtQixLQUFLLFFBQVEsQ0FBQyxLQUFLLEdBQUc7QUFDM0MsZ0JBQUksVUFBVTtBQUNaLDBCQUFZLEtBQUssQ0FBQztBQUFBLFlBQ3BCO0FBQUEsVUFDRixPQUFPO0FBQ0wsd0JBQVksS0FBSyxDQUFDO0FBQUEsVUFDcEI7QUFBQSxRQUNGLENBQUM7QUFDRCxjQUFNLGFBQWEsWUFBWTtBQUMvQixjQUFNLGFBQWEsVUFBVSxLQUFLLFdBQVc7QUFDN0MsY0FBTSxrQkFBa0IsQ0FBQyxpQkFBK0I7QUFDdEQsZ0JBQU0sVUFBb0IsQ0FBQztBQUUzQixnQkFBTSxRQUFRLGNBQWMsTUFBTSxPQUFPLENBQUMsRUFBRSxVQUFVLFNBQVM7QUFDL0QsZ0JBQU0sU0FBUyxlQUFlLFVBQVUsZ0JBQWdCLFVBQVU7QUFDbEUsZ0JBQU0sTUFBTSxTQUFTLE9BQU8sUUFBUSxJQUFJO0FBQ3hDLGNBQUlDLGFBQVksSUFBSSxDQUFDO0FBRXJCLG1CQUFTLElBQUksR0FBRyxJQUFJLEdBQUcsSUFBSSxXQUFXLEtBQUs7QUFFekMsZ0JBQUksbUJBQW1CLEtBQUssUUFBUSxDQUFDLEtBQUssR0FBRztBQUMzQyxrQkFBSSxVQUFVO0FBQ1o7QUFBQSxjQUNGO0FBRUEsY0FBQUEsYUFBWSxZQUFZLENBQUMsZUFBZSxDQUFDLE1BQU0sV0FBVyxDQUFDLENBQUMsTUFBTSxDQUFDO0FBQUEsb0JBQzNELElBQUksQ0FBQyxFQUFFLFNBQVMsWUFBWSxJQUFJLHFCQUFxQixDQUFDLE1BQU0sRUFBRTtBQUFBLG9CQUM5RCxNQUFNLFdBQVcsaUJBQWlCLEdBQUcsSUFBSSxDQUFDLEVBQUUsQ0FBQztBQUFBLG9CQUM3Q0EsVUFBUztBQUFBO0FBQUEsWUFFbkIsT0FBTztBQUNMLHNCQUFRLEtBQUssR0FBRyxNQUFNLFdBQVcsaUJBQWlCLEdBQUcsT0FBTyxXQUFXLGtCQUFrQixDQUFDLENBQUMsQ0FBQyxHQUFHO0FBQy9GO0FBQUEsWUFDRjtBQUFBLFVBQ0Y7QUFDQSxpQkFBTztBQUFBO0FBQUEsVUFFTCxhQUFhLGdCQUFnQixlQUFlLEtBQUssRUFBRSxpQkFBaUIsT0FBTyxNQUFNLENBQUM7QUFBQTtBQUFBLFVBRWxGLGFBQWEsVUFBVSxDQUFDO0FBQUEsWUFDdEIsYUFBYSxzQ0FBc0Msc0JBQXNCLENBQUM7QUFBQSwrQkFDdkQsTUFBTSxLQUFLLE9BQU87QUFBQSxpQ0FDaEIsT0FBTyxnQkFBZ0IsWUFBWSxDQUFDO0FBQUE7QUFBQSxZQUV6RCxRQUFRLEtBQUssSUFBSSxDQUFDO0FBQUEsWUFDbEIsSUFBSSxDQUFDLENBQUM7QUFBQSxZQUNOLElBQUksQ0FBQyxDQUFDO0FBQUEsWUFDTkEsVUFBUztBQUFBLFlBQ1QsSUFBSSxDQUFDLENBQUM7QUFBQSxZQUNOLElBQUksV0FBVyxJQUFJLE9BQU8sWUFBWSxjQUFjLE9BQU8sSUFBSSxJQUFJLE1BQU0sQ0FBQyxFQUFFLEtBQUssSUFBSSxDQUFDO0FBQUE7QUFBQSxRQUU1RjtBQUVBLGVBQU87QUFBQSxVQUNMO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBLFlBQVksT0FBTztBQUFBLFlBQ2pCLFNBQVMsQ0FBQyxFQUFDLE1BQU0sYUFBYSxVQUFVLGVBQWMsQ0FBQztBQUFBLFlBQ3ZELGVBQWUsRUFBQyxHQUFHLEtBQUs7QUFBQSxjQUFLLGFBQWE7QUFBQTtBQUFBLFlBQXVCLEVBQUM7QUFBQSxZQUNsRSxpQkFBaUI7QUFBQSxjQUNmLEVBQUMsTUFBTSxVQUFVLE1BQU0sV0FBVTtBQUFBLGNBQUcsR0FBRywyQkFBMkIsVUFBVTtBQUFBLGNBQzVFLEdBQUcsMkJBQTJCLFdBQVc7QUFBQSxZQUMzQztBQUFBLFVBQ0Y7QUFBQSxRQUNGO0FBQUEsTUFDRjtBQUVHLE1BQU0sbUNBQ1QsQ0FBQyxRQUErQixlQUFtRDtBQUNqRixjQUFNLE9BQWlCLENBQUM7QUFDeEIsWUFBSSxPQUFPLENBQUMsRUFBRSxLQUFLLENBQUMsSUFBSSxHQUFHO0FBQ3pCLGlCQUFPLENBQUMsRUFBRSxpQkFBaUIsRUFBRSxRQUFRLE9BQUssS0FBSyxLQUFLLE9BQU8sQ0FBQyxDQUFDLENBQUM7QUFBQSxRQUNoRTtBQUNBLGVBQU87QUFBQSxVQUNILEVBQUMsTUFBTSxVQUFVLFdBQVcsVUFBVSxtQkFBbUIsV0FBVyxrQkFBaUI7QUFBQSxRQUFDO0FBQUEsTUFDNUY7QUFFSixNQUFNLG1CQUNGLENBQUMsU0FBeUIsTUFBYyxZQUE4QixhQUE2QjtBQUNqRyxjQUFNLFNBQVMsUUFBUTtBQUN2QixjQUFNLG9CQUNGLE9BQU8sV0FBVyxJQUFJLGFBQWEsaUNBQWlDLFFBQVEsVUFBVTtBQUUxRixnQkFBUTtBQUFBLFVBQ0o7QUFBQSxZQUNJO0FBQUEsWUFBTSxFQUFDLE1BQU0sa0JBQWtCLFVBQVUsbUJBQW1CLENBQUMsTUFBTSxFQUFDO0FBQUEsWUFBRyxDQUFDLE9BQU8sQ0FBQyxDQUFDO0FBQUEsWUFDakYsa0JBQWtCLHFCQUFxQixrQkFBa0IsS0FBSyxXQUFXLElBQUksT0FBTztBQUFBLFlBQ3BGLGtCQUFrQjtBQUFBLFlBQU0sT0FBTyxDQUFDLEVBQUU7QUFBQSxZQUFVLGtCQUFrQjtBQUFBLFlBQzlELGtCQUFrQjtBQUFBLFVBQWlCO0FBQUEsVUFDdkMsRUFBQyxRQUFRLENBQUMsQ0FBQyxFQUFDO0FBQUEsUUFBQztBQUFBLE1BQ25CO0FBRUosTUFBTSxvQkFBb0IsQ0FBQyxTQUF5QixlQUF1QztBQUN6RixRQUFBRCxnQkFBZSxRQUFRLE1BQU07QUFDN0IsY0FBTSxXQUFxQixDQUFDLE9BQU8sV0FDL0I7QUFBQSxVQUFDLGVBQWUsT0FBTyxLQUFLLE9BQU87QUFBQSxVQUNsQztBQUFBLFVBQ0EsWUFBWSxNQUFNLGFBQWEsZUFBZSxDQUFDO0FBQUEsVUFDL0M7QUFBQSxRQUNMO0FBQ0EseUJBQWlCLFNBQVMsZ0JBQWdCLFlBQVksUUFBUTtBQUFBLE1BQ2hFO0FBRUEsTUFBTSxnQkFBZ0IsQ0FBQyxTQUF5QixlQUF1QztBQUNyRixRQUFBQSxnQkFBZSxRQUFRLE1BQU07QUFDN0IsY0FBTSxXQUFxQixDQUFDLE9BQU8sV0FDL0I7QUFBQSxVQUFDLGVBQWUsT0FBTyxLQUFLLE9BQU87QUFBQSxVQUNsQztBQUFBLFVBQ0EsZ0JBQWdCLE1BQU0sYUFBYSxlQUFlLENBQUM7QUFBQSxVQUNuRDtBQUFBLFFBQ0w7QUFDQSx5QkFBaUIsU0FBUyxZQUFZLFlBQVksUUFBUTtBQUFBLE1BQzVEO0FBRUEsTUFBTSxnQkFBZ0IsQ0FBQyxTQUF5QixlQUF1QztBQUNyRixRQUFBQSxnQkFBZSxRQUFRLE1BQU07QUFDN0IsY0FBTSxXQUFxQixDQUFDLE9BQU8sV0FDL0I7QUFBQSxVQUFDLFdBQVcsT0FBTyxLQUFLLEtBQUssb0JBQW9CLE9BQU8sS0FBSyxLQUFLO0FBQUEsVUFDakU7QUFBQSxVQUNBLE9BQU8sTUFBTSxhQUFhLGVBQWUsQ0FBQztBQUFBLFVBQzFDO0FBQUEsUUFDTDtBQUNBLHlCQUFpQixTQUFTLFlBQVksWUFBWSxRQUFRO0FBQUEsTUFDNUQ7QUFFQSxNQUFNLHVCQUF1QixDQUFDLFNBQXlCLGVBQXVDO0FBQzVGLFFBQUFBLGdCQUFlLFFBQVEsTUFBTTtBQUM3QixjQUFNLFdBQXFCLENBQUMsT0FBTyxXQUMvQjtBQUFBLFVBQUMsZUFBZSxPQUFPLEtBQUssT0FBTztBQUFBLFVBQ2xDO0FBQUEsVUFDQSxnQkFBZ0IsTUFBTSxhQUFhLGVBQWUsQ0FBQztBQUFBLFVBQ25EO0FBQUEsUUFDTDtBQUNBLHlCQUFpQixTQUFTLG1CQUFtQixZQUFZLFFBQVE7QUFBQSxNQUNuRTtBQUVBLE1BQU0saUJBQWlCLENBQUMsU0FBeUIsZUFBdUM7QUFDdEYsUUFBQUEsZ0JBQWUsUUFBUSxNQUFNO0FBQzdCLGNBQU0sV0FBcUIsQ0FBQyxPQUFPLFNBQVMsU0FBUztBQUNuRCxnQkFBTSxVQUFVLENBQUM7QUFDakIsbUJBQVMsSUFBSSxHQUFHLElBQUksTUFBTSxNQUFNLEtBQUs7QUFDbkMsZ0JBQUksS0FBSyxRQUFRLENBQUMsS0FBSyxLQUFLLEtBQUssV0FBVyxHQUFHO0FBQzdDLHNCQUFRLEtBQUssTUFBTSxXQUFXLGlCQUFpQixHQUFHLENBQUMsQ0FBQztBQUFBLFlBQ3REO0FBQUEsVUFDRjtBQUVBLGlCQUFPO0FBQUEsWUFDTCxHQUFHLFFBQVEsS0FBSyxJQUFJLENBQUM7QUFBQSxZQUNyQixlQUFlLE1BQU0sYUFBYSxlQUFlLENBQUM7QUFBQSxZQUNsRCxzQkFBc0IsTUFBTSxhQUFhLGVBQWUsQ0FBQztBQUFBLFlBQ3pEO0FBQUEsVUFDRjtBQUFBLFFBQ0Y7QUFDQSx5QkFBaUIsU0FBUyxhQUFhLFlBQVksUUFBUTtBQUFBLE1BQzdEO0FBRUEsTUFBTSxrQkFBa0IsQ0FBQyxTQUF5QixlQUF1QztBQUN2RixRQUFBQSxnQkFBZSxRQUFRLE1BQU07QUFDN0IsY0FBTSxXQUFxQixDQUFDLE9BQU8sUUFBUSxTQUFTO0FBQ2xELGNBQUksT0FBTztBQUNYLG1CQUFTLElBQUksR0FBRyxJQUFJLE1BQU0sTUFBTSxLQUFLO0FBQ25DLGdCQUFJLEtBQUssUUFBUSxDQUFDLEtBQUssS0FBSyxLQUFLLFdBQVcsR0FBRztBQUU3QyxzQkFBUSxRQUFRLE9BQU8sQ0FBQyxFQUFFLEtBQUssQ0FBQztBQUFBLFlBQ2xDO0FBQUEsVUFDRjtBQUVBLGlCQUFPO0FBQUEsWUFDTDtBQUFBLFlBQ0E7QUFBQSxZQUNBLGNBQWMsTUFBTSxhQUFhLGVBQWUsQ0FBQztBQUFBLFlBQ2pELGVBQWUsT0FBTyxLQUFLLEtBQUssVUFBVSxJQUFJO0FBQUEsVUFDaEQ7QUFBQSxRQUNGO0FBQ0EseUJBQWlCLFNBQVMsY0FBYyxZQUFZLFFBQVE7QUFBQSxNQUM5RDtBQUVBLE1BQU0saUJBQWlCLENBQUMsU0FBeUIsZUFBdUM7QUFDdEYsUUFBQUEsZ0JBQWUsUUFBUSxNQUFNO0FBQzdCLGNBQU0sV0FBcUIsQ0FBQyxPQUFPLFNBQVMsU0FBUztBQUNuRCxnQkFBTSxVQUFVLENBQUM7QUFDakIsbUJBQVMsSUFBSSxHQUFHLElBQUksTUFBTSxNQUFNLEtBQUs7QUFDbkMsZ0JBQUksS0FBSyxRQUFRLENBQUMsS0FBSyxLQUFLLEtBQUssV0FBVyxHQUFHO0FBQzdDLHNCQUFRLEtBQUssaUJBQWlCLENBQUMsUUFBUTtBQUFBLFlBQ3pDO0FBQUEsVUFDRjtBQUVBLGlCQUFPO0FBQUEsWUFDTCxHQUFHLFFBQVEsS0FBSyxJQUFJLENBQUM7QUFBQSxZQUNyQixlQUFlLE1BQU0sYUFBYSxlQUFlLENBQUM7QUFBQSxZQUNsRCxzQkFBc0IsTUFBTSxhQUFhLGVBQWUsQ0FBQztBQUFBLFlBQ3pEO0FBQUEsVUFDRjtBQUFBLFFBQ0Y7QUFDQSx5QkFBaUIsU0FBUyxhQUFhLFlBQVksUUFBUTtBQUFBLE1BQzdEO0FBRUEsTUFBTSxrQkFBa0IsQ0FBQyxTQUF5QixlQUF1QztBQUN2RixRQUFBQSxnQkFBZSxRQUFRLE1BQU07QUFDN0IsY0FBTSxXQUFxQixDQUFDLE9BQU8sV0FDL0I7QUFBQSxVQUFDLGVBQWUsT0FBTyxLQUFLLE9BQU87QUFBQSxVQUNsQztBQUFBLFVBQ0EsWUFBWSxNQUFNLGFBQWEsZUFBZSxDQUFDO0FBQUEsVUFDL0M7QUFBQSxRQUNMO0FBQ0EseUJBQWlCLFNBQVMsY0FBYyxZQUFZLFFBQVE7QUFBQSxNQUM5RDtBQUVBLE1BQU0saUJBQWlCLENBQUMsU0FBeUIsZUFBdUM7QUFDdEYsUUFBQUEsZ0JBQWUsUUFBUSxNQUFNO0FBQzdCLGNBQU0sV0FBcUIsQ0FBQyxPQUFPLFdBQy9CO0FBQUEsVUFBQyxlQUFlLE9BQU8sS0FBSyxPQUFPO0FBQUEsVUFDbEM7QUFBQSxVQUNBLFlBQVksTUFBTSxhQUFhLGVBQWUsQ0FBQztBQUFBLFVBQy9DO0FBQUEsUUFDTDtBQUNBLHlCQUFpQixTQUFTLGFBQWEsWUFBWSxRQUFRO0FBQUEsTUFDN0Q7QUFFQSxNQUFNLHVCQUF1QixDQUFDLFNBQXlCLGVBQXVDO0FBQzVGLFFBQUFBLGdCQUFlLFFBQVEsTUFBTTtBQUM3QixjQUFNLFdBQXFCLENBQUMsT0FBTyxXQUMvQjtBQUFBLFVBQUMsV0FBVyxPQUFPLEtBQUssS0FBSyxvQkFBb0IsT0FBTyxLQUFLLEtBQUs7QUFBQSxVQUNqRTtBQUFBLFVBQ0EsT0FBTyxNQUFNLGFBQWEsZUFBZSxDQUFDO0FBQUEsVUFDMUM7QUFBQSxRQUNMO0FBQ0EseUJBQWlCLFNBQVMsbUJBQW1CLFlBQVksUUFBUTtBQUFBLE1BQ25FO0FBRUEsTUFBTSx1QkFDRixDQUFDLE9BQTBCLE1BQXlCLHNCQUF3QztBQUMxRixZQUFJLEtBQUssV0FBVyxHQUFHO0FBQ3JCLGlCQUFPO0FBQUEsUUFDVDtBQUVBLFlBQUksYUFBYTtBQUNqQixZQUFJLGFBQWE7QUFDakIsaUJBQVMsTUFBTSxHQUFHLE1BQU0sS0FBSyxRQUFRLE9BQU87QUFDMUMsY0FBSSxLQUFLLFFBQVEsR0FBRyxNQUFNLElBQUk7QUFDNUIsMEJBQWMsTUFBTSxHQUFHO0FBQUEsVUFDekIsT0FBTztBQUNMLDBCQUFjLE1BQU0sR0FBRztBQUFBLFVBQ3pCO0FBQUEsUUFDRjtBQUtBLGVBQU8sYUFBYSxNQUFNLGFBQWE7QUFBQSxNQUN6QztBQUVHLE1BQU0sYUFBYSxDQUFDLFNBQXlCLGVBQXVDO0FBQ3pGLFlBQUkscUJBQXFCLFFBQVEsT0FBTyxDQUFDLEVBQUUsTUFBTSxXQUFXLE1BQU0sV0FBVyxpQkFBaUIsR0FBRztBQUMvRiwwQkFBZ0IsU0FBUyxVQUFVO0FBQUEsUUFDckMsT0FBTztBQUNMLDJCQUFpQixTQUFTLFVBQVU7QUFBQSxRQUN0QztBQUFBLE1BQ0Y7QUFFTyxNQUFNLFdBQVcsQ0FBQyxTQUF5QixlQUF1QztBQUN2RixZQUFJLHFCQUFxQixRQUFRLE9BQU8sQ0FBQyxFQUFFLE1BQU0sV0FBVyxNQUFNLFdBQVcsaUJBQWlCLEdBQUc7QUFDL0Ysd0JBQWMsU0FBUyxVQUFVO0FBQUEsUUFDbkMsT0FBTztBQUNMLHlCQUFlLFNBQVMsVUFBVTtBQUFBLFFBQ3BDO0FBQUEsTUFDRjtBQUVPLE1BQU0sV0FBVyxDQUFDLFNBQXlCLGVBQXVDO0FBQ3ZGLFlBQUkscUJBQXFCLFFBQVEsT0FBTyxDQUFDLEVBQUUsTUFBTSxXQUFXLE1BQU0sV0FBVyxpQkFBaUIsR0FBRztBQUMvRix3QkFBYyxTQUFTLFVBQVU7QUFBQSxRQUNuQyxPQUFPO0FBQ0wseUJBQWUsU0FBUyxVQUFVO0FBQUEsUUFDcEM7QUFBQSxNQUNGO0FBRU8sTUFBTSxrQkFBa0IsQ0FBQyxTQUF5QixlQUF1QztBQUM5RixZQUFJLHFCQUFxQixRQUFRLE9BQU8sQ0FBQyxFQUFFLE1BQU0sV0FBVyxNQUFNLFdBQVcsaUJBQWlCLEdBQUc7QUFDL0YsK0JBQXFCLFNBQVMsVUFBVTtBQUFBLFFBQzFDLE9BQU87QUFDTCxnQ0FBc0IsU0FBUyxVQUFVO0FBQUEsUUFDM0M7QUFBQSxNQUNGO0FBRU8sTUFBTSxZQUFZLENBQUMsU0FBeUIsZUFBdUM7QUFDeEYsWUFBSSxxQkFBcUIsUUFBUSxPQUFPLENBQUMsRUFBRSxNQUFNLFdBQVcsTUFBTSxXQUFXLGlCQUFpQixHQUFHO0FBQy9GLHlCQUFlLFNBQVMsVUFBVTtBQUFBLFFBQ3BDLE9BQU87QUFDTCwwQkFBZ0IsU0FBUyxVQUFVO0FBQUEsUUFDckM7QUFBQSxNQUNGO0FBRU8sTUFBTSxZQUFZLENBQUMsU0FBeUIsZUFBdUM7QUFDeEYsWUFBSSxxQkFBcUIsUUFBUSxPQUFPLENBQUMsRUFBRSxNQUFNLFdBQVcsTUFBTSxXQUFXLGlCQUFpQixHQUFHO0FBQy9GLHlCQUFlLFNBQVMsVUFBVTtBQUFBLFFBQ3BDLE9BQU87QUFDTCwwQkFBZ0IsU0FBUyxVQUFVO0FBQUEsUUFDckM7QUFBQSxNQUNGO0FBRU8sTUFBTSxhQUFhLENBQUMsU0FBeUIsZUFBdUM7QUFDekYsWUFBSSxxQkFBcUIsUUFBUSxPQUFPLENBQUMsRUFBRSxNQUFNLFdBQVcsTUFBTSxXQUFXLGlCQUFpQixHQUFHO0FBQy9GLDBCQUFnQixTQUFTLFVBQVU7QUFBQSxRQUNyQyxPQUFPO0FBQ0wsMkJBQWlCLFNBQVMsVUFBVTtBQUFBLFFBQ3RDO0FBQUEsTUFDRjtBQUVPLE1BQU0sWUFBWSxDQUFDLFNBQXlCLGVBQXVDO0FBQ3hGLFlBQUkscUJBQXFCLFFBQVEsT0FBTyxDQUFDLEVBQUUsTUFBTSxXQUFXLE1BQU0sV0FBVyxpQkFBaUIsR0FBRztBQUMvRix5QkFBZSxTQUFTLFVBQVU7QUFBQSxRQUNwQyxPQUFPO0FBQ0wsMEJBQWdCLFNBQVMsVUFBVTtBQUFBLFFBQ3JDO0FBQUEsTUFDRjtBQUVPLE1BQU0sa0JBQWtCLENBQUMsU0FBeUIsZUFBdUM7QUFDOUYsWUFBSSxxQkFBcUIsUUFBUSxPQUFPLENBQUMsRUFBRSxNQUFNLFdBQVcsTUFBTSxXQUFXLGlCQUFpQixHQUFHO0FBQy9GLCtCQUFxQixTQUFTLFVBQVU7QUFBQSxRQUMxQyxPQUFPO0FBQ0wsZ0NBQXNCLFNBQVMsVUFBVTtBQUFBLFFBQzNDO0FBQUEsTUFDRjtBQUVPLE1BQU0sZUFBZSxDQUFDLFNBQXlCLGVBQXVDO0FBQzNGLFlBQUkscUJBQXFCLFFBQVEsT0FBTyxDQUFDLEVBQUUsTUFBTSxXQUFXLE1BQU0sV0FBVyxpQkFBaUIsR0FBRztBQUMvRiw0QkFBa0IsU0FBUyxVQUFVO0FBQUEsUUFDdkMsT0FBTztBQUNMLDZCQUFtQixTQUFTLFVBQVU7QUFBQSxRQUN4QztBQUFBLE1BQ0Y7QUFBQTtBQUFBOzs7QUNyWEEsTUFjTUUsaUJBZU8sUUEwQkEsUUEwQkE7QUFqRmI7QUFBQTtBQUFBO0FBT0E7QUFFQTtBQUdBO0FBRUEsTUFBTUEsa0JBQWlCLENBQUMsV0FBd0M7QUFDOUQsWUFBSSxDQUFDLFVBQVUsT0FBTyxXQUFXLEtBQUssT0FBTyxTQUFTLEdBQUc7QUFDdkQsZ0JBQU0sSUFBSSxNQUFNLHdDQUF3QztBQUFBLFFBQzFEO0FBQ0EsWUFBSSxPQUFPLENBQUMsRUFBRSw0QkFBNkI7QUFDekMsZ0JBQU0sSUFBSSxNQUFNLHFCQUFxQjtBQUFBLFFBQ3ZDO0FBQUEsTUFDRjtBQVFPLE1BQU0sU0FBUyxDQUFDLFNBQXlCLGVBQTBDO0FBQ3hGLFFBQUFBLGdCQUFlLFFBQVEsTUFBTTtBQUM3QixjQUFNLGNBQXdCLENBQUMsT0FBTyxRQUFRLFNBQVM7QUFDckQsZ0JBQU0sVUFBVSxDQUFDO0FBQ2pCLG1CQUFTLElBQUksR0FBRyxJQUFJLE1BQU0sTUFBTSxLQUFLO0FBQ25DLGdCQUFJLEtBQUssUUFBUSxDQUFDLEtBQUssS0FBSyxLQUFLLFdBQVcsR0FBRztBQUM3QyxzQkFBUSxLQUFLLGlCQUFpQixDQUFDLFFBQVE7QUFBQSxZQUN6QztBQUFBLFVBQ0Y7QUFDQSxpQkFBTztBQUFBLFlBQ0wsR0FBRyxRQUFRLEtBQUssSUFBSSxDQUFDO0FBQUEsWUFBSSxlQUFlLE1BQU0sYUFBYSxlQUFlLENBQUM7QUFBQTtBQUFBLFlBQzNFLE9BQU8sTUFBTSxhQUFhLGVBQWUsQ0FBQyxJQUFJLFdBQVcsa0JBQWtCLElBQUksT0FBTyxHQUFHO0FBQUEsbUJBQzVFLE1BQU0sYUFBYSxlQUFlLENBQUM7QUFBQTtBQUFBO0FBQUEsWUFHaEQ7QUFBQSxZQUFJLE9BQU8sWUFBWSxjQUFjLFlBQVk7QUFBQSxVQUNuRDtBQUFBLFFBQ0Y7QUFFQSxnQkFBUTtBQUFBLFVBQ0o7QUFBQSxZQUNJO0FBQUEsWUFBVSxFQUFDLE1BQU0sV0FBVyxVQUFVLG1CQUFtQixDQUFDLE1BQU0sRUFBQztBQUFBLFlBQUcsQ0FBQyxRQUFRLE9BQU8sQ0FBQyxDQUFDO0FBQUEsWUFBRztBQUFBLFlBQ3pGLENBQUMsV0FBVyxJQUFJO0FBQUE7QUFBQSxZQUFtQixXQUFXO0FBQUEsVUFBUTtBQUFBLFVBQzFELEVBQUMsUUFBUSxDQUFDLENBQUMsRUFBQztBQUFBLFFBQUM7QUFBQSxNQUNuQjtBQUVPLE1BQU0sU0FBUyxDQUFDLFNBQXlCLGVBQTBDO0FBQ3hGLFFBQUFBLGdCQUFlLFFBQVEsTUFBTTtBQUM3QixjQUFNLGNBQXdCLENBQUMsT0FBTyxRQUFRLFNBQVM7QUFDckQsZ0JBQU0sVUFBVSxDQUFDO0FBQ2pCLG1CQUFTLElBQUksR0FBRyxJQUFJLE1BQU0sTUFBTSxLQUFLO0FBQ25DLGdCQUFJLEtBQUssUUFBUSxDQUFDLEtBQUssS0FBSyxLQUFLLFdBQVcsR0FBRztBQUM3QyxzQkFBUSxLQUFLLGlCQUFpQixDQUFDLFFBQVE7QUFBQSxZQUN6QztBQUFBLFVBQ0Y7QUFDQSxpQkFBTztBQUFBLFlBQ0wsR0FBRyxRQUFRLEtBQUssSUFBSSxDQUFDO0FBQUEsWUFBSSxlQUFlLE1BQU0sYUFBYSxlQUFlLENBQUM7QUFBQTtBQUFBLFlBQzNFLE9BQU8sTUFBTSxhQUFhLGVBQWUsQ0FBQyxJQUFJLFdBQVcsa0JBQWtCLElBQUksT0FBTyxHQUFHO0FBQUEsbUJBQzVFLE1BQU0sYUFBYSxlQUFlLENBQUM7QUFBQTtBQUFBO0FBQUEsWUFHaEQ7QUFBQSxZQUFJLE9BQU8sWUFBWSxjQUFjLFlBQVk7QUFBQSxVQUNuRDtBQUFBLFFBQ0Y7QUFFQSxnQkFBUTtBQUFBLFVBQ0o7QUFBQSxZQUNJO0FBQUEsWUFBVSxFQUFDLE1BQU0sV0FBVyxVQUFVLG1CQUFtQixDQUFDLE1BQU0sRUFBQztBQUFBLFlBQUcsQ0FBQyxRQUFRLE9BQU8sQ0FBQyxDQUFDO0FBQUEsWUFBRztBQUFBLFlBQ3pGLENBQUMsV0FBVyxJQUFJO0FBQUE7QUFBQSxZQUFtQixXQUFXO0FBQUEsVUFBUTtBQUFBLFVBQzFELEVBQUMsUUFBUSxDQUFDLENBQUMsRUFBQztBQUFBLFFBQUM7QUFBQSxNQUNuQjtBQUVPLE1BQU0sMkJBQTJCLENBQUMsZUFDckMsNEJBQTRCLFVBQW9FO0FBQUE7QUFBQTs7O0FDbEZwRyxNQW1FTSx5QkFzS08sdUJBdUZQLHVCQXNHQSx5QkErRU8sZ0JBU1AsU0FtSE87QUFqbkJiO0FBQUE7QUFBQTtBQUdBO0FBRUE7QUFFQTtBQTREQSxNQUFNLDBCQUEwQixDQUFDLFFBQStCLGVBQW9EO0FBbUNsSCxjQUFNLFFBQVEsT0FBTyxDQUFDO0FBQ3RCLGNBQU0sVUFBVSxPQUFPLENBQUM7QUFDeEIsY0FBTSxPQUFPLE9BQU8sQ0FBQztBQUNyQixjQUFNLFlBQVksT0FBTyxDQUFDO0FBQzFCLGNBQU0sT0FBTyxPQUFPLENBQUM7QUFDckIsY0FBTSx1QkFBdUIsT0FBTyxDQUFDO0FBRXJDLFlBQUksUUFBUSxzQkFBc0I7QUFDaEMsZ0JBQU0sSUFBSSxNQUFNLDREQUE0RDtBQUFBLFFBQzlFO0FBRUEsWUFBSSxNQUFNLEtBQUssV0FBVyxHQUFHO0FBQzNCLGdCQUFNLElBQUksTUFBTSxzQ0FBc0M7QUFBQSxRQUN4RDtBQUVBLGNBQU0sWUFBWSxNQUFNLEtBQUssQ0FBQztBQUM5QixjQUFNLGlCQUFpQixNQUFNLEtBQUssQ0FBQztBQUNuQyxjQUFNLGtCQUFrQixNQUFNLEtBQUssQ0FBQztBQUVwQyxZQUFJLEtBQUssS0FBSyxXQUFXLEdBQUc7QUFDMUIsZ0JBQU0sSUFBSSxNQUFNLCtDQUErQztBQUFBLFFBQ2pFO0FBRUEsWUFBSSxRQUFRLEtBQUssV0FBVyxHQUFHO0FBQzdCLGdCQUFNLElBQUksTUFBTSxrREFBa0Q7QUFBQSxRQUNwRTtBQUVBLFlBQUksUUFBUSxLQUFLLENBQUMsTUFBTSxpQkFBaUI7QUFDdkMsZ0JBQU0sSUFBSSxNQUFNLHVFQUF1RTtBQUFBLFFBQ3pGO0FBRUEsWUFBSSxLQUFLLEtBQUssQ0FBQyxNQUFNLFFBQVEsS0FBSyxDQUFDLEdBQUc7QUFDcEMsZ0JBQU0sSUFBSSxNQUFNLG9GQUFvRjtBQUFBLFFBQ3RHO0FBRUEsWUFBSSxjQUFjLEtBQUssS0FBSyxDQUFDLElBQUk7QUFDakMsWUFBSSxjQUFjO0FBQ2xCLFlBQUksY0FBYztBQUNsQixZQUFJLFdBQVcsZUFBZSxTQUFTLEdBQUc7QUFDeEMsY0FBSSxXQUFXLGVBQWUsV0FBVyxHQUFHO0FBQzFDLGtCQUFNLElBQUksTUFBTSxtREFBbUQ7QUFBQSxVQUNyRTtBQUNBLHFCQUFXLE1BQU0sV0FBVyxnQkFBZ0I7QUFDMUMsZ0JBQUksS0FBSyxXQUFXLGFBQWEsR0FBRztBQUNsQyxvQkFBTSxJQUFJLE1BQU0sbURBQW1EO0FBQUEsWUFDckU7QUFBQSxVQUNGO0FBRUEsd0JBQWMsV0FBVyxlQUFlLENBQUM7QUFDekMsd0JBQWMsV0FBVyxlQUFlLENBQUM7QUFDekMsd0JBQWMsV0FBVyxlQUFlLENBQUM7QUFBQSxRQUMzQztBQUVBLGNBQU0sbUJBQW1CO0FBRXpCLFlBQUksZ0JBQWdCLGFBQWE7QUFDL0IsZ0JBQU0sSUFBSSxNQUFNLDZEQUE2RDtBQUFBLFFBQy9FO0FBRUEsWUFBSSxLQUFLLEtBQUssQ0FBQyxNQUFNLGNBQWMsY0FBYyxhQUFhO0FBQzVELGdCQUFNLElBQUksTUFBTSwrRUFBK0U7QUFBQSxRQUNqRztBQUVBLFlBQUkscUJBQXFCO0FBQ3pCLFlBQUksTUFBTTtBQUNSLGNBQUksZ0JBQWdCLGFBQWE7QUFDL0Isa0JBQU0sSUFBSSxNQUFNLG9EQUFvRDtBQUFBLFVBQ3RFO0FBQ0EsY0FBSSxLQUFLLEtBQUssV0FBVyxHQUFHO0FBQzFCLGtCQUFNLElBQUksTUFBTSxxQ0FBcUM7QUFBQSxVQUN2RDtBQUNBLGNBQUksS0FBSyxLQUFLLENBQUMsTUFBTSxHQUFHO0FBQ3RCLGtCQUFNLElBQUksTUFBTSx3Q0FBd0M7QUFBQSxVQUMxRDtBQUNBLGNBQUksS0FBSyxLQUFLLENBQUMsTUFBTSxXQUFXO0FBQzlCLGtCQUFNLElBQUksTUFBTSxrREFBa0Q7QUFBQSxVQUNwRTtBQUNBLGNBQUksS0FBSyxLQUFLLENBQUMsTUFBTSxXQUFXLFVBQVU7QUFDeEMsa0JBQU0sSUFBSSxNQUFNLGdEQUFnRDtBQUFBLFVBQ2xFO0FBQ0EsY0FBSSxLQUFLLEtBQUssQ0FBQyxNQUFNLGNBQWMsV0FBVyxVQUFVO0FBQ3RELGtCQUFNLElBQUksTUFBTSxnRUFBZ0U7QUFBQSxVQUNsRjtBQUVBLGNBQUksQ0FBQyxXQUFXLHdCQUF3QjtBQUN0QyxpQ0FBcUIsS0FBSyxLQUFLLENBQUM7QUFBQSxVQUNsQztBQUFBLFFBRUY7QUFFQSxjQUFNLHNCQUFzQixtQkFBbUI7QUFDL0MsY0FBTSxvQkFBb0I7QUFFMUIsY0FBTSxXQUFXO0FBQ2pCLFlBQUksV0FBVztBQUdiLGdCQUFNLElBQUksTUFBTSxvQkFBb0I7QUFBQSxRQUN0QztBQUVBLFlBQUksTUFBTTtBQUNSLGdCQUFNLElBQUksTUFBTSx1QkFBdUI7QUFBQSxRQUN6QztBQUNBLFlBQUksc0JBQXNCO0FBQ3hCLGdCQUFNLElBQUksTUFBTSx1Q0FBdUM7QUFBQSxRQUN6RDtBQUVBLGVBQU87QUFBQSxVQUNMO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQSxZQUFZO0FBQUEsVUFDWjtBQUFBLFVBQ0EsVUFBVSxLQUFLLE1BQU0sY0FBYyxXQUFXLFFBQVE7QUFBQSxVQUN0RCxXQUFXLEtBQUssTUFBTSxjQUFjLFdBQVcsUUFBUTtBQUFBLFVBQ3ZELFVBQVUsV0FBVztBQUFBLFVBQ3JCLGtCQUFrQjtBQUFBLFVBQ2xCLHdCQUF3QjtBQUFBLFVBQ3hCLGlCQUFpQixXQUFXO0FBQUEsVUFDNUI7QUFBQSxVQUNBLE9BQU8sV0FBVztBQUFBLFVBQ2xCLHFCQUFxQjtBQUFBLFVBQ3JCLGNBQWM7QUFBQSxVQUNkLFdBQVc7QUFBQSxRQUNiO0FBQUEsTUFDRjtBQUVPLE1BQU0sd0JBQXdCLENBQUMsU0FBeUIsT0FBbUIsR0FBVyxNQUFjO0FBQ3pHLGNBQU0sYUFBYSxpQkFBaUIsQ0FBQztBQUNyQyxZQUFJLEtBQUs7QUFDVCxjQUFNLFFBQVEsSUFBSTtBQUNsQixZQUFJLFFBQVEsSUFBSTtBQUNkLGVBQUs7QUFBQSxRQUNQLFdBQVcsUUFBUSxJQUFJLElBQUk7QUFDekIsZUFBSyxLQUFLLEtBQUssUUFBUSxDQUFDO0FBQUEsUUFDMUI7QUFDQSxjQUFNLGdCQUFnQixLQUFLLEtBQUssSUFBSSxhQUFhLEVBQUU7QUFDbkQsY0FBTSxpQkFBaUIsMkJBQTJCLE1BQU0sUUFBUTtBQUNoRSxjQUFNLGtCQUNGLENBQUMsRUFBQyxNQUFNLGdCQUFnQixNQUFNLElBQUksRUFBQyxHQUFHLEVBQUMsTUFBTSxVQUFVLE1BQU0sTUFBSyxHQUFHLEVBQUMsTUFBTSxVQUFVLE1BQU0sY0FBYSxDQUFDO0FBQzlHLGNBQU0sV0FBVyw0QkFBNEIsTUFBTSxVQUFVLFVBQVU7QUFFdkUsY0FBTSxrQkFBa0IsQ0FBQyxpQkFBK0I7QUFDdEQsZ0JBQU0sY0FBYyxlQUFlLEtBQUssTUFBTSxVQUFVLE1BQU0sTUFBTSxVQUFVO0FBQzlFLGNBQUksaUJBQWlCO0FBQ3JCLGNBQUksZUFBZSxHQUFHO0FBQ3BCLDZCQUFpQjtBQUFBLFVBQ25CLFdBQVcsZUFBZSxHQUFHO0FBQzNCLDZCQUNJO0FBQUEsVUFDTjtBQUNBLGdCQUFNLGdCQUFnQiwwQkFBMEIsTUFBTSxRQUFRO0FBQzlELGdCQUFNLFdBQThCO0FBQUEsWUFDbEMsRUFBQyxNQUFNLFNBQVMsTUFBTSxjQUF1QztBQUFBLFlBQUcsRUFBQyxNQUFNLFVBQVUsTUFBTSxNQUFLO0FBQUEsWUFDNUYsRUFBQyxNQUFNLG1CQUFtQixNQUFNLE1BQUs7QUFBQSxVQUN2QztBQUVBLGlCQUFPO0FBQUEscUNBQzBCLEVBQUU7QUFBQSxxQ0FDRixFQUFFO0FBQUEsSUFDbkMsYUFBYSxpQkFBaUIsUUFBUSxFQUFFLGlCQUFpQixXQUFXLENBQUM7QUFBQSxJQUNyRSxhQUFhLFVBQVU7QUFBQSxZQUNyQjtBQUFBLFlBQUk7QUFBQSxZQUFHO0FBQUEsVUFDVCxDQUFDLENBQUM7QUFBQTtBQUFBO0FBQUE7QUFBQSw4QkFJd0IsV0FBVyxPQUFPLFlBQVksZ0JBQWdCLENBQUM7QUFBQTtBQUFBLGdDQUU3QyxVQUFVLGVBQWUsWUFBWSxlQUFlLENBQUM7QUFBQTtBQUFBLHlCQUU1RCxjQUFjO0FBQUE7QUFBQTtBQUFBO0FBQUEsMkJBSVosRUFBRTtBQUFBO0FBQUE7QUFBQTtBQUFBLHNCQUlQLFdBQVcsT0FBTyxZQUFZLEdBQUcsQ0FBQztBQUFBO0FBQUEseUJBRS9CLFVBQVUsZUFBZSxZQUFZLGVBQWUsQ0FBQztBQUFBO0FBQUEseUJBRXJELFVBQVUsYUFBYSxVQUFVLENBQUM7QUFBQTtBQUFBO0FBQUE7QUFBQSwyQkFJaEMsRUFBRTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSwwQkFNSCxXQUFXLE9BQU8sWUFBWSxnQkFBZ0IsQ0FBQztBQUFBO0FBQUE7QUFBQTtBQUFBLHlCQUloRCxVQUFVLGVBQWUsWUFBWSxlQUFlLENBQUM7QUFBQSwwQkFDcEQsWUFBWSxLQUFLLEtBQUs7QUFBQTtBQUFBO0FBQUE7QUFBQSxRQUk5QztBQUVBLGdCQUFRO0FBQUEsVUFDSjtBQUFBLFlBQ0UsTUFBTTtBQUFBLFlBQ04sYUFBYSxFQUFDLE1BQU0sR0FBRyxFQUFFLElBQUksUUFBUSxJQUFJLFVBQVUsR0FBRTtBQUFBLFlBQ3JEO0FBQUEsWUFDQSxZQUFZLE9BQU8sRUFBQyxTQUFTLENBQUMsR0FBRyxlQUFlLEVBQUMsR0FBRyxFQUFDLEdBQUcsZ0JBQWU7QUFBQSxVQUN6RTtBQUFBLFVBQ0EsRUFBQyxRQUFRLENBQUMsS0FBSyxHQUFHLFNBQVMsQ0FBQyxFQUFDO0FBQUEsUUFBQztBQUFBLE1BQ3BDO0FBRUEsTUFBTSx3QkFDRixDQUFDLFNBQXlCLEdBQWUsS0FBaUIsT0FDekQsWUFBaUMsZUFBK0I7QUFDL0QsY0FBTSxhQUFhO0FBQUEsVUFDakIsV0FBVztBQUFBLFVBQVcsV0FBVztBQUFBLFVBQVUsV0FBVztBQUFBLFVBQ3RELFdBQVcsbUJBQW1CLFdBQVc7QUFBQSxRQUMzQztBQUdBLGNBQU0sUUFBUSxXQUFXLFVBQVUsSUFBSSxJQUFNLEtBQUssS0FBSyxXQUFXLFFBQVEsSUFBSSxXQUFXO0FBQ3pGLGNBQU0sYUFBYSxpQkFBaUIsV0FBVyxRQUFRO0FBQ3ZELGNBQU0scUJBQXFCLFdBQVcsV0FBVztBQUNqRCxjQUFNLFlBQVk7QUFDbEIsY0FBTSxXQUFXO0FBQUEsVUFDZixHQUFHLEtBQUssS0FBSyxXQUFXLHNCQUFzQixTQUFTO0FBQUEsVUFDdkQsR0FBRyxLQUFLLEtBQUssV0FBVyxpQkFBaUIsU0FBUztBQUFBLFVBQ2xELEdBQUcsV0FBVyxZQUFZLFdBQVc7QUFBQSxRQUN2QztBQUNBLGNBQU0saUJBQWlCLDJCQUEyQixFQUFFLFFBQVE7QUFDNUQsY0FBTSxrQkFBb0M7QUFBQSxVQUN4QyxFQUFDLE1BQU0sVUFBVSxNQUFNLFdBQVcsZUFBYztBQUFBLFVBQUcsRUFBQyxNQUFNLFVBQVUsTUFBTSxtQkFBa0I7QUFBQSxVQUM1RixFQUFDLE1BQU0sVUFBVSxNQUFNLFdBQVcsb0JBQW1CO0FBQUEsVUFBRyxFQUFDLE1BQU0sVUFBVSxNQUFNLFdBQVcsaUJBQWdCO0FBQUEsVUFDMUcsRUFBQyxNQUFNLGdCQUFnQixNQUFNLE1BQUs7QUFBQSxRQUNwQztBQUVBLGNBQU0sU0FBUyxDQUFDLEdBQUcsR0FBRztBQUV0QixjQUFNLGtCQUFrQixDQUFDLGlCQUErQjtBQUN0RCxnQkFBTSxTQUFTLGNBQWMsS0FBSyxFQUFFLFVBQVUsRUFBRSxNQUFNLFVBQVU7QUFDaEUsZ0JBQU0sU0FBUyxjQUFjLE9BQU8sSUFBSSxVQUFVLElBQUksTUFBTSxVQUFVO0FBQ3RFLGdCQUFNLFNBQVMsZUFBZSxVQUFVLEVBQUUsVUFBVSxVQUFVO0FBQzlELGdCQUFNLFdBQVcsNEJBQTRCLEVBQUUsUUFBUTtBQUV2RCxnQkFBTSxXQUE4QjtBQUFBLFlBQ2xDLEVBQUMsTUFBTSxLQUFLLE1BQU0sTUFBSztBQUFBLFlBQUcsRUFBQyxNQUFNLEtBQUssTUFBTSxNQUFLO0FBQUEsWUFBRyxFQUFDLE1BQU0sS0FBSyxNQUFNLE1BQUs7QUFBQSxZQUMzRSxFQUFDLE1BQU0sc0JBQXNCLE1BQU0sTUFBSztBQUFBLFlBQUcsRUFBQyxNQUFNLFNBQVMsTUFBTSxTQUFrQztBQUFBLFVBQ3JHO0FBQ0EsaUJBQU87QUFBQSxnQkFDQyxRQUFRO0FBQUEsc0JBQ0YsU0FBUztBQUFBO0FBQUEsZ0NBRUMsT0FBTyxLQUFLLE9BQU8sS0FBSyxZQUFZLFNBQVM7QUFBQSxnQ0FDN0MsT0FBTyxLQUFLLE9BQU8sS0FBSyxZQUFZLFNBQVM7QUFBQSxJQUN6RSxhQUFhLGlCQUFpQixRQUFRLEVBQUUsaUJBQWlCLFFBQVEsUUFBUSxNQUFNLENBQUM7QUFBQSxJQUNoRixhQUFhLFVBQVU7QUFBQSxZQUNqQjtBQUFBLFlBQVc7QUFBQSxZQUFXO0FBQUEsVUFDeEIsQ0FBQyxDQUFDO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxrQkFXUSxXQUFXLFVBQVUsVUFBVSxDQUFDO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSw0QkFvQnRCLFVBQVUsU0FBUyxVQUFVLENBQUM7QUFBQTtBQUFBO0FBQUEsUUFHcEQ7QUFFQSxjQUFNLFFBQVEsUUFBUTtBQUFBLFVBQ2xCO0FBQUEsWUFDRSxNQUFNO0FBQUEsWUFDTixhQUFhLEVBQUMsTUFBTSxHQUFHLFVBQVUsSUFBSSxtQkFBbUIsQ0FBQyxRQUFRLE1BQU0sRUFBQztBQUFBLFlBQ3hFLFlBQVksT0FBTztBQUFBLGNBQ2pCLFNBQVMsQ0FBQyxFQUFDLE1BQU0sWUFBWSxVQUFVLEVBQUUsVUFBVSw2QkFBZ0MsQ0FBQztBQUFBLGNBQ3BGLGVBQWU7QUFBQSxjQUNmO0FBQUEsWUFDRjtBQUFBLFlBQ0E7QUFBQSxVQUNGO0FBQUEsVUFDQSxFQUFDLFFBQVEsU0FBUyxDQUFDLEVBQUUsRUFBQztBQUFBLFFBQUMsRUFBRSxDQUFDO0FBRTlCO0FBQUEsVUFDSTtBQUFBLFVBQVM7QUFBQSxVQUFPLFdBQVcsWUFBWSxXQUFXLFdBQVcsV0FBVztBQUFBLFVBQ3hFLFdBQVc7QUFBQSxRQUFtQjtBQUVsQyxlQUFPO0FBQUEsTUFDVDtBQUVKLE1BQU0sMEJBQ0YsQ0FBQyxTQUF5QixPQUFtQixHQUFlLFdBQWdDO0FBQzFGLGNBQU0sY0FBYyxDQUFDLE9BQU8sV0FBVyxPQUFPLGdCQUFnQixPQUFPLFdBQVc7QUFDaEYsY0FBTSxZQUFZO0FBQ2xCLGNBQU0sV0FBVztBQUFBLFVBQ2YsR0FBRyxLQUFLLEtBQUssT0FBTyxZQUFZLFNBQVM7QUFBQSxVQUN6QyxHQUFHLEtBQUssS0FBSyxPQUFPLGlCQUFpQixTQUFTO0FBQUEsVUFDOUMsR0FBRyxPQUFPLFlBQVksT0FBTztBQUFBLFFBQy9CO0FBQ0EsY0FBTSxrQkFBb0M7QUFBQSxVQUN4QyxFQUFDLE1BQU0sVUFBVSxNQUFNLE9BQU8sZUFBYztBQUFBLFVBQUcsRUFBQyxNQUFNLFVBQVUsTUFBTSxPQUFPLG9CQUFtQjtBQUFBLFVBQ2hHLEVBQUMsTUFBTSxVQUFVLE1BQU0sT0FBTyxVQUFTO0FBQUEsVUFBRyxFQUFDLE1BQU0sVUFBVSxNQUFNLE9BQU8sU0FBUTtBQUFBLFVBQ2hGLEVBQUMsTUFBTSxVQUFVLE1BQU0sT0FBTyxZQUFXO0FBQUEsUUFDM0M7QUFFQSxjQUFNLGtCQUFrQixDQUFDLGlCQUErQjtBQUN0RCxnQkFBTSxjQUFjLGNBQWMsU0FBUyxNQUFNLFVBQVUsTUFBTSxJQUFJO0FBQ3JFLGdCQUFNLFVBQVUsY0FBYyxLQUFLLEVBQUUsVUFBVSxFQUFFLElBQUk7QUFDckQsZ0JBQU0sU0FBUyxlQUFlLFVBQVUsTUFBTSxVQUFVLFdBQVc7QUFDbkUsZ0JBQU0sV0FBOEI7QUFBQSxZQUNsQyxFQUFDLE1BQU0sS0FBSyxNQUFNLE1BQUs7QUFBQSxZQUFHLEVBQUMsTUFBTSxLQUFLLE1BQU0sTUFBSztBQUFBLFlBQUcsRUFBQyxNQUFNLEtBQUssTUFBTSxNQUFLO0FBQUEsWUFDM0UsRUFBQyxNQUFNLGFBQWEsTUFBTSxNQUFLO0FBQUEsWUFBRyxFQUFDLE1BQU0saUJBQWlCLE1BQU0sTUFBSztBQUFBLFVBQ3ZFO0FBQ0EsaUJBQU87QUFBQSxzQkFDTyxTQUFTO0FBQUEsZ0NBQ0MsWUFBWSxLQUFLLEtBQUssS0FBSyxZQUFZLFNBQVM7QUFBQSxnQ0FDaEQsWUFBWSxLQUFLLEtBQUssS0FBSyxZQUFZLFNBQVM7QUFBQSxJQUM1RSxhQUFhLGlCQUFpQixRQUFRLEVBQUUsaUJBQWlCLGFBQWEsU0FBUyxNQUFNLENBQUM7QUFBQSxJQUN0RixhQUFhLFVBQVU7QUFBQSxZQUNqQjtBQUFBLFlBQVc7QUFBQSxZQUFXO0FBQUEsVUFDeEIsQ0FBQyxDQUFDO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxpQkFRTyxZQUFZLEtBQUssT0FBTztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFFBeUJuQztBQUVBLGVBQU8sUUFBUTtBQUFBLFVBQ1g7QUFBQSxZQUNFLE1BQU07QUFBQSxZQUNOLGFBQWEsRUFBQyxtQkFBbUIsQ0FBQyxRQUFRLE1BQU0sRUFBQztBQUFBLFlBQ2pELFlBQVksT0FBTztBQUFBLGNBQ2pCLFNBQVMsQ0FBQyxFQUFDLE1BQU0sYUFBYSxVQUFVLE1BQU0sVUFBVSw2QkFBZ0MsQ0FBQztBQUFBLGNBQ3pGLGVBQWU7QUFBQSxjQUNmO0FBQUEsWUFDRjtBQUFBLFlBQ0E7QUFBQSxVQUNGO0FBQUEsVUFDQSxFQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUMsR0FBRyxTQUFTLENBQUMsQ0FBQyxFQUFDO0FBQUEsUUFBQyxFQUFFLENBQUM7QUFBQSxNQUMzQztBQUVHLE1BQU0saUJBQ1QsQ0FBQyxTQUF5QixHQUFlLEdBQWUsR0FBZSxZQUN0RSxPQUE2QixVQUFnQyxZQUM3RCxzQkFBNEMsWUFBaUMsZUFBK0I7QUFDM0csY0FBTSxRQUFRLHNCQUFzQixTQUFTLEdBQUcsR0FBRyxzQkFBc0IsWUFBWSxVQUFVO0FBRS9GLGdDQUF3QixTQUFTLE9BQU8sR0FBRyxVQUFVO0FBQUEsTUFDdkQ7QUFFSixNQUFNLFVBQVUsQ0FBQyxTQUF5QixlQUFvQztBQUM1RSxjQUFNLGNBQWM7QUFBQSxVQUNsQixXQUFXO0FBQUEsVUFDWCxXQUFXO0FBQUEsVUFDWCxXQUFXO0FBQUEsVUFDWCxXQUFXO0FBQUEsUUFDYjtBQUNBLGNBQU0sSUFBSSxXQUFXO0FBQ3JCLGNBQU0sSUFBSSxXQUFXO0FBQ3JCLGNBQU0sSUFBSSxXQUFXO0FBQ3JCLGNBQU0sWUFBWTtBQUNsQixjQUFNLFdBQVc7QUFBQSxVQUNmLEdBQUcsS0FBSyxLQUFLLFdBQVcsV0FBVyxTQUFTO0FBQUEsVUFDNUMsR0FBRyxLQUFLLEtBQUssV0FBVyxpQkFBaUIsU0FBUztBQUFBLFVBQ2xELEdBQUcsV0FBVyxZQUFZLFdBQVc7QUFBQSxRQUN2QztBQUNBLGNBQU0sU0FBUyxDQUFDLFFBQVEsT0FBTyxDQUFDLEdBQUcsUUFBUSxPQUFPLENBQUMsR0FBRyxRQUFRLE9BQU8sQ0FBQyxDQUFDO0FBQ3ZFLGNBQU0sa0JBQW9DO0FBQUEsVUFDeEMsRUFBQyxNQUFNLFVBQVUsTUFBTSxFQUFDO0FBQUEsVUFBRyxFQUFDLE1BQU0sVUFBVSxNQUFNLEVBQUM7QUFBQSxVQUFHLEVBQUMsTUFBTSxVQUFVLE1BQU0sRUFBQztBQUFBLFVBQzlFLEVBQUMsTUFBTSxVQUFVLE1BQU0sV0FBVyxTQUFRO0FBQUEsVUFBRyxFQUFDLE1BQU0sVUFBVSxNQUFNLFdBQVcsU0FBUTtBQUFBLFVBQ3ZGLEVBQUMsTUFBTSxVQUFVLE1BQU0sV0FBVyxXQUFVO0FBQUEsVUFDNUMsRUFBQyxNQUFNLFVBQVUsTUFBTSxXQUFXLGFBQWEsV0FBVyxhQUFhLFdBQVcsWUFBVztBQUFBLFFBQy9GO0FBRUEsY0FBTSxrQkFBa0IsQ0FBQyxpQkFBK0I7QUFDdEQsZ0JBQU0sVUFBVSxlQUFlLFlBQVksT0FBTyxDQUFDLEVBQUUsVUFBVSxXQUFXO0FBQzFFLGdCQUFNLFVBQVUsZUFBZSxZQUFZLE9BQU8sQ0FBQyxFQUFFLFVBQVUsV0FBVztBQUMxRSxnQkFBTSxVQUFVLGVBQWUsWUFBWSxPQUFPLENBQUMsRUFBRSxVQUFVLFdBQVc7QUFDMUUsZ0JBQU0sUUFBUSxjQUFjLFNBQVMsT0FBTyxDQUFDLEVBQUUsVUFBVSxPQUFPLENBQUMsRUFBRSxJQUFJO0FBQ3ZFLGdCQUFNLFNBQVMsY0FBYyxVQUFVLE9BQU8sQ0FBQyxFQUFFLFVBQVUsT0FBTyxDQUFDLEVBQUUsSUFBSTtBQUN6RSxnQkFBTSxPQUFPLGNBQWMsUUFBUSxPQUFPLENBQUMsRUFBRSxVQUFVLE9BQU8sQ0FBQyxFQUFFLElBQUk7QUFDckUsZ0JBQU0sV0FBVyxNQUFNLEtBQUs7QUFFNUIsZ0JBQU0sV0FBOEI7QUFBQSxZQUNsQyxFQUFDLE1BQU0sS0FBSyxNQUFNLE1BQUs7QUFBQSxZQUFHLEVBQUMsTUFBTSxLQUFLLE1BQU0sTUFBSztBQUFBLFlBQUcsRUFBQyxNQUFNLEtBQUssTUFBTSxNQUFLO0FBQUEsWUFBRyxFQUFDLE1BQU0sYUFBYSxNQUFNLE1BQUs7QUFBQSxZQUM3RyxFQUFDLE1BQU0sYUFBYSxNQUFNLE1BQUs7QUFBQSxZQUFHLEVBQUMsTUFBTSxlQUFlLE1BQU0sTUFBSztBQUFBLFlBQUcsRUFBQyxNQUFNLE9BQU8sTUFBTSxNQUFLO0FBQUEsVUFDakc7QUFDQSxpQkFBTztBQUFBLHNCQUNXLFNBQVM7QUFBQSxvQ0FDSyxRQUFRLEtBQUssWUFBWSxTQUFTO0FBQUEsc0NBQ2hDLFFBQVEsS0FBSyxZQUFZLFNBQVM7QUFBQSxzQ0FDbEMsUUFBUSxLQUFLLFlBQVksU0FBUztBQUFBLHNDQUNsQyxRQUFRLEtBQUssWUFBWSxTQUFTO0FBQUEsSUFDcEUsYUFBYSxpQkFBaUIsUUFBUSxFQUFFLGlCQUFpQixPQUFPLFFBQVEsTUFBTSxTQUFTLFNBQVMsT0FBTyxDQUFDO0FBQUEsSUFDeEcsYUFBYSxVQUFVO0FBQUEsWUFDckI7QUFBQSxZQUFXO0FBQUEsWUFBVztBQUFBLFVBQ3hCLENBQUMsQ0FBQztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsbUJBV2EsUUFBUTtBQUFBLG1CQUNSLFFBQVE7QUFBQSxtQkFDUixRQUFRO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFFBb0N6QjtBQUVBLGVBQU8sUUFBUTtBQUFBLFVBQ1g7QUFBQSxZQUNFLE1BQU07QUFBQSxZQUNOLGFBQWEsRUFBQyxtQkFBbUIsQ0FBQyxRQUFRLFFBQVEsTUFBTSxFQUFDO0FBQUEsWUFDekQsWUFBWSxPQUFPO0FBQUEsY0FDakIsU0FBUztBQUFBLGdCQUNQLEVBQUMsTUFBTSxhQUFhLFVBQVUsUUFBUSxPQUFPLENBQUMsRUFBRSxVQUFVLDZCQUFnQztBQUFBLGdCQUMxRixFQUFDLE1BQU0sYUFBYSxVQUFVLFFBQVEsT0FBTyxDQUFDLEVBQUUsVUFBVSw2QkFBZ0M7QUFBQSxnQkFDMUYsRUFBQyxNQUFNLGFBQWEsVUFBVSxRQUFRLE9BQU8sQ0FBQyxFQUFFLFVBQVUsNkJBQWdDO0FBQUEsY0FDNUY7QUFBQSxjQUNBLGVBQWU7QUFBQSxjQUNmO0FBQUEsWUFDRjtBQUFBLFlBQ0E7QUFBQSxVQUNGO0FBQUEsVUFDQSxFQUFDLFFBQVEsU0FBUyxDQUFDLElBQUksSUFBSSxFQUFFLEVBQUM7QUFBQSxRQUFDO0FBQUEsTUFDckM7QUFFTyxNQUFNLFlBQVksQ0FBQyxTQUF5QixlQUFxQztBQUN0RixjQUFNLFNBQVMsd0JBQXdCLFFBQVEsUUFBUSxVQUFVO0FBRWpFLGNBQU0sQ0FBQyxHQUFHLEdBQUcsQ0FBQyxJQUFJLFFBQVEsU0FBUyxNQUFNO0FBRXpDLGVBQU87QUFBQSxVQUNIO0FBQUEsVUFBUztBQUFBLFVBQUc7QUFBQSxVQUFHO0FBQUEsVUFBRyxRQUFRLE9BQU8sQ0FBQztBQUFBLFVBQUc7QUFBQSxVQUFXO0FBQUEsVUFBVztBQUFBLFVBQVcsUUFBUSxPQUFPLENBQUM7QUFBQSxVQUFHO0FBQUEsVUFBUTtBQUFBLFFBQVU7QUFBQSxNQUNqSDtBQUFBO0FBQUE7OztBQ3huQkEsTUFxQk1DLGlCQWtDQSxxQ0FnRk8sMEJBR0E7QUExSWI7QUFBQTtBQUFBO0FBR0E7QUFHQTtBQUNBO0FBR0E7QUFXQSxNQUFNQSxrQkFBaUIsQ0FBQyxRQUErQixlQUEwQztBQUMvRixZQUFJLENBQUMsVUFBVSxPQUFPLFdBQVcsR0FBRztBQUNsQyxnQkFBTSxJQUFJLE1BQU0sc0NBQXNDO0FBQUEsUUFDeEQ7QUFFQSxjQUFNLGtCQUFrQixDQUFDLFFBQTJCLFVBQTZCLFlBQW9CO0FBQ25HLGdCQUFNLElBQUksU0FBUztBQUNuQixjQUFJLE1BQU0sT0FBTyxRQUFRO0FBQ3ZCLGtCQUFNLElBQUksTUFBTSxHQUFHLE9BQU8sdUJBQXVCLENBQUMsRUFBRTtBQUFBLFVBQ3REO0FBQ0EsbUJBQVMsUUFBUSxDQUFDLEdBQUcsTUFBTTtBQUN6QixnQkFBSSxNQUFNLE9BQU8sQ0FBQyxHQUFHO0FBQ25CLG9CQUFNLElBQUksTUFBTSxHQUFHLE9BQU8sU0FBUyxDQUFDLGdCQUFnQjtBQUFBLFlBQ3REO0FBQUEsVUFDRixDQUFDO0FBQUEsUUFDSDtBQUVBLFlBQUksT0FBTyxDQUFDLEVBQUUsS0FBSyxTQUFTLEdBQUc7QUFDN0IsZ0JBQU0sUUFBUSxXQUFXLFdBQVcsU0FDL0IsV0FBVyxVQUFVLE9BQU8sQ0FBQyxFQUFFLEtBQUssTUFBTSxFQUFFLElBQ3ZCLE9BQU8sQ0FBQyxFQUFFLEtBQUssTUFBTSxFQUFFLEVBQUUsT0FBTyxPQUFPLENBQUMsRUFBRSxLQUFLLE1BQU0sR0FBRyxPQUFPLENBQUMsRUFBRSxLQUFLLFNBQVMsQ0FBQyxDQUFDLElBQ3hHLE9BQU8sQ0FBQyxFQUFFLEtBQUssTUFBTSxHQUFHLFdBQVcsVUFBVSxJQUFJLE1BQVM7QUFDOUQsMEJBQWdCLE9BQU8sQ0FBQyxFQUFFLE1BQU0sT0FBTyxxQkFBcUI7QUFDNUQsMEJBQWdCLE9BQU8sQ0FBQyxFQUFFLE1BQU0sT0FBTyxpQkFBaUI7QUFDeEQsMEJBQWdCLE9BQU8sQ0FBQyxFQUFFLE1BQU0sT0FBTyxvQkFBb0I7QUFDM0QsMEJBQWdCLE9BQU8sQ0FBQyxFQUFFLE1BQU0sT0FBTyxtQkFBbUI7QUFBQSxRQUM1RCxPQUFPO0FBQ0wsMEJBQWdCLE9BQU8sQ0FBQyxFQUFFLE1BQU0sQ0FBQyxDQUFDLEdBQUcscUJBQXFCO0FBQzFELDBCQUFnQixPQUFPLENBQUMsRUFBRSxNQUFNLENBQUMsQ0FBQyxHQUFHLGlCQUFpQjtBQUN0RCwwQkFBZ0IsT0FBTyxDQUFDLEVBQUUsTUFBTSxDQUFDLENBQUMsR0FBRyxvQkFBb0I7QUFDekQsMEJBQWdCLE9BQU8sQ0FBQyxFQUFFLE1BQU0sQ0FBQyxDQUFDLEdBQUcsbUJBQW1CO0FBQUEsUUFDMUQ7QUFBQSxNQUNGO0FBRUEsTUFBTSxzQ0FDRixDQUFDLFFBQStCLGVBQWlEO0FBQy9FLGNBQU0sRUFBQyxTQUFTLFNBQVMsT0FBTSxJQUFJO0FBQ25DLGNBQU0sU0FBUyxPQUFPLENBQUMsRUFBRTtBQUN6QixjQUFNLGFBQWEsVUFBVSxpQkFBaUIsT0FBTyxPQUFPLFNBQVMsQ0FBQyxDQUFDLElBQUk7QUFDM0UsY0FBTSxjQUFjLFdBQVcsVUFBVSxPQUFPLFNBQVMsSUFBSSxhQUFhO0FBQzFFLGNBQU0sYUFBYSxVQUFVLEtBQUssTUFBTSxJQUFJO0FBRTVDLGNBQU0sb0JBQW9CLHFCQUFxQixPQUFPLE1BQU0sS0FBSztBQUNqRSxjQUFNLGNBQWMsb0JBQW9CLE9BQU8sU0FBUztBQUN4RCxjQUFNLElBQUksY0FBYyxLQUFLLE9BQU8sQ0FBQyxFQUFFLFVBQVUsT0FBTyxDQUFDLEVBQUUsTUFBTSxVQUFVO0FBQzNFLGNBQU0sUUFBUSxjQUFjLFNBQVMsT0FBTyxDQUFDLEVBQUUsVUFBVSxPQUFPLENBQUMsRUFBRSxNQUFNLFdBQVc7QUFDcEYsY0FBTSxPQUFPLGNBQWMsUUFBUSxPQUFPLENBQUMsRUFBRSxVQUFVLE9BQU8sQ0FBQyxFQUFFLE1BQU0sV0FBVztBQUNsRixjQUFNLFlBQVksY0FBYyxhQUFhLE9BQU8sQ0FBQyxFQUFFLFVBQVUsT0FBTyxDQUFDLEVBQUUsTUFBTSxXQUFXO0FBQzVGLGNBQU0sV0FBVyxjQUFjLFlBQVksT0FBTyxDQUFDLEVBQUUsVUFBVSxPQUFPLENBQUMsRUFBRSxNQUFNLFdBQVc7QUFDMUYsY0FBTSxJQUFJLGVBQWUsS0FBSyxPQUFPLENBQUMsRUFBRSxVQUFVLGFBQWEsVUFBVTtBQUd6RSxjQUFNLGNBQWMsTUFBYztBQUNoQyxjQUFJLFVBQVU7QUFDZCxjQUFJLFNBQVM7QUFDWCxzQkFBVSxpQkFDTixPQUFPLFdBQVcsSUFBTSxPQUNwQixXQUFXLFNBQVMsaUJBQWlCLE9BQU8sU0FBUyxDQUFDLE9BQU8sVUFBVSxLQUNuRCxrQkFBa0I7QUFBQSxVQUNoRCxPQUFPO0FBQ0wsZ0JBQUksV0FBVyxRQUFRO0FBQ3JCLHdCQUFVO0FBQUEsY0FDUixFQUFFLFdBQVcsaUJBQWlCLEtBQUssR0FBRyxDQUFDO0FBQUEsNEJBQ3pCLEVBQUUsZ0JBQWdCLGVBQWUsQ0FBQztBQUFBLFlBQ3BELE9BQU87QUFFTCx3QkFBVSxrQkFBa0IsTUFBTSxLQUFLLE9BQU87QUFBQSxxREFDTCxPQUFPLFNBQVMsQ0FBQztBQUUxRCx1QkFBUyxJQUFJLEdBQUcsSUFBSSxNQUFNLE1BQU0sS0FBSztBQUNuQywyQkFBVyxZQUFZLENBQUMscUJBQXFCLENBQUM7QUFBQSxjQUNoRDtBQUNBLHlCQUFXLGlCQUFpQixNQUFNLGdCQUFnQixVQUFVLENBQUM7QUFBQSxZQUMvRDtBQUFBLFVBQ0Y7QUFDQSxpQkFBTztBQUFBLFFBQ1Q7QUFDQSxjQUFNLCtCQUErQixDQUFDLFdBQXlCO0FBQUEsb0JBQ2pELE9BQU87QUFBQSxJQUN2QixPQUFPLGdCQUFnQixjQUFjLEtBQUssRUFBRSxpQkFBaUIsR0FBRyxPQUFPLE1BQU0sV0FBVyxVQUFVLENBQUMsQ0FBQztBQUFBLElBQ3BHLE9BQU8sVUFBVSxDQUFDO0FBQUEsSUFDbEIsT0FBTyxzQ0FBc0MscUJBQXFCLENBQUM7QUFBQSwwQkFDN0MsRUFBRSxnQkFBZ0IsZ0JBQWdCLFVBQVUsRUFBRSxDQUFDO0FBQUEsTUFDbkUsWUFBWSxDQUFDO0FBQUEsa0JBQ0QsTUFBTSxZQUFZLFNBQVMsQ0FBQztBQUFBLGlCQUM3QixLQUFLLFlBQVksU0FBUyxDQUFDO0FBQUEsc0JBQ3RCLFVBQVUsWUFBWSxTQUFTLENBQUM7QUFBQSxxQkFDakMsU0FBUyxZQUFZLFNBQVMsQ0FBQztBQUFBLGNBQ3RDLEVBQUUsWUFBWSxZQUFZLENBQUM7QUFBQTtBQUFBLE1BRW5DLEVBQUUsWUFBWSxjQUFjLE9BQU8sQ0FBQztBQUFBO0FBRXBDLGVBQU87QUFBQSxVQUNMLE1BQU07QUFBQSxVQUNOLGFBQWE7QUFBQSxZQUNYLE1BQU0sR0FBRyxXQUFXLE9BQU8sSUFBSSxXQUFXLE1BQU0sSUFBSSxPQUFPLElBQUksVUFBVTtBQUFBLFlBQ3pFLG1CQUFtQixvQkFBb0IsQ0FBQyxRQUFRLFFBQVEsUUFBUSxRQUFRLE1BQU0sSUFBSTtBQUFBLFVBQ3BGO0FBQUEsVUFDQSxpQkFBaUI7QUFBQSxVQUNqQixZQUFZLE9BQU87QUFBQSxZQUNqQixTQUFTLENBQUMsRUFBQyxNQUFNLE9BQU8sQ0FBQyxFQUFFLE1BQU0sVUFBVSxPQUFPLENBQUMsRUFBRSxTQUFRLENBQUM7QUFBQSxZQUM5RCxlQUFlLEVBQUMsR0FBRyxLQUFLO0FBQUEsY0FBSyxhQUFhO0FBQUE7QUFBQSxZQUF1QixFQUFDO0FBQUEsWUFDbEUsaUJBQWlCLG9CQUNiO0FBQUEsY0FDRSxFQUFDLE1BQU0sVUFBVSxNQUFNLFdBQVU7QUFBQSxjQUNqQyxHQUFHLDJCQUEyQixNQUFNO0FBQUEsWUFDdEMsSUFDQTtBQUFBLGNBQ0UsRUFBQyxNQUFNLFVBQVUsTUFBTSxXQUFVO0FBQUEsWUFDbkM7QUFBQSxVQUNOO0FBQUEsUUFDRjtBQUFBLE1BQ0Y7QUFFRyxNQUFNLDJCQUEyQixDQUFDLGVBQ3JDLDRCQUE0QixVQUFvRTtBQUU3RixNQUFNLFlBQVksQ0FBQyxTQUF5QixlQUE4QztBQUMvRixjQUFNLEVBQUMsUUFBUSxZQUFXLElBQUk7QUFDOUIsY0FBTSxvQkFBb0IseUJBQXlCLEVBQUMsR0FBRyxZQUFZLFlBQVcsQ0FBQztBQUMvRSxZQUFJQyxLQUFJLE9BQU8sc0JBQXNCO0FBQ25DLFVBQUFELGdCQUFlLFFBQVEsaUJBQWlCO0FBQUEsUUFDMUM7QUFDQSxZQUFJLFdBQVcsY0FBYztBQUMzQixnQkFBTSxJQUFJLE1BQU0sdURBQXVEO0FBQUEsUUFDekUsT0FBTztBQUNMLGtCQUFRLFFBQVEsb0NBQW9DLFFBQVEsaUJBQWlCLENBQUM7QUFBQSxRQUNoRjtBQUFBLE1BQ0Y7QUFBQTtBQUFBOzs7QUNySkEsTUFTTUUsaUJBa0JBLDBCQWtDTztBQTdEYjtBQUFBO0FBQUE7QUFJQTtBQUdBO0FBRUEsTUFBTUEsa0JBQWlCLENBQUMsV0FBd0M7QUFDOUQsWUFBSSxPQUFPLENBQUMsRUFBRSxLQUFLLFdBQVcsR0FBRztBQUMvQixnQkFBTSxJQUFJLE1BQU0sZ0NBQWdDO0FBQUEsUUFDbEQ7QUFFQSxZQUFJLENBQUMsQ0FBQyxLQUFLLEtBQUssSUFBSSxFQUFFLFNBQVMsT0FBTyxDQUFDLEVBQUUsS0FBSyxDQUFDLENBQUMsR0FBRztBQUNqRCxnQkFBTSxJQUFJLE1BQU0sK0NBQStDO0FBQUEsUUFDakU7QUFFQSxZQUFJLE9BQU8sQ0FBQyxFQUFFLEtBQUssV0FBVyxHQUFHO0FBQy9CLGdCQUFNLElBQUksTUFBTSx1Q0FBdUM7QUFBQSxRQUN6RDtBQUVBLFlBQUksT0FBTyxDQUFDLEVBQUUsS0FBSyxDQUFDLE1BQU0sT0FBTyxDQUFDLEVBQUUsS0FBSyxDQUFDLEdBQUc7QUFDM0MsZ0JBQU0sSUFBSSxNQUFNLG1EQUFtRDtBQUFBLFFBQ3JFO0FBQUEsTUFDRjtBQUVBLE1BQU0sMkJBQTJCLENBQUMsV0FBK0M7QUFDL0UsY0FBTSxjQUFjLE9BQU8sQ0FBQyxFQUFFO0FBRTlCLGNBQU0sV0FBVyxPQUFPLENBQUMsRUFBRSxLQUFLLENBQUM7QUFFakMsY0FBTSxhQUFhLFVBQVUsS0FBSyxXQUFXLElBQUk7QUFFakQsY0FBTSxXQUFXLE9BQU8sQ0FBQyxFQUFFO0FBQzNCLGNBQU0sUUFBUSxjQUFjLFNBQVMsVUFBVSxhQUFhLENBQUM7QUFDN0QsY0FBTSxPQUFPLGNBQWMsUUFBUSxVQUFVLENBQUMsUUFBUSxHQUFHLENBQUM7QUFDMUQsY0FBTSxXQUFXLGNBQWMsWUFBWSxVQUFVLGFBQWEsQ0FBQztBQUNuRSxjQUFNLFNBQVMsZUFBZSxVQUFVLFVBQVUsYUFBYSxDQUFDO0FBRWhFLGNBQU0sa0JBQWtCLENBQUMsaUJBQStCO0FBQUEscUJBQ3JDLFFBQVE7QUFBQSxJQUN6QixhQUFhLGlCQUFpQixPQUFPLE1BQU0sVUFBVSxNQUFNLENBQUM7QUFBQTtBQUFBLElBRTVELGFBQWEsVUFBVSxDQUFDO0FBQUEsTUFDdEIsYUFBYSxzQ0FBc0MsVUFBVSxDQUFDO0FBQUEsa0JBQ2xELE1BQU0sWUFBWSxZQUFZLENBQUM7QUFBQSxVQUN2QyxLQUFLLFlBQVksdUJBQXVCLENBQUMsTUFBTSxTQUFTLFlBQVksWUFBWSxDQUFDO0FBQUEsTUFDckYsT0FBTyxZQUFZLGNBQWMsT0FBTyxDQUFDO0FBQUE7QUFHN0MsZUFBTztBQUFBLFVBQ0wsTUFBTTtBQUFBLFVBQ04sWUFBWSxPQUFPO0FBQUEsWUFDakIsU0FBUyxDQUFDLEVBQUMsTUFBTSxhQUFhLFVBQVUsT0FBTyxDQUFDLEVBQUUsU0FBUSxDQUFDO0FBQUEsWUFDM0QsZUFBZSxFQUFDLEdBQUcsS0FBSztBQUFBLGNBQUssYUFBYTtBQUFBO0FBQUEsWUFBdUIsRUFBQztBQUFBLFVBQ3BFO0FBQUEsVUFDQTtBQUFBLFFBQ0Y7QUFBQSxNQUNGO0FBRU8sTUFBTSxVQUFVLENBQUMsWUFBa0M7QUFDeEQsUUFBQUEsZ0JBQWUsUUFBUSxNQUFNO0FBQzdCLGdCQUFRLFFBQVEseUJBQXlCLFFBQVEsTUFBTSxDQUFDO0FBQUEsTUFDMUQ7QUFBQTtBQUFBOzs7QUNoRUEsTUFlTSxnQ0E0QkEsOEJBaUJPLEtBSUEsTUFJQSxPQUlBLE1BSUEsT0FJQSxNQUdBLE9BU0EscUJBSUEsTUE4QlAsa0NBTU8sTUFhQSxNQUlBLEtBSUEsTUFRQSxzQkFHQSxLQWdCQSxTQWNBLEtBTUEsS0FJQSxPQUlBLE1BT0EsV0FPQSxLQUlBLEtBSUEsWUFJQSxNQU1BLFNBSUEsS0FJQSxNQUlBLE1BSUEsS0FJQSxNQUlBLGlCQVFBO0FBaFJiO0FBQUE7QUFBQTtBQUdBO0FBRUE7QUFDQTtBQUdBO0FBTUEsTUFBTSxpQ0FDRixDQUFDLGNBQTRCLFVBQWtCLGVBQXVCLGdCQUNyRSxVQUFtQyw2QkFBOEM7QUFDaEYsY0FBTSxVQUFVLEtBQUssS0FBSyxXQUFXLENBQUM7QUFFdEMsWUFBSSxhQUFhO0FBQ2pCLFlBQUksT0FBTyxhQUFhLFVBQVU7QUFDaEMsdUJBQWEsR0FBRyxRQUFRO0FBQUEsUUFDMUIsT0FBTztBQUNMLHVCQUFhLFNBQVMsR0FBRztBQUFBLFFBQzNCO0FBRUEsY0FBTSxRQUFRLGNBQWMsYUFBYSxlQUFlLENBQUMsT0FBTyxHQUFHLENBQUM7QUFDcEUsY0FBTSxTQUFTLGVBQWUsY0FBYyxnQkFBZ0IsQ0FBQyxPQUFPLEdBQUcsQ0FBQztBQUV4RSxlQUFPO0FBQUEsUUFDTCxhQUFhLGdCQUFnQixZQUFZLEtBQUssRUFBRSxpQkFBaUIsT0FBTyxNQUFNLENBQUM7QUFBQTtBQUFBLElBRW5GLDRCQUE0QixFQUFFO0FBQUE7QUFBQSxJQUU5QixhQUFhLFVBQVUsQ0FBQztBQUFBLE1BQ3RCLGFBQWEsc0NBQXNDLG1CQUFtQixDQUFDO0FBQUE7QUFBQSxjQUUvRCxNQUFNLFlBQVksWUFBWSxDQUFDO0FBQUEsTUFDdkMsT0FBTyxZQUFZLGNBQWMsVUFBVSxDQUFDO0FBQUE7QUFBQSxNQUU5QztBQUVKLE1BQU0sK0JBQ0YsQ0FBQyxPQUFtQixNQUFjLFVBQW1DLDBCQUNwRSxVQUFtQixpQkFBeUIsTUFBTSxjQUEyQjtBQUFBLFFBQzVFO0FBQUEsUUFDQSxhQUFhLEVBQUMsTUFBTSxVQUFVLG1CQUFtQixDQUFDLE1BQU0sRUFBQztBQUFBLFFBQ3pELGlCQUFpQixrQkFBZ0I7QUFBQSxVQUM3QjtBQUFBLFVBQWMsVUFBVSxLQUFLLE1BQU0sSUFBSTtBQUFBLFVBQUcsTUFBTTtBQUFBLFVBQVU7QUFBQSxVQUFnQjtBQUFBLFVBQVU7QUFBQSxRQUF3QjtBQUFBLFFBQ2hILFlBQVksQ0FBQyxrQkFBa0I7QUFBQSxVQUM3QixTQUFTLENBQUMsRUFBQyxNQUFNLE1BQU0sTUFBTSxVQUFVLGVBQWMsQ0FBQztBQUFBLFVBQ3RELGVBQ0ksRUFBQyxHQUFHLEtBQUs7QUFBQSxZQUFLLFVBQVUsS0FBSyxhQUFhLENBQUMsRUFBRSxJQUFJLElBQUksS0FBMEI7QUFBQTtBQUFBLFVBQWdCLEVBQUM7QUFBQSxVQUNwRyxpQkFBaUI7QUFBQSxZQUNmLEVBQUMsTUFBTSxVQUFVLE1BQU0sS0FBSyxLQUFLLFVBQVUsS0FBSyxNQUFNLElBQUksSUFBSSxDQUFDLEVBQUM7QUFBQSxVQUNsRTtBQUFBLFFBQ0Y7QUFBQSxNQUNGO0FBRUcsTUFBTSxNQUFNLENBQUMsWUFBa0M7QUFDcEQsZ0JBQVEsUUFBUSw2QkFBNkIsUUFBUSxPQUFPLENBQUMsR0FBRyxPQUFPLEtBQUssQ0FBQztBQUFBLE1BQy9FO0FBRU8sTUFBTSxPQUFPLENBQUMsWUFBa0M7QUFDckQsZ0JBQVEsUUFBUSw2QkFBNkIsUUFBUSxPQUFPLENBQUMsR0FBRyxRQUFRLE1BQU0sQ0FBQztBQUFBLE1BQ2pGO0FBRU8sTUFBTSxRQUFRLENBQUMsWUFBa0M7QUFDdEQsZ0JBQVEsUUFBUSw2QkFBNkIsUUFBUSxPQUFPLENBQUMsR0FBRyxTQUFTLE9BQU8sQ0FBQztBQUFBLE1BQ25GO0FBRU8sTUFBTSxPQUFPLENBQUMsWUFBa0M7QUFDckQsZ0JBQVEsUUFBUSw2QkFBNkIsUUFBUSxPQUFPLENBQUMsR0FBRyxRQUFRLE1BQU0sQ0FBQztBQUFBLE1BQ2pGO0FBRU8sTUFBTSxRQUFRLENBQUMsWUFBa0M7QUFDdEQsZ0JBQVEsUUFBUSw2QkFBNkIsUUFBUSxPQUFPLENBQUMsR0FBRyxTQUFTLE9BQU8sQ0FBQztBQUFBLE1BQ25GO0FBRU8sTUFBTSxPQUFPLENBQUMsWUFBa0M7QUFDckQsZ0JBQVEsUUFBUSw2QkFBNkIsUUFBUSxPQUFPLENBQUMsR0FBRyxRQUFRLE1BQU0sQ0FBQztBQUFBLE1BQ2pGO0FBQ08sTUFBTSxRQUFRLENBQUMsWUFBa0M7QUFDdEQsZ0JBQVEsUUFBUSw2QkFBNkIsUUFBUSxPQUFPLENBQUMsR0FBRyxTQUFTLE9BQU8sQ0FBQztBQUFBLE1BQ25GO0FBT08sTUFBTSxzQkFBc0IsQ0FBQyxlQUNoQyw0QkFBNEIsVUFBMEI7QUFHbkQsTUFBTSxPQUFPLENBQUMsU0FBeUIsZUFBcUM7QUFDakYsWUFBSTtBQUNKLGdCQUFRLFdBQVcsSUFBSTtBQUFBLFVBQ3JCO0FBQ0UsbUJBQU87QUFDUDtBQUFBLFVBQ0Y7QUFDRSxtQkFBTztBQUNQO0FBQUEsVUFDRjtBQUNFLG1CQUFPO0FBQ1A7QUFBQSxVQUNGO0FBQ0UsbUJBQU87QUFDUDtBQUFBLFVBQ0Y7QUFDRSxtQkFBTztBQUNQO0FBQUEsVUFDRjtBQUNFLGtCQUFNLElBQUksV0FBVywwRUFBMEUsV0FBVyxFQUFFLEVBQUU7QUFBQSxRQUNsSDtBQUNBLGdCQUFRO0FBQUEsVUFDSiw2QkFBNkIsUUFBUSxPQUFPLENBQUMsR0FBRyxRQUFRLE1BQU0sUUFBVyxXQUFXLFVBQVUsV0FBVyxFQUFFO0FBQUEsUUFBQztBQUFBLE1BQ2xIO0FBT0EsTUFBTSxtQ0FBbUMsQ0FBQyxXQUFrRDtBQUMxRixjQUFNLE1BQU8sT0FBTyxVQUFVLEtBQUssT0FBTyxDQUFDLEVBQUUsU0FBUyxJQUFLLE9BQU8sQ0FBQyxFQUFFLGdCQUFnQixFQUFFLENBQUMsSUFBSTtBQUM1RixjQUFNLE1BQU8sT0FBTyxVQUFVLEtBQUssT0FBTyxDQUFDLEVBQUUsU0FBUyxJQUFLLE9BQU8sQ0FBQyxFQUFFLGdCQUFnQixFQUFFLENBQUMsSUFBSTtBQUM1RixlQUFPLDRCQUE0QixFQUFDLEtBQUssSUFBRyxDQUFDO0FBQUEsTUFDL0M7QUFFTyxNQUFNLE9BQU8sQ0FBQyxTQUF5QixtQkFBeUM7QUFDckYsY0FBTSxhQUFhLFFBQVEsT0FBTyxXQUFXLElBQUksaUJBQWlCLGlDQUFpQyxRQUFRLE1BQU07QUFDakgsY0FBTSxXQUFXLDBCQUEwQixRQUFRLE9BQU8sQ0FBQyxFQUFFLFFBQVE7QUFDckUsZ0JBQVE7QUFBQSxVQUNKO0FBQUEsWUFDSSxRQUFRLE9BQU8sQ0FBQztBQUFBLFlBQUc7QUFBQSxZQUFRLE9BQUssU0FBUyxDQUFDO0FBQUEsWUFBMkI7QUFBQSw0QkFDbkQsUUFBUSxZQUFZLFFBQVEsSUFBSSxXQUFXLEdBQUc7QUFBQSw0QkFDOUMsUUFBUSxZQUFZLFFBQVEsSUFBSSxXQUFXLEdBQUc7QUFBQTtBQUFBLFlBRWhFLFdBQVc7QUFBQSxVQUFRO0FBQUEsVUFDdkIsRUFBQyxRQUFRLENBQUMsQ0FBQyxFQUFDO0FBQUEsUUFBQztBQUFBLE1BQ25CO0FBRU8sTUFBTSxPQUFPLENBQUMsWUFBa0M7QUFDckQsZ0JBQVEsUUFBUSw2QkFBNkIsUUFBUSxPQUFPLENBQUMsR0FBRyxRQUFRLE1BQU0sQ0FBQztBQUFBLE1BQ2pGO0FBRU8sTUFBTSxNQUFNLENBQUMsWUFBa0M7QUFDcEQsZ0JBQVEsUUFBUSw2QkFBNkIsUUFBUSxPQUFPLENBQUMsR0FBRyxPQUFPLEtBQUssQ0FBQztBQUFBLE1BQy9FO0FBRU8sTUFBTSxPQUFPLENBQUMsWUFBa0M7QUFDckQsZ0JBQVEsUUFBUSw2QkFBNkIsUUFBUSxPQUFPLENBQUMsR0FBRyxRQUFRLE1BQU0sQ0FBQztBQUFBLE1BQ2pGO0FBTU8sTUFBTSx1QkFBdUIsQ0FBQyxlQUNqQyw0QkFBNEIsVUFBNkI7QUFFdEQsTUFBTSxNQUFNLENBQUMsU0FBeUIsZUFBc0M7QUFDakYsY0FBTSxXQUFXLDBCQUEwQixRQUFRLE9BQU8sQ0FBQyxFQUFFLFFBQVE7QUFDckUsZ0JBQVEsUUFBUTtBQUFBLFVBQ1osUUFBUSxPQUFPLENBQUM7QUFBQSxVQUFHO0FBQUEsVUFBTyxPQUFLLFlBQVksQ0FBQztBQUFBLFVBQUs7QUFBQSx1QkFDaEMsUUFBUSxJQUFJLFdBQVcsS0FBSztBQUFBO0FBQUEsa0JBRWpDLFFBQVEsUUFBUSxRQUFRO0FBQUE7QUFBQTtBQUFBO0FBQUEsd0JBSWxCLFFBQVEsY0FBYyxRQUFRO0FBQUE7QUFBQTtBQUFBLFVBR2hELFdBQVc7QUFBQSxRQUFRLENBQUM7QUFBQSxNQUMxQjtBQUVPLE1BQU0sVUFBVSxDQUFDLFVBQWtCLFVBQVUsVUFBVTtBQUFBLFlBQ2xELE9BQU87QUFBQSxZQUNQLE9BQU87QUFBQSxZQUNQLE9BQU87QUFBQSxZQUNQLE9BQU87QUFBQSxZQUNQLE9BQU87QUFBQSxZQUNQLE9BQU87QUFBQTtBQUFBLGlCQUVGLFFBQVEsUUFBUSxRQUFRO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFNbEMsTUFBTSxNQUFNLENBQUMsWUFBa0M7QUFDcEQsY0FBTSxXQUFXLDBCQUEwQixRQUFRLE9BQU8sQ0FBQyxFQUFFLFFBQVE7QUFDckUsZ0JBQVEsUUFBUTtBQUFBLFVBQ1osUUFBUSxPQUFPLENBQUM7QUFBQSxVQUFHO0FBQUEsVUFBTyxPQUFLLFlBQVksQ0FBQztBQUFBLFVBQUssUUFBUSxRQUFRLFFBQVEsS0FBSyxRQUFRO0FBQUEsUUFBQyxDQUFDO0FBQUEsTUFDOUY7QUFFTyxNQUFNLE1BQU0sQ0FBQyxZQUFrQztBQUNwRCxnQkFBUSxRQUFRLDZCQUE2QixRQUFRLE9BQU8sQ0FBQyxHQUFHLE9BQU8sS0FBSyxDQUFDO0FBQUEsTUFDL0U7QUFFTyxNQUFNLFFBQVEsQ0FBQyxZQUFrQztBQUN0RCxnQkFBUSxRQUFRLDZCQUE2QixRQUFRLE9BQU8sQ0FBQyxHQUFHLFNBQVMsT0FBTyxDQUFDO0FBQUEsTUFDbkY7QUFFTyxNQUFNLE9BQU8sQ0FBQyxZQUFrQztBQUNyRCxjQUFNLFdBQVcsMEJBQTBCLFFBQVEsT0FBTyxDQUFDLEVBQUUsUUFBUTtBQUNyRSxnQkFBUSxRQUFRO0FBQUEsVUFDWixRQUFRLE9BQU8sQ0FBQztBQUFBLFVBQUc7QUFBQSxVQUFRLE9BQUssU0FBUyxDQUFDLHNCQUFzQixDQUFDO0FBQUEsVUFDakUsUUFBUSxRQUFRLFFBQVEsS0FBSyxRQUFRO0FBQUEsUUFBQyxDQUFDO0FBQUEsTUFDN0M7QUFFTyxNQUFNLFlBQVksQ0FBQyxTQUF5QixlQUFzQztBQUN2RixjQUFNLFdBQVcsMEJBQTBCLFFBQVEsT0FBTyxDQUFDLEVBQUUsUUFBUTtBQUNyRSxnQkFBUSxRQUFRO0FBQUEsVUFDWixRQUFRLE9BQU8sQ0FBQztBQUFBLFVBQUc7QUFBQSxVQUFhLE9BQUssOEJBQThCLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxZQUFZLFFBQVE7QUFBQSxVQUNwRyw2QkFBNkIsUUFBUSxJQUFJLFdBQVcsS0FBSztBQUFBLFVBQU0sV0FBVztBQUFBLFFBQVEsQ0FBQztBQUFBLE1BQ3pGO0FBRU8sTUFBTSxNQUFNLENBQUMsWUFBa0M7QUFDcEQsZ0JBQVEsUUFBUSw2QkFBNkIsUUFBUSxPQUFPLENBQUMsR0FBRyxPQUFPLE9BQUssSUFBSSxDQUFDLEVBQUUsQ0FBQztBQUFBLE1BQ3RGO0FBRU8sTUFBTSxNQUFNLENBQUMsWUFBa0M7QUFDcEQsZ0JBQVEsUUFBUSw2QkFBNkIsUUFBUSxPQUFPLENBQUMsR0FBRyxPQUFPLE9BQUssSUFBSSxDQUFDLEVBQUUsQ0FBQztBQUFBLE1BQ3RGO0FBRU8sTUFBTSxhQUFhLENBQUMsWUFBa0M7QUFDM0QsZ0JBQVEsUUFBUSw2QkFBNkIsUUFBUSxPQUFPLENBQUMsR0FBRyxjQUFjLE9BQUssT0FBTyxDQUFDLEVBQUUsQ0FBQztBQUFBLE1BQ2hHO0FBRU8sTUFBTSxPQUFPLENBQUMsWUFBa0M7QUFDckQsY0FBTSxXQUFXLDBCQUEwQixRQUFRLE9BQU8sQ0FBQyxFQUFFLFFBQVE7QUFDckUsZ0JBQVEsUUFBUTtBQUFBLFVBQ1osUUFBUSxPQUFPLENBQUM7QUFBQSxVQUFHO0FBQUEsVUFBUSxPQUFLLGVBQWUsUUFBUSxXQUFXLENBQUMsS0FBSyxDQUFDLFdBQVcsUUFBUTtBQUFBLFFBQVMsQ0FBQztBQUFBLE1BQzVHO0FBRU8sTUFBTSxVQUFVLENBQUMsWUFBa0M7QUFDeEQsZ0JBQVEsUUFBUSw2QkFBNkIsUUFBUSxPQUFPLENBQUMsR0FBRyxXQUFXLE9BQUssc0JBQXNCLENBQUMsS0FBSyxDQUFDO0FBQUEsTUFDL0c7QUFFTyxNQUFNLE1BQU0sQ0FBQyxZQUFrQztBQUNwRCxnQkFBUSxRQUFRLDZCQUE2QixRQUFRLE9BQU8sQ0FBQyxHQUFHLE9BQU8sS0FBSyxDQUFDO0FBQUEsTUFDL0U7QUFFTyxNQUFNLE9BQU8sQ0FBQyxZQUFrQztBQUNyRCxnQkFBUSxRQUFRLDZCQUE2QixRQUFRLE9BQU8sQ0FBQyxHQUFHLFFBQVEsTUFBTSxDQUFDO0FBQUEsTUFDakY7QUFFTyxNQUFNLE9BQU8sQ0FBQyxZQUFrQztBQUNyRCxnQkFBUSxRQUFRLDZCQUE2QixRQUFRLE9BQU8sQ0FBQyxHQUFHLFFBQVEsTUFBTSxDQUFDO0FBQUEsTUFDakY7QUFFTyxNQUFNLE1BQU0sQ0FBQyxZQUFrQztBQUNwRCxnQkFBUSxRQUFRLDZCQUE2QixRQUFRLE9BQU8sQ0FBQyxHQUFHLE9BQU8sS0FBSyxDQUFDO0FBQUEsTUFDL0U7QUFFTyxNQUFNLE9BQU8sQ0FBQyxZQUFrQztBQUNyRCxnQkFBUSxRQUFRLDZCQUE2QixRQUFRLE9BQU8sQ0FBQyxHQUFHLFFBQVEsTUFBTSxDQUFDO0FBQUEsTUFDakY7QUFFTyxNQUFNLGtCQUFrQixDQUFDLFNBQXlCLGVBQXdDO0FBQy9GLGNBQU0sV0FBVywwQkFBMEIsUUFBUSxPQUFPLENBQUMsRUFBRSxRQUFRO0FBQ3JFLGdCQUFRLFFBQVE7QUFBQSxVQUNaLFFBQVEsT0FBTyxDQUFDO0FBQUEsVUFBRztBQUFBLFVBQW1CLE9BQUssZUFBZSxRQUFRLFdBQVcsQ0FBQyxLQUFLLENBQUM7QUFBQSxVQUNwRix3Q0FBd0MsUUFBUSxLQUFLLFdBQVcsS0FBSztBQUFBLFVBQU0sV0FBVztBQUFBLFFBQVEsQ0FBQztBQUNuRyxlQUFPO0FBQUEsTUFDVDtBQUVPLE1BQU0sTUFBTSxDQUFDLFlBQWtDO0FBQ3BELGdCQUFRLFFBQVEsNkJBQTZCLFFBQVEsT0FBTyxDQUFDLEdBQUcsT0FBTyxLQUFLLENBQUM7QUFBQSxNQUMvRTtBQUFBO0FBQUE7OztBQ2xSQSxNQVVNQyxpQkFrQkEsZ0NBeUNPO0FBckViO0FBQUE7QUFBQTtBQUlBO0FBR0E7QUFDQTtBQUVBLE1BQU1BLGtCQUFpQixDQUFDLFdBQXdDO0FBQzlELFlBQUksT0FBTyxDQUFDLEVBQUUsS0FBSyxXQUFXLEdBQUc7QUFDL0IsZ0JBQU0sSUFBSSxNQUFNLGdDQUFnQztBQUFBLFFBQ2xEO0FBRUEsWUFBSSxDQUFDLENBQUMsTUFBTSxNQUFNLEtBQUssRUFBRSxTQUFTLE9BQU8sQ0FBQyxFQUFFLEtBQUssQ0FBQyxDQUFDLEdBQUc7QUFDcEQsZ0JBQU0sSUFBSSxNQUFNLDRDQUE0QztBQUFBLFFBQzlEO0FBRUEsWUFBSSxPQUFPLENBQUMsRUFBRSxLQUFLLFdBQVcsR0FBRztBQUMvQixnQkFBTSxJQUFJLE1BQU0sdUNBQXVDO0FBQUEsUUFDekQ7QUFFQSxZQUFJLE9BQU8sQ0FBQyxFQUFFLEtBQUssQ0FBQyxNQUFNLE9BQU8sQ0FBQyxFQUFFLEtBQUssQ0FBQyxHQUFHO0FBQzNDLGdCQUFNLElBQUksTUFBTSxtREFBbUQ7QUFBQSxRQUNyRTtBQUFBLE1BQ0Y7QUFFQSxNQUFNLGlDQUFpQyxDQUFDLFdBQStDO0FBQ3JGLGNBQU0sY0FBYyxPQUFPLENBQUMsRUFBRSxLQUFLLE1BQU07QUFDekMsb0JBQVksQ0FBQyxJQUFJLFlBQVksQ0FBQyxJQUFJO0FBRWxDLGNBQU0sUUFBUSxjQUFjLFNBQVMsT0FBTyxDQUFDLEVBQUUsVUFBVSxPQUFPLENBQUMsRUFBRSxNQUFNLENBQUM7QUFDMUUsY0FBTSxPQUFPLGNBQWMsUUFBUSxPQUFPLENBQUMsRUFBRSxVQUFVLENBQUMsT0FBTyxDQUFDLEVBQUUsS0FBSyxDQUFDLENBQUMsR0FBRyxDQUFDO0FBQzdFLGNBQU0sU0FBUyxlQUFlLFVBQVUsT0FBTyxDQUFDLEVBQUUsVUFBVSxhQUFhLENBQUM7QUFFMUUsY0FBTSxhQUFhLFVBQVUsS0FBSyxXQUFXLElBQUk7QUFDakQsY0FBTSxXQUFXLDRCQUE0QixPQUFPLENBQUMsRUFBRSxRQUFRO0FBRS9ELGNBQU0sa0JBQWtCLENBQUMsaUJBQStCO0FBQUE7QUFBQSx5QkFFakMsT0FBTyxDQUFDLEVBQUUsS0FBSyxDQUFDLElBQUksSUFBSSxDQUFDO0FBQUE7QUFBQSxJQUU5QyxhQUFhLGlCQUFpQixPQUFPLE1BQU0sTUFBTSxDQUFDO0FBQUE7QUFBQSxJQUVsRCxRQUFRLFFBQVEsUUFBUSxLQUFLLFFBQVEsQ0FBQztBQUFBO0FBQUEsSUFFdEMsYUFBYSxVQUFVLENBQUM7QUFBQSxNQUN0QixhQUFhLHNDQUFzQyxVQUFVLENBQUM7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BUTlELE9BQU8sWUFBWSxjQUFjLHVCQUF1QixDQUFDO0FBQUE7QUFHN0QsZUFBTztBQUFBLFVBQ0wsTUFBTTtBQUFBLFVBQ04sWUFBWSxPQUFPO0FBQUEsWUFDakIsU0FBUyxDQUFDLEVBQUMsTUFBTSxhQUFhLFVBQVUsT0FBTyxDQUFDLEVBQUUsU0FBUSxDQUFDO0FBQUEsWUFDM0QsZUFBZSxFQUFDLEdBQUcsS0FBSztBQUFBLGNBQUssYUFBYTtBQUFBO0FBQUEsWUFBdUIsRUFBQztBQUFBLFVBQ3BFO0FBQUEsVUFDQTtBQUFBLFFBQ0Y7QUFBQSxNQUNGO0FBRU8sTUFBTSxnQkFBZ0IsQ0FBQyxZQUFrQztBQUM5RCxRQUFBQSxnQkFBZSxRQUFRLE1BQU07QUFDN0IsZ0JBQVEsUUFBUSwrQkFBK0IsUUFBUSxNQUFNLENBQUM7QUFBQSxNQUNoRTtBQUFBO0FBQUE7OztBQ3hFQSxNQWlCTSw2QkF5R0EsMkJBNkVBLGFBUU8sS0FJQSxLQUlBLE9BTUEsS0FJQSxLQXNCQSxLQUlBLFNBTUEsTUFNQSxnQkFNQTtBQTdRYjtBQUFBO0FBQUE7QUFHQTtBQUVBO0FBR0E7QUFTQSxNQUFNLDhCQUNGLENBQUMsY0FBNEIsT0FBMEIsT0FBMEIsWUFDaEYsV0FBb0IsYUFBc0IsNkJBQXNDLFVBQ2hGLE9BQWUsT0FBZSxZQUFvQixtQkFDbEQsNkJBQXNDO0FBQ3JDLFlBQUk7QUFDSixZQUFJO0FBQ0osWUFBSSxPQUFPLGFBQWEsVUFBVTtBQUNoQyw2QkFBbUIsbUJBQW1CLENBQUNDLElBQUdDLE9BQU0sR0FBRyxRQUFRLEtBQUtELEVBQUMsTUFBTUMsRUFBQztBQUFBLFFBQzFFLFdBQVcsT0FBTyxhQUFhLFlBQVk7QUFDekMsNkJBQW1CLG1CQUFtQjtBQUFBLFFBQ3hDLE9BQU87QUFDTCw2QkFBbUIsU0FBUztBQUM1Qiw2QkFBbUIsU0FBUztBQUFBLFFBQzlCO0FBRUEsY0FBTSxvQkFBb0Isb0JBQW9CLE1BQU0sU0FBUztBQUM3RCxjQUFNLG9CQUFvQixvQkFBb0IsTUFBTSxTQUFTO0FBQzdELGNBQU0sb0JBQW9CLG9CQUFvQixXQUFXLFNBQVM7QUFDbEUsY0FBTSxTQUFTLGVBQWUsY0FBYyxZQUFZLG1CQUFtQixDQUFDO0FBQzVFLGNBQU0sSUFBSSxjQUFjLFNBQVMsT0FBTyxtQkFBbUIsQ0FBQztBQUM1RCxjQUFNLElBQUksY0FBYyxTQUFTLE9BQU8sbUJBQW1CLENBQUM7QUFFNUQsWUFBSTtBQUNKLFlBQUksV0FBVztBQUNiLGNBQUksYUFBYTtBQUNmLGtCQUFNLGdCQUFnQixVQUFVLEtBQUssS0FBSyxNQUFNO0FBQ2hELGtCQUFNLGdCQUFnQixVQUFVLEtBQUssS0FBSyxNQUFNO0FBQ2hELGtCQUFNLHVCQUF1QixNQUFNLFNBQVMsS0FBSyxNQUFNLE1BQU0sU0FBUyxDQUFDLElBQUksTUFBTTtBQUNqRixrQkFBTSx1QkFBdUIsTUFBTSxTQUFTLEtBQUssTUFBTSxNQUFNLFNBQVMsQ0FBQyxJQUFJLE1BQU07QUFDakYsZ0JBQUksaUJBQWlCLGVBQWU7QUFDbEMsMkJBQWEsT0FBTztBQUFBLGdCQUNoQjtBQUFBLGdCQUNBO0FBQUEsa0JBQ0ksZ0JBQWdCLEdBQUcsRUFBRSxLQUFLLEtBQUssSUFBSSxFQUFFLFlBQVksR0FBRyxDQUFDLFFBQVEsRUFBRSxZQUFZLFlBQVk7QUFBQSxrQkFDdkYsZ0JBQWdCLEdBQUcsRUFBRSxLQUFLLEtBQUssSUFBSSxFQUFFLFlBQVksR0FBRyxDQUFDLFFBQVEsRUFBRSxZQUFZLFlBQVk7QUFBQSxnQkFBQztBQUFBLGNBQUM7QUFBQSxZQUNuRyxPQUFPO0FBQ0wsMkJBQWE7QUFBQSxrQ0FDUyxPQUFPLGdCQUFnQixpQkFBaUIsQ0FBQztBQUFBLDRCQUMvQyxFQUFFLDJCQUEyQixpQkFBaUIsTUFBTSxDQUFDO0FBQUEsNEJBQ3JELEVBQUUsMkJBQTJCLGlCQUFpQixNQUFNLENBQUM7QUFBQSxjQUVqRSxPQUFPO0FBQUEsZ0JBQ0g7QUFBQSxnQkFDQTtBQUFBLGtCQUNJLCtCQUErQix1QkFDM0IsRUFBRSxZQUFZLGNBQWMsSUFDNUIsR0FBRyxFQUFFLEtBQUssS0FBSyxJQUFJLEVBQUUsWUFBWSxjQUFjLENBQUM7QUFBQSxrQkFDcEQsK0JBQStCLHVCQUMzQixFQUFFLFlBQVksY0FBYyxJQUM1QixHQUFHLEVBQUUsS0FBSyxLQUFLLElBQUksRUFBRSxZQUFZLGNBQWMsQ0FBQztBQUFBLGdCQUFpQjtBQUFBLGNBQUMsQ0FBQztBQUFBO0FBQUEsWUFFckY7QUFBQSxVQUNGLE9BQU87QUFDTCx5QkFBYSxPQUFPO0FBQUEsY0FDaEI7QUFBQSxjQUFjLGlCQUFpQixFQUFFLFlBQVksWUFBWSxHQUFHLEVBQUUsWUFBWSxZQUFZLENBQUM7QUFBQSxZQUFDO0FBQUEsVUFDOUY7QUFBQSxRQUNGLE9BQU87QUFDTCxjQUFJLENBQUMsYUFBYTtBQUNoQixrQkFBTSxJQUFJLE1BQU0sc0ZBQXNGO0FBQUEsVUFDeEc7QUFFQSxnQkFBTSxtQkFBbUIsQ0FBQyxRQUFnQixHQUFXLFdBQVcsT0FBTztBQUNyRSxrQkFBTSxjQUFjLGVBQWUsQ0FBQyxlQUFlLENBQUM7QUFDcEQsa0JBQU0sY0FBYyxlQUFlLENBQUMsZUFBZSxDQUFDO0FBQ3BELG1CQUFPO0FBQUEsK0JBQ2MsQ0FBQyxNQUFNLE9BQU8sZ0JBQWdCLHFCQUFxQixDQUFDLEdBQUcsQ0FBQztBQUFBLHlCQUM5RCxDQUFDLE1BQU0sRUFBRSwyQkFBMkIsZ0JBQWdCLENBQUMsSUFBSSxNQUFNLENBQUM7QUFBQSx5QkFDaEUsQ0FBQyxNQUFNLEVBQUUsMkJBQTJCLGdCQUFnQixDQUFDLElBQUksTUFBTSxDQUFDO0FBQUEsd0JBQ2pFLENBQUMsYUFBYSxDQUFDO0FBQUEsd0JBQ2YsQ0FBQyxhQUFhLENBQUM7QUFBQSw0QkFDWCxDQUFDLGFBQWEsQ0FBQztBQUFBLDRCQUNmLENBQUMsYUFBYSxDQUFDO0FBQUEsY0FDN0IsTUFBTSxJQUFJLENBQUMsT0FBTyxRQUFRLElBQUksaUJBQWlCLGFBQWEsV0FBVyxDQUFDO0FBQUE7QUFBQSxVQUU5RTtBQUNBLGNBQUksNkJBQThCO0FBQ2hDLHlCQUFhO0FBQUE7QUFBQSxjQUVULGlCQUFpQixRQUFRLEdBQUcsS0FBSyxDQUFDO0FBQUEsY0FDbEMsaUJBQWlCLFFBQVEsR0FBRyxLQUFLLENBQUM7QUFBQSxjQUNsQyxpQkFBaUIsUUFBUSxHQUFHLEtBQUssQ0FBQztBQUFBLGNBQ2xDLGlCQUFpQixRQUFRLEdBQUcsS0FBSyxDQUFDO0FBQUE7QUFBQSxVQUV4QyxPQUFPO0FBQ0wseUJBQWE7QUFBQSxjQUNULGlCQUFpQiwwQkFBMEIsQ0FBQyxDQUFDO0FBQUEsY0FDN0MsaUJBQWlCLDBCQUEwQixDQUFDLENBQUM7QUFBQSxjQUM3QyxpQkFBaUIsMEJBQTBCLENBQUMsQ0FBQztBQUFBLGNBQzdDLGlCQUFpQiwwQkFBMEIsQ0FBQyxDQUFDO0FBQUE7QUFBQSxVQUVuRDtBQUFBLFFBQ0Y7QUFFQSxlQUFPO0FBQUEsVUFDSCxhQUFhLGdCQUFnQixZQUFZLEtBQUssRUFBRSxpQkFBaUIsR0FBRyxHQUFHLE1BQU0sQ0FBQztBQUFBO0FBQUEsVUFFOUUsNEJBQTRCLEVBQUU7QUFBQTtBQUFBLFVBRTlCLGFBQWEsVUFBVSxDQUFDO0FBQUEsVUFDeEIsYUFBYSxzQ0FBc0MsbUJBQW1CLENBQUM7QUFBQSxVQUN2RSxVQUFVO0FBQUE7QUFBQSxNQUVoQjtBQUVKLE1BQU0sNEJBQ0YsQ0FBQyxNQUFjLFVBQWtCLEdBQWUsR0FBZSxVQUM5RCwwQkFBbUMsaUJBQXlCLEVBQUUsYUFBMEI7QUFDdkYsY0FBTSxjQUFjLENBQUMsVUFBVSxTQUFTLEVBQUUsTUFBTSxFQUFFLElBQUk7QUFDdEQsWUFBSSxjQUFjLEVBQUU7QUFDcEIsWUFBSSxhQUFhLFVBQVUsS0FBSyxFQUFFLElBQUk7QUFFdEMsWUFBSSxZQUFZO0FBQ2hCLFlBQUksOEJBQThCO0FBR2xDLGNBQU0sY0FBYyxDQUFDLFdBQVc7QUFDaEMsWUFBSSxhQUFhO0FBQ2YsZ0JBQU0sa0JBQWtCLGNBQWMsVUFBVSxFQUFFLE1BQU0sRUFBRSxNQUFNLEtBQUs7QUFDckUsY0FBSSxDQUFDLGlCQUFpQjtBQUNwQixrQkFBTSxJQUFJLE1BQU0sOENBQStDO0FBQUEsVUFDakU7QUFDQSx3QkFBYztBQUNkLHVCQUFhLFVBQVUsS0FBSyxXQUFXO0FBQ3ZDLGdCQUFNLGdCQUFnQixVQUFVLEtBQUssRUFBRSxJQUFJLE1BQU07QUFDakQsZ0JBQU0sZ0JBQWdCLFVBQVUsS0FBSyxFQUFFLElBQUksTUFBTTtBQUNqRCxnQkFBTSx1QkFBdUIsRUFBRSxLQUFLLFNBQVMsS0FBSyxFQUFFLEtBQUssRUFBRSxLQUFLLFNBQVMsQ0FBQyxJQUFJLE1BQU07QUFDcEYsZ0JBQU0sdUJBQXVCLEVBQUUsS0FBSyxTQUFTLEtBQUssRUFBRSxLQUFLLEVBQUUsS0FBSyxTQUFTLENBQUMsSUFBSSxNQUFNO0FBQ3BGLHNCQUFZLEtBQUssYUFBYTtBQUM5QixzQkFBWSxLQUFLLGFBQWE7QUFDOUIsc0JBQVksS0FBSyxvQkFBb0I7QUFDckMsc0JBQVksS0FBSyxvQkFBb0I7QUFFckMsY0FBSSxrQkFBa0I7QUFDdEIsbUJBQVMsSUFBSSxHQUFHLElBQUksWUFBWSxRQUFRLEtBQUs7QUFDM0Msa0JBQU0sT0FBTyxFQUFFLEtBQUssRUFBRSxLQUFLLFNBQVMsQ0FBQyxLQUFLO0FBQzFDLGtCQUFNLE9BQU8sRUFBRSxLQUFLLEVBQUUsS0FBSyxTQUFTLENBQUMsS0FBSztBQUMxQyxnQkFBSSxTQUFTLE1BQU07QUFDakIsaUNBQW1CO0FBQUEsWUFDckIsT0FBTztBQUNMO0FBQUEsWUFDRjtBQUFBLFVBQ0Y7QUFDQSxjQUFJLGtCQUFrQixNQUFNLEdBQUc7QUFDN0IsMENBQThCO0FBQzlCLHdCQUFZO0FBQUEsVUFDZCxXQUFXLGlCQUFpQixpQkFBaUIsd0JBQXdCLHNCQUFzQjtBQUN6Rix3QkFBWTtBQUFBLFVBQ2Q7QUFBQSxRQUNGLE9BQU87QUFFTCxzQkFBWTtBQUFBLFFBQ2Q7QUFDQSxvQkFBWSxLQUFLLFNBQVM7QUFDMUIsY0FBTSxvQkFBb0IscUJBQXFCLEVBQUUsS0FBSyxNQUFNLEtBQUsscUJBQXFCLEVBQUUsS0FBSyxNQUFNLEtBQy9GLHFCQUFxQixZQUFZLE1BQU07QUFDM0MsZUFBTztBQUFBLFVBQ0w7QUFBQSxVQUNBLGFBQWE7QUFBQSxZQUNYLE1BQU0sV0FBVyxZQUFZLElBQUksQ0FBQyxNQUFNLEVBQUUsU0FBUyxDQUFDLEVBQUUsS0FBSyxHQUFHO0FBQUEsWUFDOUQsbUJBQW1CLG9CQUFvQixDQUFDLFFBQVEsTUFBTSxJQUFJLENBQUMsUUFBUSxNQUFNO0FBQUEsVUFDM0U7QUFBQSxVQUNBLGlCQUFpQixDQUFDLGlCQUFpQjtBQUFBLFlBQy9CO0FBQUEsWUFBYyxFQUFFO0FBQUEsWUFBTSxFQUFFO0FBQUEsWUFBTTtBQUFBLFlBQWE7QUFBQSxZQUFXO0FBQUEsWUFBYTtBQUFBLFlBQTZCO0FBQUEsWUFDaEcsRUFBRTtBQUFBLFlBQVUsRUFBRTtBQUFBLFlBQVU7QUFBQSxZQUFnQjtBQUFBLFlBQW1CO0FBQUEsVUFBd0I7QUFBQSxVQUN2RixZQUFZLE9BQU87QUFBQSxZQUNqQixTQUFTLENBQUMsRUFBQyxNQUFNLGFBQWEsVUFBVSxlQUFjLENBQUM7QUFBQSxZQUN2RCxlQUFlLEVBQUMsR0FBRyxLQUFLO0FBQUEsY0FBSyxhQUFhLEtBQTBCO0FBQUE7QUFBQSxZQUFzQixFQUFDO0FBQUEsWUFDM0YsaUJBQWlCLG9CQUNiO0FBQUEsY0FDRSxFQUFDLE1BQU0sVUFBVSxNQUFNLEtBQUssS0FBSyxVQUFVLEtBQUssV0FBVyxJQUFJLENBQUMsRUFBQztBQUFBLGNBQ2pFLEdBQUcsMkJBQTJCLEVBQUUsSUFBSTtBQUFBLGNBQ3BDLEdBQUcsMkJBQTJCLEVBQUUsSUFBSTtBQUFBLGNBQ3BDLEdBQUcsMkJBQTJCLFdBQVc7QUFBQSxZQUMzQyxJQUNBO0FBQUEsY0FDRSxFQUFDLE1BQU0sVUFBVSxNQUFNLEtBQUssS0FBSyxVQUFVLEtBQUssV0FBVyxJQUFJLENBQUMsRUFBQztBQUFBLFlBQ25FO0FBQUEsVUFDTjtBQUFBLFFBQ0Y7QUFBQSxNQUNGO0FBRUosTUFBTSxjQUNGLENBQUMsU0FBeUIsTUFBYyxVQUE4QiwwQkFDckUsVUFBbUIsbUJBQWtDO0FBQ3BELGdCQUFRLFFBQVE7QUFBQSxVQUNaO0FBQUEsVUFBTSxZQUFZO0FBQUEsVUFBSSxRQUFRLE9BQU8sQ0FBQztBQUFBLFVBQUcsUUFBUSxPQUFPLENBQUM7QUFBQSxVQUFHO0FBQUEsVUFBVTtBQUFBLFVBQ3RFO0FBQUEsUUFBYyxDQUFDO0FBQUEsTUFDckI7QUFFRyxNQUFNLE1BQU0sQ0FBQyxZQUFrQztBQUNwRCxvQkFBWSxTQUFTLE9BQU8sQ0FBQyxHQUFHLE1BQU0sR0FBRyxDQUFDLElBQUksQ0FBQyxFQUFFO0FBQUEsTUFDbkQ7QUFFTyxNQUFNLE1BQU0sQ0FBQyxZQUFrQztBQUNwRCxvQkFBWSxTQUFTLE9BQU8sQ0FBQyxHQUFHLE1BQU0sR0FBRyxDQUFDLElBQUksQ0FBQyxFQUFFO0FBQUEsTUFDbkQ7QUFFTyxNQUFNLFFBQVEsQ0FBQyxZQUFrQztBQUN0RDtBQUFBLFVBQ0k7QUFBQSxVQUFTO0FBQUEsVUFBVSxFQUFDLFFBQVEsQ0FBQyxHQUFHLE1BQU0sT0FBTyxDQUFDLEtBQUssQ0FBQyxLQUFLLFFBQVEsQ0FBQyxHQUFHLE1BQU0sYUFBYSxDQUFDLEtBQUssQ0FBQyxJQUFHO0FBQUEsVUFBSTtBQUFBLFVBQ3RHO0FBQUE7QUFBQSxRQUF3QjtBQUFBLE1BQzlCO0FBRU8sTUFBTSxNQUFNLENBQUMsWUFBa0M7QUFDcEQsb0JBQVksU0FBUyxPQUFPLENBQUMsR0FBRyxNQUFNLEdBQUcsQ0FBQyxJQUFJLENBQUMsRUFBRTtBQUFBLE1BQ25EO0FBRU8sTUFBTSxNQUFNLENBQUMsWUFBa0M7QUFDcEQsY0FBTSxPQUFPLGNBQWMsU0FBUyxRQUFRLE9BQU8sQ0FBQyxFQUFFLFVBQVUsUUFBUSxPQUFPLENBQUMsRUFBRSxJQUFJLEVBQUUsS0FBSztBQUM3RixjQUFNLFdBQVcsU0FBUyxRQUFRLFVBQVU7QUFDNUM7QUFBQSxVQUNJO0FBQUEsVUFBUztBQUFBLFVBQVEsRUFBQyxRQUFRLENBQUMsR0FBRyxNQUFNLGNBQWMsQ0FBQyxJQUFJLENBQUMsS0FBSyxRQUFRLENBQUMsR0FBRyxNQUFNLHFCQUFxQixDQUFDLElBQUksQ0FBQyxJQUFHO0FBQUEsVUFDN0c7QUFBQSx3QkFDa0IsSUFBSSxTQUFTLElBQUksUUFBUSxJQUFJO0FBQUEsaUJBQ3BDLElBQUk7QUFBQSxpQkFDSixJQUFJO0FBQUEsdUJBQ0UsSUFBSTtBQUFBLGlCQUNWLElBQUk7QUFBQTtBQUFBLCtCQUVVLElBQUksNkJBQTZCLElBQUkscUJBQXFCLElBQUksSUFDbkYsUUFBUTtBQUFBO0FBQUEsb0NBRWtCLElBQUksZUFBZSxJQUFJLGNBQWMsSUFBSTtBQUFBO0FBQUEsb0JBRXpELElBQUk7QUFBQTtBQUFBO0FBQUEsUUFFakI7QUFBQSxNQUNQO0FBRU8sTUFBTSxNQUFNLENBQUMsWUFBa0M7QUFDcEQsb0JBQVksU0FBUyxPQUFPLENBQUMsR0FBRyxNQUFNLEdBQUcsQ0FBQyxJQUFJLENBQUMsRUFBRTtBQUFBLE1BQ25EO0FBRU8sTUFBTSxVQUFVLENBQUMsWUFBa0M7QUFDeEQ7QUFBQSxVQUNJO0FBQUEsVUFBUztBQUFBLFVBQVksRUFBQyxRQUFRLENBQUMsR0FBRyxNQUFNLE9BQU8sQ0FBQyxJQUFJLENBQUMsS0FBSyxRQUFRLENBQUMsR0FBRyxNQUFNLGFBQWEsQ0FBQyxJQUFJLENBQUMsSUFBRztBQUFBLFVBQUk7QUFBQSxVQUN0RztBQUFBO0FBQUEsUUFBd0I7QUFBQSxNQUM5QjtBQUVPLE1BQU0sT0FBTyxDQUFDLFlBQWtDO0FBQ3JEO0FBQUEsVUFDSTtBQUFBLFVBQVM7QUFBQSxVQUFTLEVBQUMsUUFBUSxDQUFDLEdBQUcsTUFBTSxPQUFPLENBQUMsSUFBSSxDQUFDLEtBQUssUUFBUSxDQUFDLEdBQUcsTUFBTSxhQUFhLENBQUMsSUFBSSxDQUFDLElBQUc7QUFBQSxVQUFJO0FBQUEsVUFDbkc7QUFBQTtBQUFBLFFBQXdCO0FBQUEsTUFDOUI7QUFFTyxNQUFNLGlCQUFpQixDQUFDLFlBQWtDO0FBQy9EO0FBQUEsVUFDSTtBQUFBLFVBQVM7QUFBQSxVQUFtQixFQUFDLFFBQVEsQ0FBQyxHQUFHLE1BQU0sT0FBTyxDQUFDLEtBQUssQ0FBQyxLQUFLLFFBQVEsQ0FBQyxHQUFHLE1BQU0sYUFBYSxDQUFDLEtBQUssQ0FBQyxJQUFHO0FBQUEsVUFDM0c7QUFBQSxVQUFXO0FBQUE7QUFBQSxRQUF3QjtBQUFBLE1BQ3pDO0FBRU8sTUFBTSxjQUFjLENBQUMsWUFBa0M7QUFDNUQ7QUFBQSxVQUNJO0FBQUEsVUFBUztBQUFBLFVBQWdCLEVBQUMsUUFBUSxDQUFDLEdBQUcsTUFBTSxPQUFPLENBQUMsS0FBSyxDQUFDLEtBQUssUUFBUSxDQUFDLEdBQUcsTUFBTSxhQUFhLENBQUMsS0FBSyxDQUFDLElBQUc7QUFBQSxVQUN4RztBQUFBLFVBQVc7QUFBQTtBQUFBLFFBQXdCO0FBQUEsTUFDekM7QUFBQTtBQUFBOzs7QUNqUkEsTUFjTUMsaUJBcUJBLHlCQVdBLGtCQW1CQSx5QkFrR08sUUFLQTtBQXhLYjtBQUFBO0FBQUE7QUFJQTtBQUNBO0FBR0E7QUFNQSxNQUFNQSxrQkFBaUIsQ0FBQyxXQUF3QztBQUM5RCxZQUFJLENBQUMsVUFBVSxPQUFPLFNBQVMsR0FBRztBQUNoQyxnQkFBTSxJQUFJLE1BQU0sZ0JBQWdCO0FBQUEsUUFDbEM7QUFFQSxjQUFNLFlBQVksT0FBTyxDQUFDLEVBQUU7QUFDNUIsY0FBTSxzQkFBc0IsT0FBTyxDQUFDLEVBQUUsS0FBSztBQUUzQyxtQkFBVyxTQUFTLFFBQVE7QUFFMUIsY0FBSSxNQUFNLGFBQWEsV0FBVztBQUNoQyxrQkFBTSxJQUFJLE1BQU0sa0NBQWtDO0FBQUEsVUFDcEQ7QUFHQSxjQUFJLE1BQU0sS0FBSyxXQUFXLHFCQUFxQjtBQUM3QyxrQkFBTSxJQUFJLE1BQU0sMENBQTBDO0FBQUEsVUFDNUQ7QUFBQSxRQUNGO0FBQUEsTUFDRjtBQUVBLE1BQU0sMEJBQTBCLENBQUMsaUJBQXlCLHdCQUF3QztBQUFBO0FBQUEsd0NBRTFELGVBQWUsTUFBTSxtQkFBbUI7QUFBQSxnQ0FDaEQsZUFBZTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsYUFLbEMsZUFBZTtBQUFBO0FBRzVCLE1BQU0sbUJBQW1CLENBQUMsUUFBa0MsV0FBMEI7QUFDcEYsY0FBTSxrQkFBa0IsT0FBTztBQUUvQixjQUFNLFlBQXNCLENBQUM7QUFDN0IsaUJBQVMsSUFBSSxHQUFHLElBQUksaUJBQWlCLEVBQUUsR0FBRztBQUN4QyxnQkFBTSxnQkFBZ0IsT0FBTyxZQUFZLGNBQWMsT0FBTyxDQUFDLEVBQUUsYUFBYSxTQUFTLENBQUM7QUFDeEYsY0FBSSxvQkFBb0IsR0FBRztBQUN6QixzQkFBVSxLQUFLLGFBQWE7QUFBQSxVQUM5QixXQUFXLE1BQU0sR0FBRztBQUNsQixzQkFBVSxLQUFLLHFCQUFxQixDQUFDLFFBQVEsYUFBYSxJQUFJO0FBQUEsVUFDaEUsV0FBVyxNQUFNLGtCQUFrQixHQUFHO0FBQ3BDLHNCQUFVLEtBQUssVUFBVSxhQUFhLElBQUk7QUFBQSxVQUM1QyxPQUFPO0FBQ0wsc0JBQVUsS0FBSywwQkFBMEIsQ0FBQyxPQUFPLGFBQWEsSUFBSTtBQUFBLFVBQ3BFO0FBQUEsUUFDRjtBQUNBLGVBQU8sVUFBVSxLQUFLLElBQUk7QUFBQSxNQUM1QjtBQUVBLE1BQU0sMEJBQTBCLENBQUMsUUFBK0IsU0FBOEI7QUFDNUYsY0FBTSxhQUFhLE9BQU8sQ0FBQyxFQUFFLEtBQUssTUFBTTtBQUN4QyxZQUFJLFFBQVEsV0FBVyxVQUFVLE9BQVEsS0FBSyxXQUFXLFFBQVM7QUFDaEUsZ0JBQU0sSUFBSSxNQUFNLDhEQUErRDtBQUFBLFFBQ2pGO0FBQ0EsY0FBTSxlQUFnQixPQUFPLElBQUssV0FBVyxTQUFTLE9BQU87QUFHN0QsY0FBTSxjQUFjLFdBQVcsTUFBTSxDQUFDO0FBQ3RDLGlCQUFTLElBQUksR0FBRyxJQUFJLE9BQU8sUUFBUSxLQUFLO0FBQ3RDLGdCQUFNLGFBQWEsT0FBTyxDQUFDLEVBQUUsS0FBSyxNQUFNO0FBQ3hDLG1CQUFTLFlBQVksR0FBRyxZQUFZLFdBQVcsUUFBUSxhQUFhO0FBRWxFLGdCQUFJLGNBQWMsY0FBYztBQUM5QiwwQkFBWSxZQUFZLEtBQUssV0FBVyxTQUFTO0FBQUEsWUFDbkQsV0FFUyxXQUFXLFNBQVMsTUFBTSxXQUFXLFNBQVMsR0FBRztBQUN4RCxvQkFBTSxJQUFJLE1BQU0sa0NBQWtDO0FBQUEsWUFDcEQ7QUFBQSxVQUNGO0FBQUEsUUFDRjtBQUVBLGNBQU0sYUFBYSxVQUFVLEtBQUssV0FBVztBQUU3QyxjQUFNLG1CQUFtQixJQUFJLE1BQWMsT0FBTyxNQUFNO0FBQ3hELGNBQU0sWUFBWSxJQUFJLE1BQXFCLE9BQU8sTUFBTTtBQUN4RCxjQUFNLFdBQVcsT0FBTyxDQUFDLEVBQUU7QUFFM0IsWUFBSSxjQUFjO0FBQ2xCLGNBQU0sb0JBQXdELENBQUM7QUFDL0QsY0FBTSxvQkFBb0IsQ0FBQztBQUMzQixjQUFNLDRCQUE0QixDQUFDO0FBQ25DLGNBQU0sa0JBQW9DLENBQUMsRUFBQyxNQUFNLFVBQVUsTUFBTSxXQUFVLENBQUM7QUFDN0UsaUJBQVMsSUFBSSxHQUFHLElBQUksT0FBTyxRQUFRLEVBQUUsR0FBRztBQUN0Qyx5QkFBZSxPQUFPLENBQUMsRUFBRSxLQUFLLFlBQVk7QUFDMUMsMkJBQWlCLENBQUMsSUFBSTtBQUN0QixvQ0FBMEIsS0FBSyxxQkFBcUIsT0FBTyxDQUFDLEVBQUUsS0FBSyxNQUFNLENBQUM7QUFDMUUsNEJBQWtCLEtBQUssMEJBQTBCLENBQUMsSUFBSSxPQUFPLENBQUMsRUFBRSxLQUFLLFNBQVMsT0FBTyxDQUFDLEVBQUUsSUFBSTtBQUM1RixvQkFBVSxDQUFDLElBQUksY0FBYyxRQUFRLENBQUMsSUFBSSxVQUFVLGtCQUFrQixDQUFDLENBQUM7QUFDeEUsNEJBQWtCLEtBQUssMEJBQTBCLENBQUMsSUFBSSxTQUFTLE1BQU07QUFDckUsMEJBQWdCLEtBQUssRUFBQyxNQUFNLFVBQVUsTUFBTSxpQkFBaUIsQ0FBQyxFQUFDLENBQUM7QUFBQSxRQUNsRTtBQUNBLGlCQUFTLElBQUksR0FBRyxJQUFJLE9BQU8sUUFBUSxFQUFFLEdBQUc7QUFDdEMsY0FBSSwwQkFBMEIsQ0FBQyxHQUFHO0FBQ2hDLDRCQUFnQixLQUFLLEdBQUcsMkJBQTJCLE9BQU8sQ0FBQyxFQUFFLElBQUksQ0FBQztBQUFBLFVBQ3BFO0FBQUEsUUFDRjtBQUVBLGNBQU0sNkJBQTZCLHFCQUFxQixZQUFZLE1BQU07QUFDMUUsWUFBSSw0QkFBNEI7QUFDOUIsMEJBQWdCLEtBQUssR0FBRywyQkFBMkIsV0FBVyxDQUFDO0FBQUEsUUFDakU7QUFFQSxjQUFNLG9CQUFvQiw2QkFBNkIsWUFBWSxTQUFTO0FBQzVFLGNBQU0sU0FBUyxlQUFlLFVBQVUsVUFBVSxpQkFBaUI7QUFFbkUsY0FBTSxjQUFjLE9BQU8sV0FBVyxXQUFXLFlBQVk7QUFDN0QsY0FBTSxzQkFDRixNQUFNLEtBQUssTUFBTSxpQkFBaUIsTUFBTSxFQUFFLEtBQUssQ0FBQyxFQUFFLElBQUksT0FBSyw0QkFBNEIsQ0FBQyxFQUFFLEVBQUUsS0FBSyxHQUFHO0FBQ3hHLGNBQU0sa0JBQWtCLENBQUMsaUJBQStCO0FBQUE7QUFBQSxLQUVyRCxNQUFNO0FBQ1AsdUJBQWEsZ0JBQWdCLGNBQWMsS0FBSztBQUNoRCxtQkFBUyxJQUFJLEdBQUcsSUFBSSxPQUFPLFFBQVEsS0FBSztBQUN0Qyx5QkFBYSxnQkFBZ0IsbUJBQW1CLENBQUMsSUFBSSxLQUFLO0FBQUEsVUFDNUQ7QUFDQSxpQkFBTyxhQUFhLGlCQUFpQixHQUFHLFdBQVcsTUFBTTtBQUFBLFFBQzNELEdBQUcsQ0FBQztBQUFBO0FBQUEsSUFFRix3QkFBd0IsaUJBQWlCLFFBQVEsbUJBQW1CLENBQUM7QUFBQTtBQUFBLElBRXJFLGFBQWEsVUFBVSxDQUFDO0FBQUEsTUFDdEIsYUFBYSxzQ0FBc0MscUJBQXFCLENBQUM7QUFBQTtBQUFBLG9CQUUzRCxPQUFPLGdCQUFnQixZQUFZLENBQUM7QUFBQTtBQUFBLDJDQUViLFdBQVc7QUFBQTtBQUFBLDBDQUVaLGlCQUFpQixNQUFNLE1BQU0sbUJBQW1CO0FBQUEsUUFDbEYsV0FBVztBQUFBO0FBQUE7QUFBQSxNQUdiLGlCQUFpQixXQUFXLE1BQU0sQ0FBQztBQUFBO0FBR3ZDLGVBQU87QUFBQSxVQUNMLE1BQU07QUFBQSxVQUNOLGFBQWEsRUFBQyxNQUFNLEdBQUcsSUFBSSxJQUFJLGtCQUFpQjtBQUFBLFVBQ2hELFlBQVksT0FBTztBQUFBLFlBQ2pCLFNBQVMsQ0FBQyxFQUFDLE1BQU0sYUFBYSxVQUFVLE9BQU8sQ0FBQyxFQUFFLFNBQVEsQ0FBQztBQUFBLFlBQzNELGVBQWUsRUFBQyxHQUFHLEtBQUs7QUFBQSxjQUFLLGFBQWE7QUFBQTtBQUFBLFlBQXVCLEVBQUM7QUFBQSxZQUNsRTtBQUFBLFVBQ0Y7QUFBQSxVQUNBO0FBQUEsUUFDRjtBQUFBLE1BQ0Y7QUFFTyxNQUFNLFNBQVMsQ0FBQyxTQUF5QixlQUF1QztBQUNyRixRQUFBQSxnQkFBZSxRQUFRLE1BQU07QUFDN0IsZ0JBQVEsUUFBUSx3QkFBd0IsUUFBUSxRQUFRLFdBQVcsSUFBSSxDQUFDO0FBQUEsTUFDMUU7QUFFTyxNQUFNLHdCQUF3QixDQUFDLGVBQ2xDLDRCQUE0QixFQUFDLE1BQU0sV0FBVyxLQUFjLENBQUM7QUFBQTtBQUFBOzs7QUN6S2pFLE1BWWEsc0JBc0JBO0FBbENiO0FBQUE7QUFBQTtBQUdBO0FBU08sTUFBTSx1QkFBdUIsQ0FBQyxZQUEwQyxjQUNsQjtBQUN2RCxnQkFBUSxXQUFXLFlBQVk7QUFBQSxVQUM3QixLQUFLO0FBQ0gsbUJBQU8sRUFBQyxvQkFBb0IsSUFBSSxpQkFBaUIsc0JBQXNCLFNBQVMsVUFBUztBQUFBLFVBQzNGLEtBQUs7QUFDSCxtQkFBTztBQUFBLGNBQ0wsb0JBQW9CO0FBQUEsY0FDcEIsaUJBQWlCLFlBQVksU0FBUyxZQUFZLFNBQVM7QUFBQSxZQUM3RDtBQUFBLFVBQ0YsS0FBSztBQUNILG1CQUFPO0FBQUEsY0FDTCxvQkFBb0IsbUJBQW1CLFNBQVMsSUFBSSxXQUFXLE9BQVEscUJBQXFCLFNBQVMsSUFDakcsV0FBVyxPQUFRO0FBQUEsY0FDdkIsaUJBQWlCO0FBQUEsWUFDbkI7QUFBQSxVQUVGO0FBQ0UsbUJBQU8sRUFBQyxvQkFBb0IsSUFBSSxpQkFBaUIsR0FBRTtBQUFBLFFBQ3ZEO0FBQUEsTUFDRjtBQUVHLE1BQU0sb0NBQ1QsQ0FBQyxlQUFnRjtBQUMvRSxjQUFNLGFBQWEsWUFBWSxjQUF3QjtBQUV2RCxZQUFJLGVBQWUsUUFBUTtBQUN6QixnQkFBTSxDQUFDLFNBQVMsT0FBTyxJQUFJLFlBQVkscUJBQXlDLENBQUMsVUFBVSxRQUFRO0FBQ25HLGlCQUFPLEVBQUMsWUFBWSxTQUFTLFNBQVMsb0JBQW9CLEdBQUcsVUFBVSxJQUFJLE9BQU8sSUFBSSxPQUFPLEdBQUU7QUFBQSxRQUNqRztBQUNBLGVBQU8sRUFBQyxZQUFZLG9CQUFvQixXQUFVO0FBQUEsTUFDcEQ7QUFBQTtBQUFBOzs7QUMzQ0osTUFxQmEsYUFlQTtBQXBDYjtBQUFBO0FBQUE7QUFxQk8sTUFBTSxjQUFjLENBQUMsV0FBbUIsYUFBcUI7QUFDbEUsZ0JBQVEsV0FBVztBQUFBLFVBQ2pCLEtBQUs7QUFDSCxtQkFBTztBQUFBLFVBQ1QsS0FBSztBQUNILG1CQUFPLFFBQVEsUUFBUTtBQUFBLFVBQ3pCLEtBQUs7QUFDSCxtQkFBTyxRQUFRLFFBQVE7QUFBQSxVQUN6QixLQUFLO0FBQ0gsbUJBQU8sUUFBUSxRQUFRO0FBQUEsVUFDekI7QUFDRSxrQkFBTSxJQUFJLE1BQU0sR0FBRyxTQUFTLDhCQUE4QjtBQUFBLFFBQzlEO0FBQUEsTUFDRjtBQUVPLE1BQU0sY0FBYyxDQUFDLFlBQTZCO0FBQUEsUUFDakQsVUFBVSxtREFBbUQsRUFBRTtBQUFBO0FBQUE7QUFBQTs7O0FDckN2RSxNQXFCYTtBQXJCYjtBQUFBO0FBQUE7QUFxQk8sTUFBTSxnQkFBZ0IsQ0FBQyxjQUF1QjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFVBTzNDLFNBQVMsWUFBWSxTQUFTLFlBQVksU0FBUztBQUFBO0FBQUE7QUFBQTtBQUFBOzs7QUM1QjdELE1BNkJNLDRCQWlCQSx3QkF5Qk8sNEJBdUZQLHdCQWlCQSx5QkFLTyx3QkFnS1AseUJBOEVPO0FBbGFiO0FBQUE7QUFBQTtBQXNCQTtBQUVBO0FBQ0E7QUFFQTtBQUVBLE1BQU0sNkJBQTZCLENBQUNDLFlBQW9CLGNBQThCO0FBQ3BGLFlBQUlBLFlBQVc7QUFDYixpQkFBTztBQUFBO0FBQUE7QUFBQSx3REFHNkMsWUFBWSxtQkFBbUIsRUFBRTtBQUFBO0FBQUEsUUFHdkYsT0FBTztBQUNMLGlCQUFPO0FBQUE7QUFBQTtBQUFBLGdEQUdxQyxZQUFZLG1CQUFtQixFQUFFO0FBQUE7QUFBQSxRQUUvRTtBQUFBLE1BQ0Y7QUFFQSxNQUFNLHlCQUF5QixDQUFDLFlBQXFCLHFCQUE2QjtBQUNoRixZQUFJLFlBQVk7QUFDZCxpQkFBTztBQUFBO0FBQUE7QUFBQTtBQUFBLFVBSUQscUJBQXFCLElBQUksS0FBSyw2REFBNkQ7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBS3pGLHFCQUFxQixJQUFJLEtBQUssMkNBQTJDO0FBQUE7QUFBQSxRQUVuRixPQUFPO0FBQ0wsaUJBQU87QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFNQyxxQkFBcUIsSUFBSSxLQUFLLHlDQUF5QztBQUFBO0FBQUEsUUFFakY7QUFBQSxNQUNGO0FBRU8sTUFBTSw2QkFDVCxDQUFDLGVBQXlCLGVBQXlDLE9BQU8sT0FBTyxXQUNoRixhQUFhLE9BQU8sWUFBWSxJQUFJLFNBQVMsT0FBTyxrQkFBa0IsT0FBZTtBQUNwRixjQUFNLGFBQWEsY0FBYyxDQUFDLElBQUksY0FBYyxDQUFDO0FBQ3JELGNBQU0sYUFBYSxjQUFjLENBQUMsSUFBSSxjQUFjLENBQUM7QUFDckQsY0FBTSxhQUFhLGFBQWEsYUFBYTtBQUM3QyxjQUFNLGFBQWEsYUFBYSxZQUFZO0FBQzVDLGNBQU0sbUJBQW1CLGFBQWEsY0FBYyxDQUFDO0FBQ3JELGNBQU0sZ0JBQWdCLFlBQVksY0FBYyxDQUFDO0FBRWpELFlBQUksR0FBSSxjQUFjLHFCQUFxQixLQUFLLGNBQWMsQ0FBQyxNQUFNLEtBQzdELENBQUMsZUFBZSxxQkFBcUIsS0FBSyxxQkFBcUIsT0FDakUsYUFBYSxjQUFjLENBQUMsTUFBTSxLQUFLLFlBQVksY0FBYyxDQUFDLE1BQU0sS0FBSyxjQUFjLENBQUMsTUFBTSxJQUFJO0FBQzFHLGdCQUFNLElBQUksTUFBTSxpQkFBaUIsVUFBVSw4QkFDdkMsZ0JBQWdCLHlCQUF5QixjQUFjLENBQUMsQ0FBQztBQUFBLG9DQUNqQyxnQkFBZ0I7QUFBQSxlQUNyQyxVQUFVLHlDQUF5QyxjQUFjLENBQUMsQ0FBQyxlQUN0RSxTQUFTLDBDQUEwQyxjQUFjLENBQUMsQ0FBQyxrQkFDbkUsY0FBYyxDQUFDLENBQUMsYUFBYTtBQUFBLFFBQ25DO0FBQ0EsZUFBTztBQUFBLHlDQUM0QixnQkFBZ0IsSUFBSSxJQUFJLE1BQU0sYUFBYSxnQkFBZ0IsTUFBTSxVQUFVO0FBQUEsMkNBQ3pFLElBQUksTUFBTSxhQUFhLGNBQWMsQ0FBQyxDQUFDLE1BQU0sU0FBUztBQUFBO0FBQUEsdUJBRTFFLGNBQWMsQ0FBQyxDQUFDO0FBQUEsdUJBQ2hCLGNBQWMsQ0FBQyxDQUFDO0FBQUEsMkJBQ1osZ0JBQWdCO0FBQUEsb0JBQ3ZCLFNBQVM7QUFBQTtBQUFBLDJCQUVGLGNBQWMsQ0FBQyxDQUFDLEtBQUssY0FBYyxDQUFDLENBQUMsS0FBSyxjQUFjLENBQUMsQ0FBQztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLGdCQVVyRSxTQUFTLE1BQU0saUJBQWlCO0FBQUEsSUFDNUMsWUFBWSxzQkFBc0IsVUFBVSxnQkFBZ0IsWUFBWSxDQUFDLE1BQU0sRUFBRTtBQUFBLDhDQUN2QyxVQUFVO0FBQUE7QUFBQSxtQkFFckMsU0FBUyxHQUFHLEtBQUssS0FBSyxrQkFBa0IsU0FBUyxDQUFDLEtBQUsseUNBQXlDO0FBQUEsaUJBQ2xHLFNBQVMscUJBQXFCLGVBQWUsS0FBSyxHQUFHO0FBQUE7QUFBQSx3QkFFOUMsSUFBSTtBQUFBO0FBQUE7QUFBQSw4QkFHRSxhQUFhO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBTS9CLDJCQUEyQixZQUFZLFNBQVMsQ0FBQztBQUFBO0FBQUE7QUFBQTtBQUFBLDBDQUluQixhQUFhO0FBQUE7QUFBQTtBQUFBLHNGQUk3QyxZQUFZLG1CQUFtQixFQUFFO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFVL0IscUJBQXFCLElBQUksS0FBSyw0REFBNEQ7QUFBQTtBQUFBLFlBRTFGLHVCQUF1QixZQUFZLGdCQUFnQixDQUFDO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFVNUQ7QUFFSixNQUFNLHlCQUF5QixDQUFDQSxZQUFvQixjQUE4QjtBQUNoRixZQUFJQSxZQUFXO0FBQ2IsaUJBQU87QUFBQTtBQUFBO0FBQUEseUNBRzhCLFlBQVksbUJBQW1CLEVBQUU7QUFBQTtBQUFBLFFBR3hFLE9BQU87QUFDTCxpQkFBTztBQUFBO0FBQUE7QUFBQSxpQ0FHc0IsWUFBWSxtQkFBbUIsRUFBRTtBQUFBO0FBQUEsUUFFaEU7QUFBQSxNQUNGO0FBRUEsTUFBTSwwQkFBMEIsQ0FBQyxlQUM3QixhQUFhLGtEQUFrRDtBQUk1RCxNQUFNLHlCQUNULENBQUMsZUFBeUIsZUFBeUMsT0FBTyxPQUFPLFdBQ2hGLGFBQWEsT0FBTyxZQUFZLElBQUksU0FBUyxPQUFPLGtCQUFrQixJQUN0RSw0QkFBNEIsVUFBa0I7QUFDN0MsY0FBTSxhQUFhLGNBQWMsQ0FBQyxJQUFJLGNBQWMsQ0FBQztBQUNyRCxjQUFNLGFBQWEsY0FBYyxDQUFDLElBQUksY0FBYyxDQUFDO0FBQ3JELGNBQU0sYUFBYSxhQUFhLGFBQWE7QUFDN0MsY0FBTSxhQUFhLGFBQWEsWUFBWTtBQUU1QyxZQUFJLEVBQUUsYUFBYSxjQUFjLENBQUMsTUFBTSxLQUFLLGFBQWEsY0FBYyxDQUFDLE1BQU0sS0FDekUsWUFBWSxjQUFjLENBQUMsTUFBTSxJQUFJO0FBQ3pDLGdCQUFNLElBQUksTUFBTSxjQUFjLFVBQVUseUNBQ3BDLGNBQWMsQ0FBQyxDQUFDLGdCQUFnQixVQUFVLHlDQUMxQyxjQUFjLENBQUMsQ0FBQyxlQUFlLFNBQVMseUNBQXlDLGNBQWMsQ0FBQyxDQUFDLEVBQUU7QUFBQSxRQUN6RztBQUNBLGNBQU0sZ0JBQWdCLGFBQWEsY0FBYyxDQUFDO0FBQ2xELGNBQU0sZ0JBQWdCLGFBQWEsY0FBYyxDQUFDO0FBQ2xELGNBQU0sZ0JBQWdCLFlBQVksY0FBYyxDQUFDO0FBQ2pELGNBQU0sZ0JBQWdCLDRCQUNsQjtBQUFBO0FBQUE7QUFBQSxnREFHc0MsVUFBVTtBQUFBLGdEQUNWLFVBQVU7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLGlEQUtULFVBQVUsMkJBQTJCLGNBQWMsQ0FBQyxDQUFDO0FBQUEsbURBQ25ELFVBQVUsMkJBQTJCLGNBQWMsQ0FBQyxDQUFDO0FBQUEsWUFDNUYsdUJBQXVCLFlBQVksU0FBUyxDQUFDO0FBQUE7QUFBQTtBQUFBO0FBQUEsaURBSVIsU0FBUywyQkFBMkIsY0FBYyxDQUFDLENBQUM7QUFBQSx1REFDOUMsVUFBVSwyQkFBMkIsY0FBYyxDQUFDLENBQUM7QUFBQTtBQUFBO0FBQUEsdUNBR3JFLFlBQVksbUJBQW1CLEVBQUU7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSw0QkFPNUMsSUFBSTtBQUFBO0FBQUE7QUFBQSwyREFHMkIsY0FBYyxDQUFDLENBQUM7QUFBQTtBQUFBO0FBQUEsMEJBSTdELGFBQWEsb0NBQW9DLGNBQWMsQ0FBQyxDQUFDLE9BQ3BELGlDQUFpQyxjQUFjLENBQUMsQ0FBQyxPQUFPO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsMERBVXpCLGNBQWMsQ0FBQyxDQUFDO0FBQUE7QUFBQSw0REFFZCxjQUFjLENBQUMsQ0FBQztBQUFBO0FBQUE7QUFBQTtBQUFBLFFBS2xFO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLDRDQU1rQyxVQUFVO0FBQUE7QUFBQSxrQ0FFcEIsYUFBYTtBQUFBLGtDQUNiLGFBQWE7QUFBQSxrQ0FDYixhQUFhO0FBQUE7QUFBQTtBQUFBO0FBQUEsc0NBSVQsYUFBYTtBQUFBLHdDQUNYLGFBQWE7QUFBQTtBQUFBO0FBQUEsUUFHN0MsdUJBQXVCLFlBQVksU0FBUyxDQUFDO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxzQ0FLZixhQUFhO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLDhCQU1yQixZQUFZLG1CQUFtQixFQUFFO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsd0JBT3ZDLElBQUk7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxRQU9wQix3QkFBd0IsVUFBVSxDQUFDO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFrQnJDLGVBQU87QUFBQSx5Q0FDNEIsSUFBSSxLQUFLLFVBQVUsTUFBTSxVQUFVO0FBQUEseUNBQ25DLElBQUksS0FBSyxVQUFVLE1BQU0sU0FBUztBQUFBLHlCQUNsRCxjQUFjLENBQUMsQ0FBQztBQUFBLHlCQUNoQixjQUFjLENBQUMsQ0FBQztBQUFBLHNCQUNuQixTQUFTO0FBQUE7QUFBQSwyQkFFSixjQUFjLENBQUMsQ0FBQyxLQUFLLGNBQWMsQ0FBQyxDQUFDLEtBQUssY0FBYyxDQUFDLENBQUM7QUFBQTtBQUFBO0FBQUE7QUFBQSxrQkFJbkUsU0FBUyxNQUFNLGlCQUFpQjtBQUFBLE1BQzVDLFlBQVksc0JBQXNCLFVBQVUsZ0JBQWdCLFlBQVksQ0FBQyxNQUFNLEVBQUU7QUFBQSxxQkFDbEUsU0FBUyxHQUFHLEtBQUssS0FBSyxrQkFBa0IsU0FBUyxDQUFDLEtBQUsseUNBQXlDO0FBQUEsbUJBQ2xHLFNBQVMscUJBQXFCLGVBQWUsS0FBSyxHQUFHO0FBQUE7QUFBQSw0QkFFNUMsSUFBSTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFRMUIsYUFBYTtBQUFBO0FBQUE7QUFBQSxNQUdmO0FBRUosTUFBTSwwQkFDRixDQUFDLFdBQW1CLFNBQWtCLGlCQUF5QixXQUM5RCxhQUF1QyxpQkFBaUIsVUFBa0I7QUFDekUsY0FBTSxDQUFDLGFBQWEsYUFBYSxVQUFVLElBQUk7QUFDL0MsY0FBTSxDQUFDLGVBQWUsV0FBVyxXQUFXQyxlQUFjLElBQUk7QUFDOUQsY0FBTSxpQkFBaUIsaUJBQWlCLGFBQWEsVUFBVTtBQUMvRCxjQUFNLGlCQUFpQixpQkFBaUIsYUFBYSxVQUFVO0FBQy9ELGNBQU0sV0FBVyw0QkFBNEIsVUFBVSxDQUFDLEVBQUUsS0FBSyxNQUFNO0FBQ3JFLGNBQU0sY0FBYyxNQUFNO0FBQ3hCLGdCQUFNLFFBQVEsVUFBVTtBQUN4QixnQkFBTSxZQUFZLGNBQWM7QUFDaEMsY0FBSSxTQUFTLGlCQUFpQixVQUFVLEtBQUssT0FBTztBQUNwRCxtQkFBUyxJQUFJLFFBQVEsSUFBSSxHQUFHLElBQUksWUFBWSxHQUFHLEtBQUssR0FBRyxLQUFLLEtBQUs7QUFDL0Qsc0JBQVU7QUFBQSxXQUFjLENBQUMsT0FBTyxZQUFZLElBQUksZ0JBQWdCLENBQUMsTUFBTSxjQUFjO0FBQUEsVUFDdkY7QUFDQSx5QkFBZSxRQUFRLE9BQUs7QUFDMUIsc0JBQVU7QUFBQSxXQUFjLENBQUM7QUFBQSxVQUMzQixDQUFDO0FBQ0Qsb0JBQVU7QUFBQSxXQUFjLFFBQVEsQ0FBQztBQUFBLDhCQUNYLFFBQVEsQ0FBQztBQUMvQixpQkFBTztBQUFBLFFBQ1Q7QUFDQSxjQUFNLGNBQWMsTUFBTTtBQUN4QixnQkFBTSxRQUFRLFVBQVU7QUFDeEIsZ0JBQU0sWUFBWSxjQUFjO0FBQ2hDLGNBQUksU0FBUyxpQkFBaUIsVUFBVSxLQUFLLE9BQU87QUFDcEQsbUJBQVMsSUFBSSxRQUFRLElBQUksR0FBRyxJQUFJLFlBQVksR0FBRyxLQUFLLEdBQUcsS0FBSyxLQUFLO0FBQy9ELHNCQUFVO0FBQUEsV0FBYyxDQUFDLE9BQU8sWUFBWSxJQUFJLGdCQUFnQixDQUFDLE1BQU0sY0FBYztBQUFBLFVBQ3ZGO0FBQ0EseUJBQWUsUUFBUSxPQUFLO0FBQzFCLHNCQUFVO0FBQUEsV0FBYyxDQUFDO0FBQUEsVUFDM0IsQ0FBQztBQUNELG9CQUFVO0FBQUEsV0FBYyxRQUFRLENBQUM7QUFBQSw4QkFDWCxRQUFRLENBQUM7QUFDL0IsaUJBQU87QUFBQSxRQUNUO0FBQ0EsY0FBTSxTQUFTO0FBQUEsa0VBQzZDLGNBQWMsS0FBSyxPQUFPLFFBQ2xGLFlBQVksV0FBVyxRQUFRLENBQUM7QUFBQSxvQkFDdEIsWUFBWSxXQUFXLFFBQVEsQ0FBQztBQUFBLDBCQUMxQixTQUFTO0FBQUE7QUFBQTtBQUFBLFVBR3pCLFlBQVksQ0FBQztBQUFBLGtCQUNMLFVBQVUsYUFBYSxVQUFVLENBQUM7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLGtFQUtjLGNBQWMsS0FBSyxPQUFPLFFBQ2xGLFlBQVksV0FBVyxRQUFRLENBQUM7QUFBQSxvQkFDdEIsWUFBWSxXQUFXLFFBQVEsQ0FBQztBQUFBLDBCQUMxQixTQUFTO0FBQUE7QUFBQTtBQUFBLFVBR3pCLFlBQVksQ0FBQztBQUFBLGtCQUNMLFVBQVUsYUFBYSxVQUFVLENBQUM7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLDZEQUtTLFlBQVksV0FBVyxRQUFRLENBQUM7QUFBQSwwQkFDbkUsU0FBUztBQUFBO0FBQUE7QUFBQTtBQUFBLFVBS3pCLFVBQ0ksbUJBQW1CLGlCQUFpQixnQkFBZ0IsR0FBRyxZQUFZLFdBQVcsUUFBUSxDQUFDLGFBQWEsTUFDaEUsRUFBc0M7QUFBQSxVQUM5RSxlQUFlO0FBQUEsVUFDZkEsZ0JBQWUsYUFBYSxxQkFBcUIsT0FBTyxDQUFDO0FBQUE7QUFBQTtBQUFBO0FBSTdELGVBQU87QUFBQSxNQUNUO0FBRUcsTUFBTSwwQkFDVCxDQUFDLFFBQStCLHNCQUFvRCxhQUNuRixxQkFDQSxpQkFBaUIsVUFBeUQ7QUFDekUsY0FBTSxTQUFTLE9BQU8sQ0FBQyxFQUFFO0FBQ3pCLGNBQU0sU0FBUyxPQUFPLENBQUMsRUFBRTtBQUV6QixjQUFNLGFBQWEsT0FBTyxNQUFNLEdBQUcsRUFBRTtBQUNyQyxjQUFNLGFBQWEsT0FBTyxNQUFNLEdBQUcsRUFBRTtBQUVyQyxjQUFNLFlBQVksc0JBQXNCLG9CQUFvQixNQUFNLEdBQUcsRUFBRSxJQUFJLFlBQVksTUFBTSxHQUFHLEVBQUU7QUFDbEcsY0FBTSxzQkFBc0IscUJBQXFCLFVBQVUsTUFBTTtBQUNqRSxjQUFNLG1CQUFtQixzQkFBc0IsVUFBVSxTQUFTO0FBQ2xFLGNBQU0sWUFBWSxpQkFBaUIsYUFBYSxPQUFPLENBQUMsRUFBRSxVQUFVLGtCQUFrQixDQUFDO0FBQ3ZGLGNBQU0sWUFBWSxVQUFVLEtBQUssU0FBUztBQUUxQyxjQUFNLFlBQVksT0FBTyxPQUFPLFNBQVMsQ0FBQztBQUMxQyxjQUFNLFdBQVcsT0FBTyxPQUFPLFNBQVMsQ0FBQztBQUN6QyxjQUFNLFlBQVksT0FBTyxPQUFPLFNBQVMsQ0FBQztBQUMxQyxjQUFNLFNBQVMsV0FBVyxNQUFNLEtBQUssWUFBWSxNQUFNO0FBR3ZELGNBQU0sb0JBQW9CLGFBQWEsSUFBSSxDQUFDLEdBQUcsR0FBRyxDQUFDLElBQUksQ0FBQyxHQUFHLEdBQUcsQ0FBQztBQUMvRCxjQUFNLGdCQUEwQyxDQUFDLEdBQUcsR0FBRyxDQUFDO0FBQ3hELGNBQU0sV0FBVztBQUFBLFVBQ2YsS0FBSyxLQUFLLFlBQVksY0FBYyxDQUFDLElBQUksa0JBQWtCLENBQUMsQ0FBQztBQUFBLFVBQzdELEtBQUssS0FBSyxZQUFZLGNBQWMsQ0FBQyxJQUFJLGtCQUFrQixDQUFDLENBQUM7QUFBQSxVQUM3RCxLQUFLLEtBQUssWUFBWSxjQUFjLENBQUMsSUFBSSxrQkFBa0IsQ0FBQyxDQUFDO0FBQUEsUUFDL0Q7QUFFQSxjQUFNLFdBQVcsNEJBQTRCLE9BQU8sQ0FBQyxFQUFFLFFBQVE7QUFDL0QsY0FBTSxhQUFhLFNBQVMsSUFBSTtBQUVoQyxjQUFNLGFBQWEsQ0FBQyxHQUFHLFlBQVksV0FBVyxXQUFXLFVBQVU7QUFDbkUsY0FBTSx3QkFBd0IscUJBQXFCLFdBQVcsTUFBTTtBQUNwRSxjQUFNLGVBQWUsd0JBQXdCLFdBQVcsU0FBUztBQUVqRSxjQUFNLGFBQWEsQ0FBQyxHQUFHLFlBQVksVUFBVSxZQUFZLFVBQVU7QUFDbkUsY0FBTSx3QkFBd0IscUJBQXFCLFdBQVcsTUFBTTtBQUNwRSxjQUFNLGVBQWUsd0JBQXdCLFdBQVcsU0FBUztBQUVqRSxjQUFNLGtCQUFrQixDQUFDLFdBQVcsV0FBVyxZQUFZLFVBQVU7QUFFckUsY0FBTSxJQUFJLGNBQWMsS0FBSyxPQUFPLENBQUMsRUFBRSxVQUFVLGNBQWMsVUFBVTtBQUN6RSxjQUFNLElBQUksY0FBYyxLQUFLLE9BQU8sQ0FBQyxFQUFFLFVBQVUsY0FBYyxVQUFVO0FBQ3pFLGNBQU0sU0FBUyxlQUFlLFVBQVUsT0FBTyxDQUFDLEVBQUUsVUFBVSxnQkFBZ0IsUUFBUSxVQUFVO0FBQzlGLGNBQU0saUJBQWlCLENBQUMsR0FBRyxDQUFDO0FBQzVCLGNBQU0sa0JBQ0YsQ0FBQyxFQUFDLE1BQU0sU0FBUyxNQUFNLFVBQVMsR0FBRyxFQUFDLE1BQU0sU0FBUyxNQUFNLFVBQVMsR0FBRyxFQUFDLE1BQU0sU0FBUyxNQUFNLFNBQVEsQ0FBQztBQUN4RyxZQUFJLHFCQUFxQjtBQUN2QiwwQkFBZ0IsS0FBSyxHQUFHLDJCQUEyQixTQUFTLENBQUM7QUFBQSxRQUMvRDtBQUNBLFlBQUksdUJBQXVCO0FBQ3pCLDBCQUFnQixLQUFLLEdBQUcsMkJBQTJCLFVBQVUsQ0FBQztBQUFBLFFBQ2hFO0FBQ0EsWUFBSSx1QkFBdUI7QUFDekIsMEJBQWdCLEtBQUssR0FBRywyQkFBMkIsVUFBVSxDQUFDO0FBQUEsUUFDaEU7QUFDQSxjQUFNLG9CQUF3RCxDQUFDO0FBQy9ELDBCQUFrQixLQUFLLHdCQUF3QixTQUFTLE1BQU07QUFDOUQsMEJBQWtCLEtBQUssd0JBQXdCLFNBQVMsTUFBTTtBQUU5RCxjQUFNLFVBQVUsT0FBTyxTQUFTO0FBQ2hDLGNBQU0sRUFBQyxvQkFBb0IsZ0JBQWUsSUFBSSxxQkFBcUIsc0JBQXNCLE9BQU8sS0FBSyxLQUFLO0FBQzFHLGNBQU0sbUJBQW1CO0FBQUEsVUFDckI7QUFBQSxVQUFZO0FBQUEsVUFBUztBQUFBLFVBQWlCLENBQUMsV0FBVyxHQUFHLEdBQUcsTUFBTTtBQUFBLFVBQUcsQ0FBQyxZQUFZLFlBQVksU0FBUztBQUFBLFVBQ25HO0FBQUEsUUFBYztBQUNsQixZQUFJLFNBQVM7QUFDWCxnQkFBTSxpQkFBaUIsaUJBQWlCLGFBQWE7QUFDckQseUJBQWUsS0FBSyxjQUFjLFFBQVEsT0FBTyxDQUFDLEVBQUUsVUFBVSxPQUFPLENBQUMsRUFBRSxLQUFLLFFBQVEsY0FBYyxDQUFDO0FBQ3BHLDBCQUFnQixLQUFLLEdBQUcsMkJBQTJCLE9BQU8sQ0FBQyxFQUFFLElBQUksQ0FBQztBQUVsRSw0QkFBa0IsS0FBSyxNQUFNO0FBQUEsUUFDL0I7QUFDQSx3QkFBZ0IsS0FBSyxHQUFHLDJCQUEyQixlQUFlLENBQUM7QUFFbkUsY0FBTSxrQkFBa0IsQ0FBQyxpQkFBK0I7QUFBQSxJQUVwRCxhQUFhLGdCQUFnQixhQUFhLEtBQUssRUFDMUMsZ0JBQWdCLGFBQWEsS0FBSyxFQUNsQyxnQkFBZ0IsWUFBWSxLQUFLLEVBQ2pDLDBCQUEwQixTQUFTLEVBQ25DLGlCQUFpQixHQUFHLGdCQUFnQixNQUFNLENBQUM7QUFBQSxJQUN0RCxrQkFBa0I7QUFBQSxJQUNsQixnQkFBZ0I7QUFBQSxJQUVWLFNBQVMsMkJBQTJCLG1CQUFtQixlQUFlLFVBQVUsU0FBUyxJQUNoRix1QkFBdUIsbUJBQW1CLGVBQWUsVUFBVSxTQUFTLENBQUM7QUFBQTtBQUcxRixlQUFPO0FBQUEsVUFDTCxNQUFNO0FBQUEsVUFDTixhQUFhO0FBQUEsWUFDWCxNQUFNLHFCQUFxQixxQkFBcUIsR0FBRyxpQkFBaUIsR0FDN0QsTUFBTSxHQUNOLGNBQWM7QUFBQSxZQUNyQjtBQUFBLFVBQ0Y7QUFBQSxVQUNBLFlBQVksT0FBTztBQUFBLFlBQ2pCLFNBQVMsQ0FBQyxFQUFDLE1BQU0sYUFBYSxVQUFVLE9BQU8sQ0FBQyxFQUFFLFNBQVEsQ0FBQztBQUFBLFlBQzNELGVBQWUsRUFBQyxHQUFHLFNBQVMsQ0FBQyxHQUFHLEdBQUcsU0FBUyxDQUFDLEdBQUcsR0FBRyxTQUFTLENBQUMsRUFBQztBQUFBLFlBQzlEO0FBQUEsVUFDRjtBQUFBLFVBQ0E7QUFBQSxRQUNGO0FBQUEsTUFDRjtBQUFBO0FBQUE7OztBQzNnQkosTUFnQ00scUJBNkhPO0FBN0piO0FBQUE7QUFBQTtBQXFCQTtBQUdBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFFQSxNQUFNLHNCQUNGLENBQUMsZ0JBQXlCLFdBQW9CLFdBQW9CLFVBQW1CLFVBQVUsT0FDOUYsWUFBNEIsb0JBQW9CLEdBQUcsb0JBQW9CLEdBQUcsbUJBQW1CLEdBQzdGLFdBQVcsVUFBa0I7QUFDNUIsY0FBTSxjQUFjLENBQUNDLHNCQUE2QjtBQUNoRCxrQkFBUUEsbUJBQWtCO0FBQUEsWUFDeEIsS0FBSztBQUNILHFCQUFPO0FBQUEsWUFDVCxLQUFLO0FBQ0gscUJBQU8sa0JBQWtCLFFBQVE7QUFBQSxZQUNuQyxLQUFLO0FBQ0gscUJBQU87QUFBQSxZQUNUO0FBQ0Usb0JBQU0sSUFBSSxNQUFNLG9CQUFvQkEsaUJBQWdCLG9CQUFvQjtBQUFBLFVBQzVFO0FBQUEsUUFDRjtBQUNBLGNBQU0sY0FBYyxDQUFDQSxzQkFBNkI7QUFDaEQsa0JBQVFBLG1CQUFrQjtBQUFBLFlBQ3hCLEtBQUs7QUFDSCxxQkFBTztBQUFBLFlBQ1QsS0FBSztBQUNILHFCQUFPO0FBQUEsWUFDVDtBQUNFLG9CQUFNLElBQUksTUFBTSxvQkFBb0JBLGlCQUFnQixvQkFBb0I7QUFBQSxVQUM1RTtBQUFBLFFBQ0Y7QUFDQSxjQUFNLGdCQUFnQixpQkFBaUI7QUFBQTtBQUFBLFFBR0E7QUFBQTtBQUFBO0FBSXZDLGNBQU0sa0JBQWtCLGlCQUFpQjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxRQU9BO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBUXpDLGNBQU0sVUFBVSxpQkFBaUIsNkJBQTZCO0FBQzlELGNBQU0sU0FBUyxpQkFBaUIsNkJBQTZCO0FBQzdELGNBQU0sTUFBTSxpQkFBaUIsUUFBUTtBQUNyQyxjQUFNLE1BQU0saUJBQWlCLFFBQVE7QUFDckMsY0FBTSxlQUFlO0FBQUE7QUFBQSxxQkFFTixpQkFBaUIsa0NBQWtDLCtCQUErQjtBQUFBLG1CQUNwRixHQUFHO0FBQUEsbUJBQ0gsR0FBRztBQUFBO0FBQUEsaUJBRUwsR0FBRztBQUFBLGlCQUNILEdBQUc7QUFBQTtBQUFBO0FBQUEsZ0JBR0osR0FBRztBQUFBLG9CQUNDLFlBQVksbUJBQW1CLFFBQVEsQ0FBQztBQUFBO0FBQUE7QUFBQSw4QkFHOUIsT0FBTywyQkFBMkIsTUFBTTtBQUFBLFFBQzlELGFBQWE7QUFBQTtBQUFBLFFBRWIsWUFBWSxpQkFBaUIsQ0FBQztBQUFBO0FBQUE7QUFJaEMsY0FBTSxVQUFVLGlCQUFrQixhQUFhLFdBQVc7QUFBQSx3QkFDeEMsaUJBQWlCO0FBQUEsTUFDbkMsWUFBWSxLQUM4QztBQUFBLHdCQUN4QyxpQkFBaUI7QUFBQTtBQUFBLFFBRWpDLFlBQVk7QUFBQTtBQUFBLGFBRVAsWUFBWSxtQkFBbUIsUUFBUSxDQUFDLFdBQ2IsWUFBWSxZQUFZO0FBQUEsd0JBQ3hDLGlCQUFpQjtBQUFBLE1BQ25DLFlBQVksS0FDOEM7QUFBQSx3QkFDeEMsaUJBQWlCO0FBQUE7QUFBQSxRQUVqQyxZQUFZO0FBQUE7QUFBQSxhQUVQLFlBQVksbUJBQW1CLFFBQVEsQ0FBQztBQUUvQyxjQUFNLFVBQVUsR0FBRyxZQUFZLGlCQUFpQixDQUFDO0FBRWpELGNBQU0sVUFBVSxZQUFZLGtCQUFrQixRQUFRO0FBQ3RELGNBQU0sUUFDRixpQkFBaUIsWUFBWSxtQkFBbUIsUUFBUSxJQUFJLFlBQVksbUJBQW1CLFFBQVE7QUFDdkcsY0FBTSxRQUNGLGlCQUFpQixZQUFZLG1CQUFtQixRQUFRLElBQUksWUFBWSxtQkFBbUIsUUFBUTtBQUN2RyxjQUFNLEVBQUMsb0JBQW9CLGdCQUFlLElBQUkscUJBQXFCLFlBQVksT0FBTztBQUN0RixjQUFNLFdBQVc7QUFBQSxNQUNqQixrQkFBa0I7QUFBQSx5REFDaUMsS0FBSztBQUFBLFFBQ3RELGlCQUFpQixVQUFVLE9BQU87QUFBQTtBQUFBO0FBQUEseURBR2UsS0FBSztBQUFBLFFBQ3RELGlCQUFpQixVQUFVLE9BQU87QUFBQTtBQUFBO0FBQUEsZ0VBR3NCLE9BQU87QUFBQSwwQkFDN0MsZ0JBQWdCO0FBQUE7QUFBQTtBQUFBO0FBQUEsdUJBSW5CLGlCQUFpQixrQ0FBa0MsK0JBQStCO0FBQUEsUUFDakcsZUFBZTtBQUFBLFFBQ2YsWUFBWSxPQUFPLENBQUM7QUFBQSxRQUNwQixlQUFlO0FBQUE7QUFBQTtBQUFBO0FBSWpCLGVBQU87QUFBQSxNQUNUO0FBRUcsTUFBTSxnQ0FDVCxDQUFDLFFBQStCLFlBQTRCLGFBQWdDLFdBQzNGLFdBQW1CLFVBQWtCLFNBQWtCLDhCQUFvRDtBQUMxRyxjQUFNLGlCQUFpQixXQUFXLFdBQVc7QUFDN0MsY0FBTSxhQUFhLGlCQUFpQixPQUFPLENBQUMsRUFBRSxLQUFLLENBQUMsSUFBSSxPQUFPLENBQUMsRUFBRSxLQUFLLENBQUM7QUFDeEUsY0FBTSxZQUFZLFlBQVksQ0FBQztBQUMvQixjQUFNLFdBQVcsaUJBQWlCLFlBQVksQ0FBQyxJQUFJLFlBQVksQ0FBQztBQUNoRSxjQUFNLFlBQVksaUJBQWlCLFlBQVksQ0FBQyxJQUFJLFlBQVksQ0FBQztBQUNqRSxjQUFNLGNBQWMsaUJBQWlCLFlBQVksQ0FBQyxJQUFJLFlBQVksQ0FBQztBQUVuRSxjQUFNLFNBQVMsbUJBQW1CLGFBQWEsTUFBTSxLQUFLLGFBQWEsTUFBTSxNQUFNLGNBQWMsTUFBTTtBQUd2RyxjQUFNLFlBQVksaUJBQWlCLGNBQWMsV0FBVztBQUM1RCxjQUFNLFlBQVksaUJBQWlCLFdBQVcsWUFBWTtBQUMxRCxjQUFNLGdCQUEwQyxDQUFDLEdBQUcsR0FBRyxDQUFDO0FBQ3hELGNBQU0sb0JBQW9CLGFBQWEsSUFBSSxDQUFDLEdBQUcsR0FBRyxDQUFDLElBQUksQ0FBQyxHQUFHLEdBQUcsQ0FBQztBQUMvRCxjQUFNLFdBQVc7QUFBQSxVQUNmLEtBQUssS0FBSyxZQUFZLGNBQWMsQ0FBQyxJQUFJLGtCQUFrQixDQUFDLENBQUM7QUFBQSxVQUM3RCxLQUFLLEtBQUssWUFBWSxjQUFjLENBQUMsSUFBSSxrQkFBa0IsQ0FBQyxDQUFDO0FBQUEsVUFDN0QsS0FBSyxLQUFLLFlBQVksY0FBYyxDQUFDLElBQUksa0JBQWtCLENBQUMsQ0FBQztBQUFBLFFBQy9EO0FBRUEsa0JBQVUsV0FBVyxNQUFNLGlDQUFpQyxRQUFRLEVBQUU7QUFFdEUsY0FBTSxtQkFBbUIsU0FBVSxrQkFBa0IsYUFBYSxNQUFNLElBQUksSUFBSSxJQUFLO0FBRXJGLGNBQU0sYUFBYSxjQUFjLENBQUMsSUFBSSxrQkFBa0IsQ0FBQztBQUN6RCxjQUFNLGFBQWEsY0FBYyxDQUFDLElBQUksa0JBQWtCLENBQUM7QUFDekQsY0FBTSxZQUFZLEtBQUssSUFBSSxjQUFjLENBQUMsSUFBSSxrQkFBa0IsY0FBYyxDQUFDLENBQUM7QUFFaEYsY0FBTSxZQUFZLFlBQVksZUFBZTtBQUM3QyxjQUFNLFlBQVksWUFBWSxlQUFlO0FBQzdDLGNBQU0sV0FBVyxXQUFXLGNBQWM7QUFFMUMsY0FBTSxlQUFlLFNBQVMsQ0FBQyxrQkFBa0IsR0FBRyxDQUFDLElBQUksQ0FBQyxHQUFHLEdBQUcsQ0FBQztBQUNqRSxjQUFNLElBQUksNEJBQTRCLE9BQU8sQ0FBQyxFQUFFLFFBQVE7QUFHeEQsY0FBTSxhQUFhLFNBQVMsSUFBSTtBQUNoQyxjQUFNLGtCQUNGLENBQUMsRUFBQyxNQUFNLFNBQVMsTUFBTSxVQUFTLEdBQUcsRUFBQyxNQUFNLFNBQVMsTUFBTSxVQUFTLEdBQUcsRUFBQyxNQUFNLFNBQVMsTUFBTSxTQUFRLENBQUM7QUFDeEcsY0FBTSxJQUNGLGNBQWMsS0FBSyxPQUFPLENBQUMsRUFBRSxVQUFVLE9BQU8sQ0FBQyxFQUFFLEtBQUssUUFBUSxxQkFBcUIsSUFBSSxJQUFJLGdCQUFnQjtBQUMvRyxjQUFNLElBQUksY0FBYyxLQUFLLE9BQU8sQ0FBQyxFQUFFLFVBQVUsT0FBTyxDQUFDLEVBQUUsS0FBSyxRQUFRLFVBQVU7QUFDbEYsY0FBTSxpQkFBaUIsQ0FBQyxHQUFHLENBQUM7QUFFNUIsd0JBQWdCLEtBQUssR0FBRywyQkFBMkIsT0FBTyxDQUFDLEVBQUUsSUFBSSxDQUFDO0FBQ2xFLHdCQUFnQixLQUFLLEdBQUcsMkJBQTJCLE9BQU8sQ0FBQyxFQUFFLElBQUksQ0FBQztBQUVsRSxZQUFJLG1CQUFtQjtBQUFBLHFEQUN3QixTQUFTLFFBQVEsQ0FBQyxNQUFNLENBQUM7QUFBQSw4QkFDaEQsU0FBUyxRQUFRLENBQUMsTUFBTSxDQUFDO0FBQUE7QUFBQSw2RUFFc0IsU0FBUyxRQUFRLENBQUMsTUFBTSxDQUFDO0FBQUE7QUFBQSxxQ0FFakUsU0FBUyxRQUFRLEVBQUU7QUFBQTtBQUVsRCxZQUFJLFNBQVM7QUFDWCxnQkFBTSxPQUFPLGNBQWMsUUFBUSxPQUFPLENBQUMsRUFBRSxVQUFVLE9BQU8sQ0FBQyxFQUFFLEtBQUssUUFBUSxVQUFVO0FBQ3hGLHlCQUFlLEtBQUssSUFBSTtBQUV4QiwwQkFBZ0IsS0FBSyxHQUFHLDJCQUEyQixPQUFPLENBQUMsRUFBRSxJQUFJLENBQUM7QUFFbEUsOEJBQW9CO0FBQUEsMERBQzhCLFNBQVMsUUFBUSxDQUFDLE1BQU0sQ0FBQztBQUFBLCtCQUNwRCxpQkFBaUIsTUFBTSxHQUFHLEdBQUcsU0FBUyxRQUFRLEVBQUU7QUFBQTtBQUFBLFFBRXpFO0FBQ0EsY0FBTSxTQUFTLGVBQWUsVUFBVSxPQUFPLENBQUMsRUFBRSxVQUFVLFlBQVksUUFBUSxVQUFVO0FBQzFGLHdCQUFnQixLQUFLLEdBQUcsMkJBQTJCLFdBQVcsQ0FBQztBQUMvRCxlQUFPO0FBQUEsVUFDTCxNQUFNO0FBQUEsVUFDTixhQUFhLEVBQUMsTUFBTSxXQUFXLFNBQVE7QUFBQSxVQUN2QyxZQUFZLE9BQU87QUFBQSxZQUNqQixTQUFTLENBQUMsRUFBQyxNQUFNLGFBQWEsVUFBVSxPQUFPLENBQUMsRUFBRSxTQUFRLENBQUM7QUFBQSxZQUMzRCxlQUFlLEVBQUMsR0FBRyxTQUFTLENBQUMsR0FBRyxHQUFHLFNBQVMsQ0FBQyxHQUFHLEdBQUcsU0FBUyxDQUFDLEVBQUM7QUFBQSxZQUM5RDtBQUFBLFVBQ0Y7QUFBQSxVQUNBLGlCQUFpQixDQUFDLGlCQUErQjtBQUFBLFVBQy9DLGNBQWMseUJBQXlCLENBQUM7QUFBQTtBQUFBO0FBQUE7QUFBQSxVQUt0QyxhQUFhLGdCQUFnQixhQUFhLEtBQUssRUFDMUMsZ0JBQWdCLGFBQWEsS0FBSyxFQUNsQyxnQkFBZ0IsWUFBWSxLQUFLLEVBQ2pDLGlCQUFpQixHQUFHLGdCQUFnQixNQUFNLENBQUM7QUFBQSxtREFDVCxXQUFXLFlBQVksQ0FBQyxDQUFDLEtBQUssV0FBVyxZQUFZLENBQUMsQ0FBQztBQUFBLDRDQUM5RCxXQUFXLEtBQUssQ0FBQyxDQUFDLEtBQUssV0FBVyxLQUFLLENBQUMsQ0FBQztBQUFBLCtDQUN0QyxXQUFXLFFBQVEsQ0FBQyxDQUFDLEtBQUssV0FBVyxRQUFRLENBQUMsQ0FBQztBQUFBLGlEQUM3QyxXQUFXLFVBQVUsQ0FBQyxDQUFDLEtBQUssV0FBVyxVQUFVLENBQUMsQ0FBQztBQUFBLFVBQzFGLGdCQUFnQjtBQUFBLFVBRWQ7QUFBQSxZQUNJO0FBQUEsWUFBZ0I7QUFBQSxZQUFXO0FBQUEsWUFBVztBQUFBLFlBQVU7QUFBQSxZQUFTO0FBQUEsWUFBWSxhQUFhLENBQUM7QUFBQSxZQUFHLGFBQWEsQ0FBQztBQUFBLFlBQ3BHLGFBQWEsQ0FBQztBQUFBLFlBQUc7QUFBQSxVQUFDLENBQUM7QUFBQSxjQUV2QixTQUNJLDJCQUEyQixtQkFBbUIsZUFBZSxHQUFHLFFBQVcsQ0FBQyxnQkFBZ0IsU0FBUyxJQUNyRztBQUFBLFlBQ0k7QUFBQSxZQUFtQjtBQUFBLFlBQWU7QUFBQSxZQUFHO0FBQUEsWUFBVyxDQUFDO0FBQUEsWUFBZ0I7QUFBQSxZQUFXO0FBQUEsWUFBTztBQUFBLFlBQ25GO0FBQUEsVUFBeUIsQ0FBQztBQUFBLFFBQ3hDO0FBQUEsTUFDRjtBQUFBO0FBQUE7OztBQ3RRSixNQWVhLDhCQW1GQTtBQWxHYjtBQUFBO0FBQUE7QUFJQTtBQUdBO0FBQ0E7QUFDQTtBQU1PLE1BQU0sK0JBQ1QsQ0FBQyxRQUErQixZQUMvQiwrQkFBcUY7QUFDcEYsY0FBTSxVQUFVLE9BQU8sU0FBUztBQUNoQyxjQUFNLGNBQWMsVUFBVSxnQ0FBZ0M7QUFDOUQsY0FBTSxTQUFTLE9BQU8sQ0FBQyxFQUFFO0FBQ3pCLGNBQU0sU0FBUyxPQUFPLENBQUMsRUFBRTtBQUN6QixjQUFNLHlCQUF5QixPQUFPLENBQUMsSUFBSSxXQUFXO0FBRXRELGNBQU0sZ0JBQWdCLFdBQVcsV0FBVztBQUM1QyxjQUFNLGNBQWM7QUFBQSxVQUNoQjtBQUFBLFVBQVE7QUFBQSxVQUFRLFdBQVc7QUFBQSxVQUFXLFdBQVc7QUFBQSxVQUFNLFdBQVc7QUFBQSxVQUFTO0FBQUEsUUFBYTtBQUM1RixjQUFNLGFBQWEsVUFBVSxLQUFLLFdBQVc7QUFFN0MsY0FBTSxTQUFTLGVBQWUsVUFBVSxPQUFPLENBQUMsRUFBRSxVQUFVLFdBQVc7QUFDdkUsY0FBTSxFQUFDLG9CQUFvQixnQkFBZSxJQUFJLHFCQUFxQixZQUFZLE9BQU8sS0FBSyxLQUFLO0FBQ2hHLGNBQU0sSUFBSSxjQUFjLEtBQUssT0FBTyxDQUFDLEVBQUUsVUFBVSxNQUFNO0FBQ3ZELGNBQU0sSUFBSSxjQUFjLEtBQUssT0FBTyxDQUFDLEVBQUUsVUFBVSxNQUFNO0FBQ3ZELGNBQU0sWUFBWSxDQUFDLEdBQUcsQ0FBQztBQUN2QixZQUFJLFNBQVM7QUFDWCxvQkFBVSxLQUFLLGNBQWMsS0FBSyxPQUFPLENBQUMsRUFBRSxVQUFVLE9BQU8sQ0FBQyxFQUFFLElBQUksQ0FBQztBQUFBLFFBQ3ZFO0FBRUEsY0FBTSxrQkFBa0IsQ0FBQyxpQkFBK0I7QUFBQSxvQ0FDMUIsV0FBVyxRQUFRLENBQUMsQ0FBQyxNQUFNLFdBQVcsUUFBUSxDQUFDLENBQUM7QUFBQSxpQ0FDbkQsV0FBVyxLQUFLLENBQUMsQ0FBQyxNQUFNLFdBQVcsS0FBSyxDQUFDLENBQUM7QUFBQTtBQUFBLElBRXZFLGFBQWEsaUJBQWlCLEdBQUcsV0FBVyxNQUFNLENBQUM7QUFBQTtBQUFBLElBRW5ELGtCQUFrQjtBQUFBO0FBQUEsSUFFbEIsYUFBYSxVQUFVLENBQUM7QUFBQSxNQUN0QixhQUFhLHNDQUFzQyxVQUFVLENBQUM7QUFBQTtBQUFBLDBCQUUxQyxPQUFPLGdCQUFnQixZQUFZLENBQUM7QUFBQTtBQUFBLDhDQUVoQixnQkFBZ0IsSUFBSSxDQUFDO0FBQUEseURBQ1YsZ0JBQWdCLElBQUksQ0FBQyxvQkFDcEUsZ0JBQWdCLElBQUksQ0FBQztBQUFBLDJDQUNZLHNCQUFzQjtBQUFBO0FBQUEsaUJBRWhELE9BQU8sS0FBSyxLQUFLLE1BQU0sT0FBTyxLQUFLLEtBQUs7QUFBQSxrREFDUCxPQUFPLENBQUMsQ0FBQztBQUFBLHVDQUNwQixPQUFPLENBQUMsQ0FBQztBQUFBLDhDQUNGLE9BQU8sQ0FBQyxDQUFDO0FBQUEsZ0RBQ1AsV0FBVyxVQUFVLENBQUMsQ0FBQztBQUFBO0FBQUEseUNBRTlCLE9BQU8sZ0JBQWdCLElBQUksQ0FBQyxDQUFDO0FBQUE7QUFBQTtBQUFBO0FBQUEsOENBSXhCLE9BQU8sQ0FBQyxDQUFDO0FBQUEsZ0RBQ1AsV0FBVyxVQUFVLENBQUMsQ0FBQztBQUFBLHlDQUM5QixPQUFPLGdCQUFnQixJQUFJLENBQUMsQ0FBQztBQUFBO0FBQUE7QUFBQTtBQUFBLHVCQUs1RCxnQkFBZ0IsRUFBRSxJQUFJLFNBQVMsV0FBVyxVQUFVLGVBQWUsSUFDbkQsRUFBRSxJQUFJLFNBQVMsaUJBQWlCLFdBQVcsUUFBUSxDQUFDO0FBQUEsdUJBQ3ZELEVBQUUsSUFBSSxrQkFBa0IsY0FBYyxXQUFXLFFBQVEsQ0FBQztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFLM0UsV0FBVztBQUFBLE1BQ1gsZUFBZTtBQUFBLE1BQ2YsT0FBTyxZQUFZLGNBQWMsT0FBTyxDQUFDO0FBQUE7QUFFekMsZUFBTztBQUFBLFVBQ0wsTUFBTTtBQUFBLFVBQ04sYUFBYSxFQUFDLE1BQU0sV0FBVyxTQUFRO0FBQUEsVUFDdkMsWUFBWSxPQUFPO0FBQUEsWUFDakIsU0FBUyxDQUFDO0FBQUEsY0FDUixNQUFNLDZCQUE2QiwyQkFBMkIsV0FBVyxJQUFJO0FBQUEsY0FDN0UsVUFBVSxPQUFPLENBQUMsRUFBRTtBQUFBLFlBQ3RCLENBQUM7QUFBQSxZQUNELGVBQWUsRUFBQyxHQUFHLEtBQUs7QUFBQSxjQUFLLGFBQWE7QUFBQTtBQUFBLFlBQXVCLEVBQUM7QUFBQSxVQUNwRTtBQUFBLFVBQ0E7QUFBQSxRQUNGO0FBQUEsTUFDRjtBQUVHLE1BQU0sd0NBQ1QsQ0FBQyxRQUErQixZQUE0QixnQkFBZ0Q7QUFDMUcsY0FBTSxVQUFVLE9BQU8sU0FBUztBQUNoQyxjQUFNLGFBQWEsaUJBQWlCLFlBQVksQ0FBQyxDQUFDO0FBQ2xELGNBQU0sZUFBZSxpQkFBaUIsWUFBWSxDQUFDLENBQUM7QUFDcEQsY0FBTSxhQUFhLFVBQVUsS0FBSyxXQUFXLElBQUksYUFBYTtBQUM5RCxjQUFNLFNBQVMsQ0FBQyxPQUFPLENBQUMsRUFBRSxLQUFLLENBQUMsR0FBRyxPQUFPLENBQUMsRUFBRSxLQUFLLENBQUMsR0FBRyxPQUFPLENBQUMsRUFBRSxLQUFLLENBQUMsR0FBRyxPQUFPLENBQUMsRUFBRSxLQUFLLENBQUMsSUFBSSxVQUFVO0FBQ3ZHLGNBQU0sU0FBUyxDQUFDLE9BQU8sQ0FBQyxFQUFFLEtBQUssQ0FBQyxHQUFHLE9BQU8sQ0FBQyxFQUFFLEtBQUssQ0FBQyxHQUFHLE9BQU8sQ0FBQyxFQUFFLEtBQUssQ0FBQyxHQUFHLE9BQU8sQ0FBQyxFQUFFLEtBQUssQ0FBQyxJQUFJLFVBQVU7QUFDdkcsY0FBTSxzQkFBc0IsQ0FBQyxZQUFZLENBQUMsR0FBRyxZQUFZLENBQUMsR0FBRyxZQUFZLENBQUMsR0FBRyxZQUFZLENBQUMsSUFBSSxVQUFVO0FBRXhHLGNBQU0sa0JBQW9DO0FBQUEsVUFDeEMsRUFBQyxNQUFNLFVBQVUsTUFBTSxXQUFVO0FBQUEsVUFBRyxFQUFDLE1BQU0sU0FBUyxNQUFNLFdBQVcsUUFBTztBQUFBLFVBQzVFLEVBQUMsTUFBTSxTQUFTLE1BQU0sV0FBVyxLQUFJO0FBQUEsVUFBRyxHQUFHLDJCQUEyQixNQUFNO0FBQUEsVUFDNUUsR0FBRywyQkFBMkIsTUFBTTtBQUFBLFVBQUcsR0FBRywyQkFBMkIsbUJBQW1CO0FBQUEsUUFDMUY7QUFDQSxjQUFNLFdBQVcsZUFBZSxLQUFLLFdBQVcsUUFBUSxDQUFDLElBQUksT0FBTyxDQUFDO0FBQ3JFLGNBQU0sa0JBQWtCLENBQUMsaUJBQStCO0FBQ3RELGdCQUFNLFNBQVMsZUFBZSxVQUFVLE9BQU8sQ0FBQyxFQUFFLFVBQVUsb0JBQW9CLFFBQVEsVUFBVTtBQUNsRyxnQkFBTSxFQUFDLG9CQUFvQixnQkFBZSxJQUFJLHFCQUFxQixZQUFZLE9BQU8sS0FBSyxLQUFLO0FBQ2hHLGdCQUFNLElBQUksY0FBYyxLQUFLLE9BQU8sQ0FBQyxFQUFFLFVBQVUsT0FBTyxRQUFRLFVBQVU7QUFDMUUsZ0JBQU0sSUFBSSxjQUFjLEtBQUssT0FBTyxDQUFDLEVBQUUsVUFBVSxPQUFPLFFBQVEsVUFBVTtBQUMxRSxnQkFBTSxZQUFZLENBQUMsR0FBRyxDQUFDO0FBQ3ZCLGNBQUksU0FBUztBQUNYLHNCQUFVLEtBQUssY0FBYyxLQUFLLE9BQU8sQ0FBQyxFQUFFLFVBQVUsT0FBTyxDQUFDLEVBQUUsTUFBTSxVQUFVLENBQUM7QUFBQSxVQUNuRjtBQUNBLGdCQUFNLGNBQWMsVUFBVSxnQ0FBZ0M7QUFFOUQsaUJBQU87QUFBQSxJQUVILGFBQWEsZ0JBQWdCLGVBQWUsS0FBSyxFQUM1QyxnQkFBZ0IsV0FBVyxPQUFPLENBQUMsRUFDbkMsZ0JBQWdCLFFBQVEsT0FBTyxDQUFDLEVBQ2hDLGlCQUFpQixHQUFHLFdBQVcsTUFBTSxDQUFDO0FBQUEsSUFDbkQsa0JBQWtCO0FBQUEsSUFDbEIsYUFBYSxVQUFVLENBQUM7QUFBQSxNQUN0QixhQUFhLHNDQUFzQyxzQkFBc0IsQ0FBQztBQUFBO0FBQUE7QUFBQTtBQUFBLDhDQUlsQyxZQUFZO0FBQUEsb0NBQ3RCLFlBQVk7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSx3QkFPeEIsRUFBRSxLQUFLLEtBQUssS0FBSyxPQUFPO0FBQUEsd0JBQ3hCLE9BQU8sS0FBSyxLQUFLLEtBQUssWUFBWTtBQUFBO0FBQUE7QUFBQSw4Q0FHWixPQUFPLENBQUMsQ0FBQztBQUFBO0FBQUE7QUFBQSw4QkFHekIsT0FBTztBQUFBO0FBQUE7QUFBQSwwQkFHWCxFQUFFLElBQUksU0FBUyxpQkFBaUIsZ0JBQWdCLGVBQWUsQ0FBQztBQUFBO0FBQUEsMEJBRWhFLEVBQUUsS0FBSyxLQUFLO0FBQUE7QUFBQTtBQUFBLGdEQUdVLE9BQU8sQ0FBQyxDQUFDO0FBQUEsd0JBQ2pDLEVBQUUsSUFBSSxZQUFZLFdBQVcsS0FBSyxnQkFBZ0IsQ0FBQztBQUFBLGlDQUMxQyxZQUFZO0FBQUEseUNBQ0osV0FBVyxRQUFRLENBQUMsQ0FBQztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSwyQkFNbkMsWUFBWTtBQUFBO0FBQUEsUUFFL0IsV0FBVztBQUFBLFFBQ1gsZUFBZTtBQUFBLFFBQ2YsT0FBTyxJQUFJLFNBQVMsT0FBTyxXQUFXLGtCQUFrQixPQUFPLENBQUM7QUFBQTtBQUFBO0FBQUEsUUFHbEU7QUFFQSxlQUFPO0FBQUEsVUFDTCxNQUFNO0FBQUEsVUFDTixhQUFhO0FBQUEsWUFDWCxNQUFNLEdBQUcsV0FBVyxrQkFBa0IsSUFBSSxVQUFVLElBQUksWUFBWSxJQUFJLE9BQU8sSUFBSSxPQUFPLENBQUMsQ0FBQyxJQUFJLE9BQU8sQ0FBQyxDQUFDO0FBQUEsWUFDekcsbUJBQW1CLFVBQVUsQ0FBQyxRQUFRLFFBQVEsTUFBTSxJQUFJLENBQUMsUUFBUSxNQUFNO0FBQUEsVUFDekU7QUFBQSxVQUNBLFlBQVksT0FBTztBQUFBLFlBQ2pCLFNBQVMsQ0FBQyxFQUFDLE1BQU0sYUFBYSxVQUFVLE9BQU8sQ0FBQyxFQUFFLFNBQVEsQ0FBQztBQUFBLFlBQzNELGVBQWUsRUFBQyxHQUFHLEtBQUs7QUFBQSxjQUFLLGFBQWE7QUFBQTtBQUFBLFlBQXVCLEVBQUM7QUFBQSxZQUNsRTtBQUFBLFVBQ0Y7QUFBQSxVQUNBO0FBQUEsUUFDRjtBQUFBLE1BQ0Y7QUFBQTtBQUFBOzs7QUMvTEosTUFXYSw4QkEwSVBDLGlCQVVPO0FBL0piO0FBQUE7QUFBQTtBQUlBO0FBR0E7QUFDQTtBQUNBO0FBRU8sTUFBTSwrQkFDVCxDQUFDLFFBQStCLHNCQUFvRCxhQUNuRixxQkFDQSxpQkFBaUIsVUFBeUQ7QUFDekUsY0FBTSxTQUFTLE9BQU8sQ0FBQyxFQUFFO0FBQ3pCLGNBQU0sU0FBUyxPQUFPLENBQUMsRUFBRTtBQUV6QixjQUFNLElBQUksT0FBTyxPQUFPLFNBQVMsQ0FBQztBQUNsQyxjQUFNLElBQUksT0FBTyxPQUFPLFNBQVMsQ0FBQztBQUNsQyxjQUFNLElBQUksT0FBTyxPQUFPLFNBQVMsQ0FBQztBQUNsQyxjQUFNLGFBQWEsaUJBQWlCLENBQUM7QUFDckMsY0FBTSxjQUFjLGlCQUFpQixDQUFDO0FBQ3RDLGNBQU0sZUFBZSxpQkFBaUIsQ0FBQztBQUN2QyxjQUFNLGFBQWEsVUFBVSxLQUFLLFdBQVcsSUFBSSxhQUFhO0FBQzlELGNBQU0sVUFBVSxPQUFPLFNBQVM7QUFDaEMsY0FBTSxZQUFZLHNCQUFzQixvQkFBb0IsTUFBTSxHQUFHLEVBQUUsSUFBSSxZQUFZLE1BQU0sR0FBRyxFQUFFO0FBQ2xHLGNBQU0sWUFBWSxVQUFVLEtBQUssU0FBUztBQUMxQyxjQUFNLHNCQUFzQixDQUFDLFdBQVcsR0FBRyxDQUFDO0FBQzVDLGNBQU0sa0JBQW9DO0FBQUEsVUFDeEMsRUFBQyxNQUFNLFVBQVUsTUFBTSxXQUFVO0FBQUEsVUFBRyxFQUFDLE1BQU0sVUFBVSxNQUFNLEVBQUM7QUFBQSxVQUFHLEVBQUMsTUFBTSxVQUFVLE1BQU0sRUFBQztBQUFBLFVBQ3ZGLEVBQUMsTUFBTSxVQUFVLE1BQU0sRUFBQztBQUFBLFVBQUcsR0FBRywyQkFBMkIsU0FBUztBQUFBLFVBQUcsR0FBRywyQkFBMkIsTUFBTTtBQUFBLFVBQ3pHLEdBQUcsMkJBQTJCLE1BQU07QUFBQSxRQUN0QztBQUNBLFlBQUksU0FBUztBQUNYLDBCQUFnQixLQUFLLEdBQUcsMkJBQTJCLE9BQU8sQ0FBQyxFQUFFLElBQUksQ0FBQztBQUFBLFFBQ3BFO0FBQ0Esd0JBQWdCLEtBQUssR0FBRywyQkFBMkIsbUJBQW1CLENBQUM7QUFFdkUsY0FBTSxrQkFBa0IsQ0FBQyxpQkFBK0I7QUFDdEQsZ0JBQU0sWUFBWSxpQkFBaUIsY0FBYyxPQUFPLENBQUMsRUFBRSxVQUFVLFVBQVUsTUFBTTtBQUNyRixnQkFBTSxJQUFJLGNBQWMsS0FBSyxPQUFPLENBQUMsRUFBRSxVQUFVLE9BQU8sUUFBUSxXQUFXO0FBQzNFLGdCQUFNLElBQUksY0FBYyxLQUFLLE9BQU8sQ0FBQyxFQUFFLFVBQVUsT0FBTyxRQUFRLFVBQVU7QUFDMUUsZ0JBQU0sU0FBUyxlQUFlLFVBQVUsT0FBTyxDQUFDLEVBQUUsVUFBVSxvQkFBb0IsUUFBUSxVQUFVO0FBQ2xHLGdCQUFNLEVBQUMsb0JBQW9CLGdCQUFlLElBQUkscUJBQXFCLHNCQUFzQixPQUFPLEtBQUssS0FBSztBQUMxRyxnQkFBTSxpQkFBaUIsQ0FBQyxHQUFHLENBQUM7QUFDNUIsY0FBSSxjQUFjO0FBQ2xCLGNBQUksU0FBUztBQUNYLGtCQUFNLGlCQUFpQixpQkFBaUIsYUFBYTtBQUNyRCwyQkFBZSxLQUFLLGNBQWMsUUFBUSxPQUFPLENBQUMsRUFBRSxVQUFVLE9BQU8sQ0FBQyxFQUFFLEtBQUssUUFBUSxjQUFjLENBQUM7QUFDcEcsMEJBQWMsR0FDVixpQkFBaUIsdUJBQXVCLGNBQWMsT0FDckMsWUFBWSxPQUFPLEtBQUssS0FBSyxrQkFBa0I7QUFBQSxVQUN0RTtBQUVBLGdCQUFNLGFBQWEsT0FBTyxNQUFNLEdBQUcsRUFBRTtBQUNyQyxnQkFBTSxhQUFhLE9BQU8sTUFBTSxHQUFHLEVBQUU7QUFDckMsZ0JBQU0saUJBQWlCLGlCQUFpQixZQUFZLFNBQVM7QUFDN0QsZ0JBQU0saUJBQWlCLGlCQUFpQixZQUFZLFNBQVM7QUFDN0QsZ0JBQU0sYUFBYSxDQUFDLFVBQXlCLGtCQUE0QjtBQUN2RSxrQkFBTSxPQUFPLFNBQVM7QUFDdEIsa0JBQU0sT0FBTyxTQUFTO0FBQ3RCLGdCQUFJLFNBQVMsR0FBRztBQUNkLHFCQUFPLE9BQU8sSUFBSSxjQUFjLFNBQVMsS0FBSyxPQUFPO0FBQUEsWUFDdkQ7QUFDQSxrQkFBTSxZQUFZLFVBQVU7QUFDNUIsZ0JBQUksU0FBUyxPQUFPLElBQUksYUFBYSxTQUFTLEtBQUssT0FBTztBQUMxRCxxQkFBUyxJQUFJLE9BQU8sSUFBSSxHQUFHLElBQUksWUFBWSxHQUFHLEtBQUssR0FBRyxLQUFLLEtBQUs7QUFDOUQsd0JBQVU7QUFBQSxFQUFLLElBQUksWUFBWSxDQUFDLE9BQU8sWUFBWSxJQUFJLGlCQUFpQixDQUFDLE1BQU0sZUFBZTtBQUFBLFlBQ2hHO0FBQ0EsMEJBQWMsUUFBUSxPQUFLO0FBQ3pCLHdCQUFVO0FBQUEsRUFBSyxJQUFJLFlBQVksQ0FBQztBQUFBLFlBQ2xDLENBQUM7QUFDRCxzQkFBVSxHQUFHLElBQUksWUFBWSxPQUFPLENBQUM7QUFBQSx1QkFDeEIsSUFBSSxZQUFZLE9BQU8sQ0FBQztBQUNyQyxtQkFBTztBQUFBLFVBQ1Q7QUFFQSxnQkFBTSxhQUFhLE1BQWM7QUFDL0IsZ0JBQUksVUFBVSxlQUFlLEVBQUUsS0FBSyxLQUFLO0FBQ3pDLHFCQUFTLElBQUksR0FBRyxJQUFJLGFBQWEsS0FBSztBQUNwQyx5QkFBVztBQUFBLDBCQUNHLENBQUMseUJBQXlCLENBQUMsMkJBQTJCLFVBQVU7QUFBQSxZQUNoRjtBQUNBLHFCQUFTLElBQUksR0FBRyxJQUFJLGNBQWMsS0FBSztBQUNyQyx5QkFBVyxpQ0FBaUMsQ0FBQyx5QkFBeUIsV0FBVztBQUVqRix1QkFBUyxJQUFJLEdBQUcsSUFBSSxhQUFhLEtBQUs7QUFDcEMsMkJBQVc7QUFBQSxxQkFDSixDQUFDLFdBQVcsRUFBRSxLQUFLLEtBQUssVUFBVSxnQkFBZ0IsSUFBSSxLQUFLLElBQUksQ0FBQyxHQUFHLFlBQVksQ0FBQyxZQUNuRixDQUFDO0FBQUE7QUFBQSxjQUNQO0FBQUEsWUFDRjtBQUNBLG1CQUFPO0FBQUEsVUFDVDtBQUVBLGlCQUFPO0FBQUEsSUFFSCxhQUFhLGdCQUFnQixjQUFjLEtBQUssRUFDM0MsZ0JBQWdCLEtBQUssS0FBSyxFQUMxQixnQkFBZ0IsS0FBSyxLQUFLLEVBQzFCLGdCQUFnQixLQUFLLEtBQUssRUFDMUIsMEJBQTBCLFNBQVMsRUFDbkMsaUJBQWlCLEdBQUcsZ0JBQWdCLE1BQU0sQ0FBQztBQUFBLElBQ3hELGtCQUFrQjtBQUFBLElBQ2xCLGFBQWEsVUFBVSxDQUFDO0FBQUEsTUFDdEIsYUFBYSxzQ0FBc0MscUJBQXFCLENBQUM7QUFBQSw0Q0FDbkMsVUFBVSxRQUFRLFVBQVU7QUFBQSw4Q0FDMUIsVUFBVTtBQUFBLGlDQUN2QixZQUFZO0FBQUEscUNBQ1IsWUFBWTtBQUFBO0FBQUE7QUFBQSxNQUczQyxZQUFZLFdBQVcsSUFBSSxLQUFLLHVCQUF1QixVQUFVLGdCQUFnQixPQUFPLENBQUMsR0FBRztBQUFBLE1BQzVGLFdBQVcsR0FBRyxjQUFjLENBQUM7QUFBQSxxQkFDZCxFQUFFLGdCQUFnQixXQUFXLENBQUM7QUFBQSxNQUM3QyxXQUFXLEdBQUcsY0FBYyxDQUFDO0FBQUEscUJBQ2QsRUFBRSxnQkFBZ0IsV0FBVyxDQUFDO0FBQUEsd0JBQzNCLE9BQU8sS0FBSyxLQUFLLEtBQUssWUFBWTtBQUFBLG9EQUNOLFdBQVc7QUFBQSxRQUN2RCxXQUFXLENBQUM7QUFBQTtBQUFBLDJCQUVPLFlBQVk7QUFBQTtBQUFBLFFBRS9CLFdBQVc7QUFBQSxRQUNYLGVBQWU7QUFBQSwwQkFDRyxPQUFPLEtBQUssT0FBTztBQUFBLHFCQUN4QixPQUFPLGdCQUFnQixhQUFhLENBQUM7QUFBQSxRQUNsRCxPQUFPLFlBQVksWUFBWSxVQUFVLElBQUksT0FBTyxDQUFDO0FBQUE7QUFBQTtBQUFBO0FBQUEsUUFJdkQ7QUFDQSxlQUFPO0FBQUEsVUFDTCxNQUFNO0FBQUEsVUFDTixhQUFhO0FBQUEsWUFDWCxNQUFNLEdBQUcscUJBQXFCLGtCQUFrQixJQUFJLFVBQVUsSUFBSSxXQUFXLElBQUksWUFBWSxJQUN6RixjQUFjO0FBQUEsWUFDbEIsbUJBQW1CLFVBQVUsQ0FBQyxRQUFRLFFBQVEsTUFBTSxJQUFJLENBQUMsUUFBUSxNQUFNO0FBQUEsVUFDekU7QUFBQSxVQUNBLFlBQVksT0FBTztBQUFBLFlBQ2pCLFNBQVMsQ0FBQyxFQUFDLE1BQU0sYUFBYSxVQUFVLE9BQU8sQ0FBQyxFQUFFLFNBQVEsQ0FBQztBQUFBLFlBQzNELGVBQWUsRUFBQyxHQUFHLEtBQUs7QUFBQSxjQUFLLGFBQWE7QUFBQTtBQUFBLFlBQXVCLEVBQUM7QUFBQSxZQUNsRTtBQUFBLFVBQ0Y7QUFBQSxVQUNBO0FBQUEsUUFDRjtBQUFBLE1BQ0Y7QUFFSixNQUFNQSxrQkFBaUIsQ0FBQyxXQUF3QztBQUM5RCxZQUFJLENBQUMsVUFBVSxPQUFPLFdBQVcsR0FBRztBQUNsQyxnQkFBTSxJQUFJLE1BQU0sMkJBQTJCO0FBQUEsUUFDN0M7QUFFQSxZQUFJLE9BQU8sQ0FBQyxFQUFFLEtBQUssT0FBTyxDQUFDLEVBQUUsS0FBSyxTQUFTLENBQUMsTUFBTSxPQUFPLENBQUMsRUFBRSxLQUFLLE9BQU8sQ0FBQyxFQUFFLEtBQUssU0FBUyxDQUFDLEdBQUc7QUFDM0YsZ0JBQU0sSUFBSSxNQUFNLGtDQUFrQztBQUFBLFFBQ3BEO0FBQUEsTUFDRjtBQUVPLE1BQU0sU0FBUyxDQUFDLFlBQWtDO0FBQ3ZELFFBQUFBLGdCQUFlLFFBQVEsTUFBTTtBQUM3QixjQUFNLGNBQWMsY0FBYyxVQUFVLFFBQVEsT0FBTyxDQUFDLEVBQUUsTUFBTSxRQUFRLE9BQU8sQ0FBQyxFQUFFLE1BQU0sSUFBSTtBQUNoRyxZQUFJLENBQUMsYUFBYTtBQUNoQixnQkFBTSxJQUFJLE1BQU0sdUNBQXdDO0FBQUEsUUFDMUQ7QUFDQSxjQUFNLElBQUksWUFBWSxZQUFZLFNBQVMsQ0FBQztBQUM1QyxjQUFNLElBQUksUUFBUSxPQUFPLENBQUMsRUFBRSxLQUFLLFFBQVEsT0FBTyxDQUFDLEVBQUUsS0FBSyxTQUFTLENBQUM7QUFDbEUsWUFBSSxJQUFJLEtBQUssSUFBSSxHQUFHO0FBQ2xCLGtCQUFRO0FBQUEsWUFDSiw2QkFBNkIsUUFBUSxRQUFRLEVBQUMsWUFBWSxJQUFJLG9CQUFvQixHQUFFLEdBQUcsV0FBVztBQUFBLFVBQUM7QUFBQSxRQUN6RyxPQUFPO0FBQ0wsa0JBQVEsUUFBUSx3QkFBd0IsUUFBUSxRQUFRLEVBQUMsWUFBWSxJQUFJLG9CQUFvQixHQUFFLEdBQUcsV0FBVyxDQUFDO0FBQUEsUUFDaEg7QUFBQSxNQUNGO0FBQUE7QUFBQTs7O0FDN0tBLE1BZWEsc0JBNkJQLDBCQUVBQyxpQkFtREEsMkJBbUJPLHFCQWdCUCxRQXdJQSxRQTBCTztBQXRTYjtBQUFBO0FBQUE7QUFJQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRU8sTUFBTSx1QkFDVCxDQUFDLFlBQStCLGFBQWdDLFdBQy9ELFlBQStCLFNBQTRCLGtCQUFxQztBQUMvRixjQUFNLFlBQVksV0FBVyxDQUFDO0FBQzlCLGNBQU0sb0JBQW9CLFdBQVcsTUFBTSxnQkFBZ0IsSUFBSSxHQUFHLGdCQUFnQixJQUFJLENBQUM7QUFDdkYsY0FBTSxjQUFjLGtCQUFrQjtBQUN0QyxjQUFNLGNBQWMsWUFBWSxDQUFDO0FBQ2pDLGNBQU0scUJBQXFCLFlBQVksTUFBTSxDQUFDO0FBQzlDLGNBQU0scUJBQXFCLG1CQUFtQixJQUFJLENBQUMsR0FBRyxNQUFNLEtBQUssSUFBSSxNQUFNLFVBQVUsQ0FBQyxJQUFJLEVBQUU7QUFDNUYsY0FBTSwyQkFBMkIsa0JBQWtCLElBQUksQ0FBQyxHQUFHLE1BQU0sSUFBSSxXQUFXLENBQUMsSUFBSSxXQUFXLElBQUksV0FBVyxDQUFDO0FBQ2hILGNBQU0sY0FDRix5QkFBeUIsSUFBSSxDQUFDLEdBQUcsTUFBTSxLQUFLLE9BQU8sSUFBSSxtQkFBbUIsQ0FBQyxJQUFJLFFBQVEsQ0FBQyxLQUFLLFFBQVEsQ0FBQyxDQUFDLENBQUM7QUFDNUcsb0JBQVksT0FBTyxHQUFHLEdBQUcsU0FBUztBQUNsQyxvQkFBWSxPQUFPLGdCQUFnQixJQUFJLEdBQUcsR0FBRyxXQUFXO0FBQ3hELGVBQU87QUFBQSxNQUNUO0FBY0osTUFBTSwyQkFBMkIsQ0FBQyxHQUFHLEdBQUcsR0FBRyxDQUFDO0FBRTVDLE1BQU1BLGtCQUFpQixDQUFDLFFBQStCLGVBQXFDO0FBRzFGLFlBQUksQ0FBQyxVQUFXLE9BQU8sV0FBVyxLQUFLLE9BQU8sV0FBVyxHQUFJO0FBQzNELGdCQUFNLElBQUksTUFBTSw2QkFBNkI7QUFBQSxRQUMvQztBQUdBLFlBQUksT0FBTyxDQUFDLEVBQUUsS0FBSyxXQUFXLEtBQUssT0FBTyxDQUFDLEVBQUUsS0FBSyxXQUFXLEdBQUc7QUFDOUQsZ0JBQU0sSUFBSSxNQUFNLHVDQUF1QztBQUFBLFFBQ3pEO0FBRUEsWUFBSSxPQUFPLENBQUMsRUFBRSxLQUFLLFdBQVcsT0FBTyxDQUFDLEVBQUUsS0FBSyxRQUFRO0FBQ25ELGdCQUFNLElBQUksTUFBTSw4Q0FBOEM7QUFBQSxRQUNoRTtBQUdBLGNBQU0sY0FBYyxPQUFPLENBQUMsRUFBRSxLQUFLLFdBQVcsV0FBVyxTQUFTLE9BQU8sQ0FBQyxFQUFFLEtBQUssU0FBUyxJQUFJLENBQUM7QUFDL0YsY0FBTSxrQkFBa0IsT0FBTyxDQUFDLEVBQUUsS0FBSyxDQUFDLElBQUksV0FBVztBQUN2RCxZQUFJLGdCQUFnQixpQkFBaUI7QUFDbkMsZ0JBQU0sSUFBSSxNQUFNLG1EQUFtRDtBQUFBLFFBQ3JFO0FBR0EsWUFBSSxPQUFPLFdBQVcsTUFBTSxPQUFPLENBQUMsRUFBRSxLQUFLLFdBQVcsS0FBSyxPQUFPLENBQUMsRUFBRSxLQUFLLENBQUMsTUFBTSxPQUFPLENBQUMsRUFBRSxLQUFLLENBQUMsSUFBSTtBQUNuRyxnQkFBTSxJQUFJLE1BQU0sY0FBYztBQUFBLFFBQ2hDO0FBRUEsY0FBTSxjQUFjLE9BQU8sQ0FBQyxFQUFFLEtBQUssU0FBUztBQUU1QyxZQUFJLFdBQVcsVUFBVSxXQUFXLGFBQWE7QUFDL0MsZ0JBQU0sSUFBSSxNQUFNLHVCQUF1QixXQUFXLEdBQUc7QUFBQSxRQUN2RDtBQUdBLFlBQUksV0FBVyxRQUFRLFdBQVcsYUFBYTtBQUM3QyxnQkFBTSxJQUFJLE1BQU0scUJBQXFCLFdBQVcsR0FBRztBQUFBLFFBQ3JEO0FBR0EsWUFBSSxXQUFXLEtBQUssV0FBVyxjQUFjLEdBQUc7QUFDOUMsZ0JBQU0sSUFBSSxNQUFNLGtCQUFrQixjQUFjLENBQUMsR0FBRztBQUFBLFFBQ3REO0FBSUEsWUFBSSxXQUFXLFlBQVksV0FBVyxLQUFLLFdBQVcsWUFBWSxXQUFXLE9BQU8sQ0FBQyxFQUFFLEtBQUssU0FBUyxHQUFHO0FBQ3RHLGdCQUFNLElBQUksTUFBTSxzQkFBc0I7QUFBQSxRQUN4QztBQUFBLE1BQ0Y7QUFFQSxNQUFNLDRCQUE0QixDQUEyQixZQUFlLFdBQXFDO0FBQy9HLGNBQU0sY0FBYyxXQUFXLFlBQVksTUFBTTtBQUVqRCxpQkFBUyxJQUFJLEdBQUcsSUFBSSxPQUFPLENBQUMsRUFBRSxLQUFLLFFBQVEsRUFBRSxHQUFHO0FBQzlDLGNBQUksWUFBWSxJQUFJLENBQUMsTUFBTSxHQUFHO0FBQzVCLHdCQUFZLElBQUksQ0FBQyxJQUFJLE9BQU8sQ0FBQyxFQUFFLEtBQUssQ0FBQztBQUFBLFVBQ3ZDO0FBQUEsUUFDRjtBQUNBLGNBQU0sT0FBTyxXQUFXLEtBQUssTUFBTTtBQUNuQyxxQkFBYTtBQUFBLFVBQ1QsT0FBTyxDQUFDLEVBQUU7QUFBQSxVQUFNLFdBQVc7QUFBQSxVQUFTLFdBQVc7QUFBQSxVQUFXO0FBQUEsVUFBYTtBQUFBLFVBQU0sV0FBVyxXQUFXO0FBQUEsVUFDbkcsV0FBVztBQUFBLFFBQU87QUFHdEIsY0FBTSxnQkFBbUIsT0FBTyxPQUFPLENBQUMsR0FBRyxVQUFVO0FBQ3JELGVBQU8sT0FBTyxlQUFlLEVBQUMsYUFBYSxNQUFNLFVBQVUsV0FBVyxTQUFRLENBQUM7QUFDL0UsZUFBTztBQUFBLE1BQ1Q7QUFFTyxNQUFNLHNCQUFzQixDQUFDLGVBQXdEO0FBQzFGLGNBQU0sdUJBQXVCLGtDQUFrQyxVQUFVO0FBRXpFLGNBQU0sU0FBUyxXQUFXO0FBQzFCLGNBQU0sVUFBVSxDQUFDLFVBQVUsU0FBUyxjQUFjLFlBQVksRUFBRSxXQUFXLFFBQWtCO0FBQzdGLGNBQU0sWUFBWSxXQUFXO0FBQzdCLGNBQU0sUUFBUSxXQUFXO0FBQ3pCLGNBQU0sY0FBYyxXQUFXO0FBQy9CLGNBQU0sT0FBTyxXQUFXO0FBQ3hCLGNBQU0sVUFBVSxXQUFXO0FBQzNCLGNBQU0sV0FBWSxXQUFXLFdBQTZCO0FBRTFELGVBQU87QUFBQSxVQUNILEVBQUMsU0FBUyxRQUFRLFdBQVcsT0FBTyxhQUFhLE1BQU0sU0FBUyxVQUFVLEdBQUcscUJBQW9CO0FBQUEsUUFBQztBQUFBLE1BQ3hHO0FBRUEsTUFBTSxTQUFTLENBQUMsU0FBeUIsUUFBK0IsZUFBcUM7QUFDM0csY0FBTSxxQkFBcUIsMEJBQTBCLFlBQVksTUFBTTtBQUt2RSxjQUFNLGlCQUFpQixXQUFXLFdBQVc7QUFDN0MsWUFBSSxXQUFXLFVBQVUsR0FBRztBQUkxQixnQkFBTSw4QkFBOEI7QUFDcEMsY0FBSSxDQUFDLCtCQUErQixrQkFBa0IsT0FBTyxDQUFDLEVBQUUsS0FBSyxDQUFDLE1BQU0sV0FBVyxTQUNuRixPQUFPLENBQUMsRUFBRSxLQUFLLENBQUMsTUFBTSxLQUFLLFdBQVcsVUFBVSxDQUFDLE1BQU0sS0FBSyxXQUFXLFVBQVUsQ0FBQyxNQUFNLEdBQUc7QUFDN0Ysa0JBQU1DLGVBQWM7QUFBQSxjQUNoQixPQUFPLENBQUMsRUFBRTtBQUFBLGNBQU0sT0FBTyxDQUFDLEVBQUU7QUFBQSxjQUFNLFdBQVc7QUFBQSxjQUFXLG1CQUFtQjtBQUFBLGNBQU0sV0FBVztBQUFBLGNBQzFGO0FBQUEsWUFBYztBQUNsQixrQkFBTUMsb0JBQW9CLFFBQVEsaUJBQWlCLE1BQy9DLFFBQVE7QUFBQSxjQUNKLDJCQUEyQixPQUFPLENBQUMsR0FBRyx3QkFBd0I7QUFBQSxjQUM5RCxFQUFDLFFBQVEsQ0FBQyxDQUFDLEdBQUcsU0FBUyxDQUFDLFdBQVcsV0FBVyxLQUFLLEVBQUUsRUFBQztBQUFBLFlBQUMsRUFBRSxDQUFDO0FBQ2xFLGdCQUFJLFdBQVcsWUFBWSxDQUFDLFFBQVEsaUJBQWlCLElBQUk7QUFDdkQsc0JBQVEsaUJBQWlCLEtBQUtBO0FBQUEsWUFDaEM7QUFDQSxrQkFBTUMsY0FBYSxDQUFDLE9BQU8sQ0FBQyxHQUFHRCxpQkFBZ0I7QUFDL0MsZ0JBQUksT0FBTyxXQUFXLEdBQUc7QUFDdkIsY0FBQUMsWUFBVyxLQUFLLE9BQU8sQ0FBQyxDQUFDO0FBQUEsWUFDM0I7QUFDQSxvQkFBUTtBQUFBLGNBQ0osc0NBQXNDQSxhQUFZLG9CQUFvQkYsWUFBVztBQUFBLGNBQUcsRUFBQyxRQUFRRSxZQUFVO0FBQUEsWUFBQztBQUFBLFVBQzlHLE9BQU87QUFDTCxvQkFBUSxRQUFRLDZCQUE2QixRQUFRLGtCQUFrQixDQUFDO0FBQUEsVUFDMUU7QUFDQTtBQUFBLFFBQ0Y7QUFFQSxjQUFNLFVBQVUsT0FBTyxXQUFXO0FBQ2xDLGNBQU0sY0FBYyxPQUFPLENBQUMsRUFBRSxLQUFLLGlCQUFpQixJQUFJLENBQUM7QUFDekQsY0FBTSxhQUFhLE9BQU8sQ0FBQyxFQUFFLEtBQUssaUJBQWlCLElBQUksQ0FBQztBQUN4RCxjQUFNLGdCQUFnQixPQUFPLENBQUMsRUFBRSxLQUFLLGlCQUFpQixJQUFJLENBQUM7QUFDM0QsY0FBTSxlQUFlLE9BQU8sQ0FBQyxFQUFFLEtBQUssQ0FBQztBQUNyQyxjQUFNLGNBQWMsT0FBTyxDQUFDLEVBQUUsS0FBSyxDQUFDO0FBRXBDLGNBQU0sY0FBYztBQUFBLFVBQ2hCLE9BQU8sQ0FBQyxFQUFFO0FBQUEsVUFBTSxPQUFPLENBQUMsRUFBRTtBQUFBLFVBQU0sV0FBVztBQUFBLFVBQVcsbUJBQW1CO0FBQUEsVUFBTSxXQUFXO0FBQUEsVUFDMUY7QUFBQSxRQUFjO0FBQ2xCLGNBQU0sWUFBWSxZQUFZLGlCQUFpQixJQUFJLENBQUM7QUFDcEQsY0FBTSxXQUFXLFlBQVksaUJBQWlCLElBQUksQ0FBQztBQUNuRCxjQUFNLGNBQWMsWUFBWSxpQkFBaUIsSUFBSSxDQUFDO0FBRXRELGNBQU0sV0FBVyxrQkFBa0IsaUJBQWlCLGVBQWUsZ0JBQWdCLGNBQy9FLFdBQVcsS0FBSyxDQUFDLE1BQU0sS0FBSyxXQUFXLEtBQUssQ0FBQyxNQUFNO0FBQ3ZELFlBQUksWUFDQyxpQkFBaUIsS0FBSyxnQkFBZ0IsS0FBSyxXQUFXLFVBQVUsQ0FBQyxNQUFNLEtBQUssV0FBVyxVQUFVLENBQUMsTUFBTSxLQUN4RyxXQUFXLFFBQVEsQ0FBQyxNQUFNLEtBQUssV0FBVyxRQUFRLENBQUMsTUFBTSxLQUFLLFdBQVcsS0FBSyxDQUFDLE1BQU0sS0FDckYsV0FBVyxLQUFLLENBQUMsTUFBTSxHQUFJO0FBRTlCLGdCQUFNLFFBQVEsWUFBWSxDQUFDO0FBQzNCLGNBQUksV0FBVyxXQUFXO0FBQzFCLGdCQUFNLGVBQWUsQ0FBQztBQUN0QixjQUFJLGdCQUFnQjtBQUNsQixrQkFBTUQsb0JBQW9CLFFBQVEsaUJBQWlCLE1BQy9DLFFBQVE7QUFBQSxjQUNKLDJCQUEyQixPQUFPLENBQUMsR0FBRyx3QkFBd0I7QUFBQSxjQUM5RCxFQUFDLFFBQVEsQ0FBQyxDQUFDLEdBQUcsU0FBUyxDQUFDLFdBQVcsV0FBVyxLQUFLLEVBQUUsRUFBQztBQUFBLFlBQUMsRUFBRSxDQUFDO0FBQ2xFLGdCQUFJLFdBQVcsWUFBWSxDQUFDLFFBQVEsaUJBQWlCLElBQUk7QUFDdkQsc0JBQVEsaUJBQWlCLEtBQUtBO0FBQUEsWUFDaEM7QUFDQSxnQkFBSSxVQUFVO0FBQ1osb0JBQU0sWUFBWSxjQUFjLGFBQWE7QUFDN0MsMEJBQVksT0FBTyxDQUFDLEVBQUUsUUFBUSxDQUFDLEdBQUcsT0FBTyxTQUFTLENBQUM7QUFDbkQsMEJBQVlBLGtCQUFpQixRQUFRLENBQUMsR0FBRyxXQUFXLFdBQVcsQ0FBQztBQUNoRSxrQ0FBb0IsQ0FBQyxHQUFHLE9BQU8sV0FBVztBQUFBLFlBQzVDLE9BQU87QUFDTCwwQkFBWSxPQUFPLENBQUMsRUFBRSxRQUFRLENBQUMsT0FBTyxjQUFjLFlBQVksYUFBYSxDQUFDO0FBQzlFLDBCQUFZQSxrQkFBaUIsUUFBUSxDQUFDLEdBQUcsZUFBZSxXQUFXLENBQUM7QUFDcEUsa0NBQW9CLENBQUMsT0FBTyxZQUFZLFVBQVUsV0FBVztBQUFBLFlBQy9EO0FBQ0EseUJBQWEsS0FBSyxTQUFTO0FBQzNCLHlCQUFhLEtBQUssU0FBUztBQUFBLFVBQzdCLE9BQU87QUFDTCx3QkFBWSxPQUFPLENBQUMsRUFBRSxRQUFRLENBQUMsT0FBTyxlQUFlLGNBQWMsVUFBVSxDQUFDO0FBQzlFLHdCQUFZLE9BQU8sQ0FBQyxFQUFFLFFBQVEsQ0FBQyxHQUFHLGFBQWEsYUFBYSxDQUFDO0FBQzdELGdDQUFvQixDQUFDLE9BQU8sYUFBYSxZQUFZLFFBQVE7QUFDN0QseUJBQWEsS0FBSyxTQUFTO0FBQzNCLHlCQUFhLEtBQUssU0FBUztBQUFBLFVBQzdCO0FBQ0EsY0FBSSxTQUFTO0FBQ1gseUJBQWEsS0FBSyxPQUFPLENBQUMsQ0FBQztBQUFBLFVBQzdCO0FBQ0EsZ0JBQU0sSUFBSSxrQkFBa0IsQ0FBQztBQUM3QixnQkFBTSxJQUFJLGFBQWEsQ0FBQyxFQUFFLEtBQUssYUFBYSxDQUFDLEVBQUUsS0FBSyxTQUFTLENBQUM7QUFFOUQsY0FBSSxJQUFJLEtBQUssSUFBSSxHQUFHO0FBQ2xCLG9CQUFRO0FBQUEsY0FDSjtBQUFBLGdCQUNJO0FBQUEsZ0JBQWM7QUFBQSxnQkFBb0I7QUFBQSxnQkFBYTtBQUFBLGdCQUFtQjtBQUFBLGNBQWM7QUFBQSxjQUNwRixFQUFDLFFBQVEsYUFBWTtBQUFBLFlBQUM7QUFBQSxVQUM1QixPQUFPO0FBQ0wsb0JBQVE7QUFBQSxjQUNKLHdCQUF3QixjQUFjLG9CQUFvQixhQUFhLG1CQUFtQixjQUFjO0FBQUEsY0FDeEcsRUFBQyxRQUFRLGFBQVk7QUFBQSxZQUFDO0FBQUEsVUFDNUI7QUFDQTtBQUFBLFFBQ0Y7QUFJQSxjQUFNO0FBQUE7QUFBQSxVQUFnRTtBQUFBO0FBR3RFLGNBQU0sbUJBQW9CLFFBQVEsaUJBQWlCLE1BQy9DLFFBQVE7QUFBQSxVQUNKLDJCQUEyQixPQUFPLENBQUMsR0FBRyx3QkFBd0I7QUFBQSxVQUM5RCxFQUFDLFFBQVEsQ0FBQyxDQUFDLEdBQUcsU0FBUyxDQUFDLFdBQVcsV0FBVyxLQUFLLEVBQUUsRUFBQztBQUFBLFFBQUMsRUFBRSxDQUFDO0FBQ2xFLFlBQUksV0FBVyxZQUFZLENBQUMsUUFBUSxpQkFBaUIsSUFBSTtBQUN2RCxrQkFBUSxpQkFBaUIsS0FBSztBQUFBLFFBQ2hDO0FBR0EsY0FBTSxhQUFhLENBQUMsT0FBTyxDQUFDLEdBQUcsZ0JBQWdCO0FBQy9DLFlBQUksU0FBUztBQUNYLHFCQUFXLEtBQUssT0FBTyxDQUFDLENBQUM7QUFBQSxRQUMzQjtBQUdBLGNBQU0sWUFBWSxpQkFBaUIsWUFBWSxXQUFXO0FBQzFELGNBQU0sWUFBWSxpQkFBaUIsY0FBYyxZQUFZO0FBQzdELGNBQU0sV0FBVyxlQUFlLGNBQWM7QUFDOUMsZ0JBQVE7QUFBQSxVQUNKO0FBQUEsWUFDSTtBQUFBLFlBQVk7QUFBQSxZQUFvQjtBQUFBLFlBQWE7QUFBQSxZQUFXO0FBQUEsWUFBVztBQUFBLFlBQVU7QUFBQSxZQUM3RTtBQUFBLFVBQXlCO0FBQUEsVUFDN0IsRUFBQyxRQUFRLFdBQVU7QUFBQSxRQUFDO0FBQUEsTUFDMUI7QUFFQSxNQUFNLFNBQVMsQ0FBQyxTQUF5QixlQUFxQztBQUU1RSxjQUFNLGdCQUFnQixXQUFXLFdBQVc7QUFDNUMsY0FBTSxTQUFTO0FBQUEsVUFDYixRQUFRLE9BQU8sQ0FBQyxFQUFFO0FBQUEsWUFDZDtBQUFBO0FBQUEsY0FFSSxDQUFDLFFBQVEsT0FBTyxDQUFDLEVBQUUsS0FBSyxDQUFDLEdBQUcsR0FBRyxRQUFRLE9BQU8sQ0FBQyxFQUFFLEtBQUssQ0FBQyxHQUFHLFFBQVEsT0FBTyxDQUFDLEVBQUUsS0FBSyxDQUFDLENBQUM7QUFBQTtBQUFBO0FBQUEsY0FFbkYsQ0FBQyxRQUFRLE9BQU8sQ0FBQyxFQUFFLEtBQUssQ0FBQyxHQUFHLFFBQVEsT0FBTyxDQUFDLEVBQUUsS0FBSyxDQUFDLEdBQUcsR0FBRyxRQUFRLE9BQU8sQ0FBQyxFQUFFLEtBQUssQ0FBQyxDQUFDO0FBQUE7QUFBQSxVQUFDO0FBQUE7QUFBQSxVQUU1RixRQUFRLE9BQU8sQ0FBQyxFQUFFLFFBQVEsQ0FBQyxRQUFRLE9BQU8sQ0FBQyxFQUFFLEtBQUssQ0FBQyxHQUFHLFFBQVEsT0FBTyxDQUFDLEVBQUUsS0FBSyxDQUFDLEdBQUcsR0FBRyxRQUFRLE9BQU8sQ0FBQyxFQUFFLEtBQUssQ0FBQyxDQUFDLENBQUM7QUFBQSxRQUNoSDtBQUNBLFlBQUksUUFBUSxPQUFPLFdBQVcsR0FBRztBQUMvQixpQkFBTyxLQUFLLFFBQVEsT0FBTyxDQUFDLENBQUM7QUFBQSxRQUMvQjtBQUNBLGNBQU0sT0FBTyxDQUFDLEdBQUcsV0FBVyxLQUFLLENBQUMsR0FBRyxHQUFHLFdBQVcsS0FBSyxDQUFDLENBQUM7QUFDMUQsY0FBTSxVQUFVLENBQUMsQ0FBQyxFQUFFLE9BQU8sV0FBVyxPQUFPO0FBQzdDLGNBQU0sWUFBWSxDQUFDLENBQUMsRUFBRSxPQUFPLFdBQVcsU0FBUztBQUNqRCxjQUFNLGNBQWMsQ0FBQyxDQUFDLEVBQUUsT0FBTyxXQUFXLFdBQVc7QUFDckQsY0FBTSxxQkFBcUIsMEJBQTBCLEVBQUMsR0FBRyxZQUFZLE1BQU0sU0FBUyxXQUFXLFlBQVcsR0FBRyxNQUFNO0FBQ25ILGdCQUFRLFFBQVE7QUFBQSxVQUNaO0FBQUEsVUFBUTtBQUFBLFVBQ1IsaUJBQWUsZ0JBQWdCLENBQUMsWUFBWSxDQUFDLEdBQUcsWUFBWSxDQUFDLEdBQUcsWUFBWSxDQUFDLENBQUMsSUFBSSxDQUFDO0FBQUEsUUFBQyxDQUFDO0FBQUEsTUFDM0Y7QUFFTyxNQUFNLE9BQU8sQ0FBQyxTQUF5QixlQUFxQztBQUNqRixRQUFBRixnQkFBZSxRQUFRLFFBQVEsVUFBVTtBQUN6QyxZQUFJLFFBQVEsT0FBTyxDQUFDLEVBQUUsS0FBSyxXQUFXLEdBQUc7QUFDdkMsaUJBQU8sU0FBUyxVQUFVO0FBQUEsUUFDNUIsT0FBTztBQUNMLGlCQUFPLFNBQVMsUUFBUSxRQUFRLFVBQVU7QUFBQSxRQUM1QztBQUFBLE1BQ0Y7QUFBQTtBQUFBOzs7QUM3U0EsTUFnQ00sOEJBNEhPO0FBNUpiO0FBQUE7QUFBQTtBQXFCQTtBQUdBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFFQSxNQUFNLCtCQUNGLENBQUMsZ0JBQXlCLFVBQVUsT0FBTyxZQUFxQyxtQkFBbUIsTUFBYztBQUMvRyxjQUFNLE9BQU8sWUFBWSxrQkFBa0IsS0FBSztBQUNoRCxjQUFNLGNBQWMsQ0FBQ0ksc0JBQTZCO0FBQ2hELGtCQUFRQSxtQkFBa0I7QUFBQSxZQUN4QixLQUFLO0FBQ0gscUJBQU87QUFBQSxZQUNULEtBQUs7QUFDSCxxQkFBTztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBVVQ7QUFDRSxvQkFBTSxJQUFJLE1BQU0sb0JBQW9CQSxpQkFBZ0Isb0JBQW9CO0FBQUEsVUFDNUU7QUFBQSxRQUNGO0FBQ0EsY0FBTSxnQkFBZ0IsaUJBQWlCO0FBQUE7QUFBQSxVQUdBO0FBQUE7QUFBQTtBQUl2QyxjQUFNLGtCQUFrQixpQkFBaUI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsUUFPQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQVF6QyxjQUFNLFVBQVUsaUJBQWlCLG1CQUFtQjtBQUNwRCxjQUFNLFNBQVMsaUJBQWlCLG1CQUFtQjtBQUNuRCxjQUFNLE1BQU0saUJBQWlCLFFBQVE7QUFDckMsY0FBTSxNQUFNLGlCQUFpQixRQUFRO0FBRXJDLGNBQU0sZUFBZTtBQUFBLHlCQUNGLGlCQUFpQixtQkFBbUIsZ0JBQWdCO0FBQUEsdUJBQ3RELGlCQUFpQixrQ0FBa0MsK0JBQStCO0FBQUEscUJBQ3BGLEdBQUc7QUFBQSxxQkFDSCxHQUFHO0FBQUE7QUFBQSxtQkFFTCxHQUFHO0FBQUEsbUJBQ0gsR0FBRztBQUFBO0FBQUE7QUFBQSxrQ0FHWSxPQUFPO0FBQUEsaUJBQ3hCLElBQUk7QUFBQTtBQUFBLGtDQUVhLE1BQU07QUFBQSxpQkFDdkIsSUFBSTtBQUFBO0FBQUE7QUFBQTtBQUFBLGtCQUlILEdBQUc7QUFBQSxRQUNiLGFBQWE7QUFBQSwwRUFDcUQsZ0JBQWdCO0FBRXBGLGNBQU0sVUFBVSxpQkFBaUI7QUFBQSwwQkFDYixnQkFBZ0I7QUFBQTtBQUFBLFVBRWhDLFlBQVk7QUFBQTtBQUFBLGVBRVAsSUFBSSxXQUNvQjtBQUFBLDBCQUNiLGdCQUFnQjtBQUFBO0FBQUEsVUFFaEMsWUFBWTtBQUFBO0FBQUEsZUFFUCxJQUFJO0FBRWIsY0FBTSxVQUFVO0FBQUEsMEJBQ0ksZ0JBQWdCO0FBQUEseUJBQ2pCLGlCQUFpQixtQkFBbUIsZ0JBQWdCO0FBQUE7QUFBQTtBQUFBLFlBSW5FLGlCQUFpQix3REFDQSxxREFBcUQ7QUFBQTtBQUFBO0FBQUEsVUFHdEUsWUFBWSxnQkFBZ0IsQ0FBQztBQUFBO0FBQUEsZUFFeEIsSUFBSTtBQUFBO0FBR2IsY0FBTSxFQUFDLG9CQUFvQixnQkFBZSxJQUFJLHFCQUFxQixZQUFZLElBQUk7QUFDbkYsY0FBTSxXQUFXO0FBQUEsUUFDZixrQkFBa0I7QUFBQSx1REFDNkIsSUFBSTtBQUFBLE1BQ3JELGlCQUFpQixVQUFVLE9BQU87QUFBQTtBQUFBO0FBQUEsdURBR2UsSUFBSTtBQUFBLE1BQ3JELGlCQUFpQixVQUFVLE9BQU87QUFBQTtBQUFBO0FBQUEsaUVBR3lCLElBQUk7QUFBQSx3QkFDN0MsZ0JBQWdCO0FBQUE7QUFBQTtBQUFBLHVCQUdqQixpQkFBaUIsa0NBQWtDLCtCQUErQjtBQUFBLFFBQ2pHLGVBQWU7QUFBQSxRQUNmLFlBQVksT0FBTyxDQUFDO0FBQUEsUUFDcEIsZUFBZTtBQUFBLDhFQUN1RCxnQkFBZ0I7QUFBQTtBQUFBO0FBR3hGLGVBQU87QUFBQSxNQUNUO0FBRUcsTUFBTSx5Q0FDVCxDQUFDLFFBQStCLFlBQXFDLGFBQ3BFLFdBQW1CLFdBQW1CLFVBQWtCLFNBQ3hELDhCQUFvRDtBQUNuRCxjQUFNLGlCQUFpQixXQUFXLFdBQVc7QUFDN0MsY0FBTSxhQUFhLGlCQUFpQixPQUFPLENBQUMsRUFBRSxLQUFLLENBQUMsSUFBSSxPQUFPLENBQUMsRUFBRSxLQUFLLENBQUM7QUFDeEUsY0FBTSxZQUFZLFlBQVksQ0FBQztBQUMvQixjQUFNLFdBQVcsaUJBQWlCLFlBQVksQ0FBQyxJQUFJLFlBQVksQ0FBQztBQUNoRSxjQUFNLFlBQVksaUJBQWlCLFlBQVksQ0FBQyxJQUFJLFlBQVksQ0FBQztBQUNqRSxjQUFNLGNBQWMsaUJBQWlCLFlBQVksQ0FBQyxJQUFJLFlBQVksQ0FBQztBQUNuRSxjQUFNLFNBQ0YsaUJBQWlCLGFBQWEsTUFBTSxLQUFLLGNBQWMsTUFBTSxJQUFJLFdBQVcsTUFBTSxLQUFLLGNBQWMsTUFBTTtBQUcvRyxjQUFNLFlBQVksaUJBQWlCLGNBQWMsV0FBVztBQUM1RCxjQUFNLFlBQVksaUJBQWlCLFdBQVcsWUFBWTtBQUMxRCxjQUFNLGdCQUEwQyxTQUM1QyxDQUFDLEdBQUcsR0FBRyxDQUFDLElBQ1IsQ0FBRSxhQUFhLEtBQUssYUFBYSxJQUFLLElBQUksSUFBSSxZQUFZLEtBQUssYUFBYSxJQUFJLElBQUksSUFBSSxDQUFDO0FBQzdGLGNBQU0sb0JBQ0YsU0FBUyxDQUFDLEdBQUcsR0FBRyxDQUFDLElBQUksQ0FBQyxhQUFhLElBQUksSUFBSSxHQUFHLFlBQVksS0FBSyxhQUFhLElBQUksSUFBSSxHQUFHLENBQUM7QUFDNUYsY0FBTSxXQUFXO0FBQUEsVUFDZixLQUFLLEtBQUssWUFBWSxjQUFjLENBQUMsSUFBSSxrQkFBa0IsQ0FBQyxDQUFDO0FBQUEsVUFDN0QsS0FBSyxLQUFLLFlBQVksY0FBYyxDQUFDLElBQUksa0JBQWtCLENBQUMsQ0FBQztBQUFBLFVBQzdELEtBQUssS0FBSyxZQUFZLGNBQWMsQ0FBQyxJQUFJLGtCQUFrQixDQUFDLENBQUM7QUFBQSxRQUMvRDtBQUVBLGtCQUFVLFdBQVcsTUFBTSx3Q0FBd0MsUUFBUSxFQUFFO0FBRTdFLGNBQU0sbUJBQW1CLFNBQVMsSUFBSTtBQUN0QyxjQUFNLFlBQVksS0FBSyxJQUFJLGNBQWMsQ0FBQyxJQUFJLGtCQUFrQixjQUFjLENBQUMsQ0FBQztBQUNoRixjQUFNLGFBQWEsU0FBUyxJQUFJO0FBQ2hDLGNBQU0sa0JBQ0YsQ0FBQyxFQUFDLE1BQU0sU0FBUyxNQUFNLFVBQVMsR0FBRyxFQUFDLE1BQU0sU0FBUyxNQUFNLFVBQVMsR0FBRyxFQUFDLE1BQU0sU0FBUyxNQUFNLFNBQVEsQ0FBQztBQUN4RyxjQUFNLElBQUksY0FBYyxLQUFLLE9BQU8sQ0FBQyxFQUFFLFVBQVUsT0FBTyxDQUFDLEVBQUUsS0FBSyxRQUFRLFVBQVU7QUFDbEYsY0FBTSxJQUFJLGNBQWMsS0FBSyxPQUFPLENBQUMsRUFBRSxVQUFVLE9BQU8sQ0FBQyxFQUFFLEtBQUssUUFBUSxDQUFDO0FBQ3pFLGNBQU0sU0FBUyxlQUFlLFVBQVUsT0FBTyxDQUFDLEVBQUUsVUFBVSxZQUFZLFFBQVEsVUFBVTtBQUMxRixjQUFNLGlCQUFpQixDQUFDLEdBQUcsQ0FBQztBQUM1Qix3QkFBZ0IsS0FBSyxHQUFHLDJCQUEyQixPQUFPLENBQUMsRUFBRSxJQUFJLENBQUM7QUFDbEUsd0JBQWdCLEtBQUssR0FBRywyQkFBMkIsT0FBTyxDQUFDLEVBQUUsSUFBSSxDQUFDO0FBRWxFLFlBQUksbUJBQW1CO0FBQ3ZCLFlBQUksU0FBUztBQUNYLGdCQUFNLE9BQU8sY0FBYyxRQUFRLE9BQU8sQ0FBQyxFQUFFLFVBQVUsT0FBTyxDQUFDLEVBQUUsS0FBSyxRQUFRLFVBQVU7QUFDeEYseUJBQWUsS0FBSyxJQUFJO0FBQ3hCLDBCQUFnQixLQUFLLEdBQUcsMkJBQTJCLE9BQU8sQ0FBQyxFQUFFLElBQUksQ0FBQztBQUVsRSw4QkFBb0I7QUFBQSwwREFDOEIsU0FBUyxjQUFjLEtBQUs7QUFBQSwrQkFDdkQsaUJBQWlCLE1BQU0sR0FBRyxHQUFHLFNBQVMsUUFBUSxFQUFFO0FBQUE7QUFBQSxRQUV6RTtBQUVBLHdCQUFnQixLQUFLLEdBQUcsMkJBQTJCLFdBQVcsQ0FBQztBQUUvRCxlQUFPO0FBQUEsVUFDTCxNQUFNO0FBQUEsVUFDTixhQUFhLEVBQUMsTUFBTSxXQUFXLFNBQVE7QUFBQSxVQUN2QyxZQUFZLE9BQU87QUFBQSxZQUNqQixTQUFTLENBQUMsRUFBQyxNQUFNLGFBQWEsVUFBVSxPQUFPLENBQUMsRUFBRSxTQUFRLENBQUM7QUFBQSxZQUMzRCxlQUFlLEVBQUMsR0FBRyxTQUFTLENBQUMsR0FBRyxHQUFHLFNBQVMsQ0FBQyxHQUFHLEdBQUcsU0FBUyxDQUFDLEVBQUM7QUFBQSxZQUM5RDtBQUFBLFVBQ0Y7QUFBQSxVQUNBLGlCQUFpQixDQUFDLGlCQUErQjtBQUFBLFVBQy9DLGNBQWMseUJBQXlCLENBQUM7QUFBQSxVQUV0QyxhQUFhLGdCQUFnQixhQUFhLEtBQUssRUFDMUMsZ0JBQWdCLGFBQWEsS0FBSyxFQUNsQyxnQkFBZ0IsWUFBWSxLQUFLLEVBQ2pDLGlCQUFpQixHQUFHLGdCQUFnQixNQUFNLENBQUM7QUFBQSxvREFDUixPQUFPLENBQUMsRUFBRSxLQUFLLEtBQUssR0FBRyxDQUFDO0FBQUEsbURBQ3pCLFdBQVcsWUFBWSxpQkFBaUIsSUFBSSxDQUFDLENBQUMsS0FDckYsV0FBVyxZQUFZLGlCQUFpQixJQUFJLENBQUMsQ0FBQztBQUFBO0FBQUEsZ0JBRzlDLFdBQVcsVUFBVSxDQUFDLEtBQUssSUFDdkIsS0FDQyxXQUFXLFlBQVksaUJBQWlCLElBQUksQ0FBQyxJQUFJLE1BQU0sV0FBVyxVQUFVLENBQUMsSUFBSSxFQUFFO0FBQUEsZ0JBRXhGLFdBQVcsVUFBVSxDQUFDLEtBQUssSUFDdkIsS0FDQyxXQUFXLFlBQVksaUJBQWlCLElBQUksQ0FBQyxJQUFJLE1BQU0sV0FBVyxVQUFVLENBQUMsSUFBSSxFQUFFO0FBQUEsZ0ZBRXhGLFdBQVcsS0FBSyxDQUFDLElBQUksV0FBVyxLQUFLLENBQUMsQ0FBQztBQUFBLDhFQUV2QyxXQUFXLEtBQUssQ0FBQyxJQUFJLFdBQVcsS0FBSyxDQUFDLENBQUM7QUFBQSxnREFDSCxXQUFXLFFBQVEsQ0FBQyxDQUFDLEtBQUssV0FBVyxRQUFRLENBQUMsQ0FBQztBQUFBLGlEQUM5QyxXQUFXLFVBQVUsQ0FBQyxDQUFDLEtBQUssV0FBVyxVQUFVLENBQUMsQ0FBQztBQUFBLGtDQUNsRSxTQUFTO0FBQUEsa0NBQ1QsU0FBUztBQUFBLGlDQUNWLFFBQVE7QUFBQSxVQUMvQixnQkFBZ0I7QUFBQSxVQUNoQiw2QkFBNkIsZ0JBQWdCLFNBQVMsWUFBWSxnQkFBZ0IsQ0FBQztBQUFBLFVBRWpGLFNBQVM7QUFBQSxZQUNJO0FBQUEsWUFBbUI7QUFBQSxZQUFlO0FBQUEsWUFBTztBQUFBLFlBQVcsQ0FBQztBQUFBLFlBQWdCO0FBQUEsVUFBUyxJQUNsRjtBQUFBLFlBQ0k7QUFBQSxZQUFtQjtBQUFBLFlBQWU7QUFBQSxZQUFPO0FBQUEsWUFBVyxDQUFDO0FBQUEsWUFBZ0I7QUFBQSxZQUFXO0FBQUEsWUFDaEY7QUFBQSxZQUFXO0FBQUEsVUFBeUIsQ0FBQztBQUFBLFFBQ3hEO0FBQUEsTUFDRjtBQUFBO0FBQUE7OztBQ2hRSixNQTBCTSw0Q0FzTk87QUFoUGI7QUFBQTtBQUFBO0FBbUJBO0FBRUE7QUFFQTtBQUdBLE1BQU0sNkNBQ0YsQ0FBQyxjQUE0QixRQUErQixZQUMzRCxhQUFnQyxTQUFrQixzQkFBK0IsU0FBUyxPQUMxRixhQUE2QjtBQUM1QixjQUFNLGlCQUFpQixXQUFXLFdBQVc7QUFDN0MsY0FBTSxTQUFTLGlCQUFpQixJQUFJO0FBQ3BDLGNBQU0sU0FBUyxpQkFBaUIsSUFBSTtBQUNwQyxjQUFNLGFBQWEsaUJBQWlCLElBQUk7QUFDeEMsY0FBTSxhQUFhLFVBQVUsS0FBSyxXQUFXO0FBQzdDLGNBQU0sZ0JBQWdCLFNBQVMsSUFBSTtBQUNuQyxjQUFNLFFBQVEsV0FBVztBQUN6QixjQUFNLFNBQVMsT0FBTyxDQUFDLEVBQUU7QUFDekIsY0FBTSx3QkFBd0IsT0FBTyxDQUFDLElBQUk7QUFDMUMsY0FBTSx5QkFBeUIsT0FBTyxDQUFDO0FBRXZDLFlBQUksbUJBQW1CO0FBQUEsaURBQ29CLFNBQVMsUUFBUSxRQUFRLE1BQU0sUUFBUTtBQUFBLDBCQUM5RCxTQUFTLFFBQVEsUUFBUSxNQUFNLFFBQVE7QUFBQTtBQUUzRCxZQUFJLFNBQVM7QUFDWCw4QkFBb0I7QUFBQSxzREFDMEIsU0FBUyxRQUFRLFFBQVEsTUFBTSxRQUFRO0FBQUEsMkJBQ2xFLGlCQUFpQixNQUFNLEdBQUcsR0FBRyxTQUFTLFFBQVEsRUFBRTtBQUFBO0FBQUEsUUFFckU7QUFDQSxjQUFNLGFBQWEsU0FBUyxJQUFJO0FBQ2hDLGNBQU0sSUFBSSxjQUFjLEtBQUssT0FBTyxDQUFDLEVBQUUsVUFBVSxPQUFPLENBQUMsRUFBRSxNQUFNLFVBQVU7QUFDM0UsY0FBTSxLQUFLLGNBQWMsTUFBTSxPQUFPLENBQUMsRUFBRSxVQUFVLE9BQU8sQ0FBQyxFQUFFLE1BQU0sVUFBVTtBQUM3RSxjQUFNLGlCQUFpQixDQUFDLElBQUksQ0FBQztBQUM3QixZQUFJLFNBQVM7QUFDWCx5QkFBZSxLQUFLLGNBQWMsUUFBUSxPQUFPLENBQUMsRUFBRSxVQUFVLENBQUMsWUFBWSxVQUFVLENBQUMsR0FBRyxVQUFVLENBQUM7QUFBQSxRQUN0RztBQUNBLGNBQU0sU0FBUyxlQUFlLFVBQVUsT0FBTyxDQUFDLEVBQUUsVUFBVSxhQUFhLFVBQVU7QUFDbkYsY0FBTSxlQUFlO0FBQUEsMkJBQ0EsdUJBQXVCLGdCQUFnQixnQkFBZ0I7QUFBQSxrQkFDaEUsdUJBQXVCLGdCQUFnQixnQkFBZ0I7QUFBQSxrQkFDdkQsdUJBQXVCLGdCQUFnQixnQkFBZ0IsTUFBTSxhQUFhO0FBQUEsd0JBQ3BFLHVCQUF1QixnQkFBZ0IsZ0JBQWdCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLGtDQU03QyxRQUFRLE1BQU0sYUFBYTtBQUFBLDhCQUMvQixhQUFhO0FBQUEsOEJBQ2IsUUFBUTtBQUFBO0FBQUE7QUFBQSx1QkFHZixRQUFRLGtCQUFrQixRQUFRLFdBQVcsUUFBUTtBQUFBO0FBQUEsb0NBRXhDLFFBQVE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSx5QkFPbkIsUUFBUSxrQkFBa0IsUUFBUSxXQUFXLFFBQVE7QUFBQSwwQkFDcEQsUUFBUSx3QkFBd0IsUUFBUSxXQUFXLFFBQVE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxzQ0FPL0MsUUFBUTtBQUFBO0FBQUE7QUFBQTtBQUFBLHdDQUlOLFFBQVE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxnQ0FVaEIsRUFBRSxJQUFJLGVBQWUsZUFBZSxNQUFNLElBQUksQ0FBQztBQUFBLGdDQUMvQyxFQUFFLElBQUksZUFBZSxlQUFlLFVBQVUsSUFBSSxDQUFDO0FBQUEsZ0NBQ25ELEVBQUUsSUFBSSxlQUFlLGVBQWUsVUFBVSxJQUFJLENBQUM7QUFBQSxnQ0FDbkQsRUFBRSxJQUFJLGVBQWUsZUFBZSxVQUFVLElBQUksQ0FBQztBQUFBO0FBQUEsK0JBRXBELEdBQUcsSUFBSSxTQUFTLFFBQVEsUUFBUSxJQUFJLENBQUM7QUFBQSxvQ0FDaEMsUUFBUTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSw0QkFNaEIsR0FBRyxJQUFJLFNBQVMsUUFBUSxTQUFTLElBQUksQ0FBQztBQUFBO0FBQUEsaURBRWpCLFFBQVE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsMkNBTWQsVUFBVTtBQUFBO0FBQUEsZ0NBRXJCLEVBQUUsSUFBSSxlQUFlLGVBQWUsTUFBTSxJQUFJLENBQUM7QUFBQSxnQ0FDL0MsRUFBRSxJQUFJLGVBQWUsZUFBZSxVQUFVLElBQUksQ0FBQztBQUFBLGdDQUNuRCxFQUFFLElBQUksZUFBZSxlQUFlLFVBQVUsSUFBSSxDQUFDO0FBQUEsZ0NBQ25ELEVBQUUsSUFBSSxlQUFlLGVBQWUsVUFBVSxJQUFJLENBQUM7QUFBQTtBQUFBLCtCQUVwRCxHQUFHLElBQUksU0FBUyxRQUFRLFFBQVEsSUFBSSxDQUFDO0FBQUEsb0NBQ2hDLFFBQVE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsZ0NBU1osRUFBRSxJQUFJLGVBQWUsZUFBZSxNQUFNLElBQUksQ0FBQztBQUFBLGdDQUMvQyxFQUFFLElBQUksZUFBZSxlQUFlLFVBQVUsSUFBSSxDQUFDO0FBQUEsZ0NBQ25ELEVBQUUsSUFBSSxlQUFlLGVBQWUsVUFBVSxJQUFJLENBQUM7QUFBQSxnQ0FDbkQsRUFBRSxJQUFJLGVBQWUsZUFBZSxVQUFVLElBQUksQ0FBQztBQUFBO0FBQUEsK0JBRXBELEdBQUcsSUFBSSxTQUFTLFFBQVEsU0FBUyxJQUFJLENBQUM7QUFBQSxvQ0FDakMsUUFBUTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLG1DQVVULGFBQWE7QUFBQSxxQ0FDWCxVQUFVLGNBQWMsUUFBUSxRQUFRLFFBQVE7QUFBQSxZQUN6RSxPQUFPLElBQUksU0FBUyxLQUFLLFNBQVMsTUFBTSxPQUFPLENBQUM7QUFBQTtBQUFBO0FBR3RELGNBQU0sY0FBYztBQUFBLGdDQUNNLE9BQU8sZ0JBQWdCLFlBQVksQ0FBQztBQUFBLHdCQUM1QyxPQUFPLFdBQVcsaUJBQWlCLENBQUMsQ0FBQztBQUFBLHFCQUN4QyxPQUFPLFdBQVcsaUJBQWlCLFVBQVUsQ0FBQztBQUFBLG9CQUMvQyxPQUFPLFdBQVcsaUJBQWlCLE1BQU0sQ0FBQztBQUFBLG9CQUMxQyxPQUFPLFdBQVcsaUJBQWlCLE1BQU0sQ0FBQztBQUFBO0FBQUE7QUFBQTtBQUFBLCtCQUkvQixzQkFBc0I7QUFBQSw2Q0FDUixzQkFBc0I7QUFBQTtBQUFBO0FBQUEsMEJBR3pDLFFBQVE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLHlCQUtULFFBQVEsaUJBQWlCLFFBQVEsV0FBVyxRQUFRO0FBQUE7QUFBQSxzQ0FFdkMsUUFBUSxnQkFBZ0IsTUFBTTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLDJCQVV6QyxRQUFRLGlCQUFpQixRQUFRLFdBQVcsUUFBUTtBQUFBO0FBQUEsd0NBRXZDLFFBQVEsZ0JBQWdCLE1BQU07QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLDZDQUt6QixxQkFBcUI7QUFBQSwyQ0FDdkIscUJBQXFCO0FBQUEsK0JBRXRELGlCQUFpQixHQUFHLElBQUksU0FBUyxRQUFRLFFBQVEsY0FBYyxJQUM5QyxHQUFHLElBQUksU0FBUyxnQkFBZ0IsUUFBUSxNQUFNLENBQUM7QUFBQSwrQkFDM0MsRUFBRSxJQUFJLGdCQUFnQixlQUFlLGVBQWUsYUFBYSxDQUFDO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLGtDQU0vRCxVQUFVLGFBQWEsR0FBRyxRQUFRLE9BQU87QUFBQSxZQUMvRCxPQUFPLFlBQVksY0FBYyxPQUFPLENBQUM7QUFBQTtBQUcvQyxlQUFPO0FBQUEsSUFDVCxhQUFhLGlCQUFpQixHQUFHLGdCQUFnQixNQUFNLENBQUM7QUFBQSxJQUN4RCxnQkFBZ0I7QUFBQSwyQ0FDdUIsWUFBWSxLQUFLLEdBQUcsQ0FBQztBQUFBLDhDQUNsQixPQUFPLENBQUMsRUFBRSxLQUFLLEtBQUssR0FBRyxDQUFDO0FBQUEsMENBQzVCLFdBQVcsUUFBUSxDQUFDLENBQUMsS0FBSyxXQUFXLFFBQVEsQ0FBQyxDQUFDO0FBQUEsNkNBQzVDLFdBQVcsWUFBWSxpQkFBaUIsSUFBSSxDQUFDLENBQUMsS0FDakYsV0FBVyxZQUFZLGlCQUFpQixJQUFJLENBQUMsQ0FBQztBQUFBLDRDQUNaLFdBQVcsVUFBVSxDQUFDLENBQUMsS0FBSyxXQUFXLFVBQVUsQ0FBQyxDQUFDO0FBQUE7QUFBQSxZQUdyRixXQUFXLFVBQVUsQ0FBQyxLQUFLLElBQ3ZCLEtBQ0MsV0FBVyxZQUFZLGlCQUFpQixJQUFJLENBQUMsSUFBSSxNQUFNLFdBQVcsVUFBVSxDQUFDLElBQUksRUFBRTtBQUFBLFlBRXhGLFdBQVcsVUFBVSxDQUFDLEtBQUssSUFDdkIsS0FDQyxXQUFXLFlBQVksaUJBQWlCLElBQUksQ0FBQyxJQUFJLE1BQU0sV0FBVyxVQUFVLENBQUMsSUFBSSxFQUFFO0FBQUEsMEVBQ3hCLFdBQVcsS0FBSyxDQUFDLElBQUksV0FBVyxLQUFLLENBQUMsQ0FBQztBQUFBLDBFQUN2QyxXQUFXLEtBQUssQ0FBQyxJQUFJLFdBQVcsS0FBSyxDQUFDLENBQUM7QUFBQSxNQUMzRyxhQUFhLFVBQVUsQ0FBQztBQUFBLE1BQ3hCLGFBQWEsc0NBQXNDLFVBQVUsQ0FBQztBQUFBLElBQ2hFLFNBQVMsZUFBZSxXQUFXO0FBQUEsTUFDbkM7QUFFRyxNQUFNLG1DQUNULENBQUMsUUFBK0IsWUFDL0IsK0JBQXFGO0FBQ3BGLGNBQU0sVUFBVSxPQUFPLFNBQVM7QUFFaEMsY0FBTSxjQUFjLFdBQVc7QUFDL0IsY0FBTSxhQUFhLFVBQVUsS0FBSyxXQUFXO0FBTTdDLGNBQU0sV0FBVztBQUFBLFVBQ2YsS0FBSyxLQUFLLGFBQWEsRUFBRTtBQUFBLFVBQ3pCO0FBQUEsVUFDQTtBQUFBLFFBQ0Y7QUFDQSxrQkFBVSxXQUFXLE1BQU0sdUNBQXVDLFFBQVEsRUFBRTtBQUU1RSxjQUFNLFdBQVcsNEJBQTRCLE9BQU8sQ0FBQyxFQUFFLFFBQVE7QUFDL0QsZUFBTztBQUFBLFVBQ0wsTUFBTTtBQUFBLFVBQ04sYUFBYSxFQUFDLE1BQU0sV0FBVyxTQUFRO0FBQUEsVUFDdkMsWUFBWSxPQUFPO0FBQUEsWUFDakIsZUFBZSxFQUFDLEdBQUcsU0FBUyxDQUFDLEdBQUcsR0FBRyxTQUFTLENBQUMsR0FBRyxHQUFHLFNBQVMsQ0FBQyxFQUFDO0FBQUEsWUFDOUQsU0FBUyxDQUFDO0FBQUEsY0FDUixNQUFNLDZCQUE2QiwyQkFBMkIsV0FBVyxJQUFJO0FBQUEsY0FDN0UsVUFBVSxPQUFPLENBQUMsRUFBRTtBQUFBLFlBQ3RCLENBQUM7QUFBQSxVQUNIO0FBQUEsVUFDQSxpQkFBaUIsQ0FBQyxpQkFBK0I7QUFBQSxZQUM3QztBQUFBLFlBQWM7QUFBQSxZQUFRO0FBQUEsWUFBWTtBQUFBLFlBQWE7QUFBQSxZQUFTLFNBQVMsQ0FBQyxNQUFNLEtBQUssU0FBUyxDQUFDLE1BQU07QUFBQSxZQUFHO0FBQUEsWUFDaEc7QUFBQSxVQUFRO0FBQUEsUUFDZDtBQUFBLE1BQ0Y7QUFBQTtBQUFBOzs7QUNsUkosTUFhTSxpQkFJQSxtQkFXQSw2QkFrQ0Esb0NBNENPLDhCQThCUEMsa0JBcUVBLHFCQUVBLGlCQXNEQSxpQkE2Q087QUFsVGI7QUFBQTtBQUFBO0FBSUE7QUFHQTtBQUNBO0FBRUE7QUFDQTtBQUVBLE1BQU0sa0JBQ0YsQ0FBQyxPQUFlLFFBQWdCLEtBQWEsUUFBZ0IsVUFBa0IsYUFDMUUsUUFBUSxLQUFLLFNBQVMsT0FBTyxTQUFTLEtBQUssV0FBVyxJQUFJO0FBRW5FLE1BQU0sb0JBQW9CLENBQUMsVUFBa0IsU0FBaUIsTUFBZ0IsTUFBYyxTQUFpQjtBQUMzRyxjQUFNLFdBQVcsS0FBSyxNQUFNLFdBQVcsQ0FBQztBQUN4QyxZQUFJLFlBQVksY0FBYztBQUM1QixlQUFLLElBQUksSUFBSTtBQUNiLGVBQUssSUFBSSxJQUFJLFdBQVc7QUFBQSxRQUMxQixXQUFXLFlBQVksY0FBYztBQUNuQyxlQUFLLElBQUksSUFBSSxXQUFXO0FBQ3hCLGVBQUssSUFBSSxJQUFJO0FBQUEsUUFDZjtBQUFBLE1BQ0Y7QUFFQSxNQUFNLDhCQUNGLENBQUMsWUFBK0IsYUFBZ0MsV0FBOEIsU0FDN0YsT0FBZSxNQUFnQixTQUE0QixlQUF3QixlQUNuRixnQkFBMEI7QUFDekIsY0FBTSxjQUFjLFdBQVcsU0FBUztBQUN4QyxjQUFNLG9CQUFvQixZQUFZLFdBQVc7QUFDakQsWUFBSSxjQUFjLFdBQVcsR0FBRztBQUM5QixtQkFBUyxJQUFJLEdBQUcsSUFBSSxhQUFhLEVBQUUsR0FBRztBQUNwQywwQkFBYyxLQUFLLENBQUM7QUFBQSxVQUN0QjtBQUFBLFFBQ0Y7QUFDQSxjQUFNLFlBQVksV0FBVyxDQUFDO0FBQzlCLGNBQU0sY0FBYyxZQUFZLGdCQUFnQixJQUFJLENBQUMsSUFBSTtBQUN6RCxpQkFBUyxJQUFJLEdBQUcsSUFBSSxXQUFXLFNBQVMsZUFBZSxnQkFBZ0IsSUFBSSxJQUFJLElBQUksYUFBYSxFQUFFLEdBQUcsRUFBRSxHQUFHO0FBQ3hHLGdCQUFNLFNBQVMsV0FBVyxDQUFDO0FBQzNCLGdCQUFNLFVBQVUsb0JBQW9CLFNBQVMsUUFBUSxDQUFDLElBQUksWUFBWSxDQUFDO0FBQ3ZFLGdCQUFNLFdBQVcsZ0JBQWdCLFFBQVEsUUFBUSxDQUFDLEdBQUcsS0FBSyxDQUFDLEdBQUcsWUFBWSxDQUFDLEdBQUcsVUFBVSxDQUFDLEdBQUcsT0FBTztBQUNuRyw0QkFBa0IsVUFBVSxTQUFTLE1BQU0sR0FBRyxJQUFJLFdBQVc7QUFDN0QsY0FBSSxtQkFBbUI7QUFDckIsd0JBQVk7QUFBQSxjQUNSLFFBQVEsQ0FBQyxLQUFLLFNBQVMsS0FBSyxjQUFjLENBQUMsS0FBSyxZQUFZLENBQUMsSUFBSSxLQUFLLFVBQVUsQ0FBQyxJQUFJLElBQUksS0FBSyxDQUFDLElBQy9GLEtBQUssSUFBSSxXQUFXO0FBQUEsWUFBQztBQUFBLFVBQzNCO0FBQUEsUUFDRjtBQUNBLG9CQUFZLE9BQU8sR0FBRyxHQUFHLFNBQVM7QUFDbEMsb0JBQVksT0FBTyxnQkFBZ0IsSUFBSSxHQUFHLEdBQUcsV0FBVztBQUFBLE1BQzFEO0FBUUosTUFBTSxxQ0FDRixDQUFvQyxZQUFlLFdBQXFDO0FBQ3RGLGNBQU0sY0FBYyxXQUFXLFlBQVksTUFBTTtBQUVqRCxZQUFJLFdBQVcsWUFBWSxXQUFXLEtBQUssV0FBVyxZQUFZLE9BQU8sQ0FBQyxHQUFHLE1BQU0sSUFBSSxHQUFHLENBQUMsTUFBTSxHQUFHO0FBQ2xHLHNCQUFZLFNBQVM7QUFDckIsbUJBQVMsSUFBSSxHQUFHLElBQUksT0FBTyxDQUFDLEVBQUUsS0FBSyxRQUFRLEVBQUUsR0FBRztBQUM5Qyx3QkFBWSxLQUFLLE9BQU8sQ0FBQyxFQUFFLEtBQUssQ0FBQyxDQUFDO0FBQUEsVUFDcEM7QUFBQSxRQUNGO0FBQ0EsY0FBTSxpQkFBaUIsV0FBVyxXQUFXO0FBQzdDLG9CQUFZLE9BQU8sR0FBRyxHQUFHLE9BQU8sQ0FBQyxFQUFFLEtBQUssQ0FBQyxDQUFDO0FBQzFDLG9CQUFZLE9BQU8saUJBQWlCLElBQUksR0FBRyxHQUFHLE9BQU8sQ0FBQyxFQUFFLEtBQUssQ0FBQyxDQUFDO0FBRS9ELGNBQU0sT0FBTyxXQUFXLEtBQUssTUFBTTtBQUNuQyxjQUFNLGNBQWMsV0FBVyxZQUFZLE1BQU07QUFDakQsY0FBTSxnQkFBZ0IsV0FBVyxjQUFjLE1BQU07QUFDckQsY0FBTSxhQUFhLE9BQU8sQ0FBQyxFQUFFO0FBQzdCLFlBQUksWUFBWSxXQUFXLFVBQVUsTUFBTTtBQUMzQyxZQUFJLFVBQVUsT0FBTyxDQUFDLEdBQUcsTUFBTSxJQUFJLEdBQUcsQ0FBQyxNQUFNLEdBQUc7QUFDOUMsZ0JBQU0sY0FBYyxPQUFPLENBQUMsRUFBRSxLQUFLLFNBQVM7QUFDNUMsc0JBQVksSUFBSSxNQUFNLFdBQVcsRUFBRSxLQUFLLENBQUM7QUFBQSxRQUMzQztBQUNBLFlBQUksVUFBVSxXQUFXLFFBQVEsTUFBTTtBQUN2QyxZQUFJLFFBQVEsT0FBTyxDQUFDLEdBQUcsTUFBTSxJQUFJLEdBQUcsQ0FBQyxNQUFNLEdBQUc7QUFDNUMsZ0JBQU0sY0FBYyxPQUFPLENBQUMsRUFBRSxLQUFLLFNBQVM7QUFDNUMsb0JBQVUsSUFBSSxNQUFNLFdBQVcsRUFBRSxLQUFLLENBQUM7QUFBQSxRQUN6QztBQUdBO0FBQUEsVUFDSTtBQUFBLFVBQVk7QUFBQSxVQUFhO0FBQUEsVUFBVyxXQUFXO0FBQUEsVUFBUyxXQUFXO0FBQUEsVUFBTztBQUFBLFVBQU07QUFBQSxVQUFTO0FBQUEsVUFDekY7QUFBQSxVQUFlO0FBQUEsUUFBVztBQUc5QixjQUFNLGdCQUFtQixPQUFPLE9BQU8sQ0FBQyxHQUFHLFVBQVU7QUFDckQsY0FBTSxXQUFXLFdBQVcsV0FBVztBQUFBLFVBQ3JDLFlBQVksS0FBSyxJQUFJO0FBQUEsVUFBRyxLQUFLLEtBQUssR0FBRztBQUFBLFVBQUcsUUFBUSxLQUFLLEdBQUc7QUFBQSxVQUFHLGNBQWMsS0FBSyxHQUFHO0FBQUEsVUFBRyxZQUFZLEtBQUssR0FBRztBQUFBLFVBQ3hHLFVBQVUsS0FBSyxHQUFHO0FBQUEsUUFDcEIsRUFBRSxLQUFLLEdBQUc7QUFDVixlQUFPLE9BQU8sZUFBZSxFQUFDLGFBQWEsTUFBTSxlQUFlLGFBQWEsV0FBVyxTQUFTLFNBQVEsQ0FBQztBQUMxRyxlQUFPO0FBQUEsTUFDVDtBQUVHLE1BQU0sK0JBQStCLENBQUMsZUFBaUU7QUFDNUcsY0FBTSx1QkFBdUIsa0NBQWtDLFVBQVU7QUFFekUsY0FBTSxTQUFTLFdBQVc7QUFDMUIsY0FBTSxVQUNGO0FBQUEsVUFBQztBQUFBLFVBQVU7QUFBQSxVQUFTO0FBQUEsVUFDbkI7QUFBQSxRQUFZLEVBQUUsT0FBTyxXQUFXLFdBQVcsY0FBYyxJQUFJLFdBQVcsT0FBaUI7QUFDOUYsY0FBTSxZQUFZLFdBQVc7QUFDN0IsY0FBTSxRQUFRLFdBQVc7QUFDekIsY0FBTSxjQUFjLFdBQVc7QUFDL0IsY0FBTSxPQUFPLFdBQVc7QUFDeEIsY0FBTSxVQUFVLFdBQVc7QUFDM0IsY0FBTSxXQUFZLFdBQVcsU0FBMkI7QUFDeEQsY0FBTSxnQkFBZ0IsV0FBVztBQUNqQyxjQUFNLGNBQWMsV0FBVztBQUMvQixlQUFPLDRCQUE0QjtBQUFBLFVBQ2pDO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQSxHQUFHO0FBQUEsUUFDTCxDQUFDO0FBQUEsTUFDSDtBQUVBLE1BQU1BLG1CQUFpQixDQUFDLFFBQStCLGVBQThDO0FBR25HLFlBQUksQ0FBQyxVQUFXLE9BQU8sV0FBVyxLQUFLLE9BQU8sV0FBVyxHQUFJO0FBQzNELGdCQUFNLElBQUksTUFBTSw2QkFBNkI7QUFBQSxRQUMvQztBQUdBLFlBQUksT0FBTyxDQUFDLEVBQUUsS0FBSyxXQUFXLEtBQUssT0FBTyxDQUFDLEVBQUUsS0FBSyxXQUFXLEdBQUc7QUFDOUQsZ0JBQU0sSUFBSSxNQUFNLDJDQUEyQztBQUFBLFFBQzdEO0FBRUEsWUFBSSxPQUFPLENBQUMsRUFBRSxLQUFLLFdBQVcsT0FBTyxDQUFDLEVBQUUsS0FBSyxRQUFRO0FBQ25ELGdCQUFNLElBQUksTUFBTSw4Q0FBOEM7QUFBQSxRQUNoRTtBQUdBLGNBQU0sY0FBYyxPQUFPLENBQUMsRUFBRSxLQUFLLFdBQVcsV0FBVyxTQUFTLE9BQU8sQ0FBQyxFQUFFLEtBQUssU0FBUyxJQUFJLENBQUM7QUFDL0YsY0FBTSxrQkFBa0IsT0FBTyxDQUFDLEVBQUUsS0FBSyxDQUFDO0FBQ3hDLFlBQUksZ0JBQWdCLGlCQUFpQjtBQUNuQyxnQkFBTSxJQUFJLE1BQU0sbURBQW1EO0FBQUEsUUFDckU7QUFFQSxjQUFNLGNBQWMsT0FBTyxDQUFDLEVBQUUsS0FBSyxDQUFDLElBQUksV0FBVztBQUduRCxZQUFJLE9BQU8sV0FBVyxNQUFNLE9BQU8sQ0FBQyxFQUFFLEtBQUssV0FBVyxLQUFLLE9BQU8sQ0FBQyxFQUFFLEtBQUssQ0FBQyxNQUFNLGNBQWM7QUFDN0YsZ0JBQU0sSUFBSSxNQUFNLGNBQWM7QUFBQSxRQUNoQztBQUVBLGNBQU0sY0FBYyxPQUFPLENBQUMsRUFBRSxLQUFLLFNBQVM7QUFDNUMsY0FBTSxlQUFlLFdBQVcsVUFBVSxPQUFPLENBQUMsR0FBRyxNQUFNLElBQUksR0FBRyxDQUFDLElBQUk7QUFFdkUsWUFBSSxnQkFBZ0IsV0FBVyxVQUFVLFdBQVcsYUFBYTtBQUMvRCxnQkFBTSxJQUFJLE1BQU0sdUJBQXVCLFdBQVcsR0FBRztBQUFBLFFBQ3ZEO0FBRUEsY0FBTSxhQUFhLFdBQVcsUUFBUSxPQUFPLENBQUMsR0FBRyxNQUFNLElBQUksR0FBRyxDQUFDLElBQUk7QUFFbkUsWUFBSSxjQUFjLFdBQVcsUUFBUSxXQUFXLGFBQWE7QUFDM0QsZ0JBQU0sSUFBSSxNQUFNLHFCQUFxQixXQUFXLEdBQUc7QUFBQSxRQUNyRDtBQUdBLGNBQU0sVUFBVSxXQUFXLEtBQUssT0FBTyxDQUFDLEdBQUcsTUFBTSxJQUFJLEdBQUcsQ0FBQyxJQUFJO0FBQzdELFlBQUksV0FBVyxXQUFXLEtBQUssV0FBVyxjQUFjLEdBQUc7QUFDekQsZ0JBQU0sSUFBSSxNQUFNLGtCQUFrQixjQUFjLENBQUMsR0FBRztBQUFBLFFBQ3REO0FBR0EsWUFBSSxXQUFXLGNBQWMsV0FBVyxlQUFlLFdBQVcsY0FBYyxXQUFXLEdBQUc7QUFDNUYsZ0JBQU0sSUFBSSxNQUFNLDRCQUE0QixXQUFXLEdBQUc7QUFBQSxRQUM1RDtBQUlBLGNBQU0saUJBQWlCLFdBQVcsWUFBWSxPQUFPLENBQUMsR0FBRyxNQUFNLElBQUksR0FBRyxDQUFDLElBQUk7QUFDM0UsWUFBSSxrQkFBa0IsV0FBVyxZQUFZLFdBQVcsS0FDcEQsV0FBVyxZQUFZLFdBQVcsT0FBTyxDQUFDLEVBQUUsS0FBSyxTQUFTLEdBQUc7QUFDL0QsZ0JBQU0sSUFBSSxNQUFNLHNCQUFzQjtBQUFBLFFBQ3hDO0FBR0EsWUFBSSxXQUFXLFlBQVksV0FBVyxLQUFLLFdBQVcsWUFBWSxXQUFXLE9BQU8sQ0FBQyxFQUFFLEtBQUssU0FBUyxHQUFHO0FBQ3RHLGdCQUFNLElBQUksTUFBTSxzQkFBc0I7QUFBQSxRQUN4QztBQUFBLE1BQ0Y7QUFHQSxNQUFNLHNCQUFzQixDQUFDLEdBQUcsR0FBRyxHQUFHLENBQUM7QUFFdkMsTUFBTSxrQkFDRixDQUFDLFNBQXlCLFFBQStCLGVBQThDO0FBQ3JHLGNBQU0scUJBQXFCLG1DQUFtQyxZQUFZLE1BQU07QUFDaEYsY0FBTSxpQkFBaUIsV0FBVyxXQUFXO0FBQzdDLGNBQU0sY0FBYyxtQkFBbUI7QUFDdkMsY0FBTSxjQUFjLFlBQVksaUJBQWlCLElBQUksQ0FBQztBQUN0RCxjQUFNLGdCQUFnQixPQUFPLENBQUMsRUFBRSxLQUFLLGlCQUFpQixJQUFJLENBQUM7QUFJM0QsWUFBSSxtQkFBbUIsVUFBVSxLQUFNLGdCQUFnQixLQUFLLGtCQUFrQixHQUFJO0FBQ2hGLGtCQUFRLFFBQVEsaUNBQWlDLFFBQVEsa0JBQWtCLENBQUM7QUFDNUU7QUFBQSxRQUNGO0FBQ0EsY0FBTSxZQUFZLFlBQVksaUJBQWlCLElBQUksQ0FBQztBQUNwRCxjQUFNLFdBQVcsWUFBWSxpQkFBaUIsSUFBSSxDQUFDO0FBQ25ELGNBQU0sZUFBZSxPQUFPLENBQUMsRUFBRSxLQUFLLENBQUM7QUFDckMsY0FBTSxjQUFjLE9BQU8sQ0FBQyxFQUFFLEtBQUssQ0FBQztBQUVwQyxjQUFNLFlBQVksaUJBQWlCLFlBQVksV0FBVztBQUMxRCxjQUFNLFlBQVksaUJBQWlCLGNBQWMsWUFBWTtBQUM3RCxjQUFNLFdBQVcsZUFBZSxjQUFjO0FBRTlDLGNBQU07QUFBQTtBQUFBLFVBQWdFO0FBQUE7QUFJdEUsY0FBTSxtQkFBb0IsUUFBUSxpQkFBaUIsTUFDL0MsUUFBUTtBQUFBLFVBQ0osMkJBQTJCLE9BQU8sQ0FBQyxHQUFHLG1CQUFtQjtBQUFBLFVBQ3pELEVBQUMsUUFBUSxDQUFDLENBQUMsR0FBRyxTQUFTLENBQUMsV0FBVyxXQUFXLEtBQUssRUFBRSxFQUFDO0FBQUEsUUFBQyxFQUFFLENBQUM7QUFDbEUsWUFBSSxXQUFXLFlBQVksQ0FBQyxRQUFRLGlCQUFpQixJQUFJO0FBQ3ZELGtCQUFRLGlCQUFpQixLQUFLO0FBQUEsUUFDaEM7QUFHQSxjQUFNLHNCQUFzQixDQUFDLE9BQU8sQ0FBQyxHQUFHLGdCQUFnQjtBQUN4RCxjQUFNLFVBQVUsT0FBTyxXQUFXO0FBQ2xDLFlBQUksU0FBUztBQUNYLGNBQUksQ0FBQyxrQkFBa0IsT0FBTyxDQUFDLEVBQUUsS0FBSyxXQUFXLEdBQUc7QUFDbEQsZ0NBQW9CLEtBQUssT0FBTyxDQUFDLEVBQUUsUUFBUSxDQUFDLE9BQU8sQ0FBQyxFQUFFLEtBQUssQ0FBQyxHQUFHLEdBQUcsQ0FBQyxDQUFDLENBQUM7QUFBQSxVQUN2RSxPQUFPO0FBQ0wsZ0NBQW9CLEtBQUssT0FBTyxDQUFDLENBQUM7QUFBQSxVQUNwQztBQUFBLFFBQ0Y7QUFHQSxnQkFBUTtBQUFBLFVBQ0o7QUFBQSxZQUNJO0FBQUEsWUFBcUI7QUFBQSxZQUFvQjtBQUFBLFlBQWE7QUFBQSxZQUFXO0FBQUEsWUFBVztBQUFBLFlBQVU7QUFBQSxZQUN0RjtBQUFBLFVBQXlCO0FBQUEsVUFDN0IsRUFBQyxRQUFRLG9CQUFtQjtBQUFBLFFBQUM7QUFBQSxNQUNuQztBQUVKLE1BQU0sa0JBQWtCLENBQUMsU0FBeUIsZUFBOEM7QUFFOUYsY0FBTSxnQkFBZ0IsV0FBVyxXQUFXO0FBRTVDLGNBQU0sU0FBUztBQUFBLFVBQ2IsUUFBUSxPQUFPLENBQUMsRUFBRTtBQUFBLFlBQ2Q7QUFBQTtBQUFBLGNBRUksQ0FBQyxRQUFRLE9BQU8sQ0FBQyxFQUFFLEtBQUssQ0FBQyxHQUFHLEdBQUcsUUFBUSxPQUFPLENBQUMsRUFBRSxLQUFLLENBQUMsR0FBRyxRQUFRLE9BQU8sQ0FBQyxFQUFFLEtBQUssQ0FBQyxDQUFDO0FBQUE7QUFBQTtBQUFBLGNBRW5GLENBQUMsUUFBUSxPQUFPLENBQUMsRUFBRSxLQUFLLENBQUMsR0FBRyxRQUFRLE9BQU8sQ0FBQyxFQUFFLEtBQUssQ0FBQyxHQUFHLEdBQUcsUUFBUSxPQUFPLENBQUMsRUFBRSxLQUFLLENBQUMsQ0FBQztBQUFBO0FBQUEsVUFBQztBQUFBO0FBQUEsVUFFNUYsUUFBUSxPQUFPLENBQUMsRUFBRSxRQUFRLENBQUMsUUFBUSxPQUFPLENBQUMsRUFBRSxLQUFLLENBQUMsR0FBRyxRQUFRLE9BQU8sQ0FBQyxFQUFFLEtBQUssQ0FBQyxHQUFHLEdBQUcsUUFBUSxPQUFPLENBQUMsRUFBRSxLQUFLLENBQUMsQ0FBQyxDQUFDO0FBQUEsUUFDaEg7QUFDQSxZQUFJLE9BQU8sV0FBVyxHQUFHO0FBQ3ZCLGlCQUFPLEtBQUssUUFBUSxPQUFPLENBQUMsQ0FBQztBQUFBLFFBQy9CO0FBQ0EsWUFBSSxjQUFjLFdBQVc7QUFDN0IsWUFBSSxZQUFZLFdBQVcsS0FBSyxZQUFZLENBQUMsTUFBTSxHQUFHO0FBQ3BELHdCQUFjLENBQUMsUUFBUSxPQUFPLENBQUMsRUFBRSxLQUFLLENBQUMsQ0FBQztBQUFBLFFBQzFDO0FBQ0EsWUFBSSxZQUFZLFdBQVc7QUFDM0IsWUFBSSxVQUFVLFdBQVcsS0FBSyxVQUFVLENBQUMsTUFBTSxHQUFHO0FBQ2hELHNCQUFZLENBQUMsQ0FBQztBQUFBLFFBQ2hCO0FBQ0EsWUFBSSxVQUFVLFdBQVc7QUFDekIsWUFBSSxRQUFRLFdBQVcsS0FBSyxRQUFRLENBQUMsTUFBTSxHQUFHO0FBQzVDLG9CQUFVLENBQUMsQ0FBQztBQUFBLFFBQ2Q7QUFDQSxZQUFJLE9BQU8sV0FBVztBQUN0QixZQUFJLEtBQUssV0FBVyxHQUFHO0FBQ3JCLGlCQUFPLENBQUMsR0FBRyxDQUFDO0FBQUEsUUFDZDtBQUNBLGVBQU8sQ0FBQyxHQUFHLEtBQUssQ0FBQyxHQUFHLEdBQUcsS0FBSyxDQUFDLENBQUM7QUFDOUIsa0JBQVUsQ0FBQyxDQUFDLEVBQUUsT0FBTyxPQUFPO0FBQzVCLG9CQUFZLENBQUMsQ0FBQyxFQUFFLE9BQU8sU0FBUztBQUNoQyxzQkFBYyxDQUFDLENBQUMsRUFBRSxPQUFPLFdBQVc7QUFDcEMsY0FBTSxxQkFDRixtQ0FBbUMsRUFBQyxHQUFHLFlBQVksTUFBTSxTQUFTLFdBQVcsWUFBVyxHQUFHLE1BQU07QUFDckcsZ0JBQVEsUUFBUTtBQUFBLFVBQ1o7QUFBQSxVQUFRO0FBQUEsVUFDUixpQkFBZSxnQkFBZ0IsQ0FBQyxZQUFZLENBQUMsR0FBRyxZQUFZLENBQUMsR0FBRyxZQUFZLENBQUMsQ0FBQyxJQUMvQyxDQUFDLFlBQVksQ0FBQyxHQUFHLFlBQVksQ0FBQyxHQUFHLFlBQVksQ0FBQyxDQUFDO0FBQUEsUUFBQyxDQUFDO0FBQUEsTUFDdEY7QUFFTyxNQUFNLGdCQUFnQixDQUFDLFNBQXlCLGVBQThDO0FBQ25HLFFBQUFBLGlCQUFlLFFBQVEsUUFBUSxVQUFVO0FBQ3pDLFlBQUksUUFBUSxPQUFPLENBQUMsRUFBRSxLQUFLLFdBQVcsR0FBRztBQUN2QywwQkFBZ0IsU0FBUyxVQUFVO0FBQUEsUUFDckMsT0FBTztBQUNMLDBCQUFnQixTQUFTLFFBQVEsUUFBUSxVQUFVO0FBQUEsUUFDckQ7QUFBQSxNQUNGO0FBQUE7QUFBQTs7O0FDelRBLE1BZ0JNLHlCQWtETyxRQU9BO0FBekViO0FBQUE7QUFBQTtBQUdBO0FBRUE7QUFDQTtBQUdBO0FBT0EsTUFBTSwwQkFDRixDQUFDLFdBQW1CLFlBQStCLFdBQXVCLGVBQ3ZEO0FBQ2IsY0FBTSxhQUFhLFVBQVUsS0FBSyxVQUFVO0FBQzVDLGNBQU0sT0FBTyxXQUFXO0FBQ3hCLGNBQU0sUUFBUSxjQUFjLFNBQVMsV0FBVyxJQUFJO0FBQ3BELGNBQU0sU0FBUyxlQUFlLFVBQVUsV0FBVyxJQUFJO0FBQ3ZELGNBQU0sWUFBWSxVQUFVLDZCQUE4QixVQUFVLGNBQWMsRUFBRSxDQUFDLElBQzNCLE9BQU8sVUFBVSxpQkFBaUIsRUFBRSxDQUFDLENBQUM7QUFDaEcsY0FBTSxPQUFPLFVBQVUsY0FBYyxXQUFXLElBQUk7QUFDcEQsY0FBTSxrQkFBa0IsQ0FBQyxpQkFBK0I7QUFDdEQsZ0JBQU0sUUFBUSxRQUFRLE1BQU0sV0FBVyxnQkFBZ0IsZUFBZSxDQUFDO0FBQ3ZFLGdCQUFNLE1BQU0sYUFBYSx3QkFBd0IsaUJBQWlCLElBQUk7QUFDdEUsZ0JBQU0sYUFBYSxXQUFXLFVBQVUsU0FBUyxXQUFXLFlBQVksU0FBUyxNQUFNO0FBQ3ZGLGdCQUFNLGFBQWEsV0FBVyxVQUFVLE1BQU0sU0FBUyxXQUFXLFlBQVksS0FBSztBQUNuRixpQkFBTztBQUFBLGtCQUVILGFBQWEsZ0JBQWdCLGNBQWMsS0FBSyxFQUMzQyxnQkFBZ0IsUUFBUSxLQUFLLEVBQzdCLGlCQUFpQixPQUFPLE1BQU0sQ0FBQztBQUFBLGtCQUNsQyxhQUFhLFVBQVUsQ0FBQztBQUFBLG9CQUN0QixhQUFhLHNDQUFzQyxxQkFBcUIsQ0FBQztBQUFBLHVDQUN0RCxPQUFPLGdCQUFnQixZQUFZLENBQUM7QUFBQSw4QkFDN0MsT0FBTyxLQUFLLEtBQUs7QUFBQSxzQ0FDVCxVQUFVO0FBQUEscUNBQ1gsVUFBVTtBQUFBO0FBQUEsc0JBRXpCLE1BQU0sV0FBVyxnQkFBZ0IsaUJBQWlCLFFBQVEsQ0FBQztBQUFBLGtDQUMvQyxNQUFNLGFBQWEsY0FBYyxDQUFDO0FBQUE7QUFBQSxvQkFFaEQsT0FBTyxZQUFZLGNBQWMsS0FBSyxDQUFDO0FBQUE7QUFBQSxRQUVqRDtBQUNBLGVBQU87QUFBQSxVQUNMLE1BQU07QUFBQSxVQUNOLGFBQWEsRUFBQyxNQUFNLFdBQVcsVUFBVSxtQkFBbUIsQ0FBQyxNQUFNLEVBQUM7QUFBQSxVQUNwRSxZQUFZLE9BQU87QUFBQSxZQUNqQixTQUFTLENBQUMsRUFBQyxNQUFNLFlBQVksVUFBVSxVQUFTLENBQUM7QUFBQSxZQUNqRCxlQUFlLEVBQUMsR0FBRyxLQUFLO0FBQUEsY0FBSyxhQUFhO0FBQUE7QUFBQSxZQUF1QixFQUFDO0FBQUEsWUFDbEUsaUJBQWlCO0FBQUEsY0FDZixFQUFDLE1BQU0sVUFBVSxNQUFNLFdBQVU7QUFBQSxjQUFHLEVBQUMsTUFBTSxTQUFTLE1BQU0sS0FBSTtBQUFBLGNBQzlELEdBQUcsMkJBQTJCLFVBQVU7QUFBQSxjQUFHLEdBQUcsMkJBQTJCLFVBQVU7QUFBQSxZQUNyRjtBQUFBLFVBRUY7QUFBQSxVQUNBO0FBQUEsUUFDRjtBQUFBLE1BQ0Y7QUFHRCxNQUFNLFNBQVMsQ0FBQyxTQUF5QixlQUF1QztBQUNyRixjQUFNLGFBQWEsUUFBUSxPQUFPLENBQUMsRUFBRTtBQUNyQyxjQUFNLFlBQVksUUFBUSxPQUFPLENBQUMsRUFBRTtBQUNwQyxjQUFNLE9BQU8sUUFBUSxPQUFPLENBQUM7QUFDN0IsZ0JBQVEsUUFBUSx3QkFBd0IsV0FBVyxZQUFZLE1BQU0sVUFBVSxHQUFHLEVBQUMsUUFBUSxDQUFDLENBQUMsRUFBQyxDQUFDO0FBQUEsTUFDakc7QUFFTyxNQUFNLHdCQUF3QixDQUFDLGVBQTBEO0FBQzlGLGNBQU0sWUFBWSxXQUFXLGNBQXdCO0FBQ3JELGNBQU0sVUFBVSxXQUFXLFlBQXNCO0FBQ2pELGVBQU8sNEJBQTRCLEVBQUMsV0FBVyxRQUFPLENBQUM7QUFBQSxNQUN6RDtBQUFBO0FBQUE7OztBQzdFQSxNQXNCTSxlQUVBLGFBQ0EsaUJBQ0EsWUFDQSxnQkFRQSxZQXFCQSxnQkE0SEEsV0FFQSx5QkFxSE8sUUFTQTtBQXBUYjtBQUFBO0FBQUE7QUFJQTtBQUNBO0FBR0E7QUFjQSxNQUFNLGdCQUNGO0FBQ0osTUFBTSxjQUFjLE1BQU0sZ0JBQWdCO0FBQzFDLE1BQU0sa0JBQWtCLE1BQU0sY0FBYztBQUM1QyxNQUFNLGFBQWEsTUFBTSxjQUFjLFFBQVE7QUFDL0MsTUFBTSxpQkFBaUIsTUFBTSxhQUFhO0FBUTFDLE1BQU0sYUFBTixNQUFpQjtBQUFBLFFBQ2YsWUFBWSxhQUFhLElBQUk7QUFDM0IsZUFBSyxrQkFBa0Isb0JBQUksSUFBc0I7QUFDakQsZUFBSyxhQUFhO0FBQUEsUUFDcEI7QUFBQTtBQUFBLFFBR0EsVUFBVSxRQUFnQixPQUFlO0FBQ3ZDLGNBQUksUUFBUSxLQUFLLGdCQUFnQixJQUFJLE1BQU07QUFDM0MsY0FBSSxVQUFVLFFBQVc7QUFDdkIsb0JBQVEsQ0FBQyxLQUFLO0FBQUEsVUFDaEIsT0FBTztBQUNMLGtCQUFNLEtBQUssS0FBSztBQUFBLFVBQ2xCO0FBQ0EsZUFBSyxnQkFBZ0IsSUFBSSxRQUFRLEtBQUs7QUFBQSxRQUN4QztBQUFBO0FBQUEsTUFJRjtBQUVBLE1BQU0saUJBQU4sTUFBcUI7QUFBQSxRQUNuQixZQUFZLFFBQStDLFVBQWtCO0FBQWxCO0FBQ3pELGVBQUssY0FBYztBQUNuQixlQUFLLGVBQWUsb0JBQUksSUFBd0I7QUFDaEQsZUFBSyxNQUFNLElBQUksTUFBa0I7QUFDakMsZUFBSyxhQUFhLENBQUM7QUFHbkIsY0FBSSxDQUFDLEtBQUssR0FBRyxJQUFJLFNBQVMsU0FBUyxJQUFJLElBQUksU0FBUyxNQUFNLE1BQU0sQ0FBQyxJQUFJLENBQUMsVUFBVSxFQUFFO0FBQ2xGLGNBQUksQ0FBQyxJQUFJLE1BQU0sT0FBTyxjQUFjLENBQUMsR0FBRztBQUN0QyxrQkFBTSxJQUFJLE1BQU0sa0JBQWtCO0FBQUEsVUFDcEM7QUFDQSxnQkFBTSxhQUFhLElBQUksTUFBTSxHQUFHO0FBQ2hDLHFCQUFXLFFBQVEsQ0FBQyxXQUFXLFVBQVU7QUFDdkMsa0JBQU0sT0FBTyxPQUFPLEtBQUssRUFBRSxLQUFLLE1BQU07QUFDdEMsZ0JBQUksQ0FBQyxVQUFVLE1BQU0sT0FBTyxlQUFlLENBQUMsR0FBRztBQUM3QyxvQkFBTSxJQUFJLE1BQU0sa0JBQWtCO0FBQUEsWUFDcEM7QUFDQSxrQkFBTSxhQUFhLEtBQUssWUFBWSxXQUFXLE1BQU0sTUFBTSxLQUFLO0FBQ2hFLGlCQUFLLElBQUksS0FBSyxVQUFVO0FBQUEsVUFDMUIsQ0FBQztBQUdELGNBQUksUUFBUSxJQUFJO0FBRWQsbUJBQU8sQ0FBQyxHQUFHLEtBQUssYUFBYSxRQUFRLENBQUMsRUFDMUIsT0FBTyxDQUFDLENBQUMsS0FBSyxJQUFJLE1BQU8sS0FBSyxVQUFVLEtBQUssUUFBUSxLQUFNLEVBQzNELElBQUksQ0FBQyxDQUFDLEdBQUcsTUFBTSxHQUFHLEVBQ2xCLEtBQUssRUFBRTtBQUFBLFVBQ3JCLE9BQU87QUFDTCxnQkFBSSxDQUFDLElBQUksTUFBTSxPQUFPLFdBQVcsQ0FBQyxHQUFHO0FBQ25DLG9CQUFNLElBQUksTUFBTSxhQUFhO0FBQUEsWUFDL0I7QUFBQSxVQUNGO0FBR0EsZ0JBQU0sYUFBYSxJQUFJLE1BQU0sT0FBTyxlQUFlLEdBQUcsQ0FBQztBQUN2RCxzQkFBWSxRQUFRLENBQUMsV0FBVztBQUM5QixnQkFBSSxXQUFXLE9BQU87QUFDcEIsbUJBQUssYUFBYSxLQUFLLFdBQVcsT0FBTyxLQUFLLFlBQVk7QUFBQSxZQUM1RCxPQUFPO0FBQ0wsb0JBQU0sT0FBTyxLQUFLLGFBQWEsSUFBSSxNQUFNO0FBQ3pDLGtCQUFJLFNBQVMsUUFBVztBQUN0QixzQkFBTSxJQUFJLE1BQU0sb0JBQW9CO0FBQUEsY0FDdEM7QUFDQSxtQkFBSyxXQUFXLEtBQUssS0FBSyxRQUFRO0FBQUEsWUFDcEM7QUFBQSxVQUNGLENBQUM7QUFDRCxlQUFLLE1BQU0sS0FBSyxZQUFZLEtBQUssT0FBTyxLQUFLLFVBQVU7QUFBQSxRQUN6RDtBQUFBO0FBQUE7QUFBQSxRQUdBLFVBQVUsUUFBZ0IsVUFBa0IsWUFBb0I7QUFDOUQsY0FBSSxPQUFPLEtBQUssYUFBYSxJQUFJLE1BQU07QUFDdkMsY0FBSSxTQUFTLFFBQVc7QUFDdEIsZ0JBQUksS0FBSyxhQUFhLFlBQVksS0FBSyxVQUFVLEdBQUc7QUFDbEQsb0JBQU0sSUFBSSxNQUFNLG9CQUFvQjtBQUFBLFlBQ3RDLE9BQU87QUFDTCxtQkFBSztBQUNMLG1CQUFLLGFBQWEsS0FBSyxVQUFVO0FBQUEsWUFDbkM7QUFBQSxVQUNGLE9BQU87QUFDTCxtQkFBTyxFQUFDLE9BQU8sR0FBRyxVQUFVLGNBQWMsQ0FBQyxVQUFVLEVBQUM7QUFBQSxVQUN4RDtBQUNBLGVBQUssYUFBYSxJQUFJLFFBQVEsSUFBSTtBQUFBLFFBQ3BDO0FBQUE7QUFBQSxRQUdBLFlBQVksTUFBYyxTQUFrQixNQUF5QixRQUFRLElBQWdCO0FBQzNGLGdCQUFNLE9BQU8sS0FBSztBQUNsQixjQUFJLFdBQVc7QUFDZixjQUFJLGVBQWUsQ0FBQztBQUNwQixjQUFJLFVBQVU7QUFFZCxjQUFJLENBQUMsS0FBSyxNQUFNLE9BQU8sZUFBZSxDQUFDLE1BQU0sQ0FBQyxXQUFXLFNBQVMsS0FBSztBQUNyRSxrQkFBTSxJQUFJLE1BQU0sa0JBQWtCO0FBQUEsVUFDcEM7QUFDQSxnQkFBTSxlQUFlLEtBQUssTUFBTSxPQUFPLGVBQWUsR0FBRyxDQUFDO0FBQzFELGdCQUFNLGFBQWEsSUFBSSxXQUFXLEtBQUs7QUFFdkMsd0JBQWMsUUFBUSxDQUFDLFFBQWdCLE1BQWM7QUFDbkQsZ0JBQUksV0FBVyxPQUFPO0FBQ3BCLGtCQUFJLFVBQVU7QUFDWixzQkFBTSxJQUFJLE1BQU0sNkNBQTZDO0FBQUEsY0FDL0Q7QUFDQSx5QkFBVztBQUNYLG9CQUFNLG9CQUFvQixPQUFPLGFBQWEsU0FBUztBQUN2RCxrQkFBSSxvQkFBb0IsR0FBRztBQUN6QixzQkFBTSxJQUFJLE1BQU0sd0JBQXdCO0FBQUEsY0FDMUM7QUFDQSw2QkFBZSxLQUFLLE1BQU0sU0FBUyxVQUFVLGlCQUFpQjtBQUM5RCxrQkFBSSxLQUFLLGFBQWE7QUFDcEIsb0JBQUksS0FBSyxhQUFhLFdBQVcsYUFBYSxVQUMxQyxLQUFLLGFBQWEsU0FBUyxNQUFNLGFBQWEsU0FBUyxHQUFHO0FBQzVELHdCQUFNLElBQUksTUFBTSw4QkFBOEI7QUFBQSxnQkFDaEQ7QUFBQSxjQUNGLFdBQVcsU0FBUztBQUNsQixxQkFBSyxjQUFjO0FBQ25CLHFCQUFLLGVBQWU7QUFBQSxjQUN0QixPQUFPO0FBQ0wsc0JBQU0sSUFBSSxNQUFNLHVDQUF1QztBQUFBLGNBQ3pEO0FBRUEsdUJBQVMsSUFBSSxHQUFHLElBQUksYUFBYSxRQUFRLEtBQUs7QUFDNUMsc0JBQU1DLFVBQVMsT0FBTyxhQUFhLElBQUksV0FBVyxDQUFDLElBQUksQ0FBQztBQUN4RCwyQkFBVyxVQUFVQSxTQUFRLElBQUksQ0FBQztBQUNsQyxxQkFBSyxVQUFVQSxTQUFRLEtBQUssU0FBUyxHQUFHLEtBQUs7QUFBQSxjQUMvQztBQUFBLFlBQ0YsT0FBTztBQUNMLHlCQUFXLFVBQVUsUUFBUSxLQUFLLEtBQUssY0FBYyxLQUFLLGFBQWEsU0FBUyxJQUFJLEVBQUU7QUFDdEYsbUJBQUssVUFBVSxRQUFRLEtBQUssU0FBUyxHQUFHLEtBQUs7QUFBQSxZQUMvQztBQUFBLFVBQ0YsQ0FBQztBQUNELGlCQUFPO0FBQUEsUUFDVDtBQUFBO0FBQUEsTUFRRjtBQUVBLE1BQU0sWUFBWSxDQUFDLFNBQXlCLE9BQU87QUFFbkQsTUFBTSwwQkFDRixDQUFDLDJCQUErQyxhQUF1QyxVQUN0RixnQkFBZ0MsZ0JBQWdEO0FBQy9FLGNBQU0sZUFBZSxZQUFZLElBQUksQ0FBQyxNQUFNLFVBQVUsMEJBQTBCLEtBQUssSUFBSSxLQUFLLFNBQVMsSUFBSTtBQUMzRyxjQUFNLFlBQVksYUFBYSxJQUFJLENBQUMsYUFBYSxVQUFVLGNBQWMsUUFBUSxLQUFLLElBQUksVUFBVSxXQUFXLENBQUM7QUFDaEgsY0FBTSxhQUFhLFVBQVUsS0FBSyxXQUFXO0FBQzdDLGNBQU0sNkJBQTZCLHFCQUFxQixZQUFZLE1BQU07QUFDMUUsY0FBTSxvQkFBb0IsNkJBQTZCLFlBQVksU0FBUztBQUM1RSxjQUFNLFNBQVMsZUFBZSxVQUFVLFVBQVUsaUJBQWlCO0FBQ25FLGNBQU0sa0JBQ0YsQ0FBQyxHQUFHLGVBQWUsYUFBYSxLQUFLLENBQUMsRUFBRSxPQUFPLENBQUMsV0FBVyxDQUFDLGVBQWUsSUFBSSxnQkFBZ0IsSUFBSSxNQUFNLENBQUM7QUFDOUcsY0FBTSxrQkFBa0IsQ0FBQyxpQkFBK0I7QUFDdEQsZ0JBQU0sVUFBb0IsQ0FBQztBQUMzQixnQkFBTSxXQUFXO0FBQ2pCLGdCQUFNLFVBQVU7QUFDaEIsZ0JBQU0sWUFBWTtBQUNsQixnQkFBTSxzQkFBZ0MsQ0FBQztBQUN2QyxnQkFBTSx1QkFBaUMsQ0FBQztBQUN4QyxnQkFBTSx1QkFBaUMsQ0FBQztBQUN4QyxnQkFBTSxrQkFBNEIsQ0FBQztBQUNuQyxnQkFBTSx5QkFBeUIsZUFBZSxhQUFhLFNBQVMsZUFBZSxJQUFJLGdCQUFnQjtBQUN2Ryx5QkFBZSxhQUFhLFFBQVEsQ0FBQyxNQUFNLFdBQVc7QUFDcEQsZ0JBQUksZUFBZSxJQUFJLGdCQUFnQixJQUFJLE1BQU0sR0FBRztBQUNsRCxvQkFBTSxjQUFjLGVBQWUsSUFBSSxnQkFBZ0IsSUFBSSxNQUFNLElBQUksQ0FBQztBQUN0RSxrQkFBSSxnQkFBZ0IsUUFBVztBQUM3QiwrQkFBZSxJQUFJLFFBQVEsQ0FBQyxNQUFNLE1BQU07QUFDdEMsc0JBQUksS0FBSyxhQUFhLFNBQVMsQ0FBQyxHQUFHO0FBQ2pDLDBCQUFNLFVBQVUsS0FBSyxnQkFBZ0IsSUFBSSxNQUFNO0FBQy9DLHdCQUFJLFlBQVksUUFBVztBQUN6Qiw0QkFBTSxJQUFJLE1BQU0sc0JBQXNCO0FBQUEsb0JBQ3hDO0FBQ0EsNEJBQVEsUUFBUSxDQUFDLFVBQVU7QUFDekIsOEJBQVEsS0FBSyxHQUNULFVBQVUsQ0FBQyxFQUFFO0FBQUEsd0JBQ1QsUUFBUSxDQUFDO0FBQUEsd0JBQVc7QUFBQSx3QkFBTyxPQUFPLFdBQVcsaUJBQWlCLFdBQVc7QUFBQSxzQkFBQyxDQUFDLEVBQUU7QUFBQSxvQkFDdkYsQ0FBQztBQUFBLGtCQUNIO0FBQUEsZ0JBQ0YsQ0FBQztBQUFBLGNBQ0g7QUFBQSxZQUNGLE9BQU87QUFDTCw2QkFBZSxJQUFJLFFBQVEsQ0FBQyxNQUFNLE1BQU07QUFDdEMsb0JBQUksS0FBSyxhQUFhLFNBQVMsQ0FBQyxHQUFHO0FBQ2pDLHdCQUFNLFVBQVUsS0FBSyxnQkFBZ0IsSUFBSSxNQUFNO0FBQy9DLHNCQUFJLFlBQVksUUFBVztBQUN6QiwwQkFBTSxJQUFJLE1BQU0sc0JBQXNCO0FBQUEsa0JBQ3hDO0FBQ0EsMEJBQVEsUUFBUSxDQUFDLFVBQVU7QUFDekIsd0NBQW9CLEtBQUssR0FBRyxVQUFVLENBQUMsRUFBRSxXQUFXLFFBQVEsQ0FBQyxXQUFXLE9BQU8sR0FBRyxNQUFNLEVBQUUsQ0FBQyxFQUFFO0FBQUEsa0JBQy9GLENBQUM7QUFDRCxrQ0FBZ0IsS0FBSyxXQUFXLFVBQVUsQ0FBQyxFQUFFLGFBQWEsUUFBUSxDQUFDLFNBQVMsQ0FBQyxHQUFHO0FBQUEsZ0JBQ2xGO0FBQUEsY0FDRixDQUFDO0FBQ0QsbUNBQXFCO0FBQUEsZ0JBQ2pCLFdBQVcsTUFBTSxjQUFjLE1BQU0sZUFBZSxVQUFVLE1BQU0sQ0FBQyxLQUFLLE1BQU07QUFBQSxjQUFPO0FBQzNGLG1DQUFxQixLQUFLLEdBQUc7QUFBQSxZQUMvQjtBQUFBLFVBQ0YsQ0FBQztBQUNELGdCQUFNQyxhQUFZLHlCQUNkO0FBQUEsWUFDRSxHQUFHO0FBQUEsWUFDSCxhQUFhLFVBQVUsSUFBSSxDQUFDLFVBQVUsTUFBTSxTQUFTLGFBQWEsUUFBUSxDQUFDLFNBQVMsQ0FBQyxFQUFFLEtBQUssS0FBSyxDQUFDO0FBQUEsVUFDcEcsSUFDQTtBQUFBLFlBQ0UsR0FBRztBQUFBLFlBQ0g7QUFBQSxZQUNBLEdBQUc7QUFBQSxZQUNILEdBQUc7QUFBQSxZQUNIO0FBQUEsWUFDQSxHQUFHO0FBQUEsWUFDSDtBQUFBLFlBQ0EsR0FBRztBQUFBLFVBQ0w7QUFDSixpQkFBTztBQUFBLGNBRUgsYUFDSyxpQkFBaUIsZ0JBQWdCLElBQUksQ0FBQyxZQUFZLEVBQUMsTUFBTSxHQUFHLFVBQVUsTUFBTSxDQUFDLElBQUksTUFBTSxNQUFLLEVBQUUsQ0FBQyxFQUMvRixnQkFBZ0IsY0FBYyxLQUFLLEVBQ25DLGlCQUFpQixHQUFHLFdBQVcsTUFBTSxDQUFDO0FBQUE7QUFBQSxjQUV6QyxhQUFhLFVBQVUsQ0FBQztBQUFBLGNBQ3hCLGFBQWEsc0NBQXNDLHFCQUFxQixDQUFDO0FBQUEsa0NBQ3JELE9BQU8sZ0JBQWdCLFlBQVksQ0FBQztBQUFBLGNBQ3hELFVBQVUsSUFBSSxDQUFDLE1BQU0sTUFBTSxZQUFZLENBQUMsWUFBWSxVQUFVLENBQUMsRUFBRSxLQUFLLE9BQU8sR0FBRyxFQUFFLEtBQUssSUFBSSxDQUFDO0FBQUEsY0FDNUZBLFdBQVUsS0FBSyxJQUFJLENBQUM7QUFBQSxjQUNwQixPQUFPLFlBQVksY0FBYyxLQUFLLENBQUM7QUFBQTtBQUFBLFFBRS9DO0FBQ0EsZUFBTztBQUFBLFVBQ0wsTUFBTTtBQUFBLFVBQ04sYUFBYTtBQUFBLFlBQ1gsTUFBTSxlQUFlO0FBQUEsWUFDckIsbUJBQW1CLDBCQUEwQixJQUFJLENBQUMsdUJBQXVCLHFCQUFxQixTQUFTLE1BQU07QUFBQSxVQUMvRztBQUFBLFVBQ0EsWUFBWSxNQUFNO0FBR2hCLGtCQUFNLHNCQUNGLGdCQUFnQixPQUFPLENBQUMsV0FBVyxlQUFlLGFBQWEsSUFBSSxNQUFNLENBQUMsRUFDckUsSUFBSSxDQUFDLFlBQVksRUFBQyxNQUFNLFVBQVUsTUFBTSxlQUFlLGFBQWEsSUFBSSxNQUFNLEdBQUcsWUFBWSxFQUFDLEVBQUU7QUFDekcsZ0NBQW9CLEtBQUssRUFBQyxNQUFNLFVBQVUsTUFBTSxXQUFVLENBQUM7QUFDM0Qsa0JBQU0sa0JBQ0YsWUFBWSxPQUFPLENBQUMsR0FBRyxVQUFVLDBCQUEwQixLQUFLLENBQUMsRUFDNUQsSUFBSSxDQUFDLE1BQU0sTUFBTSxDQUFDLEdBQUcsMkJBQTJCLElBQUksQ0FBQyxDQUFDLEVBQ3RELE9BQU8sQ0FBQyxLQUFLLHlCQUF5QixJQUFJLE9BQU8sb0JBQW9CLEdBQUcsbUJBQW1CO0FBQ3BHLGdCQUFJLDRCQUE0QjtBQUM5Qiw4QkFBZ0IsS0FBSyxHQUFHLDJCQUEyQixXQUFXLENBQUM7QUFBQSxZQUNqRTtBQUNBLG1CQUFRO0FBQUEsY0FDTixTQUFTLENBQUMsRUFBQyxNQUFNLGFBQWEsU0FBUSxDQUFDO0FBQUEsY0FDdkMsZUFBZSxFQUFDLEdBQUcsS0FBSztBQUFBLGdCQUFLLGFBQWE7QUFBQTtBQUFBLGNBQXVCLEVBQUM7QUFBQSxjQUNsRTtBQUFBLFlBQ0Y7QUFBQSxVQUNGO0FBQUEsVUFDQTtBQUFBLFFBQ0Y7QUFBQSxNQUNGO0FBRUcsTUFBTSxTQUFTLENBQUMsU0FBeUIsZUFBdUM7QUFDckYsY0FBTSxpQkFBaUIsSUFBSSxlQUFlLFFBQVEsUUFBUSxXQUFXLFFBQVE7QUFDN0UsY0FBTSw0QkFBNEIsUUFBUSxPQUFPLElBQUksQ0FBQyxPQUFPLE1BQU0scUJBQXFCLE1BQU0sS0FBSyxNQUFNLENBQUM7QUFDMUcsY0FBTSxjQUFjLGVBQWU7QUFDbkMsY0FBTSxjQUFjLFFBQVEsT0FBTyxJQUFJLENBQUMsT0FBTyxNQUFNLE1BQU0sSUFBSTtBQUMvRCxnQkFBUSxRQUFRO0FBQUEsVUFDWjtBQUFBLFVBQTJCO0FBQUEsVUFBYSxRQUFRLE9BQU8sQ0FBQyxFQUFFO0FBQUEsVUFBVTtBQUFBLFVBQWdCO0FBQUEsUUFBVyxDQUFDO0FBQUEsTUFDdEc7QUFFTyxNQUFNLHdCQUF3QixDQUFDLGVBQTBEO0FBQzlGLGNBQU0sV0FBWSxXQUFXLFNBQW9CLFFBQVEsUUFBUSxFQUFFO0FBQ25FLGVBQU8sNEJBQTRCLEVBQUMsU0FBUSxDQUFDO0FBQUEsTUFDL0M7QUFBQTtBQUFBOzs7QUN2VEEsTUFVTUMsa0JBaUJBLGtCQVlBQyx1QkFJQSx5QkFvRU87QUEvR2I7QUFBQTtBQUFBO0FBR0E7QUFFQTtBQUdBO0FBRUEsTUFBTUQsbUJBQWlCLENBQUMsV0FBd0M7QUFDOUQsWUFBSSxDQUFDLFVBQVUsT0FBTyxXQUFXLEdBQUc7QUFDbEMsZ0JBQU0sSUFBSSxNQUFNLDBCQUEwQjtBQUFBLFFBQzVDO0FBQ0EsY0FBTSxhQUFhLE9BQU8sQ0FBQyxFQUFFO0FBQzdCLGNBQU0sUUFBUSxNQUFNLEtBQUssT0FBTyxDQUFDLEVBQUUsaUJBQWlCLEdBQUcsTUFBTTtBQUU3RCxZQUFJLGFBQWEsTUFBTSxTQUFTLFdBQVcsU0FBUyxJQUFJLE1BQU0sU0FBUyxXQUFXO0FBQ2xGLFlBQUksa0JBQWtCLFdBQVcsU0FBUyxNQUFNLFNBQVMsSUFBSSxXQUFXLFNBQVMsTUFBTTtBQUN2RixlQUFPLGFBQWEsTUFBTSxVQUFVLGtCQUFrQixXQUFXLFFBQVEsRUFBRSxZQUFZLEVBQUUsaUJBQWlCO0FBQ3hHLGNBQUksTUFBTSxVQUFVLE1BQU0sV0FBVyxlQUFlLEtBQUssTUFBTSxVQUFVLE1BQU0sS0FDM0UsV0FBVyxlQUFlLE1BQU0sR0FBRztBQUNyQyxrQkFBTSxJQUFJLE1BQU0sb0RBQW9EO0FBQUEsVUFDdEU7QUFBQSxRQUNGO0FBQUEsTUFDRjtBQUVBLE1BQU0sbUJBQW1CLENBQUMsUUFBMkIsV0FBd0M7QUFDM0YsY0FBTSxPQUFPLE9BQU8sU0FBUyxPQUFPO0FBQ3BDLGNBQU0sUUFBa0IsQ0FBQztBQUN6QixpQkFBUyxJQUFJLEdBQUcsSUFBSSxNQUFNLEVBQUUsR0FBRztBQUM3QixnQkFBTSxLQUFLLE9BQU8sQ0FBQyxDQUFDO0FBQUEsUUFDdEI7QUFDQSxpQkFBUyxJQUFJLEdBQUcsSUFBSSxPQUFPLFFBQVEsRUFBRSxHQUFHO0FBQ3RDLGdCQUFNLEtBQUssT0FBTyxDQUFDLE1BQU0sSUFBSSxPQUFPLElBQUksSUFBSSxJQUFJLE9BQU8sQ0FBQyxDQUFDO0FBQUEsUUFDM0Q7QUFDQSxlQUFPO0FBQUEsTUFDVDtBQUVBLE1BQU1DLHdCQUF1QixDQUFDLFlBQStCLFVBQ3hELFdBQVcsU0FBUyxNQUFNLFNBQVUsaUJBQWlCLFlBQVksS0FBSyxJQUFJLGlCQUFpQixPQUFPLFVBQVU7QUFHakgsTUFBTSwwQkFBMEIsQ0FBQyxXQUErQztBQUM5RSxjQUFNLGFBQWEsT0FBTyxDQUFDLEVBQUU7QUFDN0IsY0FBTSxRQUFRLE1BQU0sS0FBSyxPQUFPLENBQUMsRUFBRSxpQkFBaUIsR0FBRyxNQUFNO0FBQzdELGNBQU0sY0FBd0JBLHNCQUFxQixZQUFZLEtBQUs7QUFDcEUsY0FBTSxXQUFXLE9BQU8sQ0FBQyxFQUFFO0FBQzNCLGNBQU0sYUFBYSw0QkFBNkIsSUFBSTtBQUNwRCxjQUFNLGFBQWEsS0FBSyxLQUFLLFVBQVUsS0FBSyxXQUFXLElBQUksVUFBVTtBQUVyRSxjQUFNLDBCQUEwQixxQkFBcUIsV0FBVyxNQUFNO0FBQ3RFLGNBQU0sMkJBQTJCLHFCQUFxQixZQUFZLE1BQU07QUFHeEUsY0FBTSxrQkFBa0IsQ0FBQyxpQkFBK0I7QUFDdEQsZ0JBQU0sbUJBQW1CLDBCQUEwQixXQUFXLFNBQVM7QUFDdkUsZ0JBQU0sb0JBQW9CLDJCQUEyQixZQUFZLFNBQVM7QUFDMUUsZ0JBQU0sUUFBUSxjQUFjLFNBQVMsVUFBVSxrQkFBa0IsVUFBVTtBQUMzRSxnQkFBTSxTQUFTLGVBQWUsVUFBVSxVQUFVLG1CQUFtQixVQUFVO0FBQy9FLGNBQUk7QUFDSixjQUFJLDJCQUE0QjtBQUM5QixrQkFBTSxtQkFBbUIsQ0FBQyxRQUFnQixHQUFXLFdBQVcsT0FBTztBQUFBLDZCQUNoRCxDQUFDLE1BQU0sT0FBTyxnQkFBZ0Isa0JBQWtCLENBQUMsR0FBRyxDQUFDO0FBQUEsc0JBQzVELENBQUMsTUFBTSxNQUFNLDJCQUEyQixnQkFBZ0IsQ0FBQyxJQUFJLE1BQU0sQ0FBQztBQUFBLHFCQUNyRSxDQUFDLFlBQVksQ0FBQztBQUFBLHlCQUNWLENBQUMsWUFBWSxDQUFDO0FBQUEsWUFDM0IsTUFBTSxJQUFJLENBQUMsT0FBTyxRQUFRLElBQUksTUFBTSxZQUFZLFFBQVEsQ0FBQyxFQUFFLENBQUMsYUFBYSxDQUFDO0FBQUE7QUFFaEYseUJBQWE7QUFBQSwwQ0FDdUIsVUFBVTtBQUFBO0FBQUEsVUFFMUMsaUJBQWlCLFFBQVEsR0FBRyxLQUFLLENBQUM7QUFBQSxVQUNsQyxpQkFBaUIsUUFBUSxHQUFHLEtBQUssQ0FBQztBQUFBLFVBQ2xDLGlCQUFpQixRQUFRLEdBQUcsS0FBSyxDQUFDO0FBQUEsVUFDbEMsaUJBQWlCLFFBQVEsR0FBRyxLQUFLLENBQUM7QUFBQSxVQUNsQyxPQUFPLFlBQVksY0FBYyxNQUFNLENBQUM7QUFBQTtBQUFBLFVBRTlDLE9BQU87QUFDTCx5QkFBYTtBQUFBLDhCQUNXLE9BQU8sZ0JBQWdCLFlBQVksQ0FBQztBQUFBLDRCQUN0QyxNQUFNLDJCQUEyQixpQkFBaUIsTUFBTSxDQUFDO0FBQUEsVUFDM0UsT0FBTyxZQUFZLGNBQWMsTUFBTSxZQUFZLGFBQWEsQ0FBQyxDQUFDO0FBQUE7QUFBQSxVQUV4RTtBQUNBLGlCQUFPO0FBQUEsTUFDTCxhQUFhLGdCQUFnQixZQUFZLEtBQUssRUFBRSxpQkFBaUIsT0FBTyxNQUFNLENBQUM7QUFBQSxNQUMvRSxhQUFhLFVBQVUsQ0FBQztBQUFBLE1BQ3hCLGFBQWEsc0NBQXNDLG1CQUFtQixDQUFDO0FBQUEsTUFDdkUsVUFBVTtBQUFBLFFBQ2Q7QUFFQSxjQUFNLGtCQUFvQyxDQUFDLEVBQUMsTUFBTSxVQUFVLE1BQU0sV0FBVSxDQUFDO0FBQzdFLFlBQUkseUJBQXlCO0FBQzNCLDBCQUFnQixLQUFLLEdBQUcsMkJBQTJCLFVBQVUsQ0FBQztBQUFBLFFBQ2hFO0FBQ0EsWUFBSSwwQkFBMEI7QUFDNUIsMEJBQWdCLEtBQUssR0FBRywyQkFBMkIsV0FBVyxDQUFDO0FBQUEsUUFDakU7QUFDQSxlQUFPO0FBQUEsVUFDTCxNQUFNO0FBQUEsVUFDTixhQUFhLEVBQUMsTUFBTSxHQUFHLFlBQVksTUFBTSxJQUFJLG1CQUFtQixDQUFDLDBCQUEwQixTQUFTLE1BQU0sRUFBQztBQUFBLFVBQzNHO0FBQUEsVUFDQSxZQUFZLE9BQU87QUFBQSxZQUNqQixTQUFTLENBQUMsRUFBQyxNQUFNLGFBQWEsVUFBVSxPQUFPLENBQUMsRUFBRSxTQUFRLENBQUM7QUFBQSxZQUMzRCxlQUFlLEVBQUMsR0FBRyxLQUFLO0FBQUEsY0FBSyxhQUFhO0FBQUE7QUFBQSxZQUF1QixFQUFDO0FBQUEsWUFDbEU7QUFBQSxVQUNGO0FBQUEsUUFDRjtBQUFBLE1BQ0Y7QUFFTyxNQUFNLFNBQVMsQ0FBQyxZQUFrQztBQUN2RCxRQUFBRCxpQkFBZSxRQUFRLE1BQU07QUFDN0IsZ0JBQVEsUUFBUSx3QkFBd0IsUUFBUSxNQUFNLEdBQUcsRUFBQyxRQUFRLENBQUMsQ0FBQyxFQUFDLENBQUM7QUFBQSxNQUN4RTtBQUFBO0FBQUE7OztBQ2xIQSxNQWVNRSxrQkFNQSx5QkF3SE8sdUJBR0E7QUFoSmI7QUFBQTtBQUFBO0FBR0E7QUFFQTtBQUNBO0FBR0E7QUFNQSxNQUFNQSxtQkFBaUIsQ0FBQyxXQUF3QztBQUM5RCxZQUFJLENBQUMsVUFBVSxPQUFPLFdBQVcsR0FBRztBQUNsQyxnQkFBTSxJQUFJLE1BQU0sMkJBQTJCO0FBQUEsUUFDN0M7QUFBQSxNQUNGO0FBRUEsTUFBTSwwQkFBMEIsQ0FBQyxRQUErQixlQUE4QztBQUM1RyxjQUFNLGFBQWEsT0FBTyxDQUFDLEVBQUU7QUFDN0IsY0FBTSxlQUFlLE9BQU8sQ0FBQyxFQUFFO0FBRS9CLGNBQU0sWUFBWSxXQUFXO0FBQzdCLGNBQU0sT0FBTyxVQUFVLGNBQWMsV0FBVyxNQUFNLFNBQVM7QUFFL0QsY0FBTSxjQUFjLFdBQVcsTUFBTSxDQUFDO0FBQ3RDLG9CQUFZLE9BQU8sTUFBTSxHQUFHLEdBQUcsWUFBWTtBQUUzQyxjQUFNLGVBQWUsV0FBVyxJQUFJO0FBQ3BDLGNBQU0sYUFBYSxPQUFPLENBQUMsRUFBRSw0QkFBNkIsSUFBSTtBQUM5RCxjQUFNLGFBQWEsS0FBSyxLQUFLLFVBQVUsS0FBSyxXQUFXLElBQUksVUFBVTtBQUVyRSxjQUFNLDRCQUE0QixxQkFBcUIsT0FBTyxDQUFDLEVBQUUsS0FBSyxNQUFNO0FBQzVFLGNBQU0sbUJBQW1CLDRCQUE0QixPQUFPLENBQUMsRUFBRSxLQUFLLFNBQVMsT0FBTyxDQUFDLEVBQUU7QUFDdkYsY0FBTSw4QkFBOEIscUJBQXFCLE9BQU8sQ0FBQyxFQUFFLEtBQUssTUFBTTtBQUM5RSxjQUFNLHFCQUFxQiw4QkFBOEIsT0FBTyxDQUFDLEVBQUUsS0FBSyxTQUFTLE9BQU8sQ0FBQyxFQUFFO0FBQzNGLGNBQU0sNkJBQTZCLHFCQUFxQixZQUFZLE1BQU07QUFDMUUsY0FBTSxvQkFBb0IsNkJBQTZCLFlBQVksU0FBUztBQUU1RSxjQUFNLGtCQUNGLENBQUMsRUFBQyxNQUFNLFVBQVUsTUFBTSxXQUFVLEdBQUcsRUFBQyxNQUFNLFNBQVMsTUFBTSxhQUFZLEdBQUcsRUFBQyxNQUFNLFVBQVUsTUFBTSxLQUFJLENBQUM7QUFDMUcsWUFBSSwyQkFBMkI7QUFDN0IsMEJBQWdCLEtBQUssR0FBRywyQkFBMkIsT0FBTyxDQUFDLEVBQUUsSUFBSSxDQUFDO0FBQUEsUUFDcEU7QUFDQSxZQUFJLDZCQUE2QjtBQUMvQiwwQkFBZ0IsS0FBSyxHQUFHLDJCQUEyQixPQUFPLENBQUMsRUFBRSxJQUFJLENBQUM7QUFBQSxRQUNwRTtBQUNBLFlBQUksNEJBQTRCO0FBQzlCLDBCQUFnQixLQUFLLEdBQUcsMkJBQTJCLFdBQVcsQ0FBQztBQUFBLFFBQ2pFO0FBRUEsY0FBTSxvQkFBd0QsQ0FBQztBQUMvRCwwQkFBa0IsS0FBSyw0QkFBNEIsU0FBUyxNQUFNO0FBQ2xFLDBCQUFrQixLQUFLLDhCQUE4QixTQUFTLE1BQU07QUFFcEUsY0FBTSxrQkFBa0IsQ0FBQyxpQkFBK0I7QUFDdEQsZ0JBQU0sT0FBTyxjQUFjLFFBQVEsT0FBTyxDQUFDLEVBQUUsVUFBVSxrQkFBa0IsVUFBVTtBQUNuRixnQkFBTSxVQUFVLGNBQWMsZ0JBQWdCLE9BQU8sQ0FBQyxFQUFFLFVBQVUsa0JBQWtCO0FBQ3BGLGdCQUFNLFNBQVMsZUFBZSxVQUFVLE9BQU8sQ0FBQyxFQUFFLFVBQVUsbUJBQW1CLFVBQVU7QUFFekYsZ0JBQU0sa0JBQWtCLENBQUMsTUFBNkI7QUFDcEQsa0JBQU0sY0FBYyxhQUFhO0FBQ2pDLGdCQUFJLFVBQVUscUJBQXFCLENBQUMsT0FBTyxRQUFRLEtBQUssT0FBTztBQUMvRCxxQkFBUyxJQUFJLEdBQUcsSUFBSSxhQUFhLEtBQUs7QUFDcEMseUJBQVcsR0FBRyxjQUFjLElBQUksaUJBQWlCLENBQUMsSUFBSSxDQUFDLE1BQU0saUJBQWlCLENBQUMsRUFBRSxNQUM3RSxZQUFZLFNBQVMsSUFBSSxnQkFBZ0IsQ0FBQyxvQkFBb0IsQ0FBQyxNQUFNLGdCQUFnQixDQUFDLEVBQUU7QUFBQSxZQUM5RjtBQUNBLHVCQUFXO0FBQUEsbUJBQ0UsQ0FBQyxNQUFNLFFBQVEsYUFBYSxpQkFBaUIsQ0FBQyxFQUFFLENBQUM7QUFBQSxtQkFDakQsQ0FBQztBQUFBLGlCQUNILENBQUMsU0FBUyxDQUFDO0FBQUE7QUFBQSwyQkFFRCxDQUFDLE1BQU0sS0FBSyxLQUFLLE9BQU87QUFBQTtBQUU3QyxxQkFBUyxJQUFJLEdBQUcsSUFBSSxHQUFHLElBQUksV0FBVyxLQUFLO0FBQ3pDLGtCQUFJLE1BQU0sTUFBTTtBQUNkLDJCQUFXLEdBQUcsWUFBWSxJQUFJLGNBQWMsQ0FBQyxJQUFJLENBQUMsTUFBTSxjQUFjLENBQUMsRUFBRSxhQUFhLENBQUM7QUFDdkYscUJBQUs7QUFBQSxjQUNQLE9BQU87QUFDTCwyQkFBVyxHQUFHLFlBQVksSUFBSSxjQUFjLENBQUMsSUFBSSxDQUFDLE1BQU0sY0FBYyxDQUFDLEVBQUUsTUFDckUsWUFBWSxTQUFTLElBQUksZ0JBQWdCLENBQUMsSUFBSSxDQUFDLE1BQU0sZ0JBQWdCLENBQUMsRUFBRTtBQUM1RTtBQUFBLGNBQ0Y7QUFBQSxZQUNGO0FBQ0EsbUJBQU87QUFBQSxVQUNUO0FBQ0EsY0FBSTtBQUNKLGNBQUksT0FBTyxDQUFDLEVBQUUsMkJBQTRCO0FBQ3hDLGtCQUFNLG1CQUFtQixDQUFDLFFBQWdCLEdBQVcsV0FBVyxPQUFPO0FBQUEsNkJBQ2hELENBQUMsTUFBTSxPQUFPLGdCQUFnQixrQkFBa0IsQ0FBQyxHQUFHLENBQUM7QUFBQSxZQUN0RSxnQkFBZ0IsQ0FBQyxDQUFDO0FBQUEsc0JBQ1IsQ0FBQyxNQUFNLEtBQUssZ0JBQWdCLGNBQWMsQ0FBQyxFQUFFLENBQUM7QUFBQSxxQkFDL0MsQ0FBQyxZQUFZLENBQUM7QUFBQSx5QkFDVixDQUFDLFlBQVksQ0FBQztBQUFBLFlBQzNCLE1BQU0sSUFBSSxDQUFDLE9BQU8sUUFBUSxJQUFJLEtBQUssWUFBWSxRQUFRLENBQUMsRUFBRSxDQUFDLGFBQWEsQ0FBQztBQUFBO0FBRS9FLHlCQUFhO0FBQUEsMENBQ3VCLFVBQVU7QUFBQTtBQUFBLFVBRTFDLGlCQUFpQixTQUFTLEdBQUcsS0FBSyxDQUFDO0FBQUEsVUFDbkMsaUJBQWlCLFNBQVMsR0FBRyxLQUFLLENBQUM7QUFBQSxVQUNuQyxpQkFBaUIsU0FBUyxHQUFHLEtBQUssQ0FBQztBQUFBLFVBQ25DLGlCQUFpQixTQUFTLEdBQUcsS0FBSyxDQUFDO0FBQUEsVUFDbkMsT0FBTyxZQUFZLGNBQWMsT0FBTyxDQUFDO0FBQUE7QUFBQSxVQUUvQyxPQUFPO0FBQ0wseUJBQWE7QUFBQSw0QkFDUyxPQUFPLGdCQUFnQixZQUFZLENBQUM7QUFBQSxRQUN4RCxnQkFBZ0IsRUFBRSxDQUFDO0FBQUEsb0JBQ1AsS0FBSyxhQUFhLGFBQWEsQ0FBQztBQUFBLFFBQzVDLE9BQU8sWUFBWSxjQUFjLE9BQU8sQ0FBQztBQUFBO0FBQUEsVUFFN0M7QUFDQSxpQkFBTztBQUFBLFFBRUgsYUFBYSxnQkFBZ0IsY0FBYyxLQUFLLEVBQzNDLGdCQUFnQixnQkFBZ0IsS0FBSyxFQUNyQyxnQkFBZ0IsUUFBUSxLQUFLLEVBQzdCLGlCQUFpQixNQUFNLFNBQVMsTUFBTSxDQUFDO0FBQUEsUUFDNUMsYUFBYSxVQUFVLENBQUM7QUFBQSxVQUN0QixhQUFhLHNDQUFzQyxxQkFBcUIsQ0FBQztBQUFBLFVBQ3pFLFVBQVU7QUFBQTtBQUFBLFFBRWxCO0FBQ0EsZUFBTztBQUFBLFVBQ0wsTUFBTTtBQUFBLFVBQ04sYUFBYSxFQUFDLE1BQU0sV0FBVyxVQUFVLGtCQUFpQjtBQUFBLFVBQzFELFlBQVksT0FBTztBQUFBLFlBQ2pCLFNBQVM7QUFBQSxjQUNQLEVBQUMsTUFBTSxhQUFhLFVBQVUsT0FBTyxDQUFDLEVBQUUsU0FBUTtBQUFBLFlBQ2xEO0FBQUEsWUFDQSxlQUFlLEVBQUMsR0FBRyxLQUFLO0FBQUEsY0FBSyxhQUFhO0FBQUE7QUFBQSxZQUF1QixFQUFDO0FBQUEsWUFDbEU7QUFBQSxVQUNGO0FBQUEsVUFDQTtBQUFBLFFBQ0Y7QUFBQSxNQUNGO0FBRU8sTUFBTSx3QkFBd0IsQ0FBQyxlQUNsQyw0QkFBNEIsRUFBQyxNQUFNLFdBQVcsS0FBYyxDQUFDO0FBRTFELE1BQU0sU0FBUyxDQUFDLFNBQXlCLGVBQXVDO0FBQ3JGLGNBQU0sU0FBUyxRQUFRO0FBQ3ZCLFFBQUFBLGlCQUFlLE1BQU07QUFDckIsZ0JBQVEsUUFBUSx3QkFBd0IsUUFBUSxRQUFRLFVBQVUsQ0FBQztBQUFBLE1BQ3JFO0FBQUE7QUFBQTs7O0FDcEpBLE1BY01DLGtCQWVBLGlDQStETywrQkFHQTtBQS9GYjtBQUFBO0FBQUE7QUFJQTtBQUNBO0FBR0E7QUFNQSxNQUFNQSxtQkFBaUIsQ0FBQyxXQUF3QztBQUM5RCxZQUFJLENBQUMsVUFBVSxPQUFPLFdBQVcsR0FBRztBQUNsQyxnQkFBTSxJQUFJLE1BQU0sbUNBQW1DO0FBQUEsUUFDckQ7QUFFQSxZQUFJLE9BQU8sQ0FBQyxFQUFFLEtBQUssU0FBUyxHQUFHO0FBQzdCLGdCQUFNLElBQUksTUFBTSwyREFBMkQ7QUFBQSxRQUM3RTtBQUVBLFlBQUksT0FBTyxDQUFDLEVBQUUsS0FBSyxXQUFXLE9BQU8sQ0FBQyxFQUFFLEtBQUssUUFBUTtBQUNuRCxnQkFBTSxJQUFJLE1BQU07QUFBQSw0REFDd0M7QUFBQSxRQUMxRDtBQUFBLE1BQ0Y7QUFFQSxNQUFNLGtDQUNGLENBQUMsUUFBK0IsZUFBc0Q7QUFDcEYsY0FBTSxhQUFhLE9BQU8sQ0FBQyxFQUFFO0FBQzdCLGNBQU0sc0JBQXNCLE9BQU8sQ0FBQyxFQUFFO0FBQ3RDLGNBQU0sWUFBWSxXQUFXO0FBRTdCLGNBQU0sZUFBZSxPQUFPLENBQUMsRUFBRTtBQUMvQixjQUFNLGtCQUFrQixPQUFPLENBQUMsRUFBRTtBQUNsQyxjQUFNLE9BQU8sVUFBVSxjQUFjLFdBQVcsTUFBTSxTQUFTO0FBQy9ELGNBQU0sZUFBZSxXQUFXLElBQUk7QUFFcEMsY0FBTSxjQUFjLGFBQWEsTUFBTSxDQUFDO0FBQ3hDLGNBQU0sYUFBYSxVQUFVLEtBQUssV0FBVztBQUU3QyxjQUFNLFFBQVEsY0FBYyxTQUFTLHFCQUFxQixTQUFTO0FBQ25FLGNBQU0sVUFBVSxjQUFjLGdCQUFnQixpQkFBaUIsYUFBYSxNQUFNO0FBQ2xGLGNBQU0sU0FBUyxlQUFlLFVBQVUscUJBQXFCLFlBQVksTUFBTTtBQUcvRSxjQUFNLGtCQUNGLENBQUMsRUFBQyxNQUFNLFVBQVUsTUFBTSxXQUFVLEdBQUcsRUFBQyxNQUFNLFNBQVMsTUFBTSxhQUFZLEdBQUcsRUFBQyxNQUFNLFVBQVUsTUFBTSxLQUFJLENBQUM7QUFDMUcsd0JBQWdCLEtBQUssR0FBRywyQkFBMkIsVUFBVSxDQUFDO0FBQzlELHdCQUFnQixLQUFLLEdBQUcsMkJBQTJCLFlBQVksQ0FBQztBQUNoRSx3QkFBZ0IsS0FBSyxHQUFHLDJCQUEyQixXQUFXLENBQUM7QUFDL0QsY0FBTSxvQkFBd0QsQ0FBQyxRQUFRLE1BQU07QUFLN0UsY0FBTSxrQkFBa0IsQ0FBQyxpQkFBK0I7QUFBQSxRQUVwRCxhQUFhLGdCQUFnQixjQUFjLEtBQUssRUFDM0MsZ0JBQWdCLGdCQUFnQixLQUFLLEVBQ3JDLGdCQUFnQixRQUFRLEtBQUssRUFDN0IsaUJBQWlCLE9BQU8sU0FBUyxNQUFNLENBQUM7QUFBQSxRQUMvQyxhQUFhLFVBQVUsQ0FBQztBQUFBLFFBQ3hCLGFBQWEsc0NBQXNDLHFCQUFxQixDQUFDO0FBQUE7QUFBQSw0QkFFckQsT0FBTyxnQkFBZ0IsWUFBWSxDQUFDO0FBQUE7QUFBQSxrQkFFOUMsUUFBUSxZQUFZLFlBQVksQ0FBQztBQUFBO0FBQUE7QUFBQTtBQUFBLDJCQUl4QixNQUFNLEtBQUssT0FBTztBQUFBLFFBQ3JDLE1BQU0sV0FBVyxnQkFBZ0IsaUJBQWlCLFVBQVUsQ0FBQztBQUFBLG9CQUNqRCxNQUFNLGFBQWEsY0FBYyxDQUFDO0FBQUE7QUFBQSxRQUU5QyxPQUFPLFlBQVksY0FBYyxPQUFPLENBQUM7QUFBQTtBQUczQyxlQUFPO0FBQUEsVUFDTCxNQUFNO0FBQUEsVUFDTixhQUFhLEVBQUMsa0JBQWlCO0FBQUEsVUFDL0IsWUFBWSxPQUFPO0FBQUEsWUFDakIsU0FBUyxDQUFDLEVBQUMsTUFBTSxhQUFhLFVBQVUsT0FBTyxDQUFDLEVBQUUsU0FBUSxDQUFDO0FBQUEsWUFDM0QsZUFBZSxFQUFDLEdBQUcsS0FBSztBQUFBLGNBQUssYUFBYTtBQUFBO0FBQUEsWUFBdUIsRUFBQztBQUFBLFlBQ2xFO0FBQUEsVUFDRjtBQUFBLFVBQ0E7QUFBQSxRQUNGO0FBQUEsTUFDRjtBQUVHLE1BQU0sZ0NBQWdDLENBQUMsZUFDMUMsNEJBQTRCLEVBQUMsTUFBTSxXQUFXLEtBQWMsQ0FBQztBQUUxRCxNQUFNLGlCQUFpQixDQUFDLFNBQXlCLGVBQStDO0FBQ3JHLGNBQU0sU0FBUyxRQUFRO0FBQ3ZCLFFBQUFBLGlCQUFlLE1BQU07QUFDckIsZ0JBQVEsUUFBUSxnQ0FBZ0MsUUFBUSxRQUFRLFVBQVUsQ0FBQztBQUFBLE1BQzdFO0FBQUE7QUFBQTs7O0FDbkdBLE1BVU1DLGtCQTBCQSx1QkF1Rk8scUJBUUE7QUFuSWI7QUFBQTtBQUFBO0FBSUE7QUFJQTtBQUVBLE1BQU1BLG1CQUFpQixDQUFDLFdBQXdDO0FBQzlELFlBQUksQ0FBQyxRQUFRO0FBQ1gsZ0JBQU0sSUFBSSxNQUFNLGtCQUFrQjtBQUFBLFFBQ3BDO0FBQ0EsWUFBSSxPQUFPLFNBQVMsS0FBSyxPQUFPLFNBQVMsR0FBRztBQUMxQyxnQkFBTSxJQUFJLE1BQU0sc0JBQXNCO0FBQUEsUUFDeEM7QUFHQSxZQUFJLE9BQU8sV0FBVyxLQUFLLE9BQU8sQ0FBQyxFQUFFLEtBQUssU0FBUyxHQUFHO0FBQ3BELGdCQUFNLElBQUksTUFBTSwwQkFBMEI7QUFBQSxRQUM1QztBQUVBLFlBQUssT0FBTyxDQUFDLEVBQUUsYUFBYSxPQUFPLENBQUMsRUFBRSxZQUNqQyxPQUFPLFdBQVcsS0FBSyxPQUFPLENBQUMsRUFBRSxhQUFhLE9BQU8sQ0FBQyxFQUFFLFVBQVc7QUFDdEUsZ0JBQU0sSUFBSSxNQUFNLDRCQUE0QjtBQUFBLFFBQzlDO0FBQUEsTUFDRjtBQVNBLE1BQU0sd0JBQXdCLENBQUMsUUFBK0IsZUFBNEM7QUFDeEcsY0FBTSxTQUFTLE9BQU8sQ0FBQyxFQUFFLEtBQUssTUFBTTtBQUNwQyxjQUFNLFNBQVMsT0FBTyxDQUFDLEVBQUUsS0FBSyxNQUFNO0FBQ3BDLGNBQU0sQ0FBQyxHQUFHLEdBQUcsQ0FBQyxJQUFJLFNBQVM7QUFBQSxVQUN2QjtBQUFBLFVBQVEsV0FBVztBQUFBLFVBQVE7QUFBQSxVQUFRLFdBQVc7QUFBQSxVQUFRLE9BQU8sV0FBVyxJQUFJLE9BQU8sQ0FBQyxFQUFFLE9BQU87QUFBQSxRQUFTO0FBQzFHLGNBQU0sY0FBYyxDQUFDLEdBQUcsQ0FBQztBQUN6QixZQUFJLENBQUMsYUFBYTtBQUNoQixnQkFBTSxJQUFJLE1BQU0scUNBQXNDO0FBQUEsUUFDeEQ7QUFDQSxjQUFNLGFBQWEsVUFBVSxLQUFLLFdBQVc7QUFDN0MsY0FBTSxrQkFBb0M7QUFBQSxVQUN4QyxFQUFDLE1BQU0sVUFBVSxNQUFNLFdBQVU7QUFBQSxVQUFHLEVBQUMsTUFBTSxVQUFVLE1BQU0sRUFBQztBQUFBLFVBQUcsRUFBQyxNQUFNLFVBQVUsTUFBTSxFQUFDO0FBQUEsVUFBRyxFQUFDLE1BQU0sVUFBVSxNQUFNLEVBQUM7QUFBQSxVQUNsSCxFQUFDLE1BQU0sV0FBVyxNQUFNLFdBQVcsTUFBSztBQUFBLFVBQUcsRUFBQyxNQUFNLFdBQVcsTUFBTSxXQUFXLEtBQUk7QUFBQSxRQUNwRjtBQUNBLGNBQU0sb0JBQXdELENBQUMsUUFBUSxNQUFNO0FBQzdFLFlBQUksT0FBTyxXQUFXLEdBQUc7QUFDdkIsMEJBQWdCLEtBQUssR0FBRywyQkFBMkIsT0FBTyxDQUFDLEVBQUUsSUFBSSxDQUFDO0FBQ2xFLDRCQUFrQixLQUFLLE1BQU07QUFBQSxRQUMvQjtBQUNBLHdCQUFnQixLQUFLLEdBQUcsMkJBQTJCLFdBQVcsQ0FBQztBQUUvRCxjQUFNLGtCQUFrQixDQUFDLGlCQUErQjtBQUN0RCxjQUFJLE9BQU87QUFDWCxjQUFJLFdBQVcsVUFBVSxXQUFXLFFBQVE7QUFDMUMsbUJBQU87QUFBQSxVQUNULFdBQVcsV0FBVyxVQUFVLENBQUMsV0FBVyxRQUFRO0FBQ2xELG1CQUFPO0FBQUEsVUFDVCxXQUFXLENBQUMsV0FBVyxVQUFVLFdBQVcsUUFBUTtBQUNsRCxtQkFBTztBQUFBLFVBQ1QsV0FBVyxDQUFDLFdBQVcsVUFBVSxDQUFDLFdBQVcsUUFBUTtBQUNuRCxtQkFBTztBQUFBLFVBQ1Q7QUFFQSxnQkFBTSxpQkFBaUIsV0FBVyxVQUFVLElBQUksS0FBSztBQUNyRCxnQkFBTSxJQUFJLGNBQWMsS0FBSyxPQUFPLENBQUMsRUFBRSxVQUFVLE9BQU8sQ0FBQyxFQUFFLElBQUk7QUFDL0QsZ0JBQU0sSUFBSSxjQUFjLEtBQUssT0FBTyxDQUFDLEVBQUUsVUFBVSxPQUFPLENBQUMsRUFBRSxJQUFJO0FBQy9ELGdCQUFNLFdBQVcsRUFBRSxLQUFLO0FBQ3hCLGNBQUksSUFBd0I7QUFDNUIsZ0JBQU0sWUFBWSxDQUFDLEdBQUcsQ0FBQztBQUN2QixjQUFJLE9BQU8sV0FBVyxHQUFHO0FBQ3ZCLGdCQUFJLGNBQWMsS0FBSyxPQUFPLENBQUMsRUFBRSxVQUFVLE9BQU8sQ0FBQyxFQUFFLEtBQUssTUFBTTtBQUNoRSxzQkFBVSxLQUFLLENBQUM7QUFBQSxVQUNsQjtBQUNBLGdCQUFNLFNBQVMsZUFBZSxVQUFVLE9BQU8sQ0FBQyxFQUFFLFVBQVUsWUFBWSxNQUFNO0FBQzlFLG9CQUFVLEtBQUssTUFBTTtBQUNyQixnQkFBTSxXQUE4QjtBQUFBLFlBQ2xDLEVBQUMsTUFBTSxlQUFlLE1BQU0sTUFBSztBQUFBLFlBQUcsRUFBQyxNQUFNLEtBQUssTUFBTSxNQUFLO0FBQUEsWUFBRyxFQUFDLE1BQU0sS0FBSyxNQUFNLE1BQUs7QUFBQSxZQUFHLEVBQUMsTUFBTSxLQUFLLE1BQU0sTUFBSztBQUFBLFlBQy9HLEVBQUMsTUFBTSxTQUFTLE1BQU0sTUFBSztBQUFBLFlBQUcsRUFBQyxNQUFNLFFBQVEsTUFBTSxNQUFLO0FBQUEsVUFDMUQ7QUFDQSxpQkFBTztBQUFBLElBQ1AsYUFBYSxpQkFBaUIsUUFBUSxFQUFFLGlCQUFpQixHQUFHLFNBQVMsQ0FBQztBQUFBO0FBQUEsSUFFdEUsYUFBYSxVQUFVLENBQUM7QUFBQSxNQUN0QixhQUFhLHNDQUFzQyxzQkFBc0IsQ0FBQztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsa0JBSzlELFFBQVE7QUFBQTtBQUFBLFFBRWxCLElBQUk7QUFBQTtBQUFBO0FBQUEsTUFHTixjQUFjO0FBQUEsT0FDYixNQUFNO0FBQ1AsZ0JBQUksS0FBSyxNQUFNO0FBQ2IscUJBQU8saUJBQWlCLEVBQUUsMkJBQTJCLGNBQWMsTUFBTSxDQUFDLGNBQ3RFLFFBQVEscUJBQXFCLEVBQUUsWUFBWSxTQUFTLENBQUM7QUFBQSxZQUMzRDtBQUNBLG1CQUFPO0FBQUEsVUFDVCxHQUFHLENBQUM7QUFBQTtBQUFBO0FBQUEsUUFHTjtBQUVBLGVBQU87QUFBQSxVQUNMLE1BQU07QUFBQSxVQUNOLGFBQWEsRUFBQyxNQUFNLEdBQUcsV0FBVyxRQUFRLElBQUksa0JBQWlCO0FBQUEsVUFDL0QsWUFBWSxPQUFPO0FBQUEsWUFDakIsU0FBUyxDQUFDLEVBQUMsTUFBTSxhQUFhLFVBQVUsT0FBTyxDQUFDLEVBQUUsU0FBUSxDQUFDO0FBQUEsWUFDM0QsZUFBZSxFQUFDLEdBQUcsS0FBSztBQUFBLGNBQUssYUFBYTtBQUFBO0FBQUEsWUFBdUIsRUFBQztBQUFBLFlBQ2xFO0FBQUEsVUFDRjtBQUFBLFVBQ0E7QUFBQSxRQUNGO0FBQUEsTUFDRjtBQUVPLE1BQU0sc0JBQXNCLENBQUMsZUFBd0Q7QUFDMUYsY0FBTSxTQUFTLFdBQVc7QUFDMUIsY0FBTSxTQUFTLFdBQVc7QUFDMUIsY0FBTSxRQUFRLFdBQVc7QUFDekIsY0FBTSxPQUFPLFdBQVc7QUFDeEIsZUFBTyxFQUFDLFFBQVEsUUFBUSxPQUFPLE1BQU0sVUFBVSxHQUFHLFdBQVcsTUFBTSxJQUFJLFdBQVcsTUFBTSxJQUFJLFdBQVcsVUFBVSxDQUFDLEdBQUU7QUFBQSxNQUN0SDtBQUVPLE1BQU0sT0FBTyxDQUFDLFNBQXlCLGVBQXFDO0FBQ2pGLFFBQUFBLGlCQUFlLFFBQVEsTUFBTTtBQUM3QixnQkFBUSxRQUFRLHNCQUFzQixRQUFRLFFBQVEsVUFBVSxDQUFDO0FBQUEsTUFDbkU7QUFBQTtBQUFBOzs7QUN0SUEsTUFlTSwrQkF3R0EsYUF1SEEsbUNBb0RPO0FBbFNiO0FBQUE7QUFBQTtBQUdBO0FBRUE7QUFHQTtBQU9BLE1BQU0sZ0NBQ0YsQ0FBQyxRQUErQixlQUFvRDtBQUNsRixjQUFNLFNBQVMsT0FBTyxDQUFDLEVBQUU7QUFDekIsY0FBTSxjQUFjO0FBQ3BCLGNBQU0sT0FBTztBQUNiLGNBQU0sWUFBWSxVQUFVLGdCQUFnQixRQUFRLElBQUk7QUFDeEQsY0FBTSxXQUFXLFVBQVUsa0JBQWtCLFFBQVEsSUFBSTtBQUN6RCxjQUFNLGFBQWEsaUJBQWlCLFFBQVE7QUFDNUMsY0FBTSxpQkFBaUIsV0FBVztBQUNsQyxjQUFNLGFBQWEsQ0FBQyxPQUFPLENBQUMsR0FBRyxPQUFPLENBQUMsR0FBRyxjQUFjO0FBQ3hELGNBQU0sb0JBQXdELENBQUMsUUFBUSxRQUFRLE1BQU07QUFDckYsY0FBTSxrQkFDRixDQUFDLEVBQUMsTUFBTSxVQUFVLE1BQU0sU0FBUSxHQUFHLEVBQUMsTUFBTSxVQUFVLE1BQU0sZUFBYyxDQUFDO0FBQzdFLHdCQUFnQixLQUFLLEdBQUcsMkJBQTJCLFVBQVUsR0FBRyxHQUFHLDJCQUEyQixVQUFVLENBQUM7QUFFekcsY0FBTSxrQkFBa0IsQ0FBQyxpQkFBK0I7QUFDdEQsZ0JBQU0sSUFBSSxjQUFjLEtBQUssT0FBTyxDQUFDLEVBQUUsVUFBVSxXQUFXLFFBQVEsVUFBVTtBQUM5RSxnQkFBTSxRQUFRLGNBQWMsU0FBUyxPQUFPLENBQUMsRUFBRSxVQUFVLE9BQU8sQ0FBQyxFQUFFLElBQUk7QUFDdkUsZ0JBQU0sT0FBTyxjQUFjLFFBQVEsT0FBTyxDQUFDLEVBQUUsVUFBVSxPQUFPLENBQUMsRUFBRSxJQUFJO0FBQ3JFLGdCQUFNLFNBQVMsZUFBZSxVQUFVLE9BQU8sQ0FBQyxFQUFFLFVBQVUsV0FBVyxRQUFRLFVBQVU7QUFDekYsZ0JBQU0sWUFBWSxDQUFDLEdBQUcsT0FBTyxNQUFNLE1BQU07QUFDekMsZ0JBQU0sV0FBVyxFQUFFLEtBQUs7QUFDeEIsZ0JBQU0sVUFBVSxlQUFlLElBQUksUUFBUSxNQUFNLFVBQVU7QUFDM0QsZ0JBQU0sZ0JBQWdCO0FBRXRCLGdCQUFNLFdBQThCLENBQUMsRUFBQyxNQUFNLFlBQVksTUFBTSxNQUFLLEdBQUcsRUFBQyxNQUFNLGtCQUFrQixNQUFNLE1BQUssQ0FBQztBQUMzRyxpQkFBTztBQUFBO0FBQUE7QUFBQSwyQ0FHNEIsT0FBTyxLQUFLLGFBQWE7QUFBQSwwQkFDMUMsYUFBYTtBQUFBLElBQ25DLGFBQWEsaUJBQWlCLFFBQVEsRUFBRSxpQkFBaUIsR0FBRyxTQUFTLENBQUM7QUFBQSxJQUN0RSxhQUFhLFVBQVUsYUFBYSxDQUFDO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsb0JBT3JCLE9BQU87QUFBQTtBQUFBLDRCQUVDLE9BQU8sSUFBSSxFQUFFLElBQUksU0FBUyxXQUFXLEdBQUcsQ0FBQztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLHFCQWFoRCxVQUFVLHNCQUFzQixVQUFVLENBQUM7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLGdCQUtoRCxPQUFPO0FBQUE7QUFBQSx5QkFFRSxPQUFPLElBQUksRUFBRSxJQUFJLFNBQVMsV0FBVyxHQUFHLENBQUMsT0FBTyxPQUFPO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSw0QkFjcEQsVUFBVSxzQkFBc0IsVUFBVSxDQUFDO0FBQUE7QUFBQTtBQUFBO0FBQUEsbUZBSVksV0FBVyxPQUFPO0FBQUEseUNBQzVELE1BQU0sWUFBWSxTQUFTLENBQUM7QUFBQSw2QkFDeEMsS0FBSyxZQUFZLFNBQVMsQ0FBQztBQUFBO0FBQUEsb0JBRXBDLEVBQUUsSUFBSSxTQUFTLFdBQVcsR0FBRyxDQUFDLE1BQU0sUUFBUSxJQUFJLE9BQU8scUJBQXFCLFFBQVEsSUFDNUYsT0FBTztBQUFBLFFBQ1gsT0FBTyxJQUFJLFNBQVMsV0FBVyxLQUFLLE9BQU8sQ0FBQztBQUFBO0FBQUE7QUFBQSxRQUc5QztBQUNBLGVBQU87QUFBQSxVQUNMLEdBQUcsRUFBQyxNQUFNLHdCQUF1QjtBQUFBO0FBQUEsVUFFakMsYUFBYSxFQUFDLE1BQU0sR0FBRyxXQUFXLE9BQU8sSUFBSSxVQUFVLElBQUksa0JBQWlCO0FBQUEsVUFDNUUsWUFBWSxPQUFPO0FBQUEsWUFDakIsU0FBUztBQUFBLGNBQ1AsRUFBQyxNQUFNLGFBQWEsVUFBVSxPQUFPLENBQUMsRUFBRSxTQUFRO0FBQUEsWUFDbEQ7QUFBQSxZQUNBLGVBQWUsRUFBQyxHQUFHLFVBQVM7QUFBQSxZQUM1QjtBQUFBLFVBQ0Y7QUFBQSxVQUNBO0FBQUEsUUFDRjtBQUFBLE1BQ0Y7QUFFSixNQUFNLGNBQ0YsQ0FBQyxTQUF5QixPQUFtQixPQUFtQixNQUFrQixHQUFXLEdBQVcsR0FDdkcsWUFBb0I7QUFDbkIsY0FBTSxhQUFhLGlCQUFpQixDQUFDO0FBQ3JDLGNBQU0sS0FBSztBQUdYLGNBQU0sYUFBYSxlQUFlLElBQUksVUFBVSxRQUFRLFVBQVU7QUFDbEUsY0FBTSxjQUFjLGVBQWUsSUFBSSxRQUFRLE1BQU0sVUFBVTtBQUMvRCxjQUFNLGlCQUFpQixDQUFDLE1BQWMsU0FBaUIsR0FBRyxVQUFVLElBQUksSUFBSSxLQUFLLElBQUk7QUFDckYsY0FBTSxjQUFjLElBQUksSUFBSTtBQUM1QixjQUFNLFNBQVMsS0FBSyxLQUFLLElBQUksRUFBRTtBQUUvQixjQUFNLHdCQUE0RCxDQUFDLE1BQU07QUFDekUsY0FBTSxzQkFBd0M7QUFBQSxVQUM1QyxFQUFDLE1BQU0sVUFBVSxNQUFNLE9BQU07QUFBQSxVQUFHLEVBQUMsTUFBTSxVQUFVLE1BQU0sRUFBQztBQUFBLFVBQUcsRUFBQyxNQUFNLFVBQVUsTUFBTSxLQUFLLE1BQU0sSUFBSSxVQUFVLEVBQUM7QUFBQSxVQUM1RyxFQUFDLE1BQU0sVUFBVSxNQUFNLEtBQUssTUFBTSxJQUFJLElBQUksVUFBVSxFQUFDO0FBQUEsUUFDdkQ7QUFFQSxjQUFNLHNCQUFzQixDQUFDLGlCQUErQjtBQUMxRCxnQkFBTSxjQUFjLGNBQWMsU0FBUyxNQUFNLFVBQVUsTUFBTSxNQUFNLFVBQVU7QUFDakYsaUJBQU87QUFBQSxJQUNYLGFBQWEsaUJBQWlCLFdBQVcsQ0FBQztBQUFBLGtFQUNvQixVQUFVO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFJeEUsYUFBYSxVQUFVLEVBQUUsQ0FBQztBQUFBLDRDQUNjLEVBQUU7QUFBQSwrQ0FDQyxFQUFFO0FBQUEsOEJBQ25CLEVBQUU7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLGdCQVFoQixXQUFXLE9BQU8sVUFBVSxDQUFDO0FBQUEsdUJBQ3RCLFdBQVcsT0FBTyxVQUFVLENBQUM7QUFBQTtBQUFBLHNCQUU5QixXQUFXO0FBQUE7QUFBQTtBQUFBO0FBQUEsMkJBSU4sZUFBZSxPQUFPLFlBQVksQ0FBQztBQUFBO0FBQUEsUUFFeEQ7QUFFQSxjQUFNLGFBQWEsUUFBUTtBQUFBLFVBQ3ZCO0FBQUEsWUFDRSxNQUFNO0FBQUEsWUFDTixhQUFhLEVBQUMsTUFBTSxHQUFHLFVBQVUsSUFBSSxtQkFBbUIsc0JBQXFCO0FBQUEsWUFDN0UsWUFBWSxPQUFPO0FBQUEsY0FDakIsU0FBUztBQUFBLGdCQUNQLEVBQUMsTUFBTSxDQUFDLEdBQUcsR0FBRyxJQUFJLENBQUMsR0FBRyx3QkFBd0I7QUFBQSxjQUNoRDtBQUFBLGNBQ0EsZUFBZSxFQUFDLEdBQUcsSUFBSSxJQUFJLFdBQVU7QUFBQSxjQUNyQyxpQkFBaUI7QUFBQSxZQUNuQjtBQUFBLFlBQ0EsaUJBQWlCO0FBQUEsVUFDbkI7QUFBQSxVQUNBLEVBQUMsUUFBUSxDQUFDLEtBQUssR0FBRyxTQUFTLENBQUMsRUFBRSxFQUFDO0FBQUEsUUFBQyxFQUFFLENBQUM7QUFFdkMsY0FBTSxrQkFBb0M7QUFBQSxVQUN4QyxFQUFDLE1BQU0sVUFBVSxNQUFNLFlBQVc7QUFBQSxVQUFHLEVBQUMsTUFBTSxVQUFVLE1BQU0sRUFBQztBQUFBLFVBQzdELEVBQUMsTUFBTSxVQUFVLE1BQU0sS0FBSyxNQUFNLElBQUksVUFBVSxFQUFDO0FBQUEsVUFBRyxFQUFDLE1BQU0sVUFBVSxNQUFNLEtBQUssTUFBTSxLQUFLLElBQUksVUFBVSxFQUFDO0FBQUEsUUFDNUc7QUFDQSxjQUFNLG9CQUF3RCxDQUFDLFFBQVEsUUFBUSxNQUFNO0FBQ3JGLGNBQU0sa0JBQWtCLENBQUMsaUJBQStCO0FBQ3RELGdCQUFNLGNBQWMsY0FBYyxTQUFTLE1BQU0sVUFBVSxNQUFNLE1BQU0sVUFBVTtBQUNqRixnQkFBTSxhQUFhLGNBQWMsUUFBUSxLQUFLLFVBQVUsS0FBSyxNQUFNLFVBQVU7QUFDN0UsaUJBQU87QUFBQSwyREFDNEMsVUFBVTtBQUFBLDJEQUNWLFlBQVksS0FBSyxPQUFPO0FBQUEsMERBQ3pCLFdBQVcsS0FBSyxPQUFPO0FBQUEsa0VBQ2YsVUFBVTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBSXhFLGFBQWEsVUFBVSxDQUFDO0FBQUEsTUFDdEIsYUFBYSxzQ0FBc0Msd0JBQXdCLENBQUM7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLGdCQUtsRSxXQUFXLE9BQU8sVUFBVSxDQUFDO0FBQUEsdUJBQ3RCLFdBQVcsT0FBTyxVQUFVLENBQUM7QUFBQSwrQkFDckIsRUFBRTtBQUFBLGdFQUMrQixFQUFFO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLCtEQU1ILE9BQU87QUFBQSxxQ0FDakMsV0FBVztBQUFBLHlCQUN2QixXQUFXO0FBQUE7QUFBQSwyQkFFVCxlQUFlLGdCQUFnQixjQUFjLENBQUM7QUFBQTtBQUFBLFFBRW5FO0FBQ0EsZUFBTyxRQUFRO0FBQUEsVUFDWDtBQUFBLFlBQ0UsTUFBTTtBQUFBO0FBQUEsWUFFTixhQUFhLEVBQUMsTUFBTSxHQUFHLFVBQVUsSUFBSSxPQUFPLElBQUksa0JBQWlCO0FBQUEsWUFDakUsWUFBWSxPQUFPO0FBQUEsY0FDakIsU0FBUztBQUFBLGdCQUNQLEVBQUMsTUFBTSxDQUFDLEdBQUcsR0FBRyxDQUFDLEdBQUcsd0JBQXdCO0FBQUEsY0FDNUM7QUFBQSxjQUNBLGVBQWUsRUFBQyxHQUFHLEtBQUs7QUFBQSxnQkFBSyxjQUFjO0FBQUE7QUFBQSxjQUF1QixFQUFDO0FBQUEsY0FDbkU7QUFBQSxZQUNGO0FBQUEsWUFDQTtBQUFBLFVBQ0Y7QUFBQSxVQUNBLEVBQUMsUUFBUSxDQUFDLFlBQVksT0FBTyxJQUFJLEdBQUcsU0FBUyxDQUFDLEVBQUUsRUFBQztBQUFBLFFBQUMsRUFBRSxDQUFDO0FBQUEsTUFDM0Q7QUFFSixNQUFNLG9DQUNGLENBQUMsU0FBeUIsUUFBK0IsZUFBdUM7QUFDOUYsY0FBTSxTQUFTLE9BQU8sQ0FBQyxFQUFFO0FBQ3pCLGNBQU0sY0FBYztBQUNwQixjQUFNLElBQUksT0FBTyxDQUFDO0FBQ2xCLGNBQU0sSUFBSSxPQUFPLE9BQU8sU0FBUyxDQUFDO0FBQ2xDLGNBQU0sSUFBSSxVQUFVLGtCQUFrQixRQUFRLENBQUMsSUFBSTtBQUNuRCxjQUFNLGFBQWEsaUJBQWlCLENBQUM7QUFDckMsY0FBTSxhQUFhLFVBQVUsS0FBSyxXQUFXLElBQUk7QUFDakQsY0FBTSxrQkFDRixDQUFDLEVBQUMsTUFBTSxVQUFVLE1BQU0sRUFBQyxHQUFHLEVBQUMsTUFBTSxVQUFVLE1BQU0sS0FBSyxNQUFNLElBQUksVUFBVSxFQUFDLENBQUM7QUFDbEYsY0FBTSxvQkFBd0QsQ0FBQyxRQUFRLE1BQU07QUFFN0UsY0FBTSxvQkFBb0IsWUFBWSxTQUFTLE9BQU8sQ0FBQyxHQUFHLE9BQU8sQ0FBQyxHQUFHLE9BQU8sQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLFdBQVcsT0FBTztBQUMzRyxjQUFNLGtCQUFrQixDQUFDLGlCQUErQjtBQUN0RCxnQkFBTSxXQUFXLDRCQUE0QixPQUFPLENBQUMsRUFBRSxRQUFRO0FBQy9ELGdCQUFNLFlBQVksZUFBZSxJQUFJLFVBQVUsUUFBUSxVQUFVO0FBQ2pFLGdCQUFNLGdCQUFnQixlQUFlLElBQUksV0FBVyxNQUFNLFVBQVUsSUFBSSxRQUFRO0FBRWhGLGdCQUFNLGNBQWMsY0FBYyxTQUFTLE9BQU8sQ0FBQyxFQUFFLFVBQVUsT0FBTyxDQUFDLEVBQUUsTUFBTSxVQUFVO0FBQ3pGLGdCQUFNLGVBQWUsZUFBZSxVQUFVLE9BQU8sQ0FBQyxFQUFFLFVBQVUsYUFBYSxVQUFVO0FBRXpGLGlCQUFPO0FBQUEsMkRBQzRDLFlBQVksS0FBSyxPQUFPO0FBQUEsZ0VBQ25CLFNBQVM7QUFBQSxrRUFDUCxhQUFhLEtBQUssT0FBTztBQUFBO0FBQUE7QUFBQTtBQUFBLElBSXZGLGFBQWEsVUFBVSxDQUFDO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLGtEQU1zQixhQUFhLGVBQWUsYUFBYTtBQUFBO0FBQUEsUUFFckY7QUFDQSxnQkFBUTtBQUFBLFVBQ0o7QUFBQSxZQUNFLE1BQU07QUFBQSxZQUNOLGFBQWEsRUFBQyxNQUFNLEdBQUcsVUFBVSxJQUFJLGtCQUFpQjtBQUFBLFlBQ3RELFlBQVksT0FBTztBQUFBLGNBQ2pCLFNBQVMsQ0FBQyxFQUFDLE1BQU0sYUFBYSxVQUFVLE9BQU8sQ0FBQyxFQUFFLFNBQVEsQ0FBQztBQUFBLGNBQzNELGVBQWUsRUFBQyxHQUFHLEtBQUs7QUFBQSxnQkFBSyxhQUFhO0FBQUE7QUFBQSxjQUF1QixFQUFDO0FBQUEsY0FDbEU7QUFBQSxZQUNGO0FBQUEsWUFDQTtBQUFBLFVBQ0Y7QUFBQSxVQUNBLEVBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxHQUFHLGlCQUFpQixFQUFDO0FBQUEsUUFBQztBQUFBLE1BQzlDO0FBRUcsTUFBTSxlQUFlLENBQUMsU0FBeUIsZUFBNkM7QUFDakcsWUFBSSxXQUFXLFdBQVcsUUFBUTtBQUNoQyw0Q0FBa0MsU0FBUyxRQUFRLFFBQVEsVUFBVTtBQUFBLFFBQ3ZFLE9BQU87QUFDTCxrQkFBUSxRQUFRLDhCQUE4QixRQUFRLFFBQVEsVUFBVSxDQUFDO0FBQUEsUUFDM0U7QUFBQSxNQUNGO0FBQUE7QUFBQTs7O0FDeFNBLE1BZU1DLGtCQU1BLDRCQTBHTztBQS9IYjtBQUFBO0FBQUE7QUFHQTtBQUVBO0FBR0E7QUFPQSxNQUFNQSxtQkFBaUIsQ0FBQyxXQUF3QztBQUM5RCxZQUFJLENBQUMsVUFBVSxPQUFPLFNBQVMsR0FBRztBQUNoQyxnQkFBTSxJQUFJLE1BQU0sdUNBQXVDO0FBQUEsUUFDekQ7QUFBQSxNQUNGO0FBRUEsTUFBTSw2QkFDRixDQUFDLFFBQStCLFlBQWlDLGdCQUFxQztBQUNwRyxjQUFNLFNBQVMsT0FBTyxDQUFDLEVBQUU7QUFDekIsY0FBTSxRQUFRLE9BQU8sQ0FBQztBQUN0QixjQUFNLE9BQU8sT0FBTyxDQUFDO0FBRXJCLGNBQU0sY0FBYztBQUNwQixjQUFNLE9BQU8sVUFBVSxjQUFjLFdBQVcsTUFBTSxPQUFPLE1BQU07QUFDbkUsY0FBTSxZQUFZLFVBQVUsZ0JBQWdCLFFBQVEsSUFBSTtBQUN4RCxjQUFNLFdBQVcsVUFBVSxrQkFBa0IsUUFBUSxJQUFJO0FBRXpELGNBQU0sWUFBWSxVQUFVLEtBQUssTUFBTSxJQUFJO0FBQzNDLGNBQU0sV0FBVyxPQUFPLFVBQVUsS0FBSyxLQUFLLElBQUksSUFBSTtBQUNwRCxZQUFJLGNBQWMsWUFBYSxRQUFRLGFBQWEsVUFBVztBQUM3RCxnQkFBTSxJQUFJLE1BQU0sK0JBQStCLFFBQVE7QUFBQTtBQUFBLDJCQUVwQyxTQUFTLHFCQUFxQixRQUFRLEVBQUU7QUFBQSxRQUM3RDtBQUVBLGNBQU0sbUJBQTZCLENBQUM7QUFDcEMsaUJBQVMsSUFBSSxHQUFHLElBQUksT0FBTyxRQUFRLEVBQUUsR0FBRztBQUN0QyxjQUFJLElBQUksTUFBTTtBQUNaLDZCQUFpQixLQUFLLE9BQU8sQ0FBQyxDQUFDO0FBQUEsVUFDakMsT0FBTztBQUNMLDZCQUFpQixLQUFLLENBQUM7QUFBQSxVQUN6QjtBQUFBLFFBQ0Y7QUFDQSxjQUFNLGFBQWEsaUJBQWlCLFFBQVE7QUFDNUMsY0FBTSxvQkFBd0QsQ0FBQyxRQUFRLE1BQU07QUFDN0UsY0FBTSxrQkFBb0M7QUFBQSxVQUN4QyxFQUFDLE1BQU0sVUFBVSxNQUFNLFVBQVM7QUFBQSxVQUFHLEVBQUMsTUFBTSxXQUFXLE1BQU0sU0FBUTtBQUFBLFVBQ25FLEVBQUMsTUFBTSxVQUFVLE1BQU0sS0FBSyxNQUFNLFdBQVcsVUFBVSxFQUFDO0FBQUEsVUFBRyxFQUFDLE1BQU0sV0FBVyxNQUFNLFdBQVcsUUFBTztBQUFBLFFBQ3ZHO0FBQ0EsWUFBSSxNQUFNO0FBQ1IsNEJBQWtCLEtBQUssTUFBTTtBQUFBLFFBQy9CO0FBQ0EsY0FBTSxvQkFBb0IsY0FBYztBQUN4QyxjQUFNLGtCQUFrQixjQUFjO0FBRXRDLGNBQU0sa0JBQWtCLENBQUMsaUJBQStCO0FBQ3RELGdCQUFNLFdBQVcsNEJBQTRCLE9BQU8sQ0FBQyxFQUFFLFFBQVE7QUFDL0QsZ0JBQU0sWUFBWTtBQUFBLFlBQ2hCLGNBQWMsS0FBSyxPQUFPLENBQUMsRUFBRSxVQUFVLE9BQU8sQ0FBQyxFQUFFLE1BQU0sVUFBVTtBQUFBLFlBQ2pFLGNBQWMsU0FBUyxNQUFNLFVBQVUsTUFBTSxNQUFNLFVBQVU7QUFBQSxVQUMvRDtBQUNBLGNBQUksTUFBTTtBQUNSLHNCQUFVLEtBQUssY0FBYyxRQUFRLEtBQUssVUFBVSxLQUFLLE1BQU0sVUFBVSxDQUFDO0FBQUEsVUFDNUU7QUFDQSxvQkFBVSxLQUFLLGVBQWUsVUFBVSxPQUFPLENBQUMsRUFBRSxVQUFVLGFBQWEsVUFBVSxDQUFDO0FBQ3BGLGNBQUksbUJBQW1CO0FBQ3JCLHNCQUFVLEtBQUssZUFBZSxtQ0FBb0MsZ0JBQWdCLENBQUM7QUFBQSxVQUNyRjtBQUNBLGNBQUksaUJBQWlCO0FBQ25CLHNCQUFVLEtBQUssZUFBZSxpQ0FBa0MsZ0JBQWdCLENBQUM7QUFBQSxVQUNuRjtBQUVBLGdCQUFNLFdBQThCO0FBQUEsWUFDbEMsRUFBQyxNQUFNLGNBQWMsTUFBTSxNQUFLO0FBQUEsWUFBRyxFQUFDLE1BQU0sYUFBYSxNQUFNLE1BQUs7QUFBQSxZQUNsRSxFQUFDLE1BQU0sd0JBQXdCLE1BQU0sTUFBSztBQUFBLFlBQUcsRUFBQyxNQUFNLFdBQVcsTUFBTSxNQUFLO0FBQUEsVUFDNUU7QUFDQSxpQkFBTztBQUFBLElBQ1gsYUFBYSxpQkFBaUIsUUFBUSxFQUFFLGlCQUFpQixHQUFHLFNBQVMsQ0FBQztBQUFBLElBQ3RFLGFBQWEsVUFBVSxDQUFDO0FBQUEsTUFDdEIsYUFBYSxzQ0FBc0MscUJBQXFCLENBQUM7QUFBQTtBQUFBLHVCQUV4RCxXQUFXLE9BQU8sVUFBVSxDQUFDO0FBQUEsNkJBQ3ZCLFdBQVcsT0FBTyxVQUFVLENBQUM7QUFBQTtBQUFBO0FBQUEsb0JBR3RDLFVBQVUsVUFBVSxZQUFZLGVBQWUsQ0FBQztBQUFBO0FBQUE7QUFBQTtBQUFBLGlCQUluRCxVQUFVLGNBQWMsVUFBVSxDQUFDO0FBQUE7QUFBQSxzQkFFOUIsVUFBVSxvQkFBb0IsVUFBVSxDQUFDO0FBQUE7QUFBQTtBQUFBLHVCQUd4QyxVQUFVLFVBQVUsWUFBWSxlQUFlLENBQUM7QUFBQSx1QkFDaEQsVUFBVSxVQUFVLFlBQVksVUFBVSxDQUFDO0FBQUEsNkJBQ3JDLFVBQVUsQ0FBQyxFQUFFLEtBQUssS0FBSztBQUFBLFVBQzFDLE9BQU8sS0FBSyxVQUFVLFVBQVUsWUFBWSxTQUFTLENBQUMsS0FBSyxFQUFFO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFJakUsb0JBQW9CLHdDQUF3QyxFQUFFO0FBQUEsTUFDOUQsa0JBQWtCLDJDQUEyQyxFQUFFO0FBQUE7QUFBQSxRQUUvRDtBQUNBLGNBQU0sVUFBVSxDQUFDLEVBQUMsTUFBTSxhQUFhLFVBQVUsT0FBTyxDQUFDLEVBQUUsU0FBUSxDQUFDO0FBQ2xFLFlBQUksbUJBQW1CO0FBQ3JCLGtCQUFRLEtBQUssRUFBQyxNQUFNLGtCQUFrQix3QkFBd0IsQ0FBQztBQUFBLFFBQ2pFO0FBQ0EsWUFBSSxpQkFBaUI7QUFDbkIsa0JBQVEsS0FBSyxFQUFDLE1BQU0sa0JBQWtCLHdCQUF3QixDQUFDO0FBQUEsUUFDakU7QUFFQSxlQUFPO0FBQUEsVUFDTCxNQUFNO0FBQUEsVUFDTixhQUFhLEVBQUMsTUFBTSxHQUFHLFVBQVUsSUFBSSxXQUFXLElBQUksa0JBQWlCO0FBQUEsVUFDckUsWUFBWSxPQUNQLEVBQUMsU0FBUyxlQUFlLEVBQUMsR0FBRyxLQUFLO0FBQUEsWUFBSyxZQUFZO0FBQUE7QUFBQSxVQUF1QixFQUFDLEdBQUcsZ0JBQWU7QUFBQSxVQUNsRztBQUFBLFFBQ0Y7QUFBQSxNQUNGO0FBRUcsTUFBTSxZQUFZLENBQUMsU0FBeUIsZUFBMEM7QUFDM0YsUUFBQUEsaUJBQWUsUUFBUSxNQUFNO0FBQzdCLGdCQUFRLFFBQVEsMkJBQTJCLFFBQVEsUUFBUSxZQUFZLFFBQVEsV0FBVyxDQUFDO0FBQUEsTUFDN0Y7QUFBQTtBQUFBOzs7QUNsSUEsTUFZTUMsa0JBME5PLG1DQUdQQywyQkFFQSxrQkF3Q0EsZ0NBMkJPO0FBOVNiO0FBQUE7QUFBQTtBQUlBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBLE1BQU1ELG1CQUFpQixDQUFDLFFBQStCLGVBQW9EO0FBQ3pHLGNBQU0sUUFBUSxPQUFPLENBQUM7QUFDdEIsY0FBTSxNQUFNLE9BQU8sQ0FBQztBQUNwQixjQUFNLFFBQVEsT0FBTyxDQUFDO0FBQ3RCLGNBQU0sT0FBTyxPQUFPLENBQUM7QUFDckIsY0FBTSxpQkFBaUIsT0FBTyxDQUFDO0FBQy9CLGNBQU0sdUJBQXVCLE9BQU8sQ0FBQztBQUNyQyxjQUFNLFVBQVUsT0FBTyxDQUFDO0FBQ3hCLGNBQU0sWUFBWSxPQUFPLENBQUM7QUFvQzFCLFlBQUksTUFBTSxLQUFLLFdBQVcsS0FBSyxNQUFNLEtBQUssV0FBVyxHQUFHO0FBQ3RELGdCQUFNLElBQUksTUFBTSxtREFBbUQ7QUFBQSxRQUNyRTtBQUVBLGNBQU0sZUFBZTtBQUNyQixjQUFNLFlBQVksTUFBTSxLQUFLLENBQUM7QUFDOUIsY0FBTSxpQkFBaUIsTUFBTSxLQUFLLENBQUM7QUFDbkMsY0FBTSxhQUFhLE1BQU0sS0FBSyxXQUFXLElBQUssZUFBZSxNQUFNLEtBQUssQ0FBQyxJQUFJLElBQUksTUFBTSxLQUFLLENBQUMsSUFDaEQsV0FBVyxXQUFXLE1BQU0sS0FBSyxDQUFDO0FBQy9FLFlBQUksbUJBQW1CO0FBRXZCLFlBQUkscUJBQXFCO0FBQ3pCLFlBQUksb0JBQW9CO0FBQ3hCLGNBQU0sV0FBVyxLQUFLLE1BQU0sYUFBYSxXQUFXLFFBQVE7QUFDNUQsWUFBSSxXQUFXLFdBQVc7QUFDeEIsY0FBSSxRQUFRLEtBQUssV0FBVyxHQUFHO0FBQzdCLGtCQUFNLElBQUksTUFBTSxtREFBbUQ7QUFBQSxVQUNyRTtBQUNBLGNBQUksVUFBVSxLQUFLLFdBQVcsR0FBRztBQUMvQixrQkFBTSxJQUFJLE1BQU0scURBQXFEO0FBQUEsVUFDdkU7QUFDQSwrQkFBcUIsUUFBUSxLQUFLLENBQUM7QUFDbkMsOEJBQW9CLFFBQVEsS0FBSyxDQUFDO0FBQUEsUUFDcEMsV0FBVyxXQUFXLFdBQVc7QUFDL0IsZ0JBQU0sSUFBSSxNQUFNLHdFQUF3RTtBQUFBLFFBQzFGO0FBRUEsWUFBSTtBQUNKLFlBQUksS0FBSztBQUNQLGNBQUksTUFBTSxLQUFLLFdBQVcsR0FBRztBQUMzQixrQkFBTSxJQUFJLE1BQU0sa0VBQWtFO0FBQUEsVUFDcEY7QUFDQSxjQUFJLElBQUksS0FBSyxTQUFTLEtBQUssSUFBSSxLQUFLLFNBQVMsR0FBRztBQUM5QyxrQkFBTSxJQUFJLE1BQU0sdURBQXVEO0FBQUEsVUFDekU7QUFDQSxjQUFJLE1BQU0sS0FBSyxDQUFDLE1BQU0sSUFBSSxLQUFLLENBQUMsR0FBRztBQUNqQyxrQkFBTSxJQUFJLE1BQU0sNERBQTREO0FBQUEsVUFDOUU7QUFFQSxjQUFJLElBQUksS0FBSyxXQUFXLEdBQUc7QUFDekIsZ0JBQUksSUFBSSxLQUFLLENBQUMsTUFBTSxNQUFNLEtBQUssQ0FBQyxHQUFHO0FBQ2pDLG9CQUFNLElBQUksTUFBTSw2REFBNkQ7QUFBQSxZQUMvRTtBQUNBO0FBQ0EsK0JBQW1CLElBQUksS0FBSyxDQUFDO0FBQUEsVUFDL0IsV0FBVyxJQUFJLEtBQUssV0FBVyxHQUFHO0FBQ2hDLGdCQUFJLElBQUksS0FBSyxDQUFDLE1BQU0sV0FBVyxZQUFZLElBQUksS0FBSyxDQUFDLE1BQU0sS0FBSyxJQUFJLEtBQUssQ0FBQyxNQUFNLFVBQVU7QUFDeEYsb0JBQU0sSUFBSSxNQUFNLDRGQUE0RjtBQUFBLFlBQzlHO0FBQ0EsZ0JBQUksT0FBTztBQUNULG9CQUFNLElBQUksTUFBTSx5REFBeUQ7QUFBQSxZQUMzRTtBQUNBO0FBQ0EsK0JBQW1CLElBQUksS0FBSyxDQUFDO0FBQUEsVUFDL0IsT0FBTztBQUNMLGdCQUFJLElBQUksS0FBSyxDQUFDLE1BQU0sV0FBVyxZQUFZLElBQUksS0FBSyxDQUFDLE1BQU0sVUFBVTtBQUNuRSxvQkFBTSxJQUFJLE1BQU0sd0ZBQXdGO0FBQUEsWUFDMUc7QUFFQTtBQUNBLCtCQUFtQixJQUFJLEtBQUssQ0FBQztBQUFBLFVBQy9CO0FBQUEsUUFDRixPQUFPO0FBQ0wsY0FBSSxNQUFNLEtBQUssV0FBVyxLQUFLLE1BQU0sS0FBSyxXQUFXLEdBQUc7QUFDdEQsa0JBQU0sSUFBSSxNQUFNLHVFQUF1RTtBQUFBLFVBQ3pGO0FBQ0EsY0FBSSxNQUFNLEtBQUssV0FBVyxNQUFNLE1BQU0sS0FBSyxDQUFDLE1BQU0sV0FBVyxZQUFZLE1BQU0sS0FBSyxDQUFDLE1BQU0sSUFBSTtBQUM3RixrQkFBTSxJQUFJLE1BQU0sOEZBQThGO0FBQUEsVUFDaEg7QUFFQTtBQUFBLFFBQ0Y7QUFFQSxZQUFJLE1BQU07QUFDUixjQUFJLEtBQUssS0FBSyxXQUFXLEdBQUc7QUFDMUIsa0JBQU0sSUFBSSxNQUFNLDhDQUE4QztBQUFBLFVBQ2hFO0FBRUEsY0FBSSxPQUFPO0FBQ1QsZ0JBQUksTUFBTSxLQUFLLFdBQVcsS0FBSyxNQUFNLEtBQUssQ0FBQyxNQUFNLEdBQUc7QUFDbEQsb0JBQU0sSUFBSSxNQUFNLG9DQUFvQztBQUFBLFlBQ3REO0FBQUEsVUFDRjtBQUFBLFFBQ0Y7QUFFQSxZQUFJO0FBQ0osWUFBSSxnQkFBZ0I7QUFDbEI7QUFDQSxnQkFBTSxXQUFXLGVBQWU7QUFDaEMsY0FBSSxTQUFTLFdBQVcsR0FBRztBQUN6QixnQkFBSSxTQUFTLENBQUMsTUFBTSxXQUFXO0FBQzdCO0FBQUEsWUFDRixXQUFXLFNBQVMsQ0FBQyxNQUFNLElBQUksWUFBWSxHQUFHO0FBQzVDO0FBQUEsWUFDRjtBQUFBLFVBQ0YsV0FBVyxTQUFTLFdBQVcsS0FBSyxTQUFTLENBQUMsTUFBTSxhQUFhLFNBQVMsQ0FBQyxNQUFNLGtCQUFrQjtBQUNqRztBQUFBLFVBQ0Y7QUFDQSxjQUFJLGtDQUE0QztBQUM5QyxrQkFBTSxJQUFJLE1BQU0sMEZBQTBGO0FBQUEsVUFDNUc7QUFDQSxnQkFBTSxJQUFJLE1BQU0sb0JBQW9CO0FBQUEsUUFDdEM7QUFFQSxZQUFJLGVBQWU7QUFDbkIsWUFBSSxjQUFjO0FBQ2xCLFlBQUksT0FBTztBQUNULGNBQUksTUFBTSxLQUFLLFdBQVcsS0FBSyxNQUFNLEtBQUssV0FBVyxHQUFHO0FBQ3RELGtCQUFNLElBQUksTUFBTSxxREFBcUQ7QUFBQSxVQUN2RTtBQUVBLGNBQUksTUFBTSxLQUFLLENBQUMsTUFBTSxNQUFNLEtBQUssQ0FBQyxHQUFHO0FBQ25DLGtCQUFNLElBQUksTUFBTSw4REFBOEQ7QUFBQSxVQUNoRjtBQUVBLGNBQUksTUFBTSxLQUFLLFdBQVcsR0FBRztBQUMzQixnQkFBSSxxQkFBcUIsTUFBTSxLQUFLLENBQUMsR0FBRztBQUN0QyxvQkFBTSxJQUFJLE1BQU0sd0VBQXdFO0FBQUEsWUFDMUY7QUFDQSwwQkFBYyxNQUFNLEtBQUssQ0FBQztBQUFBLFVBQzVCLE9BQU87QUFDTCxnQkFBSSxxQkFBcUIsTUFBTSxLQUFLLENBQUMsR0FBRztBQUN0QyxvQkFBTSxJQUFJLE1BQU0sa0ZBQWtGO0FBQUEsWUFDcEc7QUFDQSwwQkFBYyxNQUFNLEtBQUssQ0FBQyxJQUFJLE1BQU0sS0FBSyxDQUFDO0FBQzFDLDJCQUFlO0FBQUEsVUFDakI7QUFBQSxRQUNGO0FBRUEsY0FBTSxzQkFBc0IscUJBQXFCO0FBQ2pELGNBQU0sc0JBQXNCO0FBTzVCLFlBQUksZ0JBQWdCO0FBQ2xCLGdCQUFNLElBQUksTUFBTSxtQ0FBbUM7QUFBQSxRQUNyRDtBQUNBLFlBQUksc0JBQXNCO0FBQ3hCLGdCQUFNLElBQUksTUFBTSw2QkFBNkI7QUFBQSxRQUMvQztBQUNBLFlBQUksU0FBUztBQUNYLGdCQUFNLElBQUksTUFBTSwwQkFBMEI7QUFBQSxRQUM1QztBQUNBLFlBQUksV0FBVztBQUNiLGdCQUFNLElBQUksTUFBTSw0QkFBNEI7QUFBQSxRQUM5QztBQUVBLGVBQU87QUFBQSxVQUNMO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBLGlCQUFpQjtBQUFBLFVBQ2pCO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBLFdBQVcsS0FBSyxNQUFNLGNBQWMsV0FBVyxRQUFRO0FBQUEsVUFDdkQsVUFBVSxXQUFXO0FBQUEsVUFDckIsa0JBQWtCO0FBQUEsVUFDbEIsd0JBQXdCO0FBQUEsVUFDeEIsaUJBQWlCLFdBQVc7QUFBQSxVQUM1QjtBQUFBLFVBQ0EsT0FBTyxXQUFXO0FBQUEsVUFDbEI7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFFBQ0Y7QUFBQSxNQUNGO0FBRU8sTUFBTSxvQ0FBb0MsQ0FBQyxlQUM5Qyw0QkFBNEIsRUFBQyxHQUFHLFdBQVUsQ0FBQztBQUUvQyxNQUFNQyw0QkFBZ0QsNEJBQTRCLEVBQUMsTUFBTSxDQUFDLEdBQUcsR0FBRyxHQUFHLENBQUMsRUFBQyxDQUFDO0FBRXRHLE1BQU0sbUJBQ0YsQ0FBQyxTQUF5QixLQUFpQixNQUFrQixXQUFtQixnQkFDL0UsWUFBb0IsZUFBdUI7QUFDMUMsY0FBTSxjQUFjLENBQUMsV0FBVyxnQkFBZ0IsVUFBVTtBQUMxRCxjQUFNLGFBQWEsVUFBVSxLQUFLLFdBQVc7QUFDN0MsY0FBTSxrQkFDRixDQUFDLEVBQUMsTUFBTSxVQUFVLE1BQU0sV0FBVSxHQUFHLEVBQUMsTUFBTSxVQUFVLE1BQU0sV0FBVSxHQUFHLEVBQUMsTUFBTSxVQUFVLE1BQU0sV0FBVSxDQUFDO0FBRS9HLGNBQU0sa0JBQWtCLENBQUMsaUJBQStCO0FBQ3RELGdCQUFNLFNBQVMsZUFBZSxpQkFBaUIsSUFBSSxVQUFVLFdBQVc7QUFDeEUsZ0JBQU0sV0FBVyxjQUFjLE9BQU8sSUFBSSxVQUFVLFdBQVc7QUFDL0QsZ0JBQU0sWUFBWSxjQUFjLFFBQVEsS0FBSyxVQUFVLFdBQVc7QUFFbEUsZ0JBQU0sV0FBOEI7QUFBQSxZQUNsQyxFQUFDLE1BQU0sZUFBZSxNQUFNLE1BQUs7QUFBQSxZQUFHLEVBQUMsTUFBTSxlQUFlLE1BQU0sTUFBSztBQUFBLFlBQUcsRUFBQyxNQUFNLGVBQWUsTUFBTSxNQUFLO0FBQUEsVUFDM0c7QUFDQSxpQkFBTztBQUFBLElBQ1gsYUFBYSxpQkFBaUIsUUFBUSxFQUFFLGlCQUFpQixVQUFVLFdBQVcsTUFBTSxDQUFDO0FBQUEsSUFDckYsYUFBYSxVQUFVLENBQUM7QUFBQSxNQUN0QixhQUFhLHNDQUFzQyxzQkFBc0IsQ0FBQztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsUUFLMUU7QUFFQSxlQUFPLFFBQVE7QUFBQSxVQUNYO0FBQUEsWUFDRSxNQUFNO0FBQUEsWUFDTixhQUFhLEVBQUMsbUJBQW1CLENBQUMsUUFBUSxNQUFNLEVBQUM7QUFBQSxZQUNqRCxZQUFZLE9BQU87QUFBQSxjQUNqQixTQUFTLENBQUMsRUFBQyxNQUFNLGFBQWEsVUFBVSxJQUFJLFVBQVUsNkJBQWdDLENBQUM7QUFBQSxjQUN2RixlQUFlLEVBQUMsR0FBRyxLQUFLO0FBQUEsZ0JBQUssYUFBYTtBQUFBO0FBQUEsY0FBdUIsRUFBQztBQUFBLGNBQ2xFO0FBQUEsWUFDRjtBQUFBLFlBQ0E7QUFBQSxVQUNGO0FBQUEsVUFDQSxFQUFDLFFBQVEsQ0FBQyxLQUFLLElBQUksR0FBRyxTQUFTLENBQUMsRUFBRSxFQUFDO0FBQUEsUUFBQyxFQUFFLENBQUM7QUFBQSxNQUM3QztBQUVKLE1BQU0saUNBQ0YsQ0FBQyxTQUF5QixXQUFtQixVQUFrQixnQkFBd0IsVUFDdEYsT0FBbUIsTUFBbUIsZUFBd0I7QUFHN0QsWUFBSSxnQkFBZ0I7QUFDcEIsWUFBSSxDQUFDLE1BQU07QUFDVCxjQUFJLE1BQU0sS0FBSyxXQUFXLEdBQUc7QUFDM0IsNEJBQWdCLE1BQU0sUUFBUSxDQUFDLFdBQVcsZ0JBQWdCLFVBQVUsUUFBUSxDQUFDO0FBQUEsVUFDL0U7QUFDQSxpQkFBTyxRQUFRO0FBQUEsWUFDWCwyQkFBMkIsZUFBZUEsMEJBQXlCLElBQUk7QUFBQSxZQUN2RSxFQUFDLFFBQVEsQ0FBQyxhQUFhLEdBQUcsU0FBUyxDQUFDLEVBQUUsRUFBQztBQUFBLFVBQUMsRUFBRSxDQUFDO0FBQUEsUUFDakQsT0FBTztBQUNMLGNBQUksbUJBQW1CLEdBQUc7QUFDeEIsa0JBQU0sSUFBSSxNQUFNLG1GQUFtRjtBQUFBLFVBQ3JHLE9BQU87QUFDTCw0QkFDSSxpQkFBaUIsU0FBUyxPQUFPLE1BQU0sV0FBVyxnQkFBZ0IsV0FBVyxVQUFVLFVBQVc7QUFDdEcsNEJBQWdCLGNBQWMsUUFBUSxDQUFDLFdBQVcsZ0JBQWdCLFVBQVUsUUFBUSxDQUFDO0FBQ3JGLG1CQUFPLFFBQVE7QUFBQSxjQUNYLDJCQUEyQixlQUFlQSwwQkFBeUIsSUFBSTtBQUFBLGNBQ3ZFLEVBQUMsUUFBUSxDQUFDLGFBQWEsR0FBRyxTQUFTLENBQUMsRUFBRSxFQUFDO0FBQUEsWUFBQyxFQUFFLENBQUM7QUFBQSxVQUNqRDtBQUFBLFFBQ0Y7QUFBQSxNQUNGO0FBRUcsTUFBTSxxQkFBcUIsQ0FBQyxTQUF5QixlQUFxQztBQUMvRixjQUFNLFNBQVNELGlCQUFlLFFBQVEsUUFBUSxVQUFVO0FBRXhELFlBQUksUUFBUSxPQUFPLENBQUMsRUFBRSxLQUFLLFdBQVcsR0FBRztBQUN2QyxnQkFBTSxJQUFJLE1BQU0sK0JBQStCO0FBQUEsUUFDakQ7QUFFQSxZQUFJLFFBQVEsT0FBTyxDQUFDLEdBQUcsS0FBSyxXQUFXLEdBQUc7QUFDeEMsZ0JBQU0sSUFBSSxNQUFNLDhCQUE4QjtBQUFBLFFBQ2hEO0FBR0EsY0FBTSxTQUFTLFFBQVEsT0FBTyxDQUFDLEtBQUssUUFBUSxPQUFPLENBQUMsS0FBSyxRQUFRLE9BQU8sQ0FBQyxFQUFFLEtBQUssV0FBVyxLQUN2RixRQUFRLE9BQU8sQ0FBQyxFQUFFLEtBQUssV0FBVztBQUV0QyxjQUFNLElBQUk7QUFBQSxVQUNOO0FBQUEsVUFBUyxPQUFPO0FBQUEsVUFBVyxPQUFPO0FBQUEsVUFBVSxPQUFPO0FBQUEsVUFBZ0IsT0FBTztBQUFBLFVBQVUsUUFBUSxPQUFPLENBQUM7QUFBQSxVQUNwRyxRQUFRLE9BQU8sQ0FBQztBQUFBLFVBQUc7QUFBQSxRQUFDO0FBRXhCLFlBQUksUUFBUTtBQUNWLGlCQUFPO0FBQUEsWUFDSDtBQUFBLFlBQVM7QUFBQSxZQUFHLFFBQVEsT0FBTyxDQUFDO0FBQUEsWUFBRyxRQUFRLE9BQU8sQ0FBQztBQUFBLFlBQUcsUUFBUSxPQUFPLENBQUM7QUFBQSxZQUFHO0FBQUEsWUFBVztBQUFBLFlBQVc7QUFBQSxZQUMzRixRQUFRLE9BQU8sQ0FBQztBQUFBLFlBQUc7QUFBQSxZQUFRO0FBQUEsVUFBVTtBQUFBLFFBQzNDO0FBRUEsY0FBTSxJQUFJO0FBQUEsVUFDTjtBQUFBLFVBQVMsT0FBTztBQUFBLFVBQVcsT0FBTztBQUFBLFVBQVUsT0FBTztBQUFBLFVBQWtCLE9BQU87QUFBQSxVQUFVLFFBQVEsT0FBTyxDQUFDO0FBQUEsVUFDdEcsUUFBUSxPQUFPLENBQUM7QUFBQSxVQUFHLE9BQU87QUFBQSxRQUFVO0FBRXhDLGNBQU0sSUFBSTtBQUFBLFVBQ047QUFBQSxVQUFTLE9BQU87QUFBQSxVQUFXLE9BQU87QUFBQSxVQUFVLE9BQU87QUFBQSxVQUFrQixPQUFPO0FBQUEsVUFBVyxRQUFRLE9BQU8sQ0FBQztBQUFBLFVBQ3ZHLFFBQVEsT0FBTyxDQUFDO0FBQUEsVUFBRyxJQUFJLE9BQU87QUFBQSxRQUFVO0FBRTVDO0FBQUEsVUFDSTtBQUFBLFVBQVM7QUFBQSxVQUFHO0FBQUEsVUFBRztBQUFBLFVBQUcsUUFBUSxPQUFPLENBQUM7QUFBQSxVQUFHO0FBQUEsVUFBVyxRQUFRLE9BQU8sQ0FBQztBQUFBLFVBQUcsUUFBUSxPQUFPLENBQUM7QUFBQSxVQUFHLFFBQVEsT0FBTyxDQUFDO0FBQUEsVUFBRztBQUFBLFVBQ3pHO0FBQUEsUUFBVTtBQUFBLE1BQ2hCO0FBQUE7QUFBQTs7O0FDbFZBLE1BaUJNRSxrQkFtQkEsZ0JBMEJBLGVBMkJBLFlBdUJBLFlBdUJBLGVBZUEsc0JBa0RBLCtCQTBCTztBQWxPYjtBQUFBO0FBQUE7QUFHQTtBQUVBO0FBR0E7QUFTQSxNQUFNQSxtQkFBaUIsQ0FBQyxXQUF3QztBQUM5RCxZQUFJLENBQUMsVUFBVSxPQUFPLFNBQVMsR0FBRztBQUNoQyxnQkFBTSxJQUFJLE1BQU0sZ0JBQWdCO0FBQUEsUUFDbEM7QUFDQSxZQUFJLE9BQU8sQ0FBQyxFQUFFLDRCQUE2QjtBQUN6QyxnQkFBTSxJQUFJLE1BQU0sMkJBQTJCO0FBQUEsUUFDN0M7QUFFQSxZQUFJLE9BQU8sVUFBVSxHQUFHO0FBQ3RCLGNBQUksWUFBWSxPQUFPLENBQUMsRUFBRSxLQUFLLFNBQVMsTUFBTSxPQUFPLENBQUMsRUFBRSxLQUFLLENBQUM7QUFDOUQsY0FBSSxPQUFPLFdBQVcsR0FBRztBQUN2Qix3QkFBWSxPQUFPLENBQUMsRUFBRSxLQUFLLENBQUMsSUFBSSxNQUFNLE9BQU8sQ0FBQyxFQUFFLEtBQUssQ0FBQztBQUFBLFVBQ3hEO0FBQ0EsY0FBSSxDQUFDLFdBQVc7QUFDZCxrQkFBTSxJQUFJLE1BQU0sNkVBQTZFO0FBQUEsVUFDL0Y7QUFBQSxRQUNGO0FBQUEsTUFDRjtBQUVBLE1BQU0saUJBQWlCLENBQUMsUUFBdUIsV0FBbUIsZUFBK0I7QUFDL0YsWUFBSSxRQUFRO0FBQ1osaUJBQVMsSUFBSSxZQUFZLEdBQUcsS0FBSyxHQUFHLEVBQUUsR0FBRztBQUN2QyxtQkFBUztBQUFBLHNCQUNTLE9BQU8sV0FBVyxXQUFXLENBQUMsQ0FBQyxPQUFPLGFBQWEsaUJBQWlCLEdBQUcsVUFBVSxDQUFDO0FBQUE7QUFBQTtBQUFBO0FBQUEsMkJBSTdFLGFBQWEsb0JBQW9CLEdBQUcsU0FBUyxDQUFDO0FBQUE7QUFBQTtBQUFBLGdDQUd6QyxhQUFhLHNCQUFzQixHQUFHLFNBQVMsQ0FBQztBQUFBO0FBQUEsUUFFOUU7QUFFQSxlQUFPO0FBQUEsb0JBQ1csT0FBTyxLQUFLLEtBQUs7QUFBQTtBQUFBO0FBQUE7QUFBQSxjQUl2QixLQUFLO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFJbkI7QUFFQSxNQUFNLGdCQUFnQixDQUFDLFFBQXVCLFdBQW1CLGVBQStCO0FBQzlGLFlBQUksUUFBUTtBQUNaLGlCQUFTLElBQUksWUFBWSxHQUFHLEtBQUssR0FBRyxFQUFFLEdBQUc7QUFDdkMsbUJBQVM7QUFBQSwwQkFDYSxPQUFPLFdBQVcsV0FBVyxDQUFDLENBQUMsT0FBTyxhQUFhLGlCQUFpQixHQUFHLFVBQVUsQ0FBQztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEseUNBS25FLGFBQWEsb0JBQW9CLEdBQUcsU0FBUyxDQUFDO0FBQUE7QUFBQSxnQ0FFdkQsYUFBYSxvQkFBb0IsR0FBRyxTQUFTLENBQUM7QUFBQTtBQUFBO0FBQUE7QUFBQSxvQ0FJMUMsYUFBYSxzQkFBc0IsR0FBRyxTQUFTLENBQUM7QUFBQTtBQUFBLFFBRWxGO0FBRUEsZUFBTztBQUFBO0FBQUE7QUFBQSxnQkFHTyxLQUFLO0FBQUE7QUFBQTtBQUFBLE1BR3JCO0FBRUEsTUFBTSxhQUFhLENBQUMsUUFBdUIsV0FBbUIsZUFBK0I7QUFDM0YsWUFBSSxRQUFRO0FBQ1osaUJBQVMsSUFBSSxZQUFZLEdBQUcsS0FBSyxHQUFHLEVBQUUsR0FBRztBQUN2QyxtQkFBUztBQUFBLDBCQUNhLE9BQU8sV0FBVyxXQUFXLENBQUMsQ0FBQyxPQUFPLGFBQWEsaUJBQWlCLEdBQUcsVUFBVSxDQUFDO0FBQUE7QUFBQTtBQUFBO0FBQUEsK0JBSTdFLGFBQWEsb0JBQW9CLEdBQUcsU0FBUyxDQUFDO0FBQUEsNEJBQ2pELGFBQWEsb0JBQW9CLEdBQUcsU0FBUyxDQUFDO0FBQUE7QUFBQSxvQ0FFdEMsYUFBYSxzQkFBc0IsR0FBRyxTQUFTLENBQUM7QUFBQTtBQUFBLFFBRWxGO0FBRUEsZUFBTztBQUFBO0FBQUE7QUFBQSxnQkFHTyxLQUFLO0FBQUE7QUFBQTtBQUFBLE1BR3JCO0FBRUEsTUFBTSxhQUFhLENBQUMsUUFBdUIsV0FBbUIsZUFBK0I7QUFDM0YsWUFBSSxRQUFRO0FBQ1osaUJBQVMsSUFBSSxZQUFZLEdBQUcsS0FBSyxHQUFHLEVBQUUsR0FBRztBQUN2QyxtQkFBUztBQUFBLDBCQUNhLE9BQU8sV0FBVyxXQUFXLENBQUMsQ0FBQyxPQUFPLGFBQWEsaUJBQWlCLEdBQUcsVUFBVSxDQUFDO0FBQUE7QUFBQSw2QkFFL0UsYUFBYSxvQkFBb0IsR0FBRyxTQUFTLENBQUM7QUFBQTtBQUFBLCtCQUU1QyxhQUFhLG9CQUFvQixHQUFHLFNBQVMsQ0FBQztBQUFBLDZCQUNoRCxhQUFhLG9CQUFvQixHQUFHLFNBQVMsQ0FBQztBQUFBO0FBQUEsb0NBRXZDLGFBQWEsc0JBQXNCLEdBQUcsU0FBUyxDQUFDO0FBQUE7QUFBQSxRQUVsRjtBQUVBLGVBQU87QUFBQTtBQUFBO0FBQUEsZ0JBR08sS0FBSztBQUFBO0FBQUE7QUFBQSxNQUdyQjtBQUVBLE1BQU0sZ0JBQWdCLENBQUMsUUFBdUIsV0FBbUIsZUFBc0M7QUFDckcsZ0JBQVEsV0FBVyxNQUFNO0FBQUEsVUFDdkIsS0FBSztBQUNILG1CQUFPLGVBQWUsUUFBUSxXQUFXLFdBQVcsS0FBSyxNQUFNO0FBQUEsVUFDakUsS0FBSztBQUNILG1CQUFPLGNBQWMsUUFBUSxXQUFXLFdBQVcsS0FBSyxNQUFNO0FBQUEsVUFDaEUsS0FBSztBQUNILG1CQUFPLFdBQVcsUUFBUSxXQUFXLFdBQVcsS0FBSyxNQUFNO0FBQUEsVUFDN0QsS0FBSztBQUNILG1CQUFPLFdBQVcsUUFBUSxXQUFXLFdBQVcsS0FBSyxNQUFNO0FBQUEsVUFDN0Q7QUFDRSxrQkFBTSxJQUFJLE1BQU0sY0FBYztBQUFBLFFBQ2xDO0FBQUEsTUFDRjtBQUVBLE1BQU0sdUJBQXVCLENBQUMsUUFBK0IsZUFBMkM7QUFDdEcsY0FBTSxjQUFjLFVBQVUsU0FBUyxPQUFPLENBQUMsRUFBRSxLQUFLLE1BQU0sR0FBRyxXQUFXLElBQUk7QUFDOUUsY0FBTSxZQUFZLE9BQU8sQ0FBQyxFQUFFO0FBQzVCLGNBQU0sYUFBYSxVQUFVLEtBQUssV0FBVztBQUM3QyxjQUFNLGtCQUNGLENBQUMsRUFBQyxNQUFNLFVBQVUsTUFBTSxXQUFVLEdBQUcsRUFBQyxNQUFNLFVBQVUsTUFBTSxXQUFXLEtBQUksQ0FBQztBQUNoRixZQUFJLFdBQVcsU0FBUyxHQUFHO0FBQ3pCLGdCQUFNLGlCQUFpQiwyQkFBMkIsT0FBTyxDQUFDLEVBQUUsUUFBUTtBQUNwRSwwQkFBZ0IsS0FBSyxFQUFDLE1BQU0sZ0JBQWdCLE1BQU0sV0FBVyxNQUFLLENBQUM7QUFBQSxRQUNyRTtBQUVBLHdCQUFnQixLQUFLLEdBQUcsMkJBQTJCLE9BQU8sQ0FBQyxFQUFFLElBQUksR0FBRyxHQUFHLDJCQUEyQixXQUFXLENBQUM7QUFDOUcsY0FBTSxvQkFBd0QsQ0FBQyxNQUFNO0FBRXJFLGNBQU0sa0JBQWtCLENBQUMsaUJBQStCO0FBQ3RELGdCQUFNLFNBQVMsZUFBZSxVQUFVLE9BQU8sQ0FBQyxFQUFFLFVBQVUsWUFBWSxNQUFNO0FBQzlFLGdCQUFNLFFBQVEsY0FBYyxLQUFLLE9BQU8sQ0FBQyxFQUFFLFVBQVUsVUFBVSxNQUFNO0FBQ3JFLGdCQUFNLFdBQVcsTUFBTSxLQUFLO0FBQzVCLGdCQUFNLGFBQWEsY0FBYyxRQUFRLFVBQVUsUUFBUSxVQUFVO0FBQ3JFLGdCQUFNLFdBQ0YsQ0FBQyxFQUFDLE1BQU0sZUFBZSxNQUFNLE1BQUssR0FBRyxFQUFDLE1BQU0sUUFBUSxNQUFNLE9BQU8sUUFBUSxXQUFXLEtBQUssT0FBTSxDQUFDO0FBQ3BHLGNBQUksV0FBVyxTQUFTLEdBQUc7QUFDekIscUJBQVMsS0FBSyxFQUFDLE1BQU0sa0JBQWtCLE1BQU0sU0FBa0MsQ0FBQztBQUFBLFVBQ2xGO0FBRUEsaUJBQU87QUFBQSxjQUNHLGFBQWEsaUJBQWlCLFFBQVEsRUFBRSxpQkFBaUIsT0FBTyxNQUFNLENBQUM7QUFBQSxjQUN2RSxhQUFhLFVBQVUsQ0FBQztBQUFBLGNBQ3hCLGFBQWEsc0NBQXNDLHNCQUFzQixDQUFDO0FBQUE7QUFBQSw0QkFFNUQsT0FBTyxnQkFBZ0IsWUFBWSxDQUFDO0FBQUE7QUFBQSwwQkFFdEMsUUFBUTtBQUFBLGNBQ3BCLFVBQVU7QUFBQTtBQUFBO0FBQUEsUUFHdEI7QUFFQSxlQUFPO0FBQUEsVUFDTCxNQUFNO0FBQUEsVUFDTixhQUFhLEVBQUMsTUFBTSxHQUFHLFdBQVcsSUFBSSxJQUFJLGtCQUFpQjtBQUFBLFVBQzNELFlBQVksT0FBTztBQUFBLFlBQ2pCLFNBQVMsQ0FBQyxFQUFDLE1BQU0sYUFBYSxVQUFVLE9BQU8sQ0FBQyxFQUFFLFNBQVEsQ0FBQztBQUFBLFlBQzNELGVBQWUsRUFBQyxHQUFHLEtBQUs7QUFBQSxjQUFLLFVBQVUsS0FBSyxXQUFXLElBQUk7QUFBQTtBQUFBLFlBQXVCLEVBQUM7QUFBQSxZQUNuRjtBQUFBLFVBQ0Y7QUFBQSxVQUNBO0FBQUEsUUFDRjtBQUFBLE1BQ0Y7QUFFQSxNQUFNLGdDQUFnQyxDQUFDLFFBQStCLGVBQTZDO0FBQ2pILFlBQUksT0FBTyxTQUFTLEdBQUc7QUFDckIsZ0JBQU0sZUFBZSxPQUFPLENBQUMsRUFBRSxpQkFBaUI7QUFDaEQsZ0JBQU0sUUFBUyxPQUFPLFVBQVUsS0FBSyxPQUFPLENBQUMsRUFBRSxPQUFRLE9BQU8sQ0FBQyxFQUFFLGdCQUFnQixFQUFFLENBQUMsSUFBSTtBQUV4RixnQkFBTSxZQUFZLE9BQU8sQ0FBQyxFQUFFLEtBQUs7QUFDakMsZ0JBQU0sYUFBYSxJQUFJLFdBQVcsSUFBSSxTQUFTLEVBQUUsS0FBSyxDQUFDO0FBQ3ZELGNBQUksT0FBTyxVQUFVLEdBQUc7QUFDdEIsa0JBQU0sT0FBTyxPQUFPLENBQUMsRUFBRSxpQkFBaUI7QUFDeEMscUJBQVMsSUFBSSxHQUFHLElBQUksS0FBSyxRQUFRLEtBQUs7QUFDcEMseUJBQVcsT0FBTyxLQUFLLENBQUMsQ0FBQyxDQUFDLElBQUksT0FBTyxhQUFhLENBQUMsQ0FBQztBQUNwRCx5QkFBVyxPQUFPLEtBQUssQ0FBQyxDQUFDLElBQUksU0FBUyxJQUFJLE9BQU8sYUFBYSxJQUFJLEtBQUssTUFBTSxDQUFDO0FBQUEsWUFDaEY7QUFBQSxVQUNGLE9BQU87QUFDTCx5QkFBYSxRQUFRLENBQUMsR0FBRyxNQUFNLFdBQVcsT0FBTyxDQUFDLENBQUMsSUFBSyxPQUFPLENBQUMsQ0FBRTtBQUFBLFVBQ3BFO0FBRUEsZ0JBQU0sT0FBaUIsQ0FBQztBQUN4QixxQkFBVyxRQUFRLE9BQUssS0FBSyxLQUFLLENBQUMsQ0FBQztBQUVwQyxpQkFBTyxFQUFDLE1BQU0sV0FBVyxNQUFNLE9BQU8sS0FBSTtBQUFBLFFBQzVDLE9BQU87QUFDTCxpQkFBTztBQUFBLFFBQ1Q7QUFBQSxNQUNGO0FBRU8sTUFBTSxNQUFNLENBQUMsU0FBeUIsZUFBb0M7QUFDL0UsUUFBQUEsaUJBQWUsUUFBUSxNQUFNO0FBQzdCLGNBQU0sb0JBQW9CLDhCQUE4QixRQUFRLFFBQVEsVUFBVTtBQUNsRixnQkFBUSxRQUFRLHFCQUFxQixRQUFRLFFBQVEsaUJBQWlCLEdBQUcsRUFBQyxRQUFRLENBQUMsQ0FBQyxFQUFDLENBQUM7QUFBQSxNQUN4RjtBQUFBO0FBQUE7OztBQ3RPQSxNQWtCTUMsa0JBTUEseUNBNEJBLHNCQTBEQSxxQkFzSkEsK0JBR0EsMENBR0Esc0NBR0EsMkJBYUEsOEJBaUNPLDRCQVlBLGFBS1Asc0JBV08sa0NBS0EsbUJBVVAsMEJBNEJPLFNBS0Esd0JBZ0JBLDhCQUtBO0FBNVpiO0FBQUE7QUFBQTtBQUdBO0FBR0E7QUFJQTtBQVFBLE1BQU1BLG1CQUFpQixDQUFDLFdBQXdDO0FBQzlELFlBQUlDLEtBQUksT0FBTyx5QkFBeUIsQ0FBQyxVQUFVLE9BQU8sV0FBVyxJQUFJO0FBQ3ZFLGdCQUFNLElBQUksTUFBTSw0QkFBNEI7QUFBQSxRQUM5QztBQUFBLE1BQ0Y7QUFFQSxNQUFNLDBDQUEwQyxDQUM1QyxPQUFtQixZQUEyQixxQkFBeUQ7QUFDekcsY0FBTSxpQkFBaUIsV0FBVyxXQUFXO0FBQzdDLGNBQU0sMkJBQTJCLE1BQU0sS0FBSyxNQUFNO0FBQ2xELFlBQUksZ0JBQWdCO0FBQ2xCLG1DQUF5QixPQUFPLEdBQUcsR0FBRyx5QkFBeUIsSUFBSSxDQUFFO0FBQUEsUUFDdkU7QUFDQSxjQUFNLGVBQWUsT0FBTyxlQUFlLEtBQUssWUFBWSxXQUFXO0FBQ3ZFLGNBQU0sY0FBYyxXQUFXLFlBQVksTUFBTTtBQUNqRCxjQUFNLFVBQVUsV0FBVyxRQUFRLE1BQU07QUFDekMsY0FBTSxZQUFzQixlQUFnQixXQUFpQyxVQUFVLE1BQU0sSUFBSSxDQUFDO0FBQ2xHLGNBQU0sT0FBTyxXQUFXLEtBQUssTUFBTTtBQUNuQyxxQkFBYSxxQkFBcUIsa0JBQWtCLDBCQUEwQixhQUFhLFNBQVMsV0FBVyxJQUFJO0FBRW5ILGNBQU0sNEJBQTRCLGFBQWE7QUFBQSxVQUMzQztBQUFBLFVBQWtCO0FBQUEsVUFBMEI7QUFBQSxVQUFTO0FBQUEsVUFBVztBQUFBLFVBQWE7QUFBQSxVQUFNLFdBQVc7QUFBQSxRQUFPO0FBRXpHLGNBQU0sZ0JBQWdCLE9BQU8sT0FBTyxDQUFDLEdBQUcsVUFBVTtBQUNsRCxZQUFJLGNBQWM7QUFDaEIsaUJBQU8sT0FBTyxlQUFlLEVBQUMsYUFBYSxTQUFTLE1BQU0sV0FBVyxVQUFVLFdBQVcsU0FBUSxDQUFDO0FBQUEsUUFDckcsT0FBTztBQUNMLGlCQUFPLE9BQU8sZUFBZSxFQUFDLGFBQWEsU0FBUyxNQUFNLFVBQVUsV0FBVyxTQUFRLENBQUM7QUFBQSxRQUMxRjtBQUNBLGNBQU0sMkJBQTJCLDBCQUEwQixNQUFNO0FBQ2pFLGlDQUF5QixLQUFLLHlCQUF5QixPQUFPLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQztBQUN0RSxlQUFPLENBQUMsZUFBZSxpQkFBaUIsMkJBQTJCLHlCQUF5QjtBQUFBLE1BQzlGO0FBRUEsTUFBTSx1QkFBdUIsQ0FDekIsYUFDQSxlQUFnRztBQUNsRyxjQUFNLGlCQUFpQixXQUFXLFdBQVc7QUFDN0MsY0FBTSxhQUFhLFVBQVUsS0FBSyxXQUFXO0FBQzdDLGNBQU0sYUFBYSxVQUFVLEtBQUssV0FBVyxXQUFXO0FBQ3hELGNBQU0sa0JBQW9DLENBQUMsRUFBQyxNQUFNLFVBQVUsTUFBTSxXQUFVLEdBQUcsRUFBQyxNQUFNLFVBQVUsTUFBTSxXQUFVLENBQUM7QUFDakgsY0FBTSxXQUE4QixDQUFDLEVBQUMsTUFBTSxjQUFjLE1BQU0sTUFBSyxHQUFHLEVBQUMsTUFBTSxjQUFjLE1BQU0sTUFBSyxDQUFDO0FBQ3pHLFlBQUksV0FBVyxZQUFZLFVBQVUsR0FBRztBQUN0QyxnQkFBTSxLQUFLLFdBQVcsWUFBWSxXQUFXLFlBQVksU0FBUyxDQUFDO0FBQ25FLGdCQUFNLEtBQUssV0FBVyxRQUFRLFdBQVcsUUFBUSxTQUFTLENBQUM7QUFDM0QsZ0JBQU0sVUFBVSxXQUFXLEtBQUssV0FBVyxLQUFLLFNBQVMsSUFBSSxDQUFDO0FBQzlELGdCQUFNLFFBQVEsV0FBVyxLQUFLLFdBQVcsS0FBSyxTQUFTLENBQUM7QUFDeEQsZ0JBQU0sb0JBQW9CLENBQUMsRUFBRSxVQUFVO0FBQ3ZDLDBCQUFnQjtBQUFBLFlBQ1osRUFBQyxNQUFNLFVBQVUsTUFBTSxHQUFFO0FBQUEsWUFDekIsRUFBQyxNQUFNLFVBQVUsTUFBTSxHQUFFO0FBQUEsWUFDekIsRUFBQyxNQUFNLFVBQVUsTUFBTSxRQUFPO0FBQUEsWUFDOUIsRUFBQyxNQUFNLFVBQVUsTUFBTSxNQUFLO0FBQUEsVUFDaEM7QUFDQSxtQkFBUztBQUFBLFlBQ0wsRUFBQyxNQUFNLE1BQU0sTUFBTSxNQUFLO0FBQUEsWUFBRyxFQUFDLE1BQU0sTUFBTSxNQUFNLE1BQUs7QUFBQSxZQUFHLEVBQUMsTUFBTSxXQUFXLE1BQU0sTUFBSztBQUFBLFlBQ25GLEVBQUMsTUFBTSxTQUFTLE1BQU0sTUFBSztBQUFBLFVBQUM7QUFFaEMsY0FBSSxvQkFBb0I7QUFDeEIsY0FBSSxXQUFXLFlBQVksV0FBVyxHQUFHO0FBQ3ZDLGtCQUFNLEtBQUssV0FBVyxZQUFZLFdBQVcsWUFBWSxTQUFTLENBQUM7QUFDbkUsa0JBQU0sS0FBSyxXQUFXLFFBQVEsV0FBVyxRQUFRLFNBQVMsQ0FBQztBQUMzRCxrQkFBTSxVQUFVLFdBQVcsS0FBSyxXQUFXLEtBQUssU0FBUyxJQUFJLENBQUM7QUFDOUQsa0JBQU0sUUFBUSxXQUFXLEtBQUssV0FBVyxLQUFLLFNBQVMsQ0FBQztBQUN4RCxnQ0FBb0IsQ0FBQyxFQUFFLFVBQVU7QUFDakMsNEJBQWdCO0FBQUEsY0FDWixFQUFDLE1BQU0sVUFBVSxNQUFNLEdBQUU7QUFBQSxjQUFHLEVBQUMsTUFBTSxVQUFVLE1BQU0sR0FBRTtBQUFBLGNBQUcsRUFBQyxNQUFNLFVBQVUsTUFBTSxRQUFPO0FBQUEsY0FDdEYsRUFBQyxNQUFNLFVBQVUsTUFBTSxNQUFLO0FBQUEsWUFBQztBQUVqQyxxQkFBUztBQUFBLGNBQ0wsRUFBQyxNQUFNLE1BQU0sTUFBTSxNQUFLO0FBQUEsY0FBRyxFQUFDLE1BQU0sTUFBTSxNQUFNLE1BQUs7QUFBQSxjQUFHLEVBQUMsTUFBTSxXQUFXLE1BQU0sTUFBSztBQUFBLGNBQ25GLEVBQUMsTUFBTSxTQUFTLE1BQU0sTUFBSztBQUFBLFlBQUM7QUFBQSxVQUNsQztBQUNBLGlCQUFPLENBQUMsaUJBQWlCLFVBQVUsTUFBTSxtQkFBbUIsaUJBQWlCO0FBQUEsUUFDL0UsT0FBTztBQUNMLGNBQUksZ0JBQWdCO0FBQ2xCLGtCQUFNLElBQUksTUFBTSx1RUFBdUU7QUFBQSxVQUN6RjtBQUNBLGdCQUFNLGdCQUFnQixVQUFVLGVBQWUsV0FBVyxXQUFXO0FBQ3JFLDBCQUFnQjtBQUFBLFlBQ1osRUFBQyxNQUFNLFVBQVUsTUFBTSxjQUFhO0FBQUEsWUFBRyxFQUFDLE1BQU0sVUFBVSxNQUFNLFdBQVcsS0FBSTtBQUFBLFlBQzdFLEVBQUMsTUFBTSxVQUFVLE1BQU0sV0FBVyxRQUFPO0FBQUEsVUFBQztBQUM5QyxtQkFBUztBQUFBLFlBQ0wsRUFBQyxNQUFNLGlCQUFpQixNQUFNLE9BQU8sUUFBUSxjQUFjLE9BQU07QUFBQSxZQUNqRSxFQUFDLE1BQU0sUUFBUSxNQUFNLE9BQU8sUUFBUSxXQUFXLEtBQUssT0FBTTtBQUFBLFlBQzFELEVBQUMsTUFBTSxXQUFXLE1BQU0sT0FBTyxRQUFRLFdBQVcsUUFBUSxPQUFNO0FBQUEsVUFBQztBQUVyRSxnQkFBTSxVQUFVLFdBQVcsS0FBSyxPQUFPLENBQUMsS0FBSyxRQUFRLE1BQU0sR0FBRztBQUM5RCxpQkFBTyxDQUFDLGlCQUFpQixVQUFVLENBQUMsQ0FBQyxTQUFTLE9BQU8sS0FBSztBQUFBLFFBQzVEO0FBQUEsTUFDRjtBQUVBLE1BQU0sc0JBQXNCLENBQ3hCLGNBQTRCLEdBQWtCLE1BQWMsaUJBQXlCLFlBQ3JGLEtBQWEsS0FBYSxPQUFlLFVBQTZCLFNBQWtCLG1CQUN4RixzQkFBdUM7QUFDekMsY0FBTSxpQkFBaUIsV0FBVyxXQUFXO0FBQzdDLGNBQU0sV0FBVyxFQUFFLEtBQUs7QUFDeEIsY0FBTSxTQUFTLGVBQWUsVUFBVSxFQUFFLEtBQUssUUFBUSxlQUFlO0FBRXRFLFlBQUksV0FBVyxZQUFZLFVBQVUsR0FBRztBQUN0QyxjQUFJLFFBQVE7QUFDWixjQUFJLFFBQVE7QUFDWixjQUFJLFdBQVc7QUFDZixnQkFBTSxVQUFVLFFBQVEsaUJBQWlCLElBQUk7QUFDN0MsY0FBSSxtQkFBbUI7QUFDckIsb0JBQVE7QUFBQTtBQUFBLDZCQUVlLE9BQU8sZUFBZSxPQUFPO0FBQUEsaUNBQ3pCLE9BQU8scUJBQXFCLE9BQU87QUFBQSw0Q0FDeEIsT0FBTztBQUFBO0FBQUE7QUFBQTtBQUFBLGtDQUlqQixFQUFFLGdCQUFnQixVQUFVLENBQUM7QUFBQSxvQkFDM0MsR0FBRztBQUFBO0FBQUEsVUFFbkIsT0FBTztBQUNMLG9CQUFRO0FBQUE7QUFBQSw2QkFFZSxPQUFPLGVBQWUsT0FBTztBQUFBLGtDQUN4QixFQUFFLGdCQUFnQixVQUFVLENBQUM7QUFBQSxvQkFDM0MsR0FBRztBQUFBO0FBQUEsVUFFbkI7QUFFQSxjQUFJLFdBQVcsWUFBWSxXQUFXLEdBQUc7QUFDdkMsa0JBQU0sVUFBVSxRQUFRLGlCQUFpQixJQUFJO0FBQzdDLGdCQUFJLG1CQUFtQjtBQUNyQixzQkFBUTtBQUFBO0FBQUEsNkJBRWEsT0FBTyxlQUFlLE9BQU87QUFBQSxpQ0FDekIsT0FBTyxxQkFBcUIsT0FBTyx5QkFBeUIsT0FBTztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFLOUYsT0FBTztBQUNMLHNCQUFRO0FBQUE7QUFBQSw2QkFFYSxPQUFPLGVBQWUsT0FBTztBQUFBO0FBQUEsWUFFcEQ7QUFDQSx1QkFBVztBQUFBO0FBQUE7QUFBQSxVQUdiO0FBRUEsZ0JBQU0sY0FBYztBQUFBLGNBQ1YsYUFBYSxpQkFBaUIsUUFBUSxFQUFFLGlCQUFpQixHQUFHLE1BQU0sQ0FBQztBQUFBO0FBQUEsY0FFbkUsYUFBYSxVQUFVLENBQUM7QUFBQSxnQkFDdEIsYUFBYSxzQ0FBc0MscUJBQXFCLENBQUM7QUFBQTtBQUFBLDhCQUUzRCxPQUFPLGdCQUFnQixZQUFZLENBQUM7QUFBQSwrQkFDbkMsT0FBTyxnQkFBZ0IsWUFBWSxDQUFDO0FBQUE7QUFBQSw0QkFFdkMsUUFBUSxJQUFJLEtBQUs7QUFBQTtBQUFBLGdCQUU3QixLQUFLO0FBQUEsZ0JBQ0wsS0FBSztBQUFBLGdCQUNMLFFBQVE7QUFBQSxnQkFDUixHQUFHO0FBQUE7QUFBQTtBQUFBO0FBSWYsaUJBQU87QUFBQSxRQUNULE9BQU87QUFDTCxjQUFJLGdCQUFnQjtBQUNsQixrQkFBTSxJQUFJLE1BQU0sdUVBQXVFO0FBQUEsVUFDekY7QUFDQSxnQkFBTSxjQUFjLFdBQVcsWUFBWTtBQUMzQyxnQkFBTSxXQUFXLFdBQVcsS0FBSztBQUNqQyxjQUFJLFVBQVU7QUFDZCxjQUFJLFNBQVM7QUFDWCxzQkFBVTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsZ0NBUWdCLEVBQUUsZ0JBQWdCLFVBQVUsQ0FBQztBQUFBLGtCQUMzQyxHQUFHO0FBQUE7QUFBQSxVQUVqQixPQUFPO0FBQ0wsc0JBQVU7QUFBQTtBQUFBLDhCQUVjLEVBQUUsZ0JBQWdCLFVBQVUsQ0FBQztBQUFBLGdCQUMzQyxHQUFHO0FBQUE7QUFBQSxVQUVmO0FBQ0EsZ0JBQU0sY0FBYztBQUFBLGNBQ1YsYUFBYSxpQkFBaUIsUUFBUSxFQUFFLGlCQUFpQixHQUFHLE1BQU0sQ0FBQztBQUFBO0FBQUEsY0FFbkUsYUFBYSxVQUFVLENBQUM7QUFBQSxnQkFDdEIsYUFBYSxzQ0FBc0MscUJBQXFCLENBQUM7QUFBQSw4QkFDM0QsT0FBTyxnQkFBZ0IsWUFBWSxDQUFDO0FBQUEsK0JBQ25DLE9BQU8sZ0JBQWdCLFlBQVksQ0FBQztBQUFBO0FBQUEsd0NBRTNCLFdBQVc7QUFBQTtBQUFBLDRCQUV2QixRQUFRLElBQUksS0FBSztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSx1Q0FNTixjQUFjLENBQUM7QUFBQSwwQ0FDWixhQUFhLDBCQUEwQixLQUFLLFdBQVcsQ0FBQztBQUFBLDJDQUN2RCxhQUFhLDBCQUEwQixLQUFLLFdBQVcsQ0FBQztBQUFBO0FBQUEsMEJBRXpFLGNBQWMsQ0FBQztBQUFBO0FBQUE7QUFBQSwrQkFHVixPQUFPLFdBQVcsVUFBVSxJQUFJO0FBQUEsK0NBRXZELGFBQWEsb0JBQW9CLE9BQU8sT0FBTyxXQUFXLEtBQUssV0FBVyxDQUFDO0FBQUEsb0NBQy9DLE9BQU8sV0FBVyxRQUFRLGFBQWEsaUJBQWlCLFVBQVUsUUFBUSxDQUFDO0FBQUEsb0JBQzNGLE9BQU87QUFBQTtBQUFBLGdCQUVYLEdBQUc7QUFBQTtBQUFBO0FBQUE7QUFJZixpQkFBTztBQUFBLFFBQ1Q7QUFBQSxNQUNGO0FBY0EsTUFBTSxnQ0FBZ0MsQ0FBQyxlQUNsQyxHQUFHLFdBQVcsTUFBTSxJQUFJLFdBQVcsUUFBUSxJQUFJLFdBQVcsT0FBTyxJQUFJLFdBQVcsWUFBWSxNQUFNO0FBRXZHLE1BQU0sMkNBQTJDLENBQUMsZUFDN0MsR0FBRyw4QkFBOEIsVUFBVSxDQUFDLElBQUksV0FBVyxlQUFlO0FBRS9FLE1BQU0sdUNBQXVDLENBQUMsZUFDekMsR0FBRyw4QkFBOEIsVUFBVSxDQUFDLElBQUksV0FBVyxZQUFZLElBQUksV0FBVyxTQUFTO0FBRXBHLE1BQU0sNEJBQTRCLENBQUMsZ0JBQStEO0FBQUEsUUFDaEcsUUFBUSxXQUFXO0FBQUEsUUFDbkIsU0FBUyxDQUFDLFVBQVUsU0FBUyxjQUFjLFlBQVksRUFBRSxXQUFXLFFBQWtCO0FBQUEsUUFDdEYsVUFBVSxXQUFXO0FBQUEsUUFDckIsYUFBYSxXQUFXO0FBQUEsUUFDeEIsU0FBUyxXQUFXO0FBQUEsUUFDcEIsTUFBTSxXQUFXO0FBQUEsTUFDbkI7QUFNQSxNQUFNLCtCQUNGLENBQUMsTUFBYyxPQUFtQixrQkFBMkIsZUFBbUQ7QUFDOUcsY0FBTSxDQUFDLG9CQUFvQixXQUFXLElBQ2xDLHdDQUF3QyxPQUFPLFlBQVksZ0JBQWdCO0FBQy9FLGNBQU0sSUFBSSxjQUFjLEtBQUssTUFBTSxVQUFVLE1BQU0sS0FBSyxNQUFNO0FBQzlELGNBQU0sV0FBVyxFQUFFLEtBQUs7QUFFeEIsY0FBTSxNQUFNO0FBQ1osWUFBSSxNQUFNO0FBQ1YsWUFBSSxtQkFBbUIsaUJBQWlCO0FBQ3RDLGlCQUFPLFlBQVksUUFBUTtBQUFBLFFBQzdCLE9BQU87QUFDTCxpQkFBTyxZQUFZLFFBQVE7QUFBQSxRQUM3QjtBQUNBLGNBQU0sQ0FBQyxpQkFBaUIsVUFBVSxTQUFTLG1CQUFtQixpQkFBaUIsSUFDM0UscUJBQXFCLGFBQWEsa0JBQWtCO0FBQ3hELHdCQUFnQixLQUFLLEdBQUcsMkJBQTJCLE1BQU0sSUFBSSxHQUFHLEdBQUcsMkJBQTJCLFdBQVcsQ0FBQztBQUMxRyxjQUFNLG9CQUF3RCxDQUFDLE1BQU07QUFDckUsZUFBTztBQUFBLFVBQ0w7QUFBQSxVQUNBLGFBQ0ksRUFBQyxNQUFNLEdBQUcsV0FBVyxRQUFRLElBQUksT0FBTyxJQUFJLGlCQUFpQixJQUFJLGlCQUFpQixJQUFJLGtCQUFpQjtBQUFBLFVBQzNHLFlBQVksT0FBTztBQUFBLFlBQ2pCLFNBQVMsQ0FBQyxFQUFDLE1BQU0sYUFBYSxVQUFVLE1BQU0sU0FBUSxDQUFDO0FBQUEsWUFDdkQsZUFBZSxFQUFDLEdBQUcsS0FBSztBQUFBLGNBQUssVUFBVSxLQUFLLFdBQVcsSUFBSTtBQUFBO0FBQUEsWUFBdUIsRUFBQztBQUFBLFlBQ25GO0FBQUEsVUFDRjtBQUFBLFVBQ0EsaUJBQWlCLGtCQUFnQjtBQUFBLFlBQzdCO0FBQUEsWUFBYztBQUFBLFlBQUcsTUFBTSxLQUFLO0FBQUEsWUFBUSxZQUFZO0FBQUEsWUFBUTtBQUFBLFlBQW9CO0FBQUEsWUFBSztBQUFBLFlBQUs7QUFBQSxZQUFLO0FBQUEsWUFDM0Y7QUFBQSxZQUFTO0FBQUEsWUFBbUI7QUFBQSxVQUFpQjtBQUFBLFFBQ25EO0FBQUEsTUFDRjtBQUVHLE1BQU0sNkJBQTZCLENBQUMsZUFBK0Q7QUFDeEcsY0FBTSxrQkFBbUIsV0FBVyxzQkFBaUMsSUFBSSxRQUFRO0FBRWpGLGNBQU0sT0FBTywwQkFBMEIsVUFBVTtBQUVqRCxZQUFJLEtBQUssYUFBYSxHQUFHO0FBQ3ZCLGdCQUFNLElBQUksTUFBTSx3RUFBd0U7QUFBQSxRQUMxRjtBQUNBLGNBQU0sd0JBQXdCLEVBQUMsaUJBQWlCLEdBQUcsTUFBTSxVQUFVLEdBQUU7QUFDckUsZUFBTyxFQUFDLEdBQUcsdUJBQXVCLFVBQVUseUNBQXlDLHFCQUFxQixFQUFDO0FBQUEsTUFDN0c7QUFFTyxNQUFNLGNBQWMsQ0FBQyxTQUF5QixlQUE0QztBQUMvRixRQUFBRCxpQkFBZSxRQUFRLE1BQU07QUFDN0IsZ0JBQVEsUUFBUSw2QkFBNkIsZUFBZSxRQUFRLE9BQU8sQ0FBQyxHQUFHLE9BQU8sVUFBVSxDQUFDO0FBQUEsTUFDbkc7QUFFQSxNQUFNLHVCQUF1QjtBQUFBLFFBQzNCLFNBQVM7QUFBQSxRQUNULFVBQVU7QUFBQSxRQUNWLGlCQUFpQjtBQUFBLFFBQ2pCLGFBQWEsQ0FBQztBQUFBLFFBQ2QsU0FBUyxDQUFDO0FBQUEsUUFDVixNQUFNLENBQUM7QUFBQSxRQUNQLGNBQWM7QUFBQSxRQUNkLFdBQVcsQ0FBQztBQUFBLE1BQ2Q7QUFFTyxNQUFNLG1DQUFtQyxDQUFDLGVBQStEO0FBQzlHLGNBQU0sU0FBUyxXQUFXO0FBQzFCLGVBQU8sRUFBQyxRQUFRLEdBQUcsc0JBQXNCLFVBQVUsT0FBTTtBQUFBLE1BQzNEO0FBRU8sTUFBTSxvQkFBb0IsQ0FBQyxTQUF5QixlQUE0QztBQUNyRyxRQUFBQSxpQkFBZSxRQUFRLE1BQU07QUFDN0IsZ0JBQVEsUUFBUSw2QkFBNkIscUJBQXFCLFFBQVEsT0FBTyxDQUFDLEdBQUcsTUFBTSxVQUFVLENBQUM7QUFBQSxNQUN4RztBQU9BLE1BQU0sMkJBQ0YsQ0FBQyxNQUFjLE9BQW1CLGtCQUEyQixlQUErQztBQUMxRyxjQUFNLENBQUMsb0JBQW9CLFdBQVcsSUFDbEMsd0NBQXdDLE9BQU8sWUFBWSxnQkFBZ0I7QUFDL0UsY0FBTSxNQUFNO0FBQUE7QUFBQTtBQUdaLGNBQU0sTUFBTTtBQUNaLGNBQU0sSUFBSSxjQUFjLEtBQUssTUFBTSxVQUFVLE1BQU0sS0FBSyxNQUFNO0FBQzlELGNBQU0sb0JBQXdELENBQUMsTUFBTTtBQUNyRSxjQUFNLENBQUMsaUJBQWlCLFVBQVUsU0FBUyxtQkFBbUIsaUJBQWlCLElBQzNFLHFCQUFxQixhQUFhLGtCQUFrQjtBQUN4RCx3QkFBZ0IsS0FBSyxHQUFHLDJCQUEyQixNQUFNLElBQUksR0FBRyxHQUFHLDJCQUEyQixXQUFXLENBQUM7QUFDMUcsZUFBTztBQUFBLFVBQ0w7QUFBQSxVQUNBLGFBQ0ksRUFBQyxNQUFNLEdBQUcsV0FBVyxRQUFRLElBQUksT0FBTyxJQUFJLGlCQUFpQixJQUFJLGlCQUFpQixJQUFJLGtCQUFpQjtBQUFBLFVBQzNHLFlBQVksT0FBTztBQUFBLFlBQ2pCLFNBQVMsQ0FBQyxFQUFDLE1BQU0sYUFBYSxVQUFVLE1BQU0sU0FBUSxDQUFDO0FBQUEsWUFDdkQsZUFBZSxFQUFDLEdBQUcsS0FBSztBQUFBLGNBQUssVUFBVSxLQUFLLFdBQVcsSUFBSTtBQUFBO0FBQUEsWUFBdUIsRUFBQztBQUFBLFlBQ25GO0FBQUEsVUFDRjtBQUFBLFVBQ0EsaUJBQWlCLGtCQUFnQjtBQUFBLFlBQzdCO0FBQUEsWUFBYztBQUFBLFlBQUcsTUFBTSxLQUFLO0FBQUEsWUFBUSxZQUFZO0FBQUEsWUFBUTtBQUFBLFlBQW9CO0FBQUEsWUFBSztBQUFBLFlBQUs7QUFBQSxZQUFNO0FBQUEsWUFDNUY7QUFBQSxZQUFTO0FBQUEsWUFBbUI7QUFBQSxVQUFpQjtBQUFBLFFBQ25EO0FBQUEsTUFDRjtBQUVHLE1BQU0sVUFBVSxDQUFDLFNBQXlCLGVBQXdDO0FBQ3ZGLFFBQUFBLGlCQUFlLFFBQVEsTUFBTTtBQUM3QixnQkFBUSxRQUFRLHlCQUF5QixXQUFXLFFBQVEsT0FBTyxDQUFDLEdBQUcsT0FBTyxVQUFVLENBQUM7QUFBQSxNQUMzRjtBQUVPLE1BQU0seUJBQXlCLENBQUMsZUFBMkQ7QUFDaEcsY0FBTSxlQUFlLFdBQVc7QUFDaEMsY0FBTSxZQUFZLFdBQVc7QUFFN0IsY0FBTSxPQUFPLDBCQUEwQixVQUFVO0FBRWpELFlBQUksaUJBQWlCLEdBQUc7QUFDdEIsZ0JBQU0sSUFBSSxNQUFNLDZEQUE2RDtBQUFBLFFBQy9FO0FBQ0EsWUFBSSxLQUFLLGFBQWEsR0FBRztBQUN2QixnQkFBTSxJQUFJLE1BQU0sb0VBQW9FO0FBQUEsUUFDdEY7QUFDQSxjQUFNLG9CQUFvQixFQUFDLGNBQWMsV0FBVyxHQUFHLE1BQU0sVUFBVSxHQUFFO0FBQ3pFLGVBQU8sRUFBQyxHQUFHLG1CQUFtQixVQUFVLHFDQUFxQyxpQkFBaUIsRUFBQztBQUFBLE1BQ2pHO0FBRU8sTUFBTSwrQkFBK0IsQ0FBQyxlQUEyRDtBQUN0RyxjQUFNLFNBQVMsV0FBVztBQUMxQixlQUFPLEVBQUMsUUFBUSxHQUFHLHNCQUFzQixVQUFVLE9BQU07QUFBQSxNQUMzRDtBQUVPLE1BQU0sZ0JBQWdCLENBQUMsU0FBeUIsZUFBd0M7QUFDN0YsUUFBQUEsaUJBQWUsUUFBUSxNQUFNO0FBQzdCLGdCQUFRLFFBQVEseUJBQXlCLGlCQUFpQixRQUFRLE9BQU8sQ0FBQyxHQUFHLE1BQU0sVUFBVSxDQUFDO0FBQUEsTUFDaEc7QUFBQTtBQUFBOzs7QUMvWkEsTUFVTSx1QkFVQSx3QkFxQ087QUF6RGI7QUFBQTtBQUFBO0FBR0E7QUFFQTtBQUdBO0FBRUEsTUFBTSx3QkFBd0IsQ0FBQyxPQUFlLE9BQWUsVUFBd0I7QUFDbkYsY0FBTSxpQkFBaUIsVUFBVTtBQUNqQyxjQUFNLDhCQUE4QixRQUFRLFNBQVMsUUFBUTtBQUM3RCxjQUFNLDhCQUE4QixRQUFRLFNBQVMsUUFBUTtBQUU3RCxZQUFJLGtCQUFrQiwrQkFBK0IsNkJBQTZCO0FBQ2hGLGdCQUFNLElBQUksTUFBTSwyQ0FBNEM7QUFBQSxRQUM5RDtBQUFBLE1BQ0Y7QUFFQSxNQUFNLHlCQUF5QixDQUFDLE9BQWUsT0FBZSxPQUFlLGFBQW9DO0FBQy9HLGNBQU0sY0FBYyxLQUFLLElBQUksS0FBSyxNQUFNLFFBQVEsU0FBUyxLQUFLLENBQUM7QUFDL0QsY0FBTSxjQUF3QixDQUFDLFdBQVc7QUFDMUMsY0FBTSxhQUFhO0FBQ25CLGNBQU0saUJBQWlCLDJCQUEyQixRQUFRO0FBQzFELGNBQU0sa0JBQW9DO0FBQUEsVUFDeEMsRUFBQyxNQUFNLFVBQVUsTUFBTSxXQUFVO0FBQUEsVUFBRyxFQUFDLE1BQU0sZ0JBQWdCLE1BQU0sTUFBSztBQUFBLFVBQUcsRUFBQyxNQUFNLGdCQUFnQixNQUFNLE1BQUs7QUFBQSxVQUMzRyxHQUFHLDJCQUEyQixXQUFXO0FBQUEsUUFDM0M7QUFFQSxjQUFNLGtCQUFrQixDQUFDLGlCQUErQjtBQUN0RCxnQkFBTSxTQUFTLGVBQWUsVUFBVSxVQUFVLFlBQVksTUFBTTtBQUNwRSxnQkFBTSxXQUFXLE9BQU8sS0FBSztBQUM3QixnQkFBTSxXQUE4QjtBQUFBLFlBQ2xDLEVBQUMsTUFBTSxjQUFjLE1BQU0sTUFBSztBQUFBLFlBQUcsRUFBQyxNQUFNLFNBQVMsTUFBTSxTQUFrQztBQUFBLFlBQzNGLEVBQUMsTUFBTSxTQUFTLE1BQU0sU0FBa0M7QUFBQSxVQUMxRDtBQUNBLGlCQUFPO0FBQUEsVUFDRCxhQUFhLGlCQUFpQixRQUFRLEVBQUUsaUJBQWlCLE1BQU0sQ0FBQztBQUFBLFVBQ2hFLGFBQWEsVUFBVSxDQUFDO0FBQUEsVUFDeEIsYUFBYSxzQ0FBc0MscUJBQXFCLENBQUM7QUFBQSxnREFDbkMsUUFBUTtBQUFBO0FBQUEsUUFFdEQ7QUFFQSxlQUFPO0FBQUEsVUFDTCxNQUFNO0FBQUEsVUFDTixhQUFhLEVBQUMsTUFBTSxHQUFHLFFBQVEsR0FBRTtBQUFBLFVBQ2pDO0FBQUEsVUFDQSxZQUFZLE9BQU87QUFBQSxZQUNqQixTQUFTLENBQUMsRUFBQyxNQUFNLGFBQWEsU0FBUSxDQUFDO0FBQUEsWUFDdkMsZUFBZSxFQUFDLEdBQUcsS0FBSztBQUFBLGNBQUssYUFBYTtBQUFBO0FBQUEsWUFBdUIsRUFBQztBQUFBLFlBQ2xFO0FBQUEsVUFDRjtBQUFBLFFBQ0Y7QUFBQSxNQUNGO0FBRU8sTUFBTSxRQUFRLENBQUMsWUFBa0M7QUFDdEQsWUFBSSxRQUFRO0FBQ1osWUFBSSxRQUFRO0FBQ1osWUFBSSxRQUFRO0FBQ1osWUFBSSxRQUFRLE9BQU8sQ0FBQyxFQUFFLDRCQUE2QjtBQUNqRCxrQkFBUSxRQUFRLE9BQU8sQ0FBQyxFQUFFLGNBQWMsRUFBRSxDQUFDO0FBQzNDLGtCQUFRLFFBQVEsT0FBTyxDQUFDLEVBQUUsY0FBYyxFQUFFLENBQUM7QUFDM0Msa0JBQVEsUUFBUSxPQUFPLENBQUMsRUFBRSxjQUFjLEVBQUUsQ0FBQztBQUFBLFFBQzdDLFdBQVcsUUFBUSxPQUFPLENBQUMsRUFBRSw0QkFBNkI7QUFDeEQsa0JBQVEsUUFBUSxPQUFPLENBQUMsRUFBRSxnQkFBZ0IsRUFBRSxDQUFDO0FBQzdDLGtCQUFRLFFBQVEsT0FBTyxDQUFDLEVBQUUsZ0JBQWdCLEVBQUUsQ0FBQztBQUM3QyxrQkFBUSxRQUFRLE9BQU8sQ0FBQyxFQUFFLGdCQUFnQixFQUFFLENBQUM7QUFBQSxRQUMvQztBQUNBLFlBQUlFLEtBQUksT0FBTyxzQkFBc0I7QUFDbkMsZ0NBQXNCLE9BQU8sT0FBTyxLQUFLO0FBQUEsUUFDM0M7QUFFQSxnQkFBUSxRQUFRLHVCQUF1QixPQUFPLE9BQU8sT0FBTyxRQUFRLE9BQU8sQ0FBQyxFQUFFLFFBQVEsR0FBRyxFQUFDLFFBQVEsQ0FBQyxFQUFDLENBQUM7QUFBQSxNQUN2RztBQUFBO0FBQUE7OztBQzNFQSxNQWdDTSxnQkF1QkEsY0FTQUMsa0JBNkNBLDRDQWtEQSw2QkFrQ0EsV0FhQSxpQkF3QkEsbUJBeUJBLDJDQXVCQSx3Q0FrQ0EsbUJBV0EsMkJBUUEsdUJBc0RBLHNCQTZFQSx3QkF3RUEseUJBdUhBLHFDQU9PLFFBaUJBO0FBcnFCYjtBQUFBO0FBQUE7QUFLQTtBQUNBO0FBR0E7QUF1QkEsTUFBTSxpQkFBaUIsQ0FBQyxRQUFrQixlQUF1QztBQUMvRSxlQUFPLE1BQU0sQ0FBQyxVQUFVLFFBQVEsTUFBTSxNQUFNO0FBQ2xCLGdCQUFNLElBQUksTUFBTSxvREFBb0Q7QUFBQSxRQUN0RSxFQUFFO0FBRTFCLFlBQUksT0FBTyxTQUFTLEdBQUc7QUFDckIsY0FBSSxXQUFXLFNBQVMsVUFBVTtBQUNoQyxnQkFBSSxFQUFFLE9BQU8sV0FBVyxLQUFLLE9BQU8sV0FBVyxLQUFNLE9BQU8sV0FBVyxLQUFLLE9BQU8sQ0FBQyxNQUFNLEtBQUssT0FBTyxDQUFDLE1BQU0sS0FDdEcsT0FBTyxXQUFXLEtBQUssT0FBTyxDQUFDLE1BQU0sS0FBSyxPQUFPLENBQUMsTUFBTSxLQUN4RCxPQUFPLFdBQVcsS0FBSyxPQUFPLENBQUMsTUFBTSxLQUFLLE9BQU8sQ0FBQyxNQUFNLElBQUs7QUFDbEUsb0JBQU0sSUFBSTtBQUFBLGdCQUNOO0FBQUE7QUFBQSxjQUN3RjtBQUFBLFlBQzlGO0FBQUEsVUFDRixXQUFXLFdBQVcsU0FBUyxTQUFTO0FBQ3RDLGdCQUFJLEVBQUUsT0FBTyxXQUFXLEtBQU0sT0FBTyxXQUFXLEtBQUssT0FBTyxDQUFDLE1BQU0sS0FBSyxPQUFPLENBQUMsTUFBTSxLQUMvRSxPQUFPLFdBQVcsS0FBSyxPQUFPLENBQUMsTUFBTSxLQUFLLE9BQU8sQ0FBQyxNQUFNLElBQUs7QUFDbEUsb0JBQU0sSUFBSSxNQUFNLCtEQUErRDtBQUFBLFlBQ2pGO0FBQUEsVUFDRjtBQUFBLFFBQ0Y7QUFBQSxNQUNGO0FBRUEsTUFBTSxlQUFlLENBQUMsUUFBMkIsTUFBeUIsU0FBMkI7QUFDbkcsYUFBSyxNQUFNLENBQUMsVUFBVSxTQUFTLEtBQUssUUFBUSxTQUFTLE1BQU07QUFDbkMsZ0JBQU0sSUFBSSxNQUFNLHFFQUFxRTtBQUFBLFFBQ3ZGLEVBQUU7QUFDeEIsY0FBTSxZQUFZLElBQUksTUFBTSxJQUFJLEVBQUUsS0FBSyxDQUFHO0FBQzFDLGFBQUssUUFBUSxDQUFDLE9BQU8sVUFBVSxVQUFVLEtBQUssSUFBSSxPQUFPLEtBQUssQ0FBQztBQUMvRCxlQUFPO0FBQUEsTUFDVDtBQUVBLE1BQU1BLG1CQUNGLENBQUMsUUFBK0IsWUFBOEIsY0FBc0IsUUFDbkYsT0FBaUIsUUFBd0I7QUFDeEMsY0FBTSxDQUFDLGVBQWUsa0JBQWtCLGVBQWUsSUFDbEQsZUFBZSxLQUFNLENBQUMsR0FBRyxHQUFHLENBQUMsSUFBSSxDQUFDLElBQUssT0FBTyxTQUFTLElBQUssSUFBSSxJQUFJLEVBQUU7QUFDM0UsY0FBTSxPQUFPLE9BQU8sQ0FBQyxFQUFFLEtBQUs7QUFDNUIsWUFBSSxnQkFBZ0IsS0FBSyxPQUFPLFNBQVMsaUJBQWlCLE9BQU8sYUFBYSxFQUFFLEtBQUssU0FBUyxHQUFHO0FBQy9GLGlCQUFPLGFBQWEsRUFBRSxnQkFBZ0IsRUFBRSxRQUFRLENBQUMsVUFBVSxJQUFJLEtBQUssS0FBSyxDQUFDO0FBQUEsUUFDNUUsV0FBVyxXQUFXLDRCQUE0QixzQkFBc0I7QUFDdEUsZ0JBQU0sSUFBSSxNQUFNLDJGQUEyRjtBQUFBLFFBQzdHO0FBRUEsWUFBSSxtQkFBbUIsS0FBSyxPQUFPLFNBQVMsb0JBQW9CLE9BQU8sZ0JBQWdCLEVBQUUsS0FBSyxTQUFTLEdBQUc7QUFDeEcsaUJBQU8sZ0JBQWdCLEVBQUUsZ0JBQWdCLEVBQUUsUUFBUSxDQUFDLFVBQVUsT0FBTyxLQUFLLEtBQUssQ0FBQztBQUNoRixjQUFJLE9BQU8sV0FBVyxNQUNqQixPQUFPLFdBQVcsU0FBUyxnQkFBZ0IsTUFBTSxPQUFPLFdBQVcsV0FBVyxLQUFLLFVBQVU7QUFDaEcsa0JBQU0sSUFBSTtBQUFBLGNBQ047QUFBQSxZQUE2RjtBQUFBLFVBQ25HO0FBQ0EseUJBQWUsUUFBUSxVQUFVO0FBQ2pDLGNBQUksV0FBVyxLQUFLLFNBQVMsR0FBRztBQUM5Qix5QkFBYSxRQUFRLFdBQVcsTUFBTSxJQUFJLEVBQUUsUUFBUSxDQUFDLE9BQU8sVUFBVSxPQUFPLEtBQUssSUFBSSxLQUFLO0FBQUEsVUFDN0Y7QUFBQSxRQUNGO0FBQ0EsWUFBSSxrQkFBa0IsS0FBSyxPQUFPLFNBQVMsaUJBQWlCO0FBQzFELGlCQUFPLGVBQWUsRUFBRSxpQkFBaUIsRUFBRSxRQUFRLENBQUMsVUFBVSxNQUFNLEtBQUssT0FBTyxLQUFLLENBQUMsQ0FBQztBQUN2RixjQUFJLE1BQU0sV0FBVyxRQUFTLGdCQUFnQixNQUFNLE1BQU0sV0FBVyxXQUFXLEtBQUssUUFBUztBQUM1RixrQkFBTSxJQUFJLE1BQU0sNEZBQTRGO0FBQUEsVUFDOUc7QUFBQSxRQUNGO0FBRUEsWUFBSSxXQUFXLEtBQUssU0FBUyxHQUFHO0FBQzlCLGNBQUksT0FBTyxXQUFXLFdBQVcsS0FBSyxRQUFRO0FBQzVDLGtCQUFNLElBQUksTUFBTSwwRkFBMEY7QUFBQSxVQUM1RztBQUNBLGNBQUksTUFBTSxXQUFXLFdBQVcsS0FBSyxRQUFRO0FBQzNDLGtCQUFNLElBQUk7QUFBQSxjQUNOO0FBQUEsWUFBOEY7QUFBQSxVQUNwRztBQUFBLFFBQ0Y7QUFDQSxZQUFJLE9BQU8sV0FBVyxlQUFlLE9BQU8sVUFBVSxlQUFlLE9BQU8sU0FBUyxLQUFLLE1BQU0sU0FBUyxNQUFNO0FBQzdHLGdCQUFNLElBQUksTUFBTSx5REFBeUQ7QUFBQSxRQUMzRTtBQUFBLE1BQ0Y7QUFFSixNQUFNLDZDQUNGLENBQUMsd0JBQWlELFVBQzlDO0FBQUEsMkRBQ21ELEtBQUssU0FDM0QsTUFBTTtBQUNELGdCQUFRLHdCQUF3QjtBQUFBLFVBQzlCLEtBQUs7QUFDSCxtQkFBTyxVQUFVLEtBQUssZ0JBQWdCLEtBQUs7QUFBQSxVQUM3QyxLQUFLO0FBQ0gsbUJBQU87QUFBQSw4QkFDUyxLQUFLLHVCQUF1QixLQUFLO0FBQUE7QUFBQTtBQUFBO0FBQUEsVUFJbkQsS0FBSztBQUNILG1CQUFPLFdBQVcsS0FBSyx1QkFBdUIsS0FBSztBQUFBLFVBQ3JELEtBQUs7QUFDSCxtQkFBTztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxrQ0FNYSxLQUFLO0FBQUE7QUFBQSwwQkFFYixLQUFLLDZEQUE2RCxLQUFLO0FBQUE7QUFBQTtBQUFBLFVBR3JGLEtBQUs7QUFDSCxtQkFBTztBQUFBLDZCQUNRLEtBQUssZ0JBQWdCLEtBQUs7QUFBQSwyQkFDNUIsS0FBSyxnQkFBZ0IsS0FBSyx5QkFBeUIsS0FBSztBQUFBLDBCQUN6RCxLQUFLO0FBQUE7QUFBQSxtQ0FFSSxLQUFLLHlCQUF5QixLQUFLO0FBQUE7QUFBQSxVQUUxRCxLQUFLO0FBQ0gsbUJBQU8sdUJBQXVCLEtBQUssWUFBWSxLQUFLO0FBQUEsdUNBQzNCLEtBQUs7QUFBQSxtQ0FDVCxLQUFLO0FBQUE7QUFBQSxzQ0FFRixLQUFLLHVCQUF1QixLQUFLO0FBQUEsVUFDM0QsS0FBSztBQUNILG1CQUFPLFlBQVksS0FBSyx1QkFBdUIsS0FBSztBQUFBLFVBQ3REO0FBQ0Usa0JBQU0sSUFBSSxNQUFNLDZCQUE2QixzQkFBc0IsbUJBQW1CO0FBQUEsUUFDMUY7QUFBQSxNQUNGLEdBQUcsSUFDUDtBQUVKLE1BQU0sOEJBQThCLENBQUMsYUFBMEIsY0FBc0IsVUFDakYsNkNBQTZDLEtBQUssNEJBQTRCLEtBQUssUUFBUSxNQUFNO0FBQy9GLGdCQUFRLGFBQWE7QUFBQSxVQUNuQixLQUFLO0FBQ0gsbUJBQU87QUFBQSxVQUtULEtBQUs7QUFDSCxtQkFBTztBQUFBLFVBQ1QsS0FBSztBQUNILG1CQUFPO0FBQUEsVUFDVCxLQUFLO0FBQ0gsbUJBQU87QUFBQSxVQUtULEtBQUs7QUFBQSxVQUNMO0FBQ0UsZ0JBQUksZUFBZSxJQUFJO0FBQ3JCLHFCQUFPO0FBQUEsWUFNVDtBQUNBLGtCQUFNLElBQUksTUFBTSxnQkFBZ0IsV0FBVyxtQkFBbUI7QUFBQSxRQUNsRTtBQUFBLE1BQ0YsR0FBRyxJQUNIO0FBRUosTUFBTSxZQUFZLENBQUMsS0FBd0IsTUFBeUIsU0FBMkI7QUFDN0YsY0FBTSxTQUFTLElBQUksTUFBTSxJQUFJLEVBQUUsS0FBSyxDQUFDLEVBQUUsT0FBTyxJQUFJLE1BQU0sSUFBSSxFQUFFLEtBQUssQ0FBQyxDQUFDO0FBQ3JFLGNBQU0sV0FBVyxJQUFJLFdBQVcsSUFBSSxTQUFTLElBQUksTUFBTTtBQUN2RCxZQUFJLEtBQUssU0FBUyxHQUFHO0FBQ25CLGVBQUssUUFBUSxDQUFDLEdBQUcsTUFBTTtBQUNyQixtQkFBTyxDQUFDLElBQUksU0FBUyxDQUFDO0FBQ3RCLG1CQUFPLElBQUksSUFBSSxJQUFJLFNBQVMsS0FBSyxTQUFTLENBQUM7QUFBQSxVQUM3QyxDQUFDO0FBQ0QsaUJBQU87QUFBQSxRQUNUO0FBQ0EsZUFBTztBQUFBLE1BQ1Q7QUFFQSxNQUFNLGtCQUNGLENBQUMsWUFBK0IsUUFBMkIsT0FBMEIsU0FDckU7QUFDVixZQUFJLGNBQXdCLENBQUM7QUFDN0IsWUFBSSxNQUFNLFNBQVMsR0FBRztBQUNwQixjQUFJLEtBQUssU0FBUyxHQUFHO0FBQ25CLHVCQUFXLFFBQVEsQ0FBQyxNQUFNLFlBQVksS0FBSyxDQUFDLENBQUM7QUFDN0MsZ0JBQUksS0FBSyxJQUFJLEdBQUcsSUFBSSxJQUFJLFdBQVcsUUFBUTtBQUN6QyxvQkFBTSxJQUFJLE1BQU0sc0JBQXNCO0FBQUEsWUFDeEM7QUFDQSxpQkFBSyxRQUFRLENBQUMsR0FBRyxNQUFNLFlBQVksQ0FBQyxJQUFJLE1BQU0sQ0FBQyxDQUFDO0FBQUEsVUFDbEQsT0FBTztBQUNMLGtCQUFNLFFBQVEsQ0FBQyxNQUFNLFlBQVksS0FBSyxDQUFDLENBQUM7QUFBQSxVQUMxQztBQUFBLFFBQ0YsT0FBTztBQUNMLGNBQUksT0FBTyxXQUFXLEdBQUc7QUFDdkIsa0JBQU0sSUFBSSxNQUFNLHlDQUF5QztBQUFBLFVBQzNELE9BQU87QUFDTCwwQkFBYyxXQUFXLElBQUksQ0FBQyxPQUFPLFVBQVUsS0FBSyxNQUFNLFFBQVEsT0FBTyxLQUFLLENBQUMsQ0FBQztBQUFBLFVBQ2xGO0FBQUEsUUFDRjtBQUNBLGVBQU87QUFBQSxNQUNUO0FBRVIsTUFBTSxvQkFBb0IsQ0FBQyxZQUErQixRQUFrQixlQUFpQztBQUMzRyxjQUFNLGlCQUFpQixNQUFNO0FBQzNCLGtCQUFRLFdBQVcsdUJBQXVCO0FBQUEsWUFDeEMsS0FBSztBQUNILHFCQUFPLFdBQVcsS0FBSyxTQUFTLElBQUksS0FBSyxJQUFJLEdBQUcsV0FBVyxLQUFLLElBQUksT0FBSyxPQUFPLENBQUMsQ0FBQyxHQUFHLE9BQU8sU0FBUyxJQUNqRSxLQUFLLElBQUksR0FBRyxRQUFRLE9BQU8sU0FBUztBQUFBLFlBQzFFLEtBQUs7QUFDSCxxQkFBTyxXQUFXLEtBQUssU0FBUyxJQUFJLEtBQUssSUFBSSxHQUFHLFdBQVcsS0FBSyxJQUFJLE9BQUssT0FBTyxDQUFDLENBQUMsR0FBRyxPQUFPLFNBQVMsSUFDakUsS0FBSyxJQUFJLEdBQUcsUUFBUSxPQUFPLFNBQVM7QUFBQSxZQUMxRTtBQUNFLG9CQUFNLElBQUksTUFBTSw0QkFBNEIsV0FBVyxxQkFBcUIsbUJBQW1CO0FBQUEsVUFDbkc7QUFBQSxRQUNGLEdBQUc7QUFDSCxlQUFPLEtBQUssR0FBSyxHQUFHLE9BQU8sTUFBTTtBQUNqQyxjQUFNLHNCQUFzQixXQUFXLE1BQU07QUFDN0MsWUFBSSxXQUFXLEtBQUssU0FBUyxHQUFHO0FBQzlCLHFCQUFXLEtBQUssUUFBUSxDQUFDLE1BQU0sT0FBTyxDQUFDLElBQUksYUFBYTtBQUN4RCxxQkFBVyxLQUFLLFFBQVEsQ0FBQyxNQUFNLG9CQUFvQixDQUFDLElBQUksS0FBSyxNQUFNLFdBQVcsQ0FBQyxJQUFJLE9BQU8sQ0FBQyxDQUFDLENBQUM7QUFBQSxRQUMvRixPQUFPO0FBQ0wsaUJBQU8sS0FBSyxlQUFlLEdBQUcsT0FBTyxNQUFNO0FBQzNDLDhCQUFvQixRQUFRLENBQUMsR0FBRyxNQUFNLG9CQUFvQixDQUFDLElBQUksS0FBSyxNQUFNLElBQUksT0FBTyxDQUFDLENBQUMsQ0FBQztBQUFBLFFBQzFGO0FBQ0EsZUFBTztBQUFBLE1BQ1Q7QUFFQSxNQUFNLDRDQUNGLENBQUMsUUFBdUIsWUFBK0IsYUFBZ0MsY0FDdEYsY0FBOEI7QUFBQSxtRUFDZ0MsT0FBTyxLQUFLLE9BQU8sY0FDOUUsT0FBTyxLQUFLLEtBQUssS0FBSyxZQUFZLE1BQU07QUFBQSxvQ0FDWixPQUFPLEtBQUssS0FBSyxLQUFLLFlBQVksTUFBTTtBQUFBLGdDQUM1QyxZQUFZLE1BQU07QUFBQSw2QkFDckIsT0FBTyxXQUFXLGtCQUFrQixHQUFHLENBQUM7QUFBQSxzQkFDL0MsYUFBYSxtQkFBbUIsS0FBSyxZQUFZLENBQUM7QUFBQSx3QkFDaEQsYUFBYSxnQkFBZ0IsS0FBSyxTQUFTLENBQUM7QUFBQSx1QkFDN0MsYUFBYSxnQkFBZ0IsT0FBTyxXQUFXLE1BQU0sSUFBSSxTQUFTLENBQUM7QUFBQTtBQUFBLGtDQUV4RCxPQUFPLEtBQUssS0FBSztBQUFBO0FBQUEsZ0NBRW5CLGFBQWEsd0JBQXdCLEtBQUssV0FBVyxNQUFNLENBQUM7QUFBQSxpQ0FDM0QsYUFBYSx5QkFBeUIsS0FBSyxZQUFZLE1BQU0sQ0FBQztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQVEvRixNQUFNLHlDQUNGLENBQUMsT0FBc0IsUUFBdUIsWUFBK0IsYUFDNUUsY0FBc0IsV0FBbUIscUJBQXNDO0FBQUEsZ0VBQ3BCLE9BQU8sS0FBSyxPQUFPLFFBQVEsTUFBTSxLQUFLLE9BQU87QUFBQSwyQkFDbEYsTUFBTSxLQUFLLE9BQU87QUFBQSxnQ0FDYixZQUFZLE1BQU07QUFBQSw2QkFDckIsT0FBTyxXQUFXLGtCQUFrQixHQUFHLENBQUM7QUFBQTtBQUFBLHNCQUUvQyxhQUFhLG1CQUFtQixLQUFLLFlBQVksQ0FBQztBQUFBO0FBQUE7QUFBQTtBQUFBLDBCQUk5QyxhQUFhLGdCQUFnQixLQUFLLFNBQVMsQ0FBQztBQUFBLHlCQUM3QyxhQUFhLGdCQUFnQixPQUFPLFdBQVcsTUFBTSxJQUFJLFNBQVMsQ0FBQztBQUFBLGdDQUM1RCxhQUFhLHdCQUF3QixLQUFLLFdBQVcsTUFBTSxDQUFDO0FBQUEsaUNBQzNELGFBQWEseUJBQXlCLEtBQUssWUFBWSxNQUFNLENBQUM7QUFBQTtBQUFBO0FBQUEsaUJBRzlFLGdCQUFnQiw0Q0FBNEMsT0FBTyxLQUFLLEtBQUs7QUFBQTtBQUFBO0FBQUEsd0NBR3RELE9BQU8sS0FBSyxLQUFLO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFVBUy9DLE1BQU0sV0FBVyxpQkFBaUIsS0FBSyxjQUFjLENBQUM7QUFBQTtBQUFBO0FBQUE7QUFJaEUsTUFBTSxvQkFBb0IsQ0FBQyxPQUFzQixlQUEwQztBQUFBLDBDQUNqRCxNQUFNLEtBQUssT0FBTztBQUFBLGdDQUM1QixXQUFXLE1BQU07QUFBQSw0QkFDckIsTUFBTSxXQUFXLGlCQUFpQixHQUFHLENBQUM7QUFBQSxnREFDbEIsYUFBYSx3QkFBd0IsS0FBSyxXQUFXLE1BQU0sQ0FBQztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFPNUcsTUFBTSw0QkFDRixDQUFDLE9BQXNCLFlBQW9CLFVBQWtCLGdCQUN6RCxNQUFNLE9BQU8sY0FBYztBQUFBLE1BQzdCLE1BQU0sV0FBVyxpQkFBaUIsWUFBWSxTQUFTLENBQUM7QUFBQSxNQUN4RCxNQUFNLFdBQVcsaUJBQWlCLFVBQVUsT0FBTyxDQUFDO0FBQUEsSUFFdkI7QUFFbkMsTUFBTSx3QkFDRixDQUFDLE9BQXNCLFFBQXVCLFlBQStCLGtCQUM1RSx1QkFBdUM7QUFDdEMsY0FBTSxTQUFTO0FBQ2YsY0FBTSxDQUFDLFVBQVUsV0FBVyxVQUFVLFVBQVUsSUFDNUMsV0FBVyxXQUFXLElBQUksQ0FBQyxJQUFJLEdBQUcsR0FBRyxFQUFFLElBQUssU0FBUyxDQUFDLEdBQUcsR0FBRyxHQUFHLENBQUMsSUFBSSxDQUFDLEdBQUcsR0FBRyxHQUFHLENBQUM7QUFDbkYsY0FBTSxRQUFRLE1BQU0sS0FBSztBQUN6QixlQUFPO0FBQUEsd0VBQzJELEtBQUs7QUFBQSwyQkFDbEQsTUFBTSxLQUFLLE9BQU87QUFBQSxRQUNyQyxNQUFNLFdBQVcsaUJBQWlCLFdBQVcsbUJBQW1CLFdBQVcsU0FBUyxDQUFDLFFBQVEsQ0FBQztBQUFBLFFBQzlGLE1BQU0sV0FBVyxpQkFBaUIsVUFBVSxtQkFBbUIsV0FBVyxRQUFRLENBQUMsUUFBUSxDQUFDO0FBQUEsUUFDNUYsMEJBQTBCLE9BQU8sWUFBWSxVQUFVLENBQUMsQ0FBQztBQUFBLGVBQ2xELE1BQU0sYUFBYSxlQUFlLENBQUM7QUFBQTtBQUFBO0FBQUEsK0NBR0gsT0FBTyxLQUFLLE9BQU8sUUFBUSxLQUFLO0FBQUE7QUFBQSxnQkFFL0QsS0FBSyxzQkFBc0IsU0FBUztBQUFBLGdCQUNwQyxLQUFLLHNCQUFzQixRQUFRO0FBQUEsUUFFekMsbUJBQ0kseUJBQXlCLFdBQVcsU0FBUyxDQUFDLDhCQUE4QixXQUFXLFFBQVEsQ0FBQztBQUFBLGlCQUM3RixrQkFBa0I7QUFBQSxXQUVyQixFQUFFO0FBQUEsOEJBQ2MsV0FBVyxTQUFTLENBQUM7QUFBQSw4QkFDckIsV0FBVyxRQUFRLENBQUM7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLDJCQUt2QixXQUFXLFNBQVMsSUFBSSx1QkFBdUIsVUFBVSxPQUFPLEdBQUc7QUFBQSwwQkFDcEUsV0FBVyxTQUFTLElBQUksdUJBQXVCLFFBQVEsT0FBTyxHQUFHO0FBQUEsaUJBQzFFLEtBQUs7QUFBQSxpQkFDTCxLQUFLO0FBQUEsaUJBQ0wsS0FBSztBQUFBLGlCQUNMLEtBQUs7QUFBQSxpQkFDTCxLQUFLLGdCQUFnQixLQUFLO0FBQUEsaUJBQzFCLEtBQUssVUFBVSxLQUFLO0FBQUEsaUJBQ3BCLEtBQUssZ0JBQWdCLEtBQUs7QUFBQSxpQkFDMUIsS0FBSyxVQUFVLEtBQUs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BV2pDO0FBRUosTUFBTSx1QkFDRixDQUFDLE9BQXNCLFFBQXVCLFlBQStCLGFBQzVFLFFBQTJCLEtBQXdCLGFBQXFCLGtCQUN4RSxvQkFBNEIsbUJBQW9DO0FBQy9ELGNBQU0sT0FBTyxXQUFXLFdBQVc7QUFDbkMsY0FBTSxTQUFTO0FBQ2YsY0FBTSxDQUFDLFdBQVcsUUFBUSxJQUFJLE9BQU8sQ0FBQyxHQUFHLENBQUMsSUFBSSxTQUFTLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUM7QUFDckUsY0FBTSxRQUFRLE1BQU0sS0FBSztBQUN6QixjQUFNLG1DQUFtQyxDQUFDLFFBQXdCO0FBQ2hFLGdCQUFNLFlBQVksUUFBUSxZQUFZLFFBQVE7QUFDOUMsaUJBQU87QUFBQSxXQUNKLFNBQVMscUNBQXFDLE1BQU0sS0FBSyxPQUFPLHFCQUMvRCxPQUFPLEtBQUssT0FBTyxRQUFRLEtBQUs7QUFBQSw2QkFDZixPQUFPLFdBQVcsa0JBQWtCLEdBQUcsQ0FBQztBQUFBLDJCQUMxQyxLQUFLLCtEQUErRCxPQUFPLEdBQUcsQ0FBQztBQUFBLFVBQ2hHLFlBQVksR0FBRyxDQUFDLEtBQUssV0FBVyxHQUFHLENBQUMsS0FBSyxJQUFJLEdBQUcsQ0FBQyxLQUFLLElBQUksR0FBRyxDQUFDLE1BQU0sV0FBVyxNQUFNO0FBQUEsZ0NBQy9ELEtBQUs7QUFBQTtBQUFBO0FBQUEsY0FHdkIsZ0JBQWdCLDBDQUEwQyxXQUFXLEdBQUcsQ0FBQztBQUFBLG1CQUNwRSxrQkFBa0I7QUFBQTtBQUFBLDBCQUVYLEtBQUssZ0JBQWdCLEtBQUs7QUFBQTtBQUFBLGdCQUVwQyxTQUFTLEtBQUssS0FBSyxvQkFBb0IsS0FBSztBQUFBLGdCQUM1QyxTQUFTLFdBQVcsU0FBUyxPQUFPLFdBQVcsR0FBRyxDQUFDO0FBQUEsZUFDcEQsTUFBTTtBQUNYLGdCQUFJLGdCQUFnQjtBQUNsQixxQkFBTztBQUFBO0FBQUEsWUFFVCxXQUFXLGtCQUFrQjtBQUMzQixxQkFBTyxVQUFVLGtCQUFrQjtBQUFBLFlBQ3JDLE9BQU87QUFDTCxxQkFBTyxHQUFHLFNBQVMsaUJBQWlCLFNBQVMsS0FBSyxXQUFXLEdBQUcsQ0FBQztBQUFBLFlBQ25FO0FBQUEsVUFDRixHQUFHLENBQUM7QUFBQTtBQUFBLGtDQUVzQixNQUFNLEtBQUssT0FBTztBQUFBLFlBQ3hDLE1BQU0sV0FBVyxzQkFBc0IsS0FBSyxPQUFPLFNBQVMsR0FBRyxDQUFDO0FBQUEsMEJBRWhFLFFBQVEsWUFBWSxNQUFNLGFBQWEsb0JBQW9CLElBQ3ZDLDJEQUEyRDtBQUFBO0FBQUE7QUFBQTtBQUFBLFFBSXJGO0FBRUEsZUFBTztBQUFBLE1BQ1AsaUNBQWlDLFNBQVMsQ0FBQztBQUFBLE1BQzNDLGlDQUFpQyxRQUFRLENBQUM7QUFBQSxxQ0FDWCxLQUFLLGNBQWMsS0FBSztBQUFBO0FBQUEsd0JBRXJDLEtBQUssZ0JBQWdCLEtBQUs7QUFBQSx3QkFDMUIsS0FBSztBQUFBLHdCQUNMLEtBQUs7QUFBQSx1QkFDTixLQUFLO0FBQUEsb0JBQ1IsV0FBVyx3QkFBd0IsV0FBVyx5QkFDeEQsV0FBVyx5QkFBeUIsV0FBVztBQUFBLG9CQUNyQyxXQUFXLG1CQUFtQixXQUFXO0FBQUEsb0JBQ3pDLFdBQVcsMkJBQTJCLFdBQVc7QUFBQSxvQkFDakQsV0FBVyx5QkFBeUIsV0FBVywwQkFDekQsV0FBVywwQkFBMEIsV0FBVztBQUFBO0FBQUE7QUFBQTtBQUFBLHFDQUlyQixLQUFLLHNCQUFzQixLQUFLLFlBQVksS0FBSztBQUFBLG9CQUNsRSxLQUFLO0FBQUE7QUFBQTtBQUFBO0FBQUEsNENBSW1CLE9BQU8sS0FBSyxPQUFPLFFBQVEsS0FBSztBQUFBLHlCQUNuRCxNQUFNLEtBQUssT0FBTztBQUFBO0FBQUE7QUFBQTtBQUFBLE1BSXZDO0FBRUosTUFBTSx5QkFDRixDQUFDLE9BQXNCLFFBQXVCLFlBQStCLGtCQUM1RSx1QkFBdUM7QUFDdEMsY0FBTSxTQUFTO0FBQ2YsY0FBTSxDQUFDLFVBQVUsVUFBVSxXQUFXLFVBQVUsVUFBVSxJQUN0RCxXQUFXLFdBQVcsSUFBSSxDQUFDLElBQUksR0FBRyxHQUFHLEdBQUcsRUFBRSxJQUFLLFNBQVMsQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLENBQUMsSUFBSSxDQUFDLEdBQUcsR0FBRyxHQUFHLEdBQUcsQ0FBQztBQUM1RixjQUFNLFFBQVEsTUFBTSxLQUFLO0FBQ3pCLGVBQU87QUFBQSx3RkFDMkUsS0FBSztBQUFBLDJCQUNsRSxNQUFNLEtBQUssT0FBTztBQUFBLFFBQ3JDLE1BQU0sV0FBVyxpQkFBaUIsVUFBVSxxQkFBcUIsV0FBVyxRQUFRLENBQUMsUUFBUSxDQUFDO0FBQUEsUUFDOUYsTUFBTSxXQUFXLGlCQUFpQixXQUFXLHNCQUFzQixXQUFXLFNBQVMsQ0FBQyxRQUFRLENBQUM7QUFBQSxRQUNqRyxNQUFNLFdBQVcsaUJBQWlCLFVBQVUscUJBQXFCLFdBQVcsUUFBUSxDQUFDLFFBQVEsQ0FBQztBQUFBLFFBQzlGLDBCQUEwQixPQUFPLFlBQVksVUFBVSxDQUFDLENBQUM7QUFBQSxlQUNsRCxNQUFNLGFBQWEsZUFBZSxDQUFDO0FBQUE7QUFBQTtBQUFBLGdEQUdGLE9BQU8sS0FBSyxPQUFPLFFBQVEsS0FBSztBQUFBO0FBQUEsa0JBRTlELEtBQUssc0JBQXNCLFFBQVE7QUFBQSxtQkFDbEMsS0FBSyxzQkFBc0IsU0FBUztBQUFBLGtCQUNyQyxLQUFLLHNCQUFzQixRQUFRO0FBQUEsUUFFM0MsbUJBQW1CLDZCQUE2QixXQUFXLFFBQVEsQ0FBQyxvQ0FDN0MsV0FBVyxTQUFTLENBQUMsa0NBQWtDLFdBQVcsUUFBUSxDQUFDO0FBQUEsZUFDN0Ysa0JBQWtCO0FBQUEsYUFFSixFQUFFO0FBQUE7QUFBQSxnQ0FFQyxXQUFXLFFBQVEsQ0FBQztBQUFBLG9DQUNoQixXQUFXLFNBQVMsQ0FBQztBQUFBLGtDQUN2QixXQUFXLFFBQVEsQ0FBQztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLDJCQU8zQixXQUFXLFNBQVMsSUFBSSx1QkFBdUIsVUFBVSxPQUFPLEdBQUc7QUFBQSwwQkFDcEUsV0FBVyxTQUFTLElBQUksdUJBQXVCLFFBQVEsT0FBTyxHQUFHO0FBQUE7QUFBQSxrQkFFekUsS0FBSztBQUFBLGtCQUNMLEtBQUs7QUFBQSxrQkFDTCxLQUFLO0FBQUEsa0JBQ0wsS0FBSztBQUFBLGtCQUNMLEtBQUs7QUFBQSxrQkFDTCxLQUFLO0FBQUEsa0JBQ0wsS0FBSztBQUFBLGtCQUNMLEtBQUs7QUFBQSxpQkFDTixLQUFLLGtCQUFrQixLQUFLO0FBQUEsaUJBQzVCLEtBQUssVUFBVSxLQUFLO0FBQUEsaUJBQ3BCLEtBQUssbUJBQW1CLEtBQUs7QUFBQSxpQkFDN0IsS0FBSyxVQUFVLEtBQUs7QUFBQSxpQkFDcEIsS0FBSyxrQkFBa0IsS0FBSztBQUFBLGlCQUM1QixLQUFLLFVBQVUsS0FBSztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BZ0JqQztBQUVKLE1BQU0sMEJBQ0YsQ0FBQyxhQUF5QixZQUE4QixjQUFzQixhQUM3RSxPQUEwQixhQUE2QztBQUN0RSxjQUFNLGFBQWEsWUFBWTtBQUMvQixjQUFNLE1BQU0sVUFBVSxVQUFVLFdBQVcsTUFBTSxXQUFXLE1BQU07QUFFbEUsWUFBSSxjQUFjLGdCQUFnQixZQUFZLGFBQWEsT0FBTyxXQUFXLElBQUk7QUFDakYsWUFBSSxTQUFTLFlBQVksTUFBTTtBQUMvQixZQUFJLFlBQVksV0FBVyxHQUFHO0FBQzVCLG1CQUFTLFdBQVcsSUFBSSxDQUFDLE9BQU8sVUFBVSxVQUFVLElBQUksSUFBTSxZQUFZLEtBQUssSUFBSSxLQUFLO0FBQ3hGLGNBQUksV0FBVywwQkFBMEIsV0FBVztBQUNsRCwwQkFBYyxrQkFBa0IsWUFBWSxRQUFRLFVBQVU7QUFBQSxVQUNoRTtBQUFBLFFBQ0Y7QUFDQSxjQUFNLFNBQVMsZUFBZSxVQUFVLFlBQVksVUFBVSxZQUFZLE1BQU07QUFDaEYsY0FBTSxRQUFRLGNBQWMsU0FBUyxZQUFZLFVBQVUsV0FBVyxNQUFNO0FBQzVFLGNBQU0sYUFBYSxVQUFVLEtBQUssV0FBVztBQUM3QyxjQUFNLFVBQVUsV0FBVyxXQUFXLFlBQVksVUFBVSxXQUFXLE1BQU0sQ0FBQyxHQUFHLE1BQU0sTUFBTSxZQUFZLENBQUMsQ0FBQztBQUMzRyxjQUFNLG1CQUFtQixXQUFXLDRCQUE0QjtBQUNoRSxjQUFNLHFCQUFxQixXQUFXO0FBQ3RDLGNBQU0sV0FBVyxNQUFNLEtBQUs7QUFDNUIsY0FBTSxrQkFBa0IsQ0FBQyxpQkFBK0I7QUFBQSxRQUN0RCxVQUFVLEtBQUs7QUFBQSxRQUNmLDJDQUEyQyxXQUFXLHlCQUF5QixRQUFRLENBQUM7QUFBQSxTQUN2RixNQUFNO0FBQ1Asa0JBQVEsV0FBVyxNQUFNO0FBQUEsWUFDdkIsS0FBSztBQUNILHFCQUFPO0FBQUEsZ0JBQ0gsa0JBQWtCLE9BQU8sVUFBVSxDQUFDO0FBQUEsZ0JBQ3BDLDRCQUE0QixXQUFXLGFBQWEsY0FBYyxRQUFRLENBQUM7QUFBQSxnQkFFM0U7QUFBQSxnQkFDSTtBQUFBLGdCQUFPO0FBQUEsZ0JBQVE7QUFBQSxnQkFBWTtBQUFBLGdCQUFhLE9BQU87QUFBQSxnQkFBUSxJQUFJO0FBQUEsZ0JBQVE7QUFBQSxjQUFnQixDQUFDO0FBQUE7QUFBQSxZQUU5RixLQUFLO0FBQ0gscUJBQU87QUFBQSxnQkFDSCwwQ0FBMEMsUUFBUSxZQUFZLGFBQWEsT0FBTyxRQUFRLElBQUksTUFBTSxDQUFDO0FBQUEsaUJBQ3BHLE1BQU07QUFDVCxvQkFBSSxXQUFXLFdBQVcsS0FBSyxXQUFXLFdBQVcsR0FBRztBQUN0RCx5QkFBTyxHQUFHLHNCQUFzQixPQUFPLFFBQVEsWUFBWSxrQkFBa0Isa0JBQWtCLENBQUM7QUFBQSxnQkFDbEcsV0FBVyxXQUFXLFdBQVcsS0FBSyxXQUFXLFdBQVcsR0FBRztBQUM3RCx5QkFBTyxHQUFHLHVCQUF1QixPQUFPLFFBQVEsWUFBWSxrQkFBa0Isa0JBQWtCLENBQUM7QUFBQSxnQkFDbkcsT0FBTztBQUNMLHdCQUFNLE1BQU0sa0ZBQWtGO0FBQUEsZ0JBQ2hHO0FBQUEsY0FDRixHQUFHLENBQUM7QUFBQTtBQUFBLFlBRU4sS0FBSztBQUNILHFCQUFPO0FBQUEsZUFDSixNQUFNO0FBQ1Asb0JBQUksV0FBVyxXQUFXLEtBQUssV0FBVyxXQUFXLEdBQUc7QUFDdEQseUJBQU8sR0FDSDtBQUFBLG9CQUNJO0FBQUEsb0JBQU87QUFBQSxvQkFBUTtBQUFBLG9CQUFZO0FBQUEsb0JBQWE7QUFBQSxvQkFBUTtBQUFBLG9CQUFLLFdBQVc7QUFBQSxvQkFBYTtBQUFBLG9CQUM3RSxXQUFXO0FBQUEsb0JBQW9CLFdBQVc7QUFBQSxrQkFBYyxDQUFDO0FBQUEsZ0JBQ25FLE9BQU87QUFDTCx3QkFBTSxNQUFNLDJFQUEyRTtBQUFBLGdCQUN6RjtBQUFBLGNBQ0YsR0FBRyxDQUFDO0FBQUE7QUFBQSxZQUVOO0FBQ0Usb0JBQU0sTUFBTSxxQkFBcUI7QUFBQSxVQUNyQztBQUFBLFFBQ0YsR0FBRyxDQUFDO0FBQUEsT0FDSDtBQUFBLFFBRUcsYUFBYSxnQkFBZ0IsZUFBZSxLQUFLLEVBQzVDLGdCQUFnQixVQUFVLE9BQU8sT0FBTyxNQUFNLEVBQzlDLGdCQUFnQixPQUFPLE9BQU8sSUFBSSxNQUFNLEVBQ3hDLGlCQUFpQixPQUFPLE1BQU0sQ0FBQztBQUFBLFFBQ3RDLGFBQWEsVUFBVSxDQUFDO0FBQUEsVUFDdEIsYUFBYSxzQ0FBc0Msc0JBQXNCLENBQUM7QUFBQSxVQUMxRSxVQUFVLDRDQUE0QztBQUFBLCtCQUNqQyxPQUFPLGdCQUFnQixZQUFZLENBQUM7QUFBQSw2QkFDdEMsTUFBTSxLQUFLLE9BQU87QUFBQSxXQUNwQyxNQUFNO0FBQ1Qsa0JBQVEsV0FBVyxNQUFNO0FBQUEsWUFDdkIsS0FBSztBQUNILHFCQUFPO0FBQUE7QUFBQSx5Q0FFc0IsTUFBTSxhQUFhLGVBQWUsQ0FBQztBQUFBO0FBQUEseUNBRW5DLFdBQVcsa0JBQWtCO0FBQUE7QUFBQSxZQUU1RCxLQUFLO0FBQ0gscUJBQU8sd0JBQ0YsV0FBVyxXQUFXLEtBQUssV0FBVyxXQUFXLElBQUssMEJBQ0Esd0JBQXdCO0FBQUEsWUFDckYsS0FBSztBQUNILHFCQUFPO0FBQUEsWUFDVDtBQUNFLG9CQUFNLE1BQU0sNEJBQTRCLFdBQVcsSUFBSSxFQUFFO0FBQUEsVUFDN0Q7QUFBQSxRQUNGLEdBQUcsQ0FBQztBQUFBLENBQ1Q7QUFBQTtBQUdLLGVBQU87QUFBQSxVQUNMLE1BQU07QUFBQSxVQUNOLGFBQWE7QUFBQSxZQUNYLE1BQU0sR0FBRyxXQUFXLFFBQVEsSUFBSSxZQUFZLElBQUksT0FBTyxTQUFTLElBQUksU0FBUyxFQUFFLElBQzNFLE1BQU0sU0FBUyxJQUFJLFFBQVEsRUFBRSxJQUFJLElBQUksU0FBUyxJQUFJLE1BQU0sRUFBRSxJQUFJLE9BQU8sSUFBSSxVQUFVO0FBQUEsWUFDdkYsbUJBQW1CLENBQUMsTUFBTTtBQUFBLFVBQzVCO0FBQUEsVUFDQTtBQUFBLFVBQ0EsWUFBWSxPQUFPO0FBQUEsWUFDakIsU0FBUyxDQUFDLEVBQUMsTUFBTSxhQUFhLFVBQVUsWUFBWSxTQUFRLENBQUM7QUFBQSxZQUM3RCxlQUFlLEVBQUMsR0FBRyxLQUFLO0FBQUEsY0FBSyxhQUFhO0FBQUE7QUFBQSxZQUF1QixFQUFDO0FBQUEsWUFDbEUsaUJBQWlCO0FBQUEsY0FDZixFQUFDLE1BQU0sVUFBVSxNQUFNLFdBQVU7QUFBQSxjQUNqQyxFQUFDLE1BQU0sV0FBVyxNQUFNLE9BQU07QUFBQSxjQUM5QixFQUFDLE1BQU0sV0FBVyxNQUFNLElBQUc7QUFBQSxjQUMzQixHQUFHLDJCQUEyQixVQUFVO0FBQUEsY0FDeEMsR0FBRywyQkFBMkIsV0FBVztBQUFBLFlBQzNDO0FBQUEsVUFDRjtBQUFBLFFBQ0Y7QUFBQSxNQUNGO0FBRUosTUFBTSxzQ0FBc0MsQ0FBQyxZQUFvQztBQUMvRSxjQUFNLG1CQUFtQixRQUFRO0FBQ2pDLGNBQU0scUJBQXFCLElBQUksWUFBWSxrQkFBa0IsaUJBQWlCLFlBQVksQ0FBQztBQUMzRixjQUFNLGVBQWUsbUJBQW1CLENBQUM7QUFDekMsZUFBTztBQUFBLE1BQ1Q7QUFFTyxNQUFNLFNBQVMsQ0FBQyxTQUF5QixlQUF1QztBQUNyRixjQUFNLFNBQW1CLENBQUM7QUFDMUIsY0FBTSxRQUFrQixDQUFDO0FBQ3pCLGNBQU0sTUFBZ0IsQ0FBQztBQUt2QixjQUFNLGVBQWUsb0NBQW9DLE9BQU87QUFDaEUsWUFBSSxXQUFXLGNBQWMsR0FBRztBQUM5QixnQkFBTSxNQUFNLDZEQUE2RDtBQUFBLFFBQzNFO0FBQ0EsUUFBQUEsaUJBQWUsUUFBUSxRQUFRLFlBQVksY0FBYyxRQUFRLE9BQU8sR0FBRztBQUMzRSxnQkFBUTtBQUFBLFVBQ0osd0JBQXdCLFFBQVEsT0FBTyxDQUFDLEdBQUcsWUFBWSxjQUFjLFFBQVEsT0FBTyxHQUFHO0FBQUEsVUFBRyxFQUFDLFFBQVEsQ0FBQyxDQUFDLEVBQUM7QUFBQSxRQUFDO0FBQUEsTUFDN0c7QUFFTyxNQUFNLHdCQUF3QixDQUFDLGVBQTBEO0FBQzlGLGNBQU0sWUFBWSxXQUFXO0FBQzdCLGNBQU0sT0FBTyxXQUFXO0FBQ3hCLGNBQU0sMEJBQ0YsV0FBVztBQUNmLGNBQU0sY0FBYyxXQUFXO0FBQy9CLGNBQU0saUJBQWlCLFdBQVcsbUJBQTZCO0FBQy9ELGNBQU0scUJBQXFCLFdBQVc7QUFDdEMsY0FBTSx3QkFBK0MsV0FBVztBQUNoRSxjQUFNLE9BQWEsV0FBVztBQUU5QixjQUFNLGNBQTRCLFdBQVcsZ0JBQWdCLEtBQUssV0FBVyxXQUFXO0FBQ3hGLGVBQU8sNEJBQTRCO0FBQUEsVUFDakM7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFFBQ0YsQ0FBQztBQUFBLE1BQ0g7QUFBQTtBQUFBOzs7QUM1ckJBLE1BZU1DLGtCQXlEQSxnQ0F5Rk8sZUFvQkE7QUFyTGI7QUFBQTtBQUFBO0FBR0E7QUFFQTtBQUNBO0FBR0E7QUFNQSxNQUFNQSxtQkFBaUIsQ0FBQyxXQUF3QztBQUM5RCxZQUFJLENBQUMsVUFBVSxPQUFPLFNBQVMsR0FBRztBQUNoQyxnQkFBTSxJQUFJLE1BQU0sdUNBQXVDO0FBQUEsUUFDekQ7QUFFQSxjQUFNLFFBQW9CLE9BQU8sQ0FBQztBQUNsQyxjQUFNLE9BQW1CLE9BQU8sQ0FBQztBQUNqQyxjQUFNLFFBQW9CLE9BQU8sQ0FBQztBQUVsQyxZQUFJLE1BQU0sYUFBYSxLQUFLLFlBQVksTUFBTSxhQUFhLE1BQU0sVUFBVTtBQUN6RSxnQkFBTSxJQUFJLE1BQU0seUNBQXlDO0FBQUEsUUFDM0Q7QUFFQSxZQUFJLE1BQU0sS0FBSyxXQUFXLEtBQUssTUFBTSxLQUFLLFdBQVcsR0FBRztBQUN0RCxnQkFBTSxJQUFJLE1BQU0sd0JBQXdCO0FBQUEsUUFDMUM7QUFFQSxZQUFJLEtBQUssS0FBSyxXQUFXLEtBQUssS0FBSyxLQUFLLFdBQVcsR0FBRztBQUNwRCxnQkFBTSxJQUFJLE1BQU0sdUJBQXVCO0FBQUEsUUFDekM7QUFFQSxjQUFNLGFBQWEsTUFBTSxLQUFLLE1BQU0sS0FBSyxTQUFTLENBQUM7QUFDbkQsY0FBTSxpQkFBaUIsTUFBTSxLQUFLLE1BQU0sS0FBSyxTQUFTLENBQUM7QUFDdkQsWUFBSSxLQUFLLEtBQUssS0FBSyxLQUFLLFNBQVMsQ0FBQyxNQUFNLFlBQVk7QUFDbEQsZ0JBQU0sSUFBSSxNQUFNLDhDQUE4QztBQUFBLFFBQ2hFO0FBQ0EsWUFBSSxLQUFLLEtBQUssS0FBSyxLQUFLLFNBQVMsQ0FBQyxNQUFNLGdCQUFnQjtBQUN0RCxnQkFBTSxJQUFJLE1BQU0sa0RBQWtEO0FBQUEsUUFDcEU7QUFFQSxZQUFJLE1BQU0sS0FBSyxXQUFXLEdBQUc7QUFDM0IsZ0JBQU0sSUFBSSxNQUFNLGtCQUFrQjtBQUFBLFFBQ3BDO0FBQ0EsWUFBSSxNQUFNLEtBQUssTUFBTSxLQUFLLFNBQVMsQ0FBQyxNQUFNLFlBQVk7QUFDcEQsZ0JBQU0sSUFBSSxNQUFNLCtDQUErQztBQUFBLFFBQ2pFO0FBQ0EsWUFBSSxPQUFPLFNBQVMsR0FBRztBQUNyQixnQkFBTSxPQUFtQixPQUFPLENBQUM7QUFDakMsY0FBSSxLQUFLLEtBQUssV0FBVyxHQUFHO0FBQzFCLGtCQUFNLElBQUksTUFBTSxpQkFBaUI7QUFBQSxVQUNuQztBQUNBLGNBQUksS0FBSyxLQUFLLEtBQUssS0FBSyxTQUFTLENBQUMsTUFBTSxZQUFZO0FBQ2xELGtCQUFNLElBQUksTUFBTSw4Q0FBOEM7QUFBQSxVQUNoRTtBQUFBLFFBQ0Y7QUFFQSxZQUFJLE9BQU8sU0FBUyxHQUFHO0FBQ3JCLGdCQUFNLE9BQW1CLE9BQU8sQ0FBQztBQUNqQyxjQUFJLEtBQUssS0FBSyxXQUFXLEdBQUc7QUFDMUIsa0JBQU0sSUFBSSxNQUFNLGlCQUFpQjtBQUFBLFVBQ25DO0FBQ0EsY0FBSSxLQUFLLEtBQUssS0FBSyxLQUFLLFNBQVMsQ0FBQyxNQUFNLFlBQVk7QUFDbEQsa0JBQU0sSUFBSSxNQUFNLDhDQUE4QztBQUFBLFVBQ2hFO0FBQUEsUUFDRjtBQUFBLE1BQ0Y7QUFFQSxNQUFNLGlDQUNGLENBQUMsUUFBK0IsWUFBcUMsYUFBcUIsZUFDdkU7QUFDYixjQUFNLGFBQWEsT0FBTyxDQUFDLEVBQUU7QUFDN0IsY0FBTSxZQUFZLFVBQVUsS0FBSyxVQUFVO0FBQzNDLGNBQU0sY0FBYztBQUNwQixjQUFNLGFBQWE7QUFDbkIsY0FBTSxhQUFhLFdBQVcsTUFBTSxFQUFFLEVBQUUsQ0FBQztBQUN6QyxjQUFNLG1CQUFtQixhQUFhLFdBQVcsTUFBTSxHQUFHLEVBQUUsRUFBRSxPQUFPLENBQUMsSUFBSSxDQUFDO0FBQzNFLGNBQU0sZUFBZSxPQUFPLFNBQVM7QUFDckMsY0FBTSxlQUFlLE9BQU8sU0FBUztBQUNyQyxjQUFNLGdCQUFnQixjQUFjLGNBQWM7QUFDbEQsY0FBTSxxQkFBcUIsY0FBYyxjQUFjO0FBQ3ZELGNBQU0sNEJBQTRCLGNBQWM7QUFFaEQsY0FBTSxhQUFhLGlCQUFpQixVQUFVO0FBQzlDLGNBQU0sWUFBWTtBQUFBLFVBQ2hCLGNBQWMsS0FBSyxPQUFPLENBQUMsRUFBRSxVQUFVLE9BQU8sQ0FBQyxFQUFFLE1BQU0sVUFBVTtBQUFBLFVBQ2pFLGNBQWMsUUFBUSxPQUFPLENBQUMsRUFBRSxVQUFVLE9BQU8sQ0FBQyxFQUFFLE1BQU0sVUFBVTtBQUFBLFVBQ3BFLGNBQWMsU0FBUyxPQUFPLENBQUMsRUFBRSxVQUFVLE9BQU8sQ0FBQyxFQUFFLE1BQU0sVUFBVTtBQUFBLFFBQ3ZFO0FBQ0EsWUFBSSxjQUFjO0FBQ2hCLG9CQUFVLEtBQUssY0FBYyxRQUFRLE9BQU8sQ0FBQyxFQUFFLFVBQVUsT0FBTyxDQUFDLEVBQUUsTUFBTSxVQUFVLENBQUM7QUFBQSxRQUN0RjtBQUNBLFlBQUksY0FBYztBQUNoQixvQkFBVSxLQUFLLGNBQWMsUUFBUSxPQUFPLENBQUMsRUFBRSxVQUFVLE9BQU8sQ0FBQyxFQUFFLE1BQU0sVUFBVSxDQUFDO0FBQUEsUUFDdEY7QUFDQSxrQkFBVSxLQUFLLGVBQWUsVUFBVSxPQUFPLENBQUMsRUFBRSxVQUFVLGFBQWEsVUFBVSxDQUFDO0FBQ3BGLFlBQUksZUFBZTtBQUNqQixvQkFBVSxLQUFLLGVBQWUsNkJBQThCLGdCQUFnQixDQUFDO0FBQUEsUUFDL0U7QUFDQSxZQUFJLG9CQUFvQjtBQUN0QixvQkFBVSxLQUFLLGVBQWUsK0JBQWdDLGdCQUFnQixDQUFDO0FBQUEsUUFDakY7QUFDQSxZQUFJLDJCQUEyQjtBQUM3QixvQkFBVSxLQUFLLGVBQWUsb0JBQW9CLE9BQU8sQ0FBQyxFQUFFLFVBQVUsYUFBYSxVQUFVLENBQUM7QUFBQSxRQUNoRztBQUNBLGNBQU0sV0FBVyw0QkFBNEIsT0FBTyxDQUFDLEVBQUUsUUFBUTtBQUMvRCxjQUFNLGtCQUFrQixDQUFDLGlCQUErQjtBQUFBLGdDQUNsQyxVQUFVO0FBQUEsMENBQ0EsYUFBYSxVQUFVO0FBQUEsNkJBQ3BDLFdBQVcsT0FBTztBQUFBO0FBQUEsUUFFdkMsYUFBYSxpQkFBaUIsR0FBRyxTQUFTLENBQUM7QUFBQTtBQUFBLFFBRTNDLGFBQWEsVUFBVSxDQUFDO0FBQUEsVUFDdEIsYUFBYSxzQ0FBc0MsYUFBYSxVQUFVLENBQUM7QUFBQTtBQUFBLG9CQUVqRSxXQUFXLE9BQU8sVUFBVSxDQUFDO0FBQUEsMEJBQ3ZCLFdBQVcsT0FBTyxVQUFVLENBQUM7QUFBQTtBQUFBO0FBQUEsNEJBRzNCLGVBQWUsWUFBWSxLQUFLO0FBQUE7QUFBQTtBQUFBLFlBR2hELDRCQUE0QiwwQ0FBMEMsRUFBRTtBQUFBO0FBQUEsMkJBRXpELFVBQVUsVUFBVSxZQUFZLE9BQU8sQ0FBQztBQUFBO0FBQUE7QUFBQTtBQUFBLHFCQUk5QyxVQUFVLE9BQU8sVUFBVSxDQUFDO0FBQUEsc0NBQ1gsVUFBVSxhQUFhLFVBQVUsQ0FBQztBQUFBLFVBQzlELGdCQUFnQixtQ0FBbUMsRUFBRTtBQUFBLFVBQ3JELHFCQUFxQiwwQ0FBMEMsRUFBRTtBQUFBO0FBQUEsdURBRXBCLFFBQVEsYUFBYSxRQUFRO0FBQUEsZUFDckUsZUFBZSxZQUFZLEtBQUs7QUFBQTtBQUFBO0FBR3JDLGNBQU0sVUFBVSxDQUFDLEVBQUMsTUFBTSxhQUFhLFVBQVUsT0FBTyxDQUFDLEVBQUUsU0FBUSxDQUFDO0FBQ2xFLFlBQUksY0FBYyxHQUFHO0FBQ25CLGtCQUFRLEtBQUssRUFBQyxNQUFNLGtCQUFrQix3QkFBd0IsQ0FBQztBQUFBLFFBQ2pFO0FBQ0EsWUFBSSxjQUFjLEdBQUc7QUFDbkIsa0JBQVEsS0FBSyxFQUFDLE1BQU0sa0JBQWtCLHdCQUF3QixDQUFDO0FBQUEsUUFDakU7QUFDQSxZQUFJLGNBQWMsR0FBRztBQUNuQixrQkFBUSxLQUFLLEVBQUMsTUFBTSxZQUFZLFVBQVUsT0FBTyxDQUFDLEVBQUUsU0FBUSxDQUFDO0FBQUEsUUFDL0Q7QUFFQSxlQUFPO0FBQUEsVUFDTCxNQUFNO0FBQUEsVUFDTixhQUFhLEVBQUMsTUFBTSxXQUFXLFNBQVE7QUFBQSxVQUN2QztBQUFBLFVBQ0EsWUFBWSxPQUFPLEVBQUMsU0FBUyxlQUFlLEVBQUMsR0FBRyxLQUFLLEtBQUssYUFBYSxhQUFhLEVBQUUsRUFBQyxFQUFDO0FBQUEsUUFDMUY7QUFBQSxNQUNGO0FBRUQsTUFBTSxnQkFBZ0IsQ0FBQyxTQUF5QixlQUE4QztBQUVuRyxjQUFNLGFBQWE7QUFDbkIsUUFBQUEsaUJBQWUsUUFBUSxNQUFNO0FBRzdCLGNBQU0sVUFBVSxDQUFDLENBQUM7QUFDbEIsWUFBSSxRQUFRLGNBQWMsR0FBRztBQUMzQixrQkFBUSxLQUFLLGFBQWEsSUFBSSxFQUFFO0FBQUEsUUFDbEM7QUFDQSxZQUFJLFFBQVEsY0FBYyxHQUFHO0FBQzNCLGtCQUFRLEtBQUssYUFBYSxJQUFJLEVBQUU7QUFBQSxRQUNsQztBQUNBLFlBQUksUUFBUSxjQUFjLEdBQUc7QUFDM0Isa0JBQVEsS0FBSyxDQUFDO0FBQUEsUUFDaEI7QUFDQSxnQkFBUTtBQUFBLFVBQ0osK0JBQStCLFFBQVEsUUFBUSxZQUFZLFFBQVEsYUFBYSxVQUFVO0FBQUEsVUFBRyxFQUFDLFFBQU87QUFBQSxRQUFDO0FBQUEsTUFDNUc7QUFFTyxNQUFNLCtCQUErQixDQUFDLGVBQWlFO0FBQzVHLGNBQU0sVUFBVSxXQUFXO0FBQzNCLGVBQU8sNEJBQTRCLEVBQUMsUUFBTyxDQUFDO0FBQUEsTUFDOUM7QUFBQTtBQUFBOzs7QUN4TEEsTUFpQk1DLGtCQWtCQSxXQWNBLGlDQWVBLG1CQWNBLDJCQXNCQSx3QkFtRk8sT0FZQTtBQW5NYjtBQUFBO0FBQUE7QUFHQTtBQUVBO0FBQ0E7QUFHQTtBQVFBLE1BQU1BLG1CQUFpQixDQUFDLFFBQStCLGVBQXNDO0FBQzNGLFlBQUksQ0FBQyxVQUFVLE9BQU8sU0FBUyxHQUFHO0FBQ2hDLGdCQUFNLElBQUksTUFBTSxnQkFBZ0I7QUFBQSxRQUNsQztBQUNBLFlBQUksV0FBVyxLQUFLLFdBQVcsR0FBRztBQUNoQyxjQUFJLFdBQVcsS0FBSyxXQUFXLFdBQVcsT0FBTyxVQUFVLFdBQVcsS0FBSyxXQUFXLFdBQVcsS0FBSyxRQUFRO0FBQzVHLGtCQUFNLElBQUksTUFBTSxpREFBaUQ7QUFBQSxVQUNuRTtBQUFBLFFBQ0YsV0FBVyxXQUFXLE9BQU8sV0FBVyxXQUFXLEtBQUssUUFBUTtBQUM5RCxnQkFBTSxJQUFJLE1BQU0sMkNBQTJDO0FBQUEsUUFDN0Q7QUFDQSxlQUFPLE1BQU0sQ0FBQyxFQUFFLFFBQVEsQ0FBQyxHQUFHLFFBQVE7QUFDbEMsY0FBSSxPQUFPLE1BQU0sQ0FBQyxFQUFFLDhCQUErQixPQUFPLE1BQU0sQ0FBQyxFQUFFLDRCQUE2QjtBQUM5RixrQkFBTSxJQUFJLE1BQU0sU0FBUyxHQUFHLHFDQUFxQztBQUFBLFVBQ25FO0FBQUEsUUFDRixDQUFDO0FBQUEsTUFDSDtBQUVBLE1BQU0sWUFBWSxDQUFDLFFBQStCLFFBQTBCO0FBQzFFLGNBQU0sUUFBa0IsQ0FBQztBQUN6QixZQUFJLE9BQU8sU0FBUyxLQUFLO0FBQ3ZCLGNBQUksT0FBTyxHQUFHLEVBQUUsNEJBQTZCO0FBQzNDLG1CQUFPLEdBQUcsRUFBRSxpQkFBaUIsRUFBRSxRQUFRLE9BQUssTUFBTSxLQUFLLE9BQU8sQ0FBQyxDQUFDLENBQUM7QUFBQSxVQUNuRSxXQUFXLE9BQU8sR0FBRyxFQUFFLDRCQUE2QjtBQUNsRCxtQkFBTyxHQUFHLEVBQUUsY0FBYyxFQUFFLFFBQVEsT0FBSyxNQUFNLEtBQUssT0FBTyxDQUFDLENBQUMsQ0FBQztBQUFBLFVBQ2hFLE9BQU87QUFDTCxrQkFBTSxJQUFJLE1BQU0sU0FBUyxHQUFHLHFDQUFxQztBQUFBLFVBQ25FO0FBQUEsUUFDRjtBQUNBLGVBQU87QUFBQSxNQUNUO0FBRUEsTUFBTSxrQ0FDRixDQUFDLFFBQStCLGVBQWlEO0FBQy9FLFlBQUksT0FBTyxTQUFTLEdBQUc7QUFDckIsZ0JBQU0sU0FBbUIsVUFBVSxRQUFRLENBQUM7QUFDNUMsZ0JBQU0sT0FBaUIsVUFBVSxRQUFRLENBQUM7QUFDMUMsY0FBSSxPQUFpQixVQUFVLFFBQVEsQ0FBQztBQUN4QyxjQUFJLEtBQUssV0FBVyxHQUFHO0FBQ3JCLG1CQUFPLENBQUMsR0FBRyxNQUFNLE9BQU8sQ0FBQyxFQUFFLEtBQUssTUFBTSxFQUFFLEtBQUssQ0FBQztBQUFBLFVBQ2hEO0FBQ0EsaUJBQU8sNEJBQTRCLEVBQUMsUUFBUSxNQUFNLEtBQUksQ0FBQztBQUFBLFFBQ3pELE9BQU87QUFDTCxpQkFBTztBQUFBLFFBQ1Q7QUFBQSxNQUNGO0FBRUosTUFBTSxvQkFDRixDQUFDLE9BQWUsT0FBZSxZQUErQixNQUF5QixVQUN6RTtBQUNSLFlBQUksV0FBVztBQUNmLFlBQUksUUFBUSxHQUFHO0FBQ2Isc0JBQVksV0FBVyxLQUFLLEtBQUssQ0FBQztBQUFBLFFBQ3BDO0FBQ0EsWUFBSSxNQUFNLEtBQUssSUFBSSxHQUFHO0FBQ3BCLGlCQUFPLEtBQUssSUFBSSxHQUFHLEtBQUssSUFBSSxVQUFVLFdBQVcsS0FBSyxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUM7QUFBQSxRQUNwRSxPQUFPO0FBQ0wsaUJBQU8sS0FBSyxJQUFJLEdBQUcsS0FBSyxJQUFJLFVBQVUsV0FBVyxLQUFLLEtBQUssQ0FBQyxDQUFDLENBQUM7QUFBQSxRQUNoRTtBQUFBLE1BQ0Y7QUFFUixNQUFNLDRCQUNGLENBQUMsT0FBc0IsUUFBdUIsZUFDMUMsNENBQTRDLE9BQU8sS0FBSyxPQUFPLFFBQVEsTUFBTSxLQUFLLE9BQU87QUFBQSwrQkFDbEUsTUFBTSxLQUFLLE9BQU87QUFBQTtBQUFBLHlCQUV4QixXQUFXLE1BQU07QUFBQSxrQ0FDUixhQUFhLHdCQUF3QixLQUFLLFdBQVcsTUFBTSxDQUFDO0FBQUEsNEJBQ2xFLGFBQWEsa0JBQWtCLEtBQUssV0FBVyxNQUFNLENBQUM7QUFBQSw0QkFDdEQsYUFBYSxrQkFBa0IsS0FBSyxXQUFXLE1BQU0sQ0FBQztBQUFBLDZCQUNyRCxhQUFhLG1CQUFtQixLQUFLLFdBQVcsTUFBTSxDQUFDO0FBQUEsaUNBQ25ELE9BQU8sV0FBVyxrQkFBa0IsR0FBRyxDQUFDO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsY0FPM0QsTUFBTSxXQUFXLGlCQUFpQixLQUFLLGFBQWEsQ0FBQztBQUFBO0FBQUE7QUFBQTtBQUtuRSxNQUFNLHlCQUF5QixDQUFDLFFBQStCLGVBQTZDO0FBQzFHLGNBQU0sYUFBYSxPQUFPLENBQUMsRUFBRTtBQUM3QixjQUFNLFlBQVksVUFBVSxLQUFLLFVBQVU7QUFDM0MsY0FBTSxPQUFRLFdBQVcsS0FBSyxTQUFTLElBQUssVUFBVSxjQUFjLFdBQVcsTUFBTSxXQUFXLE1BQU0sSUFDMUQsQ0FBQyxHQUFHLE1BQU0sV0FBVyxNQUFNLEVBQUUsS0FBSyxDQUFDO0FBQy9FLFlBQUksUUFBUSxVQUFVLFFBQVEsQ0FBQztBQUMvQixjQUFNLFFBQVEsQ0FBQyxTQUFTLFNBQVMsTUFBTSxNQUFNO0FBQ25CLGdCQUFNLElBQUksTUFBTSxrQkFBa0I7QUFBQSxRQUNwQyxFQUFFO0FBQzFCLFlBQUksTUFBTSxXQUFXLEdBQUc7QUFDdEIsa0JBQVEsTUFBTSxLQUFLLE1BQU0sRUFBRSxLQUFLLENBQUM7QUFBQSxRQUNuQztBQUNBLGNBQU0sU0FBUyxXQUFXLE9BQU8sSUFBSSxDQUFDLE9BQU8sTUFBTSxrQkFBa0IsT0FBTyxHQUFHLFlBQVksTUFBTSxLQUFLLENBQUM7QUFFdkcsY0FBTSxPQUFPLFdBQVcsS0FBSyxJQUFJLENBQUMsS0FBSyxNQUFNLGtCQUFrQixLQUFLLEdBQUcsWUFBWSxNQUFNLEtBQUssQ0FBQztBQUUvRixZQUFJLEtBQUssV0FBVyxPQUFPLFVBQVUsS0FBSyxXQUFXLEtBQUssUUFBUTtBQUNoRSxnQkFBTSxJQUFJLE1BQU0sOERBQThEO0FBQUEsUUFDaEY7QUFFQSxZQUFJLEtBQUssV0FBVyxXQUFXLFFBQVE7QUFDckMsbUJBQVMsSUFBSSxHQUFHLElBQUksV0FBVyxRQUFRLEVBQUUsR0FBRztBQUMxQyxnQkFBSSxDQUFDLEtBQUssU0FBUyxDQUFDLEdBQUc7QUFDckIscUJBQU8sT0FBTyxHQUFHLEdBQUcsQ0FBQztBQUNyQixtQkFBSyxPQUFPLEdBQUcsR0FBRyxXQUFXLENBQUMsQ0FBQztBQUMvQixvQkFBTSxPQUFPLEdBQUcsR0FBRyxDQUFDO0FBQUEsWUFDdEI7QUFBQSxVQUNGO0FBQUEsUUFDRjtBQUNBLGNBQU0sUUFBUSxNQUFNLElBQUksVUFBUSxLQUFLLEtBQUssSUFBSSxDQUFDO0FBRS9DLGNBQU0sUUFBUSxDQUFDLE1BQU0sR0FBRyxVQUFVO0FBQ2hDLGNBQUksT0FBTyxHQUFHO0FBQ1osa0JBQU0sWUFBWSxLQUFLLENBQUMsSUFBSSxPQUFPLENBQUMsS0FBSztBQUN6QyxrQkFBTSxTQUFTLE9BQU8sQ0FBQztBQUN2QixrQkFBTSxXQUFXLFNBQVMsV0FBVyxNQUFNLENBQUM7QUFDNUMsbUJBQU8sQ0FBQyxJQUFJO0FBQ1osaUJBQUssQ0FBQyxJQUFJO0FBQ1Ysa0JBQU0sQ0FBQyxJQUFJLENBQUM7QUFBQSxVQUNkO0FBQUEsUUFDRixDQUFDO0FBRUQsY0FBTSxjQUFjLFdBQVcsTUFBTSxDQUFDO0FBQ3RDLGFBQUssUUFBUSxDQUFDLE1BQU0sTUFBTTtBQUN4QixzQkFBWSxJQUFJLElBQUksS0FBSyxNQUFNLEtBQUssSUFBSSxJQUFJLE9BQU8sSUFBSSxLQUFLLE1BQU0sSUFBSSxDQUFDO0FBQUEsUUFDekUsQ0FBQztBQUNELGNBQU0sbUJBQStCLEVBQUMsTUFBTSxhQUFhLFVBQVUsT0FBTyxDQUFDLEVBQUUsU0FBUTtBQUVyRixjQUFNLFNBQVMsZUFBZSxVQUFVLE9BQU8sQ0FBQyxFQUFFLFVBQVUsWUFBWSxNQUFNO0FBQzlFLGNBQU0sUUFBUSxjQUFjLFNBQVMsT0FBTyxDQUFDLEVBQUUsVUFBVSxPQUFPLENBQUMsRUFBRSxLQUFLLE1BQU07QUFDOUUsY0FBTSxhQUFhLFVBQVUsS0FBSyxXQUFXO0FBQzdDLGNBQU0sV0FBOEI7QUFBQSxVQUNsQyxFQUFDLE1BQU0sY0FBYyxNQUFNLE1BQUs7QUFBQSxVQUFHLEVBQUMsTUFBTSxVQUFVLE1BQU0sT0FBTyxRQUFRLE9BQU8sT0FBTTtBQUFBLFVBQ3RGLEVBQUMsTUFBTSxTQUFTLE1BQU0sT0FBTyxRQUFRLE1BQU0sT0FBTTtBQUFBLFVBQUcsRUFBQyxNQUFNLFNBQVMsTUFBTSxPQUFPLFFBQVEsTUFBTSxPQUFNO0FBQUEsUUFDdkc7QUFFQSxjQUFNLGtCQUFvQztBQUFBLFVBQ3hDLEVBQUMsTUFBTSxVQUFVLE1BQU0sV0FBVTtBQUFBLFVBQUcsRUFBQyxNQUFNLFVBQVUsTUFBTSxPQUFNO0FBQUEsVUFBRyxFQUFDLE1BQU0sU0FBUyxNQUFNLE1BQUs7QUFBQSxVQUMvRixFQUFDLE1BQU0sVUFBVSxNQUFNLE1BQUs7QUFBQSxVQUFHLEdBQUcsMkJBQTJCLE9BQU8sQ0FBQyxFQUFFLElBQUk7QUFBQSxVQUMzRSxHQUFHLDJCQUEyQixXQUFXO0FBQUEsUUFDM0M7QUFFQSxjQUFNLGtCQUFrQixDQUFDLGlCQUErQjtBQUFBLFFBQ2xELGFBQWEsaUJBQWlCLFFBQVEsRUFBRSxpQkFBaUIsT0FBTyxNQUFNLENBQUM7QUFBQSxVQUNyRSwwQkFBMEIsT0FBTyxRQUFRLFVBQVUsQ0FBQztBQUFBLFVBQ3BELGFBQWEsVUFBVSxDQUFDO0FBQUEsWUFDdEIsYUFBYSxzQ0FBc0MscUJBQXFCLENBQUM7QUFBQSxpQ0FDcEQsT0FBTyxnQkFBZ0IsWUFBWSxDQUFDO0FBQUE7QUFBQSxZQUV6RCxPQUFPLFlBQVksY0FBYyxNQUFNLGFBQWEsZUFBZSxDQUFDLENBQUM7QUFBQTtBQUUvRSxlQUFPO0FBQUEsVUFDTCxNQUFNO0FBQUEsVUFDTixhQUFhLEVBQUMsTUFBTSxHQUFHLE1BQU0sTUFBTSxJQUFJLE9BQU8sTUFBTSxJQUFJLE1BQU0sTUFBTSxJQUFJLG1CQUFtQixDQUFDLE1BQU0sRUFBQztBQUFBLFVBQ25HO0FBQUEsVUFDQSxZQUFZLE9BQU87QUFBQSxZQUNqQixTQUFTLENBQUMsZ0JBQWdCO0FBQUEsWUFDMUIsZUFBZSxFQUFDLEdBQUcsS0FBSztBQUFBLGNBQUssWUFBWTtBQUFBO0FBQUEsWUFBdUIsRUFBQztBQUFBLFlBQ2pFO0FBQUEsVUFDRjtBQUFBLFFBQ0Y7QUFBQSxNQUNGO0FBRU8sTUFBTSxRQUFRLENBQUMsU0FBeUIsZUFBc0M7QUFDbkYsUUFBQUEsaUJBQWUsUUFBUSxRQUFRLFVBQVU7QUFDekMsY0FBTSxvQkFBb0IsZ0NBQWdDLFFBQVEsUUFBUSxVQUFVO0FBQ3BGLGdCQUFRLFFBQVEsdUJBQXVCLFFBQVEsUUFBUSxpQkFBaUIsR0FBRyxFQUFDLFFBQVEsQ0FBQyxDQUFDLEVBQUMsQ0FBQztBQUFBLE1BTzFGO0FBRU8sTUFBTSx1QkFBdUIsQ0FBQyxlQUF5RDtBQUM1RixjQUFNLFNBQVMsV0FBVztBQUMxQixjQUFNLE9BQU8sV0FBVztBQUN4QixjQUFNLE9BQU8sV0FBVztBQUN4QixlQUFPLDRCQUE0QixFQUFDLFFBQVEsTUFBTSxLQUFJLENBQUM7QUFBQSxNQUN6RDtBQUFBO0FBQUE7OztBQ3hNQSxNQWNNQyxrQkFVQSwwQkF3SE8sU0FLQTtBQXJKYjtBQUFBO0FBQUE7QUFRQTtBQUNBO0FBR0E7QUFFQSxNQUFNQSxtQkFBaUIsQ0FBQyxXQUF3QztBQUM5RCxZQUFJLENBQUMsVUFBVSxPQUFPLFdBQVcsR0FBRztBQUNsQyxnQkFBTSxJQUFJLE1BQU0sOEJBQThCO0FBQUEsUUFDaEQ7QUFBQSxNQUNGO0FBTUEsTUFBTSwyQkFBMkIsQ0FBQyxPQUFtQixlQUErQztBQUNsRyxjQUFNLFFBQVEsTUFBTTtBQUNwQixjQUFNLGFBQWEsVUFBVSxLQUFLLEtBQUs7QUFDdkMsY0FBTSxLQUFLO0FBQ1gsWUFBSSxPQUFPLFdBQVc7QUFDdEIsWUFBSSxPQUFPLEdBQUc7QUFDWixpQkFBTyxNQUFNLFNBQVM7QUFBQSxRQUN4QjtBQUNBLFlBQUksT0FBTyxNQUFNLFNBQVMsR0FBRztBQUMzQixnQkFBTSxJQUFJLE1BQU0sMENBQTBDO0FBQUEsUUFDNUQ7QUFFQSxjQUFNLE9BQU8sTUFBTSxJQUFJO0FBQ3ZCLGNBQU0sT0FBTyxhQUFhO0FBQzFCLGNBQU0sYUFBYSxpQkFBaUIsSUFBSTtBQUN4QyxjQUFNLGFBQWEsT0FBTztBQUUxQixjQUFNLFlBQVksQ0FBQyxNQUFjQyxnQkFBdUI7QUFDdEQsY0FBSUEsZ0JBQWUsR0FBRztBQUNwQixtQkFBTyxXQUFXLElBQUksT0FBTyxJQUFJLFlBQVksSUFBSSxPQUFPLElBQUk7QUFBQSxVQUM5RCxXQUFXQSxnQkFBZSxHQUFHO0FBQzNCLG1CQUFPLE9BQU8sSUFBSSxPQUFPLElBQUk7QUFBQSxVQUMvQixXQUFXQSxnQkFBZSxHQUFHO0FBQzNCLG1CQUFPLFdBQVcsSUFBSSxPQUFPLElBQUksUUFBUSxJQUFJO0FBQUEsVUFDL0M7QUFFQSxpQkFBTztBQUFBLFFBQ1Q7QUFDQSxjQUFNLElBQUksY0FBYyxLQUFLLE1BQU0sVUFBVSxNQUFNLE1BQU0sVUFBVTtBQUNuRSxjQUFNLFNBQVMsZUFBZSxVQUFVLE1BQU0sVUFBVSxNQUFNLE1BQU0sVUFBVTtBQUM5RSxjQUFNLFlBQVksRUFBRSxLQUFLO0FBRXpCLGNBQU0sZ0JBQWdCLDRCQUE0QixNQUFNLFFBQVEsTUFBTSxRQUNsRSxtQkFBbUIsU0FBUyxzQkFDNUIsbUJBQW1CLFNBQVM7QUFDaEMsY0FBTSxrQkFBa0IsQ0FBQyxpQkFBK0I7QUFBQSxzQ0FDcEIsU0FBUztBQUFBLHNDQUNULFNBQVM7QUFBQSw0Q0FDSCxTQUFTLEtBQUssRUFBRTtBQUFBO0FBQUEsNERBRUEsU0FBUztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsZ0VBS0wsU0FBUztBQUFBO0FBQUE7QUFBQTtBQUFBLFFBSWpFLGFBQWEsZ0JBQWdCLGNBQWMsS0FBSyxFQUFFLGlCQUFpQixHQUFHLE1BQU0sQ0FBQztBQUFBLFFBQzdFLGFBQWEsVUFBVSxDQUFDO0FBQUE7QUFBQTtBQUFBLHFCQUdYLEVBQUU7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsVUFNYixhQUFhO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsMkJBbUJJLFNBQVMsSUFBSSxVQUFVLG1CQUFtQixVQUFVLENBQUM7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLDBCQUt0RCxTQUFTO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLDJCQWVSLFNBQVMsSUFBSSxVQUFVLG1CQUFtQixVQUFVLENBQUM7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFVOUUsZUFBTztBQUFBLFVBQ0wsTUFBTTtBQUFBLFVBQ04sYUFBYSxFQUFDLE1BQU0sR0FBRyxVQUFVLElBQUksbUJBQW1CLENBQUMsTUFBTSxFQUFDO0FBQUEsVUFDaEUsWUFBWSxPQUFPO0FBQUEsWUFDakIsU0FBUyxDQUFDLEVBQUMsTUFBTSxPQUFPLFVBQVUsTUFBTSxTQUFRLENBQUM7QUFBQSxZQUNqRCxlQUFlLEVBQUMsR0FBRyxLQUFJO0FBQUEsWUFDdkIsaUJBQWlCLENBQUMsRUFBQyxNQUFNLFVBQVUsTUFBTSxXQUFVLENBQUM7QUFBQSxVQUN0RDtBQUFBLFVBQ0E7QUFBQSxRQUNGO0FBQUEsTUFDRjtBQUVPLE1BQU0sVUFBVSxDQUFDLFNBQXlCLGVBQXdDO0FBQ3ZGLFFBQUFELGlCQUFlLFFBQVEsTUFBTTtBQUM3QixnQkFBUSxRQUFRLHlCQUF5QixRQUFRLE9BQU8sQ0FBQyxHQUFHLFVBQVUsQ0FBQztBQUFBLE1BQ3pFO0FBRU8sTUFBTSx5QkFBeUIsQ0FBQyxlQUNuQyw0QkFBNEIsRUFBQyxNQUFNLFdBQVcsS0FBYyxDQUFDO0FBQUE7QUFBQTs7O0FDdEpqRSxNQWdCTUUsa0JBTUEsaUNBV0EsMEJBU0EscUJBcUJBLHdCQXdETyxPQU9BO0FBOUhiO0FBQUE7QUFBQTtBQUlBO0FBQ0E7QUFHQTtBQVFBLE1BQU1BLG1CQUFpQixDQUFDLFdBQXdDO0FBQzlELFlBQUksQ0FBQyxVQUFVLE9BQU8sU0FBUyxHQUFHO0FBQ2hDLGdCQUFNLElBQUksTUFBTSxnQkFBZ0I7QUFBQSxRQUNsQztBQUFBLE1BQ0Y7QUFFQSxNQUFNLGtDQUNGLENBQUMsUUFBK0IsZUFBaUQ7QUFDL0UsY0FBTSxhQUF1QixDQUFDO0FBQzlCLFlBQUksYUFBcUIsV0FBVztBQUNwQyxZQUFJLE9BQU8sQ0FBQyxFQUFFLEtBQUssQ0FBQyxJQUFJLEdBQUc7QUFDekIsaUJBQU8sQ0FBQyxFQUFFLGlCQUFpQixFQUFFLFFBQVEsT0FBSyxXQUFXLEtBQUssT0FBTyxDQUFDLENBQUMsQ0FBQztBQUNwRSx1QkFBYSxXQUFXO0FBQUEsUUFDMUI7QUFDQSxlQUFPLDRCQUE0QixFQUFDLFlBQVksTUFBTSxXQUFXLE1BQU0sV0FBVSxDQUFDO0FBQUEsTUFDcEY7QUFFSixNQUFNLDJCQUEyQixDQUFDLG9CQUFvQztBQUFBO0FBQUEsZ0NBRXRDLGVBQWU7QUFBQSxrQkFDN0IsYUFBYSwrQkFBK0IsS0FBSyxlQUFlLENBQUM7QUFBQTtBQUFBO0FBQUE7QUFBQSxhQUl0RSxlQUFlO0FBQUE7QUFFNUIsTUFBTSxzQkFBc0IsQ0FBQyxZQUFzQztBQUNqRSxjQUFNLGtCQUFrQixRQUFRO0FBQ2hDLGNBQU0sWUFBc0IsQ0FBQztBQUM3QixpQkFBUyxJQUFJLEdBQUcsSUFBSSxpQkFBaUIsRUFBRSxHQUFHO0FBQ3hDLGdCQUFNLGdCQUFnQixRQUFRLENBQUMsRUFBRSxhQUFhLFdBQVcsbUJBQW1CO0FBQzVFLGNBQUksb0JBQW9CLEdBQUc7QUFDekIsc0JBQVUsS0FBSyxhQUFhO0FBQUEsVUFDOUIsV0FBVyxNQUFNLEdBQUc7QUFDbEIsc0JBQVUsS0FBSyx3QkFBd0IsQ0FBQyxRQUFRLGFBQWEsSUFBSTtBQUFBLFVBQ25FLFdBQVcsTUFBTSxrQkFBa0IsR0FBRztBQUNwQyxzQkFBVSxLQUFLLFVBQVUsYUFBYSxJQUFJO0FBQUEsVUFDNUMsT0FBTztBQUNMLHNCQUFVLEtBQUssNkJBQTZCLENBQUMsT0FBTyxhQUFhLElBQUk7QUFBQSxVQUN2RTtBQUFBLFFBQ0Y7QUFDQSxlQUFPO0FBQUEsd0RBQytDLFFBQVEsQ0FBQyxFQUFFLEtBQUssT0FBTztBQUFBLFVBQ3JFLFVBQVUsS0FBSyxJQUFJLENBQUM7QUFBQTtBQUFBLE1BRTlCO0FBRUEsTUFBTSx5QkFBeUIsQ0FBQyxRQUErQixlQUE2QztBQUMxRyxjQUFNLGFBQWEsT0FBTyxDQUFDLEVBQUU7QUFDN0IsY0FBTSxZQUFZLFVBQVUsS0FBSyxVQUFVO0FBQzNDLGNBQU0sV0FBVyxPQUFPLENBQUMsRUFBRTtBQUMzQixjQUFNLE9BQU8sVUFBVSxjQUFjLFdBQVcsTUFBTSxXQUFXLE1BQU07QUFDdkUsY0FBTSxVQUFVLElBQUksTUFBcUIsV0FBVyxVQUFVO0FBQzlELGNBQU0sUUFBUSxjQUFjLFNBQVMsVUFBVSxVQUFVO0FBQ3pELGNBQU0sa0JBQWtCLElBQUksTUFBYyxXQUFXLFVBQVU7QUFDL0QsY0FBTSxvQkFBa0MsQ0FBQztBQUN6QyxjQUFNLGVBQTJCLENBQUM7QUFDbEMsWUFBSSxjQUFjO0FBQ2xCLGNBQU0sa0JBQW9DLENBQUMsRUFBQyxNQUFNLFVBQVUsTUFBTSxVQUFTLENBQUM7QUFDNUUsaUJBQVMsSUFBSSxHQUFHLElBQUksV0FBVyxZQUFZLEtBQUs7QUFDOUMseUJBQWUsV0FBVyxXQUFXLENBQUM7QUFDdEMsMEJBQWdCLENBQUMsSUFBSTtBQUNyQixnQkFBTSxjQUFjLFdBQVcsTUFBTTtBQUNyQyxzQkFBWSxXQUFXLElBQUksSUFBSSxXQUFXLFdBQVcsQ0FBQztBQUN0RCx1QkFBYSxLQUFLLFdBQVc7QUFDN0Isa0JBQVEsQ0FBQyxJQUFJLGVBQWUsU0FBUyxDQUFDLElBQUksVUFBVSxXQUFXO0FBQy9ELDRCQUFrQixLQUFLLEVBQUMsTUFBTSxhQUFhLENBQUMsR0FBRyxVQUFVLE9BQU8sQ0FBQyxFQUFFLFNBQVEsQ0FBQztBQUFBLFFBQzlFO0FBQ0Esd0JBQWdCLEtBQUssRUFBQyxNQUFNLFVBQVUsTUFBTSxnQkFBZSxDQUFDO0FBQzVELHdCQUFnQixLQUFLLEdBQUcsMkJBQTJCLFVBQVUsQ0FBQztBQUM5RCxxQkFBYSxRQUFRLENBQUMsZ0JBQWdCLGdCQUFnQixLQUFLLEdBQUcsMkJBQTJCLFdBQVcsQ0FBQyxDQUFDO0FBQ3RHLGNBQU0sa0JBQWtCLENBQUMsaUJBQStCO0FBQUEsSUFFcEQsYUFBYSxnQkFBZ0IsY0FBYyxLQUFLLEVBQzNDLGdCQUFnQixzQkFBc0IsT0FBTyxnQkFBZ0IsTUFBTSxFQUNuRSxpQkFBaUIsT0FBTyxHQUFHLE9BQU8sQ0FBQztBQUFBLElBQzFDLHlCQUF5QixnQkFBZ0IsTUFBTSxDQUFDO0FBQUEsSUFDaEQsb0JBQW9CLE9BQU8sQ0FBQztBQUFBO0FBQUEsSUFFNUIsYUFBYSxVQUFVLENBQUM7QUFBQSxNQUN0QixhQUFhLHNDQUFzQyxxQkFBcUIsQ0FBQztBQUFBO0FBQUEsb0JBRTNELE1BQU0sZ0JBQWdCLFlBQVksQ0FBQztBQUFBLGtCQUNyQyxNQUFNLFdBQVcsV0FBVyxJQUFJLENBQUM7QUFBQTtBQUFBO0FBQUEsaUJBR2xDLGFBQWEsK0JBQStCLHNCQUFzQixnQkFBZ0IsTUFBTSxDQUFDO0FBQUEsUUFDbEcsTUFBTSxXQUFXLFdBQVcsTUFBTSxPQUFPLENBQUM7QUFBQTtBQUFBO0FBQUE7QUFJaEQsZUFBTztBQUFBLFVBQ0wsTUFBTTtBQUFBLFVBQ04sYUFBYSxFQUFDLE1BQU0sV0FBVyxVQUFVLG1CQUFtQixDQUFDLE1BQU0sRUFBQztBQUFBLFVBQ3BFO0FBQUEsVUFDQSxZQUFZLE9BQU87QUFBQSxZQUNqQixTQUFTO0FBQUEsWUFDVCxlQUFlLEVBQUMsR0FBRyxLQUFLO0FBQUEsY0FBSyxZQUFZO0FBQUE7QUFBQSxZQUF1QixFQUFDO0FBQUEsWUFDakU7QUFBQSxVQUNGO0FBQUEsUUFDRjtBQUFBLE1BQ0Y7QUFFTyxNQUFNLFFBQVEsQ0FBQyxTQUF5QixlQUFzQztBQUNuRixRQUFBQSxpQkFBZSxRQUFRLE1BQU07QUFDN0IsY0FBTSxvQkFDRixRQUFRLE9BQU8sV0FBVyxJQUFJLGFBQWEsZ0NBQWdDLFFBQVEsUUFBUSxVQUFVO0FBQ3pHLGdCQUFRLFFBQVEsdUJBQXVCLFFBQVEsUUFBUSxpQkFBaUIsR0FBRyxFQUFDLFFBQVEsQ0FBQyxDQUFDLEVBQUMsQ0FBQztBQUFBLE1BQzFGO0FBRU8sTUFBTSx1QkFBdUIsQ0FBQyxlQUF5RDtBQUM1RixjQUFNLE9BQU8sV0FBVztBQUN4QixjQUFNLGFBQXVCLFdBQVc7QUFDeEMsY0FBTSxhQUFhLFdBQVcsYUFBdUIsSUFBSSxXQUFXLFNBQVMsV0FBVztBQUN4RixZQUFJLGVBQWUsV0FBVyxRQUFRO0FBQ3BDLGdCQUFNLElBQUksTUFBTSwrQ0FBK0M7QUFBQSxRQUNqRTtBQUNBLGVBQU8sNEJBQTRCLEVBQUMsTUFBTSxZQUFZLFdBQVUsQ0FBQztBQUFBLE1BQ25FO0FBQUE7QUFBQTs7O0FDdElBLE1BVU0sWUFJQUMsa0JBeUJBQyxpQkFVTyx1QkF5Q0E7QUExRmI7QUFBQTtBQUFBO0FBR0E7QUFFQTtBQUdBO0FBRUEsTUFBTSxhQUFhLENBQUMsc0JBQ2hCLE1BQU0sS0FBSyxrQkFBa0IsaUJBQWlCLEdBQUcsTUFBTTtBQUczRCxNQUFNRCxtQkFBaUIsQ0FBQyxXQUF3QztBQUM5RCxZQUFJLENBQUMsVUFBVSxPQUFPLFdBQVcsR0FBRztBQUNsQyxnQkFBTSxJQUFJLE1BQU0seUJBQXlCO0FBQUEsUUFDM0M7QUFFQSxZQUFJLE9BQU8sQ0FBQyxFQUFFLDhCQUErQixPQUFPLENBQUMsRUFBRSw4QkFDbkQsT0FBTyxDQUFDLEVBQUUsOEJBQThCO0FBQzFDLGdCQUFNLElBQUksTUFBTSx1REFBdUQ7QUFBQSxRQUN6RTtBQUVBLFlBQUksT0FBTyxDQUFDLEVBQUUsNEJBQTZCO0FBQ3pDLGdCQUFNLElBQUksTUFBTSxtREFBbUQ7QUFBQSxRQUNyRTtBQUVBLFlBQUksT0FBTyxDQUFDLEVBQUUsS0FBSyxXQUFXLEdBQUc7QUFDL0IsZ0JBQU0sSUFBSSxNQUFNLG9DQUFvQztBQUFBLFFBQ3REO0FBRUEsY0FBTSxVQUE2QixXQUFXLE9BQU8sQ0FBQyxDQUFDO0FBRXZELFlBQUksUUFBUSxXQUFXLE9BQU8sQ0FBQyxFQUFFLEtBQUssUUFBUTtBQUM1QyxnQkFBTSxJQUFJLE1BQU0sdUZBQXVGO0FBQUEsUUFDekc7QUFBQSxNQUNGO0FBRUEsTUFBTUMsa0JBQWlCLENBQUMsWUFBK0IsWUFBa0Q7QUFDdkcsY0FBTSxjQUF3QixDQUFDO0FBRS9CLGlCQUFTLElBQUksR0FBRyxJQUFJLFdBQVcsUUFBUSxFQUFFLEdBQUc7QUFDMUMsc0JBQVksS0FBSyxXQUFXLENBQUMsSUFBSSxRQUFRLENBQUMsQ0FBQztBQUFBLFFBQzdDO0FBRUEsZUFBTztBQUFBLE1BQ1Q7QUFFTyxNQUFNLHdCQUF3QixDQUFDLFdBQStDO0FBQ25GLGNBQU0sYUFBYSxPQUFPLENBQUMsRUFBRTtBQUM3QixjQUFNLFVBQTZCLFdBQVcsT0FBTyxDQUFDLENBQUM7QUFDdkQsY0FBTSxjQUFjQSxnQkFBZSxZQUFZLE9BQU87QUFDdEQsY0FBTSxhQUFhLFVBQVUsS0FBSyxXQUFXO0FBRTdDLGNBQU0sV0FBVyxPQUFPLENBQUMsRUFBRTtBQUMzQixjQUFNLFFBQVEsY0FBYyxTQUFTLFVBQVUsV0FBVyxNQUFNO0FBQ2hFLGNBQU0sU0FBUyxlQUFlLFVBQVUsVUFBVSxZQUFZLE1BQU07QUFFcEUsY0FBTSxrQkFBa0IsQ0FBQyxpQkFBK0I7QUFBQSwyQkFDL0IsTUFBTSxRQUFRLEdBQUcsVUFBVSxDQUFDO0FBQUEsUUFDL0MsYUFBYSxnQkFBZ0IsZUFBZSxLQUFLLEVBQUUsaUJBQWlCLE9BQU8sTUFBTSxDQUFDO0FBQUEsUUFDbEYsYUFBYSxVQUFVLENBQUM7QUFBQSxRQUN4QixhQUFhLHNDQUFzQyxzQkFBc0IsQ0FBQztBQUFBLDZCQUNyRCxPQUFPLGdCQUFnQixZQUFZLENBQUM7QUFBQSwyQkFDdEMsTUFBTSxLQUFLLE9BQU87QUFBQSw0QkFDakIsV0FBVyxNQUFNO0FBQUEsNEJBQ2pCLE1BQU0sV0FBVyx3QkFBd0IsR0FBRyxDQUFDO0FBQUEsZ0NBQ3pDLE9BQU8sV0FBVyxrQkFBa0IsR0FBRyxDQUFDO0FBQUE7QUFBQSxVQUU5RCxNQUFNLFdBQVcsaUJBQWlCLEtBQUssaUJBQWlCLENBQUM7QUFBQTtBQUFBLFFBRTNELE9BQU8sWUFBWSxjQUFjLE1BQU0sYUFBYSxlQUFlLENBQUMsQ0FBQztBQUFBO0FBRzNFLGVBQU87QUFBQSxVQUNMLE1BQU07QUFBQSxVQUNOLGFBQWEsRUFBQyxNQUFNLEdBQUcsT0FBTyxJQUFJLG1CQUFtQixDQUFDLE1BQU0sRUFBQztBQUFBLFVBQzdELFlBQVksT0FBTztBQUFBLFlBQ2pCLFNBQVMsQ0FBQyxFQUFDLE1BQU0sYUFBYSxVQUFVLE9BQU8sQ0FBQyxFQUFFLFNBQVEsQ0FBQztBQUFBLFlBQzNELGVBQWUsRUFBQyxHQUFHLEtBQUs7QUFBQSxjQUFLLGFBQWE7QUFBQTtBQUFBLFlBQXVCLEVBQUM7QUFBQSxZQUNsRSxpQkFBaUI7QUFBQSxjQUNmLEVBQUMsTUFBTSxVQUFVLE1BQU0sV0FBVTtBQUFBLGNBQUcsR0FBRywyQkFBMkIsT0FBTyxDQUFDLEVBQUUsSUFBSTtBQUFBLGNBQ2hGLEdBQUcsMkJBQTJCLFdBQVc7QUFBQSxZQUMzQztBQUFBLFVBQ0Y7QUFBQSxVQUNBO0FBQUEsUUFDRjtBQUFBLE1BQ0Y7QUFFTyxNQUFNLE9BQU8sQ0FBQyxZQUFrQztBQUNyRCxRQUFBRCxpQkFBZSxRQUFRLE1BQU07QUFDN0IsZ0JBQVEsUUFBUSxzQkFBc0IsUUFBUSxNQUFNLEdBQUcsRUFBQyxRQUFRLENBQUMsQ0FBQyxFQUFDLENBQUM7QUFBQSxNQUN0RTtBQUFBO0FBQUE7OztBQzdGQSxNQVVNLDRCQTJEQSwwQkFzQ087QUEzR2I7QUFBQTtBQUFBO0FBR0E7QUFFQTtBQUdBO0FBRUEsTUFBTSw2QkFDRixDQUFDLGNBQTRCLFFBQStCLFlBQStCLGFBQzFGLGVBQXVCO0FBQ3RCLGNBQU0sU0FBUyxlQUFlLGVBQWUsWUFBWSxXQUFXLFFBQVEsQ0FBQztBQUM3RSxjQUFNLElBQUksY0FBYyxVQUFVLE9BQU8sQ0FBQyxFQUFFLFVBQVUsT0FBTyxDQUFDLEVBQUUsS0FBSyxRQUFRLENBQUM7QUFDOUUsY0FBTSxJQUFJLGNBQWMsVUFBVSxPQUFPLENBQUMsRUFBRSxVQUFVLE9BQU8sQ0FBQyxFQUFFLEtBQUssUUFBUSxDQUFDO0FBQzlFLGNBQU0sSUFBSSxjQUFjLFVBQVUsT0FBTyxDQUFDLEVBQUUsVUFBVSxPQUFPLENBQUMsRUFBRSxLQUFLLFFBQVEsQ0FBQztBQUU5RSxZQUFJO0FBQ0osY0FBTSxhQUFhLENBQUNFLElBQVdDLElBQVdDLE9BQWMsVUFBVUQsRUFBQyxLQUFLRCxFQUFDLEtBQUtFLEVBQUM7QUFDL0UsWUFBSSxDQUFDLGFBQWE7QUFDaEIsdUJBQWEsT0FBTztBQUFBLFlBQ2hCO0FBQUEsWUFDQSxXQUFXLEVBQUUsWUFBWSxZQUFZLEdBQUcsRUFBRSxZQUFZLFlBQVksR0FBRyxFQUFFLFlBQVksWUFBWSxDQUFDO0FBQUEsVUFBQztBQUFBLFFBQ3ZHLE9BQU87QUFDTCxnQkFBTSxtQkFBbUIsQ0FBQyxRQUFnQixHQUFXLFdBQVcsT0FBTztBQUNyRSxrQkFBTSxjQUFjLGlCQUFpQixDQUFDLGdCQUFnQixDQUFDO0FBQ3ZELGtCQUFNLGNBQWMsaUJBQWlCLENBQUMsZ0JBQWdCLENBQUM7QUFFdkQsa0JBQU0sY0FBYyxzQkFBc0IsQ0FBQyxPQUFPLGdCQUFpQixJQUFJLEtBQUssQ0FBRTtBQUM5RSxtQkFBTztBQUFBLGdDQUNlLENBQUMsTUFBTSxPQUFPLGdCQUFnQixxQkFBcUIsQ0FBQyxHQUFHLENBQUM7QUFBQSwwQkFDOUQsQ0FBQyxNQUFNLEVBQUUsMkJBQTJCLGlCQUFpQixDQUFDLElBQUksTUFBTSxDQUFDO0FBQUEsMEJBQ2pFLENBQUMsTUFBTSxFQUFFLDJCQUEyQixpQkFBaUIsQ0FBQyxJQUFJLE1BQU0sQ0FBQztBQUFBLDBCQUNqRSxDQUFDLE1BQU0sRUFBRSwyQkFBMkIsaUJBQWlCLENBQUMsSUFBSSxNQUFNLENBQUM7QUFBQSx5QkFDbEUsQ0FBQyxjQUFjLENBQUM7QUFBQSx5QkFDaEIsQ0FBQyxjQUFjLENBQUM7QUFBQSx5QkFDaEIsQ0FBQyxjQUFjLENBQUM7QUFBQSw2QkFDWixDQUFDLGNBQWMsQ0FBQztBQUFBLDZCQUNoQixDQUFDLGNBQWMsQ0FBQztBQUFBLGNBQy9CLE1BQU0sSUFBSSxDQUFDLE9BQU8sUUFBUSxJQUFJLFdBQVcsYUFBYSxhQUFhLFdBQVcsQ0FBQztBQUFBO0FBQUEsVUFFckY7QUFDQSxjQUFJLDZCQUE4QjtBQUNoQyx5QkFBYTtBQUFBO0FBQUEsY0FFVCxpQkFBaUIsUUFBUSxHQUFHLEtBQUssQ0FBQztBQUFBLGNBQ2xDLGlCQUFpQixRQUFRLEdBQUcsS0FBSyxDQUFDO0FBQUEsY0FDbEMsaUJBQWlCLFFBQVEsR0FBRyxLQUFLLENBQUM7QUFBQSxjQUNsQyxpQkFBaUIsUUFBUSxHQUFHLEtBQUssQ0FBQztBQUFBO0FBQUEsVUFFeEMsT0FBTztBQUNMLHlCQUFhO0FBQUEsY0FDVCxpQkFBaUIsMkJBQTJCLENBQUMsQ0FBQztBQUFBLGNBQzlDLGlCQUFpQiwyQkFBMkIsQ0FBQyxDQUFDO0FBQUEsY0FDOUMsaUJBQWlCLDJCQUEyQixDQUFDLENBQUM7QUFBQSxjQUM5QyxpQkFBaUIsMkJBQTJCLENBQUMsQ0FBQztBQUFBO0FBQUEsVUFFcEQ7QUFBQSxRQUNGO0FBRUEsZUFBTztBQUFBLFVBQ0gsYUFBYSxnQkFBZ0IsWUFBWSxLQUFLLEVBQUUsaUJBQWlCLEdBQUcsR0FBRyxHQUFHLE1BQU0sQ0FBQztBQUFBLFVBQ2pGLGFBQWEsVUFBVSxDQUFDO0FBQUEsVUFDeEIsYUFBYSxzQ0FBc0MsbUJBQW1CLENBQUM7QUFBQSxVQUN2RSxVQUFVO0FBQUE7QUFBQSxNQUVoQjtBQUVKLE1BQU0sMkJBQTJCLENBQUMsV0FBK0M7QUFDL0UsY0FBTSxRQUFRLE9BQU8sQ0FBQyxFQUFFO0FBQ3hCLGNBQU0sUUFBUSxPQUFPLENBQUMsRUFBRTtBQUN4QixjQUFNLFFBQVEsT0FBTyxDQUFDLEVBQUU7QUFDeEIsY0FBTSxpQkFBaUIsT0FBTyxDQUFDLEVBQUU7QUFFakMsY0FBTSxjQUFjLEVBQUUsVUFBVSxTQUFTLE9BQU8sS0FBSyxLQUFLLFVBQVUsU0FBUyxPQUFPLEtBQUs7QUFDekYsWUFBSSxjQUFjO0FBQ2xCLFlBQUksYUFBYSxVQUFVLEtBQUssS0FBSztBQUdyQyxZQUFJLGFBQWE7QUFDZixnQkFBTSxrQkFBa0IsY0FBYyxVQUFVLGNBQWMsVUFBVSxPQUFPLE9BQU8sS0FBSyxHQUFJLE9BQU8sS0FBSztBQUMzRyxjQUFJLENBQUMsaUJBQWlCO0FBQ3BCLGtCQUFNLElBQUksTUFBTSw2Q0FBOEM7QUFBQSxVQUNoRTtBQUNBLHdCQUFjO0FBQ2QsdUJBQWEsVUFBVSxLQUFLLFdBQVc7QUFBQSxRQUN6QztBQUVBLGNBQU0sVUFBVSxLQUFLLEtBQUssYUFBYSxDQUFDO0FBRXhDLGVBQU87QUFBQSxVQUNMLE1BQU07QUFBQSxVQUNOLGFBQWEsRUFBQyxtQkFBbUIsQ0FBQyxRQUFRLFFBQVEsTUFBTSxFQUFDO0FBQUEsVUFDekQsaUJBQWlCLENBQUMsaUJBQ2QsMkJBQTJCLGNBQWMsUUFBUSxhQUFhLGFBQWEsY0FBYztBQUFBLFVBQzdGLFlBQVksT0FBTztBQUFBLFlBQ2pCLFNBQVMsQ0FBQyxFQUFDLE1BQU0sYUFBYSxVQUFVLGVBQWMsQ0FBQztBQUFBLFlBQ3ZELGVBQWUsRUFBQyxHQUFHLEtBQUs7QUFBQSxjQUFLLGFBQWEsS0FBMEI7QUFBQTtBQUFBLFlBQWdCLEVBQUM7QUFBQSxZQUNyRixpQkFBaUI7QUFBQSxjQUNmLEVBQUMsTUFBTSxVQUFVLE1BQU0sUUFBTztBQUFBLGNBQUcsR0FBRywyQkFBMkIsS0FBSztBQUFBLGNBQUcsR0FBRywyQkFBMkIsS0FBSztBQUFBLGNBQzFHLEdBQUcsMkJBQTJCLEtBQUs7QUFBQSxjQUFHLEdBQUcsMkJBQTJCLFdBQVc7QUFBQSxZQUNqRjtBQUFBLFVBQ0Y7QUFBQSxRQUNGO0FBQUEsTUFDRjtBQUVPLE1BQU0sUUFBUSxDQUFDLFlBQWtDO0FBQ3RELGdCQUFRLFFBQVEseUJBQXlCLFFBQVEsTUFBTSxDQUFDO0FBQUEsTUFDMUQ7QUFBQTtBQUFBOzs7QUM3R0EsTUF5Q2E7QUF6Q2I7QUFBQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU9PLE1BQU0sMEJBQStELG9CQUFJLElBQUk7QUFBQSxRQUNsRixDQUFDLE9BQU8sQ0FBVSxHQUFHLENBQUM7QUFBQSxRQUN0QixDQUFDLFFBQVEsQ0FBVSxJQUFJLENBQUM7QUFBQSxRQUN4QixDQUFDLFNBQVMsQ0FBVSxLQUFLLENBQUM7QUFBQSxRQUMxQixDQUFDLE9BQU8sQ0FBVyxHQUFHLENBQUM7QUFBQSxRQUN2QixDQUFDLFVBQVUsQ0FBQyxRQUFRLHdCQUF3QixDQUFDO0FBQUEsUUFDN0MsQ0FBQyxVQUFVLENBQUMsUUFBUSx3QkFBd0IsQ0FBQztBQUFBLFFBQzdDLENBQUMsUUFBUSxDQUFVLElBQUksQ0FBQztBQUFBLFFBQ3hCLENBQUMsU0FBUyxDQUFVLEtBQUssQ0FBQztBQUFBLFFBQzFCLENBQUMsUUFBUSxDQUFVLElBQUksQ0FBQztBQUFBLFFBQ3hCLENBQUMsU0FBUyxDQUFVLEtBQUssQ0FBQztBQUFBLFFBQzFCLENBQUMsYUFBYSxDQUFDLFNBQVMsQ0FBQztBQUFBO0FBQUEsUUFFekIsQ0FBQyxlQUFlLENBQU0sYUFBa0IsMEJBQTBCLENBQUM7QUFBQSxRQUNuRSxDQUFDLHNCQUFzQixDQUFDLFNBQVMsQ0FBQztBQUFBLFFBQ2xDLENBQUMsV0FBVyxDQUFDLE9BQU8sQ0FBQztBQUFBLFFBQ3JCLENBQUMsaUJBQWlCLENBQUMsYUFBYSxDQUFDO0FBQUEsUUFDakMsQ0FBQyxRQUFRLENBQVUsTUFBZSxtQkFBbUIsQ0FBQztBQUFBLFFBQ3RELENBQUMsUUFBUSxDQUFVLElBQUksQ0FBQztBQUFBLFFBQ3hCLENBQUMsUUFBUSxDQUFVLElBQUksQ0FBQztBQUFBLFFBQ3hCLENBQUMsVUFBVSxDQUFDLFFBQVEscUJBQXFCLENBQUM7QUFBQSxRQUMxQyxDQUFDLFFBQVEsQ0FBQyxNQUFNLG1CQUFtQixDQUFDO0FBQUEsUUFDcEMsQ0FBQyxpQkFBaUIsQ0FBQyxlQUFlLDRCQUE0QixDQUFDO0FBQUEsUUFDL0QsQ0FBQyxPQUFPLENBQVUsR0FBRyxDQUFDO0FBQUEsUUFDdEIsQ0FBQyxRQUFRLENBQVUsSUFBSSxDQUFDO0FBQUEsUUFDeEIsQ0FBQyxVQUFVLENBQUMsUUFBUSxxQkFBcUIsQ0FBQztBQUFBLFFBQzFDLENBQUMsT0FBTyxDQUFXLEdBQUcsQ0FBQztBQUFBLFFBQ3ZCLENBQUMsVUFBVSxDQUFDLFFBQVEscUJBQXFCLENBQUM7QUFBQSxRQUMxQyxDQUFDLE9BQU8sQ0FBVSxLQUFjLG9CQUFvQixDQUFDO0FBQUEsUUFDckQsQ0FBQyxTQUFTLENBQVcsS0FBSyxDQUFDO0FBQUEsUUFDM0IsQ0FBQyxPQUFPLENBQVUsR0FBRyxDQUFDO0FBQUEsUUFDdEIsQ0FBQyxPQUFPLENBQVUsR0FBRyxDQUFDO0FBQUEsUUFDdEIsQ0FBQyxVQUFVLENBQUMsTUFBTSxDQUFDO0FBQUEsUUFDbkIsQ0FBQyxTQUFTLENBQVUsS0FBSyxDQUFDO0FBQUEsUUFDMUIsQ0FBQyxhQUFhLENBQUMsTUFBTSxtQkFBbUIsQ0FBQztBQUFBLFFBQ3pDLENBQUMsVUFBVSxDQUFDLFFBQVEscUJBQXFCLENBQUM7QUFBQSxRQUMxQyxDQUFDLGtCQUFrQixDQUFDLGdCQUFnQiw2QkFBNkIsQ0FBQztBQUFBLFFBQ2xFLENBQUMsUUFBUSxDQUFVLElBQUksQ0FBQztBQUFBLFFBQ3hCLENBQUMsUUFBUSxDQUFDLE1BQU0sbUJBQW1CLENBQUM7QUFBQSxRQUNwQyxDQUFDLHFCQUFxQixDQUFNLG1CQUF3QixnQ0FBZ0MsQ0FBQztBQUFBLFFBQ3JGLENBQUMsaUJBQWlCLENBQU0sZUFBb0IsNEJBQTRCLENBQUM7QUFBQSxRQUN6RSxDQUFDLFdBQVcsQ0FBVyxPQUFPLENBQUM7QUFBQSxRQUMvQixDQUFDLGtCQUFrQixDQUFXLGNBQWMsQ0FBQztBQUFBLFFBQzdDLENBQUMseUJBQXlCLENBQUMsWUFBWSxDQUFDO0FBQUEsUUFDeEMsQ0FBQyxzQkFBc0IsQ0FBQyxTQUFTLENBQUM7QUFBQSxRQUNsQyxDQUFDLGFBQWEsQ0FBVSxXQUFvQixvQkFBb0IsQ0FBQztBQUFBLFFBQ2pFLENBQUMsUUFBUSxDQUFXLElBQUksQ0FBQztBQUFBLFFBQ3pCLENBQUMsZUFBZSxDQUFXLFdBQVcsQ0FBQztBQUFBLFFBQ3ZDLENBQUMsT0FBTyxDQUFVLEdBQUcsQ0FBQztBQUFBLFFBQ3RCLENBQUMsVUFBVSxDQUFDLE1BQU0sQ0FBQztBQUFBO0FBQUEsUUFFbkIsQ0FBQyxXQUFXLENBQU0sU0FBYyxzQkFBc0IsQ0FBQztBQUFBLFFBQ3ZELENBQUMsT0FBTyxDQUFXLEdBQUcsQ0FBQztBQUFBLFFBQ3ZCLENBQUMsc0JBQXNCLENBQUMsb0JBQW9CLGlDQUFpQyxDQUFDO0FBQUEsUUFDOUUsQ0FBQyxPQUFPLENBQVUsR0FBRyxDQUFDO0FBQUEsUUFDdEIsQ0FBQyxPQUFPLENBQVUsR0FBRyxDQUFDO0FBQUEsUUFDdEIsQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDO0FBQUEsUUFDYixDQUFDLE9BQU8sQ0FBVyxHQUFHLENBQUM7QUFBQSxRQUN2QixDQUFDLFNBQVMsQ0FBQyxLQUFLLENBQUM7QUFBQSxRQUNqQixDQUFDLGNBQWMsQ0FBVSxVQUFVLENBQUM7QUFBQSxRQUNwQyxDQUFDLGFBQWEsQ0FBQyxTQUFTLENBQUM7QUFBQSxRQUN6QixDQUFDLGNBQWMsQ0FBQyxVQUFVLENBQUM7QUFBQSxRQUMzQixDQUFDLGFBQWEsQ0FBQyxTQUFTLENBQUM7QUFBQSxRQUN6QixDQUFDLGFBQWEsQ0FBQyxTQUFTLENBQUM7QUFBQSxRQUN6QixDQUFDLGNBQWMsQ0FBQyxVQUFVLENBQUM7QUFBQSxRQUMzQixDQUFDLFlBQVksQ0FBQyxRQUFRLENBQUM7QUFBQSxRQUN2QixDQUFDLFlBQVksQ0FBQyxRQUFRLENBQUM7QUFBQSxRQUN2QixDQUFDLGdCQUFnQixDQUFDLFlBQVksQ0FBQztBQUFBLFFBQy9CLENBQUMsbUJBQW1CLENBQUMsZUFBZSxDQUFDO0FBQUEsUUFDckMsQ0FBQyxtQkFBbUIsQ0FBQyxlQUFlLENBQUM7QUFBQSxRQUNyQyxDQUFDLFFBQVEsQ0FBVSxJQUFJLENBQUM7QUFBQSxRQUN4QixDQUFDLFVBQVUsQ0FBQyxRQUFRLHFCQUFxQixDQUFDO0FBQUEsUUFDMUMsQ0FBQyxXQUFXLENBQVUsT0FBTyxDQUFDO0FBQUEsUUFDOUIsQ0FBQyxPQUFPLENBQVUsR0FBRyxDQUFDO0FBQUEsUUFDdEIsQ0FBQyxRQUFRLENBQVUsSUFBSSxDQUFDO0FBQUEsUUFDeEIsQ0FBQyxTQUFTLENBQUMsT0FBTyxvQkFBb0IsQ0FBQztBQUFBLFFBQ3ZDLENBQUMsMEJBQTBCLENBQUMsZUFBZSw0QkFBNEIsQ0FBQztBQUFBLFFBQ3hFLENBQUMsU0FBUyxDQUFDLE9BQU8sb0JBQW9CLENBQUM7QUFBQSxRQUN2QyxDQUFDLFFBQVEsQ0FBVSxJQUFJLENBQUM7QUFBQSxRQUN4QixDQUFDLFdBQVcsQ0FBQyxTQUFTLHNCQUFzQixDQUFDO0FBQUEsUUFDN0MsQ0FBQyxPQUFPLENBQVcsR0FBRyxDQUFDO0FBQUEsUUFDdkIsQ0FBQyxPQUFPLENBQVUsR0FBRyxDQUFDO0FBQUEsUUFDdEIsQ0FBQyxRQUFRLENBQVUsSUFBSSxDQUFDO0FBQUEsUUFDeEIsQ0FBQyxtQkFBbUIsQ0FBVSxpQkFBMEIsb0JBQW9CLENBQUM7QUFBQSxRQUM3RSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUM7QUFBQSxRQUNmLENBQUMsYUFBYSxDQUFDLFdBQVcsd0JBQXdCLENBQUM7QUFBQSxRQUNuRCxDQUFDLFNBQVMsQ0FBQyxLQUFLLENBQUM7QUFBQSxNQUNuQixDQUFDO0FBQUE7QUFBQTs7O0FDaElELE1Bb0JhO0FBcEJiO0FBQUE7QUFBQTtBQUdBO0FBR0E7QUFFQTtBQVlPLE1BQU0saUJBQU4sTUFBcUI7QUFBQSxRQUkxQixZQUFvQixTQUF3QjtBQUF4QjtBQUNsQixlQUFLLE9BQU8sb0JBQUksSUFBSTtBQUNwQixlQUFLLGtCQUFrQjtBQUFBLFFBQ3pCO0FBQUEsUUFDQSxZQUFZLEtBQWtDO0FBQzVDLGlCQUFPLEtBQUssS0FBSyxJQUFJLEdBQUc7QUFBQSxRQUMxQjtBQUFBLFFBQ0EsWUFBWSxLQUFjLFVBQTBCO0FBQ2xELGVBQUssS0FBSyxJQUFJLEtBQUssUUFBUTtBQUFBLFFBQzdCO0FBQUEsUUFDQSxJQUFJLGVBQXlCLFFBQW1CLFNBQW9CLGVBQ2hFLHNCQUEwRDtBQUM1RCwyQkFBaUIsY0FBYyxZQUFZLElBQUk7QUFDL0MsZ0JBQU0sU0FBUyxLQUFLLFFBQVE7QUFDNUIsZ0JBQU0scUJBQXFCLEtBQUssUUFBUSxzQkFBc0I7QUFDOUQsZUFBSyxRQUFRLGVBQWUsS0FBSyxRQUFRLHdCQUF3QixDQUFDO0FBQ2xFLDZCQUFtQixZQUFZLGNBQWMsZUFBZTtBQUM1RCxnQkFBTSxVQUFVLENBQUM7QUFDakIscUJBQVcsU0FBUyxRQUFRO0FBQzFCLG9CQUFRLEtBQUssRUFBQyxTQUFTLFFBQVEsUUFBUSxVQUFVLEVBQUMsUUFBUSxNQUFNLE9BQU0sRUFBQyxDQUFDO0FBQUEsVUFDMUU7QUFDQSxxQkFBVyxVQUFVLFNBQVM7QUFDNUIsb0JBQVEsS0FBSyxFQUFDLFNBQVMsUUFBUSxRQUFRLFVBQVUsRUFBQyxRQUFRLE9BQU8sT0FBTSxFQUFDLENBQUM7QUFBQSxVQUMzRTtBQUNBLGNBQUksc0JBQXNCO0FBQ3hCLG9CQUFRLEtBQUssRUFBQyxTQUFTLFFBQVEsUUFBUSxVQUFVLHFCQUFvQixDQUFDO0FBQUEsVUFDeEU7QUFDQSxnQkFBTSxZQUFZLE9BQU87QUFBQSxZQUNyQixFQUFDLFFBQVEsY0FBYyxnQkFBZ0IsbUJBQW1CLENBQUMsR0FBRyxTQUFTLE9BQU8sY0FBYyxZQUFZLEtBQUk7QUFBQSxVQUFDO0FBQ2pILDZCQUFtQixhQUFhLEdBQUcsU0FBUztBQUU1Qyw2QkFBbUIsbUJBQW1CLEdBQUcsYUFBYTtBQUN0RCxlQUFLLFFBQVEsZUFBZSxLQUFLLFFBQVEsd0JBQXdCLElBQUksQ0FBQztBQUN0RSxlQUFLLFFBQVE7QUFFYixjQUFJLEtBQUssUUFBUSx5QkFBeUIsS0FBSyxRQUFRLHFCQUNuRCxLQUFLLFFBQVEsY0FBYyxhQUFhO0FBQzFDLGlCQUFLLFFBQVEsZUFBZTtBQUFBLFVBQzlCO0FBQ0EsY0FBSSxLQUFLLFFBQVEseUJBQXlCLEtBQUssUUFBUSxtQkFBbUI7QUFDeEUsaUJBQUssUUFBUSxNQUFNO0FBQUEsVUFDckI7QUFDQSx5QkFBZSxjQUFjLFlBQVksSUFBSTtBQUFBLFFBQy9DO0FBQUEsUUFDQSxVQUFnQjtBQUFBLFFBRWhCO0FBQUEsUUFDQSxNQUFNLGFBQTBCLDZCQUFpRTtBQUMvRiwyQkFBaUIsWUFBWSxJQUFJO0FBQ2pDLGdCQUFNLFNBQVMsS0FBSyxRQUFRO0FBQzVCLGdCQUFNLGFBQXVCLENBQUM7QUFDOUIsY0FBSSxPQUFPLFNBQVMsSUFBSSxZQUFZLEdBQUc7QUFDckMsdUJBQVcsS0FBSyxhQUFhO0FBQUEsVUFDL0I7QUFDQSxnQkFBTSxlQUFlLG1CQUFtQiwyQkFBMkI7QUFDbkUsZ0JBQU0sV0FBVyxZQUFZLGdCQUFnQixZQUFZO0FBQ3pELGdCQUFNLE9BQU8sR0FBRyxXQUFXLEtBQUssSUFBSSxDQUFDO0FBQUEsRUFBSyxhQUFhLHlCQUF5QjtBQUFBLEVBQUssUUFBUTtBQUM3RixnQkFBTSxlQUFlLE9BQU8sbUJBQW1CLEVBQUMsTUFBTSxPQUFPLFlBQVksS0FBSSxDQUFDO0FBQzlFLG9CQUFVLFdBQVcsTUFBTSxZQUFZLFlBQVksSUFBSSxpQkFBaUIsSUFBSSxFQUFFO0FBRTlFLGdCQUFNLGtCQUFrQixPQUFPO0FBQUEsWUFDM0IsRUFBQyxTQUFTLEVBQUMsUUFBUSxjQUFjLFlBQVksT0FBTSxHQUFHLFFBQVEsUUFBUSxPQUFPLFlBQVksS0FBSTtBQUFBLFVBQUM7QUFFbEcseUJBQWUsWUFBWSxJQUFJO0FBQy9CLGlCQUFPLEVBQUMsYUFBYSxnQkFBZTtBQUFBLFFBQ3RDO0FBQUEsUUFFQSwyQkFBMkIsZUFDRTtBQUMzQixnQkFBTSxJQUFJLE9BQU8sa0JBQWtCLFdBQVcsZ0JBQWdCLGNBQWM7QUFDNUUsZ0JBQU0sSUFBSSxPQUFPLGtCQUFrQixXQUFXLElBQUssY0FBYyxLQUFLO0FBQ3RFLGdCQUFNLElBQUksT0FBTyxrQkFBa0IsV0FBVyxJQUFLLGNBQWMsS0FBSztBQUN0RSxnQkFBTSxvQkFBb0IsS0FBSyxRQUFRLE9BQU8sT0FBTztBQUNyRCxjQUFJLEtBQUsscUJBQXFCLEtBQUsscUJBQXFCLEtBQUssbUJBQW1CO0FBQzlFLG1CQUFPLENBQUMsR0FBRyxHQUFHLENBQUM7QUFBQSxVQUNqQjtBQUNBLGdCQUFNLE9BQU8sSUFBSSxJQUFJO0FBQ3JCLGNBQUksa0JBQWtCLEtBQUssS0FBSyxLQUFLLEtBQUssSUFBSSxDQUFDO0FBQy9DLGNBQUksa0JBQWtCLG1CQUFtQjtBQUN2Qyw4QkFBa0IsS0FBSyxLQUFLLEtBQUssS0FBSyxJQUFJLENBQUM7QUFDM0MsZ0JBQUksa0JBQWtCLG1CQUFtQjtBQUN2QyxvQkFBTSxJQUFJLE1BQU0sNkNBQTZDO0FBQUEsWUFDL0Q7QUFDQSxtQkFBTyxDQUFDLGlCQUFpQixpQkFBaUIsZUFBZTtBQUFBLFVBQzNELE9BQU87QUFDTCxtQkFBTyxDQUFDLGlCQUFpQixpQkFBaUIsQ0FBQztBQUFBLFVBQzdDO0FBQUEsUUFDRjtBQUFBLE1BQ0Y7QUFBQTtBQUFBOzs7QUNoSEEsTUE0Qk0sd0NBNENBLHlCQXFCTztBQTdGYjtBQUFBO0FBQUE7QUFHQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWlCQSxNQUFNLHlDQUNGLENBQUMsY0FBcUMsc0JBQTJFO0FBQy9HLFlBQUksa0JBQWtCLFdBQVcsYUFBYSxRQUFRO0FBQ3BELGdCQUFNLElBQUksTUFBTSw0QkFBNEIsa0JBQWtCLE1BQU0sd0NBQ2hFLGFBQWEsTUFBTSxHQUFHO0FBQUEsUUFDNUI7QUFFQSxjQUFNLGFBQXVCLENBQUM7QUFDOUIsaUJBQVMsSUFBSSxHQUFHLElBQUksYUFBYSxRQUFRLEVBQUUsR0FBRztBQUM1QyxnQkFBTSxPQUFPLGFBQWEsQ0FBQyxFQUFFO0FBQzdCLGtCQUFRLGtCQUFrQixDQUFDLEdBQUc7QUFBQSxZQUM1QixLQUFLLFFBQVE7QUFDWCx5QkFBVyxLQUFLLEVBQUU7QUFDbEI7QUFBQSxZQUNGO0FBQUEsWUFDQSxLQUFLLFFBQVE7QUFDWCx5QkFBVyxLQUFLLEdBQUcsSUFBSSxFQUFFO0FBQ3pCO0FBQUEsWUFDRjtBQUFBLFlBQ0EsS0FBSyxRQUFRO0FBQ1gsb0JBQU0sT0FBTyxhQUFhLENBQUMsRUFBRSxLQUFLO0FBQ2xDLHlCQUFXLEtBQUssR0FBRyxJQUFJLElBQUksSUFBSSxFQUFFO0FBQ2pDO0FBQUEsWUFDRjtBQUFBLFlBQ0EsS0FBSyxRQUFRO0FBQ1gsb0JBQU0sT0FBTyxhQUFhLENBQUMsRUFBRSxLQUFLLEtBQUssR0FBRztBQUMxQyx5QkFBVyxLQUFLLEdBQUcsSUFBSSxJQUFJLElBQUksRUFBRTtBQUNqQztBQUFBLFlBQ0Y7QUFBQSxZQUNBO0FBQ0Usb0JBQU0sSUFBSSxNQUFNLGlDQUFpQyxrQkFBa0IsQ0FBQyxDQUFDLEVBQUU7QUFBQSxVQUMzRTtBQUFBLFFBQ0Y7QUFFQSxlQUFPLFdBQVcsS0FBSyxHQUFHO0FBQUEsTUFDNUI7QUFTSixNQUFNLDBCQUNGLENBQUMsYUFBMEIsY0FBcUMseUJBQTBDO0FBR3hHLFlBQUksTUFBTSxZQUFZO0FBQ3RCLFlBQUksWUFBWSxhQUFhLE1BQU07QUFDakMsaUJBQU8sTUFBTSxZQUFZLFlBQVksT0FBTztBQUFBLFFBQzlDO0FBQ0EsZUFBTyxNQUFNLHVCQUNULElBQ087QUFBQSxVQUNJO0FBQUEsVUFDQSxZQUFZLGFBQWEscUJBQ3JCLElBQUksTUFBd0MsYUFBYSxNQUFNLEVBQUUsS0FBSyxNQUFNO0FBQUEsUUFBQyxDQUFDO0FBQ2pHLGVBQU87QUFBQSxNQUNUO0FBTUcsTUFBTSxnQkFBTixNQUFvQjtBQUFBLFFBQXBCO0FBaUJMO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxpQ0FBK0I7QUFnQy9CLGVBQVEsaUJBQXlDO0FBQ2pELGVBQVEscUJBQWlEO0FBQ3pELG1DQUFvQjtBQUNwQix1Q0FBd0I7QUFHeEI7QUFBQSxlQUFRLGlCQUFzQyxDQUFDO0FBRS9DO0FBQUEsZUFBUSxpQkFBc0Qsb0JBQUksSUFBSTtBQVd0RTtBQUFBO0FBQUE7QUFBQSw0Q0FBNEUsb0JBQUksSUFBSTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsUUFuQ3BGLElBQUksMEJBQW9EO0FBQ3RELGNBQUksS0FBSyxvQkFBb0IsTUFBTTtBQUNqQyxrQkFBTSxJQUFJLE1BQU0seUVBQXlFO0FBQUEsVUFDM0Y7QUFFQSxjQUFJLE9BQU8sS0FBSyxpQkFBaUIsSUFBSSxLQUFLLGVBQWU7QUFDekQsY0FBSSxDQUFDLE1BQU07QUFDVCxtQkFBTyxDQUFDO0FBQ1IsaUJBQUssaUJBQWlCLElBQUksS0FBSyxpQkFBaUIsSUFBSTtBQUFBLFVBQ3REO0FBRUEsaUJBQU87QUFBQSxRQUNUO0FBQUEsUUF5QkEsTUFBTSxXQUFXQyxNQUFVLFNBQW9DO0FBQzdELGVBQUssTUFBTUE7QUFDWCxnQkFBTSxtQkFBcUMsQ0FBQztBQUM1QyxnQkFBTSxtQkFBd0M7QUFBQSxZQUM1QyxnQkFBZ0I7QUFBQSxjQUNkLGdDQUFnQyxRQUFRLE9BQU87QUFBQSxjQUMvQyxrQ0FBa0MsUUFBUSxPQUFPO0FBQUEsY0FDakQsNkJBQTZCLFFBQVEsT0FBTztBQUFBLGNBQzVDLGVBQWUsUUFBUSxPQUFPO0FBQUEsY0FDOUIsbUNBQW1DLFFBQVEsT0FBTztBQUFBLGNBQ2xELDBCQUEwQixRQUFRLE9BQU87QUFBQSxjQUN6QywwQkFBMEIsUUFBUSxPQUFPO0FBQUEsY0FDekMsMEJBQTBCLFFBQVEsT0FBTztBQUFBLFlBQzNDO0FBQUEsWUFDQTtBQUFBLFVBQ0Y7QUFFQSxjQUFJLFFBQVEsU0FBUyxJQUFJLHFEQUFxRCxHQUFHO0FBQy9FLDZCQUFpQixLQUFLLHFEQUF1RTtBQUFBLFVBQy9GLFdBQVcsUUFBUSxTQUFTLElBQUksaUJBQWlCLEdBQUc7QUFDbEQsNkJBQWlCLEtBQUssaUJBQWlCO0FBQUEsVUFDekM7QUFDQSxjQUFJLFFBQVEsU0FBUyxJQUFJLFlBQVksR0FBRztBQUN0Qyw2QkFBaUIsS0FBSyxZQUFZO0FBQUEsVUFDcEM7QUFFQSxlQUFLLFNBQVMsTUFBTSxRQUFRLGNBQWMsZ0JBQWdCO0FBQzFELGVBQUssaUJBQWlCLHFCQUFxQixJQUFJO0FBQy9DLGVBQUssaUJBQWlCLElBQUksZUFBZSxJQUFJO0FBQzdDLGVBQUssVUFBVSxvQkFBSSxJQUFJO0FBQ3ZCLGVBQUssdUJBQXVCLG9CQUFJLElBQUk7QUFDcEMsZUFBSyxtQkFBbUIsb0JBQUksSUFBSTtBQUdoQywwQkFBZ0JBLEtBQUksVUFBVyxDQUFDLENBQUNBLEtBQUksS0FBSztBQUkxQyxlQUFLLE9BQU8sb0JBQW9CLFFBQU07QUFDcEMsZ0JBQUksR0FBRyxpQkFBaUIsb0JBQW9CO0FBRTFDLHNCQUFRLE1BQU0sbURBQW1ELEdBQUcsTUFBTSxPQUFPLEVBQUU7QUFBQSxZQUNyRjtBQUFBLFVBQ0Y7QUFFQSxpQkFBTyxlQUFlLEtBQUssSUFBSSxRQUFRLFVBQVUsRUFBQyxPQUFPLEtBQUssT0FBTSxDQUFDO0FBR3JFLGVBQUssYUFBYTtBQUFBLFFBQ3BCO0FBQUEsUUFFQSxVQUFnQjtBQUNkLGNBQUksT0FBTyxLQUFLLGFBQWEsYUFBYTtBQUN4QyxpQkFBSyxTQUFTLFFBQVE7QUFBQSxVQUN4QjtBQUNBLGVBQUssZUFBZSxRQUFRO0FBQUEsUUFDOUI7QUFBQSxRQUVBLG9CQUF1QztBQUNyQyxjQUFJLENBQUMsS0FBSyxnQkFBZ0I7QUFDeEIsaUJBQUssaUJBQWlCLEtBQUssT0FBTyxxQkFBcUI7QUFHdkQsaUJBQUssYUFBYTtBQUNsQixnQkFBSSxLQUFLLGNBQWMsVUFBVSxPQUFPLEtBQUssYUFBYSxhQUFhO0FBQ3JFLG1CQUFLLFdBQVcsS0FBSyxPQUFPLGVBQWU7QUFBQSxnQkFDekMsTUFBTTtBQUFBLGdCQUNOLE9BQU8sS0FBSyxvQkFBb0I7QUFBQSxjQUNsQyxDQUFDO0FBQ0QsbUJBQUsscUJBQXFCLEtBQUssT0FBTztBQUFBO0FBQUEsZ0JBRWxDLEVBQUMsTUFBTSxLQUFLLG9CQUFvQixJQUFJLEdBQUcsT0FBTyxlQUFlLFdBQVcsZUFBZSxjQUFhO0FBQUEsY0FBQztBQUFBLFlBQzNHO0FBQUEsVUFDRjtBQUNBLGlCQUFPLEtBQUs7QUFBQSxRQUNkO0FBQUEsUUFFQSx3QkFBK0M7QUFDN0MsY0FBSSxDQUFDLEtBQUssb0JBQW9CO0FBQzVCLGtCQUFNLHdCQUFrRCxDQUFDO0FBRXpELGdCQUFJLEtBQUssY0FBYyxhQUFhO0FBQ2xDLG9DQUFzQixrQkFBa0I7QUFBQSxnQkFDdEMsVUFBVSxLQUFLO0FBQUEsZ0JBQ2YsMkJBQTJCLEtBQUssd0JBQXdCO0FBQUEsZ0JBQ3hELHFCQUFxQixLQUFLLHdCQUF3QixJQUFJO0FBQUEsY0FDeEQ7QUFBQSxZQUNGO0FBRUEsaUJBQUsscUJBQXFCLEtBQUssa0JBQWtCLEVBQUUsaUJBQWlCLHFCQUFxQjtBQUFBLFVBQzNGO0FBQ0EsaUJBQU8sS0FBSztBQUFBLFFBQ2Q7QUFBQSxRQUVBLGlCQUF1QjtBQUNyQixjQUFJLEtBQUssb0JBQW9CO0FBQzNCLGlCQUFLLG1CQUFtQixJQUFJO0FBQzVCLGlCQUFLLHFCQUFxQjtBQUFBLFVBQzVCO0FBQUEsUUFDRjtBQUFBLFFBRUEsUUFBYztBQUNaLGNBQUksQ0FBQyxLQUFLLGdCQUFnQjtBQUN4QjtBQUFBLFVBQ0Y7QUFFQSwyQkFBaUI7QUFFakIsZUFBSyxlQUFlO0FBQ3BCLGNBQUk7QUFDSixjQUFJLEtBQUssY0FBYyxRQUFRO0FBQzdCLGlCQUFLLGVBQWU7QUFBQSxjQUNoQixLQUFLO0FBQUEsY0FBVztBQUFBLGNBQUcsS0FBSyx3QkFBd0I7QUFBQSxjQUFHLEtBQUs7QUFBQSxjQUFxQjtBQUFBLFlBQUM7QUFFbEYsOEJBQWtCLEtBQUssT0FBTztBQUFBO0FBQUEsY0FFMUIsRUFBQyxNQUFNLEtBQUssd0JBQXdCLElBQUksR0FBRyxPQUFPLGVBQWUsV0FBVyxlQUFlLFNBQVE7QUFBQSxZQUFDO0FBRXhHLGlCQUFLLGVBQWUsSUFBSSxpQkFBaUIsS0FBSyxjQUFjO0FBQzVELGlCQUFLLGlCQUFpQixDQUFDO0FBQ3ZCLGlCQUFLLGVBQWU7QUFBQSxjQUNoQixLQUFLO0FBQUEsY0FBcUI7QUFBQSxjQUFHO0FBQUEsY0FBaUI7QUFBQSxjQUFHLEtBQUssd0JBQXdCLElBQUk7QUFBQSxZQUFDO0FBQUEsVUFDekY7QUFFQSxlQUFLLE9BQU8sTUFBTSxPQUFPLENBQUMsS0FBSyxlQUFlLE9BQU8sQ0FBQyxDQUFDO0FBQ3ZELGVBQUssZUFBZSxzQkFBc0I7QUFDMUMsZUFBSyxpQkFBaUI7QUFDdEIsZUFBSyx3QkFBd0I7QUFFN0IsY0FBSSxLQUFLLGNBQWMsUUFBUTtBQUM3QixpQkFBSyxnQkFBaUIsU0FBUyxXQUFXLElBQUksRUFBRSxLQUFLLE1BQU07QUFDekQsb0JBQU0sYUFBYSxJQUFJLGVBQWUsZ0JBQWdCLGVBQWUsQ0FBQztBQUN0RSxvQkFBTSxpQkFBaUIsS0FBSyxlQUFlLElBQUksZUFBZTtBQUM5RCx1QkFBUyxJQUFJLEdBQUcsSUFBSSxXQUFXLFNBQVMsR0FBRyxLQUFLO0FBQzlDLHNCQUFNLG9CQUFvQixlQUFlLENBQUM7QUFDMUMsc0JBQU0sV0FBVyxrQkFBa0I7QUFDbkMsc0JBQU0sYUFBYSxLQUFLLFFBQVEsSUFBSSxRQUFRO0FBQzVDLHNCQUFNLGFBQWEsV0FBVztBQUM5QixzQkFBTSxhQUFhLFdBQVc7QUFDOUIsc0JBQU0sY0FBYyxrQkFBa0I7QUFDdEMsc0JBQU0sbUJBQW1CLGtCQUFrQjtBQUMzQyxzQkFBTSxvQkFBb0Isa0JBQWtCO0FBQzVDLHNCQUFNLGVBQWUsV0FBVyxJQUFJLENBQUM7QUFDckMsc0JBQU0sYUFBYSxXQUFXLElBQUksSUFBSSxDQUFDO0FBRXZDLG9CQUFJLE9BQU8sS0FBSyxrQkFBa0IsYUFBYTtBQUM3Qyx1QkFBSyxnQkFBZ0I7QUFBQSxnQkFDdkI7QUFFQSxzQkFBTSxZQUFZLE9BQU8sZUFBZSxLQUFLLGFBQWE7QUFDMUQsc0JBQU0sVUFBVSxPQUFPLGFBQWEsS0FBSyxhQUFhO0FBRXRELG9CQUFJLENBQUMsT0FBTyxjQUFjLFNBQVMsS0FBSyxDQUFDLE9BQU8sY0FBYyxPQUFPLEdBQUc7QUFDdEUsd0JBQU0sSUFBSSxXQUFXLDJCQUEyQjtBQUFBLGdCQUNsRDtBQUVBLG9CQUFJLEtBQUssSUFBSSxPQUFPLFdBQVcsUUFBUTtBQUNyQyx1QkFBSyxJQUFJLE9BQU8sVUFBVSxPQUFPO0FBQUEsb0JBQy9CLFNBQVM7QUFBQSxvQkFDVCxnQkFBZ0IsaUJBQWlCO0FBQUEsc0JBQzdCLFlBQVUsRUFBQyxNQUFNLE1BQU0sTUFBTSxVQUFVLDJCQUEyQixNQUFNLFFBQVEsRUFBQztBQUFBLG9CQUFFO0FBQUEsb0JBQ3ZGLGlCQUFpQixrQkFBa0I7QUFBQSxzQkFDL0IsWUFBVSxFQUFDLE1BQU0sTUFBTSxNQUFNLFVBQVUsMkJBQTJCLE1BQU0sUUFBUSxFQUFDO0FBQUEsb0JBQUU7QUFBQSxvQkFDdkY7QUFBQSxvQkFDQTtBQUFBLG9CQUNBO0FBQUEsb0JBQ0E7QUFBQSxvQkFDQTtBQUFBLG9CQUNBO0FBQUEsa0JBQ0YsQ0FBQztBQUFBLGdCQUNILE9BQU87QUFFTCxzQkFBSSxjQUFjO0FBQ2xCLG1DQUFpQixRQUFRLENBQUMsT0FBT0MsT0FBTTtBQUNyQyxtQ0FBZSxTQUFTQSxFQUFDLE9BQU8sTUFBTSxJQUFJLE9BQU8sMkJBQTJCLE1BQU0sUUFBUSxDQUFDO0FBQUEsa0JBQzdGLENBQUM7QUFDRCxzQkFBSSxlQUFlO0FBQ25CLG9DQUFrQixRQUFRLENBQUMsT0FBT0EsT0FBTTtBQUN0QyxvQ0FBZ0IsVUFBVUEsRUFBQyxPQUFPLE1BQU0sSUFBSSxPQUFPLDJCQUEyQixNQUFNLFFBQVEsQ0FBQztBQUFBLGtCQUMvRixDQUFDO0FBRUQsMEJBQVEsSUFBSSx1QkFBdUIsUUFBUSxJQUFJLFVBQVUsSUFBSSxVQUFVLElBQUksV0FBVyxLQUFLLFdBQVcsR0FDbEcsWUFBWSxtQkFBbUIsVUFBVSxTQUFTLEtBQUs7QUFBQSxnQkFDN0Q7QUFDQSxzQkFBTSxPQUFPLEdBQUcsV0FBVyxLQUFLLFlBQVksS0FBSyxVQUFVLEVBQUU7QUFBQSxjQUMvRDtBQUNBLDhCQUFnQixNQUFNO0FBQ3RCLG1CQUFLLGVBQWUsT0FBTyxlQUFlO0FBQUEsWUFDNUMsQ0FBQztBQUFBLFVBQ0g7QUFDQSx5QkFBZTtBQUFBLFFBQ2pCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFFBYUEsSUFBSSxTQUFzQixrQkFBeUMsZUFDL0Qsb0JBQ0EsMEJBQW1HO0FBQ3JHLDJCQUFpQixRQUFRLElBQUk7QUFFN0IsZ0JBQU0sYUFBd0IsQ0FBQztBQUMvQixtQkFBUyxJQUFJLEdBQUcsSUFBSSxpQkFBaUIsUUFBUSxFQUFFLEdBQUc7QUFDaEQsa0JBQU0sVUFBVSxLQUFLLGVBQWUsSUFBSSxpQkFBaUIsQ0FBQyxFQUFFLElBQUk7QUFDaEUsZ0JBQUksQ0FBQyxTQUFTO0FBQ1osb0JBQU0sSUFBSSxNQUFNLDBCQUEwQixpQkFBaUIsQ0FBQyxFQUFFLElBQUksRUFBRTtBQUFBLFlBQ3RFO0FBQ0EsdUJBQVcsQ0FBQyxJQUFJO0FBQUEsVUFDbEI7QUFFQSxnQkFBTSxFQUFDLFNBQVMsZUFBZSxnQkFBZSxJQUFJLFFBQVEsV0FBVyxnQkFBZ0I7QUFHckYsZ0JBQU0seUJBQXlCLGNBQWMsV0FBVyxJQUFJLFFBQVEsSUFBSSxDQUFDLEdBQUcsTUFBTSxDQUFDLElBQUk7QUFDdkYsY0FBSSx1QkFBdUIsV0FBVyxRQUFRLFFBQVE7QUFDcEQsa0JBQU0sSUFBSSxNQUFNLGVBQWUsdUJBQXVCLE1BQU0scUJBQXFCLFFBQVEsTUFBTSxHQUFHO0FBQUEsVUFDcEc7QUFHQSxnQkFBTSxvQkFBa0MsQ0FBQztBQUN6QyxnQkFBTSxjQUF5QixDQUFDO0FBQ2hDLG1CQUFTLElBQUksR0FBRyxJQUFJLFFBQVEsUUFBUSxFQUFFLEdBQUc7QUFJdkMsZ0JBQUksQ0FBQyxPQUFPLFVBQVUsdUJBQXVCLENBQUMsQ0FBQyxLQUFLLHVCQUF1QixDQUFDLElBQUksTUFDNUUsdUJBQXVCLENBQUMsS0FBSyxRQUFRLFFBQVE7QUFDL0Msb0JBQU0sSUFBSSxNQUFNLHlCQUF5Qix1QkFBdUIsQ0FBQyxDQUFDLEVBQUU7QUFBQSxZQUN0RTtBQUNBLGdCQUFJLHVCQUF1QixDQUFDLE1BQU0sSUFBSTtBQUNwQztBQUFBLFlBQ0Y7QUFDQSxrQkFBTSxjQUFjLHVCQUF1QixDQUFDLE1BQU07QUFDbEQsa0JBQU0sZUFBZSx1QkFBdUIsQ0FBQyxNQUFNO0FBQ25ELGtCQUFNLGFBQWMsZUFBZSxlQUMvQix5QkFBeUIsUUFBUSxDQUFDLEVBQUUsVUFBVSxRQUFRLENBQUMsRUFBRSxJQUFJLElBQzdELG1CQUFtQix1QkFBdUIsQ0FBQyxHQUFHLFFBQVEsQ0FBQyxFQUFFLFVBQVUsUUFBUSxDQUFDLEVBQUUsSUFBSTtBQUN0RixrQkFBTSxVQUFVLEtBQUssZUFBZSxJQUFJLFdBQVcsSUFBSTtBQUN2RCxnQkFBSSxDQUFDLFNBQVM7QUFDWixvQkFBTSxJQUFJLE1BQU0sMkJBQTJCLFdBQVcsSUFBSSxFQUFFO0FBQUEsWUFDOUQ7QUFDQSxnQkFBSSxhQUFhO0FBQ2YsbUJBQUssY0FBYyxLQUFLLE9BQU87QUFBQSxZQUNqQztBQUNBLGdCQUFJLGNBQWM7QUFDaEIsa0JBQUksaUJBQWlCLEtBQUsscUJBQXFCLElBQUksS0FBSyxlQUFnQjtBQUN4RSxrQkFBSSxDQUFDLGdCQUFnQjtBQUNuQixpQ0FBaUIsQ0FBQztBQUNsQixxQkFBSyxxQkFBcUIsSUFBSSxLQUFLLGlCQUFrQixjQUFjO0FBQUEsY0FDckU7QUFDQSw2QkFBZSxLQUFLLE9BQU87QUFBQSxZQUM3QjtBQUNBLDhCQUFrQixLQUFLLFVBQVU7QUFDakMsd0JBQVksS0FBSyxPQUFPO0FBQUEsVUFDMUI7QUFNQSxjQUFJO0FBQ0osY0FBSSxpQkFBaUI7QUFDbkIsZ0JBQUksZ0JBQWdCO0FBQ3BCLGtCQUFNLFVBQW9CLENBQUM7QUFFM0IsNEJBQWdCLFFBQVEsT0FBSztBQUMzQixvQkFBTSxPQUFPLE9BQU8sRUFBRSxTQUFTLFdBQVcsQ0FBQyxFQUFFLElBQUksSUFBSSxFQUFFO0FBQ3ZELGtCQUFJLEtBQUssV0FBVyxHQUFHO0FBQ3JCO0FBQUEsY0FDRjtBQUVBLG9CQUFNLGdCQUFnQixLQUFLLFVBQVUsSUFBSSxLQUFLLFNBQVMsSUFBSTtBQUMzRCw4QkFBZ0IsS0FBSyxLQUFLLGdCQUFnQixhQUFhLElBQUk7QUFDM0Qsc0JBQVEsS0FBSyxhQUFhO0FBSTFCLCtCQUFpQixLQUFLLFNBQVMsSUFBSSxLQUFLLEtBQUssS0FBSyxTQUFTLENBQUMsSUFBSSxLQUFLLEtBQUssU0FBUztBQUFBLFlBQ3JGLENBQUM7QUFJRCxrQkFBTSxzQkFBc0I7QUFDNUIsNEJBQWdCLEtBQUssS0FBSyxnQkFBZ0IsbUJBQW1CLElBQUk7QUFDakUsa0JBQU0sY0FBYyxJQUFJLFlBQVksYUFBYTtBQUNqRCw0QkFBZ0IsUUFBUSxDQUFDLEdBQUcsTUFBTTtBQUNoQyxvQkFBTSxTQUFTLFFBQVEsQ0FBQztBQUN4QixvQkFBTSxPQUFPLE9BQU8sRUFBRSxTQUFTLFdBQVcsQ0FBQyxFQUFFLElBQUksSUFBSSxFQUFFO0FBQ3ZELGtCQUFJLEVBQUUsU0FBUyxTQUFTO0FBQ3RCLG9CQUFJLFdBQVcsYUFBYSxRQUFRLEtBQUssTUFBTSxFQUFFLElBQUksSUFBSTtBQUFBLGNBQzNELFdBQVcsRUFBRSxTQUFTLFVBQVU7QUFDOUIsb0JBQUksWUFBWSxhQUFhLFFBQVEsS0FBSyxNQUFNLEVBQUUsSUFBSSxJQUFJO0FBQUEsY0FDNUQsT0FBTztBQUNMLG9CQUFJLGFBQWEsYUFBYSxRQUFRLEtBQUssTUFBTSxFQUFFLElBQUksSUFBSTtBQUFBLGNBQzdEO0FBQUEsWUFDRixDQUFDO0FBRUQsa0JBQU07QUFBQTtBQUFBLGNBRUYsS0FBSyxlQUFlLE9BQU8sZUFBZSxlQUFlLFdBQVcsZUFBZSxPQUFPO0FBQUE7QUFDOUYsaUJBQUssT0FBTyxNQUFNLFlBQVksa0JBQWtCLFFBQVEsR0FBRyxhQUFhLEdBQUcsYUFBYTtBQUN4RixpQkFBSyxlQUFlLFFBQVEsa0JBQWtCLEVBQUU7QUFDaEQsbUNBQXVCLEVBQUMsUUFBUSxHQUFHLE1BQU0sZUFBZSxRQUFRLGtCQUFrQixPQUFNO0FBQUEsVUFDMUY7QUFFQSxnQkFBTSwwQkFBMEIsS0FBSyxlQUFlLDJCQUEyQixhQUFhO0FBQzVGLGdCQUFNLHVCQUF1Qix3QkFBd0IsQ0FBQyxNQUFNLEtBQUssd0JBQXdCLENBQUMsTUFBTTtBQUVoRyxnQkFBTSxNQUFNLHdCQUF3QixTQUFTLGtCQUFrQixvQkFBb0I7QUFDbkYsY0FBSSxXQUFXLEtBQUssZUFBZSxZQUFZLEdBQUc7QUFDbEQsY0FBSSxDQUFDLFVBQVU7QUFDYix1QkFBVyxLQUFLLGVBQWUsTUFBTSxTQUFTLHVCQUF1QjtBQUNyRSxpQkFBSyxlQUFlLFlBQVksS0FBSyxRQUFRO0FBQzdDLHNCQUFVLFFBQVEsTUFBTSxtQkFBbUIsR0FBRyxrQkFBa0IsUUFBUSxJQUFJLEVBQUU7QUFBQSxVQUNoRjtBQUVBO0FBQUEsWUFDSTtBQUFBLFlBQ0EsTUFBTSx5QkFBeUIsUUFBUSxJQUFJLFVBQVUsR0FBRyxVQUFVLHdCQUF3QixDQUFDLENBQUMsSUFDeEYsd0JBQXdCLENBQUMsQ0FBQyxJQUFJLHdCQUF3QixDQUFDLENBQUM7QUFBQSxVQUFFO0FBRWxFLGNBQUksS0FBSyxjQUFjLFFBQVE7QUFDN0Isa0JBQU0sb0JBQXVDO0FBQUEsY0FDM0MsVUFBVSxLQUFLO0FBQUEsY0FDZixhQUFhLFNBQVMsWUFBWTtBQUFBLGNBQ2xDO0FBQUEsY0FDQTtBQUFBLFlBQ0Y7QUFDQSxpQkFBSyxlQUFlLEtBQUssaUJBQWlCO0FBQUEsVUFDNUM7QUFFQSxlQUFLLGVBQWUsSUFBSSxVQUFVLFlBQVksYUFBYSx5QkFBeUIsb0JBQW9CO0FBRXhHLHlCQUFlLFFBQVEsSUFBSTtBQUMzQixpQkFBTztBQUFBLFFBQ1Q7QUFBQSxRQUVBLE9BQU8sV0FBbUIsTUFBd0I7QUFDaEQsZUFBSyxlQUFlLE9BQU8sV0FBVyxJQUFJO0FBQUEsUUFDNUM7QUFBQSxRQUVBLE9BQU8sS0FBYSxLQUFtQjtBQUNyQyxlQUFLLGVBQWUsT0FBTyxLQUFLLEdBQUc7QUFBQSxRQUNyQztBQUFBLFFBRUEsTUFBTSxTQUFTLFdBQW1CLGlCQUFrRDtBQUdsRixnQkFBTSxLQUFLLGVBQWUsU0FBUyxXQUFXLGVBQWU7QUFBQSxRQUMvRDtBQUFBLFFBRUEsTUFBTSxNQUFzQjtBQUMxQixpQkFBTyxLQUFLLGVBQWUsT0FBTyxJQUFJLEVBQUU7QUFBQSxRQUMxQztBQUFBLFFBRUEsS0FBSyxLQUFxQjtBQUN4QixpQkFBTyxLQUFLLGVBQWUsUUFBUSxHQUFHO0FBQUEsUUFDeEM7QUFBQSxRQUVBLGFBQWEsWUFBb0IsVUFBa0IsV0FBb0IsWUFBMEI7QUFDL0YsZ0JBQU0sS0FBSyx3QkFBd0IsSUFBSSxVQUFVO0FBQ2pELGNBQUksQ0FBQyxJQUFJO0FBQ1Asa0JBQU0sSUFBSSxNQUFNLDJCQUEyQixVQUFVLEVBQUU7QUFBQSxVQUN6RDtBQUVBLGdCQUFNLGFBQXlCO0FBQUEsWUFDN0I7QUFBQSxZQUNBO0FBQUEsWUFDQSxhQUFhLEdBQUcsQ0FBQztBQUFBLFlBQ2pCLFlBQVksQ0FBQyxHQUFHLENBQUMsR0FBRyxTQUFTO0FBQUEsVUFDL0I7QUFDQSxlQUFLLFFBQVEsSUFBSSxVQUFVLFVBQVU7QUFBQSxRQUN2QztBQUFBLFFBRUEsY0FBYyxVQUF3QjtBQUNwQyxnQkFBTSxpQkFBaUIsS0FBSyxxQkFBcUIsSUFBSSxRQUFRO0FBQzdELGNBQUksZ0JBQWdCO0FBQ2xCLHVCQUFXLFFBQVEsZ0JBQWdCO0FBQ2pDLG1CQUFLLGVBQWUsUUFBUSxLQUFLLEVBQUU7QUFBQSxZQUNyQztBQUNBLGlCQUFLLHFCQUFxQixPQUFPLFFBQVE7QUFBQSxVQUMzQztBQUVBLGVBQUssaUJBQWlCLE9BQU8sUUFBUTtBQUNyQyxlQUFLLFFBQVEsT0FBTyxRQUFRO0FBQUEsUUFDOUI7QUFBQSxRQUVBLGNBQWMsVUFBa0IsU0FBeUIsUUFBNkM7QUFDcEcsZ0JBQU0sU0FBUyxLQUFLLFFBQVEsSUFBSSxRQUFRO0FBQ3hDLGNBQUksQ0FBQyxRQUFRO0FBQ1gsa0JBQU0sSUFBSSxNQUFNLHVCQUF1QixRQUFRLEVBQUU7QUFBQSxVQUNuRDtBQUNBLGdCQUFNLGFBQWEsT0FBTztBQUMxQixnQkFBTSxhQUFhLE9BQU87QUFDMUIsZ0JBQU0sY0FBYyxPQUFPO0FBQzNCLGdCQUFNLGFBQWEsT0FBTztBQUMxQixjQUFJLEtBQUssb0JBQW9CLE1BQU07QUFDakMsa0JBQU0sSUFBSSxNQUFNLFlBQVksVUFBVSxLQUFLLFVBQVUsMkNBQTJDO0FBQUEsVUFDbEc7QUFDQSxlQUFLLGtCQUFrQjtBQUd2QixjQUFJLFdBQVcsQ0FBQyxHQUFHO0FBQ2pCLHVCQUFXLENBQUMsSUFBSSxXQUFXLENBQUMsRUFBRSxXQUFXLENBQUMsQ0FBQztBQUMzQyx1QkFBVyxDQUFDLElBQUk7QUFBQSxVQUNsQjtBQUVBLG9CQUFVLFFBQVEsTUFBTSxrQ0FBa0MsVUFBVSxLQUFLLFVBQVUsTUFBTTtBQUV6RixnQkFBTSxnQkFBZ0IsS0FBSyxJQUFJO0FBRS9CLGVBQUssZ0JBQWdCLENBQUM7QUFDdEIsY0FBSTtBQUNGLGdCQUFJLGVBQWU7QUFDakIsbUJBQUssT0FBTyxlQUFlLFlBQVk7QUFBQSxZQUN6QztBQUVBLHdCQUFZLFNBQVMsV0FBVyxDQUFDLENBQUM7QUFDbEMsbUJBQU87QUFBQSxVQUNULFNBQVMsR0FBRztBQUNWLG1CQUFPLEtBQUssUUFBUSxRQUFRLHFCQUFxQixVQUFVLEtBQUssVUFBVSxhQUFhLENBQUMsRUFBRSxDQUFDO0FBQzNGLG1CQUFPO0FBQUEsVUFDVCxVQUFFO0FBQ0EsZ0JBQUksZUFBZTtBQUNqQixxQkFBTyxLQUFLLEtBQUssT0FBTyxjQUFjLEVBQUU7QUFBQSxnQkFDcEMsU0FBTyxNQUFNLHFDQUFxQyxVQUFVLEtBQUssVUFBVSxNQUFNLElBQUksT0FBTyxLQUFLO0FBQUEsY0FBSSxDQUFDO0FBQUEsWUFDNUc7QUFFQSx1QkFBVyxRQUFRLEtBQUssZUFBZTtBQUNyQyxtQkFBSyxlQUFlLFFBQVEsS0FBSyxFQUFFO0FBQUEsWUFDckM7QUFDQSxpQkFBSyxnQkFBZ0IsQ0FBQztBQUN0QixpQkFBSyxrQkFBa0I7QUFBQSxVQUN6QjtBQUFBLFFBQ0Y7QUFBQTtBQUFBLFFBR0EsZUFBZSxXQUFtQixPQUFlLFFBQW1CLE1BQXNCO0FBQ3hGLGNBQUksNEJBQTRCLEtBQUssMkJBQTJCLElBQUksU0FBUztBQUM3RSxjQUFJLENBQUMsMkJBQTJCO0FBQzlCLHdDQUE0QixvQkFBSSxJQUFJO0FBQ3BDLGlCQUFLLDJCQUEyQixJQUFJLFdBQVcseUJBQXlCO0FBQUEsVUFDMUU7QUFFQSxnQkFBTSxpQkFBaUIsMEJBQTBCLElBQUksS0FBSztBQUMxRCxnQkFBTSxLQUFLLEtBQUssZUFBZSx1QkFBdUIsUUFBUSxNQUFNLGlCQUFpQixDQUFDLENBQUM7QUFDdkYsb0NBQTBCLElBQUksT0FBTyxDQUFDLElBQUksTUFBTSxDQUFDO0FBQ2pELGlCQUFPO0FBQUEsUUFDVDtBQUFBLFFBQ0Esa0JBQWtCLFdBQXlCO0FBQ3pDLGdCQUFNLDRCQUE0QixLQUFLLDJCQUEyQixJQUFJLFNBQVM7QUFDL0UsY0FBSSwyQkFBMkI7QUFDN0Isc0NBQTBCLFFBQVEsZ0JBQWMsS0FBSyxlQUFlLHlCQUF5QixXQUFXLENBQUMsQ0FBQyxDQUFDO0FBQzNHLGlCQUFLLDJCQUEyQixPQUFPLFNBQVM7QUFBQSxVQUNsRDtBQUFBLFFBQ0Y7QUFBQSxRQUNBLFVBQVUsV0FBOEI7QUFDdEMsZ0JBQU0sVUFBVSxLQUFLLGVBQWUsSUFBSSxTQUFTO0FBQ2pELGNBQUksQ0FBQyxTQUFTO0FBQ1osa0JBQU0sSUFBSSxNQUFNLDJCQUEyQixTQUFTLEVBQUU7QUFBQSxVQUN4RDtBQUNBLGlCQUFPLFFBQVE7QUFBQSxRQUNqQjtBQUFBLFFBQ0EsaUJBQWlCLFdBQXNCLE1BQWMsTUFDbEI7QUFDakMsaUJBQU8sWUFBWTtBQUNqQixrQkFBTSxPQUFPLE1BQU0sZ0JBQWdCLE1BQU0sV0FBVyxJQUFJO0FBQ3hELG1CQUFPLFdBQVcsS0FBSyxRQUFRLElBQUk7QUFBQSxVQUNyQztBQUFBLFFBQ0Y7QUFBQSxRQUNBLGVBQWUsT0FBcUI7QUFDbEMsY0FBSSxLQUFLLGNBQWMsaUJBQWlCO0FBQ3RDO0FBQUEsVUFDRjtBQUdBLFVBQUMsS0FBSyxtQkFBMkIsZUFBZSxLQUFLLFVBQVUsS0FBSztBQUFBLFFBQ3RFO0FBQUEsUUFDQSxlQUFxQjtBQUNuQixlQUFLLFlBQVk7QUFDakIsY0FBSSxLQUFLLElBQUksT0FBTyxXQUFXLFNBQVMsYUFBYSxLQUFLLElBQUksS0FBSyxPQUFPO0FBQ3hFLGdCQUFJLEtBQUssT0FBTyxTQUFTLElBQUkscURBQXFELEdBQUc7QUFDbkYsbUJBQUssWUFBWTtBQUFBLFlBQ25CLFdBQVcsS0FBSyxPQUFPLFNBQVMsSUFBSSxpQkFBaUIsR0FBRztBQUN0RCxtQkFBSyxZQUFZO0FBQUEsWUFDbkI7QUFBQSxVQUNGO0FBQUEsUUFDRjtBQUFBO0FBQUEsTUFFRjtBQUFBO0FBQUE7OztBQ3BwQkE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQWdCTSxnQkF1Q0Esb0JBMkZPO0FBbEpiO0FBQUE7QUFBQTtBQU1BO0FBRUE7QUFDQTtBQUVBO0FBS0EsTUFBTSxpQkFBTixNQUFNLGdCQUFxQztBQUFBLFFBQ3pDLFlBQ1ksUUFBdUMsVUFBa0MsTUFDakUsTUFBeUI7QUFEakM7QUFBdUM7QUFBa0M7QUFDakU7QUFBQSxRQUEwQjtBQUFBLFFBRTlDLGtCQUFnQztBQUM5QixjQUFJLEtBQUssNEJBQTZCO0FBQ3BDLGtCQUFNLElBQUksTUFBTSxtQkFBbUI7QUFBQSxVQUNyQztBQUNBLGdCQUFNLGVBQWUsVUFBVSxLQUFLLEtBQUssSUFBSTtBQUM3QyxpQkFBTyxpQkFBaUIsSUFBSSxJQUFJLGFBQWEsSUFDakIsSUFBSSxhQUFhLEtBQUssT0FBTyxNQUFNLFFBQVEsS0FBSyxNQUFNLFlBQVk7QUFBQSxRQUNoRztBQUFBLFFBRUEsbUJBQWtDO0FBQ2hDLGNBQUksS0FBSyw0QkFBNkI7QUFDcEMsa0JBQU0sSUFBSSxNQUFNLG1CQUFtQjtBQUFBLFVBQ3JDO0FBQ0EsZ0JBQU0sZUFBZSxVQUFVLEtBQUssS0FBSyxJQUFJO0FBQzdDLGlCQUFPLGlCQUFpQixJQUFJLElBQUksY0FBYyxJQUNsQixJQUFJLGNBQWMsS0FBSyxPQUFPLE1BQU0sUUFBUSxLQUFLLE1BQU0sWUFBWTtBQUFBLFFBQ2pHO0FBQUEsUUFFQSxnQkFBNEI7QUFDMUIsY0FBSSxLQUFLLDRCQUE2QjtBQUNwQyxrQkFBTSxJQUFJLE1BQU0sbUJBQW1CO0FBQUEsVUFDckM7QUFDQSxnQkFBTSxlQUFlLFVBQVUsS0FBSyxLQUFLLElBQUk7QUFDN0MsaUJBQU8saUJBQWlCLElBQUksSUFBSSxXQUFXLElBQUksSUFBSSxXQUFXLEtBQUssT0FBTyxNQUFNLFFBQVEsS0FBSyxNQUFNLFlBQVk7QUFBQSxRQUNqSDtBQUFBLFFBRUEsUUFBUSxTQUF3QztBQUM5QyxjQUFJLFVBQVUsS0FBSyxPQUFPLE1BQU0sVUFBVSxLQUFLLEtBQUssSUFBSSxHQUFHO0FBQ3pELGtCQUFNLElBQUksTUFBTSxtQkFBbUI7QUFBQSxVQUNyQztBQUNBLGlCQUFPLElBQUksZ0JBQWUsS0FBSyxRQUFRLEtBQUssVUFBVSxLQUFLLE1BQU0sT0FBTztBQUFBLFFBQzFFO0FBQUEsTUFDRjtBQUVBLE1BQU0scUJBQU4sTUFBbUQ7QUFBQSxRQVlqRCxZQUFvQixRQUErQixTQUF3QixtQkFBMkI7QUFBbEY7QUFBK0I7QUFGbkQsZUFBUSxtQkFBbUI7QUFDM0IsZUFBUSxpQkFBaUI7QUFFdkIsZ0JBQU0sVUFBVSxPQUFPO0FBR3ZCLGNBQUksWUFBYSxzQkFBc0I7QUFDdkMsZUFBSyxrQkFBa0IsUUFBUSxXQUFXO0FBQzFDLGdCQUFNLGFBQWEsUUFBUSxXQUFXO0FBQ3RDLGVBQUssY0FBYyxRQUFRLFdBQVc7QUFDdEMsZUFBSyxtQkFBbUIsUUFBUSxXQUFXO0FBQzNDLGVBQUssaUJBQWlCLFFBQVEsV0FBVztBQUV6QyxnQkFBTSxTQUF1QixDQUFDO0FBQzlCLG1CQUFTLElBQUksR0FBRyxJQUFJLFlBQVksS0FBSztBQUNuQyxrQkFBTSxXQUFXLFFBQVEsV0FBVztBQUNwQyxrQkFBTSxPQUFPLFFBQVEsV0FBVztBQUNoQyxrQkFBTSxNQUFNLFFBQVEsV0FBVztBQUMvQixrQkFBTSxPQUFpQixDQUFDO0FBQ3hCLHFCQUFTLElBQUksR0FBRyxJQUFJLEtBQUssS0FBSztBQUM1QixtQkFBSyxLQUFLLFFBQVEsV0FBVyxDQUFDO0FBQUEsWUFDaEM7QUFDQSxtQkFBTyxLQUFLLElBQUksZUFBZSxRQUFRLFVBQVUsTUFBTSxJQUFJLENBQUM7QUFBQSxVQUM5RDtBQUNBLGVBQUssU0FBUztBQUFBLFFBQ2hCO0FBQUEsUUEvQkEsSUFBSSxtQkFBNkM7QUFDL0MsaUJBQU8sS0FBSyxRQUFRO0FBQUEsUUFDdEI7QUFBQSxRQUNBLElBQUksbUJBQStCO0FBQ2pDLGlCQUFPLEtBQUssT0FBTyxPQUFPLFNBQVMsS0FBSyxrQkFBa0IsS0FBSyxtQkFBbUIsS0FBSyxjQUFjO0FBQUEsUUFDdkc7QUFBQSxRQTRCQSxRQUFRLFNBQXNCLHNCQUF5RTtBQUVyRyxnQkFBTSxlQUNGLHNCQUFzQixRQUFRLElBQUksT0FBSyxPQUFPLE1BQU0sV0FBVyxLQUFLLE9BQU8sQ0FBQyxJQUFJLENBQUMsS0FBSyxLQUFLO0FBRS9GLGdCQUFNLGdCQUFnQixzQkFBc0IsV0FBVyxDQUFDO0FBQ3hELGdCQUFNLHFCQUFxQixDQUFDLE9BQWUsVUFBa0IsU0FDekQsSUFBSSxlQUFlLEtBQUssUUFBUSxVQUFVLEtBQUssT0FBTyxPQUFPLElBQUksR0FBRyxJQUFJO0FBQzVFLGdCQUFNLHdCQUF3QixDQUFDLFVBQWtCLFNBQXdDO0FBQ3ZGLGtCQUFNLGNBQWMscUJBQXFCLFFBQVE7QUFDakQsZ0JBQUksQ0FBQyxhQUFhO0FBQ2hCLG9CQUFNLElBQUksTUFBTSwwQkFBMEIsUUFBUSxFQUFFO0FBQUEsWUFDdEQ7QUFDQSxrQkFBTSxhQUFhLGNBQWMsVUFBVSxLQUFLLElBQUk7QUFDcEQsbUJBQU8sSUFBSSxlQUFlLEtBQUssUUFBUSxVQUFVLEtBQUssUUFBUSxlQUFlLE9BQU8sVUFBVSxFQUFFLElBQUksSUFBSTtBQUFBLFVBQzFHO0FBQ0EsaUJBQU8sS0FBSyxRQUFRLElBQUksU0FBUyxjQUFjLGVBQWUsb0JBQW9CLHFCQUFxQjtBQUFBLFFBQ3pHO0FBQUEsUUFFQSxPQUFPLE9BQWUsTUFBaUM7QUFDckQsZ0JBQU0sUUFBUSxLQUFLLE9BQU8sVUFBVTtBQUNwQyxjQUFJO0FBQ0Ysa0JBQU0sT0FBTyxLQUFLLE9BQU87QUFBQSxlQUFZLElBQUksS0FBSyxVQUFVO0FBQUE7QUFBQSxZQUFzQjtBQUM5RSxnQkFBSSxTQUFTLFFBQVE7QUFDckIsaUJBQUssT0FBTyxRQUFRLFFBQVEsSUFBSSxLQUFLO0FBQ3JDLHFCQUFTLElBQUksR0FBRyxJQUFJLEtBQUssUUFBUSxLQUFLO0FBQ3BDLG1CQUFLLE9BQU8sUUFBUSxRQUFRLElBQUksS0FBSyxDQUFDO0FBQUEsWUFDeEM7QUFDQSxtQkFBTyxLQUFLLE9BQU8sWUFBWSxLQUFLLGlCQUFpQixPQUFPLElBQUk7QUFBQSxVQUNsRSxTQUFTLEdBQUc7QUFDVixrQkFBTSxJQUFJO0FBQUEsY0FDTixzQ0FBc0MsS0FBSyxnQkFBZ0IsSUFBSSw4R0FFckQsQ0FBQztBQUFBLFlBQUU7QUFBQSxVQUNuQixVQUFFO0FBQ0EsaUJBQUssT0FBTyxhQUFhLEtBQUs7QUFBQSxVQUNoQztBQUFBLFFBQ0Y7QUFBQSxNQUNGO0FBZ0JPLE1BQU0sT0FBTyxPQUFNLFFBQXVCQyxNQUFVLGVBQTBDO0FBQ25HLGNBQU0sV0FBVyxPQUFPO0FBQ3hCLFlBQUksQ0FBQyxVQUFVO0FBQ2IsZ0JBQU0sSUFBSSxNQUFNLG1GQUFtRjtBQUFBLFFBQ3JHO0FBRUEsY0FBTSxVQUFVLElBQUksY0FBYztBQUNsQyxjQUFNLFFBQVEsV0FBV0EsTUFBSyxVQUFVO0FBRXhDO0FBQUE7QUFBQSxVQUVJO0FBQUE7QUFBQSxVQUdBLENBQUMsU0FBaUIsUUFBUSxNQUFNLElBQUk7QUFBQTtBQUFBLFVBR3BDLENBQUMsUUFBZ0IsUUFBUSxLQUFLLEdBQUc7QUFBQTtBQUFBLFVBR2pDLENBQUMsS0FBYSxLQUFhLE1BQWMsY0FBYyxVQUFVO0FBQy9ELGdCQUFJLGFBQWE7QUFDZix3QkFBVSxXQUFXLE1BQU0sa0NBQWtDLEdBQUcsU0FBUyxHQUFHLFVBQVUsSUFBSSxFQUFFO0FBQzVGLHNCQUFRLE9BQU8sS0FBSyxHQUFHO0FBQUEsWUFDekIsT0FBTztBQUNMLHdCQUFVLFdBQVcsTUFBTSx5Q0FBeUMsR0FBRyxlQUFlLEdBQUcsVUFBVSxJQUFJLEVBQUU7QUFDekcsb0JBQU0sT0FBTyxPQUFPLE9BQU8sU0FBUyxRQUFRLElBQUksUUFBUSxLQUFLLElBQUk7QUFDakUsc0JBQVEsT0FBTyxLQUFLLElBQUk7QUFBQSxZQUMxQjtBQUFBLFVBQ0Y7QUFBQTtBQUFBLFVBR0EsT0FBTSxXQUFtQixZQUFvQixTQUN4QjtBQUNmO0FBQUEsY0FDSTtBQUFBLGNBQ0EsTUFBTSx3Q0FBd0MsU0FBUyxnQkFBZ0IsVUFBVSxVQUFVLElBQUk7QUFBQSxZQUFFO0FBRXJHLGtCQUFNLFFBQVE7QUFBQSxjQUNWO0FBQUEsY0FBVyxNQUFNLE9BQU8sT0FBTyxTQUFTLGVBQWUsSUFBSSxlQUFlLEtBQUssSUFBSTtBQUFBLFlBQUM7QUFBQSxVQUMxRjtBQUFBO0FBQUEsVUFHSixDQUFDLFlBQW9CLFVBQWtCLGNBQ25DLFFBQVEsYUFBYSxZQUFZLFVBQVUsV0FBVyxPQUFPLGFBQWEsT0FBTyxpQkFBaUIsUUFBUSxDQUFDLENBQUM7QUFBQTtBQUFBLFVBR2hILENBQUMsV0FBbUIsUUFBUSxjQUFjLE1BQU07QUFBQTtBQUFBLFVBR2hELENBQUMsUUFBZ0IsbUJBQTJCLGVBQXVCLFdBQXdDO0FBQ3pHO0FBQUEsY0FDSTtBQUFBLGNBQ0EsTUFBTSxtQ0FBbUMsYUFBYSxZQUFZLE1BQU0sdUJBQ3BFLGlCQUFpQjtBQUFBLFlBQUU7QUFDM0Isa0JBQU0sVUFBVSxJQUFJLG1CQUFtQixRQUFRLFNBQVMsaUJBQWlCO0FBQ3pFLG1CQUFPLFFBQVEsY0FBYyxRQUFRLFNBQVMsTUFBTTtBQUFBLFVBQ3REO0FBQUEsUUFBQztBQUFBLE1BQ1A7QUFBQTtBQUFBOzs7QUM1TU8sTUFBTSxPQUFPOzs7QUNVcEIsTUFBSTtBQUVKLE1BQUksT0FBOEI7QUFDaEMscUJBQWlCO0FBQUEsRUFDbkIsT0FBTztBQUNMLHFCQUNJLFFBQTRCLE9BQW1DO0FBQUEsRUFDckU7QUFFQSxNQUFNLHlCQUFpRSxPQUNsRSxRQUE0QixPQUNBLHdDQUM3QjtBQUdKLE1BQUk7QUFDSixNQUFJLGNBQWM7QUFDbEIsTUFBSSxlQUFlO0FBQ25CLE1BQUksVUFBVTtBQUVkLE1BQU0seUJBQXlCLENBQUMsZUFBZ0M7QUFFOUQsUUFBSSxlQUFlLEdBQUc7QUFDcEIsYUFBTztBQUFBLElBQ1Q7QUFHQSxRQUFJLE9BQU8sc0JBQXNCLGFBQWE7QUFDNUMsVUFBSSxPQUFPLFNBQVMsZUFBZSxDQUFDLEtBQUsscUJBQXFCO0FBRTVELGdCQUFRO0FBQUEsVUFDSixtQ0FBbUMsYUFDbkM7QUFBQSxRQUNrRTtBQUFBLE1BQ3hFO0FBQ0EsYUFBTztBQUFBLElBQ1Q7QUFHQSxRQUFJLE9BQU8sWUFBWSxlQUFlLFFBQVEsWUFBWSxRQUFRLFNBQVMsTUFBTTtBQUUvRSxjQUFRO0FBQUEsUUFDSixtQ0FBbUMsYUFDbkM7QUFBQSxNQUM0RTtBQUFBLElBQ2xGO0FBRUEsUUFBSTtBQUdGLFVBQUksT0FBTyxtQkFBbUIsYUFBYTtBQUN6QyxZQUFJLGVBQWUsRUFBRSxNQUFNLFlBQVksSUFBSSxrQkFBa0IsQ0FBQyxDQUFDO0FBQUEsTUFDakU7QUFJQSxhQUFPLFlBQVksU0FBUyxJQUFJLFdBQVc7QUFBQSxRQUN6QztBQUFBLFFBQUc7QUFBQSxRQUFJO0FBQUEsUUFBSztBQUFBLFFBQUs7QUFBQSxRQUFHO0FBQUEsUUFBSTtBQUFBLFFBQUk7QUFBQSxRQUFHO0FBQUEsUUFBRztBQUFBLFFBQUc7QUFBQSxRQUFJO0FBQUEsUUFBSTtBQUFBLFFBQUs7QUFBQSxRQUFJO0FBQUEsUUFBRztBQUFBLFFBQUc7QUFBQSxRQUFJO0FBQUEsUUFBRztBQUFBLFFBQ25FO0FBQUEsUUFBRztBQUFBLFFBQUk7QUFBQSxRQUFLO0FBQUEsUUFBSztBQUFBLFFBQUc7QUFBQSxRQUFJO0FBQUEsUUFBSTtBQUFBLFFBQUc7QUFBQSxRQUFHO0FBQUEsUUFBRztBQUFBLFFBQUk7QUFBQSxRQUFJO0FBQUEsUUFBSztBQUFBLFFBQUk7QUFBQSxRQUFHO0FBQUEsUUFBRztBQUFBLFFBQUk7QUFBQSxNQUNsRSxDQUFDLENBQUM7QUFBQSxJQUNKLFNBQVMsR0FBRztBQUNWLGFBQU87QUFBQSxJQUNUO0FBQUEsRUFDRjtBQUVBLE1BQU0sa0JBQWtCLE1BQWU7QUFDckMsUUFBSTtBQWVGLGFBQU8sWUFBWSxTQUFTLElBQUksV0FBVztBQUFBLFFBQ3pDO0FBQUEsUUFBSztBQUFBLFFBQUk7QUFBQSxRQUFLO0FBQUEsUUFBSztBQUFBLFFBQUc7QUFBQSxRQUFHO0FBQUEsUUFBRztBQUFBLFFBQUc7QUFBQSxRQUFHO0FBQUEsUUFBRztBQUFBLFFBQUc7QUFBQSxRQUFJO0FBQUEsUUFBRztBQUFBLFFBQUc7QUFBQSxRQUFHO0FBQUEsUUFBRztBQUFBLFFBQUc7QUFBQSxRQUFHO0FBQUEsUUFBSTtBQUFBLFFBQUk7QUFBQSxRQUFLO0FBQUEsUUFBSztBQUFBLFFBQUc7QUFBQSxRQUFJO0FBQUEsUUFDdkY7QUFBQSxRQUFLO0FBQUEsUUFBSTtBQUFBLFFBQUs7QUFBQSxRQUFLO0FBQUEsUUFBRztBQUFBLFFBQUc7QUFBQSxRQUFHO0FBQUEsUUFBRztBQUFBLFFBQUc7QUFBQSxRQUFHO0FBQUEsUUFBRztBQUFBLFFBQUk7QUFBQSxRQUFHO0FBQUEsUUFBRztBQUFBLFFBQUc7QUFBQSxRQUFHO0FBQUEsUUFBRztBQUFBLFFBQUc7QUFBQSxRQUFJO0FBQUEsUUFBSTtBQUFBLFFBQUs7QUFBQSxRQUFLO0FBQUEsUUFBRztBQUFBLFFBQUk7QUFBQSxNQUN6RixDQUFDLENBQUM7QUFBQSxJQUNKLFNBQVMsR0FBRztBQUNWLGFBQU87QUFBQSxJQUNUO0FBQUEsRUFDRjtBQUVBLE1BQU0sa0JBQWtCLENBQUMsU0FBa0IsZUFBd0I7QUFDakUsUUFBSSxTQUFTO0FBQ1gsVUFBSSxPQUE4QjtBQUNoQyxlQUFPO0FBQUEsTUFDVDtBQUNBLGFBQU8sYUFBYSxnQ0FBZ0M7QUFBQSxJQUN0RCxPQUFPO0FBQ0wsYUFBTyxhQUFhLDJCQUEyQjtBQUFBLElBQ2pEO0FBQUEsRUFDRjtBQUVPLE1BQU0sd0JBQXdCLE9BQU0sVUFBK0M7QUFDeEYsUUFBSSxhQUFhO0FBQ2YsYUFBTyxRQUFRLFFBQVE7QUFBQSxJQUN6QjtBQUNBLFFBQUksY0FBYztBQUNoQixZQUFNLElBQUksTUFBTSx1REFBeUQ7QUFBQSxJQUMzRTtBQUNBLFFBQUksU0FBUztBQUNYLFlBQU0sSUFBSSxNQUFNLG9EQUFzRDtBQUFBLElBQ3hFO0FBRUEsbUJBQWU7QUFHZixVQUFNLFVBQVUsTUFBTTtBQUN0QixVQUFNLGFBQWEsTUFBTTtBQUN6QixVQUFNLE9BQU8sTUFBTTtBQUVuQixVQUFNLGFBQWEsdUJBQXVCLFVBQVU7QUFDcEQsVUFBTSxVQUFVLFFBQVEsZ0JBQWdCO0FBRXhDLFVBQU0sWUFBWSxNQUFNO0FBQ3hCLFVBQU0scUJBQXFCLE9BQU8sY0FBYyxXQUFXLFlBQVk7QUFDdkUsVUFBTSxlQUFlLGdCQUFnQixTQUFTLFVBQVU7QUFDeEQsVUFBTSxtQkFBbUIsT0FBTyxjQUFjLFdBQVcsVUFBVSxZQUFZLElBQUk7QUFFbkYsUUFBSSxZQUFZO0FBRWhCLFVBQU0sUUFBOEIsQ0FBQztBQUdyQyxRQUFJLFVBQVUsR0FBRztBQUNmLFlBQU0sS0FBSyxJQUFJLFFBQVEsQ0FBQyxZQUFZO0FBQ2xDLG1CQUFXLE1BQU07QUFDZixzQkFBWTtBQUNaLGtCQUFRO0FBQUEsUUFDVixHQUFHLE9BQU87QUFBQSxNQUNaLENBQUMsQ0FBQztBQUFBLElBQ0o7QUFHQSxVQUFNLEtBQUssSUFBSSxRQUFRLENBQUMsU0FBUyxXQUFXO0FBQzFDLFlBQU0sVUFBVSxhQUFhLHlCQUF5QjtBQUN0RCxZQUFNLFNBQWlDO0FBQUEsUUFDckMsWUFBWSxDQUFDLFVBQWtCLG9CQUE0QjtBQUN6RCxjQUF1QyxjQUFjLFNBQVMsU0FBUyxZQUFZLEtBQy9FLE9BQU8sU0FBUyxhQUFhO0FBQy9CLG1CQUFPLElBQUksZ0JBQWdCLElBQUk7QUFBQSxjQUMzQjtBQUFBO0FBQUE7QUFBQSxnQkFHRTtBQUFBLGNBQ0Y7QUFBQSxjQUNBLEVBQUMsTUFBTSxrQkFBaUI7QUFBQSxZQUFDLENBQUM7QUFBQSxVQUNoQztBQUVBLGNBQUksU0FBUyxTQUFTLE9BQU8sR0FBRztBQUM5QixnQkFBSSxrQkFBa0I7QUFDcEIscUJBQU87QUFBQSxZQUNUO0FBRUEsa0JBQU0sU0FBUyxzQkFBc0I7QUFFckMsZ0JBQUksTUFBNEI7QUFDOUIsa0JBQUksaUJBQWlCLHNCQUFzQjtBQUN6Qyx1QkFBTyxTQUFTO0FBQUEsY0FDbEIsV0FBVyxpQkFBaUIsK0JBQStCO0FBQ3pELHVCQUFPLFNBQVM7QUFBQSxjQUNsQjtBQUFBLFlBQ0Y7QUFFQSxtQkFBTyxTQUFTO0FBQUEsVUFDbEI7QUFFQSxpQkFBTyxrQkFBa0I7QUFBQSxRQUMzQjtBQUFBLE1BQ0Y7QUFFQSxVQUF1QyxZQUFZO0FBQ2pELGVBQU8sYUFBYTtBQUNwQixZQUFJLE9BQU8sU0FBUyxhQUFhO0FBQy9CLGlCQUFPLHNCQUEyQixLQUFLLFdBQVcsc0JBQXNCO0FBQUEsUUFDMUUsT0FBTztBQUNMLGdCQUFNLG1CQUFtQix1QkFBdUIsUUFBUSxTQUFTLENBQUM7QUFDbEUsaUJBQU8sc0JBQXNCLElBQUksS0FBSyxDQUFDLGdCQUFnQixHQUFHLEVBQUMsTUFBTSxrQkFBaUIsQ0FBQztBQUFBLFFBQ3JGO0FBQUEsTUFDRjtBQUVBLGNBQVEsTUFBTSxFQUFFO0FBQUE7QUFBQSxRQUVaLFlBQVU7QUFDUix5QkFBZTtBQUNmLHdCQUFjO0FBQ2QsaUJBQU87QUFDUCxrQkFBUTtBQUFBLFFBQ1Y7QUFBQTtBQUFBLFFBRUEsQ0FBQyxTQUFTO0FBQ1IseUJBQWU7QUFDZixvQkFBVTtBQUNWLGlCQUFPLElBQUk7QUFBQSxRQUNiO0FBQUEsTUFBQztBQUFBLElBQ1AsQ0FBQyxDQUFDO0FBRUYsVUFBTSxRQUFRLEtBQUssS0FBSztBQUV4QixRQUFJLFdBQVc7QUFDYixZQUFNLElBQUksTUFBTSwyREFBMkQsT0FBTyxJQUFJO0FBQUEsSUFDeEY7QUFBQSxFQUNGO0FBRU8sTUFBTSxjQUFjLE1BQXFCO0FBQzlDLFFBQUksZUFBZSxNQUFNO0FBQ3ZCLGFBQU87QUFBQSxJQUNUO0FBRUEsVUFBTSxJQUFJLE1BQU0scUNBQXFDO0FBQUEsRUFDdkQ7OztBQy9OTyxNQUFNLGtCQUFrQixDQUFDLE1BQWMsV0FBNkI7QUFDekUsVUFBTUMsUUFBTyxZQUFZO0FBRXpCLFVBQU0sYUFBYUEsTUFBSyxnQkFBZ0IsSUFBSSxJQUFJO0FBQ2hELFVBQU0sYUFBYUEsTUFBSyxRQUFRLFVBQVU7QUFDMUMsSUFBQUEsTUFBSyxhQUFhLE1BQU0sWUFBWSxVQUFVO0FBQzlDLFdBQU8sS0FBSyxVQUFVO0FBRXRCLFdBQU87QUFBQSxFQUNUO0FBTU8sTUFBTSxzQkFDVCxDQUFDLFNBQWtDLFFBQWdCLE1BQ2xELFlBQXVDO0FBQ3RDLFFBQUksT0FBTyxXQUFXLFlBQVksWUFBWSxNQUFNO0FBQ2xELFVBQUksS0FBSyxJQUFJLE9BQU8sR0FBRztBQUNyQixjQUFNLElBQUksTUFBTSwrQkFBK0I7QUFBQSxNQUNqRCxPQUFPO0FBQ0wsYUFBSyxJQUFJLE9BQU87QUFBQSxNQUNsQjtBQUFBLElBQ0Y7QUFFQSxXQUFPLFFBQVEsT0FBTyxFQUFFLFFBQVEsQ0FBQyxDQUFDLEtBQUssS0FBSyxNQUFNO0FBQ2hELFlBQU0sT0FBUSxTQUFVLFNBQVMsTUFBTTtBQUN2QyxVQUFJLE9BQU8sVUFBVSxVQUFVO0FBQzdCLDRCQUFvQixPQUFrQyxPQUFPLEtBQUssTUFBTSxPQUFPO0FBQUEsTUFDakYsV0FBVyxPQUFPLFVBQVUsWUFBWSxPQUFPLFVBQVUsVUFBVTtBQUNqRSxnQkFBUSxNQUFNLE1BQU0sU0FBUyxDQUFDO0FBQUEsTUFDaEMsV0FBVyxPQUFPLFVBQVUsV0FBVztBQUNyQyxnQkFBUSxNQUFPLFFBQVMsTUFBTSxHQUFHO0FBQUEsTUFDbkMsT0FBTztBQUNMLGNBQU0sSUFBSSxNQUFNLG1DQUFtQyxPQUFPLEtBQUssRUFBRTtBQUFBLE1BQ25FO0FBQUEsSUFDRixDQUFDO0FBQUEsRUFDSDtBQU1HLE1BQU0saUJBQWlCLENBQUMsWUFBMEI7QUFDdkQsVUFBTUEsUUFBTyxZQUFZO0FBRXpCLFVBQU0sUUFBUUEsTUFBSyxVQUFVO0FBQzdCLFFBQUk7QUFDRixZQUFNLGVBQWVBLE1BQUssV0FBVyxDQUFDO0FBQ3RDLE1BQUFBLE1BQUssaUJBQWlCLGNBQWMsZUFBZSxDQUFDO0FBQ3BELFlBQU0sWUFBWUEsTUFBSyxPQUFPLGVBQWUsQ0FBQztBQUM5QyxZQUFNLHNCQUFzQkEsTUFBSyxRQUFRLGVBQWUsSUFBSSxDQUFDO0FBQzdELFlBQU0sZUFBZSxzQkFBc0JBLE1BQUssYUFBYSxtQkFBbUIsSUFBSTtBQUNwRixZQUFNLElBQUksTUFBTSxHQUFHLE9BQU8sZ0JBQWdCLFNBQVMsb0JBQW9CLFlBQVksRUFBRTtBQUFBLElBQ3ZGLFVBQUU7QUFDQSxNQUFBQSxNQUFLLGFBQWEsS0FBSztBQUFBLElBQ3pCO0FBQUEsRUFDRjs7O0FDdkRPLE1BQU0sZ0JBQWdCLENBQUMsWUFBNkQ7QUFDekYsVUFBTUMsUUFBTyxZQUFZO0FBQ3pCLFFBQUksbUJBQW1CO0FBQ3ZCLFVBQU0sU0FBbUIsQ0FBQztBQUUxQixVQUFNLGFBQTBDLFdBQVcsQ0FBQztBQUU1RCxRQUFJO0FBQ0YsVUFBSSxTQUFTLHFCQUFxQixRQUFXO0FBQzNDLG1CQUFXLG1CQUFtQjtBQUFBLE1BQ2hDLFdBQ0ksT0FBTyxRQUFRLHFCQUFxQixZQUFZLENBQUMsT0FBTyxVQUFVLFFBQVEsZ0JBQWdCLEtBQzFGLFFBQVEsbUJBQW1CLEtBQUssUUFBUSxtQkFBbUIsR0FBRztBQUNoRSxjQUFNLElBQUksTUFBTSxxQ0FBcUMsUUFBUSxnQkFBZ0IsRUFBRTtBQUFBLE1BQ2pGO0FBRUEsVUFBSSxTQUFTLHNCQUFzQixRQUFXO0FBQzVDLG1CQUFXLG9CQUFvQjtBQUFBLE1BQ2pDLFdBQVcsT0FBTyxRQUFRLHNCQUFzQixZQUFZLENBQUMsT0FBTyxVQUFVLFFBQVEsaUJBQWlCLEdBQUc7QUFDeEcsY0FBTSxJQUFJLE1BQU0scUNBQXFDLFFBQVEsaUJBQWlCLEVBQUU7QUFBQSxNQUNsRjtBQUVBLFVBQUksU0FBUyxjQUFjLFFBQVc7QUFDcEMsbUJBQVcsWUFBWTtBQUFBLE1BQ3pCO0FBRUEsVUFBSSxnQkFBZ0I7QUFDcEIsVUFBSSxTQUFTLFFBQVEsUUFBVztBQUM5Qix3QkFBZ0IsZ0JBQWdCLFFBQVEsS0FBSyxNQUFNO0FBQUEsTUFDckQ7QUFFQSx5QkFBbUJBLE1BQUs7QUFBQSxRQUNwQixXQUFXO0FBQUEsUUFBbUIsV0FBVztBQUFBLFFBQW9CLENBQUMsQ0FBQyxXQUFXO0FBQUEsUUFBWTtBQUFBLE1BQWE7QUFDdkcsVUFBSSxxQkFBcUIsR0FBRztBQUMxQix1QkFBZSwyQkFBNEI7QUFBQSxNQUM3QztBQUVBLFVBQUksU0FBUyxVQUFVLFFBQVc7QUFDaEMsNEJBQW9CLFFBQVEsT0FBTyxJQUFJLG9CQUFJLFFBQWlDLEdBQUcsQ0FBQyxLQUFLLFVBQVU7QUFDN0YsZ0JBQU0sZ0JBQWdCLGdCQUFnQixLQUFLLE1BQU07QUFDakQsZ0JBQU0sa0JBQWtCLGdCQUFnQixPQUFPLE1BQU07QUFFckQsY0FBSUEsTUFBSyxzQkFBc0Isa0JBQWtCLGVBQWUsZUFBZSxNQUFNLEdBQUc7QUFDdEYsMkJBQWUsaUNBQWlDLEdBQUcsTUFBTSxLQUFLLEdBQUc7QUFBQSxVQUNuRTtBQUFBLFFBQ0YsQ0FBQztBQUFBLE1BQ0g7QUFFQSxhQUFPLENBQUMsa0JBQWtCLE1BQU07QUFBQSxJQUNsQyxTQUFTLEdBQUc7QUFDVixVQUFJLHFCQUFxQixHQUFHO0FBQzFCLFFBQUFBLE1BQUssc0JBQXNCLGdCQUFnQjtBQUFBLE1BQzdDO0FBQ0EsYUFBTyxRQUFRLFdBQVNBLE1BQUssTUFBTSxLQUFLLENBQUM7QUFDekMsWUFBTTtBQUFBLElBQ1I7QUFBQSxFQUNGOzs7QUN4REEsTUFBTSwyQkFBMkIsQ0FBQywyQkFBbUQ7QUFDbkYsWUFBUSx3QkFBd0I7QUFBQSxNQUM5QixLQUFLO0FBQ0gsZUFBTztBQUFBLE1BQ1QsS0FBSztBQUNILGVBQU87QUFBQSxNQUNULEtBQUs7QUFDSCxlQUFPO0FBQUEsTUFDVCxLQUFLO0FBQ0gsZUFBTztBQUFBLE1BQ1Q7QUFDRSxjQUFNLElBQUksTUFBTSx5Q0FBeUMsc0JBQXNCLEVBQUU7QUFBQSxJQUNyRjtBQUFBLEVBQ0Y7QUFFQSxNQUFNLG1CQUFtQixDQUFDLGtCQUFtRDtBQUMzRSxZQUFRLGVBQWU7QUFBQSxNQUNyQixLQUFLO0FBQ0gsZUFBTztBQUFBLE1BQ1QsS0FBSztBQUNILGVBQU87QUFBQSxNQUNUO0FBQ0UsY0FBTSxJQUFJLE1BQU0sK0JBQStCLGFBQWEsRUFBRTtBQUFBLElBQ2xFO0FBQUEsRUFDRjtBQUVBLE1BQU0sdUJBQXVCLENBQUMsWUFBbUQ7QUFDL0UsUUFBSSxDQUFDLFFBQVEsT0FBTztBQUNsQixjQUFRLFFBQVEsQ0FBQztBQUFBLElBQ25CO0FBQ0EsUUFBSSxDQUFDLFFBQVEsTUFBTSxTQUFTO0FBQzFCLGNBQVEsTUFBTSxVQUFVLENBQUM7QUFBQSxJQUMzQjtBQUNBLFVBQU0sVUFBVSxRQUFRLE1BQU07QUFDOUIsUUFBSSxDQUFDLFFBQVEsOEJBQThCO0FBRXpDLGNBQVEsK0JBQStCO0FBQUEsSUFDekM7QUFHQSxRQUFJLFFBQVEsc0JBQ1IsUUFBUSxtQkFBbUIsS0FBSyxTQUFPLE9BQU8sT0FBTyxXQUFXLEtBQUssR0FBRyxVQUFVLFFBQVEsR0FBRztBQUMvRixjQUFRLG1CQUFtQjtBQUFBLElBQzdCO0FBQUEsRUFDRjtBQUVBLE1BQU0sd0JBQ0YsQ0FBQyxzQkFBOEIsb0JBQzlCLFdBQTJCO0FBQzFCLGVBQVcsTUFBTSxvQkFBb0I7QUFDbkMsVUFBSSxTQUFTLE9BQU8sT0FBTyxXQUFXLEtBQUssR0FBRztBQUc5QyxjQUFRLFFBQVE7QUFBQSxRQUNkLEtBQUs7QUFDSCxtQkFBUztBQUNULGNBQUksT0FBTyxPQUFPLFVBQVU7QUFDMUIsa0JBQU0sZUFBZTtBQUNyQixnQkFBSSxjQUFjLFlBQVk7QUFDNUIsb0JBQU0sZ0JBQWdCLGdCQUFnQixjQUFjLE1BQU07QUFDMUQsb0JBQU0sa0JBQWtCLGdCQUFnQixhQUFhLFlBQVksTUFBTTtBQUN2RSxrQkFBSSxZQUFZLEVBQUUsMEJBQTBCLHNCQUFzQixlQUFlLGVBQWUsTUFDNUYsR0FBRztBQUNMLCtCQUFlLG9EQUFvRCxhQUFhLFVBQVUsR0FBRztBQUFBLGNBQy9GO0FBQUEsWUFDRjtBQUNBLGdCQUFJLGNBQWMsWUFBWTtBQUM1QixrQkFBSSxhQUFhLGFBQWE7QUFFOUIsa0JBQUksT0FBTyxjQUFjLFlBQVksQ0FBQyxPQUFPLFVBQVUsVUFBVSxLQUFLLGFBQWEsR0FBRztBQUNwRiw2QkFBYTtBQUFBLGNBQ2Y7QUFDQSxvQkFBTSxnQkFBZ0IsZ0JBQWdCLGNBQWMsTUFBTTtBQUMxRCxvQkFBTSxrQkFBa0IsZ0JBQWdCLFdBQVcsU0FBUyxHQUFHLE1BQU07QUFDckUsa0JBQUksWUFBWSxFQUFFLDBCQUEwQixzQkFBc0IsZUFBZSxlQUFlLE1BQzVGLEdBQUc7QUFDTCwrQkFBZSxvREFBb0QsYUFBYSxVQUFVLEdBQUc7QUFBQSxjQUMvRjtBQUFBLFlBQ0Y7QUFDQSxnQkFBSSxjQUFjLGlCQUFpQjtBQUNqQyxvQkFBTSxnQkFBZ0IsZ0JBQWdCLG1CQUFtQixNQUFNO0FBQy9ELG9CQUFNLGtCQUFrQixnQkFBZ0IsYUFBYSxpQkFBaUIsTUFBTTtBQUM1RSxrQkFBSSxZQUFZLEVBQUUsMEJBQTBCLHNCQUFzQixlQUFlLGVBQWUsTUFDNUYsR0FBRztBQUNMO0FBQUEsa0JBQ0kseURBQXlELGFBQWEsZUFBZTtBQUFBLGdCQUFHO0FBQUEsY0FDOUY7QUFBQSxZQUNGO0FBQUEsVUFDRjtBQUNBO0FBQUEsUUFDRixLQUFLO0FBQ0gsbUJBQVM7QUFDVCxjQUFJLE9BQU8sT0FBTyxVQUFVO0FBQzFCLGtCQUFNLGdCQUFnQjtBQUN0QixnQkFBSSxlQUFlLGlCQUFpQjtBQUNsQyxrQkFBSSxjQUFjLG9CQUFvQixVQUFVLGNBQWMsb0JBQW9CLFFBQVE7QUFDeEYsc0JBQU0sSUFBSSxNQUFNLG9EQUFvRCxjQUFjLGVBQWUsRUFBRTtBQUFBLGNBQ3JHO0FBQ0Esb0JBQU0sZ0JBQWdCLGdCQUFnQixtQkFBbUIsTUFBTTtBQUMvRCxvQkFBTSxrQkFBa0IsZ0JBQWdCLGNBQWMsaUJBQWlCLE1BQU07QUFDN0Usa0JBQUksWUFBWSxFQUFFLDBCQUEwQixzQkFBc0IsZUFBZSxlQUFlLE1BQzVGLEdBQUc7QUFDTDtBQUFBLGtCQUNJLHlEQUF5RCxjQUFjLGVBQWU7QUFBQSxnQkFBRztBQUFBLGNBQy9GO0FBQUEsWUFDRjtBQUFBLFVBQ0Y7QUFDQTtBQUFBLFFBQ0YsS0FBSztBQUFBLFFBQ0wsS0FBSztBQUNIO0FBQUEsUUFDRjtBQUNFLGdCQUFNLElBQUksTUFBTSxxQ0FBcUMsTUFBTSxFQUFFO0FBQUEsTUFDakU7QUFFQSxZQUFNLG1CQUFtQixnQkFBZ0IsUUFBUSxNQUFNO0FBQ3ZELFVBQUksWUFBWSxFQUFFLDRCQUE0QixzQkFBc0IsZ0JBQWdCLE1BQU0sR0FBRztBQUMzRix1QkFBZSxvQ0FBb0MsTUFBTSxHQUFHO0FBQUEsTUFDOUQ7QUFBQSxJQUNGO0FBQUEsRUFDRjtBQUVHLE1BQU0sb0JBQW9CLENBQUMsWUFBa0U7QUFDbEcsVUFBTUMsUUFBTyxZQUFZO0FBQ3pCLFFBQUksdUJBQXVCO0FBQzNCLFVBQU0sU0FBbUIsQ0FBQztBQUUxQixVQUFNLGlCQUFrRCxXQUFXLENBQUM7QUFDcEUseUJBQXFCLGNBQWM7QUFFbkMsUUFBSTtBQUNGLFlBQU0seUJBQXlCLHlCQUF5QixlQUFlLDBCQUEwQixLQUFLO0FBQ3RHLFlBQU0sZ0JBQWdCLGlCQUFpQixlQUFlLGlCQUFpQixZQUFZO0FBQ25GLFlBQU0sa0JBQ0YsT0FBTyxlQUFlLFVBQVUsV0FBVyxnQkFBZ0IsZUFBZSxPQUFPLE1BQU0sSUFBSTtBQUUvRixZQUFNLG1CQUFtQixlQUFlLG9CQUFvQjtBQUM1RCxVQUFJLENBQUMsT0FBTyxVQUFVLGdCQUFnQixLQUFLLG1CQUFtQixLQUFLLG1CQUFtQixHQUFHO0FBQ3ZGLGNBQU0sSUFBSSxNQUFNLHFDQUFxQyxnQkFBZ0IsRUFBRTtBQUFBLE1BQ3pFO0FBRUEsWUFBTSxvQkFBb0IsZUFBZSxxQkFBcUI7QUFDOUQsVUFBSSxDQUFDLE9BQU8sVUFBVSxpQkFBaUIsS0FBSyxvQkFBb0IsS0FBSyxvQkFBb0IsR0FBRztBQUMxRixjQUFNLElBQUksTUFBTSxxQ0FBcUMsaUJBQWlCLEVBQUU7QUFBQSxNQUMxRTtBQUVBLFlBQU0sK0JBQStCLE9BQU8sZUFBZSwyQkFBMkIsV0FDbEYsZ0JBQWdCLGVBQWUsd0JBQXdCLE1BQU0sSUFDN0Q7QUFFSiw2QkFBdUJBLE1BQUs7QUFBQSxRQUN4QjtBQUFBLFFBQXdCLENBQUMsQ0FBQyxlQUFlO0FBQUEsUUFBbUIsQ0FBQyxDQUFDLGVBQWU7QUFBQSxRQUFrQjtBQUFBLFFBQy9GLENBQUMsQ0FBQyxlQUFlO0FBQUEsUUFBaUI7QUFBQSxRQUFHO0FBQUEsUUFBaUI7QUFBQSxRQUFrQjtBQUFBLFFBQ3hFO0FBQUEsTUFBNEI7QUFDaEMsVUFBSSx5QkFBeUIsR0FBRztBQUM5Qix1QkFBZSwrQkFBZ0M7QUFBQSxNQUNqRDtBQUVBLFVBQUksZUFBZSxvQkFBb0I7QUFDckMsOEJBQXNCLHNCQUFzQixlQUFlLG9CQUFvQixNQUFNO0FBQUEsTUFDdkY7QUFFQSxVQUFJLGVBQWUsd0JBQXdCO0FBQ3pDLG1CQUFXLENBQUMsTUFBTSxLQUFLLEtBQUssT0FBTyxRQUFRLGVBQWUsc0JBQXNCLEdBQUc7QUFDakYsY0FBSSxPQUFPLFNBQVMsVUFBVTtBQUM1QixrQkFBTSxJQUFJLE1BQU0sa0RBQWtELElBQUksRUFBRTtBQUFBLFVBQzFFO0FBQ0EsY0FBSSxPQUFPLFVBQVUsWUFBWSxDQUFDLE9BQU8sVUFBVSxLQUFLLEtBQUssUUFBUSxHQUFHO0FBQ3RFLGtCQUFNLElBQUksTUFBTSxpRUFBaUUsS0FBSyxFQUFFO0FBQUEsVUFDMUY7QUFDQSxnQkFBTSxhQUFhLGdCQUFnQixNQUFNLE1BQU07QUFDL0MsY0FBSUEsTUFBSyw2QkFBNkIsc0JBQXNCLFlBQVksS0FBSyxNQUFNLEdBQUc7QUFDcEYsMkJBQWUsd0NBQXdDLElBQUksTUFBTSxLQUFLLEdBQUc7QUFBQSxVQUMzRTtBQUFBLFFBQ0Y7QUFBQSxNQUNGO0FBRUEsVUFBSSxlQUFlLFVBQVUsUUFBVztBQUN0Qyw0QkFBb0IsZUFBZSxPQUFPLElBQUksb0JBQUksUUFBaUMsR0FBRyxDQUFDLEtBQUssVUFBVTtBQUNwRyxnQkFBTSxnQkFBZ0IsZ0JBQWdCLEtBQUssTUFBTTtBQUNqRCxnQkFBTSxrQkFBa0IsZ0JBQWdCLE9BQU8sTUFBTTtBQUVyRCxjQUFJQSxNQUFLLDBCQUEwQixzQkFBc0IsZUFBZSxlQUFlLE1BQU0sR0FBRztBQUM5RiwyQkFBZSxxQ0FBcUMsR0FBRyxNQUFNLEtBQUssR0FBRztBQUFBLFVBQ3ZFO0FBQUEsUUFDRixDQUFDO0FBQUEsTUFDSDtBQUVBLGFBQU8sQ0FBQyxzQkFBc0IsTUFBTTtBQUFBLElBQ3RDLFNBQVMsR0FBRztBQUNWLFVBQUkseUJBQXlCLEdBQUc7QUFDOUIsUUFBQUEsTUFBSywwQkFBMEIsb0JBQW9CO0FBQUEsTUFDckQ7QUFDQSxhQUFPLFFBQVEsV0FBU0EsTUFBSyxNQUFNLEtBQUssQ0FBQztBQUN6QyxZQUFNO0FBQUEsSUFDUjtBQUFBLEVBQ0Y7OztBQ3BNQTs7O0FDTEE7OztBQ0hPLE1BQU1DLFlBQVc7OztBRFlqQixNQUFNLFdBQVcsT0FBTSxTQUFzRTtBQUNsRyxRQUFJLE9BQU8sU0FBUyxVQUFVO0FBQzVCLFVBQUksT0FBTyxZQUFZLGVBQWUsUUFBUSxZQUFZLFFBQVEsU0FBUyxNQUFNO0FBRS9FLFlBQUk7QUFDRixpQkFBTyxJQUFJLFdBQVcsTUFBTUMsVUFBUyxJQUFJLENBQUM7QUFBQSxRQUM1QyxTQUFTLEdBQUc7QUFDVixjQUFJLEVBQUUsU0FBUyx5QkFBeUI7QUFFdEMsa0JBQU0sU0FBWSxpQkFBaUIsSUFBSTtBQUN2QyxrQkFBTSxTQUF1QixDQUFDO0FBQzlCLDZCQUFpQixTQUFTLFFBQVE7QUFDaEMscUJBQU8sS0FBSyxLQUFLO0FBQUEsWUFDbkI7QUFDQSxtQkFBTyxJQUFJLFdBQVcsT0FBTyxPQUFPLE1BQU0sQ0FBQztBQUFBLFVBQzdDO0FBQ0EsZ0JBQU07QUFBQSxRQUNSO0FBQUEsTUFDRixPQUFPO0FBRUwsY0FBTSxXQUFXLE1BQU0sTUFBTSxJQUFJO0FBQ2pDLFlBQUksQ0FBQyxTQUFTLElBQUk7QUFDaEIsZ0JBQU0sSUFBSSxNQUFNLHNDQUFzQyxJQUFJLEVBQUU7QUFBQSxRQUM5RDtBQUNBLGNBQU0sc0JBQXNCLFNBQVMsUUFBUSxJQUFJLGdCQUFnQjtBQUNqRSxjQUFNLFdBQVcsc0JBQXNCLFNBQVMscUJBQXFCLEVBQUUsSUFBSTtBQUMzRSxZQUFJLFdBQVcsWUFBc0I7QUFHbkMsaUJBQU8sSUFBSSxXQUFXLE1BQU0sU0FBUyxZQUFZLENBQUM7QUFBQSxRQUNwRCxPQUFPO0FBRUwsY0FBSSxDQUFDLFNBQVMsTUFBTTtBQUNsQixrQkFBTSxJQUFJLE1BQU0sc0NBQXNDLElBQUkscUJBQXFCO0FBQUEsVUFDakY7QUFDQSxnQkFBTSxTQUFTLFNBQVMsS0FBSyxVQUFVO0FBRXZDLGNBQUk7QUFDSixjQUFJO0FBRUYscUJBQVMsSUFBSSxZQUFZLFFBQVE7QUFBQSxVQUNuQyxTQUFTLEdBQUc7QUFDVixnQkFBSSxhQUFhLFlBQVk7QUFFM0Isb0JBQU0sUUFBUSxLQUFLLEtBQUssV0FBVyxLQUFLO0FBQ3hDLHVCQUFTLElBQUksWUFBWSxPQUFPLEVBQUMsU0FBUyxPQUFPLFNBQVMsTUFBSyxDQUFDLEVBQUU7QUFBQSxZQUNwRSxPQUFPO0FBQ0wsb0JBQU07QUFBQSxZQUNSO0FBQUEsVUFDRjtBQUVBLGNBQUksU0FBUztBQUViLGlCQUFPLE1BQU07QUFDWCxrQkFBTSxFQUFDLE1BQU0sTUFBSyxJQUFJLE1BQU0sT0FBTyxLQUFLO0FBQ3hDLGdCQUFJLE1BQU07QUFDUjtBQUFBLFlBQ0Y7QUFDQSxrQkFBTSxZQUFZLE1BQU07QUFDeEIsa0JBQU0sUUFBUSxJQUFJLFdBQVcsUUFBUSxRQUFRLFNBQVM7QUFDdEQsa0JBQU0sSUFBSSxLQUFLO0FBQ2Ysc0JBQVU7QUFBQSxVQUNaO0FBQ0EsaUJBQU8sSUFBSSxXQUFXLFFBQVEsR0FBRyxRQUFRO0FBQUEsUUFDM0M7QUFBQSxNQUNGO0FBQUEsSUFFRixXQUFXLGdCQUFnQixNQUFNO0FBQy9CLGFBQU8sSUFBSSxXQUFXLE1BQU0sS0FBSyxZQUFZLENBQUM7QUFBQSxJQUNoRCxXQUFXLGdCQUFnQixZQUFZO0FBQ3JDLGFBQU87QUFBQSxJQUNULE9BQU87QUFDTCxhQUFPLElBQUksV0FBVyxJQUFJO0FBQUEsSUFDNUI7QUFBQSxFQUNGOzs7QUR2QkEsTUFBTSxVQUFVLENBQUMsWUFBb0IsaUJBQStCO0FBQ2xFLFVBQU0sWUFBWSxZQUFZLEVBQUUsU0FBUyxZQUFZLFlBQVk7QUFDakUsUUFBSSxjQUFjLEdBQUc7QUFDbkIscUJBQWUsK0JBQWdDO0FBQUEsSUFDakQ7QUFBQSxFQUNGO0FBTU8sTUFBTSxjQUFjLE9BQU1DLFNBQTRCO0FBRTNELFlBQVFBLEtBQUksS0FBSyxZQUFhLHFCQUFxQkEsS0FBSSxRQUFRLENBQUM7QUFBQSxFQUNsRTtBQVFPLE1BQU0sU0FBUyxPQUFNQSxNQUFVLFdBQWtDO0FBQ3RFLFFBQWtDLFdBQVcsVUFBVTtBQUVyRCxVQUFJLE9BQU8sY0FBYyxlQUFlLENBQUMsVUFBVSxLQUFLO0FBQ3RELGNBQU0sSUFBSSxNQUFNLGdEQUFnRDtBQUFBLE1BQ2xFO0FBQ0EsWUFBTSxVQUFVLE1BQU0sVUFBVSxJQUFJLGVBQWU7QUFDbkQsVUFBSSxDQUFDLFNBQVM7QUFDWixjQUFNLElBQUk7QUFBQSxVQUNOO0FBQUEsUUFBMEc7QUFBQSxNQUNoSDtBQUVBLFVBQUksQ0FBQ0EsS0FBSSxLQUFLLE1BQU07QUFDbEIsY0FBTSxJQUFJO0FBQUEsVUFDTjtBQUFBLFFBQXFHO0FBQUEsTUFDM0c7QUFLQSxZQUFNLFdBQVcsMENBQXVCO0FBQ3hDLFlBQU0sU0FBUyxZQUFZLEdBQUdBLE1BQUssT0FBTztBQUFBLElBQzVDO0FBQUEsRUFDRjtBQW9DQSxNQUFNLGlCQUFpQixvQkFBSSxJQUE2QjtBQU94RCxNQUFNLDZCQUE2QixDQUFDLGtCQUE0QztBQUM5RSxVQUFNQyxRQUFPLFlBQVk7QUFDekIsVUFBTSxRQUFRQSxNQUFLLFVBQVU7QUFDN0IsUUFBSTtBQUNGLFlBQU0sYUFBYUEsTUFBSyxXQUFXLENBQUM7QUFDcEMsWUFBTSxZQUFZQSxNQUFLLHdCQUF3QixlQUFlLFlBQVksYUFBYSxDQUFDO0FBQ3hGLFVBQUksY0FBYyxHQUFHO0FBQ25CLHVCQUFlLHVDQUF3QztBQUFBLE1BQ3pEO0FBQ0EsYUFBTyxDQUFDQSxNQUFLLE9BQU8sYUFBYSxDQUFDLEdBQUdBLE1BQUssT0FBTyxhQUFhLElBQUksQ0FBQyxDQUFDO0FBQUEsSUFDdEUsVUFBRTtBQUNBLE1BQUFBLE1BQUssYUFBYSxLQUFLO0FBQUEsSUFDekI7QUFBQSxFQUNGO0FBUU8sTUFBTSx5QkFBeUIsQ0FBQyxVQUF3QztBQUM3RSxVQUFNQSxRQUFPLFlBQVk7QUFDekIsVUFBTSxrQkFBa0JBLE1BQUssUUFBUSxNQUFNLFVBQVU7QUFDckQsUUFBSSxvQkFBb0IsR0FBRztBQUN6QixZQUFNLElBQUksTUFBTSwrREFBK0QsTUFBTSxVQUFVLEdBQUc7QUFBQSxJQUNwRztBQUNBLElBQUFBLE1BQUssT0FBTyxJQUFJLE9BQU8sZUFBZTtBQUN0QyxXQUFPLENBQUMsaUJBQWlCLE1BQU0sVUFBVTtBQUFBLEVBQzNDO0FBVU8sTUFBTSxnQkFBZ0IsT0FDekIsV0FDQSxZQUFvRjtBQUN0RixRQUFJLGlCQUF5QjtBQUM3QixVQUFNQSxRQUFPLFlBQVk7QUFFekIsUUFBSSxNQUFNLFFBQVEsU0FBUyxHQUFHO0FBRTVCLE9BQUMsaUJBQWlCLGVBQWUsSUFBSTtBQUFBLElBQ3ZDLFdBQVcsVUFBVSxXQUFXQSxNQUFLLE9BQU8sUUFBUTtBQUVsRCxPQUFDLGlCQUFpQixlQUFlLElBQUksQ0FBQyxVQUFVLFlBQVksVUFBVSxVQUFVO0FBQUEsSUFDbEYsT0FBTztBQUVMLE9BQUMsaUJBQWlCLGVBQWUsSUFBSSx1QkFBdUIsU0FBUztBQUFBLElBQ3ZFO0FBRUEsUUFBSSxnQkFBZ0I7QUFDcEIsUUFBSSx1QkFBdUI7QUFDM0IsUUFBSSxrQkFBa0I7QUFDdEIsUUFBSSxTQUFtQixDQUFDO0FBQ3hCLFVBQU0sd0JBQXdCLENBQUM7QUFDL0IsVUFBTSx5QkFBeUIsQ0FBQztBQUVoQyxRQUFJO0FBQ0YsT0FBQyxzQkFBc0IsTUFBTSxJQUFJLGtCQUFrQixPQUFPO0FBRTFELFVBQUksU0FBUyxnQkFBZ0JBLE1BQUssbUJBQW1CO0FBQ25ELGNBQU0sa0JBQWtCLENBQUM7QUFDekIsbUJBQVcsUUFBUSxRQUFRLGNBQWM7QUFDdkMsZ0JBQU0sT0FBTyxPQUFPLFNBQVMsV0FBVyxPQUFPLEtBQUs7QUFDcEQsMEJBQWdCLEtBQUssU0FBUyxPQUFPLFNBQVMsV0FBVyxPQUFPLEtBQUssSUFBSSxFQUFFLEtBQUssVUFBUTtBQUN0RixZQUFBQSxNQUFLLGtCQUFtQixNQUFNLElBQUk7QUFBQSxVQUNwQyxDQUFDLENBQUM7QUFBQSxRQUNKO0FBR0EsY0FBTSxRQUFRLElBQUksZUFBZTtBQUFBLE1BQ25DO0FBRUEsc0JBQWdCQSxNQUFLLGtCQUFrQixpQkFBaUIsaUJBQWlCLG9CQUFvQjtBQUM3RixVQUFJLGtCQUFrQixHQUFHO0FBQ3ZCLHVCQUFlLHlCQUEwQjtBQUFBLE1BQzNDO0FBRUEsWUFBTSxDQUFDLFlBQVksV0FBVyxJQUFJLDJCQUEyQixhQUFhO0FBRTFFLFlBQU0sYUFBYSxDQUFDO0FBQ3BCLFlBQU0sY0FBYyxDQUFDO0FBQ3JCLFlBQU0sMkJBQXdFLENBQUM7QUFDL0UsZUFBUyxJQUFJLEdBQUcsSUFBSSxZQUFZLEtBQUs7QUFDbkMsY0FBTSxPQUFPQSxNQUFLLGlCQUFpQixlQUFlLENBQUM7QUFDbkQsWUFBSSxTQUFTLEdBQUc7QUFDZCx5QkFBZSwwQkFBMkI7QUFBQSxRQUM1QztBQUNBLDhCQUFzQixLQUFLLElBQUk7QUFDL0IsbUJBQVcsS0FBS0EsTUFBSyxhQUFhLElBQUksQ0FBQztBQUFBLE1BQ3pDO0FBQ0EsZUFBUyxJQUFJLEdBQUcsSUFBSSxhQUFhLEtBQUs7QUFDcEMsY0FBTSxPQUFPQSxNQUFLLGtCQUFrQixlQUFlLENBQUM7QUFDcEQsWUFBSSxTQUFTLEdBQUc7QUFDZCx5QkFBZSwyQkFBNEI7QUFBQSxRQUM3QztBQUNBLCtCQUF1QixLQUFLLElBQUk7QUFDaEMsY0FBTSxhQUFhQSxNQUFLLGFBQWEsSUFBSTtBQUN6QyxvQkFBWSxLQUFLLFVBQVU7QUFFM0IsWUFBSSxNQUE0QjtBQUM5QixnQkFBTSxXQUFXLE9BQU8sU0FBUyw0QkFBNEIsV0FDekQsUUFBUSwwQkFDUixTQUFTLDBCQUEwQixVQUFVLEtBQUs7QUFDdEQsY0FBSSxhQUFhLFNBQVMsYUFBYSxnQkFBZ0IsYUFBYSxjQUFjO0FBQ2hGLGtCQUFNLElBQUksTUFBTSw0Q0FBNEMsUUFBUSxHQUFHO0FBQUEsVUFDekU7QUFDQSxtQ0FBeUIsS0FBSyxRQUFRO0FBQUEsUUFDeEM7QUFBQSxNQUNGO0FBR0EsVUFBSSxlQUFvQztBQUN4QyxVQUFrQyx5QkFBeUIsS0FBSyxPQUFLLE1BQU0sWUFBWSxHQUFHO0FBQ3hGLDBCQUFrQkEsTUFBSyxrQkFBa0IsYUFBYTtBQUN0RCxZQUFJLG9CQUFvQixHQUFHO0FBQ3pCLHlCQUFlLDBCQUEyQjtBQUFBLFFBQzVDO0FBRUEsdUJBQWU7QUFBQSxVQUNiLFFBQVE7QUFBQSxVQUNSO0FBQUEsVUFDQSxpQ0FBaUMseUJBQXlCLElBQUksT0FBSyx5QkFBeUIsQ0FBQyxDQUFDO0FBQUEsUUFDaEc7QUFBQSxNQUNGO0FBRUEscUJBQWUsSUFBSSxlQUFlLENBQUMsZUFBZSx1QkFBdUIsd0JBQXdCLFlBQVksQ0FBQztBQUM5RyxhQUFPLENBQUMsZUFBZSxZQUFZLFdBQVc7QUFBQSxJQUNoRCxTQUFTLEdBQUc7QUFDViw0QkFBc0IsUUFBUSxTQUFPQSxNQUFLLFNBQVMsR0FBRyxDQUFDO0FBQ3ZELDZCQUF1QixRQUFRLFNBQU9BLE1BQUssU0FBUyxHQUFHLENBQUM7QUFFeEQsVUFBSSxvQkFBb0IsR0FBRztBQUN6QixRQUFBQSxNQUFLLG1CQUFtQixlQUFlO0FBQUEsTUFDekM7QUFFQSxVQUFJLGtCQUFrQixHQUFHO0FBQ3ZCLFFBQUFBLE1BQUssbUJBQW1CLGFBQWE7QUFBQSxNQUN2QztBQUNBLFlBQU07QUFBQSxJQUNSLFVBQUU7QUFDQSxNQUFBQSxNQUFLLE1BQU0sZUFBZTtBQUMxQixVQUFJLHlCQUF5QixHQUFHO0FBQzlCLFFBQUFBLE1BQUssMEJBQTBCLG9CQUFvQjtBQUFBLE1BQ3JEO0FBQ0EsYUFBTyxRQUFRLFdBQVNBLE1BQUssTUFBTSxLQUFLLENBQUM7QUFHekMsTUFBQUEsTUFBSyxzQkFBc0I7QUFBQSxJQUM3QjtBQUFBLEVBQ0Y7QUFFTyxNQUFNLGlCQUFpQixDQUFDLGNBQTRCO0FBQ3pELFVBQU1BLFFBQU8sWUFBWTtBQUN6QixVQUFNLFVBQVUsZUFBZSxJQUFJLFNBQVM7QUFDNUMsUUFBSSxDQUFDLFNBQVM7QUFDWixZQUFNLElBQUksTUFBTSwrQ0FBK0MsU0FBUyxFQUFFO0FBQUEsSUFDNUU7QUFDQSxVQUFNLENBQUMsZUFBZSx1QkFBdUIsd0JBQXdCLGNBQWMsSUFBSTtBQUV2RixRQUFJLGdCQUFnQjtBQUNsQixNQUFBQSxNQUFLLG1CQUFtQixlQUFlLE1BQU07QUFBQSxJQUMvQztBQUVBLElBQUFBLE1BQUssd0JBQXdCLFNBQVM7QUFFdEMsMEJBQXNCLFFBQVEsU0FBT0EsTUFBSyxTQUFTLEdBQUcsQ0FBQztBQUN2RCwyQkFBdUIsUUFBUSxTQUFPQSxNQUFLLFNBQVMsR0FBRyxDQUFDO0FBQ3hELElBQUFBLE1BQUssbUJBQW1CLGFBQWE7QUFDckMsbUJBQWUsT0FBTyxTQUFTO0FBQUEsRUFDakM7QUFFTyxNQUFNLDJCQUNULENBQUMsUUFBNkIsZUFBeUIsUUFBa0IsV0FBbUIsVUFDaEY7QUFDTixRQUFJLENBQUMsUUFBUTtBQUNYLG9CQUFjLEtBQUssQ0FBQztBQUNwQjtBQUFBLElBQ0Y7QUFFQSxVQUFNQSxRQUFPLFlBQVk7QUFFekIsVUFBTSxXQUFXLE9BQU8sQ0FBQztBQUN6QixVQUFNLE9BQU8sT0FBTyxDQUFDO0FBQ3JCLFVBQU0sV0FBVyxPQUFPLENBQUM7QUFFekIsUUFBSTtBQUNKLFFBQUk7QUFFSixRQUFJLGFBQWEsWUFBWSxhQUFhLGNBQWM7QUFDdEQsWUFBTSxJQUFJLE1BQU0sd0NBQXdDO0FBQUEsSUFDMUQ7QUFFQSxRQUFJLGFBQWEsY0FBYztBQUM3QixZQUFNLFlBQVksT0FBTyxDQUFDLEVBQUU7QUFDNUIsWUFBTSxxQkFBcUIscUJBQXFCLDJCQUEyQixRQUFRLENBQUM7QUFDcEYsdUJBQWlCLEtBQUssT0FBTyxDQUFDLEdBQUcsTUFBTSxJQUFJLEdBQUcsQ0FBQyxJQUFJO0FBQ25ELGdCQUFVQSxNQUFLLG1CQUFtQixXQUFXLE9BQU8sV0FBVyxjQUFjO0FBQUEsSUFDL0UsT0FBTztBQUNMLFlBQU0sT0FBTyxPQUFPLENBQUM7QUFFckIsVUFBSSxNQUFNLFFBQVEsSUFBSSxHQUFHO0FBRXZCLHlCQUFpQixJQUFJLEtBQUs7QUFDMUIsa0JBQVVBLE1BQUssUUFBUSxjQUFjO0FBQ3JDLGVBQU8sS0FBSyxPQUFPO0FBQ25CLFlBQUksWUFBWSxVQUFVO0FBQzFCLGlCQUFTLElBQUksR0FBRyxJQUFJLEtBQUssUUFBUSxLQUFLO0FBQ3BDLGNBQUksT0FBTyxLQUFLLENBQUMsTUFBTSxVQUFVO0FBQy9CLGtCQUFNLElBQUksVUFBVSx3QkFBd0IsQ0FBQyxrQkFBa0I7QUFBQSxVQUNqRTtBQUNBLFVBQUFBLE1BQUssUUFBUSxXQUFXLElBQUksZ0JBQWdCLEtBQUssQ0FBQyxHQUFHLE1BQU07QUFBQSxRQUM3RDtBQUFBLE1BQ0YsT0FBTztBQUNMLHlCQUFpQixLQUFLO0FBQ3RCLGtCQUFVQSxNQUFLLFFBQVEsY0FBYztBQUNyQyxlQUFPLEtBQUssT0FBTztBQUNuQixRQUFBQSxNQUFLLE9BQU8sSUFBSSxJQUFJLFdBQVcsS0FBSyxRQUFRLEtBQUssWUFBWSxjQUFjLEdBQUcsT0FBTztBQUFBLE1BQ3ZGO0FBQUEsSUFDRjtBQUVBLFVBQU0sUUFBUUEsTUFBSyxVQUFVO0FBQzdCLFVBQU0sYUFBYUEsTUFBSyxXQUFXLElBQUksS0FBSyxNQUFNO0FBQ2xELFFBQUk7QUFDRixVQUFJLFdBQVcsYUFBYTtBQUM1QixXQUFLLFFBQVEsT0FBS0EsTUFBSyxPQUFPLFVBQVUsSUFBSSxDQUFDO0FBQzdDLFlBQU1DLFVBQVNELE1BQUs7QUFBQSxRQUNoQiwyQkFBMkIsUUFBUTtBQUFBLFFBQUc7QUFBQSxRQUFTO0FBQUEsUUFBZ0I7QUFBQSxRQUFZLEtBQUs7QUFBQSxRQUNoRix5QkFBeUIsUUFBUTtBQUFBLE1BQUM7QUFDdEMsVUFBSUMsWUFBVyxHQUFHO0FBQ2hCLHVCQUFlLGlEQUFpRCxTQUFTLFdBQVcsS0FBSyxHQUFHO0FBQUEsTUFDOUY7QUFDQSxvQkFBYyxLQUFLQSxPQUFNO0FBQUEsSUFDM0IsVUFBRTtBQUNBLE1BQUFELE1BQUssYUFBYSxLQUFLO0FBQUEsSUFDekI7QUFBQSxFQUNGO0FBS0QsTUFBTSxNQUFNLE9BQ2YsV0FBbUIsY0FBd0IsY0FBZ0MsZUFDM0UsZUFBMkMsWUFBb0U7QUFDakgsVUFBTUEsUUFBTyxZQUFZO0FBQ3pCLFVBQU0sVUFBVSxlQUFlLElBQUksU0FBUztBQUM1QyxRQUFJLENBQUMsU0FBUztBQUNaLFlBQU0sSUFBSSxNQUFNLDZDQUE2QyxTQUFTLEVBQUU7QUFBQSxJQUMxRTtBQUNBLFVBQU0sQ0FBQyxlQUFlLHVCQUF1Qix3QkFBd0IsY0FBYyxJQUFJO0FBRXZGLFVBQU0sYUFBYSxhQUFhO0FBQ2hDLFVBQU0sY0FBYyxjQUFjO0FBRWxDLFFBQUksbUJBQW1CO0FBQ3ZCLFFBQUksbUJBQTZCLENBQUM7QUFFbEMsVUFBTSxxQkFBK0IsQ0FBQztBQUN0QyxVQUFNLHNCQUFnQyxDQUFDO0FBQ3ZDLFVBQU0sb0JBQThCLENBQUM7QUFFckMsVUFBTSxpQkFBaUJBLE1BQUssVUFBVTtBQUN0QyxVQUFNLG9CQUFvQkEsTUFBSyxXQUFXLGFBQWEsQ0FBQztBQUN4RCxVQUFNLG1CQUFtQkEsTUFBSyxXQUFXLGFBQWEsQ0FBQztBQUN2RCxVQUFNLHFCQUFxQkEsTUFBSyxXQUFXLGNBQWMsQ0FBQztBQUMxRCxVQUFNLG9CQUFvQkEsTUFBSyxXQUFXLGNBQWMsQ0FBQztBQUV6RCxRQUFJO0FBQ0YsT0FBQyxrQkFBa0IsZ0JBQWdCLElBQUksY0FBYyxPQUFPO0FBRzVELGVBQVMsSUFBSSxHQUFHLElBQUksWUFBWSxLQUFLO0FBQ25DLGlDQUF5QixhQUFhLENBQUMsR0FBRyxvQkFBb0IsbUJBQW1CLFdBQVcsYUFBYSxDQUFDLENBQUM7QUFBQSxNQUM3RztBQUdBLGVBQVMsSUFBSSxHQUFHLElBQUksYUFBYSxLQUFLO0FBQ3BDO0FBQUEsVUFDSSxjQUFjLENBQUM7QUFBQSxVQUFHO0FBQUEsVUFBcUI7QUFBQSxVQUFtQjtBQUFBLFVBQVcsYUFBYSxjQUFjLENBQUM7QUFBQSxRQUFDO0FBQUEsTUFDeEc7QUFFQSxVQUFJLG1CQUFtQixvQkFBb0I7QUFDM0MsVUFBSSxrQkFBa0IsbUJBQW1CO0FBQ3pDLFVBQUksb0JBQW9CLHFCQUFxQjtBQUM3QyxVQUFJLG1CQUFtQixvQkFBb0I7QUFDM0MsZUFBUyxJQUFJLEdBQUcsSUFBSSxZQUFZLEtBQUs7QUFDbkMsUUFBQUEsTUFBSyxRQUFRLGtCQUFrQixJQUFJLG1CQUFtQixDQUFDO0FBQ3ZELFFBQUFBLE1BQUssUUFBUSxpQkFBaUIsSUFBSSxzQkFBc0IsYUFBYSxDQUFDLENBQUM7QUFBQSxNQUN6RTtBQUNBLGVBQVMsSUFBSSxHQUFHLElBQUksYUFBYSxLQUFLO0FBQ3BDLFFBQUFBLE1BQUssUUFBUSxtQkFBbUIsSUFBSSxvQkFBb0IsQ0FBQztBQUN6RCxRQUFBQSxNQUFLLFFBQVEsa0JBQWtCLElBQUksdUJBQXVCLGNBQWMsQ0FBQyxDQUFDO0FBQUEsTUFDNUU7QUFFQSxVQUFrQyxnQkFBZ0I7QUFDaEQsY0FBTSxFQUFDLFFBQVEsMEJBQTBCLGdDQUErQixJQUFJO0FBRTVFLFlBQUksc0JBQXNCLFdBQVcsWUFBWTtBQUMvQyxnQkFBTSxJQUFJLE1BQU0sMkJBQ1osVUFBVSw0REFBNEQsc0JBQXNCLE1BQU0sSUFBSTtBQUFBLFFBQzVHO0FBR0EsaUJBQVMsSUFBSSxHQUFHLElBQUksWUFBWSxLQUFLO0FBQ25DLGdCQUFNLFFBQVEsYUFBYSxDQUFDO0FBQzVCLGdCQUFNRSxhQUFZLE1BQU1GLE1BQUssY0FBYyxRQUFRLHNCQUFzQixLQUFLLEdBQUcsbUJBQW1CLENBQUMsQ0FBQztBQUN0RyxjQUFJRSxlQUFjLEdBQUc7QUFDbkIsMkJBQWUsb0JBQW9CLENBQUMsaUJBQWlCLFNBQVMsR0FBRztBQUFBLFVBQ25FO0FBQUEsUUFDRjtBQUdBLGlCQUFTLElBQUksR0FBRyxJQUFJLGFBQWEsS0FBSztBQUNwQyxnQkFBTSxRQUFRLGNBQWMsQ0FBQztBQUM3QixnQkFBTSxXQUFXLGNBQWMsQ0FBQyxJQUFJLENBQUM7QUFFckMsY0FBSSxVQUFVO0FBRVosa0JBQU1BLGFBQVlGLE1BQUssZUFBZSxRQUFRLHVCQUF1QixLQUFLLEdBQUcsb0JBQW9CLENBQUMsR0FBRyxDQUFDO0FBQ3RHLGdCQUFJRSxlQUFjLEdBQUc7QUFDbkIsNkJBQWUsbUNBQW1DLENBQUMsaUJBQWlCLFNBQVMsR0FBRztBQUFBLFlBQ2xGO0FBQUEsVUFDRixPQUFPO0FBRUwsa0JBQU1BLGFBQ0ZGLE1BQUssZUFBZSxRQUFRLHVCQUF1QixLQUFLLEdBQUcsR0FBRyxnQ0FBZ0MsS0FBSyxDQUFDO0FBQ3hHLGdCQUFJRSxlQUFjLEdBQUc7QUFDbkIsNkJBQWUscUJBQXFCLENBQUMsUUFBUSx5QkFBeUIsQ0FBQyxDQUFDLGdCQUFnQixTQUFTLEdBQUc7QUFBQSxZQUN0RztBQUFBLFVBQ0Y7QUFBQSxRQUNGO0FBQUEsTUFDRjtBQUVBLFVBQUk7QUFFSixVQUFrQyxnQkFBZ0I7QUFDaEQsb0JBQVksTUFBTUYsTUFBSztBQUFBLFVBQ25CO0FBQUEsVUFBZSxlQUFlO0FBQUEsVUFBUTtBQUFBLFVBQWE7QUFBQSxVQUFvQjtBQUFBLFFBQWdCO0FBQUEsTUFDN0YsT0FBTztBQUNMLG9CQUFZLE1BQU1BLE1BQUs7QUFBQSxVQUNuQjtBQUFBLFVBQWU7QUFBQSxVQUFrQjtBQUFBLFVBQW1CO0FBQUEsVUFBWTtBQUFBLFVBQW1CO0FBQUEsVUFDbkY7QUFBQSxVQUFvQjtBQUFBLFFBQWdCO0FBQUEsTUFDMUM7QUFFQSxVQUFJLGNBQWMsR0FBRztBQUNuQix1QkFBZSwwQkFBMEI7QUFBQSxNQUMzQztBQUVBLFlBQU0sU0FBMkIsQ0FBQztBQUVsQyxlQUFTLElBQUksR0FBRyxJQUFJLGFBQWEsS0FBSztBQUNwQyxjQUFNLFNBQVNBLE1BQUssUUFBUSxxQkFBcUIsSUFBSSxDQUFDO0FBQ3RELFlBQUksV0FBVyxvQkFBb0IsQ0FBQyxHQUFHO0FBRXJDLGlCQUFPLEtBQUssY0FBYyxDQUFDLENBQUU7QUFDN0I7QUFBQSxRQUNGO0FBRUEsY0FBTSwyQkFBMkJBLE1BQUssVUFBVTtBQUVoRCxjQUFNLG1CQUFtQkEsTUFBSyxXQUFXLElBQUksQ0FBQztBQUU5QyxZQUFJLG1CQUFtQjtBQUN2QixZQUFJLE1BQTZCLGFBQWE7QUFDOUMsWUFBSTtBQUNGLGdCQUFNRSxhQUFZRixNQUFLO0FBQUEsWUFDbkI7QUFBQSxZQUFRO0FBQUEsWUFBa0IsbUJBQW1CO0FBQUEsWUFBRyxtQkFBbUI7QUFBQSxZQUFHLG1CQUFtQjtBQUFBLFVBQUU7QUFDL0YsY0FBSUUsZUFBYyxHQUFHO0FBQ25CLDJCQUFlLDRDQUE0QyxDQUFDLEdBQUc7QUFBQSxVQUNqRTtBQUNBLGNBQUksa0JBQWtCLG1CQUFtQjtBQUN6QyxnQkFBTSxXQUFXRixNQUFLLFFBQVEsaUJBQWlCO0FBQy9DLHVCQUFhQSxNQUFLLFFBQVEsaUJBQWlCO0FBQzNDLGdCQUFNLGFBQWFBLE1BQUssUUFBUSxpQkFBaUI7QUFDakQsZ0JBQU0sYUFBYUEsTUFBSyxRQUFRLGlCQUFpQjtBQUNqRCxnQkFBTSxPQUFPLENBQUM7QUFDZCxtQkFBU0csS0FBSSxHQUFHQSxLQUFJLFlBQVlBLE1BQUs7QUFDbkMsaUJBQUssS0FBS0gsTUFBSyxRQUFRLGFBQWEsSUFBSUcsRUFBQyxDQUFDO0FBQUEsVUFDNUM7QUFDQSxVQUFBSCxNQUFLLFNBQVMsVUFBVTtBQUV4QixnQkFBTSxPQUFPLEtBQUssT0FBTyxDQUFDLEdBQUcsTUFBTSxJQUFJLEdBQUcsQ0FBQztBQUMzQyxpQkFBTywyQkFBMkIsUUFBUTtBQUUxQyxnQkFBTSxvQkFBb0IsZ0JBQWdCLHlCQUF5QixjQUFjLENBQUMsQ0FBQztBQUVuRixjQUFJLFNBQVMsVUFBVTtBQUNyQixnQkFBSSxzQkFBc0IsY0FBYztBQUN0QyxvQkFBTSxJQUFJLE1BQU0sd0NBQXdDO0FBQUEsWUFDMUQ7QUFDQSxrQkFBTSxhQUF1QixDQUFDO0FBQzlCLGdCQUFJLFlBQVksYUFBYTtBQUM3QixxQkFBU0csS0FBSSxHQUFHQSxLQUFJLE1BQU1BLE1BQUs7QUFDN0Isb0JBQU0sU0FBU0gsTUFBSyxRQUFRLFdBQVc7QUFDdkMsb0JBQU0saUJBQWlCRyxPQUFNLE9BQU8sSUFBSSxTQUFZSCxNQUFLLFFBQVEsU0FBUyxJQUFJO0FBQzlFLHlCQUFXLEtBQUtBLE1BQUssYUFBYSxRQUFRLGNBQWMsQ0FBQztBQUFBLFlBQzNEO0FBQ0EsbUJBQU8sS0FBSyxDQUFDLE1BQU0sTUFBTSxZQUFZLEtBQUssQ0FBQztBQUFBLFVBQzdDLE9BQU87QUFHTCxnQkFBSSxzQkFBc0IsZ0JBQWdCLE9BQU8sR0FBRztBQUNsRCxvQkFBTSxZQUFZQSxNQUFLLGNBQWMsVUFBVTtBQUMvQyxvQkFBTSxjQUFjLHFCQUFxQixRQUFRO0FBQ2pELGtCQUFJLGdCQUFnQixVQUFhLENBQUMseUJBQXlCLElBQUksR0FBRztBQUNoRSxzQkFBTSxJQUFJLE1BQU0sMEJBQTBCLElBQUksRUFBRTtBQUFBLGNBQ2xEO0FBR0EsaUNBQW1CO0FBRW5CLHFCQUFPLEtBQUs7QUFBQSxnQkFDVjtBQUFBLGdCQUFNO0FBQUEsZ0JBQU07QUFBQSxrQkFDVjtBQUFBLGtCQUNBLFVBQVVBLE1BQUsscUJBQXFCLFdBQVcsT0FBTyxhQUFhLElBQUk7QUFBQSxrQkFDdkUsU0FBUyxNQUFNO0FBQ2Isb0JBQUFBLE1BQUssa0JBQWtCLE1BQU07QUFBQSxrQkFDL0I7QUFBQSxnQkFDRjtBQUFBLGdCQUNBO0FBQUEsY0FDRixDQUFDO0FBQUEsWUFDSCxPQUFPO0FBQ0wsb0JBQU0sd0JBQXdCLGtDQUFrQyxJQUFJO0FBQ3BFLG9CQUFNLE9BQU8sSUFBSSxzQkFBc0IsSUFBSTtBQUMzQyxrQkFBSSxXQUFXLEtBQUssUUFBUSxLQUFLLFlBQVksS0FBSyxVQUFVLEVBQ3ZELElBQUlBLE1BQUssT0FBTyxTQUFTLFlBQVksYUFBYSxLQUFLLFVBQVUsQ0FBQztBQUN2RSxxQkFBTyxLQUFLLENBQUMsTUFBTSxNQUFNLE1BQU0sS0FBSyxDQUFDO0FBQUEsWUFDdkM7QUFBQSxVQUNGO0FBQUEsUUFDRixVQUFFO0FBQ0EsVUFBQUEsTUFBSyxhQUFhLHdCQUF3QjtBQUMxQyxjQUFJLFNBQVMsWUFBWSxZQUFZO0FBQ25DLFlBQUFBLE1BQUssTUFBTSxVQUFVO0FBQUEsVUFDdkI7QUFDQSxjQUFJLENBQUMsa0JBQWtCO0FBQ3JCLFlBQUFBLE1BQUssa0JBQWtCLE1BQU07QUFBQSxVQUMvQjtBQUFBLFFBQ0Y7QUFBQSxNQUNGO0FBRUEsVUFBSSxnQkFBZ0I7QUFDbEIsUUFBQUEsTUFBSyxzQkFBc0IsZUFBZSxNQUFNO0FBQUEsTUFDbEQ7QUFFQSxhQUFPO0FBQUEsSUFDVCxVQUFFO0FBQ0EsTUFBQUEsTUFBSyxhQUFhLGNBQWM7QUFFaEMseUJBQW1CLFFBQVEsT0FBS0EsTUFBSyxrQkFBa0IsQ0FBQyxDQUFDO0FBQ3pELDBCQUFvQixRQUFRLE9BQUtBLE1BQUssa0JBQWtCLENBQUMsQ0FBQztBQUMxRCx3QkFBa0IsUUFBUSxPQUFLQSxNQUFLLE1BQU0sQ0FBQyxDQUFDO0FBRTVDLFVBQUkscUJBQXFCLEdBQUc7QUFDMUIsUUFBQUEsTUFBSyxzQkFBc0IsZ0JBQWdCO0FBQUEsTUFDN0M7QUFDQSx1QkFBaUIsUUFBUSxPQUFLQSxNQUFLLE1BQU0sQ0FBQyxDQUFDO0FBQUEsSUFDN0M7QUFBQSxFQUNGO0FBS08sTUFBTSxlQUFlLENBQUMsY0FBNEI7QUFDdkQsVUFBTUEsUUFBTyxZQUFZO0FBQ3pCLFVBQU0sVUFBVSxlQUFlLElBQUksU0FBUztBQUM1QyxRQUFJLENBQUMsU0FBUztBQUNaLFlBQU0sSUFBSSxNQUFNLG9CQUFvQjtBQUFBLElBQ3RDO0FBQ0EsVUFBTSxnQkFBZ0IsUUFBUSxDQUFDO0FBRy9CLFVBQU0sa0JBQWtCQSxNQUFLLGlCQUFpQixhQUFhO0FBQzNELFFBQUksb0JBQW9CLEdBQUc7QUFDekIscUJBQWUsaUNBQWtDO0FBQUEsSUFDbkQ7QUFDQSxJQUFBQSxNQUFLLFNBQVMsZUFBZTtBQUFBLEVBQy9CO0FBRU8sTUFBTSw2QkFBNkIsQ0FBQyxZQUFzRTtBQUMvRyxVQUFNLFVBQTZCLENBQUM7QUFDcEMsZUFBVyxVQUFVLFNBQVM7QUFDNUIsWUFBTSxPQUFPLE9BQU8sQ0FBQztBQUNyQixVQUFJLENBQUMsTUFBTSxRQUFRLElBQUksS0FBSyxZQUFZLE1BQU07QUFDNUMsZ0JBQVEsS0FBSyxLQUFLLE1BQU07QUFBQSxNQUMxQjtBQUFBLElBQ0Y7QUFDQSxXQUFPO0FBQUEsRUFDVDs7O0FHM2xCQSxPQUFLLFlBQVksQ0FBQyxPQUEyQztBQUMzRCxVQUFNLEVBQUMsTUFBTSxJQUFLLFFBQU8sSUFBSSxHQUFHO0FBQ2hDLFFBQUk7QUFDRixjQUFRLE1BQU07QUFBQSxRQUNaLEtBQUs7QUFDSCxnQ0FBc0IsUUFBUyxJQUFJLEVBQzlCO0FBQUEsWUFDRyxNQUFNO0FBQ0osMEJBQVksT0FBUSxFQUFFO0FBQUEsZ0JBQ2xCLE1BQU07QUFDSiw4QkFBWSxFQUFDLEtBQUksQ0FBQztBQUFBLGdCQUNwQjtBQUFBLGdCQUNBLFNBQU87QUFDTCw4QkFBWSxFQUFDLE1BQU0sSUFBRyxDQUFDO0FBQUEsZ0JBQ3pCO0FBQUEsY0FBQztBQUFBLFlBQ1A7QUFBQSxZQUNBLFNBQU87QUFDTCwwQkFBWSxFQUFDLE1BQU0sSUFBRyxDQUFDO0FBQUEsWUFDekI7QUFBQSxVQUFDO0FBQ1Q7QUFBQSxRQUNGLEtBQUssV0FBVztBQUNkLGdCQUFNLEVBQUMsUUFBUSxLQUFBSSxLQUFHLElBQUk7QUFDdEIsaUJBQU9BLE1BQUssTUFBTSxFQUNiO0FBQUEsWUFDRyxNQUFNO0FBQ0osMEJBQVksRUFBQyxLQUFJLENBQUM7QUFBQSxZQUNwQjtBQUFBLFlBQ0EsU0FBTztBQUNMLDBCQUFZLEVBQUMsTUFBTSxJQUFHLENBQUM7QUFBQSxZQUN6QjtBQUFBLFVBQUM7QUFDVDtBQUFBLFFBQ0Y7QUFBQSxRQUNBLEtBQUssYUFBYTtBQUNoQixnQkFBTSxFQUFDLE9BQU0sSUFBSTtBQUNqQixnQkFBTSxhQUFhLHVCQUF1QixNQUFNO0FBQ2hELHNCQUFZLEVBQUMsTUFBTSxLQUFLLFdBQVUsQ0FBbUI7QUFDckQ7QUFBQSxRQUNGO0FBQUEsUUFDQSxLQUFLLFVBQVU7QUFDYixnQkFBTSxFQUFDLE9BQU8sUUFBTyxJQUFJO0FBQ3pCLHdCQUFjLE9BQU8sT0FBTyxFQUN2QjtBQUFBLFlBQ0cscUJBQW1CO0FBQ2pCLDBCQUFZLEVBQUMsTUFBTSxLQUFLLGdCQUFlLENBQW1CO0FBQUEsWUFDNUQ7QUFBQSxZQUNBLFNBQU87QUFDTCwwQkFBWSxFQUFDLE1BQU0sSUFBRyxDQUFDO0FBQUEsWUFDekI7QUFBQSxVQUFDO0FBQ1Q7QUFBQSxRQUNGO0FBQUEsUUFDQSxLQUFLO0FBQ0gseUJBQWUsT0FBUTtBQUN2QixzQkFBWSxFQUFDLEtBQUksQ0FBQztBQUNsQjtBQUFBLFFBQ0YsS0FBSyxPQUFPO0FBQ1YsZ0JBQU0sRUFBQyxXQUFXLGNBQWMsUUFBUSxlQUFlLFFBQU8sSUFBSTtBQUNsRSxjQUFJLFdBQVcsY0FBYyxRQUFRLGVBQWUsSUFBSSxNQUFNLGNBQWMsTUFBTSxFQUFFLEtBQUssSUFBSSxHQUFHLE9BQU8sRUFDbEc7QUFBQSxZQUNHLGFBQVc7QUFDVCxrQkFBSSxRQUFRLEtBQUssT0FBSyxFQUFFLENBQUMsTUFBTSxLQUFLLEdBQUc7QUFDckMsNEJBQVksRUFBQyxNQUFNLEtBQUssa0RBQWlELENBQUM7QUFBQSxjQUM1RSxPQUFPO0FBQ0w7QUFBQSxrQkFDSSxFQUFDLE1BQU0sS0FBSyxRQUFPO0FBQUEsa0JBQ25CLDJCQUEyQixPQUF1QztBQUFBLGdCQUFDO0FBQUEsY0FDekU7QUFBQSxZQUNGO0FBQUEsWUFDQSxTQUFPO0FBQ0wsMEJBQVksRUFBQyxNQUFNLElBQUcsQ0FBQztBQUFBLFlBQ3pCO0FBQUEsVUFBQztBQUNUO0FBQUEsUUFDRjtBQUFBLFFBQ0EsS0FBSztBQUNILHVCQUFhLE9BQVE7QUFDckIsc0JBQVksRUFBQyxLQUFJLENBQUM7QUFDbEI7QUFBQSxRQUNGO0FBQUEsTUFDRjtBQUFBLElBQ0YsU0FBUyxLQUFLO0FBQ1osa0JBQVksRUFBQyxNQUFNLElBQUcsQ0FBbUI7QUFBQSxJQUMzQztBQUFBLEVBQ0Y7IiwKICAibmFtZXMiOiBbImpvaW4iLCAiZW52IiwgInBhZCIsICJpbml0IiwgIm9mZnNldHMiLCAiaW5kaWNlcyIsICJpbXBsIiwgInZhbGlkYXRlSW5wdXRzIiwgInJlZHVjZU9wcyIsICJ2YWxpZGF0ZUlucHV0cyIsICJ2YWxpZGF0ZUlucHV0cyIsICJlbnYiLCAidmFsaWRhdGVJbnB1dHMiLCAidmFsaWRhdGVJbnB1dHMiLCAiYSIsICJiIiwgInZhbGlkYXRlSW5wdXRzIiwgInRyYW5zcG9zZSIsICJvdXRwdXRWYXJpYWJsZSIsICJpbm5lckVsZW1lbnRTaXplIiwgInZhbGlkYXRlSW5wdXRzIiwgInZhbGlkYXRlSW5wdXRzIiwgIm91dHB1dFNoYXBlIiwgInRyYW5zcG9zZWRXZWlnaHQiLCAiY29udklucHV0cyIsICJpbm5lckVsZW1lbnRTaXplIiwgInZhbGlkYXRlSW5wdXRzIiwgInN5bWJvbCIsICJyZWR1Y2VPcHMiLCAidmFsaWRhdGVJbnB1dHMiLCAiY2FsY3VsYXRlT3V0cHV0U2hhcGUiLCAidmFsaWRhdGVJbnB1dHMiLCAidmFsaWRhdGVJbnB1dHMiLCAidmFsaWRhdGVJbnB1dHMiLCAidmFsaWRhdGVJbnB1dHMiLCAidmFsaWRhdGVJbnB1dHMiLCAid2VpZ2h0VHJhbnNwb3NlQXR0cmlidXRlIiwgInZhbGlkYXRlSW5wdXRzIiwgInZhbGlkYXRlSW5wdXRzIiwgImVudiIsICJlbnYiLCAidmFsaWRhdGVJbnB1dHMiLCAidmFsaWRhdGVJbnB1dHMiLCAidmFsaWRhdGVJbnB1dHMiLCAidmFsaWRhdGVJbnB1dHMiLCAiY29tcG9uZW50cyIsICJ2YWxpZGF0ZUlucHV0cyIsICJ2YWxpZGF0ZUlucHV0cyIsICJnZXRPdXRwdXRTaGFwZSIsICJhIiwgImIiLCAiYyIsICJlbnYiLCAiaSIsICJlbnYiLCAid2FzbSIsICJ3YXNtIiwgIndhc20iLCAicmVhZEZpbGUiLCAicmVhZEZpbGUiLCAiZW52IiwgIndhc20iLCAidGVuc29yIiwgImVycm9yQ29kZSIsICJpIiwgImVudiJdCn0K\n'}}),isProxy,proxyWorker,initializing2,initialized2,aborted2,initWasmCallbacks,queuedCallbacks,enqueueCallbacks,ensureWorker,onProxyWorkerMessage,scriptSrc,initializeWebAssemblyAndOrtRuntime,initializeOrtEp,copyFromExternalBuffer2,createSession2,releaseSession2,run2,endProfiling2,init_proxy_wrapper=__esm({"web/lib/wasm/proxy-wrapper.ts"(){init_esm(),init_wasm_core_impl(),init_wasm_factory(),isProxy=()=>!!env2.wasm.proxy&&"undefined"!=typeof document,initializing2=!1,initialized2=!1,aborted2=!1,queuedCallbacks=new Map,enqueueCallbacks=(t,e)=>{const n=queuedCallbacks.get(t);n?n.push(e):queuedCallbacks.set(t,[e])},ensureWorker=()=>{if(initializing2||!initialized2||aborted2||!proxyWorker)throw new Error("worker not ready")},onProxyWorkerMessage=t=>{switch(t.data.type){case"init-wasm":initializing2=!1,t.data.err?(aborted2=!0,initWasmCallbacks[1](t.data.err)):(initialized2=!0,initWasmCallbacks[0]());break;case"init-ep":case"copy-from":case"create":case"release":case"run":case"end-profiling":{const e=queuedCallbacks.get(t.data.type);t.data.err?e.shift()[1](t.data.err):e.shift()[0](t.data.out);break}}},scriptSrc="undefined"!=typeof document?document?.currentScript?.src:void 0,initializeWebAssemblyAndOrtRuntime=async()=>{if(!initialized2){if(initializing2)throw new Error("multiple calls to 'initWasm()' detected.");if(aborted2)throw new Error("previous call to 'initWasm()' failed.");if(initializing2=!0,isProxy())return void 0===env2.wasm.wasmPaths&&scriptSrc&&0!==scriptSrc.indexOf("blob:")&&(env2.wasm.wasmPaths=scriptSrc.substr(0,+scriptSrc.lastIndexOf("/")+1)),new Promise(((t,e)=>{proxyWorker?.terminate();const n=URL.createObjectURL(new Blob([require_main()],{type:"text/javascript"}));(proxyWorker=new Worker(n,{name:"ort-wasm-proxy-worker"})).onerror=t=>e(t),proxyWorker.onmessage=onProxyWorkerMessage,URL.revokeObjectURL(n),initWasmCallbacks=[t,e];const B={type:"init-wasm",in:env2};proxyWorker.postMessage(B)}));try{await initializeWebAssembly(env2.wasm),await initRuntime(env2),initialized2=!0}catch(t){throw aborted2=!0,t}finally{initializing2=!1}}},initializeOrtEp=async t=>{if(isProxy())return ensureWorker(),new Promise(((e,n)=>{enqueueCallbacks("init-ep",[e,n]);const B={type:"init-ep",in:{epName:t,env:env2}};proxyWorker.postMessage(B)}));await initEp(env2,t)},copyFromExternalBuffer2=async t=>isProxy()?(ensureWorker(),new Promise(((e,n)=>{enqueueCallbacks("copy-from",[e,n]);const B={type:"copy-from",in:{buffer:t}};proxyWorker.postMessage(B,[t.buffer])}))):copyFromExternalBuffer(t),createSession2=async(t,e)=>{if(isProxy()){if(e?.preferredOutputLocation)throw new Error('session option "preferredOutputLocation" is not supported for proxy.');return ensureWorker(),new Promise(((n,B)=>{enqueueCallbacks("create",[n,B]);const s={type:"create",in:{model:t,options:e}},F=[];t instanceof Uint8Array&&F.push(t.buffer),proxyWorker.postMessage(s,F)}))}return createSession(t,e)},releaseSession2=async t=>{if(isProxy())return ensureWorker(),new Promise(((e,n)=>{enqueueCallbacks("release",[e,n]);const B={type:"release",in:t};proxyWorker.postMessage(B)}));releaseSession(t)},run2=async(t,e,n,B,s,F)=>{if(isProxy()){if(n.some((t=>"cpu"!==t[3])))throw new Error("input tensor on GPU is not supported for proxy.");if(s.some((t=>t)))throw new Error("pre-allocated output tensor is not supported for proxy.");return ensureWorker(),new Promise(((s,Q)=>{enqueueCallbacks("run",[s,Q]);const U=n,i={type:"run",in:{sessionId:t,inputIndices:e,inputs:U,outputIndices:B,options:F}};proxyWorker.postMessage(i,extractTransferableBuffers(U))}))}return run(t,e,n,B,s,F)},endProfiling2=async t=>{if(isProxy())return ensureWorker(),new Promise(((e,n)=>{enqueueCallbacks("end-profiling",[e,n]);const B={type:"end-profiling",in:t};proxyWorker.postMessage(B)}));endProfiling(t)}}}),encodeTensorMetadata,decodeTensorMetadata,OnnxruntimeWebAssemblySessionHandler,init_session_handler_inference2=__esm({"web/lib/wasm/session-handler-inference.ts"(){init_esm(),init_proxy_wrapper(),init_wasm_common(),init_wasm_utils_load_file(),encodeTensorMetadata=(t,e)=>{switch(t.location){case"cpu":return[t.type,t.dims,t.data,"cpu"];case"gpu-buffer":return[t.type,t.dims,{gpuBuffer:t.gpuBuffer},"gpu-buffer"];default:throw new Error(`invalid data location: ${t.location} for ${e()}`)}},decodeTensorMetadata=t=>{switch(t[3]){case"cpu":return new Tensor2(t[0],t[2],t[1]);case"gpu-buffer":{const e=t[0];if(!isGpuBufferSupportedType(e))throw new Error(`not supported data type: ${e} for deserializing GPU tensor`);const{gpuBuffer:n,download:B,dispose:s}=t[2];return Tensor2.fromGpuBuffer(n,{dataType:e,dims:t[1],download:B,dispose:s})}default:throw new Error(`invalid data location: ${t[3]}`)}},OnnxruntimeWebAssemblySessionHandler=class{async fetchModelAndCopyToWasmMemory(t){return copyFromExternalBuffer2(await loadFile(t))}async loadModel(t,e){let n;TRACE_FUNC_BEGIN(),n="string"==typeof t?"undefined"!=typeof process&&process.versions&&process.versions.node?await loadFile(t):await this.fetchModelAndCopyToWasmMemory(t):t,[this.sessionId,this.inputNames,this.outputNames]=await createSession2(n,e),TRACE_FUNC_END()}async dispose(){return releaseSession2(this.sessionId)}async run(t,e,n){TRACE_FUNC_BEGIN();const B=[],s=[];Object.entries(t).forEach((t=>{const e=t[0],n=t[1],F=this.inputNames.indexOf(e);if(-1===F)throw new Error(`invalid input '${e}'`);B.push(n),s.push(F)}));const F=[],Q=[];Object.entries(e).forEach((t=>{const e=t[0],n=t[1],B=this.outputNames.indexOf(e);if(-1===B)throw new Error(`invalid output '${e}'`);F.push(n),Q.push(B)}));const U=B.map(((t,e)=>encodeTensorMetadata(t,(()=>`input "${this.inputNames[s[e]]}"`)))),i=F.map(((t,e)=>t?encodeTensorMetadata(t,(()=>`output "${this.outputNames[Q[e]]}"`)):null)),a=await run2(this.sessionId,s,U,Q,i,n),l={};for(let t=0;t<a.length;t++)l[this.outputNames[Q[t]]]=F[t]??decodeTensorMetadata(a[t]);return TRACE_FUNC_END(),l}startProfiling(){}endProfiling(){endProfiling2(this.sessionId)}}}}),initializeFlags,OnnxruntimeWebAssemblyBackend,init_backend_wasm=__esm({"web/lib/backend-wasm.ts"(){init_node_os(),init_esm(),init_proxy_wrapper(),init_session_handler_inference2(),initializeFlags=()=>{if(("number"!=typeof env2.wasm.initTimeout||env2.wasm.initTimeout<0)&&(env2.wasm.initTimeout=0),"boolean"!=typeof env2.wasm.simd&&(env2.wasm.simd=!0),"boolean"!=typeof env2.wasm.proxy&&(env2.wasm.proxy=!1),"boolean"!=typeof env2.wasm.trace&&(env2.wasm.trace=!1),"number"!=typeof env2.wasm.numThreads||!Number.isInteger(env2.wasm.numThreads)||env2.wasm.numThreads<=0){("undefined"!=typeof self&&!self.crossOriginIsolated||"undefined"!=typeof process&&process.versions&&process.versions.node)&&(env2.wasm.numThreads=1);const t="undefined"==typeof navigator?cpus().length:navigator.hardwareConcurrency;env2.wasm.numThreads=Math.min(4,Math.ceil((t||1)/2))}},OnnxruntimeWebAssemblyBackend=class{async init(t){initializeFlags(),await initializeWebAssemblyAndOrtRuntime(),await initializeOrtEp(t)}async createInferenceSessionHandler(t,e){const n=new OnnxruntimeWebAssemblySessionHandler;return await n.loadModel(t,e),Promise.resolve(n)}}}}),backend_wasm_inference_exports={},wasmBackend;__export(backend_wasm_inference_exports,{wasmBackend:()=>wasmBackend});var init_backend_wasm_inference=__esm({"web/lib/backend-wasm-inference.ts"(){init_backend_wasm(),wasmBackend=new OnnxruntimeWebAssemblyBackend}}),lib_exports={};__export(lib_exports,{InferenceSession:()=>InferenceSession2,TRACE:()=>TRACE,TRACE_FUNC_BEGIN:()=>TRACE_FUNC_BEGIN,TRACE_FUNC_END:()=>TRACE_FUNC_END,Tensor:()=>Tensor2,TrainingSession:()=>TrainingSession2,default:()=>lib_default,env:()=>env2,registerBackend:()=>registerBackend}),init_esm(),init_esm(),init_esm();var version2="1.17.1",lib_default=esm_exports;{const t=(init_backend_onnxjs(),__toCommonJS(backend_onnxjs_exports)).onnxjsBackend;registerBackend("webgl",t,-10)}{const t=(init_backend_wasm_inference(),__toCommonJS(backend_wasm_inference_exports)).wasmBackend;registerBackend("webgpu",t,5),registerBackend("cpu",t,10),registerBackend("wasm",t,10),registerBackend("webnn",t,9)}return Object.defineProperty(env2.versions,"web",{value:version2,enumerable:!0}),__toCommonJS(lib_exports)})();