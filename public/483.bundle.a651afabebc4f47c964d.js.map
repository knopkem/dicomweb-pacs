{"version":3,"file":"483.bundle.a651afabebc4f47c964d.js","mappings":"2IAIA,MAAMA,EAAmB,mBA4CzB,SAASC,EAAWC,EAAYC,GAE9B,GAAK,KAAMC,aAAaF,GAIxB,OAAI,KAAME,aAAaF,GAAYC,GAC1B,KAAMC,aAAaF,GAAYC,GAAUE,YADlD,CAGF,CAEA,SAASC,EAAWC,EAAiBL,EAAYM,EAASL,GAExD,IAAK,KAAMC,aAAaF,GACtB,OAAO,KAGT,KAAME,aAAaF,GAAYC,GAAY,CACzCM,SAAS,EACTJ,OAAQG,GAGVD,EAAgBG,YAAYF,EAC9B,CAEA,SAASG,EAAeT,EAAYC,GAE7B,KAAMC,aAAaF,IAIpB,KAAME,aAAaF,GAAYC,KACjC,KAAMC,aAAaF,GAAYC,GAAUM,SAAU,EAEvD,CAEA,SAASG,EAAeL,EAAiBL,GAElC,KAAME,aAAaF,IAIxBW,OAAOC,KAAK,KAAMV,aAAaF,IAAaa,SAASZ,IACnD,MAAMa,EAAa,KAAMZ,aAAaF,GAAYC,IAE7Ca,EAAWP,SAAWO,EAAWX,SACpCE,EAAgBU,YAAYD,EAAWX,eAChC,KAAMD,aAAaF,GAAYC,G,GAG5C,CAEA,QAzFA,SAA6Be,GAC3B,MAAMC,GAAiB,IAAAC,mBAAkBF,IACnC,WAAEG,EAAU,kBAAEC,GAAsBH,EACpCjB,EAAa,GAAGmB,KAAcC,IAC9Bf,EAsBR,SAAsBW,GACpB,MAAMK,EAAkB,IAAIvB,IACtBwB,EAAqBN,EAAQO,cAAcF,GAMjD,OAFiBC,EAAmBC,cAAc,sBAGpD,CA/B0BC,CAAaR,GAOrC,OAJAL,OAAOC,KAAK,KAAMV,aAAaF,IAAaa,SAASZ,IACnD,KAAMC,aAAaF,GAAYC,GAAUM,SAAU,CAAK,IAGnD,CACLF,gBAAiBA,EACjBoB,sBAAuB,KAAMvB,aAC7BH,WAAYA,EAAW2B,KAAKC,KAAM3B,GAClCI,WAAYA,EAAWsB,KAAKC,KAAMtB,EAAiBL,GACnDS,eAAgBA,EAAeiB,KAAKC,KAAM3B,GAC1CU,eAAgBA,EAAegB,KAAKC,KAAMtB,EAAiBL,GAE/D,ECfA,QAbA,SACEgB,EACAY,GAEA,MAAMC,EAAmB,EAAoBb,GAG7CY,EAAGC,GAGHA,EAAiBnB,gBACnB,C,+BCVA,IAAKoB,E,iBAAL,SAAKA,GAQH,kBAMA,oBAKA,oBAKA,qBACD,CAzBD,CAAKA,IAAAA,EAAS,KA2Bd,S,mJCAA,MAAM,OAAEC,EAAM,QAAEC,EAAO,QAAEC,EAAO,SAAEC,GAAa,EAAAJ,UAEzCK,EAAmB,CAAC,CAAEC,YAAa,EAAAC,cAAcC,UAcxC,MAAMC,EAYnB,WAAAC,CAAYC,GAVZ,KAAAC,cAAgB,GAChB,KAAAC,YAAc,CAAC,EACf,KAAAC,6BAA8C,KAC9C,KAAAC,0BAA2C,KAI3C,KAAAC,mBAAqB,CAAC,EACtB,KAAAC,eAAiB,CAAC,EAGhBpB,KAAKc,GAAKA,CACZ,CAMA,cAAAO,GACE,OAAOrB,KAAKe,cAAcO,KAAI,EAAG9B,gBAAiBA,GACpD,CAKA,gBAAA+B,GACE,OAAOvB,KAAKe,cAAcS,OAC5B,CAOO,eAAAC,CAAgBC,GACrB,MAAMC,EAAe3B,KAAKoB,eAAeM,GACzC,GAAKC,EAOL,OAAOA,EANLC,QAAQC,KACN,IAAIH,6CAA4D1B,KAAKc,OAM3E,CAOO,gBAAAgB,GACL,OAAO9B,KAAKoB,cACd,CAOA,OAAAW,CAAQC,GACN,QAAShC,KAAKoB,eAAeY,EAC/B,CAWA,OAAAC,CAAQD,EAAkBE,EAAmC,CAAC,GAC5D,MAAMC,EAAiB,KAAMC,MAAMJ,GAC7BK,OAAkC,IAAbL,GAAyC,KAAbA,EACjDM,EAAoBtC,KAAKgB,YAAYgB,GAE3C,IAAKK,EAKH,YAJAT,QAAQC,KACN,uDACAK,GAKJ,IAAKC,EAIH,YAHAP,QAAQC,KACN,IAAIG,mGAKR,GAAIM,EAIF,YAHAV,QAAQC,KACN,IAAIG,0CAAiDhC,KAAKc,OAO9D,MAAQyB,UAAWC,GAAcL,EAQ3BM,EAAmB,IAAID,EANX,CAChBE,KAAMV,EACNW,YAAa3C,KAAKc,GAClBoB,kBAOFlC,KAAKoB,eAAeY,GAAYS,CAClC,CAEO,eAAAG,CACLZ,EACAa,EACAX,EAAgB,CAAC,GAEjB,IAAIY,EAAiB,KAAMV,MAAMJ,IAC7BO,UAEJ,IAAKO,EAAgB,CAEnB,MAAMC,EAAc,KAAMX,MAAMS,GAC7BN,UAIH,MAAMS,UAAqBD,GAE3BC,EAAahB,SAAWA,EAExBc,EAAiBE,EAEjB,KAAMZ,MAAMJ,GAAY,CACtBO,UAAWS,E,CAMfhD,KAAKiC,QAAQa,EAAed,SAAUE,EACxC,CAeO,WAAAe,CAAYzD,EAAoBC,GACrC,GAA0B,iBAAfD,EACT,MAAM,IAAI0D,MAAM,8CAGlB,MAAMC,GAAmB,IAAAC,uBAEzB,IAAK3D,GAAqB0D,EAAiBE,OAAS,EAClD,MAAM,IAAIH,MACR,mFAIJ,MAAMI,EAA0B7D,GAAqB0D,EAAiB,GAAGrC,GAItEd,KAAKe,cAAcwC,MAAK,EAAG/D,WAAYgE,KAAWA,IAAShE,KAE5DQ,KAAKe,cAAc0C,KAAK,CACtBjE,aACAC,kBAAmB6D,IAKvB,MAAMtB,EAAWhC,KAAK0D,kCAEE,EAAAC,SAASC,qBACbC,IAAI,eACtB7D,KAAK8D,6BAA6B9B,GAGpC,MAAM+B,EAAc,CAClBpB,YAAa3C,KAAKc,GAClBtB,aACAC,kBAAmB6D,IAGrB,IAAAU,cAAa,EAAAC,YAAa,EAAAC,OAAOC,yBAA0BJ,EAC7D,CAUO,eAAAK,CAAgB3E,EAA2BD,GAChD,MAAM6E,EAAU,GAgBhB,GAdArE,KAAKe,cAAc7B,SAAQ,CAACoF,EAAQC,KAClC,IAAIC,GAAQ,EACRF,EAAO7E,oBAAsBA,IAC/B+E,GAAQ,EAEJhF,GAAc8E,EAAO9E,aAAeA,IACtCgF,GAAQ,IAGRA,GACFH,EAAQZ,KAAKc,E,IAIbF,EAAQhB,OAGV,IAAK,IAAIoB,EAAIJ,EAAQhB,OAAS,EAAGoB,GAAK,EAAGA,IACvCzE,KAAKe,cAAc2D,OAAOL,EAAQI,GAAI,GAI1C,MAAMV,EAAc,CAClBpB,YAAa3C,KAAKc,GAClBtB,aACAC,sBAGF,IAAAuE,cAAa,EAAAC,YAAa,EAAAC,OAAOS,2BAA4BZ,EAC/D,CAEO,iBAAAa,CAAkB5C,EAAkB6C,GACzC,MAAMlD,EAAe3B,KAAKoB,eAAeY,QAEpB8C,IAAjBnD,EAQJA,EAAaiD,kBAAkBC,GAP7BjD,QAAQC,KACN,QAAQG,0DAOd,CAEA,WAAA+C,CACE/C,EACAgD,EACAC,EAAU,CAAC,GAENjD,EAKDgD,IAAS,EAAA7E,UAAUC,OAQnB4E,IAAS,EAAA7E,UAAUE,QAKnB2E,IAAS,EAAA7E,UAAUG,QAKnB0E,IAAS,EAAA7E,UAAUI,SAKvBqB,QAAQC,KAAK,qCAJX7B,KAAKkF,gBAAgBlD,GALrBhC,KAAKmF,eAAenD,GALpBhC,KAAKoF,eAAepD,GARpBhC,KAAKqF,cACHrD,EACAiD,GAAWjF,KAAKmB,mBAAmBa,IAPrCJ,QAAQC,KAAK,wCA4BjB,CAcO,aAAAwD,CACLrD,EACAsD,EAAsB,CAAC,GAEvB,MAAM3D,EAAe3B,KAAKoB,eAAeY,GAEzC,QAAqB8C,IAAjBnD,EAKF,YAJAC,QAAQC,KACN,QAAQG,kDAMZ,IAAKL,EAIH,YAHAC,QAAQC,KACN,IAAIG,eAAsBL,iEAK9B,MA4BMX,EAA+B,CACnCuE,SAlBoB,IAXevF,KAAKgB,YAAYgB,GAClDhC,KAAKgB,YAAYgB,GAAUuD,SAC3B,MAEgBD,EAAoBC,SACpCD,EAAoBC,SACpB,IAKoDC,QACtD,CAACC,EAAQC,KACP,MAAMC,OAA0Cb,IAA3BY,EAAQE,eACvBC,OAAuCf,IAAxBY,EAAQjF,YAQ7B,OALGgF,EAAOlC,MAAMuC,GAAQC,EAAeD,EAAKJ,OACzCC,IAAgBE,GAEjBJ,EAAOhC,KAAKiC,GAEPD,CAAM,GAEf,IAMAT,KAAM5E,GAGRJ,KAAKgB,YAAYgB,GAAYhB,EAC7BhB,KAAKoB,eAAeY,GAAUgD,KAAO5E,EAGrC,MACM4F,EADkB,EAAArC,SAASC,qBACCC,IAAI,cAEtC,GAAI7D,KAAKiG,8BAA8BX,IAAwBU,EAC7DhG,KAAK8D,6BAA6B9B,OAC7B,CAGL,IAD6BhC,KAAK0D,mCACLsC,EAAW,CACtC,MAAME,EAAS,EAAAC,YAAYC,iBAAiB,WAC5CpG,KAAKqG,uBAAuBH,E,EAM5BlG,KAAKiG,8BAA8BX,KACE,OAAnCtF,KAAKkB,0BACPlB,KAAKkB,0BAA4Bc,EAEjChC,KAAKkB,0BAA4BlB,KAAKiB,6BAGxCjB,KAAKiB,6BAA+Be,GAGM,mBAAjCL,EAAa2E,iBACtB3E,EAAa2E,kBAEftG,KAAKuG,mBAEL,MAAMxC,EAAwC,CAC5CpB,YAAa3C,KAAKc,GAClBkB,WACAsD,wBAGF,IAAAtB,cAAa,EAAAC,YAAa,EAAAC,OAAOsC,eAAgBzC,GACjD/D,KAAKyG,6BAA6BzE,EAAU5B,EAAQkF,EACtD,CAaO,cAAAF,CACLpD,EACAiD,GAEA,MAAMtD,EAAe3B,KAAKoB,eAAeY,GAEzC,QAAqB8C,IAAjBnD,EAKF,YAJAC,QAAQC,KACN,QAAQG,kDAQZ,MAAM0E,EAAkB1G,KAAK2G,eAAe3E,GACtChB,EAAchC,OAAO4H,OACzB,CACErB,SAAUmB,EAAkBA,EAAgBnB,SAAW,IAEzDmB,EACA,CACE1B,KAAM3E,IAIJwG,EAAgBC,MAAMC,QAAQ9B,GAAS+B,mBACzC/B,EAAQ+B,kBACRhH,KAAKiH,4BAGTjG,EAAYuE,SAAWvE,EAAYuE,SAAS2B,QACzCxB,IACgC,IAA/BT,GAAS+B,oBACRH,EAActD,MAAM4D,GACnBpB,EAAeL,EAASyB,OAK9B,IAAInC,EAAO3E,EACyB,IAAhCW,EAAYuE,SAASlC,SACvB2B,EAAO5E,EACPY,EAAYgE,KAAOA,GAGrBhF,KAAKgB,YAAYgB,GAAYhB,EAC7BW,EAAaqD,KAAOA,EAEyB,mBAAlCrD,EAAayF,kBACtBzF,EAAayF,mBAEfpH,KAAKuG,mBAOLvG,KAAKyG,6BAA6BzE,EAAU3B,EAC9C,CASO,cAAA8E,CAAenD,GACpB,MAAML,EAAe3B,KAAKoB,eAAeY,GAEzC,QAAqB8C,IAAjBnD,EAKF,YAJAC,QAAQC,KACN,QAAQG,kDAMZ,MAAMhB,EAAc,CAClBuE,SAAU,GACVP,KAAM1E,GAGRN,KAAKgB,YAAYgB,GAAYhB,EAC7BW,EAAaqD,KAAO1E,EAEyB,mBAAlCqB,EAAa0F,kBACtB1F,EAAa0F,mBAGfrH,KAAKuG,mBACLvG,KAAKyG,6BAA6BzE,EAAU1B,EAC9C,CASO,eAAA4E,CAAgBlD,GACrB,MAAML,EAAe3B,KAAKoB,eAAeY,GAEzC,QAAqB8C,IAAjBnD,EAKF,YAJAC,QAAQC,KACN,QAAQG,kDAMZ,MAAMhB,EAAc,CAClBuE,SAAU,GACVP,KAAMzE,GAGRP,KAAKmB,mBAAmBa,GAAYhC,KAAKgB,YAAYgB,GAErDhC,KAAKgB,YAAYgB,GAAYhB,EAC7BW,EAAaqD,KAAOzE,EAE0B,mBAAnCoB,EAAa2F,mBACtB3F,EAAa2F,oBAEftH,KAAKuG,mBACLvG,KAAKyG,6BAA6BzE,EAAUzB,EAC9C,CAOO,cAAAoG,CAAe3E,GACpB,MAAMuF,EAAqBvH,KAAKgB,YAAYgB,GAE5C,QAA2B8C,IAAvByC,EAIJ,OAAOA,CACT,CAQO,+BAAA7D,GACL,OAAO1E,OAAOC,KAAKe,KAAKgB,aAAawG,MAAMxF,IACzC,MAAMhB,EAAchB,KAAKgB,YAAYgB,GACrC,OACEhB,EAAYgE,OAAS5E,GACrBJ,KAAKiG,8BAA8BjF,EACpC,GAEL,CAEO,4BAAA8C,CACL9B,EACA6C,GAEA,MAAMqB,EAASlG,KAAKyH,WAAWzF,EAAU6C,GAEzC7E,KAAKqG,uBAAuBH,EAC9B,CAEQ,UAAAuB,CAAWzF,EAAkB6C,GACnC,IAAI6C,EACAxB,EAEJ,OAAIrB,IAGF6C,EAAa,GAAG1F,KAAY6C,IAE5BqB,EAAS,EAAAyB,eAAevB,iBAAiBsB,GAAY,GAEjDxB,GACKA,GAKXwB,EAAa,GAAG1F,IAEhBkE,EAAS,EAAAyB,eAAevB,iBAAiBsB,GAAY,GAEjDxB,IAKJwB,EAAa1F,EAEbkE,EAAS,EAAAyB,eAAevB,iBAAiBsB,GAAY,GAEjDxB,GAIG,EAAAC,YAAYC,iBAAiB,YACtC,CAEA,sBAAAC,CAAuBH,GACrBlG,KAAKe,cAAc7B,SAAQ,EAAGO,oBAAmBD,iBAC/C,MAAMF,GAAiB,IAAAsI,wBACrBpI,EACAC,GAGF,IAAKH,EACH,OAGF,MAAM,SAAEuI,GAAavI,GACrB,IAAAwI,mBAAkBD,EAASxI,QAAS6G,EAAO,GAE/C,CAMO,oBAAA6B,CACL/F,EACAE,EACA8F,GAEA,MAAMrG,EAAe3B,KAAKoB,eAAeY,GACzC,QAAqB8C,IAAjBnD,EAIF,OAHAC,QAAQC,KACN,QAAQG,iDAEH,EAGT,IAAIiG,EAmBJ,OAhBEA,EADED,EACe9F,EAKAlD,OAAO4H,OAAOjF,EAAaO,cAAeA,GAG7DP,EAAaO,cAAgB+F,EAEsB,mBAAxCtG,EAAauG,wBACtBvG,EAAauG,yBAGflI,KAAKuG,oBAEE,CACT,CAKO,sBAAA4B,GACL,OAAO,EAAAzH,cAAcC,OACvB,CAOO,yBAAAsG,GACL,OAAOzG,CACT,CAUA,oBAAA4H,CAAqBpG,EAAkBqG,GACrC,QAAsCvD,IAAlC9E,KAAKoB,eAAeY,GAItB,YAHAJ,QAAQC,KACN,QAAQG,gDAKZ,MAAMiG,EACJ,IAAIjI,KAAKoB,eAAeY,GAAUE,cAAemG,IACjDrI,KAAKoB,eAAeY,GAAUE,cAEhC,OAAO,IAAU+F,EACnB,CAMO,4BAAAK,GACL,OAAOtI,KAAKkB,yBACd,CAUO,KAAAqH,CACLC,EACAC,EAA2C,MAE3C,IAAIC,EAAY,kBAA8BF,GAE9C,OAAIE,GACF9G,QAAQC,KAAK,aAAa2G,oBACnBE,IAGTA,EAAY,qBAAiCF,GAC7CC,EAAeA,GAAgB,MAAO,GAEtCzJ,OAAOC,KAAKe,KAAKoB,gBACd8F,OAAOuB,GACPvJ,SAAS8C,IACR,MAAM2G,EAAqB3I,KAAKoB,eAAeY,GACzC4G,EAAoB5I,KAAKgB,YAAYgB,GACrC6G,EAAiBF,EAAmB3D,KAE1C0D,EAAUzG,QAAQD,GAEjB0G,EAAmC3D,YAClC/C,EACA6G,EACA,CACEtD,SAAUqD,EAAkBrD,UAAY,IAE3C,IAGEmD,EACT,CAOQ,6BAAAzC,CAA8BjF,GACpC,MAAM8H,EAAkB9I,KAAKiH,4BAC7B,OAAOjG,GAAauE,UAAUhC,MAAMmC,GAClCoD,EAAgBvF,MAAMwF,GAAYhD,EAAeL,EAASqD,MAE9D,CAKQ,gBAAAxC,GACNvG,KAAKe,cAAc7B,SAAQ,EAAGO,oBAAmBD,kBAC/C,IAAAwJ,oBAAmBvJ,GAAmBwJ,eAAezJ,EAAW,GAEpE,CAQQ,4BAAAiH,CACNzE,EACAgD,EACAM,GAEA,MAAMvB,EAA0C,CAC9CpB,YAAa3C,KAAKc,GAClBkB,WACAgD,OACAM,wBAGF,IAAAtB,cAAa,EAAAC,YAAa,EAAAC,OAAOgF,kBAAmBnF,EACtD,EAMF,SAASgC,EACPoD,EACAC,GAEA,OAAID,EAAS1I,cAAgB2I,EAAS3I,cAGlC0I,EAASvD,iBAAmBwD,EAASxD,gBAIlCuD,EAASE,cAAgBD,EAASC,YAC3C,CC70BA,QApBA,SAAyB1G,GAMvB,GAJ8B,KAAM2G,WAAW/F,MAC5CgG,GAAOA,EAAGzI,KAAO6B,IAKlB,YADAf,QAAQC,KAAK,IAAIc,sBAInB,MAAM+F,EAAY,IAAI9H,EAAU+B,GAMhC,OAHA,KAAM2G,WAAW7F,KAAKiF,GAGfA,CACT,C,wECPA,QAVA,WACE,MAAMY,EAAa,IAAI,KAAaA,YAEpC,IAAK,MAAMZ,KAAaY,GACtB,OAAiBZ,EAAU5H,IAG7B,KAAawI,WAAa,EAC5B,C,qFCIA,QAbA,SAA0B3G,GACxB,MAAM6G,EAAiB,KAAMF,WAAWG,WACrCF,GAAOA,EAAGzI,KAAO6B,IAGhB6G,GAAkB,IACpB,KAA4BE,gBAAgB/G,IAE5C,IAAAgH,kCAAiChH,GACjC,KAAM2G,WAAW5E,OAAO8E,EAAgB,GAE5C,C,8DCZA,QAJA,WACE,OAAO,KAAMF,UACf,C,+DCIA,QAJA,SAAsB3G,GACpB,OAAO,KAAM2G,WAAW9B,MAAMoC,GAAMA,EAAE9I,KAAO6B,GAC/C,C,0ECPA,MAAMkH,EAAQ,CAAC,EAAA1J,UAAUC,OAAQ,EAAAD,UAAUE,QAAS,EAAAF,UAAUG,SA8B9D,QAtBA,SAAmC0B,GACjC,OAAO,KAAMsH,WAAWpC,QAAO,EAAGlG,kBAChC,MAAM8I,EAAqB9K,OAAOC,KAAK+B,GAEvC,IAAK,IAAIyD,EAAI,EAAGA,EAAIqF,EAAmBzG,OAAQoB,IAC7C,GAAIzC,IAAa8H,EAAmBrF,IAK/BzD,EAAYgB,IAIb6H,EAAME,SAAS/I,EAAYgB,GAAUgD,MACvC,OAAO,EAGX,OAAO,CAAK,GAEhB,C,gVCgBA,MAAM,sBAAEgF,GAA0B,EAAAC,UAC5B,QAAEC,GAAY,EAAAC,UAEdC,EAAqB,EAAIF,EAgE/B,MAAMG,UAA8B,IAyDlC,WAAAxJ,CACEyJ,EAA6B,CAAC,EAC9BC,EAA8B,CAC5BC,0BAA2B,CAAC,QAAS,SACrCtI,cAAe,CACbuI,QAAQ,EACRC,2BAA2B,EAK3BC,+BAAgC,EAAAC,iBAAiBC,MACjDC,+BAAgC,CAG9BC,SAAS,EAETC,OAAQ,GAEVC,mBAAmB,EAEnBC,sBAAuB,GAGvBC,iCAAkC,EAIlCC,eAAe,EAOfC,mBAAoB,EAMpBC,UAAW,CACTC,aAAa,EACbC,cAAc,EACdC,0BAA2B,GAC3BC,2BAA4B,IAS9BC,cAAe,CACbZ,SAAS,EAGTa,wBAAyB,MAM3BC,SAAU,CACRd,SAAS,EAKTe,QAAS,IAEXC,gBAAgB,EAChBC,aAAcC,EACdC,gBAAiB,EAAAC,wBAIrBC,MAAM9B,EAAWC,GAhInB,KAAA8B,WAAY,EACZ,KAAAC,iBAAkB,EAClB,KAAAC,eAAgB,EAuJhB,KAAAC,iBACEC,IAEA,MAAM1I,EAAc0I,EAAIC,QAClB,QAAErN,GAAY0E,EACdzE,GAAiB,IAAAC,mBAAkBF,IACnC,gBAAEsN,GAAoBrN,EAEtBsN,EAAa5M,KAAK6M,iBACtBJ,GAGFzM,KAAK8M,cAAcF,EAAYvN,GAE/B,MAAM0N,GAAsB,IAAAC,gCAC1B3N,EACAW,KAAKiN,eASP,OANAjN,KAAKkN,aAAaT,EAAKG,EAAYG,GAEnCN,EAAIU,kBAEJ,OAAsCR,EAAiBI,GAEhDH,CAAU,EAYnB,KAAAQ,uBAAyB,CACvBX,EACAG,EACAS,KAEA,MAAMtJ,EAAc0I,EAAIC,QAClB,QAAErN,GAAY0E,EAEdgJ,GAAsB,IAAAC,gCAC1B3N,EACAW,KAAKiN,eAGPjN,KAAKsN,2BACHb,EACAG,EACAG,EACAM,EACD,EAMH,KAAAE,qBAAuB,CACrBd,EACAG,KAEA,MAAM7I,EAAc0I,EAAIC,QAClB,QAAErN,GAAY0E,EAEdgJ,GAAsB,IAAAC,gCAC1B3N,EACAW,KAAKiN,eAGHL,EAAWY,KAAKC,QAAQC,OAC1B1N,KAAK2N,0BAA0BlB,EAAKG,EAAYG,GAEhD/M,KAAK4N,wBAAwBnB,EAAKG,EAAYG,GAGhDN,EAAIU,gBAAgB,EActB,KAAAU,gBAAkB,CAChBxO,EACAuN,EACAkB,EACAC,KAEA,MAAMzO,GAAiB,IAAAC,mBAAkBF,IACnC,SAAEwI,GAAavI,GAEb2K,SAAU+D,GAAWpB,EAAWY,KAAKC,QAI7C,IAAIQ,EAAgBpG,EAASqG,cAAcF,EAAO,IAElD,IAAK,IAAIvJ,EAAI,EAAGA,EAAIuJ,EAAO3K,OAAQoB,IAAK,CACtC,MAAM0J,EAAKF,EACLG,EAAKvG,EAASqG,cAAcF,EAAOvJ,IAGzC,GAFmBuF,EAAsB8D,EAAcK,EAAIC,EAAIL,GAG7D,OAAO,EAGTE,EAAgBG,C,CAGlB,IAAKxB,EAAWY,KAAKC,QAAQC,OAE3B,OAAO,EAIT,MAAMW,EAASxG,EAASqG,cAAcF,EAAO,IACvCM,EAAOzG,EAASqG,cAAcF,EAAOA,EAAO3K,OAAS,IAE3D,OAAO2G,EAAsB8D,EAAcO,EAAQC,EAAMP,EAAU,EAG9D,KAAAQ,OAAUlP,IACf,MAAMgN,EAAYrM,KAAKqM,UACjBE,EAAgBvM,KAAKuM,cACrBD,EAAkBtM,KAAKsM,gBAEzBD,EACFrM,KAAKwO,cAAcnP,GACVkN,EACTvM,KAAKyO,sBAAsBpP,GAClBiN,GACTtM,KAAK0O,wBAAwBrP,E,EA2QzB,KAAAsP,sBAAwB,CAC9B/B,EACA/E,EACA8E,EACArN,KAEA,MAAM,KAAEkO,GAASZ,GACX,YAAEgC,GAAgBpB,GAChBvD,SAAU+D,EAAM,OAAEN,GAAWF,EAAKC,QAEpCoB,EAAY7P,OAAOC,KAAK2P,GAE9B,IAAK,IAAInK,EAAI,EAAGA,EAAIoK,EAAUxL,OAAQoB,IAAK,CACzC,MAAMqK,EAAWD,EAAUpK,GACrBsK,EAAQ/O,KAAKgP,iBAAiBF,EAAUnC,GAK9C,IAAKoC,EACH,SAGF,MAAM,UAAEE,EAAS,SAAEC,GAAaH,EAC1BI,EAAoBnB,EAAO1M,KAAK8N,GAAMvH,EAASqG,cAAckB,KAI7DC,EAAcF,EAAkB,GAChCG,EAAqBzH,EAAS0H,cAAcF,GAC5CG,EAAc3H,EAAS0H,cAAc,CACzCF,EAAY,GAAK,EACjBA,EAAY,KAERI,EAAc5H,EAAS0H,cAAc,CACzCF,EAAY,GACZA,EAAY,GAAK,IAGbK,EAAW,cAAcJ,EAAoBE,GAC7CG,EAAW,cAAcL,EAAoBG,GAE7CG,EAAgB,kCAA8BX,EAAWjB,EAAO,IACtE4B,EAAc,GAAKC,KAAKC,MAAMF,EAAc,IAC5CA,EAAc,GAAKC,KAAKC,MAAMF,EAAc,IAC5CA,EAAc,GAAKC,KAAKC,MAAMF,EAAc,IAE5C,IAAIG,EAAOH,EAAc,GACrBI,EAAOJ,EAAc,GAErBK,EAAOL,EAAc,GACrBM,EAAON,EAAc,GAErBO,EAAOP,EAAc,GACrBQ,EAAOR,EAAc,GAEzB,IAAK,IAAIS,EAAI,EAAGA,EAAIrC,EAAO3K,OAAQgN,IAAK,CACtC,MAAMT,EAAgB,kCACpBX,EACAjB,EAAOqC,IAETT,EAAc,GAAKC,KAAKC,MAAMF,EAAc,IAC5CA,EAAc,GAAKC,KAAKC,MAAMF,EAAc,IAC5CA,EAAc,GAAKC,KAAKC,MAAMF,EAAc,IAC5CG,EAAOF,KAAKS,IAAIP,EAAMH,EAAc,IACpCI,EAAOH,KAAKU,IAAIP,EAAMJ,EAAc,IAEpCK,EAAOJ,KAAKS,IAAIL,EAAML,EAAc,IACpCM,EAAOL,KAAKU,IAAIL,EAAMN,EAAc,IAEpCO,EAAON,KAAKS,IAAIH,EAAMP,EAAc,IACpCQ,EAAOP,KAAKU,IAAIH,EAAMR,EAAc,G,CAGtC,MAAMY,EAAiB,kCACrBvB,EACAjB,EAAO,IAETwC,EAAe,GAAKX,KAAKC,MAAMU,EAAe,IAC9CA,EAAe,GAAKX,KAAKC,MAAMU,EAAe,IAC9CA,EAAe,GAAKX,KAAKC,MAAMU,EAAe,IAE9C,MAAM,MAAEC,EAAK,UAAEC,IAAc,QAC3B3B,GACA,KACE,MAAM9E,EAAWuD,EAAKC,QAAQxD,SACxB0G,EAAY1G,EAAS5G,OACrBuN,EAAoB,IAAI9J,MAAM6J,GAEpC,IAAK,IAAIlM,EAAI,EAAGA,EAAIkM,EAAWlM,IAC7BmM,EAAkBnM,GAAKoD,EAASqG,cAAcjE,EAASxF,IAGzD,MACEoM,KAAMC,EACNC,KAAMC,EACNC,KAAMC,EACNC,KAAMC,GACJ,EAAAC,KAAA,iBAAsBT,GAEpBU,EAAiBzJ,EAAS0H,cAAc,CAC5C2B,EACAE,IAGIG,EAAiB,kCACrBtC,EACAqC,GAGIE,EAAqB3J,EAAS0H,cAAc,CAChDuB,EACAE,IAQF,MAAO,CAACO,EALmB,kCACzBtC,EACAuC,GAGyC,IAG/C,IAAIC,EAAO,EAAAxH,SAAA,QAAiBkF,GAAqBsB,EAAQA,EAEzDgB,GAAQ/B,EAAWC,EAGnB,MAAM+B,EAAS,KAAQ1B,EAAOD,GACxB4B,EAAS,KAAQzB,EAAOD,GACxB2B,EAAS,KAAQxB,EAAOD,GAE9BJ,EAAOF,KAAKC,MAAMC,EAAO2B,GACzB1B,EAAOH,KAAKgC,KAAK7B,EAAO0B,GACxBzB,EAAOJ,KAAKC,MAAMG,EAAO0B,GACzBzB,EAAOL,KAAKgC,KAAK3B,EAAOyB,GACxBxB,EAAON,KAAKC,MAAMK,EAAOyB,GACzBxB,EAAOP,KAAKgC,KAAKzB,EAAOwB,GAExB,MAAME,EAAY,CAChB,CAAC/B,EAAMC,GACP,CAACC,EAAMC,GACP,CAACC,EAAMC,IAGH2B,EAAc9C,EAAU+C,aAAa,CAAChC,EAAME,EAAME,IAClD6B,EAAepK,EAASqG,cAAc6D,GAE5C,IAAIG,EAAS,EACTC,EAAgB,GAChBC,EAAsB,EAC1B,MAAMC,GAAgB,OACpBpD,GACA,CAACqD,EAAUC,KACT,IAAIC,GAAS,EACb,MAAMC,EAAQ5K,EAASqG,cAAcoE,GA4BrC,OA3BIG,EAAM,IAAMP,IACdE,EAAsB,EACtBF,EAASO,EAAM,GACfN,GAAgB,IAAAO,wCACdvD,EACAsD,EACA,CAACR,EAAa,GAAIQ,EAAM,KAE1BN,EAAcQ,MAEH,SAAUC,EAAGC,GAClB,OAAOD,EAMR,KANqBC,EAMrB,GALK,EACAD,EAIL,GAJgBC,EAIhB,IAHM,EACD,CACN,KAIFV,EAAc9O,QAAUoP,EAAM,GAAKN,EAAc,GAAG,KACtDA,EAAcW,QACdV,KAEEA,EAAsB,GAAM,IAC9BI,GAAS,GAEJA,CAAM,GAEfxS,KAAKkC,cAAcgK,gBAAgB6G,cACnCjB,GAGIkB,EAAsB,CAC1BC,aAAa,OAAoBpL,EAAUiH,GAC3CoE,YAAalT,KAAKkT,YAChBrL,EACAiH,EACAlC,EAAWsC,SAASiE,oBAIlBC,GAAe,OACnBlE,EAASmE,SACTzG,EAAWsC,SAASiE,kBACpBH,GAGIM,EAAQtT,KAAKkC,cAAcgK,gBAAgBqH,gBAEjD3E,EAAYE,GAAY,CACtBuE,SAAUnE,EAASmE,SACnB5B,OACA+B,WAAW,OAAmBrE,EAAmBzB,GACjD+F,KAAMH,EAAMG,MAAMC,MAClBnD,IAAK+C,EAAM/C,KAAKmD,MAChBC,OAAQL,EAAMK,QAAQD,MACtBE,WAAYN,EAAMO,MAClBxB,cAAeA,EACfyB,SAAUpD,EACV0C,e,CAYJ,OARA,QACExG,EACAtN,EAAeuI,SAASxI,QACxB,EAAA0U,YAAYC,cAGdpH,EAAWqH,aAAc,EAElBrF,CAAW,EAGZ,KAAAsF,aAAe,CACrBtH,EACA/E,EACAvI,EACAY,KAEA,MAAM,KAAEsN,GAAsCZ,EACxCkC,EAAW9O,KAAKmU,YAAYtM,GAE5BuM,EAAiD,CACrDzR,YAAa3C,KAAK2C,YAClBX,SAAUhC,KAAKiN,cACfzN,WAAYF,EAAeuI,SAAS/G,IAGhCmE,EAAUjF,KAAKqU,sBAAsBD,EAAgBxH,GAC3D,IAAK3H,EAAQqP,WACX,OAGF,MAAMC,EAAYvU,KAAKkC,cAAc8J,aAAawB,EAAMsB,GACxD,IAAKyF,GAAkC,IAArBA,EAAUlR,OAC1B,OAGF,MAAM8L,EAAoB3B,EAAKC,QAAQxD,SAAS3I,KAAK8N,GACnDvH,EAASqG,cAAckB,KAEzB,IAAK5B,EAAKgH,QAAQC,QAAQC,SAAU,CAClC,MAAMC,GAAsB,IAAAC,wBAAuBzF,GAEnD3B,EAAKgH,QAAQC,QAAQI,cACnBhN,EAAS0H,cAAcoF,E,CAG3B,MAAMG,EAAkBjN,EAASqG,cAC/BV,EAAKgH,QAAQC,QAAQI,eAIjBE,GAAc,IAAAC,mBAClB9U,EACA0M,EAAWqI,eAAiB,GAHX,IAKjBV,EACAO,EACA3F,EACA,CAAC,EACDlK,IAGMiQ,EAAGC,EAAMC,EAAGC,EAAG,MAAEC,EAAK,OAAEC,GAAWR,EAE3CvH,EAAKgH,QAAQC,QAAQe,iBAAmB,CACtCC,QAAS5N,EAAS0H,cAAc,CAAC4F,EAAME,IACvCK,SAAU7N,EAAS0H,cAAc,CAAC4F,EAAOG,EAAOD,IAChDM,WAAY9N,EAAS0H,cAAc,CAAC4F,EAAME,EAAME,IAChDK,YAAa/N,EAAS0H,cAAc,CAAC4F,EAAOG,EAAOD,EAAME,IAC1D,GA/sBD,OAAiBvV,OACjB,OAAuBA,OACvB,OAA8BA,OAC9B,OAA4BA,OAC5B,OAA+BA,OAC/B,OAAsBA,MAEtBA,KAAK6V,gCAAiC,OACpC7V,KAAK2O,sBACL,IACA,CAAEmH,UAAU,GAEhB,CAgKO,uCAAAC,CACL1W,EACA2W,GAEA,IAAKA,IAAgBA,EAAY3S,OAC/B,OAGF,MAAM/D,GAAiB,IAAAC,mBAAkBF,IACnC,SAAEwI,GAAavI,EAErB,IAAI2W,EAEJ,GAAIpO,aAAoB,EAAAqO,eAAgB,CACtC,MAAMC,EAAStO,EAASuO,aAElB,yBAAEC,GACN,iDAA6CxO,EAAUsO,GAGzDF,EAAuBjW,KAAKsW,6BAC1BN,EACAG,EACAE,E,MAKFJ,GAAuB,IAAAM,6BAA4B1O,EAAUmO,GAG/D,OAAOC,CACT,CAOQ,4BAAAK,CACNN,EACAG,EACAE,GAEA,MAAM,gBAAEG,GAAoBL,EAEtBM,EAAiCT,EAAY9O,QAChDwP,IACC,MAAMC,EAA4BD,EAAGxH,SAASsH,gBAExCI,EACJ/G,KAAKgH,IAAI,SAASL,EAAiBG,IACnCvM,EAEF,OAAOuM,GAA6BC,CAAU,IAKlD,IAAKH,EAA+BpT,OAClC,MAAO,GAMT,MAAMyT,EAA+BT,EAA2B,GAC1D,WAAEU,GAAeZ,EAEjBa,EAAyB,GAE/B,IAAK,MAAMpK,KAAc6J,EAAgC,CACvD,MACMhE,EADO7F,EAAWY,KACLC,QAAQxD,SAAS,GAEpC,IAAK2C,EAAWqK,UACd,SAUF,MAAMC,EAAM,cAEZ,SAASA,EAAKH,EAAYtE,GAE1B,MAAM0E,EAAM,SAASD,EAAKV,GAEtB3G,KAAKgH,IAAIM,GAAOL,GAClBE,EAAuBvT,KAAKmJ,E,CAIhC,OAAOoK,CACT,CAEU,yBAAAI,GAGR,OAAO,CACT,CAEU,gBAAAvK,CAAiBJ,GACzB,MAAM4K,EAAW5K,EAAIC,OAAO4K,cAAcC,MACpCC,EAAoBpL,MAAMS,iBAAiBJ,GAqBjD,OAdgD,sBAC9C+K,EACA,CACEhK,KAAM,CACJC,QAAS,CACPxD,SAAU,CAAe,IAAIoN,KAE/BI,MAAO,GACP7I,YAAa,CAAC,GAEhBhD,wBAf6BgB,IAE/BA,EAAWY,KAAKgH,QAAQxG,OAAO3K,OAAS,CAAC,GAkB7C,CAEU,kBAAAqU,CAAmBC,GAG3B,OAAOvL,MAAMsL,mBAAmBC,EAClC,CAEU,wBAAAC,CACRC,GAEA,MAAM,eAAEvY,EAAc,SAAEwP,EAAQ,iBAAE5O,GAAqB2X,EACjDjL,EAAaiL,EAAcjL,WAEjC,IAAIkL,GAAe,EACnB,MAAM,SAAEjQ,EAAQ,gBAAE8E,GAAoBrN,EAEhC+M,EAAYrM,KAAKqM,UACjBE,EAAgBvM,KAAKuM,cACrBD,EAAkBtM,KAAKsM,gBAE7B,GAAMD,GAAaE,GAAiBD,EAI7B,CAIL,MAAMyL,EAAsB/X,KAAKgY,WAAWpL,WAAWqI,cAEvD,GAAIrI,EAAWqI,gBAAkB8C,EAC/B,GAAI1L,EACFrM,KAAKiY,wBACH3Y,EACAY,EACA0M,QAEG,GAAIN,EACTtM,KAAKkY,+BACH5Y,EACAY,EACA0M,OAEG,KAAIL,EAOT,MAAM,IAAIrJ,MACR,WAAWlD,KAAKiN,4CAPlBjN,KAAKmY,6BACH7Y,EACAY,EACA0M,E,MAQJ5M,KAAKoY,cAAc9Y,EAAgBY,EAAkB0M,GAIvDkL,GAAe,C,MApCf9X,KAAKoY,cAAc9Y,EAAgBY,EAAkB0M,GAuCvD,GAAK5M,KAAKkC,cAAc6J,eAcxB,OAVA/L,KAAKqY,wBACHzL,EACAkC,EACAjH,EACA8E,EACArN,GAGFU,KAAKkU,aAAatH,EAAY/E,EAAUvI,EAAgBY,GAEjD4X,CACT,CAEA,uBAAAO,CACEzL,EACAkC,EACAjH,EACA8E,EACArN,GAEA,MAAMyY,EAAsB/X,KAAKgY,YAAYpL,WAAWqI,cAExD,IACErI,EAAWqI,gBAAkB8C,GAC5B/X,KAAKgY,YAAYM,iBAKftY,KAAKgY,YAAYM,cAAe,CACnC,MAAM,KAAE9K,GAASZ,EAEdY,EAAKoB,YAAYE,IACqB,MAAvCtB,EAAKoB,YAAYE,GAAUgF,SAiBlBlH,EAAWqH,aACpBjU,KAAK6V,+BACHjJ,EACA/E,EACA8E,EACArN,IApBFkO,EAAKoB,YAAYE,GAAY,CAC3BuE,SAAU,KACV5B,KAAM,KACNlB,IAAK,KACLkD,KAAM,KACNE,OAAQ,KACRG,SAAU,MAGZ9T,KAAK2O,sBACH/B,EACA/E,EACA8E,EACArN,G,CAWR,EAuSF,SAAS2M,EAAoBuB,EAAMsB,GACjC,MAAMyJ,EAAoB/K,EAAKoB,YAAYE,IACrC,KACJ2C,EAAI,KACJgC,EAAI,OACJE,EAAM,UACNH,EAAS,IACTjD,EAAG,YACHiI,EAAW,SACX1E,EAAQ,aACRV,GACEmF,GAAqB,CAAC,EAEpBhE,EAAsB,GAE5B,GAAI9C,EAAM,CACR,MAAMgH,EAAWD,EACb,8BACA,UAAS,IAAAE,aAAYjH,MAASqC,IAClCS,EAAU9Q,KAAKgV,E,CAmBjB,OAhBIhF,GACFc,EAAU9Q,KAAK,UAAS,IAAAiV,aAAYjF,MAASL,KAG3C7C,GACFgE,EAAU9Q,KAAK,SAAQ,IAAAiV,aAAYnI,MAAQ6C,KAGzCO,GACFY,EAAU9Q,KAAK,aAAY,IAAAiV,aAAY/E,MAAWP,KAGhDI,GACFe,EAAU9Q,KAAK,eAAc,IAAAiV,aAAYlF,MAAcJ,KAGlDmB,CACT,CAEAlK,EAAsBrI,SAAW,oBACjC,S,uLCn+BA,MAAM2W,EAAwB,IAAsC3W,SAuBpE,MAAM4W,UAAgC,KAEpC,WAAA/X,CACEyJ,EAA6B,CAAC,EAC9BC,EAA8B,CAC5BrI,cAAe,CAAC,IAGlBkK,MAAM9B,EAAWC,GA0DnB,KAAAsO,mBAAsBlW,IACpB,MAAM+F,GAAY,IAAAoQ,cAAanW,GAE/B,IAAK+F,EACH,OAGF,MAAMqQ,GACJ,IAAAC,gCAA+BrW,GAEjC,IACGoW,GAC+C,IAAhDA,EAAqC1V,OAErC,OAIF,MAAM4V,EAAqBvQ,EAAU3H,cAAcO,KACjD,EAAG7B,oBAAmBD,iBACpB,MAAMF,GAAiB,IAAAsI,wBACrBpI,EACAC,GAGF,GAAIH,EACF,OAAOA,EAAeuI,Q,IAMtBqR,EAAyBH,EAAqCzX,KACjE6X,IACC,MAAMC,EAASpZ,KAAKqZ,gCAAgC1W,GAE9C2W,EAAsB,GAEtBC,EAAY,CAChB,CAAC,IAAgBC,UAAW,KAC5B,CAAC,IAAgBC,SAAU,IAC3B,CAAC,IAAgBC,SAAU,KAGzBP,EAAeQ,OAAS,IAA4BF,SAGtDzZ,KAAK4Z,8BAA8BjX,GAGrC,MAAMkX,EAAUN,EAAUJ,EAAeQ,MAEzC,IAAK,MAAM9R,KAAYoR,EAAoB,CACzC,MAAMa,EAAmBD,EAAQE,OAC/BlS,EACAsR,EACAC,GAGFE,EAAoB7V,KAAKqW,E,CAE3B,OAAOR,CAAmB,IAI9BU,QAAQC,WAAWf,GAAwBgB,MAAK,KAE9CjB,EAAmB/Z,SAAS2I,IAC1BA,EAASkS,QAAQ,GACjB,GACF,CA/HJ,CAEA,gBAAA1S,GACE,MAAM1E,EAAc3C,KAAK2C,YACnBoW,GACJ,IAAAC,gCAA+BrW,GAG9BoW,GAC+C,IAAhDA,EAAqC1V,QAMvC0V,EAAqC7Z,SAClCib,KACC,IAAAC,2BACEzX,EACAwX,EAA2BE,+BAC3B,EACD,GAGP,CAEA,iBAAA/S,GACE,MAAM3E,EAAc3C,KAAK2C,YACnBoW,GACJ,IAAAC,gCAA+BrW,GAG9BoW,GAC+C,IAAhDA,EAAqC1V,QAMvC0V,EAAqC7Z,SAClCib,KACC,IAAAC,2BACEzX,EACAwX,EAA2BE,+BAC3B,EACD,GAGP,CAkFA,6BAAAT,CAA8BjX,GAGtBgW,KAAyB,KAAMvW,QACnC,QAAQ,KAGV,MAAMsG,GAAY,IAAAoQ,cAAanW,GAG1B+F,EAAU3G,QAAQ4W,KACrBjQ,EAAUzG,QAAQ0W,GAClBjQ,EAAUtD,eAAeuT,GAE7B,CAOA,+BAAAU,CACE1W,GAEA,MAAM2X,EACJ,oCAA8C3X,GAC1C4X,EAAe,2BAKrB,OAFqB,sBAAkBA,EAAcD,EAGvD,EAGF1B,EAAwB5W,SAAW,sBACnC,S,kBCpNA,IAGIwY,EAAiB,4BAGjBC,EAAW,IAGXC,EAAU,oBACVC,EAAS,6BACTC,EAAY,kBAGZC,EAAe,mDACfC,EAAgB,QAChBC,EAAe,MACfC,EAAa,mGASbC,EAAe,WAGfC,EAAe,8BAGfC,EAA8B,iBAAV,EAAAC,GAAsB,EAAAA,GAAU,EAAAA,EAAOpc,SAAWA,QAAU,EAAAoc,EAGhFC,EAA0B,iBAARC,MAAoBA,MAAQA,KAAKtc,SAAWA,QAAUsc,KAGxEC,EAAOJ,GAAcE,GAAYG,SAAS,cAATA,GAkCrC,IASMC,EATFC,EAAa5U,MAAM6U,UACnBC,EAAYJ,SAASG,UACrBE,EAAc7c,OAAO2c,UAGrBG,EAAaP,EAAK,sBAGlBQ,GACEN,EAAM,SAASO,KAAKF,GAAcA,EAAW7c,MAAQ6c,EAAW7c,KAAKgd,UAAY,KACvE,iBAAmBR,EAAO,GAItCS,EAAeN,EAAUO,SAGzBC,EAAiBP,EAAYO,eAO7BC,EAAiBR,EAAYM,SAG7BG,EAAaC,OAAO,IACtBL,EAAaM,KAAKJ,GAAgBK,QA7EjB,sBA6EuC,QACvDA,QAAQ,yDAA0D,SAAW,KAI5EC,EAASnB,EAAKmB,OACdhY,EAASgX,EAAWhX,OAGpBiY,EAAMC,EAAUrB,EAAM,OACtBsB,EAAeD,EAAU5d,OAAQ,UAGjC8d,EAAcJ,EAASA,EAAOf,eAAY7W,EAC1CiY,EAAiBD,EAAcA,EAAYX,cAAWrX,EAS1D,SAASkY,EAAKC,GACZ,IAAI1Y,GAAS,EACTlB,EAAS4Z,EAAUA,EAAQ5Z,OAAS,EAGxC,IADArD,KAAKkd,UACI3Y,EAAQlB,GAAQ,CACvB,IAAI8Z,EAAQF,EAAQ1Y,GACpBvE,KAAKod,IAAID,EAAM,GAAIA,EAAM,GAC3B,CACF,CAyFA,SAASE,EAAUJ,GACjB,IAAI1Y,GAAS,EACTlB,EAAS4Z,EAAUA,EAAQ5Z,OAAS,EAGxC,IADArD,KAAKkd,UACI3Y,EAAQlB,GAAQ,CACvB,IAAI8Z,EAAQF,EAAQ1Y,GACpBvE,KAAKod,IAAID,EAAM,GAAIA,EAAM,GAC3B,CACF,CAuGA,SAASG,EAASL,GAChB,IAAI1Y,GAAS,EACTlB,EAAS4Z,EAAUA,EAAQ5Z,OAAS,EAGxC,IADArD,KAAKkd,UACI3Y,EAAQlB,GAAQ,CACvB,IAAI8Z,EAAQF,EAAQ1Y,GACpBvE,KAAKod,IAAID,EAAM,GAAIA,EAAM,GAC3B,CACF,CAsFA,SAASI,EAAa1J,EAAO2J,GAE3B,IADA,IA+SU9J,EAAO+J,EA/Sbpa,EAASwQ,EAAMxQ,OACZA,KACL,IA6SQqQ,EA7SDG,EAAMxQ,GAAQ,OA6SNoa,EA7SUD,IA8SA9J,GAAUA,GAAS+J,GAAUA,EA7SpD,OAAOpa,EAGX,OAAQ,CACV,CAUA,SAASqa,EAAQC,EAAQC,GAuDzB,IAAkBlK,EAtDhBkK,EA8FF,SAAelK,EAAOiK,GACpB,GAAI5W,EAAQ2M,GACV,OAAO,EAET,IAAIiG,SAAcjG,EAClB,GAAY,UAARiG,GAA4B,UAARA,GAA4B,WAARA,GAC/B,MAATjG,GAAiBmK,EAASnK,GAC5B,OAAO,EAET,OAAOoH,EAAcgD,KAAKpK,KAAWmH,EAAaiD,KAAKpK,IAC1C,MAAViK,GAAkBjK,KAAS1U,OAAO2e,EACvC,CAzGSI,CAAMH,EAAMD,GAAU,CAACC,GAuDvB7W,EADS2M,EAtD+BkK,GAuDvBlK,EAAQsK,EAAatK,GAlD7C,IAHA,IAAInP,EAAQ,EACRlB,EAASua,EAAKva,OAED,MAAVsa,GAAkBpZ,EAAQlB,GAC/Bsa,EAASA,EAAOM,EAAML,EAAKrZ,OAE7B,OAAQA,GAASA,GAASlB,EAAUsa,OAAS7Y,CAC/C,CAUA,SAASoZ,EAAaxK,GACpB,IAAKyK,EAASzK,KA4GE0K,EA5GiB1K,EA6GxBqI,GAAeA,KAAcqC,GA5GpC,OAAO,EA2GX,IAAkBA,EAzGZC,EAoTN,SAAoB3K,GAGlB,IAAI4K,EAAMH,EAASzK,GAAS2I,EAAeG,KAAK9I,GAAS,GACzD,OAAO4K,GAAO5D,GAAW4D,GAAO3D,CAClC,CAzTiB4D,CAAW7K,IA3Z5B,SAAsBA,GAGpB,IAAIlB,GAAS,EACb,GAAa,MAATkB,GAA0C,mBAAlBA,EAAMyI,SAChC,IACE3J,KAAYkB,EAAQ,GACtB,CAAE,MAAO8K,GAAI,CAEf,OAAOhM,CACT,CAiZsCiM,CAAa/K,GAAU4I,EAAapB,EACxE,OAAOmD,EAAQP,KAsJjB,SAAkBM,GAChB,GAAY,MAARA,EAAc,CAChB,IACE,OAAOlC,EAAaM,KAAK4B,EAC3B,CAAE,MAAOI,GAAI,CACb,IACE,OAAQJ,EAAO,EACjB,CAAE,MAAOI,GAAI,CACf,CACA,MAAO,EACT,CAhKsBE,CAAShL,GAC/B,CAyCA,SAASiL,EAAWrd,EAAKkc,GACvB,IA+CiB9J,EACbiG,EAhDAnM,EAAOlM,EAAIsd,SACf,OAgDgB,WADZjF,SADajG,EA9CA8J,KAgDmB,UAAR7D,GAA4B,UAARA,GAA4B,WAARA,EACrD,cAAVjG,EACU,OAAVA,GAjDDlG,EAAmB,iBAAPgQ,EAAkB,SAAW,QACzChQ,EAAKlM,GACX,CAUA,SAASsb,EAAUe,EAAQH,GACzB,IAAI9J,EAjeN,SAAkBiK,EAAQH,GACxB,OAAiB,MAAVG,OAAiB7Y,EAAY6Y,EAAOH,EAC7C,CA+dcqB,CAASlB,EAAQH,GAC7B,OAAOU,EAAaxK,GAASA,OAAQ5O,CACvC,CAnUAkY,EAAKrB,UAAUuB,MAnEf,WACEld,KAAK4e,SAAW/B,EAAeA,EAAa,MAAQ,CAAC,CACvD,EAkEAG,EAAKrB,UAAkB,OAtDvB,SAAoB6B,GAClB,OAAOxd,KAAK8e,IAAItB,WAAexd,KAAK4e,SAASpB,EAC/C,EAqDAR,EAAKrB,UAAU9X,IA1Cf,SAAiB2Z,GACf,IAAIhQ,EAAOxN,KAAK4e,SAChB,GAAI/B,EAAc,CAChB,IAAIrK,EAAShF,EAAKgQ,GAClB,OAAOhL,IAAWgI,OAAiB1V,EAAY0N,CACjD,CACA,OAAO4J,EAAeI,KAAKhP,EAAMgQ,GAAOhQ,EAAKgQ,QAAO1Y,CACtD,EAoCAkY,EAAKrB,UAAUmD,IAzBf,SAAiBtB,GACf,IAAIhQ,EAAOxN,KAAK4e,SAChB,OAAO/B,OAA6B/X,IAAd0I,EAAKgQ,GAAqBpB,EAAeI,KAAKhP,EAAMgQ,EAC5E,EAuBAR,EAAKrB,UAAUyB,IAXf,SAAiBI,EAAK9J,GAGpB,OAFW1T,KAAK4e,SACXpB,GAAQX,QAA0B/X,IAAV4O,EAAuB8G,EAAiB9G,EAC9D1T,IACT,EAmHAqd,EAAU1B,UAAUuB,MAjFpB,WACEld,KAAK4e,SAAW,EAClB,EAgFAvB,EAAU1B,UAAkB,OArE5B,SAAyB6B,GACvB,IAAIhQ,EAAOxN,KAAK4e,SACZra,EAAQgZ,EAAa/P,EAAMgQ,GAE/B,QAAIjZ,EAAQ,KAIRA,GADYiJ,EAAKnK,OAAS,EAE5BmK,EAAKuR,MAELra,EAAO8X,KAAKhP,EAAMjJ,EAAO,IAEpB,EACT,EAwDA8Y,EAAU1B,UAAU9X,IA7CpB,SAAsB2Z,GACpB,IAAIhQ,EAAOxN,KAAK4e,SACZra,EAAQgZ,EAAa/P,EAAMgQ,GAE/B,OAAOjZ,EAAQ,OAAIO,EAAY0I,EAAKjJ,GAAO,EAC7C,EAyCA8Y,EAAU1B,UAAUmD,IA9BpB,SAAsBtB,GACpB,OAAOD,EAAavd,KAAK4e,SAAUpB,IAAQ,CAC7C,EA6BAH,EAAU1B,UAAUyB,IAjBpB,SAAsBI,EAAK9J,GACzB,IAAIlG,EAAOxN,KAAK4e,SACZra,EAAQgZ,EAAa/P,EAAMgQ,GAO/B,OALIjZ,EAAQ,EACViJ,EAAK/J,KAAK,CAAC+Z,EAAK9J,IAEhBlG,EAAKjJ,GAAO,GAAKmP,EAEZ1T,IACT,EAiGAsd,EAAS3B,UAAUuB,MA/DnB,WACEld,KAAK4e,SAAW,CACd,KAAQ,IAAI5B,EACZ,IAAO,IAAKL,GAAOU,GACnB,OAAU,IAAIL,EAElB,EA0DAM,EAAS3B,UAAkB,OA/C3B,SAAwB6B,GACtB,OAAOmB,EAAW3e,KAAMwd,GAAa,OAAEA,EACzC,EA8CAF,EAAS3B,UAAU9X,IAnCnB,SAAqB2Z,GACnB,OAAOmB,EAAW3e,KAAMwd,GAAK3Z,IAAI2Z,EACnC,EAkCAF,EAAS3B,UAAUmD,IAvBnB,SAAqBtB,GACnB,OAAOmB,EAAW3e,KAAMwd,GAAKsB,IAAItB,EACnC,EAsBAF,EAAS3B,UAAUyB,IAVnB,SAAqBI,EAAK9J,GAExB,OADAiL,EAAW3e,KAAMwd,GAAKJ,IAAII,EAAK9J,GACxB1T,IACT,EA+KA,IAAIge,EAAegB,GAAQ,SAASC,GA4SpC,IAAkBvL,EA3ShBuL,EA4SgB,OADAvL,EA3SEuL,GA4SK,GArZzB,SAAsBvL,GAEpB,GAAoB,iBAATA,EACT,OAAOA,EAET,GAAImK,EAASnK,GACX,OAAOqJ,EAAiBA,EAAeP,KAAK9I,GAAS,GAEvD,IAAIlB,EAAUkB,EAAQ,GACtB,MAAkB,KAAVlB,GAAkB,EAAIkB,IAAW+G,EAAY,KAAOjI,CAC9D,CA2Y8B0M,CAAaxL,GA1SzC,IAAIlB,EAAS,GAOb,OANIuI,EAAa+C,KAAKmB,IACpBzM,EAAO/O,KAAK,IAEdwb,EAAOxC,QAAQzB,GAAY,SAASxW,EAAO2a,EAAQC,EAAOH,GACxDzM,EAAO/O,KAAK2b,EAAQH,EAAOxC,QAAQxB,EAAc,MAASkE,GAAU3a,EACtE,IACOgO,CACT,IASA,SAASyL,EAAMvK,GACb,GAAoB,iBAATA,GAAqBmK,EAASnK,GACvC,OAAOA,EAET,IAAIlB,EAAUkB,EAAQ,GACtB,MAAkB,KAAVlB,GAAkB,EAAIkB,IAAW+G,EAAY,KAAOjI,CAC9D,CAiEA,SAASwM,EAAQZ,EAAMiB,GACrB,GAAmB,mBAARjB,GAAuBiB,GAA+B,mBAAZA,EACnD,MAAM,IAAIC,UAvqBQ,uBAyqBpB,IAAIC,EAAW,WACb,IAAIC,EAAOC,UACPjC,EAAM6B,EAAWA,EAASK,MAAM1f,KAAMwf,GAAQA,EAAK,GACnDG,EAAQJ,EAASI,MAErB,GAAIA,EAAMb,IAAItB,GACZ,OAAOmC,EAAM9b,IAAI2Z,GAEnB,IAAIhL,EAAS4L,EAAKsB,MAAM1f,KAAMwf,GAE9B,OADAD,EAASI,MAAQA,EAAMvC,IAAII,EAAKhL,GACzBA,CACT,EAEA,OADA+M,EAASI,MAAQ,IAAKX,EAAQY,OAAStC,GAChCiC,CACT,CAGAP,EAAQY,MAAQtC,EA6DhB,IAAIvW,EAAUD,MAAMC,QAmDpB,SAASoX,EAASzK,GAChB,IAAIiG,SAAcjG,EAClB,QAASA,IAAkB,UAARiG,GAA4B,YAARA,EACzC,CA+CA,SAASkE,EAASnK,GAChB,MAAuB,iBAATA,GAtBhB,SAAsBA,GACpB,QAASA,GAAyB,iBAATA,CAC3B,CAqBKmM,CAAanM,IAAU2I,EAAeG,KAAK9I,IAAUkH,CAC1D,CAyDAkF,EAAOC,QALP,SAAapC,EAAQC,EAAMoC,GACzB,IAAIxN,EAAmB,MAAVmL,OAAiB7Y,EAAY4Y,EAAQC,EAAQC,GAC1D,YAAkB9Y,IAAX0N,EAAuBwN,EAAexN,CAC/C,C","sources":["webpack:///../../../node_modules/@cornerstonejs/tools/src/drawingSvg/getSvgDrawingHelper.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/drawingSvg/draw.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/enums/ToolModes.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/store/ToolGroupManager/ToolGroup.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/store/ToolGroupManager/createToolGroup.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/store/ToolGroupManager/destroy.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/store/ToolGroupManager/destroyToolGroup.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/store/ToolGroupManager/getAllToolGroups.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/store/ToolGroupManager/getToolGroup.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/store/ToolGroupManager/getToolGroupsWithToolName.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/annotation/PlanarFreehandROITool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/displayTools/SegmentationDisplayTool.ts","webpack:///../../../node_modules/lodash.get/index.js"],"sourcesContent":["import { state } from '../store';\nimport { getEnabledElement } from '@cornerstonejs/core';\nimport { SVGDrawingHelper } from '../types';\n\nconst VIEWPORT_ELEMENT = 'viewport-element';\n\n/**\n * Returns the SVG drawing helper for the given HTML element.\n * @param element - The HTML element to get the SVG drawing helper for.\n * @private\n */\nfunction getSvgDrawingHelper(element: HTMLDivElement): SVGDrawingHelper {\n  const enabledElement = getEnabledElement(element);\n  const { viewportId, renderingEngineId } = enabledElement;\n  const canvasHash = `${viewportId}:${renderingEngineId}`;\n  const svgLayerElement = _getSvgLayer(element);\n\n  // Reset touched\n  Object.keys(state.svgNodeCache[canvasHash]).forEach((cacheKey) => {\n    state.svgNodeCache[canvasHash][cacheKey].touched = false;\n  });\n\n  return {\n    svgLayerElement: svgLayerElement,\n    svgNodeCacheForCanvas: state.svgNodeCache,\n    getSvgNode: getSvgNode.bind(this, canvasHash),\n    appendNode: appendNode.bind(this, svgLayerElement, canvasHash),\n    setNodeTouched: setNodeTouched.bind(this, canvasHash),\n    clearUntouched: clearUntouched.bind(this, svgLayerElement, canvasHash),\n  };\n}\n\n/**\n *\n * @param element\n * @private\n */\nfunction _getSvgLayer(element) {\n  const viewportElement = `.${VIEWPORT_ELEMENT}`;\n  const internalDivElement = element.querySelector(viewportElement);\n\n  // Using :scope to make sure the right svg layer is selected otherwise it\n  // may select one from a nested viewport (eg: AdvancedMagnifyTool).\n  const svgLayer = internalDivElement.querySelector(':scope > .svg-layer');\n\n  return svgLayer;\n}\n\nfunction getSvgNode(canvasHash, cacheKey) {\n  // If state has been reset\n  if (!state.svgNodeCache[canvasHash]) {\n    return;\n  }\n\n  if (state.svgNodeCache[canvasHash][cacheKey]) {\n    return state.svgNodeCache[canvasHash][cacheKey].domRef;\n  }\n}\n\nfunction appendNode(svgLayerElement, canvasHash, svgNode, cacheKey) {\n  // If state has been reset\n  if (!state.svgNodeCache[canvasHash]) {\n    return null;\n  }\n\n  state.svgNodeCache[canvasHash][cacheKey] = {\n    touched: true,\n    domRef: svgNode,\n  };\n\n  svgLayerElement.appendChild(svgNode);\n}\n\nfunction setNodeTouched(canvasHash, cacheKey) {\n  // If state has been reset\n  if (!state.svgNodeCache[canvasHash]) {\n    return;\n  }\n\n  if (state.svgNodeCache[canvasHash][cacheKey]) {\n    state.svgNodeCache[canvasHash][cacheKey].touched = true;\n  }\n}\n\nfunction clearUntouched(svgLayerElement, canvasHash) {\n  // If state has been reset\n  if (!state.svgNodeCache[canvasHash]) {\n    return;\n  }\n\n  Object.keys(state.svgNodeCache[canvasHash]).forEach((cacheKey) => {\n    const cacheEntry = state.svgNodeCache[canvasHash][cacheKey];\n\n    if (!cacheEntry.touched && cacheEntry.domRef) {\n      svgLayerElement.removeChild(cacheEntry.domRef);\n      delete state.svgNodeCache[canvasHash][cacheKey];\n    }\n  });\n}\n\nexport default getSvgDrawingHelper;\n","import getSvgDrawingHelper from './getSvgDrawingHelper';\n\nfunction draw(\n  element: HTMLDivElement,\n  fn: (svgDrawingElement: any) => any\n): void {\n  const svgDrawingHelper = getSvgDrawingHelper(element);\n\n  // Save...\n  fn(svgDrawingHelper);\n  // Restore...\n\n  svgDrawingHelper.clearUntouched();\n}\n\nexport default draw;\n","/**\n * ToolModes - This enum defines the 4 tool states which are available.\n */\nenum ToolModes {\n  /**\n   * Active:\n   * - Can be actively used by mouse/touch events mapped to its `ToolBinding`s.\n   * - Can add data if an annotation tool.\n   * - Can be passively interacted by grabbing a tool or its handles.\n   * - Renders data if the tool has a `renderAnnotation` method.\n   */\n  Active = 'Active',\n  /**\n   * Passive:\n   * - Can be passively interacted by grabbing a tool or its handles.\n   * - Renders data if the tool has a `renderAnnotation` method.\n   */\n  Passive = 'Passive',\n  /**\n   * Enabled:\n   * - Renders data if the tool has a `renderAnnotation` method.\n   */\n  Enabled = 'Enabled',\n  /**\n   * Disabled:\n   * - Annotation does not render.\n   */\n  Disabled = 'Disabled',\n}\n\nexport default ToolModes;\n","import { MouseBindings, ToolModes } from '../../enums';\nimport get from 'lodash.get';\nimport cloneDeep from 'lodash.clonedeep';\nimport {\n  triggerEvent,\n  eventTarget,\n  getRenderingEngine,\n  getRenderingEngines,\n  getEnabledElementByIds,\n  Settings,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\nimport { Events } from '../../enums';\nimport {\n  ToolActivatedEventDetail,\n  ToolModeChangedEventDetail,\n} from '../../types/EventTypes';\nimport { ToolGroupManager, state } from '../index';\nimport {\n  IToolBinding,\n  IToolClassReference,\n  IToolGroup,\n  SetToolBindingsType,\n  ToolOptionsType,\n  ToolConfiguration,\n} from '../../types';\n\nimport { MouseCursor, SVGMouseCursor } from '../../cursors';\nimport { initElementCursor } from '../../cursors/elementCursor';\n\nconst { Active, Passive, Enabled, Disabled } = ToolModes;\n\nconst PRIMARY_BINDINGS = [{ mouseButton: MouseBindings.Primary }];\n\n/**\n * ToolGroup class which is a container for tools and their modes and states.\n * In Cornerstone3DTools, you need to create a tool group in order to use the\n * tools. ToolGroup is a way to share tool configuration, state (enabled, disabled, etc.)\n * across a set of viewports. Tools can set to be activated, enabled or disabled\n * in a toolGroup. You should not directly instantiate a ToolGroup. You need to use\n * ToolGroupManager helpers to create a new toolGroup or get a reference to an existing toolGroup.\n *\n * ```js\n * const toolGroup = csTools.ToolGroupManager.createToolGroup('toolGroupId')\n * ```\n */\nexport default class ToolGroup implements IToolGroup {\n  id: string;\n  viewportsInfo = [];\n  toolOptions = {};\n  currentActivePrimaryToolName: string | null = null;\n  prevActivePrimaryToolName: string | null = null;\n  /**\n   * Options used for restoring a tool\n   */\n  restoreToolOptions = {};\n  _toolInstances = {};\n\n  constructor(id: string) {\n    this.id = id;\n  }\n\n  /**\n   * Get the viewport IDs of all the viewports in the current viewport\n   * @returns An array of viewport IDs.\n   */\n  getViewportIds(): string[] {\n    return this.viewportsInfo.map(({ viewportId }) => viewportId);\n  }\n\n  /**\n   * Returns the toolGroup viewports info which is an array of {viewportId, renderingEngineId}\n   */\n  getViewportsInfo(): Array<Types.IViewportId> {\n    return this.viewportsInfo.slice();\n  }\n\n  /**\n   * Get the tool instance for a given tool name in the toolGroup\n   * @param toolName - The name of the tool.\n   * @returns A tool instance.\n   */\n  public getToolInstance(toolInstanceName: string) {\n    const toolInstance = this._toolInstances[toolInstanceName];\n    if (!toolInstance) {\n      console.warn(\n        `'${toolInstanceName}' is not registered with this toolGroup (${this.id}).`\n      );\n      return;\n    }\n\n    return toolInstance;\n  }\n\n  /**\n   * Retrieves the tool instances associated with this tool group.\n   *\n   * @returns A record containing the tool instances, where the keys are the tool names and the values are the tool instances.\n   */\n  public getToolInstances(): Record<string, any> {\n    return this._toolInstances;\n  }\n\n  /**\n   * Check if a tool is already added to the tool group\n   * @param toolName - Tool name\n   * @returns True if the tool is already added or false otherwise\n   */\n  hasTool(toolName: string): boolean {\n    return !!this._toolInstances[toolName];\n  }\n\n  /**\n   * Add a tool to the tool group with the given tool name and tool configuration.\n   * Note that adding a tool to a tool group will not automatically set the tool\n   * to be active. You must call setToolActive or setToolPassive and other methods\n   * to set the tool to be active or passive or in other states.\n   *\n   * @param toolName - string\n   * @param configuration - Tool configuration objects and a custom statistics calculator if needed\n   */\n  addTool(toolName: string, configuration: ToolConfiguration = {}): void {\n    const toolDefinition = state.tools[toolName];\n    const hasToolName = typeof toolName !== 'undefined' && toolName !== '';\n    const localToolInstance = this.toolOptions[toolName];\n\n    if (!hasToolName) {\n      console.warn(\n        'Tool with configuration did not produce a toolName: ',\n        configuration\n      );\n      return;\n    }\n\n    if (!toolDefinition) {\n      console.warn(\n        `'${toolName}' is not registered with the library. You need to use cornerstoneTools.addTool to register it.`\n      );\n      return;\n    }\n\n    if (localToolInstance) {\n      console.warn(\n        `'${toolName}' is already registered for ToolGroup ${this.id}.`\n      );\n      return;\n    }\n\n    // Should these be renamed higher up, so we don't have to alias?\n    // Wrap in try-catch so 3rd party tools don't explode?\n    const { toolClass: ToolClass } = toolDefinition;\n\n    const toolProps = {\n      name: toolName,\n      toolGroupId: this.id,\n      configuration,\n    };\n\n    const instantiatedTool = new ToolClass(toolProps);\n\n    // API instead of directly exposing schema?\n    // Maybe not here, but feels like a \"must\" for any method outside of the ToolGroup itself\n    this._toolInstances[toolName] = instantiatedTool;\n  }\n\n  public addToolInstance(\n    toolName: string,\n    parentClassName: string,\n    configuration = {}\n  ): void {\n    let ToolClassToUse = state.tools[toolName]\n      ?.toolClass as IToolClassReference;\n\n    if (!ToolClassToUse) {\n      // get parent class constructor\n      const ParentClass = state.tools[parentClassName]\n        .toolClass as IToolClassReference;\n\n      // Todo: could not find a way to make this work with typescript\n      // @ts-ignore\n      class ToolInstance extends ParentClass {}\n      // @ts-ignore\n      ToolInstance.toolName = toolName;\n      // @ts-ignore\n      ToolClassToUse = ToolInstance;\n\n      state.tools[toolName] = {\n        toolClass: ToolInstance as IToolClassReference,\n      };\n    }\n\n    // add the tool to the toolGroup\n    // @ts-ignore\n    this.addTool(ToolClassToUse.toolName, configuration);\n  }\n\n  //   class InstanceTool extends parentClass;\n  // InstanceTool.constructor.toolName = name;\n  // addTool(InstanceTool,configuration)\n  /**\n   * Add a viewport to the ToolGroup. It accepts viewportId and optional\n   * renderingEngineId parameter. If renderingEngineId is not provided,\n   * it checks if cornerstone-core has more than one renderingEngine; If so,\n   * it will throw an error. If cornerstone-core has only one renderingEngine,\n   * it will use that renderingEngine.\n   *\n   * @param viewportId - The unique identifier for the viewport.\n   * @param renderingEngineId - The rendering engine to use.\n   */\n  public addViewport(viewportId: string, renderingEngineId?: string): void {\n    if (typeof viewportId !== 'string') {\n      throw new Error('viewportId must be defined and be a string');\n    }\n\n    const renderingEngines = getRenderingEngines();\n\n    if (!renderingEngineId && renderingEngines.length > 1) {\n      throw new Error(\n        'You must specify a renderingEngineId when there are multiple rendering engines.'\n      );\n    }\n\n    const renderingEngineUIDToUse = renderingEngineId || renderingEngines[0].id;\n\n    // Don't overwrite if it already exists\n    if (\n      !this.viewportsInfo.some(({ viewportId: vpId }) => vpId === viewportId)\n    ) {\n      this.viewportsInfo.push({\n        viewportId,\n        renderingEngineId: renderingEngineUIDToUse,\n      });\n    }\n\n    // Handle the newly added viewport's mouse cursor\n    const toolName = this.getActivePrimaryMouseButtonTool();\n\n    const runtimeSettings = Settings.getRuntimeSettings();\n    if (runtimeSettings.get('useCursors')) {\n      this.setViewportsCursorByToolName(toolName);\n    }\n\n    const eventDetail = {\n      toolGroupId: this.id,\n      viewportId,\n      renderingEngineId: renderingEngineUIDToUse,\n    };\n\n    triggerEvent(eventTarget, Events.TOOLGROUP_VIEWPORT_ADDED, eventDetail);\n  }\n\n  /**\n   * Removes viewport from the toolGroup. If only renderingEngineId is defined\n   * it removes all the viewports with the same renderingEngineId, if viewportId\n   * is also provided, it will remove that specific viewport from the ToolGroup.\n   *\n   * @param renderingEngineId - renderingEngine id\n   * @param viewportId - viewport id\n   */\n  public removeViewports(renderingEngineId: string, viewportId?: string): void {\n    const indices = [];\n\n    this.viewportsInfo.forEach((vpInfo, index) => {\n      let match = false;\n      if (vpInfo.renderingEngineId === renderingEngineId) {\n        match = true;\n\n        if (viewportId && vpInfo.viewportId !== viewportId) {\n          match = false;\n        }\n      }\n      if (match) {\n        indices.push(index);\n      }\n    });\n\n    if (indices.length) {\n      // Note: Traverse the array backwards, such that when we remove items we\n      // do not immediately mess up our loop indicies.\n      for (let i = indices.length - 1; i >= 0; i--) {\n        this.viewportsInfo.splice(indices[i], 1);\n      }\n    }\n\n    const eventDetail = {\n      toolGroupId: this.id,\n      viewportId,\n      renderingEngineId,\n    };\n\n    triggerEvent(eventTarget, Events.TOOLGROUP_VIEWPORT_REMOVED, eventDetail);\n  }\n\n  public setActiveStrategy(toolName: string, strategyName: string) {\n    const toolInstance = this._toolInstances[toolName];\n\n    if (toolInstance === undefined) {\n      console.warn(\n        `Tool ${toolName} not added to toolGroup, can't set tool configuration.`\n      );\n\n      return;\n    }\n\n    toolInstance.setActiveStrategy(strategyName);\n  }\n\n  setToolMode(\n    toolName: string,\n    mode: ToolModes,\n    options = {} as SetToolBindingsType\n  ): void {\n    if (!toolName) {\n      console.warn('setToolMode: toolName must be defined');\n      return;\n    }\n\n    if (mode === ToolModes.Active) {\n      this.setToolActive(\n        toolName,\n        options || this.restoreToolOptions[toolName]\n      );\n      return;\n    }\n\n    if (mode === ToolModes.Passive) {\n      this.setToolPassive(toolName);\n      return;\n    }\n\n    if (mode === ToolModes.Enabled) {\n      this.setToolEnabled(toolName);\n      return;\n    }\n\n    if (mode === ToolModes.Disabled) {\n      this.setToolDisabled(toolName);\n      return;\n    }\n\n    console.warn('setToolMode: mode must be defined');\n  }\n\n  /**\n   * Set the tool mode on the toolGroup to be Active. This means the tool\n   * can be actively used by the defined bindings (e.g., Mouse primary click)\n   *\n   * - Can be actively used by mouse/touch events mapped to its `ToolBinding`s.\n   * - Can add data if an annotation tool.\n   * - Can be passively interacted by grabbing a tool or its handles.\n   * - Renders data if the tool has a `renderAnnotation` method.\n   *\n   * @param toolName - tool name\n   * @param toolBindingsOptions - tool bindings\n   */\n  public setToolActive(\n    toolName: string,\n    toolBindingsOptions = {} as SetToolBindingsType\n  ): void {\n    const toolInstance = this._toolInstances[toolName];\n\n    if (toolInstance === undefined) {\n      console.warn(\n        `Tool ${toolName} not added to toolGroup, can't set tool mode.`\n      );\n\n      return;\n    }\n\n    if (!toolInstance) {\n      console.warn(\n        `'${toolName}' instance ${toolInstance} is not registered with this toolGroup, can't set tool mode.`\n      );\n      return;\n    }\n\n    const prevBindings: IToolBinding[] = this.toolOptions[toolName]\n      ? this.toolOptions[toolName].bindings\n      : [];\n\n    const newBindings = toolBindingsOptions.bindings\n      ? toolBindingsOptions.bindings\n      : [];\n\n    // combine the new bindings with the previous bindings to avoid duplicates\n    // it allows duplicated mouse buttons as long as they don't have same\n    // modifier keys.\n    const bindingsToUse = [...prevBindings, ...newBindings].reduce(\n      (unique, binding) => {\n        const TouchBinding = binding.numTouchPoints !== undefined;\n        const MouseBinding = binding.mouseButton !== undefined;\n\n        if (\n          !unique.some((obj) => hasSameBinding(obj, binding)) &&\n          (TouchBinding || MouseBinding)\n        ) {\n          unique.push(binding);\n        }\n        return unique;\n      },\n      []\n    );\n\n    // We should not override the bindings if they are already set\n    const toolOptions: ToolOptionsType = {\n      bindings: bindingsToUse,\n      mode: Active,\n    };\n\n    this.toolOptions[toolName] = toolOptions;\n    this._toolInstances[toolName].mode = Active;\n\n    // reset the mouse cursor if tool has left click binding\n    const runtimeSettings = Settings.getRuntimeSettings();\n    const useCursor = runtimeSettings.get('useCursors');\n\n    if (this._hasMousePrimaryButtonBinding(toolBindingsOptions) && useCursor) {\n      this.setViewportsCursorByToolName(toolName);\n    } else {\n      // reset to default cursor only if there is no other tool with primary binding\n      const activeToolIdentifier = this.getActivePrimaryMouseButtonTool();\n      if (!activeToolIdentifier && useCursor) {\n        const cursor = MouseCursor.getDefinedCursor('default');\n        this._setCursorForViewports(cursor);\n      }\n    }\n\n    // if it is a primary tool binding, we should store it as the previous primary tool\n    // so that we can restore it when the tool is disabled if desired\n    if (this._hasMousePrimaryButtonBinding(toolBindingsOptions)) {\n      if (this.prevActivePrimaryToolName === null) {\n        this.prevActivePrimaryToolName = toolName;\n      } else {\n        this.prevActivePrimaryToolName = this.currentActivePrimaryToolName;\n      }\n\n      this.currentActivePrimaryToolName = toolName;\n    }\n\n    if (typeof toolInstance.onSetToolActive === 'function') {\n      toolInstance.onSetToolActive();\n    }\n    this._renderViewports();\n\n    const eventDetail: ToolActivatedEventDetail = {\n      toolGroupId: this.id,\n      toolName,\n      toolBindingsOptions,\n    };\n\n    triggerEvent(eventTarget, Events.TOOL_ACTIVATED, eventDetail);\n    this._triggerToolModeChangedEvent(toolName, Active, toolBindingsOptions);\n  }\n\n  /**\n   * Set the tool mode on the toolGroup to be Passive.\n   *\n   * - Can be passively interacted by grabbing a tool or its handles.\n   * - Renders data if the tool has a `renderAnnotation` method.\n   *\n   * @param toolName - tool name\n   * @param options - Options used when setting the tool as passive\n   *  - removeAllBindings: only the primary button bindings are removed but\n   *  if this parameter is set to true all bindings are removed.\n   */\n  public setToolPassive(\n    toolName: string,\n    options?: { removeAllBindings?: boolean | IToolBinding[] }\n  ): void {\n    const toolInstance = this._toolInstances[toolName];\n\n    if (toolInstance === undefined) {\n      console.warn(\n        `Tool ${toolName} not added to toolGroup, can't set tool mode.`\n      );\n\n      return;\n    }\n\n    // We should only remove the primary button bindings and keep\n    // the other ones (Zoom on right click)\n    const prevToolOptions = this.getToolOptions(toolName);\n    const toolOptions = Object.assign(\n      {\n        bindings: prevToolOptions ? prevToolOptions.bindings : [],\n      },\n      prevToolOptions,\n      {\n        mode: Passive,\n      }\n    );\n\n    const matchBindings = Array.isArray(options?.removeAllBindings)\n      ? options.removeAllBindings\n      : this.getDefaultPrimaryBindings();\n\n    // Remove the primary button bindings without modifiers, if they exist\n    toolOptions.bindings = toolOptions.bindings.filter(\n      (binding) =>\n        options?.removeAllBindings !== true &&\n        !matchBindings.some((matchBinding) =>\n          hasSameBinding(binding, matchBinding)\n        )\n      //(binding.mouseButton !== defaultMousePrimary || binding.modifierKey)\n    );\n    // If there are other bindings, set the tool to be active\n    let mode = Passive;\n    if (toolOptions.bindings.length !== 0) {\n      mode = Active;\n      toolOptions.mode = mode;\n    }\n\n    this.toolOptions[toolName] = toolOptions;\n    toolInstance.mode = mode;\n\n    if (typeof toolInstance.onSetToolPassive === 'function') {\n      toolInstance.onSetToolPassive();\n    }\n    this._renderViewports();\n\n    // It would make sense to use `toolInstance.mode` as mode when setting a tool\n    // as passive because it can still be actived in the end but `Passive` must\n    // be used when synchronizing ToolGroups so that other ToolGroups can take the\n    // same action (update tool bindings). Should the event have two different modes\n    // to handle this special case?\n    this._triggerToolModeChangedEvent(toolName, Passive);\n  }\n\n  /**\n   * Set the tool mode on the toolGroup to be Enabled.\n   *\n   * - Renders data if the tool has a `renderAnnotation` method..\n   *\n   * @param toolName - tool name\n   */\n  public setToolEnabled(toolName: string): void {\n    const toolInstance = this._toolInstances[toolName];\n\n    if (toolInstance === undefined) {\n      console.warn(\n        `Tool ${toolName} not added to toolGroup, can't set tool mode.`\n      );\n\n      return;\n    }\n\n    const toolOptions = {\n      bindings: [],\n      mode: Enabled,\n    };\n\n    this.toolOptions[toolName] = toolOptions;\n    toolInstance.mode = Enabled;\n\n    if (typeof toolInstance.onSetToolEnabled === 'function') {\n      toolInstance.onSetToolEnabled();\n    }\n\n    this._renderViewports();\n    this._triggerToolModeChangedEvent(toolName, Enabled);\n  }\n\n  /**\n   * Set the tool mode on the toolGroup to be Disabled.\n   *\n   * - Annotation does not render.\n   *\n   * @param toolName - tool name\n   */\n  public setToolDisabled(toolName: string): void {\n    const toolInstance = this._toolInstances[toolName];\n\n    if (toolInstance === undefined) {\n      console.warn(\n        `Tool ${toolName} not added to toolGroup, can't set tool mode.`\n      );\n\n      return;\n    }\n\n    const toolOptions = {\n      bindings: [],\n      mode: Disabled,\n    };\n\n    this.restoreToolOptions[toolName] = this.toolOptions[toolName];\n\n    this.toolOptions[toolName] = toolOptions;\n    toolInstance.mode = Disabled;\n\n    if (typeof toolInstance.onSetToolDisabled === 'function') {\n      toolInstance.onSetToolDisabled();\n    }\n    this._renderViewports();\n    this._triggerToolModeChangedEvent(toolName, Disabled);\n  }\n\n  /**\n   * Get the options for a given tool\n   * @param toolName - The name of the tool.\n   * @returns the tool options\n   */\n  public getToolOptions(toolName: string): ToolOptionsType {\n    const toolOptionsForTool = this.toolOptions[toolName];\n\n    if (toolOptionsForTool === undefined) {\n      return;\n    }\n\n    return toolOptionsForTool;\n  }\n\n  /**\n   * Find the name of the tool that is Active and has a primary button binding\n   * (Mouse primary click)\n   *\n   * @returns The name of the tool\n   */\n  public getActivePrimaryMouseButtonTool(): string {\n    return Object.keys(this.toolOptions).find((toolName) => {\n      const toolOptions = this.toolOptions[toolName];\n      return (\n        toolOptions.mode === Active &&\n        this._hasMousePrimaryButtonBinding(toolOptions)\n      );\n    });\n  }\n\n  public setViewportsCursorByToolName(\n    toolName: string,\n    strategyName?: string\n  ): void {\n    const cursor = this._getCursor(toolName, strategyName);\n\n    this._setCursorForViewports(cursor);\n  }\n\n  private _getCursor(toolName: string, strategyName?: string): MouseCursor {\n    let cursorName;\n    let cursor;\n\n    if (strategyName) {\n      // Try combinations with strategyName first:\n      // Try with toolName and toolInstanceName first.\n      cursorName = `${toolName}.${strategyName}`;\n\n      cursor = SVGMouseCursor.getDefinedCursor(cursorName, true);\n\n      if (cursor) {\n        return cursor;\n      }\n    }\n\n    // Try with toolName and toolInstanceName first.\n    cursorName = `${toolName}`;\n\n    cursor = SVGMouseCursor.getDefinedCursor(cursorName, true);\n\n    if (cursor) {\n      return cursor;\n    }\n\n    // Try with just toolName.\n    cursorName = toolName;\n\n    cursor = SVGMouseCursor.getDefinedCursor(cursorName, true);\n\n    if (cursor) {\n      return cursor;\n    }\n\n    return MouseCursor.getDefinedCursor('default');\n  }\n\n  _setCursorForViewports(cursor: MouseCursor): void {\n    this.viewportsInfo.forEach(({ renderingEngineId, viewportId }) => {\n      const enabledElement = getEnabledElementByIds(\n        viewportId,\n        renderingEngineId\n      );\n\n      if (!enabledElement) {\n        return;\n      }\n\n      const { viewport } = enabledElement;\n      initElementCursor(viewport.element, cursor);\n    });\n  }\n\n  /**\n   * Set a configuration of a tool by the given toolName.\n   * Use overwrite as true in case you want to overwrite any existing configuration (be careful, depending on config change it might break the annotation flow).\n   */\n  public setToolConfiguration(\n    toolName: string,\n    configuration: ToolConfiguration,\n    overwrite?: boolean\n  ): boolean {\n    const toolInstance = this._toolInstances[toolName];\n    if (toolInstance === undefined) {\n      console.warn(\n        `Tool ${toolName} not present, can't set tool configuration.`\n      );\n      return false;\n    }\n\n    let _configuration;\n\n    if (overwrite) {\n      _configuration = configuration;\n    } else {\n      // We should not deep copy here, it is the job of the application to\n      // deep copy the configuration before passing it to the toolGroup, otherwise\n      // some strange appending behaviour happens for the arrays\n      _configuration = Object.assign(toolInstance.configuration, configuration);\n    }\n\n    toolInstance.configuration = _configuration;\n\n    if (typeof toolInstance.onSetToolConfiguration === 'function') {\n      toolInstance.onSetToolConfiguration();\n    }\n\n    this._renderViewports();\n\n    return true;\n  }\n\n  /**\n   * Returns the default mouse primary button.\n   */\n  public getDefaultMousePrimary(): MouseBindings {\n    return MouseBindings.Primary;\n  }\n\n  /**\n   * Gets an array of bindings that is the full primary binding.\n   * Currently this is just the primary mouse button, but may be extended in the\n   * future to include touch or other binding types.\n   */\n  public getDefaultPrimaryBindings(): IToolBinding[] {\n    return PRIMARY_BINDINGS;\n  }\n\n  /**\n   * Get the configuration of tool. It returns only the config for the given path (in case exists).\n   * ConfigurationPath is the the path of the property to get separated by '.'.\n   *\n   * @example\n   * getToolConfiguration('LengthTool', 'firstLevel.secondLevel')\n   * // get from LengthTool instance the configuration value as being LengthToolInstance[configuration][firstLevel][secondLevel]\n   */\n  getToolConfiguration(toolName: string, configurationPath?: string): any {\n    if (this._toolInstances[toolName] === undefined) {\n      console.warn(\n        `Tool ${toolName} not present, can't set tool configuration.`\n      );\n      return;\n    }\n\n    const _configuration =\n      get(this._toolInstances[toolName].configuration, configurationPath) ||\n      this._toolInstances[toolName].configuration;\n\n    return cloneDeep(_configuration);\n  }\n\n  /**\n   * Gets the name of the previously active tool.\n   * @returns The name of the previously active tool.\n   */\n  public getPrevActivePrimaryToolName(): string {\n    return this.prevActivePrimaryToolName;\n  }\n\n  /**\n   *\n   * @param newToolGroupId - Id of the new (clone) tool group\n   * @param fnToolFilter - Function to filter which tools from this tool group\n   * should be added to the new (clone) one. Example: only annotations tools\n   * can be filtered and added to the new tool group.\n   * @returns A new tool group that is a clone of this one\n   */\n  public clone(\n    newToolGroupId,\n    fnToolFilter: (toolName: string) => void = null\n  ): IToolGroup {\n    let toolGroup = ToolGroupManager.getToolGroup(newToolGroupId);\n\n    if (toolGroup) {\n      console.warn(`ToolGroup ${newToolGroupId} already exists`);\n      return toolGroup;\n    }\n\n    toolGroup = ToolGroupManager.createToolGroup(newToolGroupId);\n    fnToolFilter = fnToolFilter ?? (() => true);\n\n    Object.keys(this._toolInstances)\n      .filter(fnToolFilter)\n      .forEach((toolName) => {\n        const sourceToolInstance = this._toolInstances[toolName];\n        const sourceToolOptions = this.toolOptions[toolName];\n        const sourceToolMode = sourceToolInstance.mode;\n\n        toolGroup.addTool(toolName);\n\n        (toolGroup as unknown as ToolGroup).setToolMode(\n          toolName,\n          sourceToolMode,\n          {\n            bindings: sourceToolOptions.bindings ?? [],\n          }\n        );\n      });\n\n    return toolGroup;\n  }\n\n  /**\n   * Check if the tool binding is set to be primary mouse button.\n   * @param toolOptions - The options for the tool mode.\n   * @returns A boolean value.\n   */\n  private _hasMousePrimaryButtonBinding(toolOptions) {\n    const primaryBindings = this.getDefaultPrimaryBindings();\n    return toolOptions?.bindings?.some((binding) =>\n      primaryBindings.some((primary) => hasSameBinding(binding, primary))\n    );\n  }\n\n  /**\n   * It re-renders the viewports in the toolGroup\n   */\n  private _renderViewports(): void {\n    this.viewportsInfo.forEach(({ renderingEngineId, viewportId }) => {\n      getRenderingEngine(renderingEngineId).renderViewport(viewportId);\n    });\n  }\n\n  /**\n   * Trigger ToolModeChangedEvent when changing the tool mode\n   * @param toolName - Tool name\n   * @param mode - Tool mode\n   * @param toolBindingsOptions - Binding options used when a tool is activated\n   */\n  private _triggerToolModeChangedEvent(\n    toolName: string,\n    mode: ToolModes,\n    toolBindingsOptions?: SetToolBindingsType\n  ): void {\n    const eventDetail: ToolModeChangedEventDetail = {\n      toolGroupId: this.id,\n      toolName,\n      mode,\n      toolBindingsOptions,\n    };\n\n    triggerEvent(eventTarget, Events.TOOL_MODE_CHANGED, eventDetail);\n  }\n}\n\n/**\n * Figure out if the two bindings are the same\n */\nfunction hasSameBinding(\n  binding1: IToolBinding,\n  binding2: IToolBinding\n): boolean {\n  if (binding1.mouseButton !== binding2.mouseButton) {\n    return false;\n  }\n  if (binding1.numTouchPoints !== binding2.numTouchPoints) {\n    return false;\n  }\n\n  return binding1.modifierKey === binding2.modifierKey;\n}\n","import { state } from '../index';\nimport ToolGroup from './ToolGroup';\nimport { IToolGroup } from '../../types';\n\n/**\n * Create a new tool group with the given name. ToolGroups are the new way\n * in Cornerstone3DTools to share tool configuration, state (enabled, disabled, etc.)\n * across a set of viewports.\n *\n * @param toolGroupId - The unique ID of the tool group.\n * @returns A reference to the tool group that was created.\n */\nfunction createToolGroup(toolGroupId: string): IToolGroup | undefined {\n  // Exit early if ID conflict\n  const toolGroupWithIdExists = state.toolGroups.some(\n    (tg) => tg.id === toolGroupId\n  );\n\n  if (toolGroupWithIdExists) {\n    console.warn(`'${toolGroupId}' already exists.`);\n    return;\n  }\n\n  const toolGroup = new ToolGroup(toolGroupId);\n\n  // Update state\n  state.toolGroups.push(toolGroup);\n\n  // Return reference\n  return toolGroup;\n}\n\nexport default createToolGroup;\n","// `BaseManager` or IManager interface for duplicate API between ToolGroup/Synchronizer?\nimport { state as csToolsState } from '../index';\nimport destroyToolGroup from './destroyToolGroup';\n\n// ToolGroups function entirely by their \"state\" being queried and leveraged\n// removing a ToolGroup from state is equivalent to killing it. Calling\n// destroyToolGroup() to make sure the SegmentationDisplayTools\n// have been removed from the toolGroup Viewports. //Todo: this makes more sense\n// to be based on events, but we don't have any toolGroup created/removed events\n\n/**\n * Destroy all tool groups\n */\nfunction destroy(): void {\n  const toolGroups = [...csToolsState.toolGroups];\n\n  for (const toolGroup of toolGroups) {\n    destroyToolGroup(toolGroup.id);\n  }\n\n  csToolsState.toolGroups = [];\n}\n\nexport default destroy;\n","import { state } from '../index';\nimport { removeSegmentationsFromToolGroup } from '../../stateManagement/segmentation';\nimport { segmentationRenderingEngine } from '../../utilities/segmentation/triggerSegmentationRender';\n// ToolGroups function entirely by their \"state\" being queried and leveraged\n// removing a ToolGroup from state is equivalent to killing it\n\n/**\n * Given a tool group Id, destroy the toolGroup. It will also cleanup all segmentations\n * associated with that tool group too\n *\n * @param toolGroupId - The Id of the tool group to be destroyed.\n */\nfunction destroyToolGroup(toolGroupId: string): void {\n  const toolGroupIndex = state.toolGroups.findIndex(\n    (tg) => tg.id === toolGroupId\n  );\n\n  if (toolGroupIndex > -1) {\n    segmentationRenderingEngine.removeToolGroup(toolGroupId);\n    // Todo: this should not happen here)\n    removeSegmentationsFromToolGroup(toolGroupId);\n    state.toolGroups.splice(toolGroupIndex, 1);\n  }\n}\n\nexport default destroyToolGroup;\n","import { state } from '../index';\nimport { IToolGroup } from '../../types';\n\n/**\n * Return the array of tool groups\n * @returns An array of tool groups.\n */\nfunction getAllToolGroups(): Array<IToolGroup> {\n  return state.toolGroups;\n}\n\nexport default getAllToolGroups;\n","import { state } from '../index';\nimport { IToolGroup } from '../../types';\n\n/**\n * Given a tool group Id, return the tool group\n * @param toolGroupId - The Id of the tool group to be retrieved.\n * @returns The tool group that has the same id as the tool group id that was\n * passed in.\n */\nfunction getToolGroup(toolGroupId: string): IToolGroup | undefined {\n  return state.toolGroups.find((s) => s.id === toolGroupId);\n}\n\nexport default getToolGroup;\n","import { state } from '../index';\nimport { IToolGroup } from '../../types';\nimport { ToolModes } from '../../enums';\n\nconst MODES = [ToolModes.Active, ToolModes.Passive, ToolModes.Enabled];\n\n/**\n * Returns the toolGroups that has the given toolName as active, passive\n * or enabled.\n * @param toolName - The name of the tool\n * @returns An array of tool groups.\n */\nfunction getToolGroupsWithToolName(toolName: string): IToolGroup[] | [] {\n  return state.toolGroups.filter(({ toolOptions }) => {\n    const toolGroupToolNames = Object.keys(toolOptions);\n\n    for (let i = 0; i < toolGroupToolNames.length; i++) {\n      if (toolName !== toolGroupToolNames[i]) {\n        continue;\n      }\n\n      /* filter out tools that don't have options */\n      if (!toolOptions[toolName]) {\n        continue;\n      }\n\n      if (MODES.includes(toolOptions[toolName].mode)) {\n        return true;\n      }\n    }\n    return false;\n  });\n}\n\nexport default getToolGroupsWithToolName;\n","import {\n  CONSTANTS,\n  getEnabledElement,\n  VolumeViewport,\n  utilities as csUtils,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\nimport { vec3 } from 'gl-matrix';\n\nimport { getCalibratedLengthUnitsAndScale } from '../../utilities/getCalibratedUnits';\nimport { math, roundNumber } from '../../utilities';\nimport { polyline } from '../../utilities/math';\nimport { filterAnnotationsForDisplay } from '../../utilities/planar';\nimport throttle from '../../utilities/throttle';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport registerDrawLoop from './planarFreehandROITool/drawLoop';\nimport registerEditLoopCommon from './planarFreehandROITool/editLoopCommon';\nimport registerClosedContourEditLoop from './planarFreehandROITool/closedContourEditLoop';\nimport registerOpenContourEditLoop from './planarFreehandROITool/openContourEditLoop';\nimport registerOpenContourEndEditLoop from './planarFreehandROITool/openContourEndEditLoop';\nimport registerRenderMethods from './planarFreehandROITool/renderMethods';\nimport type {\n  EventTypes,\n  ToolHandle,\n  Annotation,\n  Annotations,\n  AnnotationStyle,\n  PublicToolProps,\n  ToolProps,\n  SVGDrawingHelper,\n  AnnotationRenderContext,\n} from '../../types';\nimport { triggerAnnotationModified } from '../../stateManagement/annotation/helpers/state';\nimport { drawLinkedTextBox } from '../../drawingSvg';\nimport { PlanarFreehandROIAnnotation } from '../../types/ToolSpecificAnnotationTypes';\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\nimport { PlanarFreehandROICommonData } from '../../utilities/math/polyline/planarFreehandROIInternalTypes';\n\nimport { getLineSegmentIntersectionsCoordinates } from '../../utilities/math/polyline';\nimport pointInShapeCallback from '../../utilities/pointInShapeCallback';\nimport { isViewportPreScaled } from '../../utilities/viewport/isViewportPreScaled';\nimport { getModalityUnit } from '../../utilities/getModalityUnit';\nimport { BasicStatsCalculator } from '../../utilities/math/basic';\nimport calculatePerimeter from '../../utilities/contours/calculatePerimeter';\nimport ContourSegmentationBaseTool from '../base/ContourSegmentationBaseTool';\nimport { KeyboardBindings, ChangeTypes } from '../../enums';\n\nconst { pointCanProjectOnLine } = polyline;\nconst { EPSILON } = CONSTANTS;\n\nconst PARALLEL_THRESHOLD = 1 - EPSILON;\n\n/**\n * PlanarFreehandROITool lets you draw annotations that define an arbitrarily drawn region.\n * You can use the PlanarFreehandROITool in all perpendicular views (axial, sagittal, coronal),\n * support for oblique views is possible, but not yet supported, due to the implementation of\n * `getSubPixelSpacingAndXYDirections`.\n *\n * The resulting annotation's data and metadata (the\n * state of the viewport while drawing was happening) will get added to the\n * ToolState manager and can be accessed from the ToolState by calling getAnnotations\n * or similar methods.\n *\n * PlanarFreehandROITool annotation can be smoothed on drawing completion. This is a configured based approach.\n * The smoothing process uses b-spline algorithm and consider 4 configurations properties:\n * - smoothing.smoothOnAdd: to tell whether it should be smoothed or not (for editing it is considered the property smoothOnEdit) (default: false)\n * - smoothing.smoothOnEdit: to tell whether it should be smoothed or not when editing (default: false)\n * - smoothing.knotsRatioPercentageOnAdd: percentage of points from Segment that are likely to be considered knots during smoothing (for editing it is considered the property knotsRatioPercentageOnEdit) ( default: 40)\n * - smoothing.knotsRatioPercentageOnEdit: same as knotsRatioPercentageOnAdd but applicable only when editing the tool (default: 40)\n *\n * So, with that said the smoothing might occur when:\n * - drawing is done (i.e mouse is released) and smoothing.smoothOnAdd is true. smoothing algorithm uses knotsRatioPercentageOnAdd\n * - edit drawing is done (i.e mouse is released) and smoothing.smoothOnEdit is true. smoothing algorithm uses knotsRatioPercentageOnEdit and its only applied to changed segment\n * smoothing does not occur when:\n * - smoothing.smoothOnAdd is false and drawing is completed\n * - smoothing.smoothOnEdit is false and edit is completed\n * - drawing still happening (editing or not)\n *\n * The result of smoothing will be removal of some of the outliers\n * Changing tool configuration (see below) you can fine-tune the smoothing process by changing knotsRatioPercentageOnAdd and knotsRatioPercentageOnEdit value, which smaller values produces a more agressive smoothing.\n * A smaller value of knotsRatioPercentageOnAdd/knotsRatioPercentageOnEdit produces a more aggressive smoothing.\n *\n * ```js\n * cornerstoneTools.addTool(PlanarFreehandROITool)\n *\n * const toolGroup = ToolGroupManager.createToolGroup('toolGroupId')\n *\n * toolGroup.addTool(PlanarFreehandROITool.toolName)\n *\n * toolGroup.addViewport('viewportId', 'renderingEngineId')\n *\n * toolGroup.setToolActive(PlanarFreehandROITool.toolName, {\n *   bindings: [\n *    {\n *       mouseButton: MouseBindings.Primary, // Left Click\n *     },\n *   ],\n * })\n *\n * // set smoothing aggressiveness while adding new annotation (ps: this does not change if smoothing is ON or OFF)\n * toolGroup.setToolConfiguration(PlanarFreehandROITool.toolName, {\n *   smoothing: { knotsRatioPercentageOnAdd: 30 },\n * });\n *\n * // set smoothing to be ON while editing only\n * toolGroup.setToolConfiguration(PlanarFreehandROITool.toolName, {\n *   smoothing: { smoothOnAdd: false, smoothOnEdit: true  },\n * });\n * ```\n *\n *\n * Read more in the Docs section of the website.\n */\n\nclass PlanarFreehandROITool extends ContourSegmentationBaseTool {\n  static toolName;\n\n  public touchDragCallback: any;\n  public mouseDragCallback: any;\n  _throttledCalculateCachedStats: any;\n  private commonData?: PlanarFreehandROICommonData;\n  isDrawing = false;\n  isEditingClosed = false;\n  isEditingOpen = false;\n\n  protected activateDraw: (\n    evt: EventTypes.InteractionEventType,\n    annotation: PlanarFreehandROIAnnotation,\n    viewportIdsToRender: string[]\n  ) => void;\n  private activateClosedContourEdit: (\n    evt: EventTypes.InteractionEventType,\n    annotation: PlanarFreehandROIAnnotation,\n    viewportIdsToRender: string[]\n  ) => void;\n  private activateOpenContourEdit: (\n    evt: EventTypes.InteractionEventType,\n    annotation: PlanarFreehandROIAnnotation,\n    viewportIdsToRender: string[]\n  ) => void;\n  private activateOpenContourEndEdit: (\n    evt: EventTypes.InteractionEventType,\n    annotation: PlanarFreehandROIAnnotation,\n    viewportIdsToRender: string[],\n    handle: ToolHandle | null\n  ) => void;\n  private cancelDrawing: (element: HTMLDivElement) => void;\n  private cancelClosedContourEdit: (element: HTMLDivElement) => void;\n  private cancelOpenContourEdit: (element: HTMLDivElement) => void;\n\n  private renderContour: (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper,\n    annotation: PlanarFreehandROIAnnotation\n  ) => void;\n  private renderContourBeingDrawn: (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper,\n    annotation: PlanarFreehandROIAnnotation\n  ) => void;\n  private renderClosedContourBeingEdited: (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper,\n    annotation: PlanarFreehandROIAnnotation\n  ) => void;\n  private renderOpenContourBeingEdited: (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper,\n    annotation: PlanarFreehandROIAnnotation\n  ) => void;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        shadow: true,\n        preventHandleOutsideImage: false,\n        /**\n         * Specify which modifier key is used to add a hole to a contour. The\n         * modifier must be pressed when the first point of a new contour is added.\n         */\n        contourHoleAdditionModifierKey: KeyboardBindings.Shift,\n        alwaysRenderOpenContourHandles: {\n          // When true, always render end points when you have an open contour, rather\n          // than just rendering a line.\n          enabled: false,\n          // When enabled, use this radius to draw the endpoints whilst not hovering.\n          radius: 2,\n        },\n        allowOpenContours: true,\n        // Proximity in canvas coordinates used to join contours.\n        closeContourProximity: 10,\n        // The proximity at which we fallback to the simplest grabbing logic for\n        // determining what index of the contour to start editing.\n        checkCanvasEditFallbackProximity: 6,\n        // For closed contours, make them clockwise\n        // This can be useful if contours are compared between slices, eg for\n        // interpolation, and does not cause problems otherwise so defaulting to true.\n        makeClockWise: true,\n        // The relative distance that points should be dropped along the polyline\n        // in units of the image pixel spacing. A value of 1 means that nodes must\n        // be placed no closed than the image spacing apart. A value of 4 means that 4\n        // nodes should be placed within the space of one image pixel size. A higher\n        // value gives more finesse to the tool/smoother lines, but the value cannot\n        // be infinite as the lines become very computationally expensive to draw.\n        subPixelResolution: 4,\n        /**\n         * Smoothing is used to remove jagged irregularities in the polyline,\n         * as opposed to interpolation, which is used to create new polylines\n         * between existing polylines.\n         */\n        smoothing: {\n          smoothOnAdd: false,\n          smoothOnEdit: false, // used for edit only\n          knotsRatioPercentageOnAdd: 40,\n          knotsRatioPercentageOnEdit: 40,\n        },\n        /**\n         * Interpolation is the creation of new segmentations in between the\n         * existing segmentations/indices.  Note that this does not apply to\n         * ROI values, since those annotations are individual annotations, not\n         * connected in any way to each other, whereas segmentations are intended\n         * to be connected 2d + 1 dimension (time or space or other) volumes.\n         */\n        interpolation: {\n          enabled: false,\n          // Callback to update the annotation or perform other action when the\n          // interpolation is complete.\n          onInterpolationComplete: null,\n        },\n        /**\n         * The polyline may get processed in order to reduce the number of points\n         * for better performance and storage.\n         */\n        decimate: {\n          enabled: false,\n          /** A maximum given distance 'epsilon' to decide if a point should or\n           * shouldn't be added the resulting polyline which will have a lower\n           * number of points for higher `epsilon` values.\n           */\n          epsilon: 0.1,\n        },\n        calculateStats: true,\n        getTextLines: defaultGetTextLines,\n        statsCalculator: BasicStatsCalculator,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n\n    // Register event loops and rendering logic, which are stored in different\n    // Files due to their complexity/size.\n    registerDrawLoop(this);\n    registerEditLoopCommon(this);\n    registerClosedContourEditLoop(this);\n    registerOpenContourEditLoop(this);\n    registerOpenContourEndEditLoop(this);\n    registerRenderMethods(this);\n\n    this._throttledCalculateCachedStats = throttle(\n      this._calculateCachedStats,\n      100,\n      { trailing: true }\n    );\n  }\n\n  /**\n   * Based on the current position of the mouse and the current image, creates\n   * a `PlanarFreehandROIAnnotation` and stores it in the annotationManager.\n   *\n   * @param evt - `EventTypes.NormalizedMouseEventType`\n   * @returns The `PlanarFreehandROIAnnotation` object.\n   */\n  addNewAnnotation = (\n    evt: EventTypes.InteractionEventType\n  ): PlanarFreehandROIAnnotation => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    const annotation = this.createAnnotation(\n      evt\n    ) as PlanarFreehandROIAnnotation;\n\n    this.addAnnotation(annotation, element);\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.activateDraw(evt, annotation, viewportIdsToRender);\n\n    evt.preventDefault();\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    return annotation;\n  };\n\n  /**\n   * Begins an edit of an open contour, when the mouse has selected a handle\n   * (end) of the open contour.\n   *\n   * @param evt - `EventTypes.MouseDownEventType`\n   * @param annotation - `PlanarFreehandROIAnnotation` annotation.\n   * @param handle - The handle index, 0 for the start and 1 for the end.\n   * @param interactionType - interaction type (mouse, touch)\n   */\n  handleSelectedCallback = (\n    evt: EventTypes.InteractionEventType,\n    annotation: PlanarFreehandROIAnnotation,\n    handle: ToolHandle\n  ): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.activateOpenContourEndEdit(\n      evt,\n      annotation,\n      viewportIdsToRender,\n      handle\n    );\n  };\n\n  /**\n   * Edits the open or closed contour when the line is grabbed and dragged.\n   */\n  toolSelectedCallback = (\n    evt: EventTypes.InteractionEventType,\n    annotation: PlanarFreehandROIAnnotation\n  ): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    if (annotation.data.contour.closed) {\n      this.activateClosedContourEdit(evt, annotation, viewportIdsToRender);\n    } else {\n      this.activateOpenContourEdit(evt, annotation, viewportIdsToRender);\n    }\n\n    evt.preventDefault();\n  };\n\n  /**\n   * Returns if the canvas point is near the line of the given annotation in the\n   * provided element or not. A proximity is passed to the function to determine the\n   * proximity of the point to the annotation in number of pixels.\n   *\n   * @param element - HTML Element\n   * @param annotation - The `PlanarFreehandROIAnnotation`.\n   * @param canvasCoords - Canvas coordinates\n   * @param proximity - Proximity to tool to consider\n   * @returns Boolean, whether the canvas point is near tool\n   */\n  isPointNearTool = (\n    element: HTMLDivElement,\n    annotation: PlanarFreehandROIAnnotation,\n    canvasCoords: Types.Point2,\n    proximity: number\n  ): boolean => {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n\n    const { polyline: points } = annotation.data.contour;\n\n    // NOTE: It is implemented this way so that we do not double calculate\n    // points when number crunching adjacent line segments.\n    let previousPoint = viewport.worldToCanvas(points[0]);\n\n    for (let i = 1; i < points.length; i++) {\n      const p1 = previousPoint;\n      const p2 = viewport.worldToCanvas(points[i]);\n      const canProject = pointCanProjectOnLine(canvasCoords, p1, p2, proximity);\n\n      if (canProject) {\n        return true;\n      }\n\n      previousPoint = p2;\n    }\n\n    if (!annotation.data.contour.closed) {\n      // Contour is open, don't check last point to first point.\n      return false;\n    }\n\n    // check last point to first point\n    const pStart = viewport.worldToCanvas(points[0]);\n    const pEnd = viewport.worldToCanvas(points[points.length - 1]);\n\n    return pointCanProjectOnLine(canvasCoords, pStart, pEnd, proximity);\n  };\n\n  public cancel = (element: HTMLDivElement): void => {\n    const isDrawing = this.isDrawing;\n    const isEditingOpen = this.isEditingOpen;\n    const isEditingClosed = this.isEditingClosed;\n\n    if (isDrawing) {\n      this.cancelDrawing(element);\n    } else if (isEditingOpen) {\n      this.cancelOpenContourEdit(element);\n    } else if (isEditingClosed) {\n      this.cancelClosedContourEdit(element);\n    }\n  };\n\n  /**\n   * @override We need to override this method as the tool doesn't always have\n   * `handles`, which means `filterAnnotationsForDisplay` fails inside\n   * `filterAnnotationsWithinSlice`.\n   */\n  public filterInteractableAnnotationsForElement(\n    element: HTMLDivElement,\n    annotations: Annotations\n  ): Annotations | undefined {\n    if (!annotations || !annotations.length) {\n      return;\n    }\n\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n\n    let annotationsToDisplay;\n\n    if (viewport instanceof VolumeViewport) {\n      const camera = viewport.getCamera();\n\n      const { spacingInNormalDirection } =\n        csUtils.getTargetVolumeAndSpacingInNormalDir(viewport, camera);\n\n      // Get data with same normal and within the same slice\n      annotationsToDisplay = this.filterAnnotationsWithinSlice(\n        annotations,\n        camera,\n        spacingInNormalDirection\n      );\n    } else {\n      // Use the default `filterAnnotationsForDisplay` utility, as the stack\n      // path doesn't require handles.\n      annotationsToDisplay = filterAnnotationsForDisplay(viewport, annotations);\n    }\n\n    return annotationsToDisplay;\n  }\n\n  /**\n   * Altered version of the `utilities.planar.filterAnnotationsWithinSlice`,\n   * which uses the polyline position rather than the handle. As the polyline is\n   * always present.\n   */\n  private filterAnnotationsWithinSlice(\n    annotations: Annotations,\n    camera: Types.ICamera,\n    spacingInNormalDirection: number\n  ): Annotations {\n    const { viewPlaneNormal } = camera;\n\n    const annotationsWithParallelNormals = annotations.filter(\n      (td: Annotation) => {\n        const annotationViewPlaneNormal = td.metadata.viewPlaneNormal;\n\n        const isParallel =\n          Math.abs(vec3.dot(viewPlaneNormal, annotationViewPlaneNormal)) >\n          PARALLEL_THRESHOLD;\n\n        return annotationViewPlaneNormal && isParallel;\n      }\n    ) as PlanarFreehandROIAnnotation[];\n\n    // No in plane annotations.\n    if (!annotationsWithParallelNormals.length) {\n      return [];\n    }\n\n    // Annotation should be within the slice, which means that it should be between\n    // camera's focalPoint +/- spacingInNormalDirection.\n\n    const halfSpacingInNormalDirection = spacingInNormalDirection / 2;\n    const { focalPoint } = camera;\n\n    const annotationsWithinSlice = [];\n\n    for (const annotation of annotationsWithParallelNormals) {\n      const data = annotation.data;\n      const point = data.contour.polyline[0];\n\n      if (!annotation.isVisible) {\n        continue;\n      }\n\n      // A = point\n      // B = focal point\n      // P = normal\n\n      // B-A dot P  => Distance in the view direction.\n      // this should be less than half the slice distance.\n\n      const dir = vec3.create();\n\n      vec3.sub(dir, focalPoint, point);\n\n      const dot = vec3.dot(dir, viewPlaneNormal);\n\n      if (Math.abs(dot) < halfSpacingInNormalDirection) {\n        annotationsWithinSlice.push(annotation);\n      }\n    }\n\n    return annotationsWithinSlice;\n  }\n\n  protected isContourSegmentationTool(): boolean {\n    // Disable contour segmentation behavior because it shall be activated only\n    // for PlanarFreehandContourSegmentationTool\n    return false;\n  }\n\n  protected createAnnotation(evt: EventTypes.InteractionEventType): Annotation {\n    const worldPos = evt.detail.currentPoints.world;\n    const contourAnnotation = super.createAnnotation(evt);\n\n    const onInterpolationComplete = (annotation) => {\n      // Clear out the handles because they aren't used for straight freeform\n      annotation.data.handles.points.length = 0;\n    };\n\n    const annotation = <PlanarFreehandROIAnnotation>csUtils.deepMerge(\n      contourAnnotation,\n      {\n        data: {\n          contour: {\n            polyline: [<Types.Point3>[...worldPos]],\n          },\n          label: '',\n          cachedStats: {},\n        },\n        onInterpolationComplete,\n      }\n    );\n\n    return annotation;\n  }\n\n  protected getAnnotationStyle(context) {\n    // This method exists only because `super` cannot be called from\n    // _getRenderingOptions() which is in an external file.\n    return super.getAnnotationStyle(context);\n  }\n\n  protected renderAnnotationInstance(\n    renderContext: AnnotationRenderContext\n  ): boolean {\n    const { enabledElement, targetId, svgDrawingHelper } = renderContext;\n    const annotation = renderContext.annotation as PlanarFreehandROIAnnotation;\n\n    let renderStatus = false;\n    const { viewport, renderingEngine } = enabledElement;\n\n    const isDrawing = this.isDrawing;\n    const isEditingOpen = this.isEditingOpen;\n    const isEditingClosed = this.isEditingClosed;\n\n    if (!(isDrawing || isEditingOpen || isEditingClosed)) {\n      // No annotations are currently being modified, so we can just use the\n      // render contour method to render all of them\n      this.renderContour(enabledElement, svgDrawingHelper, annotation);\n    } else {\n      // The active annotation will need special rendering treatment. Render all\n      // other annotations not being interacted with using the standard renderContour\n      // rendering path.\n      const activeAnnotationUID = this.commonData.annotation.annotationUID;\n\n      if (annotation.annotationUID === activeAnnotationUID) {\n        if (isDrawing) {\n          this.renderContourBeingDrawn(\n            enabledElement,\n            svgDrawingHelper,\n            annotation\n          );\n        } else if (isEditingClosed) {\n          this.renderClosedContourBeingEdited(\n            enabledElement,\n            svgDrawingHelper,\n            annotation\n          );\n        } else if (isEditingOpen) {\n          this.renderOpenContourBeingEdited(\n            enabledElement,\n            svgDrawingHelper,\n            annotation\n          );\n        } else {\n          throw new Error(\n            `Unknown ${this.getToolName()} annotation rendering state`\n          );\n        }\n      } else {\n        this.renderContour(enabledElement, svgDrawingHelper, annotation);\n      }\n\n      // Todo: return boolean flag for each rendering route in the planar tool.\n      renderStatus = true;\n    }\n\n    if (!this.configuration.calculateStats) {\n      return;\n    }\n\n    this._calculateStatsIfActive(\n      annotation,\n      targetId,\n      viewport,\n      renderingEngine,\n      enabledElement\n    );\n\n    this._renderStats(annotation, viewport, enabledElement, svgDrawingHelper);\n\n    return renderStatus;\n  }\n\n  _calculateStatsIfActive(\n    annotation: PlanarFreehandROIAnnotation,\n    targetId: string,\n    viewport,\n    renderingEngine,\n    enabledElement\n  ) {\n    const activeAnnotationUID = this.commonData?.annotation.annotationUID;\n\n    if (\n      annotation.annotationUID === activeAnnotationUID &&\n      !this.commonData?.movingTextBox\n    ) {\n      return;\n    }\n\n    if (!this.commonData?.movingTextBox) {\n      const { data } = annotation;\n      if (\n        !data.cachedStats[targetId] ||\n        data.cachedStats[targetId].areaUnit == null\n      ) {\n        data.cachedStats[targetId] = {\n          Modality: null,\n          area: null,\n          max: null,\n          mean: null,\n          stdDev: null,\n          areaUnit: null,\n        };\n\n        this._calculateCachedStats(\n          annotation,\n          viewport,\n          renderingEngine,\n          enabledElement\n        );\n      } else if (annotation.invalidated) {\n        this._throttledCalculateCachedStats(\n          annotation,\n          viewport,\n          renderingEngine,\n          enabledElement\n        );\n      }\n    }\n  }\n\n  private _calculateCachedStats = (\n    annotation,\n    viewport,\n    renderingEngine,\n    enabledElement\n  ) => {\n    const { data } = annotation;\n    const { cachedStats } = data;\n    const { polyline: points, closed } = data.contour;\n\n    const targetIds = Object.keys(cachedStats);\n\n    for (let i = 0; i < targetIds.length; i++) {\n      const targetId = targetIds[i];\n      const image = this.getTargetIdImage(targetId, renderingEngine);\n\n      // If image does not exists for the targetId, skip. This can be due\n      // to various reasons such as if the target was a volumeViewport, and\n      // the volumeViewport has been decached in the meantime.\n      if (!image) {\n        continue;\n      }\n\n      const { imageData, metadata } = image;\n      const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n\n      // Using an arbitrary start point (canvasPoint), calculate the\n      // mm spacing for the canvas in the X and Y directions.\n      const canvasPoint = canvasCoordinates[0];\n      const originalWorldPoint = viewport.canvasToWorld(canvasPoint);\n      const deltaXPoint = viewport.canvasToWorld([\n        canvasPoint[0] + 1,\n        canvasPoint[1],\n      ]);\n      const deltaYPoint = viewport.canvasToWorld([\n        canvasPoint[0],\n        canvasPoint[1] + 1,\n      ]);\n\n      const deltaInX = vec3.distance(originalWorldPoint, deltaXPoint);\n      const deltaInY = vec3.distance(originalWorldPoint, deltaYPoint);\n\n      const worldPosIndex = csUtils.transformWorldToIndex(imageData, points[0]);\n      worldPosIndex[0] = Math.floor(worldPosIndex[0]);\n      worldPosIndex[1] = Math.floor(worldPosIndex[1]);\n      worldPosIndex[2] = Math.floor(worldPosIndex[2]);\n\n      let iMin = worldPosIndex[0];\n      let iMax = worldPosIndex[0];\n\n      let jMin = worldPosIndex[1];\n      let jMax = worldPosIndex[1];\n\n      let kMin = worldPosIndex[2];\n      let kMax = worldPosIndex[2];\n\n      for (let j = 1; j < points.length; j++) {\n        const worldPosIndex = csUtils.transformWorldToIndex(\n          imageData,\n          points[j]\n        );\n        worldPosIndex[0] = Math.floor(worldPosIndex[0]);\n        worldPosIndex[1] = Math.floor(worldPosIndex[1]);\n        worldPosIndex[2] = Math.floor(worldPosIndex[2]);\n        iMin = Math.min(iMin, worldPosIndex[0]);\n        iMax = Math.max(iMax, worldPosIndex[0]);\n\n        jMin = Math.min(jMin, worldPosIndex[1]);\n        jMax = Math.max(jMax, worldPosIndex[1]);\n\n        kMin = Math.min(kMin, worldPosIndex[2]);\n        kMax = Math.max(kMax, worldPosIndex[2]);\n      }\n\n      const worldPosIndex2 = csUtils.transformWorldToIndex(\n        imageData,\n        points[1]\n      );\n      worldPosIndex2[0] = Math.floor(worldPosIndex2[0]);\n      worldPosIndex2[1] = Math.floor(worldPosIndex2[1]);\n      worldPosIndex2[2] = Math.floor(worldPosIndex2[2]);\n\n      const { scale, areaUnits } = getCalibratedLengthUnitsAndScale(\n        image,\n        () => {\n          const polyline = data.contour.polyline;\n          const numPoints = polyline.length;\n          const projectedPolyline = new Array(numPoints);\n\n          for (let i = 0; i < numPoints; i++) {\n            projectedPolyline[i] = viewport.worldToCanvas(polyline[i]);\n          }\n\n          const {\n            maxX: canvasMaxX,\n            maxY: canvasMaxY,\n            minX: canvasMinX,\n            minY: canvasMinY,\n          } = math.polyline.getAABB(projectedPolyline);\n\n          const topLeftBBWorld = viewport.canvasToWorld([\n            canvasMinX,\n            canvasMinY,\n          ]);\n\n          const topLeftBBIndex = csUtils.transformWorldToIndex(\n            imageData,\n            topLeftBBWorld\n          );\n\n          const bottomRightBBWorld = viewport.canvasToWorld([\n            canvasMaxX,\n            canvasMaxY,\n          ]);\n\n          const bottomRightBBIndex = csUtils.transformWorldToIndex(\n            imageData,\n            bottomRightBBWorld\n          );\n\n          return [topLeftBBIndex, bottomRightBBIndex];\n        }\n      );\n      let area = polyline.getArea(canvasCoordinates) / scale / scale;\n      // Convert from canvas_pixels ^2 to mm^2\n      area *= deltaInX * deltaInY;\n\n      // Expand bounding box\n      const iDelta = 0.01 * (iMax - iMin);\n      const jDelta = 0.01 * (jMax - jMin);\n      const kDelta = 0.01 * (kMax - kMin);\n\n      iMin = Math.floor(iMin - iDelta);\n      iMax = Math.ceil(iMax + iDelta);\n      jMin = Math.floor(jMin - jDelta);\n      jMax = Math.ceil(jMax + jDelta);\n      kMin = Math.floor(kMin - kDelta);\n      kMax = Math.ceil(kMax + kDelta);\n\n      const boundsIJK = [\n        [iMin, iMax],\n        [jMin, jMax],\n        [kMin, kMax],\n      ] as [Types.Point2, Types.Point2, Types.Point2];\n\n      const worldPosEnd = imageData.indexToWorld([iMax, jMax, kMax]);\n      const canvasPosEnd = viewport.worldToCanvas(worldPosEnd);\n\n      let curRow = 0;\n      let intersections = [];\n      let intersectionCounter = 0;\n      const pointsInShape = pointInShapeCallback(\n        imageData,\n        (pointLPS, pointIJK) => {\n          let result = true;\n          const point = viewport.worldToCanvas(pointLPS);\n          if (point[1] != curRow) {\n            intersectionCounter = 0;\n            curRow = point[1];\n            intersections = getLineSegmentIntersectionsCoordinates(\n              canvasCoordinates,\n              point,\n              [canvasPosEnd[0], point[1]]\n            );\n            intersections.sort(\n              (function (index) {\n                return function (a, b) {\n                  return a[index] === b[index]\n                    ? 0\n                    : a[index] < b[index]\n                    ? -1\n                    : 1;\n                };\n              })(0)\n            );\n          }\n          if (intersections.length && point[0] > intersections[0][0]) {\n            intersections.shift();\n            intersectionCounter++;\n          }\n          if (intersectionCounter % 2 === 0) {\n            result = false;\n          }\n          return result;\n        },\n        this.configuration.statsCalculator.statsCallback,\n        boundsIJK\n      );\n\n      const modalityUnitOptions = {\n        isPreScaled: isViewportPreScaled(viewport, targetId),\n        isSuvScaled: this.isSuvScaled(\n          viewport,\n          targetId,\n          annotation.metadata.referencedImageId\n        ),\n      };\n\n      const modalityUnit = getModalityUnit(\n        metadata.Modality,\n        annotation.metadata.referencedImageId,\n        modalityUnitOptions\n      );\n\n      const stats = this.configuration.statsCalculator.getStatistics();\n\n      cachedStats[targetId] = {\n        Modality: metadata.Modality,\n        area,\n        perimeter: calculatePerimeter(canvasCoordinates, closed),\n        mean: stats.mean?.value,\n        max: stats.max?.value,\n        stdDev: stats.stdDev?.value,\n        statsArray: stats.array,\n        pointsInShape: pointsInShape,\n        areaUnit: areaUnits,\n        modalityUnit,\n      };\n    }\n\n    triggerAnnotationModified(\n      annotation,\n      enabledElement.viewport.element,\n      ChangeTypes.StatsUpdated\n    );\n\n    annotation.invalidated = false;\n\n    return cachedStats;\n  };\n\n  private _renderStats = (\n    annotation,\n    viewport,\n    enabledElement,\n    svgDrawingHelper\n  ) => {\n    const { data } = <PlanarFreehandROIAnnotation>annotation;\n    const targetId = this.getTargetId(viewport);\n\n    const styleSpecifier: AnnotationStyle.StyleSpecifier = {\n      toolGroupId: this.toolGroupId,\n      toolName: this.getToolName(),\n      viewportId: enabledElement.viewport.id,\n    };\n\n    const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n    if (!options.visibility) {\n      return;\n    }\n\n    const textLines = this.configuration.getTextLines(data, targetId);\n    if (!textLines || textLines.length === 0) {\n      return;\n    }\n\n    const canvasCoordinates = data.contour.polyline.map((p) =>\n      viewport.worldToCanvas(p)\n    );\n    if (!data.handles.textBox.hasMoved) {\n      const canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCoordinates);\n\n      data.handles.textBox.worldPosition =\n        viewport.canvasToWorld(canvasTextBoxCoords);\n    }\n\n    const textBoxPosition = viewport.worldToCanvas(\n      data.handles.textBox.worldPosition\n    );\n\n    const textBoxUID = '1';\n    const boundingBox = drawLinkedTextBox(\n      svgDrawingHelper,\n      annotation.annotationUID ?? '',\n      textBoxUID,\n      textLines,\n      textBoxPosition,\n      canvasCoordinates,\n      {},\n      options\n    );\n\n    const { x: left, y: top, width, height } = boundingBox;\n\n    data.handles.textBox.worldBoundingBox = {\n      topLeft: viewport.canvasToWorld([left, top]),\n      topRight: viewport.canvasToWorld([left + width, top]),\n      bottomLeft: viewport.canvasToWorld([left, top + height]),\n      bottomRight: viewport.canvasToWorld([left + width, top + height]),\n    };\n  };\n}\n\nfunction defaultGetTextLines(data, targetId): string[] {\n  const cachedVolumeStats = data.cachedStats[targetId];\n  const {\n    area,\n    mean,\n    stdDev,\n    perimeter,\n    max,\n    isEmptyArea,\n    areaUnit,\n    modalityUnit,\n  } = cachedVolumeStats || {};\n\n  const textLines: string[] = [];\n\n  if (area) {\n    const areaLine = isEmptyArea\n      ? `Area: Oblique not supported`\n      : `Area: ${roundNumber(area)} ${areaUnit}`;\n    textLines.push(areaLine);\n  }\n\n  if (mean) {\n    textLines.push(`Mean: ${roundNumber(mean)} ${modalityUnit}`);\n  }\n\n  if (max) {\n    textLines.push(`Max: ${roundNumber(max)} ${modalityUnit}`);\n  }\n\n  if (stdDev) {\n    textLines.push(`Std Dev: ${roundNumber(stdDev)} ${modalityUnit}`);\n  }\n\n  if (perimeter) {\n    textLines.push(`Perimeter: ${roundNumber(perimeter)} ${modalityUnit}`);\n  }\n\n  return textLines;\n}\n\nPlanarFreehandROITool.toolName = 'PlanarFreehandROI';\nexport default PlanarFreehandROITool;\n","import {\n  getEnabledElementByIds,\n  Types,\n  utilities as csUtils,\n} from '@cornerstonejs/core';\nimport Representations from '../../enums/SegmentationRepresentations';\nimport { config as segmentationConfig } from '../../stateManagement/segmentation';\nimport { setSegmentationVisibility } from '../../stateManagement/segmentation/config/segmentationVisibility';\nimport { getSegmentationRepresentations } from '../../stateManagement/segmentation/segmentationState';\nimport { getToolGroup } from '../../store/ToolGroupManager';\nimport { PublicToolProps, ToolProps } from '../../types';\nimport { BaseTool } from '../base';\n\nimport {\n  SegmentationRepresentationConfig,\n  ToolGroupSpecificRepresentation,\n} from '../../types/SegmentationStateTypes';\nimport { surfaceDisplay } from './Surface';\nimport { contourDisplay } from './Contour';\nimport { labelmapDisplay } from './Labelmap';\nimport SegmentationRepresentations from '../../enums/SegmentationRepresentations';\nimport { addTool, state } from '../../store';\nimport PlanarFreehandContourSegmentationTool from '../annotation/PlanarFreehandContourSegmentationTool';\n\nconst planarContourToolName = PlanarFreehandContourSegmentationTool.toolName;\n/**\n * In Cornerstone3DTools, displaying of segmentations are handled by the SegmentationDisplayTool.\n * Generally, any Segmentation can be viewed in various representations such as\n * labelmap (3d), contours, surface etc. As of now, Cornerstone3DTools only implements\n * Labelmap representation.\n *\n * SegmentationDisplayTool works at ToolGroup level, and is responsible for displaying the\n * segmentation representation for ALL viewports of a toolGroup, this way we can support complex\n * scenarios for displaying segmentations.\n *\n * Current Limitations:\n * - Only supports rendering of the volumetric segmentations in 3D space. (StackViewport segmentations are not supported yet)\n * - Labelmap representation is the only supported representation for now.\n *\n * Similar to other tools in Cornerstone3DTools, the SegmentationDisplayTool should\n * be added to the CornerstoneTools by calling cornerstoneTools.addTool(SegmentationDisplayTool)\n * and a toolGroup should be created for it using the ToolGroupManager API, finally\n * viewports information such as viewportId and renderingEngineId should be provided\n * to the toolGroup and the SegmentationDisplayTool should be set to be activated.\n *\n *\n */\nclass SegmentationDisplayTool extends BaseTool {\n  static toolName;\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      configuration: {},\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n  }\n\n  onSetToolEnabled(): void {\n    const toolGroupId = this.toolGroupId;\n    const toolGroupSegmentationRepresentations =\n      getSegmentationRepresentations(toolGroupId);\n\n    if (\n      !toolGroupSegmentationRepresentations ||\n      toolGroupSegmentationRepresentations.length === 0\n    ) {\n      return;\n    }\n\n    // for each segmentationData, make the visibility true\n    toolGroupSegmentationRepresentations.forEach(\n      (segmentationRepresentation) => {\n        setSegmentationVisibility(\n          toolGroupId,\n          segmentationRepresentation.segmentationRepresentationUID,\n          true\n        );\n      }\n    );\n  }\n\n  onSetToolDisabled(): void {\n    const toolGroupId = this.toolGroupId;\n    const toolGroupSegmentationRepresentations =\n      getSegmentationRepresentations(toolGroupId);\n\n    if (\n      !toolGroupSegmentationRepresentations ||\n      toolGroupSegmentationRepresentations.length === 0\n    ) {\n      return;\n    }\n\n    // for each segmentationData, make the visibility false\n    toolGroupSegmentationRepresentations.forEach(\n      (segmentationRepresentation) => {\n        setSegmentationVisibility(\n          toolGroupId,\n          segmentationRepresentation.segmentationRepresentationUID,\n          false\n        );\n      }\n    );\n  }\n\n  /**\n   * It is used to trigger the render for each segmentations in the toolGroup.\n   * Based on the segmentation representation type, it will call the corresponding\n   * render function.\n   *\n   * @param toolGroupId - the toolGroupId\n   */\n  renderSegmentation = (toolGroupId: string): void => {\n    const toolGroup = getToolGroup(toolGroupId);\n\n    if (!toolGroup) {\n      return;\n    }\n\n    const toolGroupSegmentationRepresentations =\n      getSegmentationRepresentations(toolGroupId);\n\n    if (\n      !toolGroupSegmentationRepresentations ||\n      toolGroupSegmentationRepresentations.length === 0\n    ) {\n      return;\n    }\n\n    // toolGroup Viewports\n    const toolGroupViewports = toolGroup.viewportsInfo.map(\n      ({ renderingEngineId, viewportId }) => {\n        const enabledElement = getEnabledElementByIds(\n          viewportId,\n          renderingEngineId\n        );\n\n        if (enabledElement) {\n          return enabledElement.viewport;\n        }\n      }\n    );\n\n    // Render each segmentationData, in each viewport in the toolGroup\n    const segmentationRenderList = toolGroupSegmentationRepresentations.map(\n      (representation: ToolGroupSpecificRepresentation) => {\n        const config = this._getMergedRepresentationsConfig(toolGroupId);\n\n        const viewportsRenderList = [];\n\n        const renderers = {\n          [Representations.Labelmap]: labelmapDisplay,\n          [Representations.Contour]: contourDisplay,\n          [Representations.Surface]: surfaceDisplay,\n        };\n\n        if (representation.type === SegmentationRepresentations.Contour) {\n          // if the representation is contour we need to make sure\n          // that the planarFreeHandTool is added to the toolGroup\n          this.addPlanarFreeHandToolIfAbsent(toolGroupId);\n        }\n\n        const display = renderers[representation.type];\n\n        for (const viewport of toolGroupViewports) {\n          const renderedViewport = display.render(\n            viewport as Types.IVolumeViewport,\n            representation,\n            config\n          );\n\n          viewportsRenderList.push(renderedViewport);\n        }\n        return viewportsRenderList;\n      }\n    );\n\n    Promise.allSettled(segmentationRenderList).then(() => {\n      // for all viewports in the toolGroup trigger a re-render\n      toolGroupViewports.forEach((viewport) => {\n        viewport.render();\n      });\n    });\n  };\n\n  addPlanarFreeHandToolIfAbsent(toolGroupId) {\n    // if it is contour we should check if the toolGroup and more importantly\n    // the cornerstoneTools have the planarFreeHandTool added\n    if (!(planarContourToolName in state.tools)) {\n      addTool(PlanarFreehandContourSegmentationTool);\n    }\n\n    const toolGroup = getToolGroup(toolGroupId);\n\n    // check if toolGroup has this tool\n    if (!toolGroup.hasTool(planarContourToolName)) {\n      toolGroup.addTool(planarContourToolName);\n      toolGroup.setToolPassive(planarContourToolName);\n    }\n  }\n\n  /**\n   * Merge the toolGroup specific configuration with the default global configuration\n   * @param toolGroupId\n   * @returns\n   */\n  _getMergedRepresentationsConfig(\n    toolGroupId: string\n  ): SegmentationRepresentationConfig {\n    const toolGroupConfig =\n      segmentationConfig.getToolGroupSpecificConfig(toolGroupId);\n    const globalConfig = segmentationConfig.getGlobalConfig();\n\n    // merge two configurations and override the global config\n    const mergedConfig = csUtils.deepMerge(globalConfig, toolGroupConfig);\n\n    return mergedConfig;\n  }\n}\n\nSegmentationDisplayTool.toolName = 'SegmentationDisplay';\nexport default SegmentationDisplayTool;\n","/**\n * lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright jQuery Foundation and other contributors <https://jquery.org/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** Used as the `TypeError` message for \"Functions\" methods. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0;\n\n/** `Object#toString` result references. */\nvar funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    symbolTag = '[object Symbol]';\n\n/** Used to match property names within property paths. */\nvar reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/,\n    reIsPlainProp = /^\\w*$/,\n    reLeadingDot = /^\\./,\n    rePropName = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g;\n\n/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n */\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n\n/** Used to match backslashes in property paths. */\nvar reEscapeChar = /\\\\(\\\\)?/g;\n\n/** Used to detect host constructors (Safari). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\n/**\n * Gets the value at `key` of `object`.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction getValue(object, key) {\n  return object == null ? undefined : object[key];\n}\n\n/**\n * Checks if `value` is a host object in IE < 9.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a host object, else `false`.\n */\nfunction isHostObject(value) {\n  // Many host objects are `Object` objects that can coerce to strings\n  // despite having improperly defined `toString` methods.\n  var result = false;\n  if (value != null && typeof value.toString != 'function') {\n    try {\n      result = !!(value + '');\n    } catch (e) {}\n  }\n  return result;\n}\n\n/** Used for built-in method references. */\nvar arrayProto = Array.prototype,\n    funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to detect overreaching core-js shims. */\nvar coreJsData = root['__core-js_shared__'];\n\n/** Used to detect methods masquerading as native. */\nvar maskSrcKey = (function() {\n  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n  return uid ? ('Symbol(src)_1.' + uid) : '';\n}());\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objectToString = objectProto.toString;\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/** Built-in value references. */\nvar Symbol = root.Symbol,\n    splice = arrayProto.splice;\n\n/* Built-in method references that are verified to be native. */\nvar Map = getNative(root, 'Map'),\n    nativeCreate = getNative(Object, 'create');\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolToString = symbolProto ? symbolProto.toString : undefined;\n\n/**\n * Creates a hash object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Hash(entries) {\n  var index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the hash.\n *\n * @private\n * @name clear\n * @memberOf Hash\n */\nfunction hashClear() {\n  this.__data__ = nativeCreate ? nativeCreate(null) : {};\n}\n\n/**\n * Removes `key` and its value from the hash.\n *\n * @private\n * @name delete\n * @memberOf Hash\n * @param {Object} hash The hash to modify.\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction hashDelete(key) {\n  return this.has(key) && delete this.__data__[key];\n}\n\n/**\n * Gets the hash value for `key`.\n *\n * @private\n * @name get\n * @memberOf Hash\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction hashGet(key) {\n  var data = this.__data__;\n  if (nativeCreate) {\n    var result = data[key];\n    return result === HASH_UNDEFINED ? undefined : result;\n  }\n  return hasOwnProperty.call(data, key) ? data[key] : undefined;\n}\n\n/**\n * Checks if a hash value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Hash\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction hashHas(key) {\n  var data = this.__data__;\n  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);\n}\n\n/**\n * Sets the hash `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Hash\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the hash instance.\n */\nfunction hashSet(key, value) {\n  var data = this.__data__;\n  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\n  return this;\n}\n\n// Add methods to `Hash`.\nHash.prototype.clear = hashClear;\nHash.prototype['delete'] = hashDelete;\nHash.prototype.get = hashGet;\nHash.prototype.has = hashHas;\nHash.prototype.set = hashSet;\n\n/**\n * Creates an list cache object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction ListCache(entries) {\n  var index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the list cache.\n *\n * @private\n * @name clear\n * @memberOf ListCache\n */\nfunction listCacheClear() {\n  this.__data__ = [];\n}\n\n/**\n * Removes `key` and its value from the list cache.\n *\n * @private\n * @name delete\n * @memberOf ListCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction listCacheDelete(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    return false;\n  }\n  var lastIndex = data.length - 1;\n  if (index == lastIndex) {\n    data.pop();\n  } else {\n    splice.call(data, index, 1);\n  }\n  return true;\n}\n\n/**\n * Gets the list cache value for `key`.\n *\n * @private\n * @name get\n * @memberOf ListCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction listCacheGet(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  return index < 0 ? undefined : data[index][1];\n}\n\n/**\n * Checks if a list cache value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf ListCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction listCacheHas(key) {\n  return assocIndexOf(this.__data__, key) > -1;\n}\n\n/**\n * Sets the list cache `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf ListCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the list cache instance.\n */\nfunction listCacheSet(key, value) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    data.push([key, value]);\n  } else {\n    data[index][1] = value;\n  }\n  return this;\n}\n\n// Add methods to `ListCache`.\nListCache.prototype.clear = listCacheClear;\nListCache.prototype['delete'] = listCacheDelete;\nListCache.prototype.get = listCacheGet;\nListCache.prototype.has = listCacheHas;\nListCache.prototype.set = listCacheSet;\n\n/**\n * Creates a map cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction MapCache(entries) {\n  var index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the map.\n *\n * @private\n * @name clear\n * @memberOf MapCache\n */\nfunction mapCacheClear() {\n  this.__data__ = {\n    'hash': new Hash,\n    'map': new (Map || ListCache),\n    'string': new Hash\n  };\n}\n\n/**\n * Removes `key` and its value from the map.\n *\n * @private\n * @name delete\n * @memberOf MapCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction mapCacheDelete(key) {\n  return getMapData(this, key)['delete'](key);\n}\n\n/**\n * Gets the map value for `key`.\n *\n * @private\n * @name get\n * @memberOf MapCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction mapCacheGet(key) {\n  return getMapData(this, key).get(key);\n}\n\n/**\n * Checks if a map value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf MapCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction mapCacheHas(key) {\n  return getMapData(this, key).has(key);\n}\n\n/**\n * Sets the map `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf MapCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the map cache instance.\n */\nfunction mapCacheSet(key, value) {\n  getMapData(this, key).set(key, value);\n  return this;\n}\n\n// Add methods to `MapCache`.\nMapCache.prototype.clear = mapCacheClear;\nMapCache.prototype['delete'] = mapCacheDelete;\nMapCache.prototype.get = mapCacheGet;\nMapCache.prototype.has = mapCacheHas;\nMapCache.prototype.set = mapCacheSet;\n\n/**\n * Gets the index at which the `key` is found in `array` of key-value pairs.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} key The key to search for.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction assocIndexOf(array, key) {\n  var length = array.length;\n  while (length--) {\n    if (eq(array[length][0], key)) {\n      return length;\n    }\n  }\n  return -1;\n}\n\n/**\n * The base implementation of `_.get` without support for default values.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @returns {*} Returns the resolved value.\n */\nfunction baseGet(object, path) {\n  path = isKey(path, object) ? [path] : castPath(path);\n\n  var index = 0,\n      length = path.length;\n\n  while (object != null && index < length) {\n    object = object[toKey(path[index++])];\n  }\n  return (index && index == length) ? object : undefined;\n}\n\n/**\n * The base implementation of `_.isNative` without bad shim checks.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function,\n *  else `false`.\n */\nfunction baseIsNative(value) {\n  if (!isObject(value) || isMasked(value)) {\n    return false;\n  }\n  var pattern = (isFunction(value) || isHostObject(value)) ? reIsNative : reIsHostCtor;\n  return pattern.test(toSource(value));\n}\n\n/**\n * The base implementation of `_.toString` which doesn't convert nullish\n * values to empty strings.\n *\n * @private\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n */\nfunction baseToString(value) {\n  // Exit early for strings to avoid a performance hit in some environments.\n  if (typeof value == 'string') {\n    return value;\n  }\n  if (isSymbol(value)) {\n    return symbolToString ? symbolToString.call(value) : '';\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\n/**\n * Casts `value` to a path array if it's not one.\n *\n * @private\n * @param {*} value The value to inspect.\n * @returns {Array} Returns the cast property path array.\n */\nfunction castPath(value) {\n  return isArray(value) ? value : stringToPath(value);\n}\n\n/**\n * Gets the data for `map`.\n *\n * @private\n * @param {Object} map The map to query.\n * @param {string} key The reference key.\n * @returns {*} Returns the map data.\n */\nfunction getMapData(map, key) {\n  var data = map.__data__;\n  return isKeyable(key)\n    ? data[typeof key == 'string' ? 'string' : 'hash']\n    : data.map;\n}\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  var value = getValue(object, key);\n  return baseIsNative(value) ? value : undefined;\n}\n\n/**\n * Checks if `value` is a property name and not a property path.\n *\n * @private\n * @param {*} value The value to check.\n * @param {Object} [object] The object to query keys on.\n * @returns {boolean} Returns `true` if `value` is a property name, else `false`.\n */\nfunction isKey(value, object) {\n  if (isArray(value)) {\n    return false;\n  }\n  var type = typeof value;\n  if (type == 'number' || type == 'symbol' || type == 'boolean' ||\n      value == null || isSymbol(value)) {\n    return true;\n  }\n  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||\n    (object != null && value in Object(object));\n}\n\n/**\n * Checks if `value` is suitable for use as unique object key.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n */\nfunction isKeyable(value) {\n  var type = typeof value;\n  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n    ? (value !== '__proto__')\n    : (value === null);\n}\n\n/**\n * Checks if `func` has its source masked.\n *\n * @private\n * @param {Function} func The function to check.\n * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n */\nfunction isMasked(func) {\n  return !!maskSrcKey && (maskSrcKey in func);\n}\n\n/**\n * Converts `string` to a property path array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the property path array.\n */\nvar stringToPath = memoize(function(string) {\n  string = toString(string);\n\n  var result = [];\n  if (reLeadingDot.test(string)) {\n    result.push('');\n  }\n  string.replace(rePropName, function(match, number, quote, string) {\n    result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));\n  });\n  return result;\n});\n\n/**\n * Converts `value` to a string key if it's not a string or symbol.\n *\n * @private\n * @param {*} value The value to inspect.\n * @returns {string|symbol} Returns the key.\n */\nfunction toKey(value) {\n  if (typeof value == 'string' || isSymbol(value)) {\n    return value;\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\n/**\n * Converts `func` to its source code.\n *\n * @private\n * @param {Function} func The function to process.\n * @returns {string} Returns the source code.\n */\nfunction toSource(func) {\n  if (func != null) {\n    try {\n      return funcToString.call(func);\n    } catch (e) {}\n    try {\n      return (func + '');\n    } catch (e) {}\n  }\n  return '';\n}\n\n/**\n * Creates a function that memoizes the result of `func`. If `resolver` is\n * provided, it determines the cache key for storing the result based on the\n * arguments provided to the memoized function. By default, the first argument\n * provided to the memoized function is used as the map cache key. The `func`\n * is invoked with the `this` binding of the memoized function.\n *\n * **Note:** The cache is exposed as the `cache` property on the memoized\n * function. Its creation may be customized by replacing the `_.memoize.Cache`\n * constructor with one whose instances implement the\n * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)\n * method interface of `delete`, `get`, `has`, and `set`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to have its output memoized.\n * @param {Function} [resolver] The function to resolve the cache key.\n * @returns {Function} Returns the new memoized function.\n * @example\n *\n * var object = { 'a': 1, 'b': 2 };\n * var other = { 'c': 3, 'd': 4 };\n *\n * var values = _.memoize(_.values);\n * values(object);\n * // => [1, 2]\n *\n * values(other);\n * // => [3, 4]\n *\n * object.a = 2;\n * values(object);\n * // => [1, 2]\n *\n * // Modify the result cache.\n * values.cache.set(object, ['a', 'b']);\n * values(object);\n * // => ['a', 'b']\n *\n * // Replace `_.memoize.Cache`.\n * _.memoize.Cache = WeakMap;\n */\nfunction memoize(func, resolver) {\n  if (typeof func != 'function' || (resolver && typeof resolver != 'function')) {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  var memoized = function() {\n    var args = arguments,\n        key = resolver ? resolver.apply(this, args) : args[0],\n        cache = memoized.cache;\n\n    if (cache.has(key)) {\n      return cache.get(key);\n    }\n    var result = func.apply(this, args);\n    memoized.cache = cache.set(key, result);\n    return result;\n  };\n  memoized.cache = new (memoize.Cache || MapCache);\n  return memoized;\n}\n\n// Assign cache to `_.memoize`.\nmemoize.Cache = MapCache;\n\n/**\n * Performs a\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * comparison between two values to determine if they are equivalent.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.eq(object, object);\n * // => true\n *\n * _.eq(object, other);\n * // => false\n *\n * _.eq('a', 'a');\n * // => true\n *\n * _.eq('a', Object('a'));\n * // => false\n *\n * _.eq(NaN, NaN);\n * // => true\n */\nfunction eq(value, other) {\n  return value === other || (value !== value && other !== other);\n}\n\n/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 8-9 which returns 'object' for typed array and other constructors.\n  var tag = isObject(value) ? objectToString.call(value) : '';\n  return tag == funcTag || tag == genTag;\n}\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return !!value && (type == 'object' || type == 'function');\n}\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return !!value && typeof value == 'object';\n}\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && objectToString.call(value) == symbolTag);\n}\n\n/**\n * Converts `value` to a string. An empty string is returned for `null`\n * and `undefined` values. The sign of `-0` is preserved.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n * @example\n *\n * _.toString(null);\n * // => ''\n *\n * _.toString(-0);\n * // => '-0'\n *\n * _.toString([1, 2, 3]);\n * // => '1,2,3'\n */\nfunction toString(value) {\n  return value == null ? '' : baseToString(value);\n}\n\n/**\n * Gets the value at `path` of `object`. If the resolved value is\n * `undefined`, the `defaultValue` is returned in its place.\n *\n * @static\n * @memberOf _\n * @since 3.7.0\n * @category Object\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @param {*} [defaultValue] The value returned for `undefined` resolved values.\n * @returns {*} Returns the resolved value.\n * @example\n *\n * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n *\n * _.get(object, 'a[0].b.c');\n * // => 3\n *\n * _.get(object, ['a', '0', 'b', 'c']);\n * // => 3\n *\n * _.get(object, 'a.b.c', 'default');\n * // => 'default'\n */\nfunction get(object, path, defaultValue) {\n  var result = object == null ? undefined : baseGet(object, path);\n  return result === undefined ? defaultValue : result;\n}\n\nmodule.exports = get;\n"],"names":["VIEWPORT_ELEMENT","getSvgNode","canvasHash","cacheKey","svgNodeCache","domRef","appendNode","svgLayerElement","svgNode","touched","appendChild","setNodeTouched","clearUntouched","Object","keys","forEach","cacheEntry","removeChild","element","enabledElement","getEnabledElement","viewportId","renderingEngineId","viewportElement","internalDivElement","querySelector","_getSvgLayer","svgNodeCacheForCanvas","bind","this","fn","svgDrawingHelper","ToolModes","Active","Passive","Enabled","Disabled","PRIMARY_BINDINGS","mouseButton","MouseBindings","Primary","ToolGroup","constructor","id","viewportsInfo","toolOptions","currentActivePrimaryToolName","prevActivePrimaryToolName","restoreToolOptions","_toolInstances","getViewportIds","map","getViewportsInfo","slice","getToolInstance","toolInstanceName","toolInstance","console","warn","getToolInstances","hasTool","toolName","addTool","configuration","toolDefinition","tools","hasToolName","localToolInstance","toolClass","ToolClass","instantiatedTool","name","toolGroupId","addToolInstance","parentClassName","ToolClassToUse","ParentClass","ToolInstance","addViewport","Error","renderingEngines","getRenderingEngines","length","renderingEngineUIDToUse","some","vpId","push","getActivePrimaryMouseButtonTool","Settings","getRuntimeSettings","get","setViewportsCursorByToolName","eventDetail","triggerEvent","eventTarget","Events","TOOLGROUP_VIEWPORT_ADDED","removeViewports","indices","vpInfo","index","match","i","splice","TOOLGROUP_VIEWPORT_REMOVED","setActiveStrategy","strategyName","undefined","setToolMode","mode","options","setToolDisabled","setToolEnabled","setToolPassive","setToolActive","toolBindingsOptions","bindings","reduce","unique","binding","TouchBinding","numTouchPoints","MouseBinding","obj","hasSameBinding","useCursor","_hasMousePrimaryButtonBinding","cursor","MouseCursor","getDefinedCursor","_setCursorForViewports","onSetToolActive","_renderViewports","TOOL_ACTIVATED","_triggerToolModeChangedEvent","prevToolOptions","getToolOptions","assign","matchBindings","Array","isArray","removeAllBindings","getDefaultPrimaryBindings","filter","matchBinding","onSetToolPassive","onSetToolEnabled","onSetToolDisabled","toolOptionsForTool","find","_getCursor","cursorName","SVGMouseCursor","getEnabledElementByIds","viewport","initElementCursor","setToolConfiguration","overwrite","_configuration","onSetToolConfiguration","getDefaultMousePrimary","getToolConfiguration","configurationPath","getPrevActivePrimaryToolName","clone","newToolGroupId","fnToolFilter","toolGroup","sourceToolInstance","sourceToolOptions","sourceToolMode","primaryBindings","primary","getRenderingEngine","renderViewport","TOOL_MODE_CHANGED","binding1","binding2","modifierKey","toolGroups","tg","toolGroupIndex","findIndex","removeToolGroup","removeSegmentationsFromToolGroup","s","MODES","toolGroupToolNames","includes","pointCanProjectOnLine","polyline","EPSILON","CONSTANTS","PARALLEL_THRESHOLD","PlanarFreehandROITool","toolProps","defaultToolProps","supportedInteractionTypes","shadow","preventHandleOutsideImage","contourHoleAdditionModifierKey","KeyboardBindings","Shift","alwaysRenderOpenContourHandles","enabled","radius","allowOpenContours","closeContourProximity","checkCanvasEditFallbackProximity","makeClockWise","subPixelResolution","smoothing","smoothOnAdd","smoothOnEdit","knotsRatioPercentageOnAdd","knotsRatioPercentageOnEdit","interpolation","onInterpolationComplete","decimate","epsilon","calculateStats","getTextLines","defaultGetTextLines","statsCalculator","BasicStatsCalculator","super","isDrawing","isEditingClosed","isEditingOpen","addNewAnnotation","evt","detail","renderingEngine","annotation","createAnnotation","addAnnotation","viewportIdsToRender","getViewportIdsWithToolToRender","getToolName","activateDraw","preventDefault","handleSelectedCallback","handle","activateOpenContourEndEdit","toolSelectedCallback","data","contour","closed","activateClosedContourEdit","activateOpenContourEdit","isPointNearTool","canvasCoords","proximity","points","previousPoint","worldToCanvas","p1","p2","pStart","pEnd","cancel","cancelDrawing","cancelOpenContourEdit","cancelClosedContourEdit","_calculateCachedStats","cachedStats","targetIds","targetId","image","getTargetIdImage","imageData","metadata","canvasCoordinates","p","canvasPoint","originalWorldPoint","canvasToWorld","deltaXPoint","deltaYPoint","deltaInX","deltaInY","worldPosIndex","Math","floor","iMin","iMax","jMin","jMax","kMin","kMax","j","min","max","worldPosIndex2","scale","areaUnits","numPoints","projectedPolyline","maxX","canvasMaxX","maxY","canvasMaxY","minX","canvasMinX","minY","canvasMinY","math","topLeftBBWorld","topLeftBBIndex","bottomRightBBWorld","area","iDelta","jDelta","kDelta","ceil","boundsIJK","worldPosEnd","indexToWorld","canvasPosEnd","curRow","intersections","intersectionCounter","pointsInShape","pointLPS","pointIJK","result","point","getLineSegmentIntersectionsCoordinates","sort","a","b","shift","statsCallback","modalityUnitOptions","isPreScaled","isSuvScaled","referencedImageId","modalityUnit","Modality","stats","getStatistics","perimeter","mean","value","stdDev","statsArray","array","areaUnit","ChangeTypes","StatsUpdated","invalidated","_renderStats","getTargetId","styleSpecifier","getLinkedTextBoxStyle","visibility","textLines","handles","textBox","hasMoved","canvasTextBoxCoords","getTextBoxCoordsCanvas","worldPosition","textBoxPosition","boundingBox","drawLinkedTextBox","annotationUID","x","left","y","top","width","height","worldBoundingBox","topLeft","topRight","bottomLeft","bottomRight","_throttledCalculateCachedStats","trailing","filterInteractableAnnotationsForElement","annotations","annotationsToDisplay","VolumeViewport","camera","getCamera","spacingInNormalDirection","filterAnnotationsWithinSlice","filterAnnotationsForDisplay","viewPlaneNormal","annotationsWithParallelNormals","td","annotationViewPlaneNormal","isParallel","abs","halfSpacingInNormalDirection","focalPoint","annotationsWithinSlice","isVisible","dir","dot","isContourSegmentationTool","worldPos","currentPoints","world","contourAnnotation","label","getAnnotationStyle","context","renderAnnotationInstance","renderContext","renderStatus","activeAnnotationUID","commonData","renderContourBeingDrawn","renderClosedContourBeingEdited","renderOpenContourBeingEdited","renderContour","_calculateStatsIfActive","movingTextBox","cachedVolumeStats","isEmptyArea","areaLine","roundNumber","planarContourToolName","SegmentationDisplayTool","renderSegmentation","getToolGroup","toolGroupSegmentationRepresentations","getSegmentationRepresentations","toolGroupViewports","segmentationRenderList","representation","config","_getMergedRepresentationsConfig","viewportsRenderList","renderers","Labelmap","Contour","Surface","type","addPlanarFreeHandToolIfAbsent","display","renderedViewport","render","Promise","allSettled","then","segmentationRepresentation","setSegmentationVisibility","segmentationRepresentationUID","toolGroupConfig","globalConfig","HASH_UNDEFINED","INFINITY","funcTag","genTag","symbolTag","reIsDeepProp","reIsPlainProp","reLeadingDot","rePropName","reEscapeChar","reIsHostCtor","freeGlobal","g","freeSelf","self","root","Function","uid","arrayProto","prototype","funcProto","objectProto","coreJsData","maskSrcKey","exec","IE_PROTO","funcToString","toString","hasOwnProperty","objectToString","reIsNative","RegExp","call","replace","Symbol","Map","getNative","nativeCreate","symbolProto","symbolToString","Hash","entries","clear","entry","set","ListCache","MapCache","assocIndexOf","key","other","baseGet","object","path","isSymbol","test","isKey","stringToPath","toKey","baseIsNative","isObject","func","pattern","tag","isFunction","e","isHostObject","toSource","getMapData","__data__","getValue","has","pop","memoize","string","baseToString","number","quote","resolver","TypeError","memoized","args","arguments","apply","cache","Cache","isObjectLike","module","exports","defaultValue"],"sourceRoot":""}