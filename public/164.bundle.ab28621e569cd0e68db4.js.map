{"version":3,"file":"164.bundle.ab28621e569cd0e68db4.js","mappings":"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","sources":["webpack:///../../../node_modules/@cornerstonejs/core/src/RenderingEngine/helpers/addImageSlicesToViewports.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/RenderingEngine/helpers/addVolumesToViewports.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/Settings.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/constants/rendering.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/constants/epsilon.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/enums/RequestType.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/enums/ViewportStatus.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/enums/BlendModes.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/enums/GeometryType.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/enums/ContourType.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/enums/DynamicOperatorType.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/enums/CalibrationTypes.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/getEnabledElement.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/loaders/imageLoader.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/loaders/volumeLoader.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/metaData.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/requestPool/imageLoadPoolManager.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/requestPool/requestPoolManager.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/utilities/triggerEvent.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/webWorkerManager/webWorkerManager.js","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/annotation/BidirectionalTool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/base/AnnotationTool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/displayTools/Labelmap/labelmapConfig.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/segmentation/RectangleROIThresholdTool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/segmentation/RectangleROIStartEndThresholdTool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/annotationFrameRange.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/boundingBox/getBoundingBoxAroundShape.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/calibrateImageSpacing.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/cine/events.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/cine/playClip.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/contourSegmentation/addContourSegmentationAnnotation.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/contourSegmentation/removeContourSegmentationAnnotation.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/contours/AnnotationToPointData.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/contours/calculatePerimeter.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/contours/findHandlePolylineIndex.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/contours/generateContourSetsFromLabelmap.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/contours/getContourHolesDataCanvas.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/contours/getContourHolesDataWorld.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/contours/updateContourPolyline.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/debounce.js","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/drawing/getTextBoxCoordsCanvas.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/getCalibratedUnits.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/getSphereBoundsInfo.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/getViewportForAnnotation.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/index.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/isObject.js","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/aabb/intersectAABB.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/aabb/distanceToPointSquared.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/aabb/distanceToPoint.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/basic/Calculator.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/basic/BasicStatsCalculator.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/ellipse/pointInEllipse.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/ellipse/getCanvasEllipseCorners.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/line/distanceToPointSquaredInfo.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/line/distanceToPointSquared.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/line/distanceToPoint.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/line/intersectLine.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/line/isPointOnLineSegment.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/point/distanceToPoint.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/point/distanceToPointSquared.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/point/mirror.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/polyline/isClosed.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/polyline/containsPoint.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/polyline/containsPoints.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/polyline/getArea.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/polyline/getSignedArea.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/polyline/getWindingDirection.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/polyline/getNormal3.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/polyline/getNormal2.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/polyline/areLineSegmentsIntersecting.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/polyline/getLineSegmentIntersectionsIndexes.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/polyline/getLinesIntersection.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/polyline/combinePolyline.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/polyline/getFirstLineSegmentIntersectionIndexes.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/polyline/intersectPolyline.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/polyline/decimate.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/polyline/getLineSegmentIntersectionsCoordinates.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/polyline/getClosestLineSegmentIntersection.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/polyline/getSubPixelSpacingAndXYDirections.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/polyline/pointsAreWithinCloseContourProximity.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/polyline/addCanvasPointsToArray.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/polyline/pointCanProjectOnLine.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/polyline/projectTo2D.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/polyline/isPointInsidePolyline3D.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/rectangle/distanceToPoint.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/sphere/pointInSphere.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/vec2/liangBarksyClip.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/planar/index.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/planarFreehandROITool/index.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/pointInShapeCallback.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/pointInSurroundingSphereCallback.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/pointToString.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/polyData/utils.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/rectangleROITool/isAxisAlignedRectangle.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/scroll.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/segmentation/InterpolationManager/InterpolationManager.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/segmentation/contourAndFindLargestBidirectional.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/segmentation/createImageIdReferenceMap.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/segmentation/floodFill.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/segmentation/getHoveredContourSegmentationAnnotation.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/segmentation/getSegmentAtLabelmapBorder.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/segmentation/getSegmentAtWorldPoint.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/segmentation/invalidateBrushCursor.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/segmentation/utilities.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/throttle.js","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/touch/index.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/triggerAnnotationRenderForToolGroupIds.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/viewport/isViewportPreScaled.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/viewport/jumpToWorld.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/viewportFilters/filterViewportsWithToolEnabled.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/viewportFilters/filterViewportsWithParallelNormals.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/viewportFilters/getViewportIdsWithToolToRender.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/viewportFilters/filterViewportsWithFrameOfReferenceUID.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/voi/colorbar/Colorbar.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/voi/colorbar/ViewportColorbar.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/voi/colorbar/enums/ColorbarRangeTextPosition.ts","webpack:///../../../node_modules/@icr/polyseg-wasm/dist/ICRPolySeg.js","webpack:///../../../node_modules/@icr/polyseg-wasm/dist/index.js","webpack:///../../../node_modules/@kitware/vtk.js/Filters/General/ContourLoopExtraction.js","webpack:///../../../node_modules/@cornerstonejs/tools/src/workers/polySegConverters.js","webpack:///../../../node_modules/@kitware/vtk.js/Common/DataModel/ImageData.js","webpack:///../../../node_modules/@kitware/vtk.js/Filters/General/ImageMarchingSquares.js","webpack:///../../../node_modules/comlink/dist/esm/comlink.mjs","webpack:///../../../node_modules/d3-array/src/bisector.js"],"sourcesContent":["import { StackViewport } from '..';\nimport type {\n  IStackViewport,\n  IStackInput,\n  IRenderingEngine,\n} from '../../types';\n\n/**\n * For each provided viewport it adds a volume to the viewport using the\n * provided renderingEngine\n *\n *\n * @param renderingEngine - The rendering engine to use to get viewports from\n * @param volumeInputs - Array of volume inputs including volumeId. Other properties\n * such as visibility, callback, blendMode, slabThickness are optional\n * @param viewportIds - Array of viewport IDs to add the volume to\n * @param immediateRender - If true, the volumes will be rendered immediately\n * @returns A promise that resolves when all volumes have been added\n */\nasync function addImageSlicesToViewports(\n  renderingEngine: IRenderingEngine,\n  stackInputs: Array<IStackInput>,\n  viewportIds: Array<string>,\n  immediateRender = false,\n  suppressEvents = false\n): Promise<void> {\n  // Check if all viewports are volumeViewports\n  for (const viewportId of viewportIds) {\n    const viewport = renderingEngine.getViewport(viewportId);\n\n    if (!viewport) {\n      throw new Error(`Viewport with Id ${viewportId} does not exist`);\n    }\n\n    // if not instance of BaseVolumeViewport, throw\n    if (!(viewport as IStackViewport).addImages) {\n      console.warn(\n        `Viewport with Id ${viewportId} does not have addImages. Cannot add image segmentation to this viewport.`\n      );\n\n      return;\n    }\n  }\n\n  const addStackPromises = viewportIds.map(async (viewportId) => {\n    const viewport = renderingEngine.getViewport(viewportId) as IStackViewport;\n\n    return viewport.addImages(stackInputs, immediateRender, suppressEvents);\n  });\n\n  await Promise.all(addStackPromises);\n}\n\nexport default addImageSlicesToViewports;\n","import BaseVolumeViewport from '../BaseVolumeViewport';\nimport type {\n  IVolumeViewport,\n  IVolumeInput,\n  IRenderingEngine,\n} from '../../types';\n\n/**\n * For each provided viewport it adds a volume to the viewport using the\n * provided renderingEngine\n *\n *\n * @param renderingEngine - The rendering engine to use to get viewports from\n * @param volumeInputs - Array of volume inputs including volumeId. Other properties\n * such as visibility, callback, blendMode, slabThickness are optional\n * @param viewportIds - Array of viewport IDs to add the volume to\n * @param immediateRender - If true, the volumes will be rendered immediately\n * @returns A promise that resolves when all volumes have been added\n */\nasync function addVolumesToViewports(\n  renderingEngine: IRenderingEngine,\n  volumeInputs: Array<IVolumeInput>,\n  viewportIds: Array<string>,\n  immediateRender = false,\n  suppressEvents = false\n): Promise<void> {\n  // Check if all viewports are volumeViewports\n  for (const viewportId of viewportIds) {\n    const viewport = renderingEngine.getViewport(viewportId);\n\n    if (!viewport) {\n      throw new Error(`Viewport with Id ${viewportId} does not exist`);\n    }\n\n    // if not instance of BaseVolumeViewport, throw\n    if (!(viewport instanceof BaseVolumeViewport)) {\n      console.warn(\n        `Viewport with Id ${viewportId} is not a BaseVolumeViewport. Cannot add volume to this viewport.`\n      );\n\n      return;\n    }\n  }\n\n  const addVolumePromises = viewportIds.map(async (viewportId) => {\n    const viewport = renderingEngine.getViewport(viewportId) as IVolumeViewport;\n\n    await viewport.addVolumes(volumeInputs, immediateRender, suppressEvents);\n  });\n\n  await Promise.all(addVolumePromises);\n  return;\n}\n\nexport default addVolumesToViewports;\n","/*\n * Constants\n */\n\nconst DEFAULT_SETTINGS = Symbol('DefaultSettings');\nconst RUNTIME_SETTINGS = Symbol('RuntimeSettings');\nconst OBJECT_SETTINGS_MAP = Symbol('ObjectSettingsMap');\nconst DICTIONARY = Symbol('Dictionary');\n\n/**\n * Settings\n */\nexport default class Settings {\n  constructor(base?: Settings) {\n    const dictionary = Object.create(\n      (base instanceof Settings && DICTIONARY in base\n        ? base[DICTIONARY]\n        : null) as object\n    );\n    Object.seal(\n      Object.defineProperty(this, DICTIONARY, {\n        value: dictionary,\n      })\n    );\n  }\n\n  set(key: string, value: unknown): boolean {\n    return set(this[DICTIONARY], key, value, null);\n  }\n\n  get(key: string): unknown {\n    return get(this[DICTIONARY], key);\n  }\n\n  /**\n   * Unset a specific key or a set of keys within a namespace when the key ends with a dot (ASCII #46).\n   * If the key is \".\", all keys will be removed and this command works as a reset.\n   * @param key - name The key to be unset or a namespace.\n   * @returns boolean\n   */\n  unset(key: string): boolean {\n    return unset(this[DICTIONARY], key + '');\n  }\n\n  forEach(callback: (key: string, value: unknown) => void): void {\n    iterate(this[DICTIONARY], callback);\n  }\n\n  extend(): Settings {\n    return new Settings(this);\n  }\n\n  /**\n   * Recursively import all properties from the given plain JavaScript object.\n   * This method has the opposite effect of the `dump` method.\n   * @param root - The root object whose properties will\n   * be imported.\n   */\n  import(root: Record<string, unknown>): void {\n    if (isPlainObject(root)) {\n      Object.keys(root).forEach((key) => {\n        set(this[DICTIONARY], key, root[key], null);\n      });\n    }\n  }\n\n  /**\n   * Build a JSON representation of the current internal state of this settings\n   * object. The returned object can be safely passed to `JSON.stringify`\n   * function.\n   * @returns The JSON representation of the current\n   * state of this settings instance\n   */\n  dump(): Record<string, unknown> {\n    const context = {};\n    iterate(this[DICTIONARY], (key, value) => {\n      if (typeof value !== 'undefined') {\n        deepSet(context, key, value);\n      }\n    });\n    return context;\n  }\n\n  static assert(subject: Settings): Settings {\n    return subject instanceof Settings\n      ? subject\n      : Settings.getRuntimeSettings();\n  }\n\n  static getDefaultSettings(subfield = null): Settings | any {\n    let defaultSettings = Settings[DEFAULT_SETTINGS];\n    if (!(defaultSettings instanceof Settings)) {\n      defaultSettings = new Settings();\n      Settings[DEFAULT_SETTINGS] = defaultSettings;\n    }\n\n    // Given subfield of 'segmentation' it will return all settings\n    // that starts with segmentation.*\n    if (subfield) {\n      const settingObj = {};\n      defaultSettings.forEach((name: string) => {\n        if (name.startsWith(subfield)) {\n          const setting = name.split(`${subfield}.`)[1];\n          settingObj[setting] = defaultSettings.get(name);\n        }\n      });\n      return settingObj;\n    }\n\n    return defaultSettings;\n  }\n\n  static getRuntimeSettings(): Settings {\n    let runtimeSettings = Settings[RUNTIME_SETTINGS];\n    if (!(runtimeSettings instanceof Settings)) {\n      runtimeSettings = new Settings(Settings.getDefaultSettings());\n      Settings[RUNTIME_SETTINGS] = runtimeSettings;\n    }\n    return runtimeSettings;\n  }\n\n  static getObjectSettings(subject: unknown, from?: unknown): Settings {\n    let settings = null;\n    if (subject instanceof Settings) {\n      settings = subject;\n    } else if (typeof subject === 'object' && subject !== null) {\n      let objectSettingsMap = Settings[OBJECT_SETTINGS_MAP];\n      if (!(objectSettingsMap instanceof WeakMap)) {\n        objectSettingsMap = new WeakMap();\n        Settings[OBJECT_SETTINGS_MAP] = objectSettingsMap;\n      }\n      settings = objectSettingsMap.get(subject);\n      if (!(settings instanceof Settings)) {\n        settings = new Settings(\n          Settings.assert(Settings.getObjectSettings(from))\n        );\n        objectSettingsMap.set(subject, settings);\n      }\n    }\n    return settings;\n  }\n\n  static extendRuntimeSettings(): Settings {\n    return Settings.getRuntimeSettings().extend();\n  }\n}\n\n/*\n * Local Helpers\n */\n\nfunction unset(dictionary: Record<string, unknown>, name: string): boolean {\n  if (name.endsWith('.')) {\n    let deleteCount = 0;\n    const namespace = name;\n    const base = namespace.slice(0, -1);\n    const deleteAll = base.length === 0;\n    for (const key in dictionary) {\n      if (\n        Object.prototype.hasOwnProperty.call(dictionary, key) &&\n        (deleteAll || key.startsWith(namespace) || key === base)\n      ) {\n        delete dictionary[key];\n        ++deleteCount;\n      }\n    }\n    return deleteCount > 0;\n  }\n  return delete dictionary[name];\n}\n\nfunction iterate(\n  dictionary: Record<string, unknown>,\n  callback: (key: string, value: unknown) => void\n): void {\n  for (const key in dictionary) {\n    callback(key, dictionary[key]);\n  }\n}\n\nfunction setAll(\n  dictionary: Record<string, unknown>,\n  prefix: string,\n  record: Record<string, unknown>,\n  references: WeakSet<Record<string, unknown>>\n): boolean {\n  let failCount: number;\n  if (references.has(record)) {\n    return set(dictionary, prefix, null, references);\n  }\n  references.add(record);\n  failCount = 0;\n  for (const field in record) {\n    if (Object.prototype.hasOwnProperty.call(record, field)) {\n      const key = field.length === 0 ? prefix : `${prefix}.${field}`;\n      if (!set(dictionary, key, record[field], references)) {\n        ++failCount;\n      }\n    }\n  }\n  references.delete(record);\n  return failCount === 0;\n}\n\n/**\n * Set the key-value pair on a given dictionary. If the given value is a\n * plain javascript object, every property of that object will also be set.\n * @param dictionary {Record<string, unknown>} The target dictionary\n * @param key {string} The given key\n * @param value {unknown} The given value\n * @param references {WeakSet<Record<string, unknown>>} references is a WeakSet\n *  instance used to keep track of which objects have already been iterated\n *  through preventing thus possible stack overflows caused by cyclic references\n * @returns {boolean} Returns true if every given key-value pair has been\n * successfully set\n */\nfunction set(\n  dictionary: Record<string, unknown>,\n  key: string,\n  value: unknown,\n  references: WeakSet<Record<string, unknown>>\n): boolean {\n  if (isValidKey(key)) {\n    if (isPlainObject(value)) {\n      return setAll(\n        dictionary,\n        key,\n        value as Record<string, unknown>,\n        references instanceof WeakSet ? references : new WeakSet()\n      );\n    }\n    dictionary[key] = value;\n    return true;\n  }\n  return false;\n}\n\nfunction get(dictionary: Record<string, unknown>, key: string): unknown {\n  return dictionary[key];\n}\n\n/**\n * Make sure the -provided key correctly formatted.\n * e.g.:\n *  \"my.cool.property\" (valid)\n *  \"my.cool.property.\" (invalid)\n *  \".my.cool.property\" (invalid)\n *  \"my.cool..property\" (invalid)\n * @param key {string} The property name to be used as key within the internal\n *  dictionary\n * @returns {boolean} True on success, false otherwise\n */\nfunction isValidKey(key: string): boolean {\n  let last: number, current: number, previous: number;\n  if (typeof key !== 'string' || (last = key.length - 1) < 0) {\n    return false;\n  }\n  previous = -1;\n  while ((current = key.indexOf('.', previous + 1)) >= 0) {\n    if (current - previous < 2 || current === last) {\n      return false;\n    }\n    previous = current;\n  }\n  return true;\n}\n\nfunction isPlainObject(subject: unknown) {\n  if (typeof subject === 'object' && subject !== null) {\n    const prototype = Object.getPrototypeOf(subject);\n    if (prototype === Object.prototype || prototype === null) {\n      return true;\n    }\n  }\n  return false;\n}\n\nfunction deepSet(context, key, value) {\n  const separator = key.indexOf('.');\n  if (separator >= 0) {\n    const subKey = key.slice(0, separator);\n    let subContext = context[subKey];\n    if (typeof subContext !== 'object' || subContext === null) {\n      const subContextValue = subContext;\n      subContext = {};\n      if (typeof subContextValue !== 'undefined') {\n        subContext[''] = subContextValue;\n      }\n      context[subKey] = subContext;\n    }\n    deepSet(subContext, key.slice(separator + 1, key.length), value);\n  } else {\n    context[key] = value;\n  }\n}\n\n/**\n * Initial Settings for the repository\n */\nSettings.getDefaultSettings().set('useCursors', true);\n","const RENDERING_DEFAULTS = {\n  MINIMUM_SLAB_THICKNESS: 5e-2,\n  MAXIMUM_RAY_DISTANCE: 1e6,\n};\n\nObject.freeze(RENDERING_DEFAULTS);\n\nexport default RENDERING_DEFAULTS;\n","const EPSILON = 1e-3;\n\nexport default EPSILON;\n","/**\n * Request types for requesting images from the imageLoadPoolManager\n */\nenum RequestType {\n  /** Highest priority for loading*/\n  Interaction = 'interaction',\n  /** Second highest priority for loading*/\n  Thumbnail = 'thumbnail',\n  /** Third highest priority for loading, usually used for image loading in the background*/\n  Prefetch = 'prefetch',\n  /** Lower priority, often used for background computations in the worker */\n  Compute = 'compute',\n}\n\nexport default RequestType;\n","enum ViewportStatus {\n  /** Initial state before any volumes or stacks are available*/\n  NO_DATA = 'noData',\n  /** Stack/volumes are available but are in progress */\n  LOADING = 'loading',\n  /** Ready to be rendered */\n  PRE_RENDER = 'preRender',\n  /** In the midst of a resize */\n  RESIZE = 'resize',\n  /** Rendered image data */\n  RENDERED = 'rendered',\n}\n\nexport default ViewportStatus;\n","import vtkConstants from '@kitware/vtk.js/Rendering/Core/VolumeMapper/Constants';\n\nconst { BlendMode } = vtkConstants;\n\n/**\n * Enums for blendModes for viewport images based on vtk.js\n *\n * It should be noted that if crosshairs are enabled and can modify the slab thickness,\n * then it will not show any difference unless MAXIMUM_INTENSITY_BLEND is set on the viewport\n * as the blend.\n */\nenum BlendModes {\n  /** composite blending - suitable for compositing multiple images */\n  COMPOSITE = BlendMode.COMPOSITE_BLEND,\n  /** maximum intensity projection */\n  MAXIMUM_INTENSITY_BLEND = BlendMode.MAXIMUM_INTENSITY_BLEND,\n  /** minimum intensity projection */\n  MINIMUM_INTENSITY_BLEND = BlendMode.MINIMUM_INTENSITY_BLEND,\n  /** average intensity projection */\n  AVERAGE_INTENSITY_BLEND = BlendMode.AVERAGE_INTENSITY_BLEND,\n}\n\nexport default BlendModes;\n","enum GeometryType {\n  CONTOUR = 'contour',\n  SURFACE = 'Surface',\n}\n\nexport default GeometryType;\n","enum ContourType {\n  CLOSED_PLANAR = 'CLOSED_PLANAR',\n  OPEN_PLANAR = 'OPEN_PLANAR',\n}\n\nexport default ContourType;\n","/**\n * DynamicOperatorType enum for cornerstone-render which defines the operator to use for generateImageFromTimeData.\n * It can be either SUM, AVERAGE or SUBTRACT.\n */\nenum DynamicOperatorType {\n  /** For summing the time frames. */\n  SUM = 'SUM',\n  /** For averaging the time frames. */\n  AVERAGE = 'AVERAGE',\n  /** For subtracting two time frames */\n  SUBTRACT = 'SUBTRACT',\n}\n\nexport default DynamicOperatorType;\n","/**\n * Defines the calibration types available.  These define how the units\n * for measurements are specified.\n */\nexport enum CalibrationTypes {\n  /**\n   * Not applicable means the units are directly defind by the underlying\n   * hardware, such as CT and MR volumetric displays, so no special handling\n   * or notification is required.\n   */\n  NOT_APPLICABLE = '',\n  /**\n   * ERMF is estimated radiographic magnification factor.  This defines how\n   * much the image is magnified at the detector as opposed to the location in\n   * the body of interest.  This occurs because the radiation beam is expanding\n   * and effectively magnifies the image on the detector compared to where the\n   * point of interest in the body is.\n   * This suggests that measurements can be partially trusted, but the user\n   * still needs to be aware that different depths within the body have differing\n   * ERMF values, so precise measurements would still need to be manually calibrated.\n   */\n  ERMF = 'ERMF',\n  /**\n   * User calibration means that the user has provided a custom calibration\n   * specifying how large the image data is.  This type can occur on\n   * volumetric images, eg for scout images that might have invalid spacing\n   * tags.\n   */\n  USER = 'User',\n  /**\n   * A projection calibration means the raw detector size, without any\n   * ERMF applied, meaning that the size in the body cannot be trusted and\n   * that a calibration should be applied.\n   * This is different from Error in that there is simply no magnification\n   * factor applied as opposed to having multiple, inconsistent magnification\n   * factors.\n   */\n  PROJECTION = 'Proj',\n  /**\n   * A region calibration is used for other types of images, typically\n   * ultrasouunds where the distance in the image may mean something other than\n   * physical distance, such as mV or Hz or some other measurement values.\n   */\n  REGION = 'Region',\n  /**\n   * Error is used to define mismatches between various units, such as when\n   * there are two different ERMF values specified.  This is an indication to\n   * NOT trust the measurement values but to manually calibrate.\n   */\n  ERROR = 'Error',\n  /** Uncalibrated image */\n  UNCALIBRATED = 'Uncalibrated',\n}\n\nexport default CalibrationTypes;\n","import getRenderingEngine, {\n  getRenderingEngines,\n} from './RenderingEngine/getRenderingEngine';\nimport { IEnabledElement, IStackViewport, IVolumeViewport } from './types';\n\n/**\n * A convenience method to find an EnabledElement given a reference to its\n * associated element. Commonly used in code that's handling a custom\n * event emitted by this library.\n *\n * @example\n * Using the renderingEngine to find the enabled element:\n * ```javascript\n * const element = getRenderingEngine(renderingEngineId)\n *    .getViewport(viewportId)\n *    .element\n *\n * const enabledElement = getEnabledElement(element)\n * ```\n *\n * @example\n * Using a cornerstone event's \"element\"\n * ```javascript\n * // Our \"cornerstone events\" contain the source element, which is\n * // raised on the viewport's div element\n * const { element } = evt.detail\n * const enabledElement = getEnabledElement(element)\n * ```\n *\n * @param element - a reference to an EnabledElement/Viewport's div element\n * @returns the associated EnabledElement, or undefined if no matching EnabledElement\n * can be found\n */\nexport default function getEnabledElement(\n  element: HTMLDivElement | undefined\n): IEnabledElement | undefined {\n  if (!element) {\n    return;\n  }\n\n  const { viewportUid, renderingEngineUid } = element.dataset;\n\n  return getEnabledElementByIds(viewportUid, renderingEngineUid);\n}\n\n/**\n * Similar to {@link getEnabledElement}, but takes the IDs of the\n * renderingEngine and viewport as parameters to return the associated\n * EnabledElement.\n *\n * @param viewportId - The Id of the viewport\n * @param renderingEngineId - The Id of the rendering engine.\n * @returns The enabled element which is an object that contains the viewport, rendering\n * engine, viewport Id, rendering engine Id, and the Frame of Reference UID.\n */\nexport function getEnabledElementByIds(\n  viewportId: string,\n  renderingEngineId: string\n): IEnabledElement {\n  if (!renderingEngineId || !viewportId) {\n    return;\n  }\n\n  const renderingEngine = getRenderingEngine(renderingEngineId);\n\n  if (!renderingEngine || renderingEngine.hasBeenDestroyed) {\n    return;\n  }\n\n  const viewport = renderingEngine.getViewport(viewportId) as\n    | IStackViewport\n    | IVolumeViewport;\n\n  if (!viewport) {\n    return;\n  }\n\n  const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n\n  return {\n    viewport,\n    renderingEngine,\n    viewportId,\n    renderingEngineId,\n    FrameOfReferenceUID,\n  };\n}\n\n/**\n * Retrieves the enabled element by the specified viewport ID. it searches\n * through all the rendering engines to find the viewport with the specified\n *\n * @param viewportId - The ID of the viewport.\n * @returns The enabled element associated with the specified viewport ID.\n */\nexport function getEnabledElementByViewportId(viewportId: string) {\n  const renderingEngines = getRenderingEngines();\n\n  for (let i = 0; i < renderingEngines.length; i++) {\n    const renderingEngine = renderingEngines[i];\n    const viewport = renderingEngine.getViewport(viewportId);\n\n    if (viewport) {\n      return getEnabledElementByIds(viewportId, renderingEngine.id);\n    }\n  }\n}\n\n/**\n * Get all the enabled elements from all the rendering engines\n * @returns An array of enabled elements.\n */\nexport function getEnabledElements(): IEnabledElement[] {\n  const enabledElements = [];\n\n  const renderingEngines = getRenderingEngines();\n\n  renderingEngines.forEach((renderingEngine) => {\n    const viewports = renderingEngine.getViewports();\n\n    viewports.forEach(({ element }) => {\n      enabledElements.push(getEnabledElement(element));\n    });\n  });\n\n  return enabledElements;\n}\n","import cache from '../cache/cache';\nimport { ImageVolume } from '../cache';\nimport Events from '../enums/Events';\nimport eventTarget from '../eventTarget';\nimport {\n  genericMetadataProvider,\n  getBufferConfiguration,\n  triggerEvent,\n  uuidv4,\n} from '../utilities';\nimport {\n  IImage,\n  ImageLoaderFn,\n  IImageLoadObject,\n  EventTypes,\n  Point2,\n  Point3,\n  Mat3,\n  PixelDataTypedArrayString,\n  PixelDataTypedArray,\n} from '../types';\nimport imageLoadPoolManager from '../requestPool/imageLoadPoolManager';\nimport { metaData } from '../';\n\nexport interface ImageLoaderOptions {\n  priority: number;\n  requestType: string;\n  additionalDetails?: Record<string, unknown>;\n  ignoreCache?: boolean;\n}\n\ninterface DerivedImages {\n  imageIds: Array<string>;\n  promises: Array<Promise<IImage>>;\n}\n\ntype LocalImageOptions = {\n  scalarData?: PixelDataTypedArray;\n  targetBufferType?: PixelDataTypedArrayString;\n  dimensions?: Point2;\n  spacing?: Point3;\n  origin?: Point3;\n  direction?: Mat3;\n  /**\n   * Skip creation of the actual buffer object.\n   * In fact, this creates a very short buffer, as there are lots of places\n   * assuming a buffer exists.\n   * This can be used when there are alternative representations of the image data.\n   */\n  skipCreateBuffer?: boolean;\n  /**\n   * A method to call to update the image object when it gets added to the cache.\n   * This can be used to create alternative representations of the image data,\n   * such as a VoxelManager.\n   */\n  onCacheAdd?: (image: IImage) => void;\n};\n\ntype DerivedImageOptions = LocalImageOptions & {\n  imageId?: string;\n  targetBufferType?: PixelDataTypedArrayString;\n};\n\n/**\n * This module deals with ImageLoaders, loading images and caching images\n */\nconst imageLoaders = {};\nlet unknownImageLoader;\n\n/**\n * Loads an image using a registered Cornerstone Image Loader.\n *\n * The image loader that is used will be\n * determined by the image loader scheme matching against the imageId.\n *\n * @param imageId - A Cornerstone Image Object's imageId\n * @param Options - to be passed to the Image Loader\n *\n * @returns - An Object which can be used to act after an image is loaded or loading fails\n */\nfunction loadImageFromImageLoader(\n  imageId: string,\n  options: ImageLoaderOptions\n): IImageLoadObject {\n  // Extract the image loader scheme: wadors:https://image1 => wadors\n  const colonIndex = imageId.indexOf(':');\n  const scheme = imageId.substring(0, colonIndex);\n  const loader = imageLoaders[scheme];\n  if (loader === undefined || loader === null) {\n    if (unknownImageLoader !== undefined) {\n      return unknownImageLoader(imageId);\n    }\n    throw new Error('loadImageFromImageLoader: no image loader for imageId');\n  }\n  // Load using the registered loader\n  const imageLoadObject = loader(imageId, options);\n  // Broadcast an image loaded event once the image is loaded\n  imageLoadObject.promise.then(\n    function (image) {\n      triggerEvent(eventTarget, Events.IMAGE_LOADED, { image });\n    },\n    function (error) {\n      const errorObject: EventTypes.ImageLoadedFailedEventDetail = {\n        imageId,\n        error,\n      };\n      triggerEvent(eventTarget, Events.IMAGE_LOAD_FAILED, errorObject);\n    }\n  );\n  return imageLoadObject;\n}\n\n/**\n * Gets the imageLoadObject by 1) Looking in to the cache to see if the\n * imageLoadObject has already been cached, 2) Checks inside the volume cache\n * to see if there is a volume that contains the same imageURI for the requested\n * imageID 3) Checks inside the imageCache for similar imageURI that might have\n * been stored as a result of decaching a volume 4) Finally if none were found\n * it request it from the registered imageLoaders.\n *\n * @param imageId - A Cornerstone Image Object's imageId\n * @param options - Options to be passed to the Image Loader\n *\n * @returns An Object which can be used to act after an image is loaded or loading fails\n */\nfunction loadImageFromCacheOrVolume(\n  imageId: string,\n  options: ImageLoaderOptions\n): IImageLoadObject {\n  if (options.ignoreCache) {\n    return loadImageFromImageLoader(imageId, options);\n  }\n\n  // 1. Check inside the image cache for imageId\n  let imageLoadObject = cache.getImageLoadObject(imageId);\n  if (imageLoadObject !== undefined) {\n    return imageLoadObject;\n  }\n  // 2. Check if there exists a volume in the cache containing the imageId,\n  // we copy the pixelData over.\n  const cachedVolumeInfo = cache.getVolumeContainingImageId(imageId);\n  if (cachedVolumeInfo?.volume?.loadStatus?.loaded) {\n    // 2.1 Convert the volume at the specific slice to a cornerstoneImage object.\n    // this will copy the pixel data over.\n    const { volume, imageIdIndex } = cachedVolumeInfo;\n\n    if (volume instanceof ImageVolume) {\n      imageLoadObject = volume.convertToCornerstoneImage(imageId, imageIdIndex);\n    }\n    return imageLoadObject;\n  }\n  // 3. If no volume found, we search inside the imageCache for the imageId\n  // that has the same URI which had been cached if the volume was converted\n  // to an image\n  const cachedImage = cache.getCachedImageBasedOnImageURI(imageId);\n  if (cachedImage) {\n    imageLoadObject = cachedImage.imageLoadObject;\n    return imageLoadObject;\n  }\n  // 4. if not in image cache nor inside the volume cache, we request the\n  // image loaders to load it\n  imageLoadObject = loadImageFromImageLoader(imageId, options);\n\n  return imageLoadObject;\n}\n\n/**\n * Loads an image given an imageId and optional priority and returns a promise\n * which will resolve to the loaded image object or fail if an error occurred.\n * The loaded image is not stored in the cache.\n *\n *\n * @param imageId - A Cornerstone Image Object's imageId\n * @param options - Options to be passed to the Image Loader\n *\n * @returns An Object which can be used to act after an image is loaded or loading fails\n */\nexport function loadImage(\n  imageId: string,\n  options: ImageLoaderOptions = { priority: 0, requestType: 'prefetch' }\n): Promise<IImage> {\n  if (imageId === undefined) {\n    throw new Error('loadImage: parameter imageId must not be undefined');\n  }\n\n  return loadImageFromCacheOrVolume(imageId, options).promise;\n}\n\n/**\n * Loads an image given an imageId and optional priority and returns a promise\n * which will resolve to the loaded image object or fail if an error occurred.\n * The image is stored in the cache.\n *\n * @param imageId -  A Cornerstone Image Object's imageId\n * @param options - Options to be passed to the Image Loader\n *\n * @returns Image Loader Object\n */\nexport function loadAndCacheImage(\n  imageId: string,\n  options: ImageLoaderOptions = { priority: 0, requestType: 'prefetch' }\n): Promise<IImage> {\n  if (imageId === undefined) {\n    throw new Error(\n      'loadAndCacheImage: parameter imageId must not be undefined'\n    );\n  }\n  const imageLoadObject = loadImageFromCacheOrVolume(imageId, options);\n\n  // if not inside cache, store it\n  if (!cache.getImageLoadObject(imageId)) {\n    cache.putImageLoadObject(imageId, imageLoadObject).catch((err) => {\n      console.warn(err);\n    });\n  }\n\n  return imageLoadObject.promise;\n}\n\n/**\n * Load and cache a list of imageIds\n *\n * @param imageIds - list of imageIds\n * @param options - options for loader\n *\n */\nexport function loadAndCacheImages(\n  imageIds: Array<string>,\n  options: ImageLoaderOptions = { priority: 0, requestType: 'prefetch' }\n): Promise<IImage>[] {\n  if (!imageIds || imageIds.length === 0) {\n    throw new Error(\n      'loadAndCacheImages: parameter imageIds must be list of image Ids'\n    );\n  }\n\n  const allPromises = imageIds.map((imageId) => {\n    return loadAndCacheImage(imageId, options);\n  });\n\n  return allPromises;\n}\n\n/**\n * Loads an image given an imageId and optional priority and returns a promise\n * which will resolve to the loaded image object or fail if an error occurred.\n * The image is stored in the cache.\n *\n * @param referencedImageId -  A Cornerstone Image Object's imageId\n * @param options - Options to be passed to the Image Loader\n *\n * @returns Image Loader Object\n */\nexport function createAndCacheDerivedImage(\n  referencedImageId: string,\n  options: DerivedImageOptions = {},\n  preventCache = false\n): Promise<IImage> {\n  if (referencedImageId === undefined) {\n    throw new Error(\n      'createAndCacheDerivedImage: parameter imageId must not be undefined'\n    );\n  }\n\n  if (options.imageId === undefined) {\n    options.imageId = `derived:${uuidv4()}`;\n  }\n\n  const { imageId, skipCreateBuffer, onCacheAdd } = options;\n\n  const imagePlaneModule = metaData.get('imagePlaneModule', referencedImageId);\n\n  const length = imagePlaneModule.rows * imagePlaneModule.columns;\n\n  const { TypedArrayConstructor } = getBufferConfiguration(\n    options.targetBufferType,\n    length\n  );\n\n  // Use a buffer of size 1 for no data\n  const imageScalarData = new TypedArrayConstructor(\n    skipCreateBuffer ? 1 : length\n  );\n  const derivedImageId = imageId;\n\n  ['imagePixelModule', 'imagePlaneModule', 'generalSeriesModule'].forEach(\n    (type) => {\n      genericMetadataProvider.add(derivedImageId, {\n        type,\n        metadata: metaData.get(type, referencedImageId),\n      });\n    }\n  );\n\n  const localImage = createAndCacheLocalImage(\n    { scalarData: imageScalarData, onCacheAdd, skipCreateBuffer },\n    imageId,\n    true\n  );\n\n  const imageLoadObject = {\n    promise: Promise.resolve(localImage),\n  };\n\n  if (!preventCache) {\n    cache.putImageLoadObject(derivedImageId, imageLoadObject);\n  }\n  return imageLoadObject.promise;\n}\n\n/**\n * Load and cache a list of imageIds\n *\n * @param referencedImageIds - list of imageIds\n * @param options\n * @param options.getDerivedImageId - function to get the derived imageId\n * @param options.targetBufferType - target buffer type\n * @param options.skipBufferCreate - avoid creating the buffer\n */\nexport function createAndCacheDerivedImages(\n  referencedImageIds: Array<string>,\n  options: DerivedImageOptions & {\n    getDerivedImageId?: (referencedImageId: string) => string;\n    targetBufferType?: PixelDataTypedArrayString;\n  } = {}\n): DerivedImages {\n  if (referencedImageIds?.length === 0) {\n    throw new Error(\n      'createAndCacheDerivedImages: parameter imageIds must be list of image Ids'\n    );\n  }\n\n  const derivedImageIds = [];\n  const allPromises = referencedImageIds.map((referencedImageId) => {\n    const newOptions: DerivedImageOptions = {\n      imageId:\n        options.getDerivedImageId?.(referencedImageId) || `derived:${uuidv4()}`,\n      ...options,\n    };\n    derivedImageIds.push(newOptions.imageId);\n    return createAndCacheDerivedImage(referencedImageId, newOptions);\n  });\n\n  return { imageIds: derivedImageIds, promises: allPromises };\n}\n\nexport function createAndCacheLocalImage(\n  options: LocalImageOptions,\n  imageId: string,\n  preventCache = false\n): IImage {\n  const imagePlaneModule = metaData.get('imagePlaneModule', imageId);\n\n  const length = imagePlaneModule.rows * imagePlaneModule.columns;\n\n  const image = {\n    imageId: imageId,\n    intercept: 0,\n    windowCenter: 0,\n    windowWidth: 0,\n    color: false,\n    numComps: 1,\n    slope: 1,\n    minPixelValue: 0,\n    maxPixelValue: 255,\n    voiLUTFunction: undefined,\n    rows: imagePlaneModule.rows,\n    columns: imagePlaneModule.columns,\n    getCanvas: undefined, // todo: which canvas?\n    height: imagePlaneModule.rows,\n    width: imagePlaneModule.columns,\n    rgba: undefined, // todo: how\n    columnPixelSpacing: imagePlaneModule.columnPixelSpacing,\n    rowPixelSpacing: imagePlaneModule.rowPixelSpacing,\n    invert: false,\n  } as IImage;\n\n  if (options.scalarData) {\n    const imageScalarData = options.scalarData;\n\n    if (\n      !(\n        imageScalarData instanceof Uint8Array ||\n        imageScalarData instanceof Float32Array ||\n        imageScalarData instanceof Uint16Array ||\n        imageScalarData instanceof Int16Array\n      )\n    ) {\n      throw new Error(\n        'To use createLocalVolume you should pass scalarData of type Uint8Array, Uint16Array, Int16Array or Float32Array'\n      );\n    }\n\n    image.sizeInBytes = imageScalarData.byteLength;\n    image.getPixelData = () => imageScalarData;\n  } else if (options.skipCreateBuffer !== true) {\n    const { numBytes, TypedArrayConstructor } = getBufferConfiguration(\n      options.targetBufferType,\n      length\n    );\n\n    const imageScalarData = new TypedArrayConstructor(length);\n\n    image.sizeInBytes = numBytes;\n    image.getPixelData = () => imageScalarData;\n  }\n\n  // The onCacheAdd may modify the size in bytes for this image, which is ok,\n  // as this is used after resolution for cache storage.  It may also do\n  // thinks like adding alternative representations such as VoxelManager\n  options.onCacheAdd?.(image);\n\n  const imageLoadObject = {\n    promise: Promise.resolve(image),\n  };\n\n  if (!preventCache) {\n    cache.putImageLoadObject(image.imageId, imageLoadObject);\n  }\n\n  return image;\n}\n\n/**\n * Removes the imageId from the request pool manager and executes the `cancel`\n * function if it exists.\n *\n * @param imageId - A Cornerstone Image Object's imageId\n *\n */\nexport function cancelLoadImage(imageId: string): void {\n  const filterFunction = ({ additionalDetails }) => {\n    if (additionalDetails.imageId) {\n      return additionalDetails.imageId !== imageId;\n    }\n\n    // for volumes\n    return true;\n  };\n\n  // Instruct the request pool manager to filter queued\n  // requests to ensure requests we no longer need are\n  // no longer sent.\n  imageLoadPoolManager.filterRequests(filterFunction);\n\n  // TODO: Cancel decoding and retrieval as well (somehow?)\n\n  // cancel image loading if in progress\n  const imageLoadObject = cache.getImageLoadObject(imageId);\n\n  if (imageLoadObject) {\n    imageLoadObject.cancelFn();\n  }\n}\n\n/**\n * Removes the imageIds from the request pool manager and calls the `cancel`\n * function if it exists.\n *\n * @param imageIds - Array of Cornerstone Image Object's imageIds\n *\n */\nexport function cancelLoadImages(imageIds: Array<string>): void {\n  imageIds.forEach((imageId) => cancelLoadImage(imageId));\n}\n\n/**\n * Removes all the ongoing image loads by calling the `cancel` method on each\n * imageLoadObject. If no `cancel` method is available, it will be ignored.\n *\n */\nexport function cancelLoadAll(): void {\n  const requestPool = imageLoadPoolManager.getRequestPool();\n\n  Object.keys(requestPool).forEach((type: string) => {\n    const requests = requestPool[type];\n\n    Object.keys(requests).forEach((priority) => {\n      const requestDetails = requests[priority].pop();\n      const additionalDetails = requestDetails.additionalDetails as any;\n      const { imageId, volumeId } = additionalDetails;\n\n      let loadObject;\n\n      if (imageId) {\n        loadObject = cache.getImageLoadObject(imageId);\n      } else if (volumeId) {\n        loadObject = cache.getVolumeLoadObject(volumeId);\n      }\n      if (loadObject) {\n        loadObject.cancel();\n      }\n    });\n    // resetting the pool types to be empty\n    imageLoadPoolManager.clearRequestStack(type);\n\n    // TODO: Clear retrieval and decoding queues as well\n  });\n}\n\n/**\n * Registers an imageLoader plugin with cornerstone for the specified scheme\n *\n * @param scheme - The scheme to use for this image loader (e.g. 'dicomweb', 'wadouri', 'http')\n * @param imageLoader - A Cornerstone Image Loader function\n */\nexport function registerImageLoader(\n  scheme: string,\n  imageLoader: ImageLoaderFn\n): void {\n  imageLoaders[scheme] = imageLoader;\n}\n/**\n * Registers a new unknownImageLoader and returns the previous one\n *\n * @param imageLoader - A Cornerstone Image Loader\n *\n * @returns The previous Unknown Image Loader\n */\nexport function registerUnknownImageLoader(\n  imageLoader: ImageLoaderFn\n): ImageLoaderFn {\n  const oldImageLoader = unknownImageLoader;\n  unknownImageLoader = imageLoader;\n  return oldImageLoader;\n}\n/**\n * Removes all registered and unknown image loaders. This should be called\n * when the application is unmounted to prevent memory leaks.\n *\n */\nexport function unregisterAllImageLoaders(): void {\n  Object.keys(imageLoaders).forEach(\n    (imageLoader) => delete imageLoaders[imageLoader]\n  );\n  unknownImageLoader = undefined;\n}\n\n/**\n * Creates and caches derived segmentation images based on the referenced imageIds, this\n * is a helper function, we don't have segmentation concept in the cornerstone core; however,\n * this helper would make it clear that the segmentation images SHOULD be Uint8Array type\n * always until we have a better solution.\n *\n * @param referencedImageIds - An array of referenced image IDs.\n * @param options - The options for creating the derived images (default: { targetBufferType: 'Uint8Array' }).\n * @returns The derived images.\n */\nexport function createAndCacheDerivedSegmentationImages(\n  referencedImageIds: Array<string>,\n  options: DerivedImageOptions = {\n    targetBufferType: 'Uint8Array',\n  }\n): DerivedImages {\n  return createAndCacheDerivedImages(referencedImageIds, options);\n}\n\n/**\n * Creates and caches a derived segmentation image based on the referenced image ID.\n * this is a helper function, we don't have segmentation concept in the cornerstone core; however,\n * this helper would make it clear that the segmentation images SHOULD be Uint8Array type\n * always until we have a better solution.\n *\n * @param referencedImageId The ID of the referenced image.\n * @param options The options for creating the derived image (default: { targetBufferType: 'Uint8Array' }).\n * @returns A promise that resolves to the created derived segmentation image.\n */\nexport function createAndCacheDerivedSegmentationImage(\n  referencedImageId: string,\n  options: DerivedImageOptions = {\n    targetBufferType: 'Uint8Array',\n  }\n): Promise<IImage> {\n  return createAndCacheDerivedImage(referencedImageId, options);\n}\n","import '@kitware/vtk.js/Rendering/Profiles/Volume';\n\nimport vtkImageData from '@kitware/vtk.js/Common/DataModel/ImageData';\nimport type { vtkImageData as vtkImageDataType } from '@kitware/vtk.js/Common/DataModel/ImageData';\nimport vtkDataArray from '@kitware/vtk.js/Common/Core/DataArray';\n\nimport { ImageVolume } from '../cache/classes/ImageVolume';\nimport cache from '../cache/cache';\nimport Events from '../enums/Events';\nimport eventTarget from '../eventTarget';\nimport triggerEvent from '../utilities/triggerEvent';\nimport cloneDeep from 'lodash.clonedeep';\n\nimport {\n  generateVolumePropsFromImageIds,\n  getBufferConfiguration,\n  uuidv4,\n} from '../utilities';\nimport {\n  Point3,\n  Metadata,\n  EventTypes,\n  Mat3,\n  IImageVolume,\n  VolumeLoaderFn,\n  IDynamicImageVolume,\n  PixelDataTypedArray,\n  IVolumeLoadObject,\n  PixelDataTypedArrayString,\n} from '../types';\nimport { getConfiguration } from '../init';\nimport {\n  performCacheOptimizationForVolume,\n  setupCacheOptimizationEventListener,\n} from '../utilities/cacheUtils';\n\ninterface VolumeLoaderOptions {\n  imageIds: Array<string>;\n}\n\ninterface DerivedVolumeOptions {\n  volumeId: string;\n  targetBuffer?: {\n    type: PixelDataTypedArrayString;\n    sharedArrayBuffer?: boolean;\n  };\n}\ninterface LocalVolumeOptions {\n  metadata: Metadata;\n  dimensions: Point3;\n  spacing: Point3;\n  origin: Point3;\n  direction: Mat3;\n  scalarData?: PixelDataTypedArray;\n  imageIds?: Array<string>;\n  referencedImageIds?: Array<string>;\n  referencedVolumeId?: string;\n  targetBuffer?: {\n    type: PixelDataTypedArrayString;\n    sharedArrayBuffer?: boolean;\n  };\n}\n\n/**\n * Adds a single scalar data to a 3D volume\n */\nfunction addScalarDataToImageData(\n  imageData: vtkImageDataType,\n  scalarData: PixelDataTypedArray,\n  dataArrayAttrs\n) {\n  const scalarArray = vtkDataArray.newInstance({\n    name: `Pixels`,\n    values: scalarData,\n    ...dataArrayAttrs,\n  });\n\n  imageData.getPointData().setScalars(scalarArray);\n}\n\n/**\n * Adds multiple scalar data (time points) to a 4D volume\n */\nfunction addScalarDataArraysToImageData(\n  imageData: vtkImageDataType,\n  scalarDataArrays: PixelDataTypedArray[],\n  dataArrayAttrs\n) {\n  scalarDataArrays.forEach((scalarData, i) => {\n    const vtkScalarArray = vtkDataArray.newInstance({\n      name: `timePoint-${i}`,\n      values: scalarData,\n      ...dataArrayAttrs,\n    });\n\n    imageData.getPointData().addArray(vtkScalarArray);\n  });\n\n  // Set the first as active otherwise nothing is displayed on the screen\n  imageData.getPointData().setActiveScalars('timePoint-0');\n}\n\nfunction createInternalVTKRepresentation(\n  volume: IImageVolume\n): vtkImageDataType {\n  const { dimensions, metadata, spacing, direction, origin } = volume;\n  const { PhotometricInterpretation } = metadata;\n\n  let numComponents = 1;\n  if (PhotometricInterpretation === 'RGB') {\n    numComponents = 3;\n  }\n\n  const imageData = vtkImageData.newInstance();\n  const dataArrayAttrs = { numberOfComponents: numComponents };\n\n  imageData.setDimensions(dimensions);\n  imageData.setSpacing(spacing);\n  imageData.setDirection(direction);\n  imageData.setOrigin(origin);\n\n  // Add scalar data to 3D or 4D volume\n  if (volume.isDynamicVolume()) {\n    const scalarDataArrays = (<IDynamicImageVolume>(\n      volume\n    )).getScalarDataArrays();\n\n    addScalarDataArraysToImageData(imageData, scalarDataArrays, dataArrayAttrs);\n  } else {\n    const scalarData = volume.getScalarData();\n\n    addScalarDataToImageData(imageData, scalarData, dataArrayAttrs);\n  }\n\n  return imageData;\n}\n\n/**\n * This module deals with VolumeLoaders and loading volumes\n */\n\nconst volumeLoaders = {};\n\nlet unknownVolumeLoader;\n\n/**\n * Load a volume using a registered Cornerstone Volume Loader.\n *\n * The volume loader that is used will be\n * determined by the volume loader scheme matching against the volumeId.\n *\n * @param volumeId - A Cornerstone Volume Object's volumeId\n * @param options - Options to be passed to the Volume Loader. Options\n * contain the ImageIds that is passed to the loader\n *\n * @returns An Object which can be used to act after a volume is loaded or loading fails\n *\n */\nfunction loadVolumeFromVolumeLoader(\n  volumeId: string,\n  options?: VolumeLoaderOptions\n): IVolumeLoadObject {\n  const colonIndex = volumeId.indexOf(':');\n  const scheme = volumeId.substring(0, colonIndex);\n  let loader = volumeLoaders[scheme];\n\n  if (loader === undefined || loader === null) {\n    if (\n      unknownVolumeLoader == null ||\n      typeof unknownVolumeLoader !== 'function'\n    ) {\n      throw new Error(\n        `No volume loader for scheme ${scheme} has been registered`\n      );\n    }\n\n    loader = unknownVolumeLoader;\n  }\n\n  const volumeLoadObject = loader(volumeId, options);\n\n  setupCacheOptimizationEventListener(volumeId);\n\n  // Broadcast a volume loaded event once the image is loaded\n  volumeLoadObject.promise.then(\n    function (volume) {\n      triggerEvent(eventTarget, Events.VOLUME_LOADED, { volume });\n    },\n    function (error) {\n      const errorObject: EventTypes.VolumeLoadedFailedEventDetail = {\n        volumeId,\n        error,\n      };\n\n      triggerEvent(eventTarget, Events.VOLUME_LOADED_FAILED, errorObject);\n    }\n  );\n\n  return volumeLoadObject;\n}\n\n/**\n * Loads a volume given a volumeId and optional priority and returns a promise which will resolve to\n * the loaded image object or fail if an error occurred.  The loaded image is not stored in the cache.\n *\n * @param volumeId - A Cornerstone Image Object's volumeId\n * @param options - Options to be passed to the Volume Loader\n *\n * @returns An Object which can be used to act after an image is loaded or loading fails\n */\nexport function loadVolume(\n  volumeId: string,\n  options: VolumeLoaderOptions = { imageIds: [] }\n): Promise<IImageVolume> {\n  if (volumeId === undefined) {\n    throw new Error('loadVolume: parameter volumeId must not be undefined');\n  }\n\n  let volumeLoadObject = cache.getVolumeLoadObject(volumeId);\n\n  if (volumeLoadObject !== undefined) {\n    return volumeLoadObject.promise;\n  }\n\n  volumeLoadObject = loadVolumeFromVolumeLoader(volumeId, options);\n\n  return volumeLoadObject.promise.then((volume: IImageVolume) => {\n    volume.imageData = createInternalVTKRepresentation(volume);\n    return volume;\n  });\n}\n\n/**\n * Loads an image given an volumeId and optional priority and returns a promise which will resolve to\n * the loaded image object or fail if an error occurred. The image is stored in the cache.\n *\n * @param volumeId - A Cornerstone Image Object's volumeId\n * @param options - Options to be passed to the Volume Loader\n *\n * @returns Volume Loader Object\n */\nexport async function createAndCacheVolume(\n  volumeId: string,\n  options?: VolumeLoaderOptions\n): Promise<Record<string, any>> {\n  if (volumeId === undefined) {\n    throw new Error(\n      'createAndCacheVolume: parameter volumeId must not be undefined'\n    );\n  }\n\n  let volumeLoadObject = cache.getVolumeLoadObject(volumeId);\n\n  if (volumeLoadObject !== undefined) {\n    return volumeLoadObject.promise;\n  }\n\n  volumeLoadObject = loadVolumeFromVolumeLoader(volumeId, options);\n\n  volumeLoadObject.promise.then((volume: IImageVolume) => {\n    volume.imageData = createInternalVTKRepresentation(volume);\n  });\n\n  cache.putVolumeLoadObject(volumeId, volumeLoadObject).catch((err) => {\n    throw err;\n  });\n\n  return volumeLoadObject.promise;\n}\n\n/**\n * Based on a referencedVolumeId, it will build and cache a new volume. If\n * no scalarData is specified in the options, an empty derived volume will be\n * created that matches the image metadata of the referenceVolume. If scalarData\n * is given, it will be used to generate the intensity values for the derivedVolume.\n * Finally, it will save the volume in the cache.\n * @param referencedVolumeId - the volumeId from which the new volume will get its metadata\n * @param options - DerivedVolumeOptions {uid: derivedVolumeUID, targetBuffer: { type: Float32Array | Uint8Array |\n * Uint16Array | Uint32Array  }, scalarData: if provided}\n *\n * @returns ImageVolume\n */\nexport async function createAndCacheDerivedVolume(\n  referencedVolumeId: string,\n  options: DerivedVolumeOptions\n): Promise<IImageVolume> {\n  const referencedVolume = cache.getVolume(referencedVolumeId);\n  if (!referencedVolume) {\n    throw new Error(\n      `Cannot created derived volume: Referenced volume with id ${referencedVolumeId} does not exist.`\n    );\n  }\n\n  let { volumeId } = options;\n  const { targetBuffer } = options;\n\n  if (volumeId === undefined) {\n    volumeId = uuidv4();\n  }\n\n  const { metadata, dimensions, spacing, origin, direction } = referencedVolume;\n  const scalarData = referencedVolume.getScalarData();\n  const scalarLength = scalarData.length;\n\n  const { volumeScalarData, numBytes } = generateVolumeScalarData(\n    targetBuffer,\n    scalarLength\n  );\n\n  // Todo: handle more than one component for segmentation (RGB)\n  const scalarArray = vtkDataArray.newInstance({\n    name: 'Pixels',\n    numberOfComponents: 1,\n    values: volumeScalarData,\n  });\n\n  const derivedImageData = vtkImageData.newInstance();\n\n  derivedImageData.setDimensions(dimensions);\n  derivedImageData.setSpacing(spacing);\n  derivedImageData.setDirection(direction);\n  derivedImageData.setOrigin(origin);\n  derivedImageData.getPointData().setScalars(scalarArray);\n\n  const derivedVolume = new ImageVolume({\n    volumeId,\n    metadata: cloneDeep(metadata),\n    dimensions: [dimensions[0], dimensions[1], dimensions[2]],\n    spacing,\n    origin,\n    direction,\n    imageData: derivedImageData,\n    scalarData: volumeScalarData,\n    sizeInBytes: numBytes,\n    imageIds: [],\n    referencedVolumeId,\n  });\n\n  const volumeLoadObject = {\n    promise: Promise.resolve(derivedVolume),\n  };\n\n  await cache.putVolumeLoadObject(volumeId, volumeLoadObject);\n\n  return derivedVolume;\n}\n\n/**\n * Creates and cache a volume based on a set of provided properties including\n * dimensions, spacing, origin, direction, metadata, scalarData. It should be noted that\n * scalarData should be provided for this function to work. If a volume with the same\n * Id exists in the cache it returns it immediately.\n * @param options -  { scalarData, metadata, dimensions, spacing, origin, direction }\n * @param volumeId - Id of the generated volume\n *\n * @returns ImageVolume\n */\nexport function createLocalVolume(\n  options: LocalVolumeOptions,\n  volumeId: string,\n  preventCache = false\n): IImageVolume {\n  const { metadata, dimensions, spacing, origin, direction, targetBuffer } =\n    options;\n\n  let { scalarData } = options;\n\n  // Define the valid data types for scalarData\n  const validDataTypes = [\n    'Uint8Array',\n    'Float32Array',\n    'Uint16Array',\n    'Int16Array',\n  ];\n\n  const scalarLength = dimensions[0] * dimensions[1] * dimensions[2];\n\n  // Check if scalarData is provided and is of a valid type\n  if (!scalarData || !validDataTypes.includes(scalarData.constructor.name)) {\n    // Check if targetBuffer is provided and has a valid type\n    if (!targetBuffer?.type || !validDataTypes.includes(targetBuffer.type)) {\n      throw new Error(\n        'createLocalVolume: parameter scalarData must be provided and must be either Uint8Array, Float32Array, Uint16Array or Int16Array'\n      );\n    }\n\n    // Generate volume scalar data if scalarData is not provided or invalid\n    ({ volumeScalarData: scalarData } = generateVolumeScalarData(\n      targetBuffer,\n      scalarLength\n    ));\n  }\n\n  // Todo: handle default values for spacing, origin, direction if not provided\n  if (volumeId === undefined) {\n    volumeId = uuidv4();\n  }\n\n  const cachedVolume = cache.getVolume(volumeId);\n\n  if (cachedVolume) {\n    return cachedVolume as IImageVolume;\n  }\n\n  const numBytes = scalarData ? scalarData.buffer.byteLength : scalarLength * 4;\n\n  // check if there is enough space in unallocated + image Cache\n  const isCacheable = cache.isCacheable(numBytes);\n  if (!isCacheable) {\n    throw new Error(Events.CACHE_SIZE_EXCEEDED);\n  }\n\n  const scalarArray = vtkDataArray.newInstance({\n    name: 'Pixels',\n    numberOfComponents: 1,\n    values: scalarData,\n  });\n\n  const imageData = vtkImageData.newInstance();\n\n  imageData.setDimensions(dimensions);\n  imageData.setSpacing(spacing);\n  imageData.setDirection(direction);\n  imageData.setOrigin(origin);\n  imageData.getPointData().setScalars(scalarArray);\n\n  const derivedVolume = new ImageVolume({\n    volumeId,\n    metadata: cloneDeep(metadata),\n    dimensions: [dimensions[0], dimensions[1], dimensions[2]],\n    spacing,\n    origin,\n    direction,\n    imageData: imageData,\n    scalarData,\n    sizeInBytes: numBytes,\n    referencedImageIds: options.referencedImageIds || [],\n    referencedVolumeId: options.referencedVolumeId,\n    imageIds: options.imageIds || [],\n  });\n\n  if (preventCache) {\n    return derivedVolume;\n  }\n\n  const volumeLoadObject = {\n    promise: Promise.resolve(derivedVolume),\n  };\n  cache.putVolumeLoadObject(volumeId, volumeLoadObject);\n\n  return derivedVolume;\n}\n\nexport async function createAndCacheVolumeFromImages(\n  volumeId: string,\n  imageIds: string[],\n  options: {\n    preventCache?: boolean;\n    additionalDetails?: Record<string, any>;\n  } = {}\n): Promise<IImageVolume> {\n  const { preventCache = false } = options;\n\n  if (imageIds === undefined) {\n    throw new Error(\n      'createAndCacheVolumeFromImages: parameter imageIds must not be undefined'\n    );\n  }\n\n  if (volumeId === undefined) {\n    throw new Error(\n      'createAndCacheVolumeFromImages: parameter volumeId must not be undefined'\n    );\n  }\n\n  const cachedVolume = cache.getVolume(volumeId);\n\n  if (cachedVolume) {\n    return Promise.resolve(cachedVolume);\n  }\n\n  const volumeProps = generateVolumePropsFromImageIds(imageIds, volumeId);\n\n  // volume is an empty volume, we need to load the data from the imageIds\n  // into the volume scalarData\n\n  // it is important to get the imageIds from the volumeProps\n  // since they are sorted\n  const imagePromises = volumeProps.imageIds.map((imageId, imageIdIndex) => {\n    const imageLoadObject = cache.getImageLoadObject(imageId);\n\n    return imageLoadObject.promise.then((image) => {\n      const pixelData = image.getPixelData();\n      const offset = imageIdIndex * image.rows * image.columns;\n\n      (volumeProps.scalarData as PixelDataTypedArray).set(pixelData, offset);\n    });\n  });\n\n  await Promise.all(imagePromises);\n\n  const volume = new ImageVolume({\n    ...volumeProps,\n    referencedImageIds: imageIds,\n    ...options,\n  });\n\n  // since we generated the volume from images, we can optimize the cache\n  // by replacing the pixelData of the images with a view of the volume's\n  // scalarData\n  performCacheOptimizationForVolume(volume);\n\n  const volumeLoadObject = {\n    promise: Promise.resolve(volume),\n  };\n\n  if (preventCache) {\n    return volumeLoadObject.promise;\n  }\n\n  cache.putVolumeLoadObject(volumeId, volumeLoadObject);\n\n  return volumeLoadObject.promise;\n}\n\n/**\n * Registers an volumeLoader plugin with cornerstone for the specified scheme\n *\n * @param scheme - The scheme to use for this volume loader (e.g. 'dicomweb', 'wadouri', 'http')\n * @param volumeLoader - A Cornerstone Volume Loader function\n */\nexport function registerVolumeLoader(\n  scheme: string,\n  volumeLoader: VolumeLoaderFn\n): void {\n  volumeLoaders[scheme] = volumeLoader;\n}\n\n/** Gets the array of volume loader schemes */\nexport function getVolumeLoaderSchemes(): string[] {\n  return Object.keys(volumeLoaders);\n}\n\n/**\n * Registers a new unknownVolumeLoader and returns the previous one\n *\n * @param volumeLoader - A Cornerstone Volume Loader\n *\n * @returns The previous Unknown Volume Loader\n */\nexport function registerUnknownVolumeLoader(\n  volumeLoader: VolumeLoaderFn\n): VolumeLoaderFn | undefined {\n  const oldVolumeLoader = unknownVolumeLoader;\n\n  unknownVolumeLoader = volumeLoader;\n\n  return oldVolumeLoader;\n}\n\nexport function getUnknownVolumeLoaderSchema(): string {\n  return unknownVolumeLoader.name;\n}\n\n/**\n * Creates and caches a derived segmentation volume based on a referenced volume.\n * This is basically a utility method since for the segmentations we have to specify\n * Uint8Array as the targetBuffer type for now until we support other types.\n *\n * @param referencedVolumeId - The ID of the referenced volume.\n * @param options - The options for creating the derived volume.\n * @returns A promise that resolves to the created derived segmentation volume.\n */\nexport async function createAndCacheDerivedSegmentationVolume(\n  referencedVolumeId: string,\n  options = {} as DerivedVolumeOptions\n): Promise<IImageVolume> {\n  return createAndCacheDerivedVolume(referencedVolumeId, {\n    ...options,\n    targetBuffer: {\n      type: 'Uint8Array',\n    },\n  });\n}\n\n/**\n * Creates a local segmentation volume.\n *\n * @param options - The options for creating the volume.\n * @param volumeId - The ID of the volume.\n * @param preventCache - Whether to prevent caching the volume.\n * @returns A promise that resolves to the created image volume.\n */\nexport async function createLocalSegmentationVolume(\n  options: LocalVolumeOptions,\n  volumeId: string,\n  preventCache = false\n): Promise<IImageVolume> {\n  if (!options.scalarData) {\n    options.scalarData = new Uint8Array(\n      options.dimensions[0] * options.dimensions[1] * options.dimensions[2]\n    );\n  }\n\n  return createLocalVolume(options, volumeId, preventCache);\n}\n\n/**\n * This function generates volume scalar data based on the provided target buffer and scalar length.\n * It checks if the cache can accommodate the data size and throws an error if it exceeds the cache size.\n * If a shared array buffer is available in the target buffer, it uses that to create the typed array.\n * Otherwise, it creates a typed array based on the scalar length.\n *\n * @param targetBuffer - The target buffer object which may contain a type and a shared array buffer.\n * @param scalarLength - The scalar length for creating the typed array.\n * @param useNorm16Texture - A flag to specify whether to use a 16-bit texture or not.\n * @returns The volume scalar data as a typed array.\n */\nfunction generateVolumeScalarData(\n  targetBuffer: {\n    type: PixelDataTypedArrayString;\n    sharedArrayBuffer?: boolean;\n  },\n  scalarLength: number\n) {\n  const { useNorm16Texture } = getConfiguration().rendering;\n\n  const { TypedArrayConstructor, numBytes } = getBufferConfiguration(\n    targetBuffer?.type,\n    scalarLength,\n    {\n      use16BitTexture: useNorm16Texture,\n      isVolumeBuffer: true,\n    }\n  );\n\n  const isCacheable = cache.isCacheable(numBytes);\n  if (!isCacheable) {\n    throw new Error(Events.CACHE_SIZE_EXCEEDED);\n  }\n\n  let volumeScalarData;\n  if (targetBuffer?.sharedArrayBuffer) {\n    const buffer = new SharedArrayBuffer(numBytes);\n    volumeScalarData = new TypedArrayConstructor(buffer);\n  } else {\n    volumeScalarData = new TypedArrayConstructor(scalarLength);\n  }\n\n  return { volumeScalarData, numBytes };\n}\n","// This module defines a way to access various metadata about an imageId.  This layer of abstraction exists\n// So metadata can be provided in different ways (e.g. by parsing DICOM P10 or by a WADO-RS document)\n\nconst providers = [];\n\n/**\n * Adds a metadata provider with the specified priority\n * @param provider - Metadata provider function\n * @param priority - 0 is default/normal, > 0 is high, < 0 is low\n *\n * @category MetaData\n */\nexport function addProvider(\n  provider: (type: string, ...query: string[]) => any,\n  priority = 0\n): void {\n  let i;\n\n  // Find the right spot to insert this provider based on priority\n  for (i = 0; i < providers.length; i++) {\n    if (providers[i].priority <= priority) {\n      break;\n    }\n  }\n\n  // Insert the decode task at position i\n  providers.splice(i, 0, {\n    priority,\n    provider,\n  });\n}\n\n/**\n * Removes the specified provider\n *\n * @param provider - Metadata provider function\n *\n * @category MetaData\n */\nexport function removeProvider(\n  provider: (type: string, query: any) => { any }\n): void {\n  for (let i = 0; i < providers.length; i++) {\n    if (providers[i].provider === provider) {\n      providers.splice(i, 1);\n\n      break;\n    }\n  }\n}\n\n/**\n * Removes all providers\n *\n * @category MetaData\n */\nexport function removeAllProviders(): void {\n  while (providers.length > 0) {\n    providers.pop();\n  }\n}\n\n/**\n * Gets metadata from the registered metadata providers.  Will call each one from highest priority to lowest\n * until one responds\n *\n * @param type -  The type of metadata requested from the metadata store\n * @param query - The query for the metadata store, often imageId\n *        Some metadata providers support multi-valued strings, which are interpretted\n *        as the provider chooses.\n *\n * @returns The metadata retrieved from the metadata store\n * @category MetaData\n */\nfunction getMetaData(type: string, ...queries): any {\n  // Invoke each provider in priority order until one returns something\n  for (let i = 0; i < providers.length; i++) {\n    const result = providers[i].provider(type, ...queries);\n\n    if (result !== undefined) {\n      return result;\n    }\n  }\n}\n\nexport { getMetaData as get };\n","import { RequestPoolManager } from './requestPoolManager';\nimport RequestType from '../enums/RequestType';\n\n/**\n * You can use the imageLoadPoolManager to load images, by providing a `requestFn`\n * that returns a promise for the image. You can provide a `type` to specify the type of\n * request (interaction, thumbnail, prefetch), and you can provide additional details\n * that will be passed to the requestFn. Below is an example of a requestFn that loads\n * an image from an imageId:\n *\n * ```javascript\n *\n * const priority = -5\n * const requestType = RequestType.Interaction\n * const additionalDetails = { imageId }\n * const options = {\n *   targetBuffer: {\n *     type: 'Float32Array',\n *     offset: null,\n *     length: null,\n *   },\n *   preScale: {\n *     enabled: true,\n *   },\n * }\n *\n * imageLoadPoolManager.addRequest(\n *   loadAndCacheImage(imageId, options).then(() => { // set on viewport}),\n *   requestType,\n *   additionalDetails,\n *   priority\n * )\n * ```\n */\nconst imageLoadPoolManager = new RequestPoolManager('imageLoadPool');\n\nimageLoadPoolManager.grabDelay = 0;\n\nimageLoadPoolManager.setMaxSimultaneousRequests(RequestType.Interaction, 1000);\nimageLoadPoolManager.setMaxSimultaneousRequests(RequestType.Thumbnail, 1000);\nimageLoadPoolManager.setMaxSimultaneousRequests(RequestType.Prefetch, 1000);\n\nexport default imageLoadPoolManager;\n","import RequestType from '../enums/RequestType';\nimport { IImage } from '../types';\nimport { uuidv4 } from '../utilities';\n\ntype AdditionalDetails = {\n  imageId?: string;\n  volumeId?: string;\n};\n\ntype RequestDetailsInterface = {\n  requestFn: () => Promise<IImage | void>;\n  type: RequestType;\n  additionalDetails: AdditionalDetails;\n};\n\ntype RequestPool = {\n  [name in RequestType]: { [key: number]: RequestDetailsInterface[] };\n};\n\n/**\n * RequestPool manager class is a base class that manages the request pools.\n * It is used imageRetrievalPoolManager, and imageLoadPoolManager to retrieve and load images.\n * Previously requestPoolManager was used to manage the retrieval and loading and decoding\n * of the images in a way that new requests were sent after the image was both loaded and decoded\n * which was not performant since it was waiting for the image to be loaded and decoded before\n * sending the next request which is a network request and can be done in parallel.\n * Now, we use separate imageRetrievalPoolManager and imageLoadPoolManager\n * to improve performance and both are extending the RequestPoolManager class which\n * is a basic queueing pool.\n *\n * A new requestPool can be created by instantiating a new RequestPoolManager class.\n *\n * ```javascript\n * const requestPoolManager = new RequestPoolManager()\n * ```\n *\n * ## ImageLoadPoolManager\n *\n * You can use the imageLoadPoolManager to load images, by providing a `requestFn`\n * that returns a promise for the image. You can provide a `type` to specify the type of\n * request (interaction, thumbnail, prefetch), and you can provide additional details\n * that will be passed to the requestFn. Below is an example of a requestFn that loads\n * an image from an imageId:\n *\n * ```javascript\n *\n * const priority = -5\n * const requestType = RequestType.Interaction\n * const additionalDetails = { imageId }\n * const options = {\n *   targetBuffer: {\n *     type: 'Float32Array',\n *     offset: null,\n *     length: null,\n *   },\n *   preScale: {\n *      enabled: true,\n *    },\n * }\n *\n * imageLoadPoolManager.addRequest(\n *   loadAndCacheImage(imageId, options).then(() => { // set on viewport}),\n *   requestType,\n *   additionalDetails,\n *   priority\n * )\n * ```\n * ### ImageRetrievalPoolManager\n * You don't need to directly use the imageRetrievalPoolManager to load images\n * since the imageLoadPoolManager will automatically use it for retrieval. However,\n * maximum number of concurrent requests can be set by calling `setMaxConcurrentRequests`.\n */\nclass RequestPoolManager {\n  private id: string;\n  private awake: boolean;\n  private requestPool: RequestPool;\n  private numRequests = {\n    interaction: 0,\n    thumbnail: 0,\n    prefetch: 0,\n    compute: 0,\n  };\n  /* maximum number of requests of each type. */\n  public maxNumRequests: {\n    interaction: number;\n    thumbnail: number;\n    prefetch: number;\n    compute: number;\n  };\n  /* A public property that is used to set the delay between requests. */\n  public grabDelay: number;\n  private timeoutHandle: number;\n\n  /**\n   * By default a request pool containing three priority groups, one for each\n   * of the request types, is created. Maximum number of requests of each type\n   * is set to 6.\n   */\n  constructor(id?: string) {\n    this.id = id ? id : uuidv4();\n\n    this.requestPool = {\n      interaction: { 0: [] },\n      thumbnail: { 0: [] },\n      prefetch: { 0: [] },\n      compute: { 0: [] },\n    };\n\n    this.grabDelay = 5;\n    this.awake = false;\n\n    this.numRequests = {\n      interaction: 0,\n      thumbnail: 0,\n      prefetch: 0,\n      compute: 0,\n    };\n\n    this.maxNumRequests = {\n      interaction: 6,\n      thumbnail: 6,\n      prefetch: 5,\n      // I believe there is a bug right now, where if there are two workers\n      // and one wants to run a compute job 6 times and the limit is just 5, then\n      // the other worker will never get a chance to run its compute job.\n      // we should probably have a separate limit for compute jobs per worker\n      // context as there is another layer of parallelism there. For this reason\n      // I'm setting the limit to 1000 for now.\n      compute: 1000,\n    };\n  }\n\n  /**\n   * This function sets the maximum number of requests for a given request type.\n   * @param type - The type of request you want to set the max number\n   * of requests for it can be either of interaction, prefetch, or thumbnail.\n   * @param maxNumRequests - The maximum number of requests that can be\n   * made at a time.\n   */\n  public setMaxSimultaneousRequests(\n    type: RequestType,\n    maxNumRequests: number\n  ): void {\n    this.maxNumRequests[type] = maxNumRequests;\n  }\n\n  /**\n   * It returns the maximum number of requests of a given type that can be made\n   * @param type - The type of request.\n   * @returns The maximum number of requests of a given type.\n   */\n  public getMaxSimultaneousRequests(type: RequestType): number {\n    return this.maxNumRequests[type];\n  }\n\n  /**\n   * Stops further fetching of the requests, all the ongoing requests will still\n   * be retrieved\n   */\n  public destroy(): void {\n    if (this.timeoutHandle) {\n      window.clearTimeout(this.timeoutHandle);\n    }\n  }\n\n  /**\n   * Adds the requests to the pool of requests.\n   *\n   * @param requestFn - A function that returns a promise which resolves in the image\n   * @param type - Priority category, it can be either of interaction, prefetch,\n   * or thumbnail.\n   * @param additionalDetails - Additional details that requests can contain.\n   * For instance the volumeId for the volume requests\n   * @param priority - Priority number for each category of requests. Its default\n   * value is priority 0. The lower the priority number, the higher the priority number\n   *\n   */\n  public addRequest(\n    requestFn: () => Promise<IImage | void>,\n    type: RequestType,\n    additionalDetails: Record<string, unknown>,\n    priority = 0\n  ): void {\n    // Describe the request\n    const requestDetails: RequestDetailsInterface = {\n      requestFn,\n      type,\n      additionalDetails,\n    };\n\n    // Check if the priority group exists on the request type\n    if (this.requestPool[type][priority] === undefined) {\n      this.requestPool[type][priority] = [];\n    }\n\n    // Adding the request to the correct priority group of the request type\n    this.requestPool[type][priority].push(requestDetails);\n\n    this.startGrabbing();\n  }\n\n  /**\n   * Filter the requestPoolManager's pool of request based on the result of\n   * provided filter function. The provided filter function needs to return false or true\n   *\n   * @param filterFunction - The filter function for filtering of the requests to keep\n   */\n  public filterRequests(\n    filterFunction: (requestDetails: RequestDetailsInterface) => boolean\n  ): void {\n    Object.keys(this.requestPool).forEach((type: string) => {\n      const requestType = this.requestPool[type];\n      Object.keys(requestType).forEach((priority) => {\n        requestType[priority] = requestType[priority].filter(\n          (requestDetails: RequestDetailsInterface) => {\n            return filterFunction(requestDetails);\n          }\n        );\n      });\n    });\n  }\n\n  /**\n   * Clears the requests specific to the provided type. For instance, the\n   * pool of requests of type 'interaction' can be cleared via this function.\n   *\n   *\n   * @param type - category of the request (either interaction, prefetch or thumbnail)\n   */\n  public clearRequestStack(type: string): void {\n    if (!this.requestPool[type]) {\n      throw new Error(`No category for the type ${type} found`);\n    }\n    this.requestPool[type] = { 0: [] };\n  }\n\n  private sendRequests(type) {\n    const requestsToSend = this.maxNumRequests[type] - this.numRequests[type];\n    let syncImageCount = 0;\n\n    for (let i = 0; i < requestsToSend; i++) {\n      const requestDetails = this.getNextRequest(type);\n      if (requestDetails === null) {\n        return false;\n      } else if (requestDetails) {\n        this.numRequests[type]++;\n        this.awake = true;\n\n        let requestResult;\n        try {\n          requestResult = requestDetails.requestFn();\n        } catch (e) {\n          // This is the only warning one will get, so need a warn message\n          console.warn('sendRequest failed', e);\n        }\n        if (requestResult?.finally) {\n          requestResult.finally(() => {\n            this.numRequests[type]--;\n            this.startAgain();\n          });\n        } else {\n          // Handle non-async request functions too - typically just short circuit ones\n          this.numRequests[type]--;\n          syncImageCount++;\n        }\n      }\n    }\n    if (syncImageCount) {\n      this.startAgain();\n    }\n\n    return true;\n  }\n\n  private getNextRequest(type): RequestDetailsInterface | null {\n    const interactionPriorities = this.getSortedPriorityGroups(type);\n    for (const priority of interactionPriorities) {\n      if (this.requestPool[type][priority].length) {\n        return this.requestPool[type][priority].shift();\n      }\n    }\n\n    return null;\n  }\n\n  protected startGrabbing(): void {\n    const hasRemainingInteractionRequests = this.sendRequests(\n      RequestType.Interaction\n    );\n    const hasRemainingThumbnailRequests = this.sendRequests(\n      RequestType.Thumbnail\n    );\n    const hasRemainingPrefetchRequests = this.sendRequests(\n      RequestType.Prefetch\n    );\n    const hasRemainingComputeRequests = this.sendRequests(RequestType.Compute);\n\n    if (\n      !hasRemainingInteractionRequests &&\n      !hasRemainingThumbnailRequests &&\n      !hasRemainingPrefetchRequests &&\n      !hasRemainingComputeRequests\n    ) {\n      this.awake = false;\n    }\n  }\n\n  protected startAgain(): void {\n    if (!this.awake) {\n      return;\n    }\n\n    if (this.grabDelay !== undefined) {\n      // Prevents calling setTimeout hundreds of times when hundreds of requests\n      // are added which make it slower and works in an unexpected way when\n      // destroy/clearTimeout is called because only the last handle is stored.\n      if (!this.timeoutHandle) {\n        this.timeoutHandle = window.setTimeout(() => {\n          this.timeoutHandle = null;\n          this.startGrabbing();\n        }, this.grabDelay);\n      }\n    } else {\n      this.startGrabbing();\n    }\n  }\n\n  protected getSortedPriorityGroups(type: string): Array<number> {\n    const priorities = Object.keys(this.requestPool[type])\n      .map(Number)\n      .filter((priority) => this.requestPool[type][priority].length)\n      .sort((a, b) => a - b);\n    return priorities;\n  }\n\n  /**\n   * Returns the request pool containing different categories, their priority and\n   * the added request details.\n   *\n   * @returns the request pool which contains different categories, their priority and\n   * the added request details\n   */\n  getRequestPool(): RequestPool {\n    return this.requestPool;\n  }\n}\n\nexport { RequestPoolManager };\n","import eventTarget from '../eventTarget';\n\n/**\n * Small utility to trigger a custom event for a given EventTarget.\n *\n * @example\n *\n * ```javascript\n * triggerEvent(element, Events.IMAGE_RENDERED, { element })\n * ```\n * or it can trigger event on the eventTarget itself\n *\n * ```javascript\n * triggerEvent(eventTarget, CSTOOLS_EVENTS.ANNOTATION_MODIFIED, { viewportId, annotationUID })\n * ```\n *\n * @param el - The element or EventTarget to trigger the event upon\n * @param type - The event type name\n * @param detail - The event detail to be sent\n * @returns false if event is cancelable and at least one of the event handlers\n * which received event called Event.preventDefault(). Otherwise it returns true.\n */\nexport default function triggerEvent(\n  el: EventTarget = eventTarget,\n  type: string,\n  detail: unknown = null\n): boolean {\n  if (!type) {\n    throw new Error('Event type was not defined');\n  }\n\n  const event = new CustomEvent(type, {\n    detail,\n    cancelable: true,\n  });\n\n  return el.dispatchEvent(event);\n}\n","import * as Comlink from 'comlink';\nimport { RequestType } from '../enums/';\nimport { RequestPoolManager } from '../requestPool/requestPoolManager';\n\nclass CentralizedWorkerManager {\n  constructor() {\n    this.workerRegistry = {};\n    this.workerPoolManager = new RequestPoolManager('webworker');\n  }\n\n  /**\n   * Registers a new worker, it doesn't mean that the function will get executed.\n   *\n   * @param workerName - The name of the worker.\n   * @param workerFn - The function that creates a new instance of the worker.\n   * @param options - Optional parameters.\n   * @param options.maxWorkerInstances - The maximum number of instances of this worker that can be created.\n   * For instance if you create a worker with maxWorkerInstances = 2, then only 2 instances of this worker will be created\n   * and in case there are 10 tasks that need to be executed, each will get assigned 5 tasks.\n   * @param options.overwrite - Whether to overwrite the worker if it's already registered.\n   * @param options.autoTerminateOnIdle - Whether to automatically terminate idle workers.\n   */\n  registerWorker(workerName, workerFn, options = {}) {\n    const {\n      maxWorkerInstances = 1,\n      overwrite = false,\n      autoTerminateOnIdle = {\n        enabled: false,\n        idleTimeThreshold: 3000, // 3 seconds\n      },\n    } = options;\n\n    if (this.workerRegistry[workerName] && !overwrite) {\n      console.warn(`Worker type '${workerName}' is already registered...`);\n      return;\n    }\n\n    if (overwrite && this.workerRegistry[workerName]?.idleCheckIntervalId) {\n      clearInterval(this.workerRegistry[workerName].idleCheckIntervalId);\n    }\n\n    const workerProperties = {\n      workerFn: null,\n      instances: [],\n      loadCounters: [],\n      lastActiveTime: [],\n      // used for termination\n      nativeWorkers: [],\n      // auto termination\n      autoTerminateOnIdle: autoTerminateOnIdle.enabled,\n      idleCheckIntervalId: null,\n      idleTimeThreshold: autoTerminateOnIdle.idleTimeThreshold,\n    };\n\n    workerProperties.loadCounters = Array(maxWorkerInstances).fill(0);\n    workerProperties.lastActiveTime = Array(maxWorkerInstances).fill(null);\n\n    for (let i = 0; i < maxWorkerInstances; i++) {\n      const worker = workerFn();\n      workerProperties.instances.push(Comlink.wrap(worker));\n      workerProperties.nativeWorkers.push(worker);\n      workerProperties.workerFn = workerFn;\n    }\n\n    this.workerRegistry[workerName] = workerProperties;\n  }\n\n  getNextWorkerAPI(workerName) {\n    const workerProperties = this.workerRegistry[workerName];\n\n    if (!workerProperties) {\n      console.error(`Worker type '${workerName}' is not registered.`);\n      return null;\n    }\n\n    // Find the worker with the minimum load.\n    const workerInstances = workerProperties.instances.filter(\n      (instance) => instance !== null\n    );\n\n    let minLoadIndex = 0;\n    let minLoadValue = workerProperties.loadCounters[0] || 0;\n    for (let i = 1; i < workerInstances.length; i++) {\n      const currentLoadValue = workerProperties.loadCounters[i] || 0;\n      if (currentLoadValue < minLoadValue) {\n        minLoadIndex = i;\n        minLoadValue = currentLoadValue;\n      }\n    }\n\n    // Check and recreate the worker if it was terminated.\n    if (workerProperties.instances[minLoadIndex] === null) {\n      const worker = workerProperties.workerFn();\n      workerProperties.instances[minLoadIndex] = Comlink.wrap(worker);\n      workerProperties.nativeWorkers[minLoadIndex] = worker;\n    }\n\n    // Update the load counter.\n    workerProperties.loadCounters[minLoadIndex] += 1;\n\n    // return the worker that has the minimum load.\n    return {\n      api: workerProperties.instances[minLoadIndex],\n      index: minLoadIndex,\n    };\n  }\n\n  /**\n   * Executes a task on a worker.\n   *\n   * @param workerName - The name of the worker to execute the task on.\n   * @param methodName - The name of the method to execute on the worker.\n   * @param args - The arguments to pass to the method. Default is an array\n   * You should put your transferable objects in the first argument as object\n   * and from the second argument you can put your non-transferable objects such\n   * as functions, classes, etc.\n   * @param options - An object containing options for the request. Default is an empty object.\n   * @param options.requestType - The type of the request. Default is RequestType.Compute.\n   * @param options.priority - The priority of the request. Default is 0.\n   * @param options.options - Additional options for the request. Default is an empty object.\n   *\n   * @returns A promise that resolves with the result of the task.\n   */\n  executeTask(\n    workerName,\n    methodName,\n    args = {},\n    {\n      requestType = RequestType.Compute,\n      priority = 0,\n      options = {},\n      callbacks = [],\n    } = {}\n  ) {\n    return new Promise((resolve, reject) => {\n      const requestFn = async () => {\n        const { api, index } = this.getNextWorkerAPI(workerName);\n        if (!api) {\n          const error = new Error(\n            `No available worker instance for '${workerName}'`\n          );\n          console.error(error);\n          reject(error);\n          return;\n        }\n\n        try {\n          // fix if any of the args keys are a function then we need to proxy it\n          // for the worker to be able to call it\n          let finalCallbacks = [];\n          if (callbacks.length) {\n            finalCallbacks = callbacks.map((cb) => {\n              return Comlink.proxy(cb);\n            });\n          }\n          const workerProperties = this.workerRegistry[workerName];\n\n          workerProperties.processing = true;\n\n          const results = await api[methodName](args, ...finalCallbacks);\n\n          workerProperties.processing = false;\n          workerProperties.lastActiveTime[index] = Date.now();\n\n          // If auto termination is enabled and the interval is not set, set it.\n          if (\n            workerProperties.autoTerminateOnIdle &&\n            !workerProperties.idleCheckIntervalId &&\n            workerProperties.idleTimeThreshold\n          ) {\n            workerProperties.idleCheckIntervalId = setInterval(() => {\n              this.terminateIdleWorkers(\n                workerName,\n                workerProperties.idleTimeThreshold\n              );\n            }, workerProperties.idleTimeThreshold);\n          }\n\n          resolve(results);\n        } catch (err) {\n          console.error(\n            `Error executing method '${methodName}' on worker '${workerName}':`,\n            err\n          );\n          reject(err);\n        } finally {\n          this.workerRegistry[workerName].loadCounters[index]--;\n        }\n      };\n\n      // I believe there is a bug right now, where if there are two workers\n      // and one wants to run a compute job 6 times and the limit is just 5, then\n      // the other worker will never get a chance to run its compute job.\n      // we should probably have a separate limit for compute jobs per worker\n      // context as there is another layer of parallelism there.\n      this.workerPoolManager.addRequest(\n        requestFn,\n        requestType,\n        options,\n        priority\n      );\n    });\n  }\n\n  terminateIdleWorkers(workerName, idleTimeThreshold) {\n    const workerProperties = this.workerRegistry[workerName];\n\n    if (workerProperties.processing) {\n      return;\n    }\n\n    const now = Date.now();\n\n    workerProperties.instances.forEach((_, index) => {\n      const lastActiveTime = workerProperties.lastActiveTime[index];\n      const isWorkerActive =\n        lastActiveTime !== null && workerProperties.loadCounters[index] > 0;\n      const idleTime = now - lastActiveTime;\n\n      if (!isWorkerActive && idleTime > idleTimeThreshold) {\n        this.terminateWorkerInstance(workerName, index);\n      }\n    });\n  }\n\n  terminate(workerName) {\n    const workerProperties = this.workerRegistry[workerName];\n    if (!workerProperties) {\n      console.error(`Worker type '${workerName}' is not registered.`);\n      return;\n    }\n\n    workerProperties.instances.forEach((_, index) => {\n      this.terminateWorkerInstance(workerName, index);\n    });\n  }\n\n  // New method to handle individual worker termination\n  terminateWorkerInstance(workerName, index) {\n    const workerProperties = this.workerRegistry[workerName];\n    const workerInstance = workerProperties.instances[index];\n\n    if (workerInstance !== null) {\n      workerInstance[Comlink.releaseProxy]();\n      workerProperties.nativeWorkers[index].terminate();\n\n      // Set the worker instance to null after termination\n      workerProperties.instances[index] = null;\n      workerProperties.lastActiveTime[index] = null;\n    }\n  }\n}\n\nexport default CentralizedWorkerManager;\n","import { vec2, vec3 } from 'gl-matrix';\nimport { getEnabledElement, utilities as csUtils } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { getCalibratedLengthUnitsAndScale } from '../../utilities/getCalibratedUnits';\nimport { roundNumber } from '../../utilities';\nimport { AnnotationTool } from '../base';\nimport throttle from '../../utilities/throttle';\nimport {\n  addAnnotation,\n  getAnnotations,\n  removeAnnotation,\n} from '../../stateManagement/annotation/annotationState';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport {\n  triggerAnnotationCompleted,\n  triggerAnnotationModified,\n} from '../../stateManagement/annotation/helpers/state';\nimport {\n  drawLine as drawLineSvg,\n  drawHandles as drawHandlesSvg,\n  drawLinkedTextBox as drawLinkedTextBoxSvg,\n} from '../../drawingSvg';\nimport { state } from '../../store';\nimport { Events } from '../../enums';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport * as lineSegment from '../../utilities/math/line';\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\nimport {\n  resetElementCursor,\n  hideElementCursor,\n} from '../../cursors/elementCursor';\nimport {\n  EventTypes,\n  ToolHandle,\n  TextBoxHandle,\n  PublicToolProps,\n  ToolProps,\n  SVGDrawingHelper,\n} from '../../types';\nimport { BidirectionalAnnotation } from '../../types/ToolSpecificAnnotationTypes';\n\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { StyleSpecifier } from '../../types/AnnotationStyle';\n\nconst { transformWorldToIndex } = csUtils;\n\n/**\n * BidirectionalTool let you draw annotations that measures the length and\n * width at the same time in `mm` unit. It is consisted of two perpendicular lines and\n * a text box. You can use the BidirectionalTool in all planes even in oblique\n * reconstructed planes. Note: annotation tools in cornerstone3DTools exists in the exact location\n * in the physical 3d space, as a result, by default, all annotations that are\n * drawing in the same frameOfReference will get shared between viewports that\n * are in the same frameOfReference.\n *\n * The resulting annotation's data (statistics) and metadata (the\n * state of the viewport while drawing was happening) will get added to the\n * ToolState manager and can be accessed from the ToolState by calling getAnnotations\n * or similar methods.\n *\n * ```js\n * cornerstoneTools.addTool(BidirectionalTool)\n *\n * const toolGroup = ToolGroupManager.createToolGroup('toolGroupId')\n *\n * toolGroup.addTool(BidirectionalTool.toolName)\n *\n * toolGroup.addViewport('viewportId', 'renderingEngineId')\n *\n * toolGroup.setToolActive(BidirectionalTool.toolName, {\n *   bindings: [\n *    {\n *       mouseButton: MouseBindings.Primary, // Left Click\n *     },\n *   ],\n * })\n * ```\n *\n * Read more in the Docs section of the website.\n */\n\nclass BidirectionalTool extends AnnotationTool {\n  static toolName;\n\n  touchDragCallback: any;\n  mouseDragCallback: any;\n  _throttledCalculateCachedStats: any;\n  editData: {\n    annotation: any;\n    viewportIdsToRender: string[];\n    handleIndex?: number;\n    movingTextBox: boolean;\n    newAnnotation?: boolean;\n    hasMoved?: boolean;\n  } | null;\n  isDrawing: boolean;\n  isHandleOutsideImage: boolean;\n  preventHandleOutsideImage: boolean;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        preventHandleOutsideImage: false,\n        getTextLines: defaultGetTextLines,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n\n    this._throttledCalculateCachedStats = throttle(\n      this._calculateCachedStats,\n      100,\n      { trailing: true }\n    );\n  }\n\n  /**\n   * Based on the current position of the mouse and the current imageId to create\n   * a Bidirectional Annotation and stores it in the annotationManager\n   *\n   * @param evt -  EventTypes.NormalizedMouseEventType\n   * @returns The annotation object.\n   *\n   */\n  addNewAnnotation(\n    evt: EventTypes.InteractionEventType\n  ): BidirectionalAnnotation {\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const worldPos = currentPoints.world;\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n\n    this.isDrawing = true;\n\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, viewUp } = camera;\n\n    const referencedImageId = this.getReferencedImageId(\n      viewport,\n      worldPos,\n      viewPlaneNormal,\n      viewUp\n    );\n\n    const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n\n    const annotation: BidirectionalAnnotation = {\n      highlighted: true,\n      invalidated: true,\n      metadata: {\n        toolName: this.getToolName(),\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\n        viewUp: <Types.Point3>[...viewUp],\n        FrameOfReferenceUID,\n        referencedImageId,\n      },\n      data: {\n        handles: {\n          points: [\n            // long\n            <Types.Point3>[...worldPos],\n            <Types.Point3>[...worldPos],\n            // short\n            <Types.Point3>[...worldPos],\n            <Types.Point3>[...worldPos],\n          ],\n          textBox: {\n            hasMoved: false,\n            worldPosition: <Types.Point3>[0, 0, 0],\n            worldBoundingBox: {\n              topLeft: <Types.Point3>[0, 0, 0],\n              topRight: <Types.Point3>[0, 0, 0],\n              bottomLeft: <Types.Point3>[0, 0, 0],\n              bottomRight: <Types.Point3>[0, 0, 0],\n            },\n          },\n          activeHandleIndex: null,\n        },\n        label: '',\n        cachedStats: {},\n      },\n    };\n\n    addAnnotation(annotation, element);\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      handleIndex: 1,\n      movingTextBox: false,\n      newAnnotation: true,\n      hasMoved: false,\n    };\n    this._activateDraw(element);\n\n    hideElementCursor(element);\n\n    evt.preventDefault();\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    return annotation;\n  }\n\n  /**\n   * It returns if the canvas point is near the provided annotation in the provided\n   * element or not. A proximity is passed to the function to determine the\n   * proximity of the point to the annotation in number of pixels.\n   *\n   * @param element - HTML Element\n   * @param annotation - Annotation\n   * @param canvasCoords - Canvas coordinates\n   * @param proximity - Proximity to tool to consider\n   * @returns Boolean, whether the canvas point is near tool\n   */\n  isPointNearTool = (\n    element: HTMLDivElement,\n    annotation: BidirectionalAnnotation,\n    canvasCoords: Types.Point2,\n    proximity: number\n  ): boolean => {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const { data } = annotation;\n    const { points } = data.handles;\n\n    // Check long axis\n    let canvasPoint1 = viewport.worldToCanvas(points[0]);\n    let canvasPoint2 = viewport.worldToCanvas(points[1]);\n\n    let line = {\n      start: {\n        x: canvasPoint1[0],\n        y: canvasPoint1[1],\n      },\n      end: {\n        x: canvasPoint2[0],\n        y: canvasPoint2[1],\n      },\n    };\n\n    let distanceToPoint = lineSegment.distanceToPoint(\n      [line.start.x, line.start.y],\n      [line.end.x, line.end.y],\n      [canvasCoords[0], canvasCoords[1]]\n    );\n\n    if (distanceToPoint <= proximity) {\n      return true;\n    }\n\n    // Check short axis\n    canvasPoint1 = viewport.worldToCanvas(points[2]);\n    canvasPoint2 = viewport.worldToCanvas(points[3]);\n\n    line = {\n      start: {\n        x: canvasPoint1[0],\n        y: canvasPoint1[1],\n      },\n      end: {\n        x: canvasPoint2[0],\n        y: canvasPoint2[1],\n      },\n    };\n\n    distanceToPoint = lineSegment.distanceToPoint(\n      [line.start.x, line.start.y],\n      [line.end.x, line.end.y],\n      [canvasCoords[0], canvasCoords[1]]\n    );\n\n    if (distanceToPoint <= proximity) {\n      return true;\n    }\n\n    return false;\n  };\n\n  /**\n   * Handles the toolSelected callback for bidirectional tool\n   * @param evt - EventTypes.MouseDownEventType\n   * @param annotation - Bidirectional annotation\n   * @param interactionType - interaction type (mouse, touch)\n   */\n  toolSelectedCallback = (\n    evt: EventTypes.InteractionEventType,\n    annotation: BidirectionalAnnotation\n  ): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    annotation.highlighted = true;\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      movingTextBox: false,\n    };\n\n    this._activateModify(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    hideElementCursor(element);\n\n    evt.preventDefault();\n  };\n\n  /**\n   * Executes the callback for when mouse has selected a handle (anchor point) of\n   * the bidirectional tool or when the text box has been selected.\n   *\n   * @param evt - EventTypes.MouseDownEventType\n   * @param annotation - Bidirectional annotation\n   * @param handle - Handle index or selected textBox information\n   * @param interactionType - interaction type (mouse, touch)\n   */\n  handleSelectedCallback = (\n    evt: EventTypes.InteractionEventType,\n    annotation: BidirectionalAnnotation,\n    handle: ToolHandle\n  ): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const data = annotation.data;\n\n    annotation.highlighted = true;\n\n    let movingTextBox = false;\n    let handleIndex;\n\n    if ((handle as TextBoxHandle).worldPosition) {\n      movingTextBox = true;\n    } else {\n      handleIndex = data.handles.points.findIndex((p) => p === handle);\n    }\n\n    // Find viewports to render on drag.\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    hideElementCursor(element);\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      handleIndex,\n      movingTextBox,\n    };\n    this._activateModify(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    evt.preventDefault();\n  };\n\n  /**\n   * Handles the mouse up action for the bidirectional tool. It can be at the end\n   * of the annotation drawing (MouseUpEventType) or when the user clicks and release\n   * the mouse button instantly which let to the annotation to draw without holding\n   * the mouse button (MouseClickEventType).\n   *\n   * @param evt - mouse up or mouse click event types\n   */\n  _endCallback = (evt: EventTypes.InteractionEventType): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, viewportIdsToRender, newAnnotation, hasMoved } =\n      this.editData;\n    const { data } = annotation;\n\n    if (newAnnotation && !hasMoved) {\n      return;\n    }\n\n    data.handles.activeHandleIndex = null;\n\n    this._deactivateModify(element);\n    this._deactivateDraw(element);\n\n    resetElementCursor(element);\n\n    const { renderingEngine } = getEnabledElement(element);\n\n    if (this.editData.handleIndex !== undefined) {\n      const { points } = data.handles;\n      const firstLineSegmentLength = vec3.distance(points[0], points[1]);\n      const secondLineSegmentLength = vec3.distance(points[2], points[3]);\n\n      if (secondLineSegmentLength > firstLineSegmentLength) {\n        // Switch points so [0,1] is the long axis and [2,3] is the short axis.\n\n        const longAxis = [[...points[2]], [...points[3]]];\n\n        const shortAxisPoint0 = [...points[0]];\n        const shortAxisPoint1 = [...points[1]];\n\n        // shortAxis[0->1] should be perpendicular (counter-clockwise) to longAxis[0->1]\n        const longAxisVector = vec2.create();\n\n        vec2.set(\n          longAxisVector,\n          longAxis[1][0] - longAxis[0][0],\n          longAxis[1][1] - longAxis[1][0]\n        );\n\n        const counterClockWisePerpendicularToLongAxis = vec2.create();\n\n        vec2.set(\n          counterClockWisePerpendicularToLongAxis,\n          -longAxisVector[1],\n          longAxisVector[0]\n        );\n\n        const currentShortAxisVector = vec2.create();\n\n        vec2.set(\n          currentShortAxisVector,\n          shortAxisPoint1[0] - shortAxisPoint0[0],\n          shortAxisPoint1[1] - shortAxisPoint0[0]\n        );\n\n        let shortAxis;\n\n        if (\n          vec2.dot(\n            currentShortAxisVector,\n            counterClockWisePerpendicularToLongAxis\n          ) > 0\n        ) {\n          shortAxis = [shortAxisPoint0, shortAxisPoint1];\n        } else {\n          shortAxis = [shortAxisPoint1, shortAxisPoint0];\n        }\n\n        data.handles.points = [\n          longAxis[0],\n          longAxis[1],\n          shortAxis[0],\n          shortAxis[1],\n        ];\n      }\n    }\n\n    if (\n      this.isHandleOutsideImage &&\n      this.configuration.preventHandleOutsideImage\n    ) {\n      removeAnnotation(annotation.annotationUID);\n    }\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    if (newAnnotation) {\n      triggerAnnotationCompleted(annotation);\n    }\n\n    this.editData = null;\n    this.isDrawing = false;\n  };\n\n  /**\n   * @param evt - mouse move event type or mouse drag\n   */\n  _dragDrawCallback = (evt: EventTypes.InteractionEventType): void => {\n    this.isDrawing = true;\n\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine, viewport } = enabledElement;\n    const { worldToCanvas } = viewport;\n    const { annotation, viewportIdsToRender, handleIndex } = this.editData;\n    const { data } = annotation;\n\n    const worldPos = currentPoints.world;\n\n    // Update first move handle\n    data.handles.points[handleIndex] = [...worldPos];\n\n    const canvasCoordPoints = data.handles.points.map(worldToCanvas);\n\n    const canvasCoords = {\n      longLineSegment: {\n        start: {\n          x: canvasCoordPoints[0][0],\n          y: canvasCoordPoints[0][1],\n        },\n        end: {\n          x: canvasCoordPoints[1][0],\n          y: canvasCoordPoints[1][1],\n        },\n      },\n      shortLineSegment: {\n        start: {\n          x: canvasCoordPoints[2][0],\n          y: canvasCoordPoints[2][1],\n        },\n        end: {\n          x: canvasCoordPoints[3][0],\n          y: canvasCoordPoints[3][1],\n        },\n      },\n    };\n\n    // ~~ calculate worldPos of our short axis handles\n    // short axis is perpendicular to long axis, and we set its length to be 2/3 of long axis\n    // (meaning each)\n    const dist = vec2.distance(canvasCoordPoints[0], canvasCoordPoints[1]);\n\n    const shortAxisDistFromCenter = dist / 3;\n    // Calculate long line's incline\n    const dx =\n      canvasCoords.longLineSegment.start.x - canvasCoords.longLineSegment.end.x;\n    const dy =\n      canvasCoords.longLineSegment.start.y - canvasCoords.longLineSegment.end.y;\n    const length = Math.sqrt(dx * dx + dy * dy);\n    const vectorX = dx / length;\n    const vectorY = dy / length;\n    // middle point between long line segment's points\n    const xMid =\n      (canvasCoords.longLineSegment.start.x +\n        canvasCoords.longLineSegment.end.x) /\n      2;\n    const yMid =\n      (canvasCoords.longLineSegment.start.y +\n        canvasCoords.longLineSegment.end.y) /\n      2;\n    // short points 1/3 distance from center of long points\n    const startX = xMid + shortAxisDistFromCenter * vectorY;\n    const startY = yMid - shortAxisDistFromCenter * vectorX;\n    const endX = xMid - shortAxisDistFromCenter * vectorY;\n    const endY = yMid + shortAxisDistFromCenter * vectorX;\n\n    // Update perpendicular line segment's points\n    data.handles.points[2] = viewport.canvasToWorld([startX, startY]);\n    data.handles.points[3] = viewport.canvasToWorld([endX, endY]);\n\n    annotation.invalidated = true;\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    this.editData.hasMoved = true;\n  };\n\n  /**\n   * Mouse drag to edit annotation callback\n   * @param evt - mouse drag event\n   */\n  _dragModifyCallback = (evt: EventTypes.InteractionEventType): void => {\n    this.isDrawing = true;\n\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n    const { annotation, viewportIdsToRender, handleIndex, movingTextBox } =\n      this.editData;\n    const { data } = annotation;\n    if (movingTextBox) {\n      const { deltaPoints } = eventDetail;\n      const worldPosDelta = deltaPoints.world;\n\n      const { textBox } = data.handles;\n      const { worldPosition } = textBox;\n\n      worldPosition[0] += worldPosDelta[0];\n      worldPosition[1] += worldPosDelta[1];\n      worldPosition[2] += worldPosDelta[2];\n\n      textBox.hasMoved = true;\n    } else if (handleIndex === undefined) {\n      // Moving tool\n      const { deltaPoints } = eventDetail;\n      const worldPosDelta = deltaPoints.world;\n      const points = data.handles.points;\n\n      points.forEach((point) => {\n        point[0] += worldPosDelta[0];\n        point[1] += worldPosDelta[1];\n        point[2] += worldPosDelta[2];\n      });\n      annotation.invalidated = true;\n    } else {\n      this._dragModifyHandle(evt);\n      annotation.invalidated = true;\n    }\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  };\n\n  /**\n   * Mouse dragging a handle callback\n   * @param evt - mouse drag event\n   */\n  _dragModifyHandle = (evt: EventTypes.InteractionEventType): void => {\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const { annotation, handleIndex: movingHandleIndex } = this.editData;\n    const { data } = annotation;\n\n    // Moving handle\n    const worldPos = currentPoints.world;\n    const canvasCoordHandlesCurrent = [\n      viewport.worldToCanvas(data.handles.points[0]),\n      viewport.worldToCanvas(data.handles.points[1]),\n      viewport.worldToCanvas(data.handles.points[2]),\n      viewport.worldToCanvas(data.handles.points[3]),\n    ];\n\n    const firstLineSegment = {\n      start: {\n        x: canvasCoordHandlesCurrent[0][0],\n        y: canvasCoordHandlesCurrent[0][1],\n      },\n      end: {\n        x: canvasCoordHandlesCurrent[1][0],\n        y: canvasCoordHandlesCurrent[1][1],\n      },\n    };\n    const secondLineSegment = {\n      start: {\n        x: canvasCoordHandlesCurrent[2][0],\n        y: canvasCoordHandlesCurrent[2][1],\n      },\n      end: {\n        x: canvasCoordHandlesCurrent[3][0],\n        y: canvasCoordHandlesCurrent[3][1],\n      },\n    };\n\n    // Handle we've selected's proposed point\n    const proposedPoint = <Types.Point3>[...worldPos];\n    const proposedCanvasCoord = viewport.worldToCanvas(proposedPoint);\n\n    if (movingHandleIndex === 0 || movingHandleIndex === 1) {\n      const fixedHandleIndex = movingHandleIndex === 0 ? 1 : 0;\n\n      const fixedHandleCanvasCoord =\n        canvasCoordHandlesCurrent[fixedHandleIndex];\n\n      const fixedHandleToProposedCoordVec = vec2.set(\n        vec2.create(),\n        proposedCanvasCoord[0] - fixedHandleCanvasCoord[0],\n        proposedCanvasCoord[1] - fixedHandleCanvasCoord[1]\n      );\n\n      const fixedHandleToOldCoordVec = vec2.set(\n        vec2.create(),\n        canvasCoordHandlesCurrent[movingHandleIndex][0] -\n          fixedHandleCanvasCoord[0],\n        canvasCoordHandlesCurrent[movingHandleIndex][1] -\n          fixedHandleCanvasCoord[1]\n      );\n\n      // normalize vector\n      vec2.normalize(\n        fixedHandleToProposedCoordVec,\n        fixedHandleToProposedCoordVec\n      );\n      vec2.normalize(fixedHandleToOldCoordVec, fixedHandleToOldCoordVec);\n\n      // Check whether this\n      const proposedFirstLineSegment = {\n        start: {\n          x: fixedHandleCanvasCoord[0],\n          y: fixedHandleCanvasCoord[1],\n        },\n        end: {\n          x: proposedCanvasCoord[0],\n          y: proposedCanvasCoord[1],\n        },\n      };\n\n      // Note: this is the case when we are modifying the long axis line segment\n      // and we make it shorter and shorter until its second half size becomes zero\n      // which basically means that any more modification would make the long axis\n      // second half disappear. In this case, we just bail out and do not update\n      // since we don't want to disrupt the bidirectional shape.\n      if (\n        this._movingLongAxisWouldPutItThroughShortAxis(\n          proposedFirstLineSegment,\n          secondLineSegment\n        )\n      ) {\n        return;\n      }\n\n      const centerOfRotation = fixedHandleCanvasCoord;\n\n      const angle = this._getSignedAngle(\n        fixedHandleToOldCoordVec,\n        fixedHandleToProposedCoordVec\n      );\n\n      // rotate handles around the center of rotation, first translate to origin,\n      // then rotate, then translate back\n      let firstPointX = canvasCoordHandlesCurrent[2][0];\n      let firstPointY = canvasCoordHandlesCurrent[2][1];\n\n      let secondPointX = canvasCoordHandlesCurrent[3][0];\n      let secondPointY = canvasCoordHandlesCurrent[3][1];\n\n      // translate to origin\n      firstPointX -= centerOfRotation[0];\n      firstPointY -= centerOfRotation[1];\n\n      secondPointX -= centerOfRotation[0];\n      secondPointY -= centerOfRotation[1];\n\n      // rotate\n      const rotatedFirstPoint =\n        firstPointX * Math.cos(angle) - firstPointY * Math.sin(angle);\n      const rotatedFirstPointY =\n        firstPointX * Math.sin(angle) + firstPointY * Math.cos(angle);\n\n      const rotatedSecondPoint =\n        secondPointX * Math.cos(angle) - secondPointY * Math.sin(angle);\n      const rotatedSecondPointY =\n        secondPointX * Math.sin(angle) + secondPointY * Math.cos(angle);\n\n      // translate back\n      firstPointX = rotatedFirstPoint + centerOfRotation[0];\n      firstPointY = rotatedFirstPointY + centerOfRotation[1];\n\n      secondPointX = rotatedSecondPoint + centerOfRotation[0];\n      secondPointY = rotatedSecondPointY + centerOfRotation[1];\n\n      // update handles\n      const newFirstPoint = viewport.canvasToWorld([firstPointX, firstPointY]);\n      const newSecondPoint = viewport.canvasToWorld([\n        secondPointX,\n        secondPointY,\n      ]);\n\n      // the fixed handle is the one that is not being moved so we\n      // don't need to update it\n      data.handles.points[movingHandleIndex] = proposedPoint;\n      data.handles.points[2] = newFirstPoint;\n      data.handles.points[3] = newSecondPoint;\n    } else {\n      // Translation manipulator\n      const translateHandleIndex = movingHandleIndex === 2 ? 3 : 2;\n\n      const canvasCoordsCurrent = {\n        longLineSegment: {\n          start: firstLineSegment.start,\n          end: firstLineSegment.end,\n        },\n        shortLineSegment: {\n          start: secondLineSegment.start,\n          end: secondLineSegment.end,\n        },\n      };\n\n      const longLineSegmentVec = vec2.subtract(\n        vec2.create(),\n        [\n          canvasCoordsCurrent.longLineSegment.end.x,\n          canvasCoordsCurrent.longLineSegment.end.y,\n        ],\n        [\n          canvasCoordsCurrent.longLineSegment.start.x,\n          canvasCoordsCurrent.longLineSegment.start.y,\n        ]\n      );\n\n      const longLineSegmentVecNormalized = vec2.normalize(\n        vec2.create(),\n        longLineSegmentVec\n      );\n\n      const proposedToCurrentVec = vec2.subtract(\n        vec2.create(),\n        [proposedCanvasCoord[0], proposedCanvasCoord[1]],\n        [\n          canvasCoordHandlesCurrent[movingHandleIndex][0],\n          canvasCoordHandlesCurrent[movingHandleIndex][1],\n        ]\n      );\n\n      const movementLength = vec2.length(proposedToCurrentVec);\n\n      const angle = this._getSignedAngle(\n        longLineSegmentVecNormalized,\n        proposedToCurrentVec\n      );\n\n      const movementAlongLineSegmentLength = Math.cos(angle) * movementLength;\n\n      const newTranslatedPoint = vec2.scaleAndAdd(\n        vec2.create(),\n        [\n          canvasCoordHandlesCurrent[translateHandleIndex][0],\n          canvasCoordHandlesCurrent[translateHandleIndex][1],\n        ],\n        longLineSegmentVecNormalized,\n        movementAlongLineSegmentLength\n      );\n\n      // don't update if it passes through the other line segment\n      if (\n        this._movingLongAxisWouldPutItThroughShortAxis(\n          {\n            start: {\n              x: proposedCanvasCoord[0],\n              y: proposedCanvasCoord[1],\n            },\n            end: {\n              x: newTranslatedPoint[0],\n              y: newTranslatedPoint[1],\n            },\n          },\n          {\n            start: {\n              x: canvasCoordsCurrent.longLineSegment.start.x,\n              y: canvasCoordsCurrent.longLineSegment.start.y,\n            },\n            end: {\n              x: canvasCoordsCurrent.longLineSegment.end.x,\n              y: canvasCoordsCurrent.longLineSegment.end.y,\n            },\n          }\n        )\n      ) {\n        return;\n      }\n\n      const intersectionPoint = lineSegment.intersectLine(\n        [proposedCanvasCoord[0], proposedCanvasCoord[1]],\n        [newTranslatedPoint[0], newTranslatedPoint[1]],\n        [firstLineSegment.start.x, firstLineSegment.start.y],\n        [firstLineSegment.end.x, firstLineSegment.end.y]\n      );\n\n      // don't update if it doesn't intersect\n      if (!intersectionPoint) {\n        return;\n      }\n\n      data.handles.points[translateHandleIndex] = viewport.canvasToWorld(\n        newTranslatedPoint as Types.Point2\n      );\n      data.handles.points[movingHandleIndex] = proposedPoint;\n    }\n  };\n\n  /**\n   * Cancels an ongoing drawing of a bidirectional annotation\n   * @param element - HTML Element\n   */\n  cancel = (element: HTMLDivElement) => {\n    // If it is mid-draw or mid-modify\n    if (this.isDrawing) {\n      this.isDrawing = false;\n      this._deactivateDraw(element);\n      this._deactivateModify(element);\n      resetElementCursor(element);\n\n      const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n      const { data } = annotation;\n\n      annotation.highlighted = false;\n      data.handles.activeHandleIndex = null;\n\n      const { renderingEngine } = getEnabledElement(element);\n\n      triggerAnnotationRenderForViewportIds(\n        renderingEngine,\n        viewportIdsToRender\n      );\n\n      if (newAnnotation) {\n        triggerAnnotationCompleted(annotation);\n      }\n\n      this.editData = null;\n      return annotation.annotationUID;\n    }\n  };\n\n  _activateDraw = (element) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(Events.MOUSE_UP, this._endCallback);\n    element.addEventListener(Events.MOUSE_DRAG, this._dragDrawCallback);\n    element.addEventListener(Events.MOUSE_MOVE, this._dragDrawCallback);\n    element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.addEventListener(\n      Events.TOUCH_TAP,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.TOUCH_END,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.TOUCH_DRAG,\n      this._dragDrawCallback as EventListener\n    );\n  };\n\n  _deactivateDraw = (element) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n    element.removeEventListener(Events.MOUSE_DRAG, this._dragDrawCallback);\n    element.removeEventListener(Events.MOUSE_MOVE, this._dragDrawCallback);\n    element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.removeEventListener(\n      Events.TOUCH_TAP,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_END,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_DRAG,\n      this._dragDrawCallback as EventListener\n    );\n  };\n\n  _activateModify = (element) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(Events.MOUSE_UP, this._endCallback);\n    element.addEventListener(Events.MOUSE_DRAG, this._dragModifyCallback);\n    element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.addEventListener(\n      Events.TOUCH_END,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.TOUCH_DRAG,\n      this._dragModifyCallback as EventListener\n    );\n    element.addEventListener(\n      Events.TOUCH_TAP,\n      this._endCallback as EventListener\n    );\n  };\n\n  _deactivateModify = (element) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n    element.removeEventListener(Events.MOUSE_DRAG, this._dragModifyCallback);\n    element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.removeEventListener(\n      Events.TOUCH_END,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_DRAG,\n      this._dragModifyCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_TAP,\n      this._endCallback as EventListener\n    );\n  };\n\n  /**\n   * it is used to draw the bidirectional annotation in each\n   * request animation frame. It calculates the updated cached statistics if\n   * data is invalidated and cache it.\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    let renderStatus = true;\n    const { viewport } = enabledElement;\n    const { element } = viewport;\n    let annotations = getAnnotations(this.getToolName(), element);\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    annotations = this.filterInteractableAnnotationsForElement(\n      element,\n      annotations\n    );\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    const targetId = this.getTargetId(viewport);\n\n    const renderingEngine = viewport.getRenderingEngine();\n\n    const styleSpecifier: StyleSpecifier = {\n      toolGroupId: this.toolGroupId,\n      toolName: this.getToolName(),\n      viewportId: enabledElement.viewport.id,\n    };\n\n    for (let i = 0; i < annotations.length; i++) {\n      const annotation = annotations[i] as BidirectionalAnnotation;\n      const { annotationUID, data } = annotation;\n      const { points, activeHandleIndex } = data.handles;\n      const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n\n      styleSpecifier.annotationUID = annotationUID;\n\n      const { color, lineWidth, lineDash, shadow } = this.getAnnotationStyle({\n        annotation,\n        styleSpecifier,\n      });\n\n      // If cachedStats does not exist, or the unit is missing (as part of import/hydration etc.),\n      // force to recalculate the stats from the points\n      if (\n        !data.cachedStats[targetId] ||\n        data.cachedStats[targetId].unit == null\n      ) {\n        data.cachedStats[targetId] = {\n          length: null,\n          width: null,\n          unit: null,\n        };\n\n        this._calculateCachedStats(annotation, renderingEngine, enabledElement);\n      } else if (annotation.invalidated) {\n        this._throttledCalculateCachedStats(\n          annotation,\n          renderingEngine,\n          enabledElement\n        );\n      }\n\n      // If rendering engine has been destroyed while rendering\n      if (!viewport.getRenderingEngine()) {\n        console.warn('Rendering Engine has been destroyed');\n        return renderStatus;\n      }\n\n      let activeHandleCanvasCoords;\n\n      if (!isAnnotationVisible(annotationUID)) {\n        continue;\n      }\n\n      if (\n        !isAnnotationLocked(annotation) &&\n        !this.editData &&\n        activeHandleIndex !== null\n      ) {\n        // Not locked or creating and hovering over handle, so render handle.\n        activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n      }\n\n      if (activeHandleCanvasCoords) {\n        const handleGroupUID = '0';\n\n        drawHandlesSvg(\n          svgDrawingHelper,\n          annotationUID,\n          handleGroupUID,\n          activeHandleCanvasCoords,\n          {\n            color,\n          }\n        );\n      }\n\n      const dataId1 = `${annotationUID}-line-1`;\n      const dataId2 = `${annotationUID}-line-2`;\n\n      const lineUID = '0';\n      drawLineSvg(\n        svgDrawingHelper,\n        annotationUID,\n        lineUID,\n        canvasCoordinates[0],\n        canvasCoordinates[1],\n        {\n          color,\n          lineDash,\n          lineWidth,\n          shadow,\n        },\n        dataId1\n      );\n\n      const secondLineUID = '1';\n      drawLineSvg(\n        svgDrawingHelper,\n        annotationUID,\n        secondLineUID,\n        canvasCoordinates[2],\n        canvasCoordinates[3],\n        {\n          color,\n          lineDash,\n          lineWidth,\n          shadow,\n        },\n        dataId2\n      );\n\n      renderStatus = true;\n\n      const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n      if (!options.visibility) {\n        data.handles.textBox = {\n          hasMoved: false,\n          worldPosition: <Types.Point3>[0, 0, 0],\n          worldBoundingBox: {\n            topLeft: <Types.Point3>[0, 0, 0],\n            topRight: <Types.Point3>[0, 0, 0],\n            bottomLeft: <Types.Point3>[0, 0, 0],\n            bottomRight: <Types.Point3>[0, 0, 0],\n          },\n        };\n        continue;\n      }\n\n      const textLines = this.configuration.getTextLines(data, targetId);\n      if (!textLines || textLines.length === 0) {\n        continue;\n      }\n\n      let canvasTextBoxCoords;\n\n      if (!data.handles.textBox.hasMoved) {\n        canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCoordinates);\n\n        data.handles.textBox.worldPosition =\n          viewport.canvasToWorld(canvasTextBoxCoords);\n      }\n\n      const textBoxPosition = viewport.worldToCanvas(\n        data.handles.textBox.worldPosition\n      );\n\n      const textBoxUID = '1';\n      const boundingBox = drawLinkedTextBoxSvg(\n        svgDrawingHelper,\n        annotationUID,\n        textBoxUID,\n        textLines,\n        textBoxPosition,\n        canvasCoordinates,\n        {},\n        options\n      );\n\n      const { x: left, y: top, width, height } = boundingBox;\n\n      data.handles.textBox.worldBoundingBox = {\n        topLeft: viewport.canvasToWorld([left, top]),\n        topRight: viewport.canvasToWorld([left + width, top]),\n        bottomLeft: viewport.canvasToWorld([left, top + height]),\n        bottomRight: viewport.canvasToWorld([left + width, top + height]),\n      };\n    }\n\n    return renderStatus;\n  };\n\n  _movingLongAxisWouldPutItThroughShortAxis = (\n    firstLineSegment,\n    secondLineSegment\n  ) => {\n    const vectorInSecondLineDirection = vec2.create();\n\n    vec2.set(\n      vectorInSecondLineDirection,\n      secondLineSegment.end.x - secondLineSegment.start.x,\n      secondLineSegment.end.y - secondLineSegment.start.y\n    );\n\n    vec2.normalize(vectorInSecondLineDirection, vectorInSecondLineDirection);\n\n    const extendedSecondLineSegment = {\n      start: {\n        x: secondLineSegment.start.x - vectorInSecondLineDirection[0] * 10,\n        y: secondLineSegment.start.y - vectorInSecondLineDirection[1] * 10,\n      },\n      end: {\n        x: secondLineSegment.end.x + vectorInSecondLineDirection[0] * 10,\n        y: secondLineSegment.end.y + vectorInSecondLineDirection[1] * 10,\n      },\n    };\n\n    // Add some buffer in the secondLineSegment when finding the proposedIntersectionPoint\n    // Of points to stop us getting stack when rotating quickly.\n\n    const proposedIntersectionPoint = lineSegment.intersectLine(\n      [extendedSecondLineSegment.start.x, extendedSecondLineSegment.start.y],\n      [extendedSecondLineSegment.end.x, extendedSecondLineSegment.end.y],\n      [firstLineSegment.start.x, firstLineSegment.start.y],\n      [firstLineSegment.end.x, firstLineSegment.end.y]\n    );\n\n    const wouldPutThroughShortAxis = !proposedIntersectionPoint;\n\n    return wouldPutThroughShortAxis;\n  };\n\n  _calculateLength(pos1, pos2) {\n    const dx = pos1[0] - pos2[0];\n    const dy = pos1[1] - pos2[1];\n    const dz = pos1[2] - pos2[2];\n\n    return Math.sqrt(dx * dx + dy * dy + dz * dz);\n  }\n\n  _calculateCachedStats = (annotation, renderingEngine, enabledElement) => {\n    const { data } = annotation;\n    const { element } = enabledElement.viewport;\n\n    const worldPos1 = data.handles.points[0];\n    const worldPos2 = data.handles.points[1];\n    const worldPos3 = data.handles.points[2];\n    const worldPos4 = data.handles.points[3];\n\n    const { cachedStats } = data;\n    const targetIds = Object.keys(cachedStats);\n\n    for (let i = 0; i < targetIds.length; i++) {\n      const targetId = targetIds[i];\n\n      const image = this.getTargetIdImage(targetId, renderingEngine);\n\n      // If image does not exists for the targetId, skip. This can be due\n      // to various reasons such as if the target was a volumeViewport, and\n      // the volumeViewport has been decached in the meantime.\n      if (!image) {\n        continue;\n      }\n\n      const { imageData, dimensions } = image;\n      const index1 = transformWorldToIndex(imageData, worldPos1);\n      const index2 = transformWorldToIndex(imageData, worldPos2);\n      const index3 = transformWorldToIndex(imageData, worldPos3);\n      const index4 = transformWorldToIndex(imageData, worldPos4);\n\n      const handles1 = [index1, index2];\n      const handles2 = [index3, index4];\n\n      const { scale: scale1, units: units1 } = getCalibratedLengthUnitsAndScale(\n        image,\n        handles1\n      );\n\n      const { scale: scale2, units: units2 } = getCalibratedLengthUnitsAndScale(\n        image,\n        handles2\n      );\n\n      const dist1 = this._calculateLength(worldPos1, worldPos2) / scale1;\n      const dist2 = this._calculateLength(worldPos3, worldPos4) / scale2;\n      const length = dist1 > dist2 ? dist1 : dist2;\n      const width = dist1 > dist2 ? dist2 : dist1;\n\n      const lengthUnit = dist1 > dist2 ? units1 : units2;\n      const widthUnit = dist1 > dist2 ? units2 : units1;\n\n      this._isInsideVolume(index1, index2, index3, index4, dimensions)\n        ? (this.isHandleOutsideImage = false)\n        : (this.isHandleOutsideImage = true);\n\n      cachedStats[targetId] = {\n        length,\n        width,\n        unit: units1,\n        lengthUnit,\n        widthUnit,\n      };\n    }\n\n    annotation.invalidated = false;\n\n    // Dispatching annotation modified\n    triggerAnnotationModified(annotation, element);\n\n    return cachedStats;\n  };\n\n  _isInsideVolume = (index1, index2, index3, index4, dimensions): boolean => {\n    return (\n      csUtils.indexWithinDimensions(index1, dimensions) &&\n      csUtils.indexWithinDimensions(index2, dimensions) &&\n      csUtils.indexWithinDimensions(index3, dimensions) &&\n      csUtils.indexWithinDimensions(index4, dimensions)\n    );\n  };\n\n  _getSignedAngle = (vector1, vector2) => {\n    return Math.atan2(\n      vector1[0] * vector2[1] - vector1[1] * vector2[0],\n      vector1[0] * vector2[0] + vector1[1] * vector2[1]\n    );\n  };\n}\n\nfunction defaultGetTextLines(data, targetId): string[] {\n  const { cachedStats, label } = data;\n  const { length, width, unit, lengthUnit, widthUnit } = cachedStats[targetId];\n\n  const textLines = [];\n  if (label) {\n    textLines.push(label);\n  }\n  if (length === undefined) {\n    return textLines;\n  }\n\n  // spaceBetweenSlices & pixelSpacing &\n  // magnitude in each direction? Otherwise, this is \"px\"?\n  textLines.push(\n    `L: ${roundNumber(length)} ${lengthUnit || unit}`,\n    `W: ${roundNumber(width)} ${widthUnit || unit}`\n  );\n\n  return textLines;\n}\n\nBidirectionalTool.toolName = 'Bidirectional';\nexport default BidirectionalTool;\n","import {\n  BaseVolumeViewport,\n  cache,\n  getEnabledElement,\n  metaData,\n  utilities as csUtils,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { vec2 } from 'gl-matrix';\n\nimport AnnotationDisplayTool from './AnnotationDisplayTool';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport {\n  Annotation,\n  Annotations,\n  EventTypes,\n  ToolHandle,\n  InteractionTypes,\n  ToolProps,\n  PublicToolProps,\n} from '../../types';\nimport { addAnnotation } from '../../stateManagement/annotation/annotationState';\nimport { StyleSpecifier } from '../../types/AnnotationStyle';\nimport { triggerAnnotationModified } from '../../stateManagement/annotation/helpers/state';\n\n/**\n * Abstract class for tools which create and display annotations on the\n * cornerstone3D canvas. In addition, it provides a base class for segmentation\n * tools that require drawing an annotation before running the segmentation strategy\n * for instance threshold segmentation based on an area and a threshold.\n * Annotation tools make use of drawing utilities to draw SVG elements on the viewport.\n *\n * To create a new annotation tool, derive from this class and implement the\n * abstract methods.\n */\nabstract class AnnotationTool extends AnnotationDisplayTool {\n  /**\n   * Creates a base annotation object, adding in any annotation base data provided\n   */\n  public static createAnnotation(...annotationBaseData): Annotation {\n    let annotation: Annotation = {\n      annotationUID: null as string,\n      highlighted: true,\n      invalidated: true,\n      metadata: {\n        toolName: this.toolName,\n      },\n      data: {\n        text: '',\n        handles: {\n          points: new Array<Types.Point3>(),\n          textBox: {\n            hasMoved: false,\n            worldPosition: <Types.Point3>[0, 0, 0],\n            worldBoundingBox: {\n              topLeft: <Types.Point3>[0, 0, 0],\n              topRight: <Types.Point3>[0, 0, 0],\n              bottomLeft: <Types.Point3>[0, 0, 0],\n              bottomRight: <Types.Point3>[0, 0, 0],\n            },\n          },\n        },\n        label: '',\n      },\n    } as unknown as Annotation;\n    for (const baseData of annotationBaseData) {\n      annotation = csUtils.deepMerge(annotation, baseData);\n    }\n    return annotation;\n  }\n\n  /**\n   * Creates a new annotation for the given viewport.  This just adds the\n   * viewport reference data to the metadata, and otherwise returns the\n   * static class createAnnotation data.\n   */\n  public static createAnnotationForViewport(viewport, ...annotationBaseData) {\n    return this.createAnnotation(\n      { metadata: viewport.getViewReference() },\n      ...annotationBaseData\n    );\n  }\n\n  /**\n   * Creates and adds an annotation of the given type, firing the annotation\n   * modified event on the new annotation.\n   * This implicitly uses the static class when you call it on the correct\n   * base class.  For example, you can call the KeyImageTool.createAnnotation\n   * method on KeyImageTool.toolName by calling KeyImageTool.createAndAddAnnotation\n   *\n   */\n  public static createAndAddAnnotation(viewport, ...annotationBaseData) {\n    const annotation = this.createAnnotationForViewport(\n      viewport,\n      ...annotationBaseData\n    );\n    addAnnotation(annotation, viewport.element);\n    triggerAnnotationModified(annotation, viewport.element);\n  }\n\n  static toolName;\n  // ===================================================================\n  // Abstract Methods - Must be implemented.\n  // ===================================================================\n\n  constructor(toolProps: PublicToolProps, defaultToolProps: ToolProps) {\n    super(toolProps, defaultToolProps);\n\n    if (toolProps.configuration?.getTextLines) {\n      this.configuration.getTextLines = toolProps.configuration.getTextLines;\n    }\n\n    if (toolProps.configuration?.statsCalculator) {\n      this.configuration.statsCalculator =\n        toolProps.configuration.statsCalculator;\n    }\n  }\n\n  /**\n   * @abstract addNewAnnotation Creates a new annotation based on the clicked mouse position\n   *\n   * @param evt - The normalized mouse event\n   * @param interactionType -  The interaction type used to add the annotation.\n   */\n  abstract addNewAnnotation(\n    evt: EventTypes.InteractionEventType,\n    interactionType: InteractionTypes\n  ): Annotation;\n\n  /**\n   * @abstract cancel Used to cancel the ongoing tool drawing and manipulation\n   *\n   */\n  abstract cancel(element: HTMLDivElement);\n\n  /**\n   * handleSelectedCallback Custom callback for when a handle is selected.\n   *\n   * @param evt - The normalized mouse event\n   * @param annotation - The annotation selected.\n   * @param handle - The selected handle (either Types.Point3 in space for annotations, or TextBoxHandle object for text boxes).\n   * @param interactionType - The interaction type the handle was selected with.\n   */\n  abstract handleSelectedCallback(\n    evt: EventTypes.InteractionEventType,\n    annotation: Annotation,\n    handle: ToolHandle,\n    interactionType: InteractionTypes\n  ): void;\n\n  /**\n   * Custom callback for when an annotation is selected\n   *\n   * @param evt - The normalized mouse event\n   * @param annotation - The `Annotation` to check.\n   * @param interactionType - The interaction type used to select the tool.\n   */\n  abstract toolSelectedCallback(\n    evt: EventTypes.InteractionEventType,\n    annotation: Annotation,\n    interactionType: InteractionTypes,\n    canvasCoords?: Types.Point2\n  ): void;\n\n  /**\n   * Returns true if the provided canvas coordinate tool is near the annotation\n   *\n   * @param element - The HTML element\n   * @param annotation - The annotation to check\n   * @param canvasCoords - The canvas coordinate to check\n   * @param proximity - The minimum proximity to consider the point near\n   * @param interactionType - The interaction type used to select the tool.\n   *\n   * @returns boolean if the point is near.\n   */\n  abstract isPointNearTool(\n    element: HTMLDivElement,\n    annotation: Annotation,\n    canvasCoords: Types.Point2,\n    proximity: number,\n    interactionType: string\n  ): boolean;\n\n  /**\n   * @virtual Event handler for Cornerstone MOUSE_MOVE event.\n   *\n   *\n   * @param evt - The normalized mouse event\n   * @param filteredAnnotations - The annotations to check for hover interactions\n   * @returns True if the annotation needs to be re-drawn by the annotationRenderingEngine.\n   */\n  public mouseMoveCallback = (\n    evt: EventTypes.MouseMoveEventType,\n    filteredAnnotations?: Annotations\n  ): boolean => {\n    if (!filteredAnnotations) {\n      return false;\n    }\n\n    const { element, currentPoints } = evt.detail;\n    const canvasCoords = currentPoints.canvas;\n    let annotationsNeedToBeRedrawn = false;\n\n    for (const annotation of filteredAnnotations) {\n      // Do not do anything if the annotation is locked or hidden.\n      if (\n        isAnnotationLocked(annotation) ||\n        !isAnnotationVisible(annotation.annotationUID)\n      ) {\n        continue;\n      }\n\n      const { data } = annotation;\n      const activateHandleIndex = data.handles\n        ? data.handles.activeHandleIndex\n        : undefined;\n\n      // Perform tool specific imagePointNearToolOrHandle to determine if the mouse\n      // is near the tool or its handles or its textBox.\n      const near = this._imagePointNearToolOrHandle(\n        element,\n        annotation,\n        canvasCoords,\n        6 // Todo: This should come from the state\n      );\n\n      const nearToolAndNotMarkedActive = near && !annotation.highlighted;\n      const notNearToolAndMarkedActive = !near && annotation.highlighted;\n      if (nearToolAndNotMarkedActive || notNearToolAndMarkedActive) {\n        annotation.highlighted = !annotation.highlighted;\n        annotationsNeedToBeRedrawn = true;\n      } else if (\n        data.handles &&\n        data.handles.activeHandleIndex !== activateHandleIndex\n      ) {\n        // Active handle index has changed, re-render.\n        annotationsNeedToBeRedrawn = true;\n      }\n    }\n\n    return annotationsNeedToBeRedrawn;\n  };\n\n  /**\n   * It checks if the mouse click is near TextBoxHandle or AnnotationHandle itself, and\n   * return either it. It prioritize TextBoxHandle over AnnotationHandle. If\n   * the mouse click is not near any of the handles, it does not return anything.\n   *\n   * @param element - The element that the tool is attached to.\n   * @param annotation - The annotation object associated with the annotation\n   * @param canvasCoords - The coordinates of the mouse click on canvas\n   * @param proximity - The distance from the mouse cursor to the point\n   * that is considered \"near\".\n   * @returns The handle that is closest to the cursor, or null if the cursor\n   * is not near any of the handles.\n   */\n  getHandleNearImagePoint(\n    element: HTMLDivElement,\n    annotation: Annotation,\n    canvasCoords: Types.Point2,\n    proximity: number\n  ): ToolHandle | undefined {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n\n    const { data } = annotation;\n    const { isCanvasAnnotation } = data;\n    const { points, textBox } = data.handles;\n\n    if (textBox) {\n      const { worldBoundingBox } = textBox;\n      if (worldBoundingBox) {\n        const canvasBoundingBox = {\n          topLeft: viewport.worldToCanvas(worldBoundingBox.topLeft),\n          topRight: viewport.worldToCanvas(worldBoundingBox.topRight),\n          bottomLeft: viewport.worldToCanvas(worldBoundingBox.bottomLeft),\n          bottomRight: viewport.worldToCanvas(worldBoundingBox.bottomRight),\n        };\n\n        if (\n          canvasCoords[0] >= canvasBoundingBox.topLeft[0] &&\n          canvasCoords[0] <= canvasBoundingBox.bottomRight[0] &&\n          canvasCoords[1] >= canvasBoundingBox.topLeft[1] &&\n          canvasCoords[1] <= canvasBoundingBox.bottomRight[1]\n        ) {\n          data.handles.activeHandleIndex = null;\n          return textBox as ToolHandle;\n        }\n      }\n    }\n\n    for (let i = 0; i < points?.length; i++) {\n      const point = points[i];\n      const annotationCanvasCoordinate = isCanvasAnnotation\n        ? point.slice(0, 2)\n        : viewport.worldToCanvas(point);\n\n      const near =\n        vec2.distance(\n          canvasCoords,\n          annotationCanvasCoordinate as Types.Point2\n        ) < proximity;\n\n      if (near === true) {\n        data.handles.activeHandleIndex = i;\n        return point;\n      }\n    }\n\n    data.handles.activeHandleIndex = null;\n  }\n\n  /**\n   * It returns the style for the text box\n   * @param styleSpecifier - An object containing the specifications such as viewportId,\n   * toolGroupId, toolName and annotationUID which are used to get the style if the level of specificity is\n   * met (hierarchy is checked from most specific to least specific which is\n   * annotationLevel -> viewportLevel -> toolGroupLevel -> default.\n   * @param annotation - The annotation for the tool that is\n   * currently active.\n   * @returns An object of the style settings for the text box.\n   */\n  public getLinkedTextBoxStyle(\n    specifications: StyleSpecifier,\n    annotation?: Annotation\n  ): Record<string, unknown> {\n    // Todo: this function can be used to set different styles for different toolMode\n    // for the textBox.\n\n    return {\n      visibility: this.getStyle(\n        'textBoxVisibility',\n        specifications,\n        annotation\n      ),\n      fontFamily: this.getStyle(\n        'textBoxFontFamily',\n        specifications,\n        annotation\n      ),\n      fontSize: this.getStyle('textBoxFontSize', specifications, annotation),\n      color: this.getStyle('textBoxColor', specifications, annotation),\n      shadow: this.getStyle('textBoxShadow', specifications, annotation),\n      background: this.getStyle(\n        'textBoxBackground',\n        specifications,\n        annotation\n      ),\n      lineWidth: this.getStyle(\n        'textBoxLinkLineWidth',\n        specifications,\n        annotation\n      ),\n      lineDash: this.getStyle(\n        'textBoxLinkLineDash',\n        specifications,\n        annotation\n      ),\n    };\n  }\n\n  /**\n   * Returns true if the viewport is scaled to SUV units\n   * @param viewport - The viewport\n   * @param targetId - The annotation targetId\n   * @param imageId - The annotation imageId\n   * @returns\n   */\n  isSuvScaled(\n    viewport: Types.IStackViewport | Types.IVolumeViewport,\n    targetId: string,\n    imageId?: string\n  ): boolean {\n    if (viewport instanceof BaseVolumeViewport) {\n      const volumeId = csUtils.getVolumeId(targetId);\n      const volume = cache.getVolume(volumeId);\n      return volume.scaling?.PT !== undefined;\n    }\n    const scalingModule: Types.ScalingParameters | undefined =\n      imageId && metaData.get('scalingModule', imageId);\n    return typeof scalingModule?.suvbw === 'number';\n  }\n\n  /**\n   * Get the style that will be applied to all annotations such as length, cobb\n   * angle, arrow annotate, etc. when rendered on a canvas or svg layer\n   */\n  protected getAnnotationStyle(context: {\n    annotation: Annotation;\n    styleSpecifier: StyleSpecifier;\n  }) {\n    const { annotation, styleSpecifier } = context;\n    const getStyle = (property) =>\n      this.getStyle(property, styleSpecifier, annotation);\n    const { annotationUID } = annotation;\n    const visibility = isAnnotationVisible(annotationUID);\n    const locked = isAnnotationLocked(annotation);\n\n    const lineWidth = getStyle('lineWidth') as number;\n    const lineDash = getStyle('lineDash') as string;\n    const color = getStyle('color') as string;\n    const shadow = getStyle('shadow') as boolean;\n    const textboxStyle = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n\n    return {\n      visibility,\n      locked,\n      color,\n      lineWidth,\n      lineDash,\n      lineOpacity: 1,\n      fillColor: color,\n      fillOpacity: 0,\n      shadow,\n      textbox: textboxStyle,\n    };\n  }\n\n  /**\n   * Returns true if the `canvasCoords` are near a handle or selectable part of the tool\n   *\n   * @param element - The HTML element\n   * @param annotation - The annotation to check\n   * @param canvasCoords - The canvas coordinates to check\n   * @param proximity - The proximity to consider\n   *\n   * @returns If the point is near.\n   */\n  private _imagePointNearToolOrHandle(\n    element: HTMLDivElement,\n    annotation: Annotation,\n    canvasCoords: Types.Point2,\n    proximity: number\n  ): boolean {\n    // Based on the tool instance type, check if the point is near the tool handles\n    const handleNearImagePoint = this.getHandleNearImagePoint(\n      element,\n      annotation,\n      canvasCoords,\n      proximity\n    );\n\n    if (handleNearImagePoint) {\n      return true;\n    }\n\n    // If the point is not near the handles, check if the point is near the tool\n    const toolNewImagePoint = this.isPointNearTool(\n      element,\n      annotation,\n      canvasCoords,\n      proximity,\n      'mouse'\n    );\n\n    if (toolNewImagePoint) {\n      return true;\n    }\n  }\n}\n\nAnnotationTool.toolName = 'AnnotationTool';\nexport default AnnotationTool;\n","import { LabelmapConfig } from '../../../types/LabelmapTypes';\n\nconst defaultLabelmapConfig: LabelmapConfig = {\n  renderOutline: true,\n  outlineWidthActive: 3,\n  outlineWidthInactive: 2,\n  activeSegmentOutlineWidthDelta: 0,\n  renderFill: true,\n  renderFillInactive: true,\n  fillAlpha: 0.7,\n  fillAlphaInactive: 0.65,\n  outlineOpacity: 1,\n  outlineOpacityInactive: 0.85,\n};\n\nfunction getDefaultLabelmapConfig(): LabelmapConfig {\n  return defaultLabelmapConfig;\n}\n\n// Checks if the labelmap config is valid, which means\n// if all the required fields are present and have the correct type\nfunction isValidLabelmapConfig(config): boolean {\n  return (\n    config &&\n    typeof config.renderOutline === 'boolean' &&\n    typeof config.outlineWidthActive === 'number' &&\n    typeof config.outlineWidthInactive === 'number' &&\n    typeof config.activeSegmentOutlineWidthDelta === 'number' &&\n    typeof config.renderFill === 'boolean' &&\n    typeof config.renderFillInactive === 'boolean' &&\n    typeof config.fillAlpha === 'number' &&\n    typeof config.fillAlphaInactive === 'number' &&\n    typeof config.outlineOpacity === 'number' &&\n    typeof config.outlineOpacityInactive === 'number'\n  );\n}\n\nexport default getDefaultLabelmapConfig;\nexport { isValidLabelmapConfig };\n","import {\n  getEnabledElement,\n  cache,\n  StackViewport,\n  utilities as csUtils,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { addAnnotation, getAnnotations } from '../../stateManagement';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\n\nimport {\n  drawHandles as drawHandlesSvg,\n  drawRect as drawRectSvg,\n} from '../../drawingSvg';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport { hideElementCursor } from '../../cursors/elementCursor';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport { triggerAnnotationModified } from '../../stateManagement/annotation/helpers/state';\nimport {\n  PublicToolProps,\n  ToolProps,\n  EventTypes,\n  SVGDrawingHelper,\n} from '../../types';\nimport { RectangleROIThresholdAnnotation } from '../../types/ToolSpecificAnnotationTypes';\nimport RectangleROITool from '../annotation/RectangleROITool';\nimport { StyleSpecifier } from '../../types/AnnotationStyle';\n\n/**\n * This tool is exactly the RectangleROITool but only draws a rectangle on the image,\n * and by using utility functions such as thresholdByRange and thresholdByROIStat it can be used to\n * create a segmentation. This tool, however, does not calculate the statistics\n * as RectangleROITool does.\n */\nclass RectangleROIThresholdTool extends RectangleROITool {\n  static toolName;\n  _throttledCalculateCachedStats: any;\n  editData: {\n    annotation: any;\n    viewportIdsToRender: string[];\n    handleIndex?: number;\n    newAnnotation?: boolean;\n    hasMoved?: boolean;\n  } | null;\n  isDrawing: boolean;\n  isHandleOutsideImage: boolean;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        shadow: true,\n        preventHandleOutsideImage: false,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n  }\n\n  /**\n   * Based on the current position of the mouse and the enabledElement it creates\n   * the edit data for the tool.\n   *\n   * @param evt -  EventTypes.NormalizedMouseEventType\n   * @returns The annotation object.\n   *\n   */\n  addNewAnnotation = (evt: EventTypes.InteractionEventType) => {\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const worldPos = currentPoints.world;\n\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n\n    this.isDrawing = true;\n\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, viewUp } = camera;\n\n    const targetId = this.getTargetId(viewport);\n    let referencedImageId, volumeId;\n\n    if (viewport instanceof StackViewport) {\n      referencedImageId = targetId.split('imageId:')[1];\n    } else {\n      volumeId = csUtils.getVolumeId(targetId);\n      const imageVolume = cache.getVolume(volumeId);\n      referencedImageId = csUtils.getClosestImageId(\n        imageVolume,\n        worldPos,\n        viewPlaneNormal\n      );\n    }\n\n    const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n    // Todo: how not to store enabledElement on the annotation, segmentationModule needs the element to\n    // decide on the active segmentIndex, active segmentationIndex etc.\n    const annotation = {\n      highlighted: true,\n      invalidated: true,\n      metadata: {\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\n        enabledElement,\n        viewUp: <Types.Point3>[...viewUp],\n        FrameOfReferenceUID,\n        referencedImageId,\n        toolName: this.getToolName(),\n        volumeId,\n      },\n      data: {\n        label: '',\n        handles: {\n          // No need a textBox\n          textBox: {\n            hasMoved: false,\n            worldPosition: null,\n            worldBoundingBox: null,\n          },\n          points: [\n            <Types.Point3>[...worldPos],\n            <Types.Point3>[...worldPos],\n            <Types.Point3>[...worldPos],\n            <Types.Point3>[...worldPos],\n          ],\n          activeHandleIndex: null,\n        },\n        segmentationId: null,\n      },\n    };\n\n    addAnnotation(annotation, element);\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      handleIndex: 3,\n      newAnnotation: true,\n      hasMoved: false,\n    };\n    this._activateDraw(element);\n\n    hideElementCursor(element);\n\n    evt.preventDefault();\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    return annotation;\n  };\n\n  /**\n   * it is used to draw the RectangleROI Threshold annotation in each\n   * request animation frame.\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    let renderStatus = false;\n    const { viewport } = enabledElement;\n    const { element } = viewport;\n    let annotations = getAnnotations(this.getToolName(), element);\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    annotations = this.filterInteractableAnnotationsForElement(\n      element,\n      annotations\n    );\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    const styleSpecifier: StyleSpecifier = {\n      toolGroupId: this.toolGroupId,\n      toolName: this.getToolName(),\n      viewportId: enabledElement.viewport.id,\n    };\n\n    for (let i = 0; i < annotations.length; i++) {\n      const annotation = annotations[i] as RectangleROIThresholdAnnotation;\n      const { annotationUID, data } = annotation;\n      const { points, activeHandleIndex } = data.handles;\n      const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n\n      styleSpecifier.annotationUID = annotationUID;\n\n      const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);\n      const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\n      const color = this.getStyle('color', styleSpecifier, annotation);\n\n      // If rendering engine has been destroyed while rendering\n      if (!viewport.getRenderingEngine()) {\n        console.warn('Rendering Engine has been destroyed');\n        return renderStatus;\n      }\n\n      // Todo: This is not correct way to add the event trigger,\n      // this will trigger on all mouse hover too. Problem is that we don't\n      // have a cached stats mechanism for this tool yet?\n      triggerAnnotationModified(annotation, element);\n\n      let activeHandleCanvasCoords;\n\n      if (!isAnnotationVisible(annotationUID)) {\n        continue;\n      }\n\n      if (\n        !isAnnotationLocked(annotation) &&\n        !this.editData &&\n        activeHandleIndex !== null\n      ) {\n        // Not locked or creating and hovering over handle, so render handle.\n        activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n      }\n\n      if (activeHandleCanvasCoords) {\n        const handleGroupUID = '0';\n\n        drawHandlesSvg(\n          svgDrawingHelper,\n          annotationUID,\n          handleGroupUID,\n          activeHandleCanvasCoords,\n          {\n            color,\n          }\n        );\n      }\n\n      const rectangleUID = '0';\n      drawRectSvg(\n        svgDrawingHelper,\n        annotationUID,\n        rectangleUID,\n        canvasCoordinates[0],\n        canvasCoordinates[3],\n        {\n          color,\n          lineDash,\n          lineWidth,\n        }\n      );\n\n      renderStatus = true;\n    }\n\n    return renderStatus;\n  };\n}\n\nRectangleROIThresholdTool.toolName = 'RectangleROIThreshold';\nexport default RectangleROIThresholdTool;\n","import {\n  getEnabledElement,\n  cache,\n  StackViewport,\n  metaData,\n  utilities as csUtils,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { vec3 } from 'gl-matrix';\nimport {\n  addAnnotation,\n  getAnnotations,\n  removeAnnotation,\n} from '../../stateManagement';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport { triggerAnnotationModified } from '../../stateManagement/annotation/helpers/state';\nimport {\n  drawHandles as drawHandlesSvg,\n  drawRect as drawRectSvg,\n} from '../../drawingSvg';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport throttle from '../../utilities/throttle';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport {\n  hideElementCursor,\n  resetElementCursor,\n} from '../../cursors/elementCursor';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { triggerAnnotationCompleted } from '../../stateManagement/annotation/helpers/state';\n\nimport {\n  PublicToolProps,\n  ToolProps,\n  EventTypes,\n  SVGDrawingHelper,\n} from '../../types';\nimport { RectangleROIStartEndThresholdAnnotation } from '../../types/ToolSpecificAnnotationTypes';\nimport RectangleROITool from '../annotation/RectangleROITool';\nimport { StyleSpecifier } from '../../types/AnnotationStyle';\nimport { pointInShapeCallback } from '../../utilities/';\n\nconst { transformWorldToIndex } = csUtils;\n\n/**\n * This tool is similar to the RectangleROIThresholdTool which\n * only draws a rectangle on the image, and by using utility functions\n * such as thresholdByRange and thresholdByROIStat it can be used to\n * create a segmentation. The only difference is that it only acts on the\n * acquisition plane and not the 3D volume, and accepts a start and end\n * slice, and renders a dashed rectangle on the image between the start and end\n * but a solid rectangle on start and end slice. Utility functions should be used\n * to modify the start and end slice.\n * // Todo: right now only the first slice has grabbable handles, need to make\n * // it so that the handles are grabbable on all slices.\n */\nclass RectangleROIStartEndThresholdTool extends RectangleROITool {\n  static toolName;\n  _throttledCalculateCachedStats: any;\n  editData: {\n    annotation: any;\n    viewportIdsToRender: string[];\n    handleIndex?: number;\n    newAnnotation?: boolean;\n    hasMoved?: boolean;\n  } | null;\n  isDrawing: boolean;\n  isHandleOutsideImage: boolean;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      configuration: {\n        numSlicesToPropagate: 10,\n        computePointsInsideVolume: false,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n\n    this._throttledCalculateCachedStats = throttle(\n      this._calculateCachedStatsTool,\n      100,\n      { trailing: true }\n    );\n  }\n\n  /**\n   * Based on the current position of the mouse and the enabledElement it creates\n   * the edit data for the tool.\n   *\n   * @param evt -  EventTypes.NormalizedMouseEventType\n   * @returns The annotation object.\n   *\n   */\n  addNewAnnotation = (evt: EventTypes.InteractionEventType) => {\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const worldPos = currentPoints.world;\n\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n\n    this.isDrawing = true;\n\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, viewUp } = camera;\n\n    let referencedImageId, imageVolume, volumeId;\n    if (viewport instanceof StackViewport) {\n      throw new Error('Stack Viewport Not implemented');\n    } else {\n      const targetId = this.getTargetId(viewport);\n      volumeId = csUtils.getVolumeId(targetId);\n      imageVolume = cache.getVolume(volumeId);\n      referencedImageId = csUtils.getClosestImageId(\n        imageVolume,\n        worldPos,\n        viewPlaneNormal\n      );\n    }\n\n    if (!referencedImageId) {\n      throw new Error('This tool does not work on non-acquisition planes');\n    }\n\n    const startIndex = viewport.getCurrentImageIdIndex();\n    const spacingInNormal = csUtils.getSpacingInNormalDirection(\n      imageVolume,\n      viewPlaneNormal\n    );\n\n    // We cannot simply add numSlicesToPropagate to startIndex because\n    // the order of imageIds can be from top to bottom or bottom to top and\n    // we want to make sure it is always propagated in the direction of the\n    // view and also to make sure we don't go out of bounds.\n    const endIndex = this._getEndSliceIndex(\n      imageVolume,\n      worldPos,\n      spacingInNormal,\n      viewPlaneNormal\n    );\n\n    const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n\n    const annotation = {\n      highlighted: true,\n      invalidated: true,\n      metadata: {\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\n        enabledElement,\n        viewUp: <Types.Point3>[...viewUp],\n        FrameOfReferenceUID,\n        referencedImageId,\n        toolName: this.getToolName(),\n        volumeId,\n        spacingInNormal,\n      },\n      data: {\n        label: '',\n        startSlice: startIndex,\n        endSlice: endIndex,\n        cachedStats: {\n          pointsInVolume: [],\n          projectionPoints: [],\n          projectionPointsImageIds: [referencedImageId],\n        },\n        handles: {\n          // No need a textBox\n          textBox: {\n            hasMoved: false,\n            worldPosition: null,\n            worldBoundingBox: null,\n          },\n          points: [\n            <Types.Point3>[...worldPos],\n            <Types.Point3>[...worldPos],\n            <Types.Point3>[...worldPos],\n            <Types.Point3>[...worldPos],\n          ],\n          activeHandleIndex: null,\n        },\n        labelmapUID: null,\n      },\n    };\n\n    // update the projection points in 3D space, since we are projecting\n    // the points to the slice plane, we need to make sure the points are\n    // computed for later export\n    this._computeProjectionPoints(annotation, imageVolume);\n\n    addAnnotation(annotation, element);\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      handleIndex: 3,\n      newAnnotation: true,\n      hasMoved: false,\n    };\n    this._activateDraw(element);\n\n    hideElementCursor(element);\n\n    evt.preventDefault();\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    return annotation;\n  };\n\n  _endCallback = (evt: EventTypes.InteractionEventType): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, viewportIdsToRender, newAnnotation, hasMoved } =\n      this.editData;\n    const { data } = annotation;\n\n    if (newAnnotation && !hasMoved) {\n      return;\n    }\n\n    data.handles.activeHandleIndex = null;\n\n    this._deactivateModify(element);\n    this._deactivateDraw(element);\n\n    resetElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n\n    this.editData = null;\n    this.isDrawing = false;\n\n    if (\n      this.isHandleOutsideImage &&\n      this.configuration.preventHandleOutsideImage\n    ) {\n      removeAnnotation(annotation.annotationUID);\n    }\n\n    const targetId = this.getTargetId(enabledElement.viewport);\n    const imageVolume = cache.getVolume(targetId.split(/volumeId:|\\?/)[1]);\n\n    if (this.configuration.calculatePointsInsideVolume) {\n      this._computePointsInsideVolume(annotation, imageVolume, enabledElement);\n    }\n\n    triggerAnnotationRenderForViewportIds(\n      enabledElement.renderingEngine,\n      viewportIdsToRender\n    );\n\n    if (newAnnotation) {\n      triggerAnnotationCompleted(annotation);\n    }\n  };\n\n  // Todo: make it work for planes other than acquisition planes\n  _computeProjectionPoints(\n    annotation: RectangleROIStartEndThresholdAnnotation,\n    imageVolume: Types.IImageVolume\n  ): void {\n    const { data, metadata } = annotation;\n    const { viewPlaneNormal, spacingInNormal } = metadata;\n    const { imageData } = imageVolume;\n    const { startSlice, endSlice } = data;\n    const { points } = data.handles;\n\n    const startIJK = transformWorldToIndex(imageData, points[0]);\n\n    if (startIJK[2] !== startSlice) {\n      throw new Error('Start slice does not match');\n    }\n\n    // substitute the end slice index 2 with startIJK index 2\n    const endIJK = vec3.fromValues(startIJK[0], startIJK[1], endSlice);\n\n    const startWorld = vec3.create();\n    imageData.indexToWorldVec3(startIJK, startWorld);\n\n    const endWorld = vec3.create();\n    imageData.indexToWorldVec3(endIJK, endWorld);\n\n    // distance between start and end slice in the world coordinate\n    const distance = vec3.distance(startWorld, endWorld);\n\n    // for each point inside points, navigate in the direction of the viewPlaneNormal\n    // with amount of spacingInNormal, and calculate the next slice until we reach the distance\n    const newProjectionPoints = [];\n    for (let dist = 0; dist < distance; dist += spacingInNormal) {\n      newProjectionPoints.push(\n        points.map((point) => {\n          const newPoint = vec3.create();\n          vec3.scaleAndAdd(newPoint, point, viewPlaneNormal, dist);\n          return Array.from(newPoint);\n        })\n      );\n    }\n\n    data.cachedStats.projectionPoints = newProjectionPoints;\n\n    // Find the imageIds for the projection points\n    const projectionPointsImageIds = [];\n    for (const RectanglePoints of newProjectionPoints) {\n      const imageId = csUtils.getClosestImageId(\n        imageVolume,\n        RectanglePoints[0],\n        viewPlaneNormal\n      );\n      projectionPointsImageIds.push(imageId);\n    }\n\n    data.cachedStats.projectionPointsImageIds = projectionPointsImageIds;\n  }\n\n  //This function return all the points inside the ROI for every slices between startSlice and endSlice\n  _computePointsInsideVolume(annotation, imageVolume, enabledElement) {\n    const { data } = annotation;\n    const projectionPoints = data.cachedStats.projectionPoints;\n\n    const pointsInsideVolume: Types.Point3[][] = [[]];\n\n    for (let i = 0; i < projectionPoints.length; i++) {\n      // If image does not exists for the targetId, skip. This can be due\n      // to various reasons such as if the target was a volumeViewport, and\n      // the volumeViewport has been decached in the meantime.\n      if (!imageVolume) {\n        continue;\n      }\n\n      const projectionPoint = projectionPoints[i][0];\n\n      const worldPos1 = data.handles.points[0];\n      const worldPos2 = data.handles.points[3];\n\n      const { dimensions, imageData } = imageVolume;\n\n      const worldPos1Index = transformWorldToIndex(imageData, worldPos1);\n      //We only need to change the Z of our bounds so we are getting the Z from the current projection point\n      const worldProjectionPointIndex = transformWorldToIndex(\n        imageData,\n        projectionPoint\n      );\n\n      worldPos1Index[0] = Math.floor(worldPos1Index[0]);\n      worldPos1Index[1] = Math.floor(worldPos1Index[1]);\n      worldPos1Index[2] = Math.floor(worldProjectionPointIndex[2]);\n\n      const worldPos2Index = transformWorldToIndex(imageData, worldPos2);\n\n      worldPos2Index[0] = Math.floor(worldPos2Index[0]);\n      worldPos2Index[1] = Math.floor(worldPos2Index[1]);\n      worldPos2Index[2] = Math.floor(worldProjectionPointIndex[2]);\n\n      // Check if one of the indexes are inside the volume, this then gives us\n      // Some area to do stats over.\n\n      if (this._isInsideVolume(worldPos1Index, worldPos2Index, dimensions)) {\n        this.isHandleOutsideImage = false;\n        const iMin = Math.min(worldPos1Index[0], worldPos2Index[0]);\n        const iMax = Math.max(worldPos1Index[0], worldPos2Index[0]);\n\n        const jMin = Math.min(worldPos1Index[1], worldPos2Index[1]);\n        const jMax = Math.max(worldPos1Index[1], worldPos2Index[1]);\n\n        const kMin = Math.min(worldPos1Index[2], worldPos2Index[2]);\n        const kMax = Math.max(worldPos1Index[2], worldPos2Index[2]);\n\n        const boundsIJK = [\n          [iMin, iMax],\n          [jMin, jMax],\n          [kMin, kMax],\n        ] as [Types.Point2, Types.Point2, Types.Point2];\n\n        const pointsInShape = pointInShapeCallback(\n          imageData,\n          () => true,\n          null,\n          boundsIJK\n        );\n\n        //@ts-ignore\n        pointsInsideVolume.push(pointsInShape);\n      }\n    }\n    data.cachedStats.pointsInVolume = pointsInsideVolume;\n  }\n\n  _calculateCachedStatsTool(annotation, enabledElement) {\n    const data = annotation.data;\n    const { viewport } = enabledElement;\n\n    const { cachedStats } = data;\n    const targetId = this.getTargetId(viewport);\n    const imageVolume = cache.getVolume(targetId.split(/volumeId:|\\?/)[1]);\n\n    // Todo: this shouldn't be here, this is a performance issue\n    // Since we are extending the RectangleROI class, we need to\n    // bring the logic for handle to some cachedStats calculation\n    this._computeProjectionPoints(annotation, imageVolume);\n\n    annotation.invalidated = false;\n\n    // Dispatching annotation modified\n    triggerAnnotationModified(annotation, viewport.element);\n\n    return cachedStats;\n  }\n\n  /**\n   * it is used to draw the rectangleROIStartEnd annotation in each\n   * request animation frame.\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    let renderStatus = false;\n    const { viewport } = enabledElement;\n\n    const annotations = getAnnotations(this.getToolName(), viewport.element);\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    const sliceIndex = viewport.getCurrentImageIdIndex();\n\n    const styleSpecifier: StyleSpecifier = {\n      toolGroupId: this.toolGroupId,\n      toolName: this.getToolName(),\n      viewportId: enabledElement.viewport.id,\n    };\n\n    for (let i = 0; i < annotations.length; i++) {\n      const annotation = annotations[\n        i\n      ] as RectangleROIStartEndThresholdAnnotation;\n      const { annotationUID, data } = annotation;\n      const { startSlice, endSlice } = data;\n      const { points, activeHandleIndex } = data.handles;\n\n      const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n\n      styleSpecifier.annotationUID = annotationUID;\n\n      const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);\n      const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\n      const color = this.getStyle('color', styleSpecifier, annotation);\n      // range of slices to render based on the start and end slice, like\n      // np.arange\n\n      // if indexIJK is outside the start/end slice, we don't render\n      if (\n        sliceIndex < Math.min(startSlice, endSlice) ||\n        sliceIndex > Math.max(startSlice, endSlice)\n      ) {\n        continue;\n      }\n\n      // WE HAVE TO CACHE STATS BEFORE FETCHING TEXT\n\n      if (annotation.invalidated) {\n        this._throttledCalculateCachedStats(annotation, enabledElement);\n      }\n\n      // if it is inside the start/end slice, but not exactly the first or\n      // last slice, we render the line in dash, but not the handles\n      let firstOrLastSlice = false;\n      if (sliceIndex === startSlice || sliceIndex === endSlice) {\n        firstOrLastSlice = true;\n      }\n\n      // If rendering engine has been destroyed while rendering\n      if (!viewport.getRenderingEngine()) {\n        console.warn('Rendering Engine has been destroyed');\n        return renderStatus;\n      }\n\n      let activeHandleCanvasCoords;\n\n      if (!isAnnotationVisible(annotationUID)) {\n        continue;\n      }\n\n      if (\n        !isAnnotationLocked(annotation) &&\n        !this.editData &&\n        activeHandleIndex !== null &&\n        firstOrLastSlice\n      ) {\n        // Not locked or creating and hovering over handle, so render handle.\n        activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n      }\n\n      if (activeHandleCanvasCoords) {\n        const handleGroupUID = '0';\n\n        drawHandlesSvg(\n          svgDrawingHelper,\n          annotationUID,\n          handleGroupUID,\n          activeHandleCanvasCoords,\n          {\n            color,\n          }\n        );\n      }\n\n      let lineDashToUse = lineDash;\n\n      if (!firstOrLastSlice) {\n        lineDashToUse = 2;\n      }\n\n      const rectangleUID = '0';\n      drawRectSvg(\n        svgDrawingHelper,\n        annotationUID,\n        rectangleUID,\n        canvasCoordinates[0],\n        canvasCoordinates[3],\n        {\n          color,\n          lineDash: lineDashToUse,\n          lineWidth,\n        }\n      );\n\n      renderStatus = true;\n    }\n\n    return renderStatus;\n  };\n\n  _getEndSliceIndex(\n    imageVolume: Types.IImageVolume,\n    worldPos: Types.Point3,\n    spacingInNormal: number,\n    viewPlaneNormal: Types.Point3\n  ): number | undefined {\n    const numSlicesToPropagate = this.configuration.numSlicesToPropagate;\n\n    // get end position by moving from worldPos in the direction of viewplaneNormal\n    // with amount of numSlicesToPropagate * spacingInNormal\n    const endPos = vec3.create();\n    vec3.scaleAndAdd(\n      endPos,\n      worldPos,\n      viewPlaneNormal,\n      numSlicesToPropagate * spacingInNormal\n    );\n\n    const halfSpacingInNormalDirection = spacingInNormal / 2;\n    // Loop through imageIds of the imageVolume and find the one that is closest to endPos\n    const { imageIds } = imageVolume;\n    let imageIdIndex;\n    for (let i = 0; i < imageIds.length; i++) {\n      const imageId = imageIds[i];\n\n      const { imagePositionPatient } = metaData.get(\n        'imagePlaneModule',\n        imageId\n      );\n\n      const dir = vec3.create();\n      vec3.sub(dir, endPos, imagePositionPatient);\n\n      const dot = vec3.dot(dir, viewPlaneNormal);\n\n      if (Math.abs(dot) < halfSpacingInNormalDirection) {\n        imageIdIndex = i;\n      }\n    }\n\n    return imageIdIndex;\n  }\n}\n\nRectangleROIStartEndThresholdTool.toolName = 'RectangleROIStartEndThreshold';\nexport default RectangleROIStartEndThresholdTool;\n","import { triggerEvent, eventTarget } from '@cornerstonejs/core';\nimport Events from '../enums/Events';\nimport { Annotation } from '../types';\n\nexport type FramesRange = [number, number] | number;\n\n/**\n * This class handles the annotation frame range values for multiframes.\n * Mostly used for the Video viewport, it allows references to\n * a range of frame values.\n */\nexport default class AnnotationFrameRange {\n  protected static frameRangeExtractor =\n    /(\\/frames\\/|[&?]frameNumber=)([^/&?]*)/i;\n\n  protected static imageIdToFrames(imageId: string): FramesRange {\n    const match = imageId.match(this.frameRangeExtractor);\n    if (!match || !match[2]) {\n      return null;\n    }\n    const range = match[2].split('-').map((it) => Number(it));\n    if (range.length === 1) {\n      return range[0];\n    }\n    return range as FramesRange;\n  }\n\n  public static framesToString(range) {\n    if (Array.isArray(range)) {\n      return `${range[0]}-${range[1]}`;\n    }\n    return String(range);\n  }\n\n  protected static framesToImageId(\n    imageId: string,\n    range: FramesRange | string\n  ): string {\n    const match = imageId.match(this.frameRangeExtractor);\n    if (!match || !match[2]) {\n      return null;\n    }\n    const newRangeString = this.framesToString(range);\n    return imageId.replace(\n      this.frameRangeExtractor,\n      `${match[1]}${newRangeString}`\n    );\n  }\n\n  /**\n   * Sets the range of frames to associate with the given annotation.\n   * The range can be a single frame number (1 based according to DICOM),\n   * or a range of values in the format `min-max` where min, max are inclusive\n   * Modifies the referencedImageID to specify the updated URL.\n   */\n  public static setFrameRange(\n    annotation: Annotation,\n    range: FramesRange | string,\n    eventBase?: { viewportId; renderingEngineId }\n  ) {\n    const { referencedImageId } = annotation.metadata;\n    annotation.metadata.referencedImageId = this.framesToImageId(\n      referencedImageId,\n      range\n    );\n    const eventDetail = {\n      ...eventBase,\n      annotation,\n    };\n    triggerEvent(eventTarget, Events.ANNOTATION_MODIFIED, eventDetail);\n  }\n\n  public static getFrameRange(\n    annotation: Annotation\n  ): number | [number, number] {\n    return this.imageIdToFrames(annotation.metadata.referencedImageId);\n  }\n}\n","import type { Types } from '@cornerstonejs/core';\nimport { CONSTANTS } from '@cornerstonejs/core';\n\nconst { EPSILON } = CONSTANTS;\n\n/** Bounding box type */\ntype BoundingBox =\n  | [Types.Point2, Types.Point2, null]\n  | [Types.Point2, Types.Point2, Types.Point2];\n\nfunction calculateBoundingBox(\n  points,\n  dimensions,\n  isWorld = false\n): BoundingBox {\n  let xMin = Infinity;\n  let xMax = isWorld ? -Infinity : 0;\n  let yMin = Infinity;\n  let yMax = isWorld ? -Infinity : 0;\n  let zMin = Infinity;\n  let zMax = isWorld ? -Infinity : 0;\n\n  const is3D = points[0]?.length === 3;\n\n  // use for loop for performance\n  for (let i = 0; i < points.length; i++) {\n    const p = points[i];\n    xMin = Math.min(p[0], xMin);\n    xMax = Math.max(p[0], xMax);\n    yMin = Math.min(p[1], yMin);\n    yMax = Math.max(p[1], yMax);\n\n    if (is3D) {\n      zMin = Math.min(p[2] ?? zMin, zMin);\n      zMax = Math.max(p[2] ?? zMax, zMax);\n    }\n  }\n\n  if (dimensions) {\n    xMin = Math.max(isWorld ? dimensions[0] + EPSILON : 0, xMin);\n    xMax = Math.min(\n      isWorld ? dimensions[0] - EPSILON : dimensions[0] - 1,\n      xMax\n    );\n    yMin = Math.max(isWorld ? dimensions[1] + EPSILON : 0, yMin);\n    yMax = Math.min(\n      isWorld ? dimensions[1] - EPSILON : dimensions[1] - 1,\n      yMax\n    );\n\n    if (is3D && dimensions.length === 3) {\n      zMin = Math.max(isWorld ? dimensions[2] + EPSILON : 0, zMin);\n      zMax = Math.min(\n        isWorld ? dimensions[2] - EPSILON : dimensions[2] - 1,\n        zMax\n      );\n    }\n  } else if (!isWorld) {\n    // still need to bound to 0 and Infinity if no dimensions are provided for ijk\n    xMin = Math.max(0, xMin);\n    xMax = Math.min(Infinity, xMax);\n    yMin = Math.max(0, yMin);\n    yMax = Math.min(Infinity, yMax);\n\n    if (is3D) {\n      zMin = Math.max(0, zMin);\n      zMax = Math.min(Infinity, zMax);\n    }\n  }\n\n  return is3D\n    ? [\n        [xMin, xMax],\n        [yMin, yMax],\n        [zMin, zMax],\n      ]\n    : [[xMin, xMax], [yMin, yMax], null];\n}\n\n/**\n * With a given vertices (points) coordinates in 2D or 3D in IJK, it calculates the minimum and maximum\n * coordinate in each axis, and returns them. If clipBounds are provided it also\n * clip the min, max to the provided width, height and depth\n *\n * @param points - shape corner points coordinates either in IJK (image coordinate)\n * @param dimensions - bounds to clip the min, max\n * @returns [[xMin,xMax],[yMin,yMax], [zMin,zMax]]\n */\nexport function getBoundingBoxAroundShapeIJK(\n  points: Types.Point2[] | Types.Point3[],\n  dimensions?: Types.Point2 | Types.Point3\n): BoundingBox {\n  return calculateBoundingBox(points, dimensions, false);\n}\n\n/**\n * With a given vertices (points) coordinates in 2D or 3D in World Coordinates, it calculates the minimum and maximum\n * coordinate in each axis, and returns them. If clipBounds are provided it also\n * clip the min, max to the provided width, height and depth\n *\n * @param points - shape corner points coordinates either in IJK (image coordinate)\n * @param clipBounds - bounds to clip the min, max\n * @returns [[xMin,xMax],[yMin,yMax], [zMin,zMax]]\n */\nexport function getBoundingBoxAroundShapeWorld(\n  points: Types.Point2[] | Types.Point3[],\n  clipBounds?: Types.Point2 | Types.Point3\n): BoundingBox {\n  return calculateBoundingBox(points, clipBounds, true);\n}\n","import { utilities, Enums } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nconst { calibratedPixelSpacingMetadataProvider } = utilities;\n\n/**\n * It adds the provided spacing to the Cornerstone internal calibratedPixelSpacing\n * metadata provider, then it invalidates all the tools that have the imageId as\n * their reference imageIds. Finally, it triggers a re-render for invalidated annotations.\n * @param imageId - ImageId for the calibrated image\n * @param rowPixelSpacing - Spacing in row direction\n * @param calibrationOrScale - either the calibration object or a scale value\n */\nexport default function calibrateImageSpacing(\n  imageId: string,\n  renderingEngine: Types.IRenderingEngine,\n  calibrationOrScale: Types.IImageCalibration | number\n): void {\n  // Handle simple parameter version\n  if (typeof calibrationOrScale === 'number') {\n    calibrationOrScale = {\n      type: Enums.CalibrationTypes.USER,\n      scale: calibrationOrScale,\n    };\n  }\n  // 1. Add the calibratedPixelSpacing metadata to the metadata\n  calibratedPixelSpacingMetadataProvider.add(imageId, calibrationOrScale);\n\n  // 2. Update the actor for stackViewports\n  const viewports = renderingEngine.getStackViewports();\n\n  // 2.1 If imageId is already being used in a stackViewport -> update actor\n  viewports.forEach((viewport) => {\n    const imageIds = viewport.getImageIds();\n    if (imageIds.includes(imageId)) {\n      viewport.calibrateSpacing(imageId);\n    }\n  });\n\n  // 2.2 If imageId is cached but not being displayed in a viewport, stackViewport\n  // will handle using the calibratedPixelSpacing since it has been added\n  // to the provider\n}\n","/**\n * CINE Tool Events\n */\nenum Events {\n  CLIP_STOPPED = 'CORNERSTONE_CINE_TOOL_STOPPED',\n  CLIP_STARTED = 'CORNERSTONE_CINE_TOOL_STARTED',\n}\n\nexport default Events;\n","import { glMatrix, vec3 } from 'gl-matrix';\nimport {\n  utilities as csUtils,\n  getEnabledElement,\n  StackViewport,\n  VolumeViewport,\n  cache,\n  BaseVolumeViewport,\n  Enums,\n} from '@cornerstonejs/core';\n\nimport { Types } from '@cornerstonejs/core';\nimport CINE_EVENTS from './events';\nimport { addToolState, getToolState, getToolStateByViewportId } from './state';\nimport { CINETypes } from '../../types';\nimport scroll from '../scroll';\n\nconst { ViewportStatus } = Enums;\nconst { triggerEvent } = csUtils;\n\nconst debounced = true;\nconst dynamicVolumesPlayingMap = new Map();\n\n/**\n * Starts playing a clip or adjusts the frame rate of an already playing clip.  framesPerSecond is\n * optional and defaults to 30 if not specified.  A negative framesPerSecond will play the clip in reverse.\n * The element must be a stack of images\n * @param element - HTML Element\n * @param framesPerSecond - Number of frames per second\n */\nfunction playClip(\n  element: HTMLDivElement,\n  playClipOptions: CINETypes.PlayClipOptions\n): void {\n  let playClipTimeouts;\n  let playClipIsTimeVarying;\n\n  if (element === undefined) {\n    throw new Error('playClip: element must not be undefined');\n  }\n\n  const enabledElement = getEnabledElement(element);\n\n  if (!enabledElement) {\n    throw new Error(\n      'playClip: element must be a valid Cornerstone enabled element'\n    );\n  }\n\n  if (!playClipOptions) {\n    playClipOptions = {};\n  }\n\n  // 4D Cine is enabled by default\n  playClipOptions.dynamicCineEnabled =\n    playClipOptions.dynamicCineEnabled ?? true;\n\n  const { viewport } = enabledElement;\n  const volume = _getVolumeFromViewport(viewport);\n  const playClipContext = _createCinePlayContext(viewport, playClipOptions);\n  let playClipData = getToolState(element);\n\n  const isDynamicCinePlaying =\n    playClipOptions.dynamicCineEnabled && volume?.isDynamicVolume();\n\n  // If user is trying to play CINE for a 4D volume it first needs\n  // to stop CINE that has may be playing for any other viewport.\n  if (isDynamicCinePlaying) {\n    _stopDynamicVolumeCine(element);\n  }\n\n  if (!playClipData) {\n    playClipData = {\n      intervalId: undefined,\n      framesPerSecond: 30,\n      lastFrameTimeStamp: undefined,\n      ignoreFrameTimeVector: false,\n      usingFrameTimeVector: false,\n      frameTimeVector: playClipOptions.frameTimeVector ?? undefined,\n      speed: playClipOptions.frameTimeVectorSpeedMultiplier ?? 1,\n      reverse: playClipOptions.reverse ?? false,\n      loop: playClipOptions.loop ?? true,\n    };\n    addToolState(element, playClipData);\n  } else {\n    // Make sure the specified clip is not running before any property update.\n    // If a 3D CINE was playing it passes isDynamicCinePlaying as FALSE to\n    // prevent stopping a 4D CINE in case it is playing on another viewport.\n    _stopClip(element, {\n      stopDynamicCine: !isDynamicCinePlaying,\n      viewportId: viewport.id,\n    });\n  }\n\n  playClipData.dynamicCineEnabled = playClipOptions.dynamicCineEnabled;\n\n  // If a framesPerSecond is specified and is valid, update the playClipData now\n  if (\n    playClipOptions.framesPerSecond < 0 ||\n    playClipOptions.framesPerSecond > 0\n  ) {\n    playClipData.framesPerSecond = Number(playClipOptions.framesPerSecond);\n    playClipData.reverse = playClipData.framesPerSecond < 0;\n    // If framesPerSecond is given, frameTimeVector will be ignored...\n    playClipData.ignoreFrameTimeVector = true;\n  }\n\n  // Determine if frame time vector should be used instead of a fixed frame rate...\n  if (\n    playClipData.ignoreFrameTimeVector !== true &&\n    playClipData.frameTimeVector &&\n    playClipData.frameTimeVector.length === playClipContext.numScrollSteps &&\n    playClipContext.frameTimeVectorEnabled\n  ) {\n    const { timeouts, isTimeVarying } = _getPlayClipTimeouts(\n      playClipData.frameTimeVector,\n      playClipData.speed\n    );\n\n    playClipTimeouts = timeouts;\n    playClipIsTimeVarying = isTimeVarying;\n  }\n\n  // This function encapsulates the frame rendering logic...\n  const playClipAction = () => {\n    const { numScrollSteps, currentStepIndex } = playClipContext;\n    let newStepIndex = currentStepIndex + (playClipData.reverse ? -1 : 1);\n    const newStepIndexOutOfRange =\n      newStepIndex < 0 || newStepIndex >= numScrollSteps;\n\n    if (!playClipData.loop && newStepIndexOutOfRange) {\n      // If a 3D CINE was playing it passes isDynamicCinePlaying as FALSE to\n      // prevent stopping a 4D CINE in case it is playing on another viewport.\n      _stopClip(element, {\n        stopDynamicCine: !isDynamicCinePlaying,\n        viewportId: viewport.id,\n      });\n\n      const eventDetail = { element };\n\n      triggerEvent(element, CINE_EVENTS.CLIP_STOPPED, eventDetail);\n      return;\n    }\n\n    // Loop around if newStepIndex is out of range\n    if (newStepIndex >= numScrollSteps) {\n      newStepIndex = 0;\n    } else if (newStepIndex < 0) {\n      newStepIndex = numScrollSteps - 1;\n    }\n\n    const delta = newStepIndex - currentStepIndex;\n\n    if (delta) {\n      playClipContext.scroll(delta);\n    }\n  };\n\n  if (isDynamicCinePlaying) {\n    dynamicVolumesPlayingMap.set(volume.volumeId, element);\n  }\n\n  // If playClipTimeouts array is available, not empty and its elements are NOT uniform ...\n  // ... (at least one timeout is different from the others), use alternate setTimeout implementation\n  if (\n    playClipTimeouts &&\n    playClipTimeouts.length > 0 &&\n    playClipIsTimeVarying\n  ) {\n    playClipData.usingFrameTimeVector = true;\n    playClipData.intervalId = window.setTimeout(\n      function playClipTimeoutHandler() {\n        playClipData.intervalId = window.setTimeout(\n          playClipTimeoutHandler,\n          playClipTimeouts[playClipContext.currentStepIndex]\n        );\n        playClipAction();\n      },\n      0\n    );\n  } else {\n    // ... otherwise user setInterval implementation which is much more efficient.\n    playClipData.usingFrameTimeVector = false;\n    playClipData.intervalId = window.setInterval(\n      playClipAction,\n      1000 / Math.abs(playClipData.framesPerSecond)\n    );\n  }\n\n  const eventDetail = {\n    element,\n  };\n\n  triggerEvent(element, CINE_EVENTS.CLIP_STARTED, eventDetail);\n}\n\n/**\n * Stops an already playing clip.\n * @param element - HTML Element\n */\nfunction stopClip(element: HTMLDivElement, options = {} as any): void {\n  _stopClip(element, {\n    stopDynamicCine: true,\n    ...options,\n  });\n}\n\nfunction _stopClip(\n  element: HTMLDivElement,\n  options = { stopDynamicCine: true, viewportId: undefined }\n) {\n  const { stopDynamicCine, viewportId } = options;\n  const enabledElement = getEnabledElement(element);\n\n  let toolState;\n  if (!enabledElement) {\n    if (viewportId) {\n      toolState = getToolStateByViewportId(viewportId);\n    } else {\n      return;\n    }\n  } else {\n    const { viewport } = enabledElement;\n    toolState = getToolState(viewport.element);\n  }\n\n  if (toolState) {\n    _stopClipWithData(toolState);\n  }\n\n  if (\n    stopDynamicCine &&\n    enabledElement?.viewport instanceof BaseVolumeViewport\n  ) {\n    _stopDynamicVolumeCine(element);\n  }\n}\n\n/**\n * [private] Stops any CINE playing for the dynamic volume loaded on this viewport\n * @param element - HTML Element\n */\nfunction _stopDynamicVolumeCine(element) {\n  const { viewport } = getEnabledElement(element);\n  const volume = _getVolumeFromViewport(viewport);\n\n  // If the current viewport has a 4D volume loaded it may be playing\n  // if it is also loaded on another viewport and user has started CINE\n  // for that one. This guarantees the other viewport will also be stopped.\n  if (volume?.isDynamicVolume()) {\n    const dynamicCineElement = dynamicVolumesPlayingMap.get(volume.volumeId);\n\n    dynamicVolumesPlayingMap.delete(volume.volumeId);\n\n    if (dynamicCineElement && dynamicCineElement !== element) {\n      stopClip(<HTMLDivElement>dynamicCineElement);\n    }\n  }\n}\n\n/**\n * [private] Turns a Frame Time Vector (0018,1065) array into a normalized array of timeouts. Each element\n * ... of the resulting array represents the amount of time each frame will remain on the screen.\n * @param vector - A Frame Time Vector (0018,1065) as specified in section C.7.6.5.1.2 of DICOM standard.\n * @param speed - A speed factor which will be applied to each element of the resulting array.\n * @returns An array with timeouts for each animation frame.\n */\nfunction _getPlayClipTimeouts(vector: number[], speed: number) {\n  let i;\n  let sample;\n  let delay;\n  let sum = 0;\n  const limit = vector.length;\n  const timeouts = [];\n\n  // Initialize time varying to false\n  let isTimeVarying = false;\n\n  if (typeof speed !== 'number' || speed <= 0) {\n    speed = 1;\n  }\n\n  // First element of a frame time vector must be discarded\n  for (i = 1; i < limit; i++) {\n    // eslint-disable-next-line no-bitwise\n    delay = (Number(vector[i]) / speed) | 0; // Integral part only\n    timeouts.push(delay);\n    if (i === 1) {\n      // Use first item as a sample for comparison\n      sample = delay;\n    } else if (delay !== sample) {\n      isTimeVarying = true;\n    }\n\n    sum += delay;\n  }\n\n  if (timeouts.length > 0) {\n    if (isTimeVarying) {\n      // If it's a time varying vector, make the last item an average...\n      // eslint-disable-next-line no-bitwise\n      delay = (sum / timeouts.length) | 0;\n    } else {\n      delay = timeouts[0];\n    }\n\n    timeouts.push(delay);\n  }\n\n  return { timeouts, isTimeVarying };\n}\n\n/**\n * [private] Performs the heavy lifting of stopping an ongoing animation.\n * @param element - HTML Element\n * @param playClipData - The data from playClip that needs to be stopped.\n */\nfunction _stopClipWithData(playClipData) {\n  const id = playClipData.intervalId;\n\n  if (typeof id !== 'undefined') {\n    playClipData.intervalId = undefined;\n    if (playClipData.usingFrameTimeVector) {\n      clearTimeout(id);\n    } else {\n      clearInterval(id);\n    }\n  }\n}\n\nfunction _getVolumesFromViewport(viewport): Types.IImageVolume[] {\n  return viewport\n    .getActors()\n    .map((actor) => cache.getVolume(actor.uid))\n    .filter((volume) => !!volume);\n}\n\nfunction _getVolumeFromViewport(viewport): Types.IImageVolume {\n  const volumes = _getVolumesFromViewport(viewport);\n  const dynamicVolume = volumes.find((volume) => volume.isDynamicVolume());\n\n  return dynamicVolume ?? volumes[0];\n}\n\nfunction _createStackViewportCinePlayContext(\n  viewport: StackViewport,\n  waitForRendered: number\n): CINETypes.CinePlayContext {\n  const imageIds = viewport.getImageIds();\n\n  return {\n    get numScrollSteps(): number {\n      return imageIds.length;\n    },\n    get currentStepIndex(): number {\n      return viewport.getTargetImageIdIndex();\n    },\n    get frameTimeVectorEnabled(): boolean {\n      // It is always in acquired orientation\n      return true;\n    },\n    waitForRenderedCount: 0,\n    scroll(delta: number): void {\n      if (\n        this.waitForRenderedCount <= waitForRendered &&\n        viewport.viewportStatus !== ViewportStatus.RENDERED\n      ) {\n        this.waitForRenderedCount++;\n        return;\n      }\n      this.waitForRenderedCount = 0;\n      scroll(viewport, { delta, debounceLoading: debounced });\n    },\n  };\n}\n\nfunction _createVolumeViewportCinePlayContext(\n  viewport: VolumeViewport,\n  volume: Types.IImageVolume\n): CINETypes.CinePlayContext {\n  const { volumeId } = volume;\n  const cachedScrollInfo = {\n    viewPlaneNormal: vec3.create(),\n    scrollInfo: null,\n  };\n\n  const getScrollInfo = () => {\n    const camera = viewport.getCamera();\n    const updateCache =\n      !cachedScrollInfo.scrollInfo ||\n      !vec3.equals(camera.viewPlaneNormal, cachedScrollInfo.viewPlaneNormal);\n\n    // Number of steps would change only after rotating the volume so it\n    // caches the result and recomputes only when necessary. Until it is\n    // rotated the current frame is updated locally\n    if (updateCache) {\n      const scrollInfo = csUtils.getVolumeViewportScrollInfo(\n        viewport,\n        volumeId\n      );\n\n      cachedScrollInfo.viewPlaneNormal = camera.viewPlaneNormal;\n      cachedScrollInfo.scrollInfo = scrollInfo;\n    }\n\n    return cachedScrollInfo.scrollInfo;\n  };\n\n  return {\n    get numScrollSteps(): number {\n      return getScrollInfo().numScrollSteps;\n    },\n    get currentStepIndex(): number {\n      return getScrollInfo().currentStepIndex;\n    },\n    get frameTimeVectorEnabled(): boolean {\n      const camera = viewport.getCamera();\n      const volumeViewPlaneNormal = volume.direction\n        .slice(6, 9)\n        .map((x) => -x) as Types.Point3;\n      const dot = vec3.dot(volumeViewPlaneNormal, camera.viewPlaneNormal);\n\n      // Check if the volume is in acquired orientation\n      // it may be flipped or rotated in plane\n      return glMatrix.equals(dot, 1);\n    },\n    scroll(delta: number): void {\n      getScrollInfo().currentStepIndex += delta;\n      scroll(viewport, { delta });\n    },\n  };\n}\n\nfunction _createDynamicVolumeViewportCinePlayContext(\n  volume: Types.IDynamicImageVolume\n): CINETypes.CinePlayContext {\n  return {\n    get numScrollSteps(): number {\n      return volume.numTimePoints;\n    },\n    get currentStepIndex(): number {\n      return volume.timePointIndex;\n    },\n    get frameTimeVectorEnabled(): boolean {\n      // Looping throught time does not uses frameTimeVector\n      return false;\n    },\n    scroll(delta: number): void {\n      // Updating this property (setter) makes it move to the desired time point\n      volume.timePointIndex += delta;\n    },\n  };\n}\n\nfunction _createCinePlayContext(\n  viewport,\n  playClipOptions: CINETypes.PlayClipOptions\n): CINETypes.CinePlayContext {\n  if (viewport instanceof StackViewport) {\n    return _createStackViewportCinePlayContext(\n      viewport,\n      playClipOptions.waitForRendered ?? 30\n    );\n  }\n\n  if (viewport instanceof VolumeViewport) {\n    const volume = _getVolumeFromViewport(viewport);\n\n    if (playClipOptions.dynamicCineEnabled && volume?.isDynamicVolume()) {\n      return _createDynamicVolumeViewportCinePlayContext(\n        <Types.IDynamicImageVolume>volume\n      );\n    }\n\n    return _createVolumeViewportCinePlayContext(viewport, volume);\n  }\n\n  throw new Error('Unknown viewport type');\n}\n\nexport { playClip, stopClip };\n","import { getSegmentation } from '../../stateManagement/segmentation/segmentationState';\nimport { ContourSegmentationAnnotation } from '../../types';\n\n/**\n * Adds a contour segmentation annotation to the specified segmentation.\n * @param annotation - The contour segmentation annotation to add.\n */\nexport function addContourSegmentationAnnotation(\n  annotation: ContourSegmentationAnnotation\n) {\n  if (annotation.parentAnnotationUID) {\n    // Don't add it for parent annotations - this happens during interpolation\n    return;\n  }\n  if (!annotation.data.segmentation) {\n    throw new Error(\n      'addContourSegmentationAnnotation: annotation does not have a segmentation data'\n    );\n  }\n\n  const { segmentationId, segmentIndex } = annotation.data.segmentation;\n  const segmentation = getSegmentation(segmentationId);\n\n  if (!segmentation.representationData.CONTOUR) {\n    segmentation.representationData.CONTOUR = { annotationUIDsMap: new Map() };\n  }\n\n  const { annotationUIDsMap } = segmentation.representationData.CONTOUR;\n\n  let annotationsUIDsSet = annotationUIDsMap.get(segmentIndex);\n\n  if (!annotationsUIDsSet) {\n    annotationsUIDsSet = new Set();\n    annotationUIDsMap.set(segmentIndex, annotationsUIDsSet);\n  }\n\n  annotationUIDsMap.set(\n    segmentIndex,\n    annotationsUIDsSet.add(annotation.annotationUID)\n  );\n}\n","import { state } from '../../stateManagement/segmentation';\nimport { ContourSegmentationAnnotation } from '../../types';\n\n/**\n * Removes a contour segmentation annotation from the given annotation.\n * If the annotation does not have a segmentation data, this method returns\n * quietly.  This can occur for interpolated segmentations that have not yet\n * been converted to real segmentations or other in-process segmentations.\n * @param annotation - The contour segmentation annotation to remove.\n */\nexport function removeContourSegmentationAnnotation(\n  annotation: ContourSegmentationAnnotation\n) {\n  if (!annotation.data.segmentation) {\n    throw new Error(\n      'removeContourSegmentationAnnotation: annotation does not have a segmentation data'\n    );\n  }\n\n  const { segmentationId, segmentIndex } = annotation.data.segmentation;\n  const segmentation = state.getSegmentation(segmentationId);\n  const { annotationUIDsMap } = segmentation?.representationData.CONTOUR || {};\n  const annotationsUIDsSet = annotationUIDsMap?.get(segmentIndex);\n\n  if (!annotationsUIDsSet) {\n    return;\n  }\n\n  annotationsUIDsSet.delete(annotation.annotationUID);\n\n  // Delete segmentIndex Set if there is no more annotations\n  if (!annotationsUIDsSet.size) {\n    annotationUIDsMap.delete(segmentIndex);\n  }\n}\n","import RectangleROIStartEndThreshold from './RectangleROIStartEndThreshold';\n\nfunction validateAnnotation(annotation) {\n  if (!annotation?.data) {\n    throw new Error('Tool data is empty');\n  }\n\n  if (!annotation.metadata || annotation.metadata.referenceImageId) {\n    throw new Error('Tool data is not associated with any imageId');\n  }\n}\n\nclass AnnotationToPointData {\n  static TOOL_NAMES: Record<string, any> = {};\n\n  constructor() {\n    // empty\n  }\n\n  static convert(annotation, index, metadataProvider) {\n    validateAnnotation(annotation);\n\n    const { toolName } = annotation.metadata;\n    const toolClass = AnnotationToPointData.TOOL_NAMES[toolName];\n\n    if (!toolClass) {\n      throw new Error(\n        `Unknown tool type: ${toolName}, cannot convert to RTSSReport`\n      );\n    }\n\n    // Each toolData should become a list of contours, ContourSequence\n    // contains a list of contours with their pointData, their geometry\n    // type and their length.\n    const ContourSequence = toolClass.getContourSequence(\n      annotation,\n      metadataProvider\n    );\n\n    // Todo: random rgb color for now, options should be passed in\n    const color = [\n      Math.floor(Math.random() * 255),\n      Math.floor(Math.random() * 255),\n      Math.floor(Math.random() * 255),\n    ];\n\n    return {\n      ReferencedROINumber: index + 1,\n      ROIDisplayColor: color,\n      ContourSequence,\n    };\n  }\n\n  static register(toolClass) {\n    AnnotationToPointData.TOOL_NAMES[toolClass.toolName] = toolClass;\n  }\n}\n\nAnnotationToPointData.register(RectangleROIStartEndThreshold);\n\nexport default AnnotationToPointData;\n","/**\n * Calculates the perimeter of a polyline.\n *\n * @param polyline - The polyline represented as an array of points.\n * @param closed - Indicates whether the polyline is closed or not.\n * @returns The perimeter of the polyline.\n */\nfunction calculatePerimeter(polyline: number[][], closed: boolean): number {\n  let perimeter = 0;\n\n  for (let i = 0; i < polyline.length - 1; i++) {\n    const point1 = polyline[i];\n    const point2 = polyline[i + 1];\n    perimeter += Math.sqrt(\n      Math.pow(point2[0] - point1[0], 2) + Math.pow(point2[1] - point1[1], 2)\n    );\n  }\n\n  if (closed) {\n    const firstPoint = polyline[0];\n    const lastPoint = polyline[polyline.length - 1];\n    perimeter += Math.sqrt(\n      Math.pow(lastPoint[0] - firstPoint[0], 2) +\n        Math.pow(lastPoint[1] - firstPoint[1], 2)\n    );\n  }\n\n  return perimeter;\n}\n\nexport default calculatePerimeter;\n","import { utilities as csUtils } from '@cornerstonejs/core';\nimport { vec3 } from 'gl-matrix';\n\nimport { ContourAnnotation } from '../../types/ToolSpecificAnnotationTypes';\n\nconst { isEqual } = csUtils;\n\n/**\n * Finds the index in the polyline of the specified handle.  If the handle\n * doesn't match a polyline point, then finds the closest polyline point.\n *\n * Assumes polyline is in the same orientation as the handles.\n *\n * @param annotation - to find the polyline and handles in\n * @param handleIndex - the index of hte handle to look for.\n *     Negative values are treated relative to the end of the handle index.\n * @returns Index in polyline of the closest handle\n *     * 0 for handleIndex 0\n *     * length for `handleIndex===handles length`\n */\nexport default function findHandlePolylineIndex(\n  annotation: ContourAnnotation,\n  handleIndex: number\n): number {\n  const { polyline } = annotation.data.contour;\n  const { points } = annotation.data.handles;\n  const { length } = points;\n  if (handleIndex === length) {\n    return polyline.length;\n  }\n  if (handleIndex < 0) {\n    handleIndex = (handleIndex + length) % length;\n  }\n  if (handleIndex === 0) {\n    return 0;\n  }\n  const handle = points[handleIndex];\n  const index = polyline.findIndex((point) => isEqual(handle, point));\n  if (index !== -1) {\n    return index;\n  }\n  // Need to find nearest\n  let closestDistance = Infinity;\n  return polyline.reduce((closestIndex, point, testIndex) => {\n    const distance = vec3.squaredDistance(point, handle);\n    if (distance < closestDistance) {\n      closestDistance = distance;\n      return testIndex;\n    }\n    return closestIndex;\n  }, -1);\n}\n","import { cache as cornerstoneCache } from '@cornerstonejs/core';\nimport vtkImageMarchingSquares from '@kitware/vtk.js/Filters/General/ImageMarchingSquares';\nimport vtkDataArray from '@kitware/vtk.js/Common/Core/DataArray';\nimport vtkImageData from '@kitware/vtk.js/Common/DataModel/ImageData';\n\nimport { getDeduplicatedVTKPolyDataPoints } from '../contours';\nimport { findContoursFromReducedSet } from './contourFinder';\nimport SegmentationRepresentations from '../../enums/SegmentationRepresentations';\n\nconst { Labelmap } = SegmentationRepresentations;\n\nfunction generateContourSetsFromLabelmap({ segmentations }) {\n  const { representationData, segments = [0, 1] } = segmentations;\n  const { volumeId: segVolumeId } = representationData[Labelmap];\n\n  // Get segmentation volume\n  const vol = cornerstoneCache.getVolume(segVolumeId);\n  if (!vol) {\n    console.warn(`No volume found for ${segVolumeId}`);\n    return;\n  }\n\n  const numSlices = vol.dimensions[2];\n\n  // NOTE: Workaround for marching squares not finding closed contours at\n  // boundary of image volume, clear pixels along x-y border of volume\n  const segData = vol.imageData.getPointData().getScalars().getData();\n  const pixelsPerSlice = vol.dimensions[0] * vol.dimensions[1];\n\n  for (let z = 0; z < numSlices; z++) {\n    for (let y = 0; y < vol.dimensions[1]; y++) {\n      const index = y * vol.dimensions[0] + z * pixelsPerSlice;\n      segData[index] = 0;\n      segData[index + vol.dimensions[0] - 1] = 0;\n    }\n  }\n\n  // end workaround\n  //\n  //\n  const ContourSets = [];\n\n  const { FrameOfReferenceUID } = vol.metadata;\n  // Iterate through all segments in current segmentation set\n  const numSegments = segments.length;\n  for (let segIndex = 0; segIndex < numSegments; segIndex++) {\n    const segment = segments[segIndex];\n\n    // Skip empty segments\n    if (!segment) {\n      continue;\n    }\n\n    const sliceContours = [];\n    const scalars = vtkDataArray.newInstance({\n      name: 'Scalars',\n      numberOfComponents: 1,\n      size: pixelsPerSlice * numSlices,\n      dataType: 'Uint8Array',\n    });\n    const { containedSegmentIndices } = segment;\n    for (let sliceIndex = 0; sliceIndex < numSlices; sliceIndex++) {\n      // Check if the slice is empty before running marching cube\n      if (\n        isSliceEmptyForSegment(sliceIndex, segData, pixelsPerSlice, segIndex)\n      ) {\n        continue;\n      }\n      const frameStart = sliceIndex * pixelsPerSlice;\n\n      try {\n        // Modify segData for this specific segment directly\n        for (let i = 0; i < pixelsPerSlice; i++) {\n          const value = segData[i + frameStart];\n          if (value === segIndex || containedSegmentIndices?.has(value)) {\n            (scalars as any).setValue(i + frameStart, 1);\n          } else {\n            (scalars as any).setValue(i, 0);\n          }\n        }\n\n        const mSquares = vtkImageMarchingSquares.newInstance({\n          slice: sliceIndex,\n        });\n\n        // filter out the scalar data so that only it has background and\n        // the current segment index\n        const imageDataCopy = vtkImageData.newInstance();\n\n        imageDataCopy.shallowCopy(vol.imageData);\n        imageDataCopy.getPointData().setScalars(scalars);\n\n        // Connect pipeline\n        mSquares.setInputData(imageDataCopy);\n        const cValues = [1];\n        mSquares.setContourValues(cValues);\n        mSquares.setMergePoints(false);\n\n        // Perform marching squares\n        const msOutput = mSquares.getOutputData();\n\n        // Clean up output from marching squares\n        const reducedSet = getDeduplicatedVTKPolyDataPoints(msOutput);\n        if (reducedSet.points?.length) {\n          const contours = findContoursFromReducedSet(reducedSet.lines);\n\n          sliceContours.push({\n            contours,\n            polyData: reducedSet,\n            FrameNumber: sliceIndex + 1,\n            sliceIndex,\n            FrameOfReferenceUID,\n          });\n        }\n      } catch (e) {\n        console.warn(sliceIndex);\n        console.warn(e);\n      }\n    }\n\n    const metadata = {\n      FrameOfReferenceUID,\n    };\n\n    const ContourSet = {\n      label: segment.label,\n      color: segment.color,\n      metadata,\n      sliceContours,\n    };\n\n    ContourSets.push(ContourSet);\n  }\n\n  return ContourSets;\n}\n\nfunction isSliceEmptyForSegment(sliceIndex, segData, pixelsPerSlice, segIndex) {\n  const startIdx = sliceIndex * pixelsPerSlice;\n  const endIdx = startIdx + pixelsPerSlice;\n\n  for (let i = startIdx; i < endIdx; i++) {\n    if (segData[i] === segIndex) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nexport { generateContourSetsFromLabelmap };\n","import type { Types } from '@cornerstonejs/core';\nimport type { Annotation } from '../../types';\nimport getContourHolesDataWorld from './getContourHolesDataWorld';\n\n/**\n * Get the polylines for the child annotations (holes)\n * @param annotation - Annotation\n * @param viewport - Viewport used to convert the points from world to canvas space\n * @returns An array that contains all child polylines\n */\nexport default function getContourHolesDataCanvas(\n  annotation: Annotation,\n  viewport: Types.IViewport\n): Types.Point2[][] {\n  const worldHoleContours = getContourHolesDataWorld(annotation);\n  const canvasHoleContours = [];\n\n  worldHoleContours.forEach((worldHoleContour) => {\n    const numPoints = worldHoleContour.length;\n\n    // Pre-allocated arrays are 3-4x faster than multiple \"push()\" calls\n    const canvasHoleContour: Types.Point2[] = new Array(numPoints);\n\n    // Using FOR loop instead of map() for better performance when processing large arrays\n    for (let i = 0; i < numPoints; i++) {\n      canvasHoleContour[i] = viewport.worldToCanvas(worldHoleContour[i]);\n    }\n\n    canvasHoleContours.push(canvasHoleContour);\n  });\n\n  return canvasHoleContours;\n}\n","import type { Types } from '@cornerstonejs/core';\nimport type { Annotation, ContourAnnotation } from '../../types';\nimport { getAnnotation } from '../../stateManagement';\n\n/**\n * Get child polylines data in world space for contour annotations that represent the holes\n * @param annotation - Annotation\n * @param viewport - Viewport used to convert the points from world to canvas space\n * @returns An array that contains all child polylines (holes) in world space\n */\nexport default function getContourHolesDataWorld(\n  annotation: Annotation\n): Types.Point3[][] {\n  const childAnnotationUIDs = annotation.childAnnotationUIDs ?? [];\n\n  return childAnnotationUIDs.map(\n    (uid) => (getAnnotation(uid) as ContourAnnotation).data.contour.polyline\n  );\n}\n","import { utilities as csUtils } from '@cornerstonejs/core';\nimport { Types } from '@cornerstonejs/core';\nimport type { ContourAnnotation } from '../../types';\nimport type { ContourWindingDirection } from '../../types/ContourAnnotation';\nimport * as math from '../math';\nimport {\n  getParentAnnotation,\n  invalidateAnnotation,\n} from '../../stateManagement';\n\n/**\n * Update the contour polyline data\n * @param annotation - Contour annotation\n * @param viewport - Viewport\n * @param polylineData - Polyline data (points, winding direction and closed)\n * @param transforms - Methods to convert points to/from canvas and world spaces\n * @param options - Options\n *   - decimate: allow to set some parameters to decimate the polyline reducing\n *   the amount of points stored which also affects how fast it will draw the\n *   annotation in a viewport, compute the winding direction, append/remove\n *   contours and create holes. A higher `epsilon` value results in a polyline\n *   with less points.\n */\nexport default function updateContourPolyline(\n  annotation: ContourAnnotation,\n  polylineData: {\n    points: Types.Point2[];\n    closed?: boolean;\n    targetWindingDirection?: ContourWindingDirection;\n  },\n  transforms: {\n    canvasToWorld: (point: Types.Point2) => Types.Point3;\n  },\n  options?: {\n    decimate?: {\n      enabled?: boolean;\n      epsilon?: number;\n    };\n  }\n) {\n  const { canvasToWorld } = transforms;\n  const { data } = annotation;\n  const { targetWindingDirection } = polylineData;\n  let { points: polyline } = polylineData;\n\n  // Decimate the polyline to reduce tha amount of points\n  if (options?.decimate?.enabled) {\n    polyline = math.polyline.decimate(\n      polylineData.points,\n      options?.decimate?.epsilon\n    );\n  }\n\n  let { closed } = polylineData;\n  const numPoints = polyline.length;\n  const polylineWorldPoints = new Array(numPoints);\n  const currentWindingDirection = math.polyline.getWindingDirection(polyline);\n  const parentAnnotation = getParentAnnotation(annotation) as ContourAnnotation;\n\n  if (closed === undefined) {\n    let currentClosedState = false;\n\n    // With two points it is just a line and do not make sense to consider it closed\n    if (polyline.length > 3) {\n      const lastToFirstDist = math.point.distanceToPointSquared(\n        polyline[0],\n        polyline[numPoints - 1]\n      );\n\n      currentClosedState = csUtils.isEqual(0, lastToFirstDist);\n    }\n\n    closed = currentClosedState;\n  }\n\n  // It must be in the opposite direction if it is a child annotation (hole)\n  let windingDirection = parentAnnotation\n    ? parentAnnotation.data.contour.windingDirection * -1\n    : targetWindingDirection;\n\n  if (windingDirection === undefined) {\n    windingDirection = currentWindingDirection;\n  } else if (windingDirection !== currentWindingDirection) {\n    polyline.reverse();\n  }\n\n  for (let i = 0; i < numPoints; i++) {\n    polylineWorldPoints[i] = canvasToWorld(polyline[i]);\n  }\n\n  data.contour.polyline = polylineWorldPoints;\n  data.contour.closed = closed;\n  data.contour.windingDirection = windingDirection;\n\n  invalidateAnnotation(annotation);\n}\n","import isObject from './isObject';\n\n/**\n * Creates a debounced function that delays invoking `func` until after `wait`\n * milliseconds have elapsed since the last time the debounced function was\n * invoked, or until the next browser frame is drawn. The debounced function\n * comes with a `cancel` method to cancel delayed `func` invocations and a\n * `flush` method to immediately invoke them. Provide `options` to indicate\n * whether `func` should be invoked on the leading and/or trailing edge of the\n * `wait` timeout. The `func` is invoked with the last arguments provided to the\n * debounced function. Subsequent calls to the debounced function return the\n * result of the last `func` invocation.\n *\n * **Note:** If `leading` and `trailing` options are `true`, `func` is\n * invoked on the trailing edge of the timeout only if the debounced function\n * is invoked more than once during the `wait` timeout.\n *\n * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n * until the next tick, similar to `setTimeout` with a timeout of `0`.\n *\n * If `wait` is omitted in an environment with `requestAnimationFrame`, `func`\n * invocation will be deferred until the next frame is drawn (typically about\n * 16ms).\n *\n * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n * for details over the differences between `debounce` and `throttle`.\n *\n * @param {Function} func The function to debounce.\n * @param {number} [wait=0]\n *  The number of milliseconds to delay; if omitted, `requestAnimationFrame` is\n *  used (if available).\n * @param {Object} [options={}] The options object.\n * @param {boolean} [options.leading=false]\n *  Specify invoking on the leading edge of the timeout.\n * @param {number} [options.maxWait]\n *  The maximum time `func` is allowed to be delayed before it's invoked.\n * @param {boolean} [options.trailing=true]\n *  Specify invoking on the trailing edge of the timeout.\n * @returns {Function} Returns the new debounced function.\n * @example\n *\n * // Avoid costly calculations while the window size is in flux.\n * jQuery(window).on('resize', debounce(calculateLayout, 150))\n *\n * // Invoke `sendMail` when clicked, debouncing subsequent calls.\n * jQuery(element).on('click', debounce(sendMail, 300, {\n *   'leading': true,\n *   'trailing': false\n * }))\n *\n * // Ensure `batchLog` is invoked once after 1 second of debounced calls.\n * const debounced = debounce(batchLog, 250, { 'maxWait': 1000 })\n * const source = new EventSource('/stream')\n * jQuery(source).on('message', debounced)\n *\n * // Cancel the trailing debounced invocation.\n * jQuery(window).on('popstate', debounced.cancel)\n *\n * // Check for pending invocations.\n * const status = debounced.pending() ? \"Pending...\" : \"Ready\"\n */\nfunction debounce(func, wait, options) {\n  let lastArgs, lastThis, maxWait, result, timerId, lastCallTime;\n\n  let lastInvokeTime = 0;\n  let leading = false;\n  let maxing = false;\n  let trailing = true;\n\n  // Bypass `requestAnimationFrame` by explicitly setting `wait=0`.\n  const useRAF =\n    !wait && wait !== 0 && typeof window.requestAnimationFrame === 'function';\n\n  if (typeof func !== 'function') {\n    throw new TypeError('Expected a function');\n  }\n  wait = Number(wait) || 0;\n  if (isObject(options)) {\n    leading = Boolean(options.leading);\n    maxing = 'maxWait' in options;\n    maxWait = maxing ? Math.max(Number(options.maxWait) || 0, wait) : maxWait;\n    trailing = 'trailing' in options ? Boolean(options.trailing) : trailing;\n  }\n\n  function invokeFunc(time) {\n    const args = lastArgs;\n    const thisArg = lastThis;\n\n    lastArgs = lastThis = undefined;\n    lastInvokeTime = time;\n    result = func.apply(thisArg, args);\n\n    return result;\n  }\n\n  function startTimer(pendingFunc, wait) {\n    if (useRAF) {\n      return window.requestAnimationFrame(pendingFunc);\n    }\n\n    return setTimeout(pendingFunc, wait);\n  }\n\n  function cancelTimer(id) {\n    if (useRAF) {\n      return window.cancelAnimationFrame(id);\n    }\n    clearTimeout(id);\n  }\n\n  function leadingEdge(time) {\n    // Reset any `maxWait` timer.\n    lastInvokeTime = time;\n    // Start the timer for the trailing edge.\n    timerId = startTimer(timerExpired, wait);\n\n    // Invoke the leading edge.\n    return leading ? invokeFunc(time) : result;\n  }\n\n  function remainingWait(time) {\n    const timeSinceLastCall = time - lastCallTime;\n    const timeSinceLastInvoke = time - lastInvokeTime;\n    const timeWaiting = wait - timeSinceLastCall;\n\n    return maxing\n      ? Math.min(timeWaiting, maxWait - timeSinceLastInvoke)\n      : timeWaiting;\n  }\n\n  function shouldInvoke(time) {\n    const timeSinceLastCall = time - lastCallTime;\n    const timeSinceLastInvoke = time - lastInvokeTime;\n\n    // Either this is the first call, activity has stopped and we're at the\n    // trailing edge, the system time has gone backwards and we're treating\n    // it as the trailing edge, or we've hit the `maxWait` limit.\n    return (\n      lastCallTime === undefined ||\n      timeSinceLastCall >= wait ||\n      timeSinceLastCall < 0 ||\n      (maxing && timeSinceLastInvoke >= maxWait)\n    );\n  }\n\n  function timerExpired() {\n    const time = Date.now();\n\n    if (shouldInvoke(time)) {\n      return trailingEdge(time);\n    }\n    // Restart the timer.\n    timerId = startTimer(timerExpired, remainingWait(time));\n  }\n\n  function trailingEdge(time) {\n    timerId = undefined;\n\n    // Only invoke if we have `lastArgs` which means `func` has been\n    // debounced at least once.\n    if (trailing && lastArgs) {\n      return invokeFunc(time);\n    }\n    lastArgs = lastThis = undefined;\n\n    return result;\n  }\n\n  function cancel() {\n    if (timerId !== undefined) {\n      cancelTimer(timerId);\n    }\n    lastInvokeTime = 0;\n    lastArgs = lastCallTime = lastThis = timerId = undefined;\n  }\n\n  function flush() {\n    return timerId === undefined ? result : trailingEdge(Date.now());\n  }\n\n  function pending() {\n    return timerId !== undefined;\n  }\n\n  function debounced(...args) {\n    const time = Date.now();\n    const isInvoking = shouldInvoke(time);\n\n    lastArgs = args;\n    lastThis = this; // eslint-disable-line consistent-this\n    lastCallTime = time;\n\n    if (isInvoking) {\n      if (timerId === undefined) {\n        return leadingEdge(lastCallTime);\n      }\n      if (maxing) {\n        // Handle invocations in a tight loop.\n        timerId = startTimer(timerExpired, wait);\n\n        return invokeFunc(lastCallTime);\n      }\n    }\n    if (timerId === undefined) {\n      timerId = startTimer(timerExpired, wait);\n    }\n\n    return result;\n  }\n  debounced.cancel = cancel;\n  debounced.flush = flush;\n  debounced.pending = pending;\n\n  return debounced;\n}\n\nexport default debounce;\n","import type { Types } from '@cornerstonejs/core';\n\n/**\n * Determine the coordinates that will place the textbox to the right of the\n * annotation.\n *\n * @param annotationCanvasPoints - The canvas points of the annotation's handles.\n * @returns - The coordinates for default placement of the textbox.\n */\nexport default function getTextBoxCoordsCanvas(\n  annotationCanvasPoints: Array<Types.Point2>\n): Types.Point2 {\n  const corners = _determineCorners(annotationCanvasPoints);\n  const centerY = (corners.top[1] + corners.bottom[1]) / 2;\n  const textBoxCanvas = <Types.Point2>[corners.right[0], centerY];\n\n  return textBoxCanvas;\n}\n\n/**\n * Determine the handles that have the min/max x and y values.\n *\n * @param canvasPoints - The canvas points of the annotation's handles.\n * @returns - The top, left, bottom, and right handles.\n */\nfunction _determineCorners(canvasPoints: Array<Types.Point2>) {\n  const handlesLeftToRight = [canvasPoints[0], canvasPoints[1]].sort(_compareX);\n  const handlesTopToBottom = [canvasPoints[0], canvasPoints[1]].sort(_compareY);\n  const right = handlesLeftToRight[handlesLeftToRight.length - 1];\n  const top = handlesTopToBottom[0];\n  const bottom = handlesTopToBottom[handlesTopToBottom.length - 1];\n\n  return {\n    top,\n    bottom,\n    right,\n  };\n\n  function _compareX(a, b) {\n    return a[0] < b[0] ? -1 : 1;\n  }\n  function _compareY(a, b) {\n    return a[1] < b[1] ? -1 : 1;\n  }\n}\n","import { Enums, utilities } from '@cornerstonejs/core';\n\nconst { CalibrationTypes } = Enums;\nconst PIXEL_UNITS = 'px';\n\nconst SUPPORTED_REGION_DATA_TYPES = [\n  1, // Tissue\n];\n\nconst SUPPORTED_LENGTH_VARIANT = [\n  '3,3', // x: cm  &  y:cm\n];\n\nconst SUPPORTED_PROBE_VARIANT = [\n  '4,3', // x: seconds  &  y : cm\n];\n\nconst UNIT_MAPPING = {\n  3: 'cm',\n  4: 'seconds',\n};\n\nconst EPS = 1e-3;\nconst SQUARE = '\\xb2';\n/**\n * Extracts the calibrated length units, area units, and the scale\n * for converting from internal spacing to image spacing.\n *\n * @param handles - to detect if spacing information is different between points\n * @param image - to extract the calibration from\n * @returns Object containing the units, area units, and scale\n */\nconst getCalibratedLengthUnitsAndScale = (image, handles) => {\n  const { calibration, hasPixelSpacing } = image;\n  let units = hasPixelSpacing ? 'mm' : PIXEL_UNITS;\n  let areaUnits = units + SQUARE;\n  let scale = 1;\n  let calibrationType = '';\n\n  if (\n    !calibration ||\n    (!calibration.type && !calibration.sequenceOfUltrasoundRegions)\n  ) {\n    return { units, areaUnits, scale };\n  }\n\n  if (calibration.type === CalibrationTypes.UNCALIBRATED) {\n    return { units: PIXEL_UNITS, areaUnits: PIXEL_UNITS + SQUARE, scale };\n  }\n\n  if (calibration.sequenceOfUltrasoundRegions) {\n    let imageIndex1, imageIndex2;\n    if (Array.isArray(handles) && handles.length === 2) {\n      [imageIndex1, imageIndex2] = handles;\n    } else if (typeof handles === 'function') {\n      const points = handles();\n      imageIndex1 = points[0];\n      imageIndex2 = points[1];\n    }\n\n    let regions = calibration.sequenceOfUltrasoundRegions.filter(\n      (region) =>\n        imageIndex1[0] >= region.regionLocationMinX0 &&\n        imageIndex1[0] <= region.regionLocationMaxX1 &&\n        imageIndex1[1] >= region.regionLocationMinY0 &&\n        imageIndex1[1] <= region.regionLocationMaxY1 &&\n        imageIndex2[0] >= region.regionLocationMinX0 &&\n        imageIndex2[0] <= region.regionLocationMaxX1 &&\n        imageIndex2[1] >= region.regionLocationMinY0 &&\n        imageIndex2[1] <= region.regionLocationMaxY1\n    );\n\n    // If we are not in a region at all we should show the underlying calibration\n    // which might be the mm spacing for the image\n    if (!regions?.length) {\n      return { units, areaUnits, scale };\n    }\n\n    // if we are in a region then it is the question of whether we support it\n    // or not. If we do not support it we should show px\n\n    regions = regions.filter(\n      (region) =>\n        SUPPORTED_REGION_DATA_TYPES.includes(region.regionDataType) &&\n        SUPPORTED_LENGTH_VARIANT.includes(\n          `${region.physicalUnitsXDirection},${region.physicalUnitsYDirection}`\n        )\n    );\n\n    if (!regions.length) {\n      return { units: PIXEL_UNITS, areaUnits: PIXEL_UNITS + SQUARE, scale };\n    }\n\n    // Todo: expand on this logic\n    const region = regions[0];\n\n    const physicalDeltaX = Math.abs(region.physicalDeltaX);\n    const physicalDeltaY = Math.abs(region.physicalDeltaY);\n\n    // if we are in a supported region then we should check if the\n    // physicalDeltaX and physicalDeltaY are the same. If they are not\n    // then we should show px again, but if they are the same then we should\n    // show the units\n    const isSamePhysicalDelta = utilities.isEqual(\n      physicalDeltaX,\n      physicalDeltaY,\n      EPS\n    );\n\n    if (isSamePhysicalDelta) {\n      // 1 to 1 aspect ratio, we use just one of them\n      scale = 1 / (physicalDeltaX * 10);\n      calibrationType = 'US Region';\n      units = 'mm';\n      areaUnits = 'mm' + SQUARE;\n    } else {\n      // here we are showing at the aspect ratio of the physical delta\n      // if they are not the same, then we should show px, but the correct solution\n      // is to grab each point separately and scale them individually\n      // Todo: implement this\n      return { units: PIXEL_UNITS, areaUnits: PIXEL_UNITS + SQUARE, scale };\n    }\n  } else if (calibration.scale) {\n    scale = calibration.scale;\n  }\n\n  // everything except REGION/Uncalibrated\n  const types = [\n    CalibrationTypes.ERMF,\n    CalibrationTypes.USER,\n    CalibrationTypes.ERROR,\n    CalibrationTypes.PROJECTION,\n  ];\n\n  if (types.includes(calibration?.type)) {\n    calibrationType = calibration.type;\n  }\n\n  return {\n    units: units + (calibrationType ? ` ${calibrationType}` : ''),\n    areaUnits: areaUnits + (calibrationType ? ` ${calibrationType}` : ''),\n    scale,\n  };\n};\n\nconst getCalibratedProbeUnitsAndValue = (image, handles) => {\n  const [imageIndex] = handles;\n  const { calibration } = image;\n  let units = ['raw'];\n  let values = [null];\n  let calibrationType = '';\n\n  if (\n    !calibration ||\n    (!calibration.type && !calibration.sequenceOfUltrasoundRegions)\n  ) {\n    return { units, values };\n    // Todo: add support for other scenarios\n  }\n\n  if (calibration.sequenceOfUltrasoundRegions) {\n    // for Probe tool\n    const supportedRegionsMetadata =\n      calibration.sequenceOfUltrasoundRegions.filter(\n        (region) =>\n          SUPPORTED_REGION_DATA_TYPES.includes(region.regionDataType) &&\n          SUPPORTED_PROBE_VARIANT.includes(\n            `${region.physicalUnitsXDirection},${region.physicalUnitsYDirection}`\n          )\n      );\n\n    if (!supportedRegionsMetadata?.length) {\n      return { units, values };\n    }\n\n    const region = supportedRegionsMetadata.find(\n      (region) =>\n        imageIndex[0] >= region.regionLocationMinX0 &&\n        imageIndex[0] <= region.regionLocationMaxX1 &&\n        imageIndex[1] >= region.regionLocationMinY0 &&\n        imageIndex[1] <= region.regionLocationMaxY1\n    );\n\n    if (!region) {\n      return { units, values };\n    }\n\n    // Todo: I think this is a ok assumption for now that if the referencePixelX0 and referencePixelY0\n    // are not defined, then we can assume 0 for them\n    const { referencePixelX0 = 0, referencePixelY0 = 0 } = region;\n    const { physicalDeltaX, physicalDeltaY } = region;\n\n    const yValue =\n      (imageIndex[1] - region.regionLocationMinY0 - referencePixelY0) *\n      physicalDeltaY;\n\n    const xValue =\n      (imageIndex[0] - region.regionLocationMinX0 - referencePixelX0) *\n      physicalDeltaX;\n\n    calibrationType = 'US Region';\n    values = [xValue, yValue];\n    units = [\n      UNIT_MAPPING[region.physicalUnitsXDirection],\n      UNIT_MAPPING[region.physicalUnitsYDirection],\n    ];\n  }\n\n  return {\n    units,\n    values,\n    calibrationType,\n  };\n};\n\n/** Gets the aspect ratio of the screen display relative to the image\n * display in order to square up measurement values.\n * That is, suppose the spacing on the image is 1, 0.5 (x,y spacing)\n * This is displayed at 1, 1 spacing on screen, then the\n * aspect value will be 1/0.5 = 2\n */\nconst getCalibratedAspect = (image) => image.calibration?.aspect || 1;\n\nexport {\n  getCalibratedLengthUnitsAndScale,\n  getCalibratedAspect,\n  getCalibratedProbeUnitsAndValue,\n};\n","import { utilities as csUtils } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport type { vtkImageData } from '@kitware/vtk.js/Common/DataModel/ImageData';\nimport { vec3 } from 'gl-matrix';\nimport { BoundsIJK } from '../types';\nimport { getBoundingBoxAroundShapeIJK } from './boundingBox';\n\nconst { transformWorldToIndex } = csUtils;\n\n/**\n * Given an imageData, and the great circle top and bottom points of a sphere,\n * this function will run the callback for each point of the imageData that is\n * within the sphere defined by the great circle points. If the viewport\n * is provided, region of interest will be an accurate approximation of the\n * sphere (using viewport camera), and the resulting performance will be\n * better.\n *\n * @privateRemarks great circle also known as orthodrome is the intersection of\n * the sphere and the plane that passes through the center of the sphere\n *\n * @param imageData - The volume imageData\n * @param circlePoints - bottom and top points of the great circle in world coordinates\n * @param callback - A callback function that will be called for each point in the shape.\n */\nfunction getSphereBoundsInfo(\n  circlePoints: [Types.Point3, Types.Point3],\n  imageData: vtkImageData,\n  viewport\n): {\n  boundsIJK: BoundsIJK;\n  centerWorld: Types.Point3;\n  radiusWorld: number;\n  topLeftWorld: Types.Point3;\n  bottomRightWorld: Types.Point3;\n} {\n  const [bottom, top] = circlePoints;\n\n  // Sphere center in world\n  const centerWorld = vec3.fromValues(\n    (bottom[0] + top[0]) / 2,\n    (bottom[1] + top[1]) / 2,\n    (bottom[2] + top[2]) / 2\n  );\n\n  // sphere radius in world\n  const radiusWorld = vec3.distance(bottom, top) / 2;\n\n  if (!viewport) {\n    throw new Error(\n      'viewport is required in order to calculate the sphere bounds'\n    );\n  }\n\n  const { boundsIJK, topLeftWorld, bottomRightWorld } =\n    _computeBoundsIJKWithCamera(\n      imageData,\n      viewport,\n      circlePoints,\n      centerWorld,\n      radiusWorld\n    );\n\n  return {\n    boundsIJK,\n    centerWorld: centerWorld as Types.Point3,\n    radiusWorld,\n    topLeftWorld: topLeftWorld as Types.Point3,\n    bottomRightWorld: bottomRightWorld as Types.Point3,\n  };\n}\n\nfunction _computeBoundsIJKWithCamera(\n  imageData,\n  viewport,\n  circlePoints,\n  centerWorld,\n  radiusWorld\n) {\n  const [bottom, top] = circlePoints;\n\n  const dimensions = imageData.getDimensions() as Types.Point3;\n\n  const camera = viewport.getCamera();\n\n  // Calculate viewRight from the camera, this will get used in order to\n  // calculate circles topLeft and bottomRight on different planes of intersection\n  // between sphere and viewPlane\n  const viewUp = vec3.fromValues(\n    camera.viewUp[0],\n    camera.viewUp[1],\n    camera.viewUp[2]\n  );\n  const viewPlaneNormal = vec3.fromValues(\n    camera.viewPlaneNormal[0],\n    camera.viewPlaneNormal[1],\n    camera.viewPlaneNormal[2]\n  );\n  const viewRight = vec3.create();\n\n  vec3.cross(viewRight, viewUp, viewPlaneNormal);\n\n  // we need to find the bounding box of the sphere in the image, e.g., the\n  // topLeftWorld and bottomRightWorld points of the bounding box.\n  // We go from the sphereCenter in the normal direction of amount radius, and\n  // we go left to find the topLeftWorld point of the bounding box. Next we go\n  // in the opposite direction and go right to find the bottomRightWorld point\n  // of the bounding box.\n  const topLeftWorld = vec3.create();\n  const bottomRightWorld = vec3.create();\n\n  vec3.scaleAndAdd(topLeftWorld, top, viewPlaneNormal, radiusWorld);\n  vec3.scaleAndAdd(bottomRightWorld, bottom, viewPlaneNormal, -radiusWorld);\n\n  // go in the direction of viewRight with the value of radius\n  vec3.scaleAndAdd(topLeftWorld, topLeftWorld, viewRight, -radiusWorld);\n  vec3.scaleAndAdd(bottomRightWorld, bottomRightWorld, viewRight, radiusWorld);\n\n  // In order to correctly come up with the boundsIJK, we need to consider\n  // all the points IJK to get the bounds, since the viewport might have\n  // rotate views and we cannot guarantee that the topLeft and bottomRight in the\n  // world, are the ones that will define the bounds in IJK\n  const topLeftIJK = transformWorldToIndex(\n    imageData,\n    topLeftWorld as Types.Point3\n  );\n  const bottomRightIJK = transformWorldToIndex(\n    imageData,\n    bottomRightWorld as Types.Point3\n  );\n\n  const pointsIJK = circlePoints.map((p) =>\n    transformWorldToIndex(imageData, p)\n  );\n\n  // get the bounding box of the sphere in the image\n  const boundsIJK = getBoundingBoxAroundShapeIJK(\n    [topLeftIJK, bottomRightIJK, ...pointsIJK],\n    dimensions\n  );\n\n  return { boundsIJK, topLeftWorld, bottomRightWorld };\n}\n\nexport { getSphereBoundsInfo };\n","import type { Annotation } from '../types';\nimport getViewportsForAnnotation from './getViewportsForAnnotation';\n\n/**\n * Finds a matching viewport in terms of the orientation of the annotation data\n * and the frame of reference.  This doesn't mean the annotation IS being displayed\n * in the viewport, just that it could be by navigating the slice, and/or pan/zoom,\n * without changing the orientation.\n *\n * @param annotation - to find a viewport that it could display in\n * @returns The viewport to display in\n */\nexport default function getViewportForAnnotation(annotation: Annotation) {\n  const viewports = getViewportsForAnnotation(annotation);\n\n  return viewports.length ? viewports[0] : undefined;\n}\n","import { utilities } from '@cornerstonejs/core';\n\nimport {\n  getAnnotationNearPoint,\n  getAnnotationNearPointOnEnabledElement,\n} from './getAnnotationNearPoint';\n\n// Lodash/common JS functionality\nimport debounce from './debounce';\nimport throttle from './throttle';\nimport isObject from './isObject';\nimport clip from './clip';\nimport calibrateImageSpacing from './calibrateImageSpacing';\nimport {\n  getCalibratedLengthUnitsAndScale,\n  getCalibratedProbeUnitsAndValue,\n  getCalibratedAspect,\n} from './getCalibratedUnits';\nimport triggerAnnotationRenderForViewportIds from './triggerAnnotationRenderForViewportIds';\nimport triggerAnnotationRenderForToolGroupIds from './triggerAnnotationRenderForToolGroupIds';\nimport triggerAnnotationRender from './triggerAnnotationRender';\nimport jumpToSlice from './viewport/jumpToSlice';\n\nimport pointInShapeCallback from './pointInShapeCallback';\nimport { getSphereBoundsInfo } from './getSphereBoundsInfo';\nimport scroll from './scroll';\nimport { pointToString } from './pointToString';\nimport annotationFrameRange from './annotationFrameRange';\nimport pointInSurroundingSphereCallback from './pointInSurroundingSphereCallback';\nimport getViewportForAnnotation from './getViewportForAnnotation';\n\n// name spaces\nimport * as contours from './contours';\nimport * as segmentation from './segmentation';\nimport * as drawing from './drawing';\nimport * as math from './math';\nimport * as planar from './planar';\nimport * as viewportFilters from './viewportFilters';\nimport * as orientation from './orientation';\nimport * as cine from './cine';\nimport * as boundingBox from './boundingBox';\nimport * as planarFreehandROITool from './planarFreehandROITool';\nimport * as rectangleROITool from './rectangleROITool';\nimport { stackPrefetch, stackContextPrefetch } from './stackPrefetch';\nimport * as viewport from './viewport';\nimport * as touch from './touch';\nimport * as dynamicVolume from './dynamicVolume';\nimport * as polyDataUtils from './polyData/utils';\nimport * as voi from './voi';\nimport * as contourSegmentation from './contourSegmentation';\n\nconst roundNumber = utilities.roundNumber;\n\n// Events\nimport { triggerEvent } from '@cornerstonejs/core';\n\nexport {\n  math,\n  planar,\n  viewportFilters,\n  drawing,\n  debounce,\n  dynamicVolume,\n  throttle,\n  orientation,\n  isObject,\n  touch,\n  triggerEvent,\n  calibrateImageSpacing,\n  getCalibratedLengthUnitsAndScale,\n  getCalibratedProbeUnitsAndValue,\n  getCalibratedAspect,\n  segmentation,\n  contours,\n  triggerAnnotationRenderForViewportIds,\n  triggerAnnotationRenderForToolGroupIds,\n  triggerAnnotationRender,\n  pointInShapeCallback,\n  getSphereBoundsInfo,\n  getAnnotationNearPoint,\n  getViewportForAnnotation,\n  getAnnotationNearPointOnEnabledElement,\n  jumpToSlice,\n  pointInSurroundingSphereCallback,\n  viewport,\n  cine,\n  clip,\n  boundingBox,\n  rectangleROITool,\n  planarFreehandROITool,\n  stackPrefetch,\n  stackContextPrefetch,\n  scroll,\n  roundNumber,\n  pointToString,\n  polyDataUtils,\n  voi,\n  annotationFrameRange,\n  contourSegmentation,\n};\n","/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @since 0.1.0\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * isObject({})\n * // => true\n *\n * isObject([1, 2, 3])\n * // => true\n *\n * isObject(Function)\n * // => true\n *\n * isObject(null)\n * // => false\n */\nfunction isObject(value) {\n  const type = typeof value;\n\n  return value !== null && (type === 'object' || type === 'function');\n}\n\nexport default isObject;\n","import { Types } from '@cornerstonejs/core';\n\n/**\n * Check if two axis-aligned bounding boxes intersect\n * @param aabb1 - First AABB\n * @param aabb2 - Second AABB\n * @returns True if they intersect or false otherwise\n */\nexport default function intersectAABB(\n  aabb1: Types.AABB2,\n  aabb2: Types.AABB2\n): boolean {\n  return (\n    aabb1.minX <= aabb2.maxX &&\n    aabb1.maxX >= aabb2.minX &&\n    aabb1.minY <= aabb2.maxY &&\n    aabb1.maxY >= aabb2.minY\n  );\n}\n","import { Types } from '@cornerstonejs/core';\n\n/**\n * Calculates the distance of a point to an AABB using 2D Box SDF (Signed Distance Field)\n *\n * The SDF of a Box\n * https://www.youtube.com/watch?v=62-pRVZuS5c\n *\n * @param aabb - Axis-aligned bound box\n * @param point - 2D point\n * @returns The closest distance between the 2D point and the AABB\n */\nexport default function distanceToPointSquared(\n  aabb: Types.AABB2,\n  point: Types.Point2\n): number {\n  const aabbWidth = aabb.maxX - aabb.minX;\n  const aabbHeight = aabb.maxY - aabb.minY;\n  const aabbSize = [aabbWidth, aabbHeight];\n  const aabbCenter: Types.Point2 = [\n    aabb.minX + aabbWidth / 2,\n    aabb.minY + aabbHeight / 2,\n  ];\n\n  // Translates the point as the center of the AABB is the new origin.\n  // THe point is also mirroed to the first quadrant to simplify the math.\n  const translatedPoint = [\n    Math.abs(point[0] - aabbCenter[0]),\n    Math.abs(point[1] - aabbCenter[1]),\n  ];\n\n  // Calculate the distance from the point to the vertical and horizontal AABB borders\n  const dx = translatedPoint[0] - aabbSize[0] * 0.5;\n  const dy = translatedPoint[1] - aabbSize[1] * 0.5;\n\n  // dx >  0 && dy >  0: diagonal line connecting the point to AABB's corner\n  // dx >  0 && dy <= 0: a line parallel to x-axis connecting the point to AABB's right side\n  // dx <= 0 && dy >  0: a line parallel to y-axis connecting the point to AABB's top side\n  // dx <= 0 && dy <= 0: the point is inside the AABB\n  if (dx > 0 && dy > 0) {\n    return dx * dx + dy * dy;\n  }\n\n  const dist = Math.max(dx, 0) + Math.max(dy, 0);\n\n  return dist * dist;\n}\n","import { Types } from '@cornerstonejs/core';\nimport distanceToPointSquared from './distanceToPointSquared';\n\n/**\n * Calculates the squared distance of a point to an AABB using\n * 2D Box SDF (Signed Distance Field)\n *\n * The SDF of a Box\n * https://www.youtube.com/watch?v=62-pRVZuS5c\n *\n * @param aabb - Axis-aligned bound box (minX, minY, maxX and maxY)\n * @param point - 2D point\n * @returns The squared distance between the 2D point and the AABB\n */\nexport default function distanceToPoint(\n  aabb: Types.AABB2,\n  point: Types.Point2\n): number {\n  return Math.sqrt(distanceToPointSquared(aabb, point));\n}\n","import { NamedStatistics } from '../../../types';\n\nabstract class Calculator {\n  static run: ({ value }) => void;\n  /**\n   * Gets the statistics as both an array of values, as well as the named values.\n   */\n  static getStatistics: () => NamedStatistics;\n}\n\nexport default Calculator;\n","import { NamedStatistics, Statistics } from '../../../types';\nimport Calculator from './Calculator';\n\nexport default class BasicStatsCalculator extends Calculator {\n  private static max = [-Infinity];\n  private static sum = [0];\n  private static sumSquares = [0];\n  private static squaredDiffSum = [0];\n  private static count = 0;\n\n  /**\n   * This callback is used when we verify if the point is in the annotion drawn so we can get every point\n   * in the shape to calculate the statistics\n   * @param value of the point in the shape of the annotation\n   */\n  static statsCallback = ({ value: newValue }): void => {\n    if (\n      Array.isArray(newValue) &&\n      newValue.length > 1 &&\n      this.max.length === 1\n    ) {\n      this.max.push(this.max[0], this.max[0]);\n      this.sum.push(this.sum[0], this.sum[0]);\n      this.sumSquares.push(this.sumSquares[0], this.sumSquares[0]);\n      this.squaredDiffSum.push(this.squaredDiffSum[0], this.squaredDiffSum[0]);\n    }\n\n    const newArray = Array.isArray(newValue) ? newValue : [newValue];\n    this.count += 1;\n\n    this.max.forEach(\n      (it, idx) => (this.max[idx] = Math.max(it, newArray[idx]))\n    );\n    this.sum.map((it, idx) => (this.sum[idx] += newArray[idx]));\n    this.sumSquares.map(\n      (it, idx) => (this.sumSquares[idx] += newArray[idx] ** 2)\n    );\n    this.squaredDiffSum.map(\n      (it, idx) =>\n        (this.squaredDiffSum[idx] += Math.pow(\n          newArray[idx] - this.sum[idx] / this.count,\n          2\n        ))\n    );\n  };\n\n  /**\n   * Basic function that calculates statictics for a given array of points.\n   * @returns An object that contains :\n   * max : The maximum value of the array\n   * mean : mean of the array\n   * stdDev : standard deviation of the array\n   * stdDevWithSumSquare : standard deviation of the array using sum²\n   * array : An array of hte above values, in order.\n   */\n\n  static getStatistics = (): NamedStatistics => {\n    const mean = this.sum.map((sum) => sum / this.count);\n    const stdDev = this.squaredDiffSum.map((squaredDiffSum) =>\n      Math.sqrt(squaredDiffSum / this.count)\n    );\n    const stdDevWithSumSquare = this.sumSquares.map((it, idx) =>\n      Math.sqrt(this.sumSquares[idx] / this.count - mean[idx] ** 2)\n    );\n\n    const named: NamedStatistics = {\n      max: {\n        name: 'max',\n        label: 'Max Pixel',\n        value: singleArrayAsNumber(this.max),\n        unit: null,\n      },\n      mean: {\n        name: 'mean',\n        label: 'Mean Pixel',\n        value: singleArrayAsNumber(mean),\n        unit: null,\n      },\n      stdDev: {\n        name: 'stdDev',\n        label: 'Standard Deviation',\n        value: singleArrayAsNumber(stdDev),\n        unit: null,\n      },\n      stdDevWithSumSquare: {\n        name: 'stdDevWithSumSquare',\n        value: singleArrayAsNumber(stdDevWithSumSquare),\n        unit: null,\n      },\n      count: {\n        name: 'count',\n        label: 'Pixel Count',\n        value: this.count,\n        unit: null,\n      },\n      array: [],\n    };\n    named.array.push(\n      named.max,\n      named.mean,\n      named.stdDev,\n      named.stdDevWithSumSquare,\n      named.count\n    );\n\n    this.max = [-Infinity];\n    this.sum = [0];\n    this.sumSquares = [0];\n    this.squaredDiffSum = [0];\n    this.count = 0;\n\n    return named;\n  };\n}\n\nfunction singleArrayAsNumber(val: number[]) {\n  return val.length === 1 ? val[0] : val;\n}\n","import type { Types } from '@cornerstonejs/core';\ninterface Inverts {\n  invXRadiusSq?: number;\n  invYRadiusSq?: number;\n  invZRadiusSq?: number;\n  fast?: boolean;\n  /**\n   * If you call the pointInEllipse.precalculateInverts first, then you\n   * can call precalculated directly instead of having the extra time for\n   * the if conditions.\n   */\n  precalculated?: (pointLPS: Types.Point3) => boolean;\n}\n\n/**\n * Given an ellipse and a point, return true if the point is inside the ellipse\n * @param ellipse - The ellipse object to check against.\n * @param pointLPS - The point in LPS space to test.\n * @param inverts - An object to cache the inverted radius squared values, if you\n * are testing multiple points against the same ellipse then it is recommended to\n * pass in the same object to cache the values. However, there is a simpler way\n * to do this by passing in the fast flag as true, then on the first iteration\n * the values will be cached and on subsequent iterations the cached values will\n * be used.\n *\n * @returns A boolean value.\n */\nexport default function pointInEllipse(\n  ellipse,\n  pointLPS,\n  inverts: Inverts = {}\n) {\n  if (!inverts.precalculated) {\n    precalculatePointInEllipse(ellipse, inverts);\n  }\n  return inverts.precalculated(pointLPS);\n}\n\n/**\n * This will perform some precalculations to make things faster.\n * Ideally, use the 'precalculated' function inside inverts to call the\n * test function.  This minimizes re-reading of variables and only needs the\n * LPS passed each time.\n * That is:\n *\n * ```\n *    const inverts = precalculatePointInEllipse(ellipse);\n *    if( inverts.precalculated(pointLPS) ) ...\n * ```\n */\nconst precalculatePointInEllipse = (ellipse, inverts: Inverts = {}) => {\n  const { xRadius, yRadius, zRadius } = ellipse;\n\n  // This will run only once since we are caching the values in the same\n  // object that is passed in.\n  if (\n    inverts.invXRadiusSq === undefined ||\n    inverts.invYRadiusSq === undefined ||\n    inverts.invZRadiusSq === undefined\n  ) {\n    inverts.invXRadiusSq = xRadius !== 0 ? 1 / xRadius ** 2 : 0;\n    inverts.invYRadiusSq = yRadius !== 0 ? 1 / yRadius ** 2 : 0;\n    inverts.invZRadiusSq = zRadius !== 0 ? 1 / zRadius ** 2 : 0;\n  }\n\n  const { invXRadiusSq, invYRadiusSq, invZRadiusSq } = inverts;\n  const { center } = ellipse;\n  const [centerL, centerP, centerS] = center;\n\n  inverts.precalculated = (pointLPS) => {\n    // Calculate the sum of normalized squared distances\n    const dx = pointLPS[0] - centerL;\n    let inside = dx * dx * invXRadiusSq;\n    if (inside > 1) {\n      return false;\n    }\n\n    const dy = pointLPS[1] - centerP;\n    inside += dy * dy * invYRadiusSq;\n    if (inside > 1) {\n      return false;\n    }\n\n    const dz = pointLPS[2] - centerS;\n    inside += dz * dz * invZRadiusSq;\n\n    // Check if the point is inside the ellipse\n    return inside <= 1;\n  };\n\n  return inverts;\n};\n\nexport { precalculatePointInEllipse };\n","import type { Types } from '@cornerstonejs/core';\n\nexport type CanvasCoordinates = [\n  Types.Point2, // bottom\n  Types.Point2, // top\n  Types.Point2, // left\n  Types.Point2 // right\n];\n\n/**\n * It takes the canvas coordinates of the ellipse corners and returns the top left and bottom right\n * corners of it\n *\n * @param ellipseCanvasPoints - The coordinates of the ellipse in the canvas.\n * @returns An array of two points.\n */\nexport default function getCanvasEllipseCorners(\n  ellipseCanvasPoints: CanvasCoordinates\n): Array<Types.Point2> {\n  const [bottom, top, left, right] = ellipseCanvasPoints;\n\n  const topLeft = <Types.Point2>[left[0], top[1]];\n  const bottomRight = <Types.Point2>[right[0], bottom[1]];\n\n  return [topLeft, bottomRight];\n}\n","import type { Types } from '@cornerstonejs/core';\nimport * as math from '../';\n\n/**\n * Calculate the closest point and the squared distance between a reference point and a line segment.\n *\n * It projects the reference point onto the line segment but it shall be bounded by the\n * start/end points since this is a line segment and not a line which could be extended.\n *\n * @param lineStart - Start point of the line segment\n * @param lineEnd - End point of the line segment\n * @param point - Reference point\n * @returns Closest point and the squared distance between a `point` and a line\n *   segment defined by `lineStart` and `lineEnd` points\n */\nexport default function distanceToPointSquaredInfo(\n  lineStart: Types.Point2,\n  lineEnd: Types.Point2,\n  point: Types.Point2\n): {\n  point: Types.Point2;\n  distanceSquared: number;\n} {\n  let closestPoint: Types.Point2;\n  const distanceSquared = math.point.distanceToPointSquared(lineStart, lineEnd);\n\n  // Check if lineStart equal to the lineEnd which means the closest point\n  // is any of these two points\n  if (lineStart[0] === lineEnd[0] && lineStart[1] === lineEnd[1]) {\n    closestPoint = lineStart;\n  }\n\n  if (!closestPoint) {\n    const dotProduct =\n      ((point[0] - lineStart[0]) * (lineEnd[0] - lineStart[0]) +\n        (point[1] - lineStart[1]) * (lineEnd[1] - lineStart[1])) /\n      distanceSquared;\n\n    if (dotProduct < 0) {\n      closestPoint = lineStart;\n    } else if (dotProduct > 1) {\n      closestPoint = lineEnd;\n    } else {\n      closestPoint = [\n        lineStart[0] + dotProduct * (lineEnd[0] - lineStart[0]),\n        lineStart[1] + dotProduct * (lineEnd[1] - lineStart[1]),\n      ];\n    }\n  }\n\n  return {\n    point: [...closestPoint],\n    distanceSquared: math.point.distanceToPointSquared(point, closestPoint),\n  };\n}\n","import { Types } from '@cornerstonejs/core';\nimport distanceToPointSquaredInfo from './distanceToPointSquaredInfo';\n\n/**\n * Calculates the distance-squared of a point to a line segment\n *\n * @param lineStart - x,y coordinates of the start of the line\n * @param lineEnd - x,y coordinates of the end of the line\n * @param point - x,y of the point\n * @returns distance-squared\n */\nexport default function distanceToPointSquared(\n  lineStart: Types.Point2,\n  lineEnd: Types.Point2,\n  point: Types.Point2\n): number {\n  return distanceToPointSquaredInfo(lineStart, lineEnd, point).distanceSquared;\n}\n","import distanceToPointSquared from './distanceToPointSquared';\nimport type { Types } from '@cornerstonejs/core';\n\n/**\n * Calculates the distance of a point to a line\n *\n * @param lineStart - x,y coordinates of the start of the line\n * @param lineEnd - x,y coordinates of the end of the line\n * @param point - x,y of the point\n * @returns distance\n */\nexport default function distanceToPoint(\n  lineStart: Types.Point2,\n  lineEnd: Types.Point2,\n  point: Types.Point2\n): number {\n  if (lineStart.length !== 2 || lineEnd.length !== 2 || point.length !== 2) {\n    throw Error(\n      'lineStart, lineEnd, and point should have 2 elements of [x, y]'\n    );\n  }\n\n  return Math.sqrt(distanceToPointSquared(lineStart, lineEnd, point));\n}\n","import type { Types } from '@cornerstonejs/core';\n\n// Returns sign of number\nfunction sign(x: any) {\n  return typeof x === 'number'\n    ? x\n      ? x < 0\n        ? -1\n        : 1\n      : x === x\n      ? 0\n      : NaN\n    : NaN;\n}\n\n/**\n * Calculates the intersection point between two lines in the 2D plane\n *\n * @param line1Start - x,y coordinates of the start of the first line\n * @param line1End - x,y coordinates of the end of the first line\n * @param line2Start - x,y coordinates of the start of the second line\n * @param line2End - x,y coordinates of the end of the second line\n * @returns [x,y] - point x,y of the point\n */\n\nexport default function intersectLine(\n  line1Start: Types.Point2,\n  line1End: Types.Point2,\n  line2Start: Types.Point2,\n  line2End: Types.Point2\n): number[] {\n  const [x1, y1] = line1Start;\n  const [x2, y2] = line1End;\n  const [x3, y3] = line2Start;\n  const [x4, y4] = line2End;\n\n  // Compute a1, b1, c1, where line joining points 1 and 2 is \"a1 x  +  b1 y  +  c1  =  0\"\n  const a1 = y2 - y1;\n  const b1 = x1 - x2;\n  const c1 = x2 * y1 - x1 * y2;\n\n  // Compute r3 and r4\n  const r3 = a1 * x3 + b1 * y3 + c1;\n  const r4 = a1 * x4 + b1 * y4 + c1;\n\n  /* Check signs of r3 and r4.  If both point 3 and point 4 lie on\n   * same side of line 1, the line segments do not intersect.\n   */\n\n  if (r3 !== 0 && r4 !== 0 && sign(r3) === sign(r4)) {\n    return;\n  }\n\n  // Compute a2, b2, c2\n  const a2 = y4 - y3;\n  const b2 = x3 - x4;\n  const c2 = x4 * y3 - x3 * y4;\n\n  // Compute r1 and r2\n  const r1 = a2 * x1 + b2 * y1 + c2;\n  const r2 = a2 * x2 + b2 * y2 + c2;\n\n  /* Check signs of r1 and r2.  If both point 1 and point 2 lie\n   * on same side of second line segment, the line segments do\n   * not intersect.\n   */\n\n  if (r1 !== 0 && r2 !== 0 && sign(r1) === sign(r2)) {\n    return;\n  }\n\n  /* Line segments intersect: compute intersection point.\n   */\n\n  const denom = a1 * b2 - a2 * b1;\n  let num;\n\n  /* The denom/2 is to get rounding instead of truncating.  It\n   * is added or subtracted to the numerator, depending upon the\n   * sign of the numerator.\n   */\n\n  num = b1 * c2 - b2 * c1;\n  const x = num / denom;\n\n  num = a2 * c1 - a1 * c2;\n  const y = num / denom;\n\n  const intersectionPoint = [x, y];\n\n  return intersectionPoint;\n}\n","import type { Types } from '@cornerstonejs/core';\n\nconst ORIENTATION_TOLERANCE = 1e-2;\n\n/**\n * Test if a point is on a line segment\n * @param lineStart - Line segment start point\n * @param lineEnd - Line segment end point\n * @param point - Point to test\n * @returns True if the point lies on the line segment or false otherwise\n */\nexport default function isPointOnLineSegment(\n  lineStart: Types.Point2,\n  lineEnd: Types.Point2,\n  point: Types.Point2\n): boolean {\n  // The code below runs ~4x faster than calling `line.distanceToPointSquared()` (155 vs 598 ms)\n\n  // No Math.min/max call for better performance when testing thousands of points\n  const minX = lineStart[0] <= lineEnd[0] ? lineStart[0] : lineEnd[0];\n  const maxX = lineStart[0] >= lineEnd[0] ? lineStart[0] : lineEnd[0];\n  const minY = lineStart[1] <= lineEnd[1] ? lineStart[1] : lineEnd[1];\n  const maxY = lineStart[1] >= lineEnd[1] ? lineStart[1] : lineEnd[1];\n\n  // Checks if the point lies inside the AABB\n  const aabbContainsPoint =\n    point[0] >= minX - ORIENTATION_TOLERANCE &&\n    point[0] <= maxX + ORIENTATION_TOLERANCE &&\n    point[1] >= minY - ORIENTATION_TOLERANCE &&\n    point[1] <= maxY + ORIENTATION_TOLERANCE;\n\n  if (!aabbContainsPoint) {\n    return false;\n  }\n\n  // Now that we know the point is inside the AABB we check if it lies on the line segment\n  const orientation =\n    (lineEnd[1] - lineStart[1]) * (point[0] - lineEnd[0]) -\n    (lineEnd[0] - lineStart[0]) * (point[1] - lineEnd[1]);\n  const absOrientation = orientation >= 0 ? orientation : -orientation;\n\n  // The orientation must be zero for points that lies on the same line\n  return absOrientation <= ORIENTATION_TOLERANCE;\n}\n","import type { Types } from '@cornerstonejs/core';\nimport distanceToPointSquared from './distanceToPointSquared';\n\ntype Point = Types.Point2 | Types.Point3;\n\n/**\n * Calculates the distance of a point to another point\n *\n * @param p1 - x,y or x,y,z of the point\n * @param p2 - x,y or x,y,z of the point\n * @returns distance\n */\nexport default function distanceToPoint(p1: Point, p2: Point): number {\n  return Math.sqrt(distanceToPointSquared(p1, p2));\n}\n","import type { Types } from '@cornerstonejs/core';\n\ntype Point = Types.Point2 | Types.Point3;\n\n/**\n * Calculates the distance squared of a point to another point\n *\n * @param p1 - x,y or x,y,z of the point\n * @param p2 - x,y or x,y,z of the point\n * @returns distance\n */\nexport default function distanceToPointSquared(p1: Point, p2: Point): number {\n  if (p1.length !== p2.length) {\n    throw Error('Both points should have the same dimensionality');\n  }\n\n  const [x1, y1, z1 = 0] = p1;\n  const [x2, y2, z2 = 0] = p2;\n  const dx = x2 - x1;\n  const dy = y2 - y1;\n  const dz = z2 - z1;\n\n  // Time to square 10M numbers:\n  //   (n * n) = 161ms | (n ** 2) = 199ms | Math.pow(n, 2) = 29529ms\n  return dx * dx + dy * dy + dz * dz;\n}\n","import { Types } from '@cornerstonejs/core';\n\n/**\n * Get a mirrored point along the line created by two points where one of them\n * is the static (\"anchor\") point and the other one is the point to be mirroed.\n * @param mirrorPoint - 2D Point to be mirroed\n * @param staticPoint - Static 2D point\n * @returns Mirroed 2D point\n */\nexport default function mirror(\n  mirrorPoint: Types.Point2,\n  staticPoint: Types.Point2\n): Types.Point2 {\n  const [x1, y1] = mirrorPoint;\n  const [x2, y2] = staticPoint;\n\n  const newX = 2 * x2 - x1;\n  const newY = 2 * y2 - y1;\n\n  return [newX, newY];\n}\n","import { glMatrix } from 'gl-matrix';\nimport type { Types } from '@cornerstonejs/core';\nimport * as math from '..';\n\n/**\n * A polyline is considered closed if the start and end points are at the same position\n *\n * @param polyline - Polyline points (2D)\n * @returns True if the polyline is already closed or false otherwise\n */\nexport default function isClosed(polyline: Types.Point2[]): boolean {\n  if (polyline.length < 3) {\n    return false;\n  }\n\n  const numPolylinePoints = polyline.length;\n\n  const firstPoint = polyline[0];\n  const lastPoint = polyline[numPolylinePoints - 1];\n  const distFirstToLastPoints = math.point.distanceToPointSquared(\n    firstPoint,\n    lastPoint\n  );\n\n  return glMatrix.equals(0, distFirstToLastPoints);\n}\n","import type { Types } from '@cornerstonejs/core';\nimport isClosed from './isClosed';\n\n/**\n * Checks if a 2D point is inside the polyline.\n *\n * A point is inside a curve/polygon if the number of intersections between the horizontal\n * ray emanating from the given point and to the right and the line segments is odd.\n * https://www.eecs.umich.edu/courses/eecs380/HANDOUTS/PROJ2/InsidePoly.html\n *\n * Note that a point on the polyline is considered inside.\n *\n * @param polyline - Polyline points (2D)\n * @param point - 2D Point\n * @returns True if the point is inside the polyline or false otherwise\n */\nexport default function containsPoint(\n  polyline: Types.Point2[],\n  point: Types.Point2,\n  options: {\n    closed?: boolean;\n    holes?: Types.Point2[][];\n  } = {\n    closed: undefined,\n  }\n): boolean {\n  if (polyline.length < 3) {\n    return false;\n  }\n\n  const numPolylinePoints = polyline.length;\n  let numIntersections = 0;\n\n  const { closed, holes } = options;\n\n  if (holes?.length) {\n    for (const hole of holes) {\n      if (containsPoint(hole, point)) {\n        return false;\n      }\n    }\n  }\n\n  // Test intersection against [end, start] line segment if it should be closed\n  const shouldClose = !(closed === undefined ? isClosed(polyline) : closed);\n  const maxSegmentIndex = polyline.length - (shouldClose ? 1 : 2);\n\n  for (let i = 0; i <= maxSegmentIndex; i++) {\n    const p1 = polyline[i];\n\n    // Calculating the next point index without using % (mod) operator like in\n    // `(i + 1) % numPolylinePoints` to make it 20% faster\n    const p2Index = i === numPolylinePoints - 1 ? 0 : i + 1;\n    const p2 = polyline[p2Index];\n\n    // Calculating min/max without using Math.min/max to make it ~3% faster\n    const maxX = p1[0] >= p2[0] ? p1[0] : p2[0];\n    const maxY = p1[1] >= p2[1] ? p1[1] : p2[1];\n    const minY = p1[1] <= p2[1] ? p1[1] : p2[1];\n\n    const mayIntersectLineSegment =\n      point[0] <= maxX && point[1] >= minY && point[1] < maxY;\n\n    if (mayIntersectLineSegment) {\n      const isVerticalLine = p1[0] === p2[0];\n      let intersects = isVerticalLine;\n\n      if (!intersects) {\n        const xIntersection =\n          ((point[1] - p1[1]) * (p2[0] - p1[0])) / (p2[1] - p1[1]) + p1[0];\n\n        intersects = point[0] <= xIntersection;\n      }\n\n      numIntersections += intersects ? 1 : 0;\n    }\n  }\n\n  return !!(numIntersections % 2);\n}\n","import type { Types } from '@cornerstonejs/core';\nimport containsPoint from './containsPoint';\n\n/**\n * Checks if a polyline contains a set of points.\n *\n * @param polyline - Polyline points (2D)\n * @param points - 2D points to verify\n * @returns True if all points are inside the polyline or false otherwise\n */\nexport default function containsPoints(\n  polyline: Types.Point2[],\n  points: Types.Point2[]\n): boolean {\n  for (let i = 0, numPoint = points.length; i < numPoint; i++) {\n    if (!containsPoint(polyline, points[i])) {\n      return false;\n    }\n  }\n\n  return true;\n}\n","import type { Types } from '@cornerstonejs/core';\n\n/**\n * Calculates the area of an array of `Point2` points using the shoelace algorithm.\n *\n * The units of the area are in the same units as the points are in. E.g. if\n * the points are in canvas, then the result is in canvas pixels ^2; If they are\n * in mm, then the result is in mm^2; etc.\n */\nexport default function getArea(points: Types.Point2[]): number {\n  // Shoelace algorithm.\n  const n = points.length;\n  let area = 0.0;\n  let j = n - 1;\n\n  for (let i = 0; i < n; i++) {\n    area += (points[j][0] + points[i][0]) * (points[j][1] - points[i][1]);\n    j = i; // j is previous vertex to i\n  }\n\n  // Return absolute value of half the sum (half as summing up traingles).\n  return Math.abs(area / 2.0);\n}\n","import type { Types } from '@cornerstonejs/core';\n\n/**\n * Returns the area with signal of a 2D polyline\n * https://www.youtube.com/watch?v=GpsKrAipXm8&t=1900s\n *\n * This functions has a runtime very close to `getArea` and it is recommended to\n * be called only if you need the area signal (eg: calculate polygon normal). If\n * you do not need the area signal you should always call `getArea`.\n *\n *\n * @param polyline - Polyline points (2D)\n * @returns Area of the polyline (with signal)\n */\nexport default function getSignedArea(polyline: Types.Point2[]): number {\n  if (polyline.length < 3) {\n    return 0;\n  }\n\n  // Reference point can be any point on the same plane\n  const refPoint = polyline[0];\n  let area = 0;\n\n  // Takes three points (reference point and two other points from each line\n  // segment) and calculate the area with cross product. The magnitude of the\n  // vector returned by a cross product is equal to the area of the parallelogram\n  // that the vectors span which is two times the area of the triangle.\n  //\n  // Not calling vec3 mathods makes the function run much faster since polylines\n  // may have thousands of points when using freehand ROI tool and that would\n  // increase considerably the number of function calls.\n  for (let i = 0, len = polyline.length; i < len; i++) {\n    const p1 = polyline[i];\n    // Using ternary instead of % (mod) operator to make it faster\n    const p2Index = i === len - 1 ? 0 : i + 1;\n    const p2 = polyline[p2Index];\n    const aX = p1[0] - refPoint[0];\n    const aY = p1[1] - refPoint[1];\n    const bX = p2[0] - refPoint[0];\n    const bY = p2[1] - refPoint[1];\n\n    // Cross product between vectors \"a\" and \"b\" which returns (0, 0, crossProd)\n    // for 2D vectors.\n    area += aX * bY - aY * bX;\n  }\n\n  // Divide by two because cross product returns two times the area for each triangle\n  area *= 0.5;\n\n  return area;\n}\n","import type { Types } from '@cornerstonejs/core';\nimport getSignedArea from './getSignedArea';\n\n/**\n * Calculate the winding direction (CW or CCW) of a polyline\n * @param polyline - Polyline (2D)\n * @returns 1 for CW or -1 for CCW polylines\n */\nexport default function getWindingDirection(polyline: Types.Point2[]): number {\n  const signedArea = getSignedArea(polyline);\n\n  // Return 1 or -1 which is also possible to convert into ContourOrientation\n  return signedArea >= 0 ? 1 : -1;\n}\n","import { vec3 } from 'gl-matrix';\nimport { Types } from '@cornerstonejs/core';\n\nfunction _getAreaVector(polyline: Types.Point3[]): Types.Point3 {\n  const vecArea = vec3.create();\n\n  // Reference point can be any point on the same plane\n  const refPoint = polyline[0];\n\n  // Takes three points, reference point and two other points from each line\n  // segment, and calculate the area with cross product. The magnitude of the\n  // vector returned by a cross product is equal to the area of the parallelogram\n  // that the vectors span which is two times the area of the triangle.\n  //\n  // Not calling vec3 mathods makes the function run much faster since polylines\n  // may have thousands of points when using freehand ROI tool and that would\n  // increase considerably the number of function calls.\n  for (let i = 0, len = polyline.length; i < len; i++) {\n    const p1 = polyline[i];\n    // Using ternary instead of % (mod) operator to make it faster\n    const p2Index = i === len - 1 ? 0 : i + 1;\n    const p2 = polyline[p2Index];\n\n    const aX = p1[0] - refPoint[0];\n    const aY = p1[1] - refPoint[1];\n    const aZ = p1[2] - refPoint[2];\n    const bX = p2[0] - refPoint[0];\n    const bY = p2[1] - refPoint[1];\n    const bZ = p2[2] - refPoint[2];\n\n    // Cross product without calling vec3.cross() for better performance\n    vecArea[0] += aY * bZ - aZ * bY;\n    vecArea[1] += aZ * bX - aX * bZ;\n    vecArea[2] += aX * bY - aY * bX;\n  }\n\n  // Divide by two because cross product returns two times the area for each triangle\n  vec3.scale(vecArea, vecArea, 0.5);\n\n  // The magnitude of the vector is the area of the polyline\n  return <Types.Point3>vecArea;\n}\n\n/**\n * Calculate the normal of a 3D planar polyline\n * @param polyline - Planar polyline in 3D space\n * @returns Normal of the 3D planar polyline\n */\nexport default function getNormal3(polyline: Types.Point3[]): Types.Point3 {\n  const vecArea = _getAreaVector(polyline);\n\n  return vec3.normalize(vecArea, vecArea) as Types.Point3;\n}\n","import { Types } from '@cornerstonejs/core';\nimport getSignedArea from './getSignedArea';\n\n/**\n * Calculate the normal of a 2D polyline\n * https://www.youtube.com/watch?v=GpsKrAipXm8&t=1982s\n *\n * @param polyline - Planar polyline in 2D space\n * @returns Normal of the 2D planar polyline\n */\nexport default function getNormal2(polyline: Types.Point2[]): Types.Point3 {\n  const area = getSignedArea(polyline);\n\n  // The normal of a 2D polyline is (0, 0, 1) or (0, 0, -1) depending if it\n  // is CW or CCW polyline\n  return [0, 0, area / Math.abs(area)] as Types.Point3;\n}\n","import type { Types } from '@cornerstonejs/core';\n\n// ATTENTION: this is an internal function and it should not be added to \"polyline\"\n// namespace.\n//\n// TODO: there is a similar function in math.lineSegment.intersectLine but we\n// need to investigate why it is 6x slower than this one when thousands of\n// intersections are calculated. Also that one may return [NaN, NaN] for\n// collinear points.\n\n/**\n * Checks whether the line (`p1`,`q1`) intersects the line (`p2`,`q2`) via an\n * orientation algorithm.\n *\n * Credit and details: geeksforgeeks.org/check-if-two-given-line-segments-intersect/\n *\n * @param p1 - Start point of line segment 1\n * @param q1 - End point of line segment 1\n * @param p2 - Start point of line segment 2\n * @param q2 - End point of line segment 2\n * @returns True if the line segments intersect or false otherwise\n */\nexport default function areLineSegmentsIntersecting(\n  p1: Types.Point2,\n  q1: Types.Point2,\n  p2: Types.Point2,\n  q2: Types.Point2\n): boolean {\n  let result = false;\n\n  // Line 1 AABB\n  const line1MinX = p1[0] < q1[0] ? p1[0] : q1[0];\n  const line1MinY = p1[1] < q1[1] ? p1[1] : q1[1];\n  const line1MaxX = p1[0] > q1[0] ? p1[0] : q1[0];\n  const line1MaxY = p1[1] > q1[1] ? p1[1] : q1[1];\n\n  // Line 2 AABB\n  const line2MinX = p2[0] < q2[0] ? p2[0] : q2[0];\n  const line2MinY = p2[1] < q2[1] ? p2[1] : q2[1];\n  const line2MaxX = p2[0] > q2[0] ? p2[0] : q2[0];\n  const line2MaxY = p2[1] > q2[1] ? p2[1] : q2[1];\n\n  // If AABBs do not intersect it is impossible for the lines to intersect.\n  // Checking AABB before doing any math makes it run ~12% faster.\n  if (\n    line1MinX > line2MaxX ||\n    line1MaxX < line2MinX ||\n    line1MinY > line2MaxY ||\n    line1MaxY < line2MinY\n  ) {\n    return false;\n  }\n\n  const orient = [\n    orientation(p1, q1, p2),\n    orientation(p1, q1, q2),\n    orientation(p2, q2, p1),\n    orientation(p2, q2, q1),\n  ];\n\n  // General Case\n  if (orient[0] !== orient[1] && orient[2] !== orient[3]) {\n    return true;\n  }\n\n  // Special Cases\n  if (orient[0] === 0 && onSegment(p1, p2, q1)) {\n    // If p1, q1 and p2 are colinear and p2 lies on segment p1q1\n    result = true;\n  } else if (orient[1] === 0 && onSegment(p1, q2, q1)) {\n    // If p1, q1 and p2 are colinear and q2 lies on segment p1q1\n    result = true;\n  } else if (orient[2] === 0 && onSegment(p2, p1, q2)) {\n    // If p2, q2 and p1 are colinear and p1 lies on segment p2q2\n    result = true;\n  } else if (orient[3] === 0 && onSegment(p2, q1, q2)) {\n    // If p2, q2 and q1 are colinear and q1 lies on segment p2q2\n    result = true;\n  }\n\n  return result;\n}\n\n/**\n * Checks the orientation of 3 points, returns a 0, 1 or 2 based on\n * the orientation of the points.\n */\nfunction orientation(\n  p: Types.Point2,\n  q: Types.Point2,\n  r: Types.Point2\n): number {\n  // Take the cross product between vectors PQ and QR\n  const orientationValue =\n    (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1]);\n\n  if (orientationValue === 0) {\n    return 0; // Colinear\n  }\n\n  return orientationValue > 0 ? 1 : 2;\n}\n\n/**\n * Checks if point `q` lies on the segment (`p`,`r`).\n */\nfunction onSegment(p: Types.Point2, q: Types.Point2, r: Types.Point2): boolean {\n  if (\n    q[0] <= Math.max(p[0], r[0]) &&\n    q[0] >= Math.min(p[0], r[0]) &&\n    q[1] <= Math.max(p[1], r[1]) &&\n    q[1] >= Math.min(p[1], r[1])\n  ) {\n    return true;\n  }\n\n  return false;\n}\n","import type { Types } from '@cornerstonejs/core';\nimport areLineSegmentsIntersecting from './areLineSegmentsIntersecting';\n\n/**\n * Get all intersections between a polyline and a line segment.\n * @param polyline - Polyline points\n * @param p1 - Start point of line segment\n * @param q1 - End point of line segment\n * @param closed - Test the intersection against the line segment that connects\n * the last to the first point when set to true\n * @returns Start/end point indexes of all line segments that intersect (p1, q1)\n */\nexport default function getLineSegmentIntersectionsIndexes(\n  polyline: Types.Point2[],\n  p1: Types.Point2,\n  q1: Types.Point2,\n  closed = true\n): Types.Point2[] {\n  const intersections: Types.Point2[] = [];\n  const numPoints = polyline.length;\n  const maxI = numPoints - (closed ? 1 : 2);\n\n  for (let i = 0; i <= maxI; i++) {\n    const p2 = polyline[i];\n    // Do not use % operator for better performance\n    const j = i === numPoints - 1 ? 0 : i + 1;\n    const q2 = polyline[j];\n\n    if (areLineSegmentsIntersecting(p1, q1, p2, q2)) {\n      intersections.push([i, j]);\n    }\n  }\n\n  return intersections;\n}\n","import { Types } from '@cornerstonejs/core';\nimport * as mathLine from '../line';\n\n// ATTENTION: this is an internal function and it should not be added to \"polyline\" namespace\n\n// Tested with +1M random overlapping line segments and any tolerance below this\n// one may return invalid results.\nconst PARALLEL_LINES_TOLERANCE = 1e-2;\n\n/**\n * It returns the intersection between two lines (not line segments) or a midpoint\n * when the line segments overlap. This function calculates the intersection between\n * lines because it considers that getFirstLineSegmentIntersectionIndexes,\n * getLineSegmentIntersectionsCoordinates or getLineSegmentIntersectionsIndexes\n * has already been called first which guarantees.\n *\n * @param p1 - Line segment 1 start\n * @param q1 - Line segment 1 end\n * @param p2 - Line segment 2 start\n * @param q2 - Line segment 21 end\n * @returns The intersection between two lines or a midpoint when they overlap\n */\nexport default function getLinesIntersection(\n  p1: Types.Point2,\n  q1: Types.Point2,\n  p2: Types.Point2,\n  q2: Types.Point2\n) {\n  const diffQ1P1 = [q1[0] - p1[0], q1[1] - p1[1]];\n  const diffQ2P2 = [q2[0] - p2[0], q2[1] - p2[1]];\n  const denominator = diffQ2P2[1] * diffQ1P1[0] - diffQ2P2[0] * diffQ1P1[1];\n  const absDenominator = denominator >= 0 ? denominator : -denominator;\n\n  if (absDenominator < PARALLEL_LINES_TOLERANCE) {\n    // No Math.min/max calls for better performance.\n    const line1AABB = [\n      p1[0] < q1[0] ? p1[0] : q1[0], // 0: minX\n      p1[0] > q1[0] ? p1[0] : q1[0], // 1: maxX\n      p1[1] < q1[1] ? p1[1] : q1[1], // 2: minY\n      p1[1] > q1[1] ? p1[1] : q1[1], // 3: maxY\n    ];\n\n    // No Math.min/max calls for better performance.\n    const line2AABB = [\n      p2[0] < q2[0] ? p2[0] : q2[0], // 0: minX\n      p2[0] > q2[0] ? p2[0] : q2[0], // 1: maxX\n      p2[1] < q2[1] ? p2[1] : q2[1], // 2: minY\n      p2[1] > q2[1] ? p2[1] : q2[1], // 3: maxY\n    ];\n\n    const aabbIntersects =\n      line1AABB[0] <= line2AABB[1] && // minX1 <= maxX2\n      line1AABB[1] >= line2AABB[0] && // maxX1 >= minX2\n      line1AABB[2] <= line2AABB[3] && // minY1 <= maxY2\n      line1AABB[3] >= line2AABB[2]; // maxY1 >= minY2\n\n    if (!aabbIntersects) {\n      return;\n    }\n\n    // Three tests are enough to know if the lines overlap\n    const overlap =\n      mathLine.isPointOnLineSegment(p1, q1, p2) ||\n      mathLine.isPointOnLineSegment(p1, q1, q2) ||\n      mathLine.isPointOnLineSegment(p2, q2, p1);\n\n    if (!overlap) {\n      return;\n    }\n\n    // min/max seems to be inverted but that is correct because it is looking\n    // for the intersection range. No Math.min/max calls for better performance.\n    const minX = line1AABB[0] > line2AABB[0] ? line1AABB[0] : line2AABB[0];\n    const maxX = line1AABB[1] < line2AABB[1] ? line1AABB[1] : line2AABB[1];\n    const minY = line1AABB[2] > line2AABB[2] ? line1AABB[2] : line2AABB[2];\n    const maxY = line1AABB[3] < line2AABB[3] ? line1AABB[3] : line2AABB[3];\n    const midX = (minX + maxX) * 0.5;\n    const midY = (minY + maxY) * 0.5;\n\n    return [midX, midY];\n  }\n\n  let a = p1[1] - p2[1];\n  let b = p1[0] - p2[0];\n  const numerator1 = diffQ2P2[0] * a - diffQ2P2[1] * b;\n  const numerator2 = diffQ1P1[0] * a - diffQ1P1[1] * b;\n  a = numerator1 / denominator;\n  b = numerator2 / denominator;\n\n  const resultX = p1[0] + a * diffQ1P1[0];\n  const resultY = p1[1] + a * diffQ1P1[1];\n\n  return [resultX, resultY];\n}\n","import { Types } from '@cornerstonejs/core';\nimport * as mathPoint from '../point';\nimport getLineSegmentIntersectionsIndexes from './getLineSegmentIntersectionsIndexes';\nimport containsPoint from './containsPoint';\nimport getNormal2 from './getNormal2';\nimport { glMatrix, vec3 } from 'gl-matrix';\nimport getLinesIntersection from './getLinesIntersection';\n\nenum PolylinePointType {\n  Vertex,\n  Intersection,\n}\n\n// Position of the point related to the intersection region\nenum PolylinePointPosition {\n  Outside = -1,\n  Edge = 0,\n  Inside = 1,\n}\n\n// Direction from last point to the intersection point to know if it is entering\n// or exiting the intersection region\nenum PolylinePointDirection {\n  Exiting = -1,\n  Unknown = 0,\n  Entering = 1,\n}\n\ntype PolylinePoint = {\n  type: PolylinePointType;\n  coordinates: Types.Point2;\n  position?: PolylinePointPosition;\n  visited: boolean;\n  next: PolylinePoint;\n};\n\ntype PolylineIntersectionPoint = PolylinePoint & {\n  direction: PolylinePointDirection;\n  cloned?: boolean;\n};\n\n/**\n * Ensure all polyline point objects are pointing to the next object in case\n * it is still not point to anyone.\n * @param polylinePoints - Array that contains all polyline points (vertices and intersections)\n */\nfunction ensuresNextPointers(polylinePoints: PolylinePoint[]) {\n  // Make sure all nodes point to a valid node\n  for (let i = 0, len = polylinePoints.length; i < len; i++) {\n    const currentPoint = polylinePoints[i];\n\n    if (!currentPoint.next) {\n      currentPoint.next = polylinePoints[i === len - 1 ? 0 : i + 1];\n    }\n  }\n}\n\n/**\n * Creates one linked list per polyline that contains all vertices and intersections\n * found while walking along the edges.\n *\n * @param targetPolyline - Target polyline\n * @param sourcePolyline - Source polyline\n * @returns Two linked lists with all vertices and intersections.\n */\nfunction getSourceAndTargetPointsList(\n  targetPolyline: Types.Point2[],\n  sourcePolyline: Types.Point2[]\n) {\n  const targetPolylinePoints: PolylinePoint[] = [];\n  const sourcePolylinePoints: PolylinePoint[] = [];\n  const sourceIntersectionsCache = new Map<\n    number,\n    PolylineIntersectionPoint[]\n  >();\n\n  const isFirstPointInside = containsPoint(sourcePolyline, targetPolyline[0]);\n\n  let intersectionPointDirection = isFirstPointInside\n    ? PolylinePointDirection.Exiting\n    : PolylinePointDirection.Entering;\n\n  // Store all vertices and intersection for target contour\n  for (let i = 0, len = targetPolyline.length; i < len; i++) {\n    const p1 = targetPolyline[i];\n    const pointInside = containsPoint(sourcePolyline, p1);\n    const vertexPoint: PolylinePoint = {\n      type: PolylinePointType.Vertex,\n      coordinates: p1,\n      position: pointInside\n        ? PolylinePointPosition.Inside\n        : PolylinePointPosition.Outside,\n      visited: false,\n      next: null,\n    };\n\n    targetPolylinePoints.push(vertexPoint);\n\n    const q1 = targetPolyline[i === len - 1 ? 0 : i + 1];\n    const intersectionsInfo = getLineSegmentIntersectionsIndexes(\n      sourcePolyline,\n      p1,\n      q1\n    ).map((intersectedLineSegment) => {\n      const sourceLineSegmentId: number = intersectedLineSegment[0];\n      const p2 = sourcePolyline[intersectedLineSegment[0]];\n      const q2 = sourcePolyline[intersectedLineSegment[1]];\n\n      // lineSegment.intersectLine returns the midpoint of the four points\n      // when the lines are parallel or co-incident.  Otherwise it will return\n      // an extension of the line.\n      const intersectionCoordinate = getLinesIntersection(\n        p1,\n        q1,\n        p2,\n        q2\n      ) as Types.Point2;\n\n      const targetStartPointDistSquared = mathPoint.distanceToPointSquared(\n        p1,\n        intersectionCoordinate\n      );\n\n      return {\n        sourceLineSegmentId,\n        coordinate: intersectionCoordinate,\n        targetStartPointDistSquared,\n      };\n    });\n\n    intersectionsInfo.sort(\n      (left, right) =>\n        left.targetStartPointDistSquared - right.targetStartPointDistSquared\n    );\n\n    intersectionsInfo.forEach((intersectionInfo) => {\n      const { sourceLineSegmentId, coordinate: intersectionCoordinate } =\n        intersectionInfo;\n\n      // Intersection point to be added to the target polyline list\n      const targetEdgePoint: PolylineIntersectionPoint = {\n        type: PolylinePointType.Intersection,\n        coordinates: intersectionCoordinate,\n        position: PolylinePointPosition.Edge,\n        direction: intersectionPointDirection,\n        visited: false,\n        next: null,\n      };\n\n      // Intersection point to be added to the source polyline list.\n      // At this point there is no way to know if the point is entering or\n      // exiting the intersection region but that is not going to be used\n      // hence it is set to \"unknown\".\n      const sourceEdgePoint: PolylineIntersectionPoint = {\n        ...targetEdgePoint,\n        direction: PolylinePointDirection.Unknown,\n        cloned: true,\n      };\n\n      if (intersectionPointDirection === PolylinePointDirection.Entering) {\n        targetEdgePoint.next = sourceEdgePoint;\n      } else {\n        sourceEdgePoint.next = targetEdgePoint;\n      }\n\n      let sourceIntersectionPoints =\n        sourceIntersectionsCache.get(sourceLineSegmentId);\n\n      if (!sourceIntersectionPoints) {\n        sourceIntersectionPoints = [];\n        sourceIntersectionsCache.set(\n          sourceLineSegmentId,\n          sourceIntersectionPoints\n        );\n      }\n\n      targetPolylinePoints.push(targetEdgePoint);\n      sourceIntersectionPoints.push(sourceEdgePoint);\n\n      // Switches from \"exiting\" to \"entering\" and vice-versa\n      intersectionPointDirection *= -1;\n    });\n  }\n\n  // Store all vertices and intersections for source contour\n  for (let i = 0, len = sourcePolyline.length; i < len; i++) {\n    const lineSegmentId: number = i;\n    const p1 = sourcePolyline[i];\n    const vertexPoint: PolylinePoint = {\n      type: PolylinePointType.Vertex,\n      coordinates: p1,\n      visited: false,\n      next: null,\n    };\n\n    sourcePolylinePoints.push(vertexPoint);\n\n    const sourceIntersectionPoints =\n      sourceIntersectionsCache.get(lineSegmentId);\n\n    if (!sourceIntersectionPoints?.length) {\n      continue;\n    }\n\n    // Calculate the distance between each intersection point to the start point\n    // of the line segment, sort them by distance and return a sorted array that\n    // contains all intersection points.\n    sourceIntersectionPoints\n      .map((intersectionPoint) => ({\n        intersectionPoint,\n        lineSegStartDistSquared: mathPoint.distanceToPointSquared(\n          p1,\n          intersectionPoint.coordinates\n        ),\n      }))\n      .sort(\n        (left, right) =>\n          left.lineSegStartDistSquared - right.lineSegStartDistSquared\n      )\n      .map(({ intersectionPoint }) => intersectionPoint)\n      .forEach((intersectionPoint) =>\n        sourcePolylinePoints.push(intersectionPoint)\n      );\n  }\n\n  ensuresNextPointers(targetPolylinePoints);\n  ensuresNextPointers(sourcePolylinePoints);\n\n  return { targetPolylinePoints, sourcePolylinePoints };\n}\n\n/**\n * Get the next unvisited polyline points that is outside the intersection region.\n * @param polylinePoints - All polyline points (vertices and intersections)\n * @returns Any unvisited point that is outside the intersection region if it\n * exists or `undefined` otherwise\n */\nfunction getUnvisitedOutsidePoint(polylinePoints: PolylinePoint[]) {\n  for (let i = 0, len = polylinePoints.length; i < len; i++) {\n    const point = polylinePoints[i];\n\n    if (!point.visited && point.position === PolylinePointPosition.Outside) {\n      return point;\n    }\n  }\n}\n\n/**\n * Merge two planar polylines (2D)\n */\nfunction mergePolylines(\n  targetPolyline: Types.Point2[],\n  sourcePolyline: Types.Point2[]\n) {\n  const targetNormal = getNormal2(targetPolyline);\n  const sourceNormal = getNormal2(sourcePolyline);\n  const dotNormals = vec3.dot(sourceNormal, targetNormal);\n\n  // Both polylines need to be CW or CCW to be merged and one of them needs to\n  // be reversed if theirs orientation are not the same\n  if (!glMatrix.equals(1, dotNormals)) {\n    sourcePolyline = sourcePolyline.slice().reverse();\n  }\n\n  const { targetPolylinePoints } = getSourceAndTargetPointsList(\n    targetPolyline,\n    sourcePolyline\n  );\n  const startPoint: PolylinePoint =\n    getUnvisitedOutsidePoint(targetPolylinePoints);\n\n  // Source polyline contains target polyline\n  if (!startPoint) {\n    return targetPolyline.slice();\n  }\n\n  const mergedPolyline = [startPoint.coordinates];\n  let currentPoint = startPoint.next;\n\n  while (currentPoint !== startPoint) {\n    if (\n      currentPoint.type === PolylinePointType.Intersection &&\n      (<PolylineIntersectionPoint>currentPoint).cloned\n    ) {\n      currentPoint = currentPoint.next;\n      continue;\n    }\n\n    mergedPolyline.push(currentPoint.coordinates);\n    currentPoint = currentPoint.next;\n  }\n\n  return mergedPolyline;\n}\n\n/**\n * Subtract two planar polylines (2D)\n */\nfunction subtractPolylines(\n  targetPolyline: Types.Point2[],\n  sourcePolyline: Types.Point2[]\n): Types.Point2[][] {\n  const targetNormal = getNormal2(targetPolyline);\n  const sourceNormal = getNormal2(sourcePolyline);\n  const dotNormals = vec3.dot(sourceNormal, targetNormal);\n\n  // The polylines need to have different orientation (CW+CCW or CCW+CW) to be\n  // subtracted and one of them needs to be reversed if theirs orientation are\n  // the same\n  if (!glMatrix.equals(-1, dotNormals)) {\n    sourcePolyline = sourcePolyline.slice().reverse();\n  }\n\n  const { targetPolylinePoints } = getSourceAndTargetPointsList(\n    targetPolyline,\n    sourcePolyline\n  );\n  let startPoint: PolylinePoint = null;\n  const subtractedPolylines = [];\n\n  while ((startPoint = getUnvisitedOutsidePoint(targetPolylinePoints))) {\n    const subtractedPolyline = [startPoint.coordinates];\n    let currentPoint = startPoint.next;\n\n    startPoint.visited = true;\n\n    while (currentPoint !== startPoint) {\n      currentPoint.visited = true;\n\n      if (\n        currentPoint.type === PolylinePointType.Intersection &&\n        (<PolylineIntersectionPoint>currentPoint).cloned\n      ) {\n        currentPoint = currentPoint.next;\n        continue;\n      }\n\n      subtractedPolyline.push(currentPoint.coordinates);\n      currentPoint = currentPoint.next;\n    }\n\n    subtractedPolylines.push(subtractedPolyline);\n  }\n\n  return subtractedPolylines;\n}\n\nexport { mergePolylines, subtractPolylines };\n","import type { Types } from '@cornerstonejs/core';\nimport areLineSegmentsIntersecting from './areLineSegmentsIntersecting';\n\n/**\n * Checks whether the line (`p1`,`q1`) intersects any of the other lines in the\n * `points`, and returns the first value.\n *\n * @param points - Polyline points\n * @param p1 - First point of the line segment that is being tested\n * @param q1 - Second point of the line segment that is being tested\n * @param closed - Test the intersection with the line segment that connects\n *   the last and first points of the polyline\n * @returns Indexes of the line segment points from the polyline that intersects [p1, q1]\n */\nexport default function getFirstLineSegmentIntersectionIndexes(\n  points: Types.Point2[],\n  p1: Types.Point2,\n  q1: Types.Point2,\n  closed = true\n): Types.Point2 | undefined {\n  let initialI;\n  let j;\n\n  if (closed) {\n    j = points.length - 1;\n    initialI = 0;\n  } else {\n    j = 0;\n    initialI = 1;\n  }\n\n  for (let i = initialI; i < points.length; i++) {\n    const p2 = points[j];\n    const q2 = points[i];\n\n    if (areLineSegmentsIntersecting(p1, q1, p2, q2)) {\n      return [j, i];\n    }\n\n    j = i;\n  }\n}\n","import { Types } from '@cornerstonejs/core';\nimport getFirstLineSegmentIntersectionIndexes from './getFirstLineSegmentIntersectionIndexes';\n\n/**\n * Check if two polylines intersect comparing line segment by line segment.\n * @param sourcePolyline - Source polyline\n * @param targetPolyline - Target polyline\n * @returns True if the polylines intersect or false otherwise\n */\nexport default function intersectPolyline(\n  sourcePolyline: Types.Point2[],\n  targetPolyline: Types.Point2[]\n): boolean {\n  // Naive way to detect intersection between polylines in O(n^2).\n  // TODO: Implement Bentley Ottmann sweep line algorithm or maybe some\n  // algorithm that uses r-tree may make it run faster\n  for (let i = 0, sourceLen = sourcePolyline.length; i < sourceLen; i++) {\n    const sourceP1 = sourcePolyline[i];\n    const sourceP2Index = i === sourceLen - 1 ? 0 : i + 1;\n    const sourceP2 = sourcePolyline[sourceP2Index];\n\n    const intersectionPointIndexes = getFirstLineSegmentIntersectionIndexes(\n      targetPolyline,\n      sourceP1,\n      sourceP2\n    );\n\n    if (intersectionPointIndexes?.length === 2) {\n      return true;\n    }\n  }\n\n  return false;\n}\n","import type { Types } from '@cornerstonejs/core';\nimport * as mathLine from '../line';\n\nconst DEFAULT_EPSILON = 0.1;\n\n/**\n * Ramer–Douglas–Peucker algorithm implementation to decimate a polyline\n * to a similar polyline with fewer points\n *\n * https://en.wikipedia.org/wiki/Ramer%E2%80%93Douglas%E2%80%93Peucker_algorithm\n * https://rosettacode.org/wiki/Ramer-Douglas-Peucker_line_simplification\n * https://karthaus.nl/rdp/\n *\n * @param polyline - Polyline to decimate\n * @param epsilon - A maximum given distance 'epsilon' to decide if a point\n * should or shouldn't be added the decimated polyline version. In each\n * iteration the polyline is split into two polylines and the distance of each\n * point from those new polylines are checked against the line that connects\n * the first and last points.\n * @returns Decimated polyline\n */\nexport default function decimate(\n  polyline: Types.Point2[],\n  epsilon = DEFAULT_EPSILON\n) {\n  const numPoints = polyline.length;\n\n  // The polyline must have at least a start and end points\n  if (numPoints < 3) {\n    return polyline;\n  }\n\n  const epsilonSquared = epsilon * epsilon;\n  const partitionQueue = [[0, numPoints - 1]];\n\n  // Used a boolean array to set each point that will be in the decimated polyline\n  // because pre-allocated arrays are 3-4x faster than thousands of push() calls\n  // to add all points to a new array.\n  const polylinePointFlags = new Array(numPoints).fill(false);\n\n  // Start and end points are always added to the decimated polyline\n  let numDecimatedPoints = 2;\n\n  // Add start and end points to the decimated polyline\n  polylinePointFlags[0] = true;\n  polylinePointFlags[numPoints - 1] = true;\n\n  // Iterative approach using a queue instead of recursion to reduce the number\n  // of function calls (performance)\n  while (partitionQueue.length) {\n    const [startIndex, endIndex] = partitionQueue.pop();\n\n    // Return if there is no point between the start and end points\n    if (endIndex - startIndex === 1) {\n      continue;\n    }\n\n    const startPoint = polyline[startIndex];\n    const endPoint = polyline[endIndex];\n    let maxDistSquared = -Infinity;\n    let maxDistIndex = -1;\n\n    // Search for the furthest point\n    for (let i = startIndex + 1; i < endIndex; i++) {\n      const currentPoint = polyline[i];\n      const distSquared = mathLine.distanceToPointSquared(\n        startPoint,\n        endPoint,\n        currentPoint\n      );\n\n      if (distSquared > maxDistSquared) {\n        maxDistSquared = distSquared;\n        maxDistIndex = i;\n      }\n    }\n\n    // Do not add any of the points because the fursthest one is very close to\n    // the line based on the epsilon value\n    if (maxDistSquared < epsilonSquared) {\n      continue;\n    }\n\n    // Update the flag for the furthest point because it will be added to the\n    // decimated polyline\n    polylinePointFlags[maxDistIndex] = true;\n    numDecimatedPoints++;\n\n    // Partition the points into two parts using maxDistIndex as the pivot point\n    // and process both sides\n    partitionQueue.push([maxDistIndex, endIndex]);\n    partitionQueue.push([startIndex, maxDistIndex]);\n  }\n\n  // A pre-allocated array is 3-4x faster then multiple push() calls\n  const decimatedPolyline: Types.Point2[] = new Array(numDecimatedPoints);\n\n  for (let srcIndex = 0, dstIndex = 0; srcIndex < numPoints; srcIndex++) {\n    if (polylinePointFlags[srcIndex]) {\n      decimatedPolyline[dstIndex++] = polyline[srcIndex];\n    }\n  }\n\n  return decimatedPolyline;\n}\n","import type { Types } from '@cornerstonejs/core';\nimport getLineSegmentIntersectionsIndexes from './getLineSegmentIntersectionsIndexes';\nimport getLinesIntersection from './getLinesIntersection';\n\n/**\n * Returns all intersections points between a line segment and a polyline\n */\nexport default function getLineSegmentIntersectionsCoordinates(\n  points: Types.Point2[],\n  p1: Types.Point2,\n  q1: Types.Point2,\n  closed = true\n): Types.Point2[] {\n  const result = [];\n  const polylineIndexes = getLineSegmentIntersectionsIndexes(\n    points,\n    p1,\n    q1,\n    closed\n  );\n\n  for (let i = 0; i < polylineIndexes.length; i++) {\n    const p2 = points[polylineIndexes[i][0]];\n    const q2 = points[polylineIndexes[i][1]];\n    const intersection = getLinesIntersection(p1, q1, p2, q2);\n    result.push(intersection);\n  }\n\n  return result;\n}\n","import { vec2 } from 'gl-matrix';\nimport type { Types } from '@cornerstonejs/core';\nimport areLineSegmentsIntersecting from './areLineSegmentsIntersecting';\n\n/**\n * Checks whether the line (`p1`,`q1`) intersects any of the other lines in the\n * `points`, and returns the closest value.\n * @param points - Polyline points\n * @param p1 - Start point of the line segment\n * @param q1 - End point of the line segment\n * @param closed - Test the intersection against the line that connects the first to the last when closed\n * @returns The closest line segment from polyline that intersects the line segment [p1, q1]\n */\nexport default function getClosestLineSegmentIntersection(\n  points: Types.Point2[],\n  p1: Types.Point2,\n  q1: Types.Point2,\n  closed = true\n): { segment: Types.Point2; distance: number } | undefined {\n  let initialQ2Index;\n  let p2Index;\n\n  if (closed) {\n    p2Index = points.length - 1;\n    initialQ2Index = 0;\n  } else {\n    p2Index = 0;\n    initialQ2Index = 1;\n  }\n\n  const intersections = [];\n\n  for (let q2Index = initialQ2Index; q2Index < points.length; q2Index++) {\n    const p2 = points[p2Index];\n    const q2 = points[q2Index];\n\n    if (areLineSegmentsIntersecting(p1, q1, p2, q2)) {\n      intersections.push([p2Index, q2Index]);\n    }\n\n    p2Index = q2Index;\n  }\n\n  if (intersections.length === 0) {\n    return;\n  }\n\n  // Find intersection closest to the start point\n  const distances = [];\n\n  intersections.forEach((intersection) => {\n    const intersectionPoints = [\n      points[intersection[0]],\n      points[intersection[1]],\n    ];\n\n    const midpoint = [\n      (intersectionPoints[0][0] + intersectionPoints[1][0]) / 2,\n      (intersectionPoints[0][1] + intersectionPoints[1][1]) / 2,\n    ];\n\n    distances.push(vec2.distance(<vec2>midpoint, p1));\n  });\n\n  const minDistance = Math.min(...distances);\n  const indexOfMinDistance = distances.indexOf(minDistance);\n\n  return {\n    segment: intersections[indexOfMinDistance],\n    distance: minDistance,\n  };\n}\n","import { StackViewport } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\nimport { vec3 } from 'gl-matrix';\n\nconst EPSILON = 1e-3;\n\n/**\n * Gets the desired spacing for points in the polyline for the\n * `PlanarFreehandROITool` in the x and y canvas directions, as well as\n * returning these canvas directions in world space.\n *\n * @param viewport - The Cornerstone3D `StackViewport` or `VolumeViewport`.\n * @param subPixelResolution - The number to divide the image pixel spacing by\n * to get the sub pixel spacing. E.g. `10` will return spacings 10x smaller than\n * the native image spacing.\n * @returns The spacings of the X and Y directions, and the 3D directions of the\n * x and y directions.\n */\nconst getSubPixelSpacingAndXYDirections = (\n  viewport: Types.IStackViewport | Types.IVolumeViewport,\n  subPixelResolution: number\n): { spacing: Types.Point2; xDir: Types.Point3; yDir: Types.Point3 } => {\n  let spacing;\n  let xDir;\n  let yDir;\n\n  if (viewport instanceof StackViewport) {\n    // Check XY directions\n    const imageData = viewport.getImageData();\n\n    xDir = imageData.direction.slice(0, 3);\n    yDir = imageData.direction.slice(3, 6);\n\n    spacing = imageData.spacing;\n  } else {\n    // Check volume directions\n    const imageData = viewport.getImageData();\n    const { direction, spacing: volumeSpacing } = imageData;\n    const { viewPlaneNormal, viewUp } = viewport.getCamera();\n\n    // Calculate size of spacing vector in normal direction\n    const iVector = direction.slice(0, 3) as Types.Point3;\n    const jVector = direction.slice(3, 6) as Types.Point3;\n    const kVector = direction.slice(6, 9) as Types.Point3;\n\n    const viewRight = vec3.create(); // Get the X direction of the viewport\n\n    vec3.cross(viewRight, <vec3>viewUp, <vec3>viewPlaneNormal);\n\n    const absViewRightDotI = Math.abs(vec3.dot(viewRight, iVector));\n    const absViewRightDotJ = Math.abs(vec3.dot(viewRight, jVector));\n    const absViewRightDotK = Math.abs(vec3.dot(viewRight, kVector));\n\n    // Get X spacing\n    let xSpacing;\n    if (Math.abs(1 - absViewRightDotI) < EPSILON) {\n      xSpacing = volumeSpacing[0];\n      xDir = iVector;\n    } else if (Math.abs(1 - absViewRightDotJ) < EPSILON) {\n      xSpacing = volumeSpacing[1];\n      xDir = jVector;\n    } else if (Math.abs(1 - absViewRightDotK) < EPSILON) {\n      xSpacing = volumeSpacing[2];\n      xDir = kVector;\n    } else {\n      throw new Error('No support yet for oblique plane planar contours');\n    }\n\n    const absViewUpDotI = Math.abs(vec3.dot(viewUp, iVector));\n    const absViewUpDotJ = Math.abs(vec3.dot(viewUp, jVector));\n    const absViewUpDotK = Math.abs(vec3.dot(viewUp, kVector));\n\n    // Get Y spacing\n    let ySpacing;\n    if (Math.abs(1 - absViewUpDotI) < EPSILON) {\n      ySpacing = volumeSpacing[0];\n      yDir = iVector;\n    } else if (Math.abs(1 - absViewUpDotJ) < EPSILON) {\n      ySpacing = volumeSpacing[1];\n      yDir = jVector;\n    } else if (Math.abs(1 - absViewUpDotK) < EPSILON) {\n      ySpacing = volumeSpacing[2];\n      yDir = kVector;\n    } else {\n      throw new Error('No support yet for oblique plane planar contours');\n    }\n\n    spacing = [xSpacing, ySpacing];\n  }\n\n  const subPixelSpacing: Types.Point2 = [\n    spacing[0] / subPixelResolution,\n    spacing[1] / subPixelResolution,\n  ];\n\n  return { spacing: subPixelSpacing, xDir, yDir };\n};\n\nexport default getSubPixelSpacingAndXYDirections;\n","import { vec2 } from 'gl-matrix';\nimport type { Types } from '@cornerstonejs/core';\n\n/**\n * Returns true if points `p1` and `p2` are within `closeContourProximity`.\n */\nconst pointsAreWithinCloseContourProximity = (\n  p1: Types.Point2,\n  p2: Types.Point2,\n  closeContourProximity: number\n): boolean => {\n  return vec2.dist(p1, p2) < closeContourProximity;\n};\n\nexport default pointsAreWithinCloseContourProximity;\n","import { getEnabledElement } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\nimport { vec2, vec3 } from 'gl-matrix';\nimport { PlanarFreehandROICommonData } from './planarFreehandROIInternalTypes';\n\n/**\n * Adds one or more points to the array at a resolution defined by the underlying image.\n */\nconst addCanvasPointsToArray = (\n  element: HTMLDivElement,\n  canvasPoints: Types.Point2[],\n  newCanvasPoint: Types.Point2,\n  commonData: PlanarFreehandROICommonData\n): number => {\n  const { xDir, yDir, spacing } = commonData;\n  const enabledElement = getEnabledElement(element);\n  const { viewport } = enabledElement;\n\n  if (!canvasPoints.length) {\n    canvasPoints.push(newCanvasPoint);\n    console.log('>>>>> !canvasPoints. :: RETURN');\n    return 1;\n  }\n\n  const lastWorldPos = viewport.canvasToWorld(\n    canvasPoints[canvasPoints.length - 1]\n  );\n  const newWorldPos = viewport.canvasToWorld(newCanvasPoint);\n  const worldPosDiff = vec3.create();\n\n  vec3.subtract(worldPosDiff, newWorldPos, lastWorldPos);\n\n  const xDist = Math.abs(vec3.dot(worldPosDiff, xDir));\n  const yDist = Math.abs(vec3.dot(worldPosDiff, yDir));\n\n  const numPointsToAdd = Math.max(\n    Math.floor(xDist / spacing[0]),\n    Math.floor(yDist / spacing[0])\n  );\n\n  if (numPointsToAdd > 1) {\n    const lastCanvasPoint = canvasPoints[canvasPoints.length - 1];\n\n    const canvasDist = vec2.dist(lastCanvasPoint, newCanvasPoint);\n\n    const canvasDir = vec2.create();\n\n    vec2.subtract(canvasDir, newCanvasPoint, lastCanvasPoint);\n\n    vec2.set(canvasDir, canvasDir[0] / canvasDist, canvasDir[1] / canvasDist);\n\n    const distPerPoint = canvasDist / numPointsToAdd;\n\n    for (let i = 1; i <= numPointsToAdd; i++) {\n      canvasPoints.push([\n        lastCanvasPoint[0] + distPerPoint * canvasDir[0] * i,\n        lastCanvasPoint[1] + distPerPoint * canvasDir[1] * i,\n      ]);\n    }\n  } else {\n    canvasPoints.push(newCanvasPoint);\n  }\n\n  return numPointsToAdd;\n};\n\nexport default addCanvasPointsToArray;\n","import type { Types } from '@cornerstonejs/core';\nimport { vec2 } from 'gl-matrix';\n\n/**\n * Returns `true` if the point `p` can project onto point (`p1`, `p2`), and if\n * this projected point is less than `proximity` units away.\n */\nconst pointCanProjectOnLine = (\n  p: Types.Point2,\n  p1: Types.Point2,\n  p2: Types.Point2,\n  proximity: number\n): boolean => {\n  // Perfom checks in order of computational complexity.\n  const p1p = [p[0] - p1[0], p[1] - p1[1]];\n  const p1p2 = [p2[0] - p1[0], p2[1] - p1[1]];\n\n  const dot = p1p[0] * p1p2[0] + p1p[1] * p1p2[1];\n\n  // Dot product needs to be positive to be a candidate for projection onto line segment.\n  if (dot < 0) {\n    return false;\n  }\n\n  const p1p2Mag = Math.sqrt(p1p2[0] * p1p2[0] + p1p2[1] * p1p2[1]);\n\n  if (p1p2Mag === 0) {\n    return false;\n  }\n\n  const projectionVectorMag = dot / p1p2Mag;\n  const p1p2UnitVector = [p1p2[0] / p1p2Mag, p1p2[1] / p1p2Mag];\n  const projectionVector = [\n    p1p2UnitVector[0] * projectionVectorMag,\n    p1p2UnitVector[1] * projectionVectorMag,\n  ];\n  const projectionPoint = <Types.Point2>[\n    p1[0] + projectionVector[0],\n    p1[1] + projectionVector[1],\n  ];\n\n  const distance = vec2.distance(p, projectionPoint);\n\n  if (distance > proximity) {\n    // point is too far away.\n    return false;\n  }\n\n  // Check projects onto line segment.\n  if (vec2.distance(p1, projectionPoint) > vec2.distance(p1, p2)) {\n    return false;\n  }\n\n  return true;\n};\n\nexport default pointCanProjectOnLine;\n","import { utilities } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nconst epsilon = 1e-6;\n\n/**\n * Projects a polyline from 3D to 2D by reducing one dimension.\n *\n * @param polyline - The polyline to be projected.\n * @returns An object containing the shared dimension index and the projected polyline in 2D.\n * @throws Error if a shared dimension index cannot be found for the polyline.\n */\nexport function projectTo2D(polyline: Types.Point3[]) {\n  // We need to reduce one dimension to 2D, so basically\n  // we need to find the dimension index that is shared by all points\n  // Use the first three points, two is enough but three is more robust\n  let sharedDimensionIndex;\n\n  const testPoints = utilities.getRandomSampleFromArray(polyline, 50);\n\n  for (let i = 0; i < 3; i++) {\n    if (\n      testPoints.every(\n        (point, index, array) => Math.abs(point[i] - array[0][i]) < epsilon\n      )\n    ) {\n      sharedDimensionIndex = i;\n      break;\n    }\n  }\n\n  if (sharedDimensionIndex === undefined) {\n    throw new Error(\n      'Cannot find a shared dimension index for polyline, probably oblique plane'\n    );\n  }\n\n  // convert polyline list and point to 2D\n  const points2D = [] as Types.Point2[];\n\n  const firstDim = (sharedDimensionIndex + 1) % 3;\n  const secondDim = (sharedDimensionIndex + 2) % 3;\n\n  for (let i = 0; i < polyline.length; i++) {\n    points2D.push([polyline[i][firstDim], polyline[i][secondDim]]);\n  }\n\n  return {\n    sharedDimensionIndex,\n    projectedPolyline: points2D,\n  };\n}\n","import type { Types } from '@cornerstonejs/core';\nimport containsPoint from './containsPoint';\nimport { projectTo2D } from './projectTo2D';\n\n/**\n * Determines whether a 3D point is inside a polyline in 3D space.\n *\n * The algorithm works by reducing the polyline and point to 2D space, and then\n * using the 2D algorithm to determine whether the point is inside the polyline.\n *\n * @param point - The 3D point to test.\n * @param polyline - The polyline represented as an array of 3D points.\n * @param options.holesPolyline - An array of polylines representing each hole, so it\n * is an array of arrays of 3D points.\n * @returns A boolean indicating whether the point is inside the polyline.\n * @throws An error if a shared dimension index cannot be found for the polyline points.\n */\nexport function isPointInsidePolyline3D(\n  point: Types.Point3,\n  polyline: Types.Point3[],\n  options: { holes?: Types.Point3[][] } = {}\n) {\n  const { sharedDimensionIndex, projectedPolyline } = projectTo2D(polyline);\n\n  const { holes } = options;\n  const projectedHoles = [] as Types.Point2[][];\n\n  if (holes) {\n    for (let i = 0; i < holes.length; i++) {\n      const hole = holes[i];\n      const hole2D = [] as Types.Point2[];\n\n      for (let j = 0; j < hole.length; j++) {\n        hole2D.push([\n          hole[j][(sharedDimensionIndex + 1) % 3],\n          hole[j][(sharedDimensionIndex + 2) % 3],\n        ]);\n      }\n\n      projectedHoles.push(hole2D);\n    }\n  }\n\n  const point2D = [\n    point[(sharedDimensionIndex + 1) % 3],\n    point[(sharedDimensionIndex + 2) % 3],\n  ] as Types.Point2;\n\n  return containsPoint(projectedPolyline, point2D, { holes: projectedHoles });\n}\n","import type { Types } from '@cornerstonejs/core';\nimport * as lineSegment from '../line';\n\ntype rectLineSegments = {\n  top: Types.Point2[];\n  right: Types.Point2[];\n  bottom: Types.Point2[];\n  left: Types.Point2[];\n};\n\n/**\n * Given a rectangle left, top, width and height, return an object containing the\n * line segments that make up the rectangle's four sides\n * @param left - The x-coordinate of the left edge of the rectangle.\n * @param top - The y-coordinate of the top edge of the rectangle.\n * @param width - The width of the rectangle.\n * @param height - The height of the rectangle.\n * @returns An object with four keys, each of which contains an array of two\n * points.\n */\nfunction rectToLineSegments(\n  left: number,\n  top: number,\n  width: number,\n  height: number\n): rectLineSegments {\n  const topLineStart: Types.Point2 = [left, top];\n  const topLineEnd: Types.Point2 = [left + width, top];\n\n  const rightLineStart: Types.Point2 = [left + width, top];\n  const rightLineEnd: Types.Point2 = [left + width, top + height];\n\n  const bottomLineStart: Types.Point2 = [left + width, top + height];\n  const bottomLineEnd: Types.Point2 = [left, top + height];\n\n  const leftLineStart: Types.Point2 = [left, top + height];\n  const leftLineEnd: Types.Point2 = [left, top];\n\n  const lineSegments = {\n    top: [topLineStart, topLineEnd],\n    right: [rightLineStart, rightLineEnd],\n    bottom: [bottomLineStart, bottomLineEnd],\n    left: [leftLineStart, leftLineEnd],\n  };\n\n  return lineSegments;\n}\n\n/**\n * Calculates distance of the point to the rectangle. It calculates the minimum\n * distance between the point and each line segment of the rectangle.\n *\n * @param rect - coordinates of the rectangle [left, top, width, height]\n * @param point - [x,y] coordinates of a point\n * @returns\n */\nexport default function distanceToPoint(\n  rect: number[],\n  point: Types.Point2\n): number {\n  if (rect.length !== 4 || point.length !== 2) {\n    throw Error(\n      'rectangle:[left, top, width, height] or point: [x,y] not defined correctly'\n    );\n  }\n\n  const [left, top, width, height] = rect;\n\n  let minDistance = 655535;\n  const lineSegments = rectToLineSegments(left, top, width, height);\n\n  Object.keys(lineSegments).forEach((segment) => {\n    const [lineStart, lineEnd] = lineSegments[segment];\n    const distance = lineSegment.distanceToPoint(lineStart, lineEnd, point);\n\n    if (distance < minDistance) {\n      minDistance = distance;\n    }\n  });\n\n  return minDistance;\n}\n","import type { Types } from '@cornerstonejs/core';\nimport { vec3 } from 'gl-matrix';\n\ntype Sphere = {\n  center: Types.Point3 | vec3;\n  radius: number;\n  // Square of the radius\n  radius2?: number;\n};\n\n/**\n * Checks if a point is inside a sphere. Note: this is similar to the\n * `pointInEllipse` function, but since we don't need checks for the\n * ellipse's rotation in different views, we can use a simpler equation\n * which would be faster (no if statements).\n *\n * This is safe to call for point in circle as long as you don't call it with\n * anything off-plane - that is, a circle is a degenerate sphere that is\n * intersected with the primary plane.\n *\n * @param sphere - Sphere object with center and radius and radius squared\n *     as radius2 if you are calling this a huge number of times.\n * @param pointLPS - the point to check in world coordinates\n * @returns boolean\n */\nexport default function pointInSphere(sphere: Sphere, pointLPS: vec3): boolean {\n  const { center, radius } = sphere;\n  const radius2 = sphere.radius2 || radius * radius;\n\n  return (\n    (pointLPS[0] - center[0]) * (pointLPS[0] - center[0]) +\n      (pointLPS[1] - center[1]) * (pointLPS[1] - center[1]) +\n      (pointLPS[2] - center[2]) * (pointLPS[2] - center[2]) <=\n    radius2\n  );\n}\n","// Pulled from source: https://github.com/w8r/liang-barsky\n// MIT Licensed.\n\n/**\n * Fast, destructive implementation of Liang-Barsky line clipping algorithm.\n * It clips a 2D segment by a rectangle.\n * @author Alexander Milevski <info@w8r.name>\n * @license MIT\n */\n\nconst EPSILON = 1e-6;\nconst INSIDE = 1;\nconst OUTSIDE = 0;\n\nfunction clipT(num, denom, c) {\n  const [tE, tL] = c;\n  if (Math.abs(denom) < EPSILON) {\n    return num < 0;\n  }\n  const t = num / denom;\n\n  if (denom > 0) {\n    if (t > tL) {\n      return 0;\n    }\n    if (t > tE) {\n      c[0] = t;\n    }\n  } else {\n    if (t < tE) {\n      return 0;\n    }\n    if (t < tL) {\n      c[1] = t;\n    }\n  }\n  return 1;\n}\n\n/**\n * @param  {Point} a\n * @param  {Point} b\n * @param  {BoundingBox} box [xmin, ymin, xmax, ymax]\n * @param  {Point?} [da]\n * @param  {Point?} [db]\n * @return {number}\n */\nexport default function clip(a, b, box, da?, db?) {\n  const [x1, y1] = a;\n  const [x2, y2] = b;\n  const dx = x2 - x1;\n  const dy = y2 - y1;\n\n  if (da === undefined || db === undefined) {\n    da = a;\n    db = b;\n  } else {\n    da[0] = a[0];\n    da[1] = a[1];\n    db[0] = b[0];\n    db[1] = b[1];\n  }\n\n  if (\n    Math.abs(dx) < EPSILON &&\n    Math.abs(dy) < EPSILON &&\n    x1 >= box[0] &&\n    x1 <= box[2] &&\n    y1 >= box[1] &&\n    y1 <= box[3]\n  ) {\n    return INSIDE;\n  }\n\n  const c = [0, 1];\n  if (\n    clipT(box[0] - x1, dx, c) &&\n    clipT(x1 - box[2], -dx, c) &&\n    clipT(box[1] - y1, dy, c) &&\n    clipT(y1 - box[3], -dy, c)\n  ) {\n    const [tE, tL] = c;\n    if (tL < 1) {\n      db[0] = x1 + tL * dx;\n      db[1] = y1 + tL * dy;\n    }\n    if (tE > 0) {\n      da[0] += tE * dx;\n      da[1] += tE * dy;\n    }\n    return INSIDE;\n  }\n  return OUTSIDE;\n}\n","import filterAnnotationsWithinSlice from './filterAnnotationsWithinSlice';\nimport getWorldWidthAndHeightFromCorners from './getWorldWidthAndHeightFromCorners';\nimport filterAnnotationsForDisplay from './filterAnnotationsForDisplay';\nimport getPointInLineOfSightWithCriteria from './getPointInLineOfSightWithCriteria';\nimport { isPlaneIntersectingAABB } from './isPlaneIntersectingAABB';\n\nexport default {\n  filterAnnotationsWithinSlice,\n  getWorldWidthAndHeightFromCorners,\n  filterAnnotationsForDisplay,\n  getPointInLineOfSightWithCriteria,\n  isPlaneIntersectingAABB,\n};\n\nexport {\n  filterAnnotationsWithinSlice,\n  getWorldWidthAndHeightFromCorners,\n  filterAnnotationsForDisplay,\n  getPointInLineOfSightWithCriteria,\n  isPlaneIntersectingAABB,\n};\n","import smoothAnnotation from './smoothAnnotation';\n\nexport default {\n  smoothAnnotation,\n};\n\nexport { smoothAnnotation };\n","import { vec3 } from 'gl-matrix';\nimport type { Types } from '@cornerstonejs/core';\nimport type { vtkImageData } from '@kitware/vtk.js/Common/DataModel/ImageData';\nimport BoundsIJK from '../types/BoundsIJK';\n\nexport type PointInShape = {\n  value: number;\n  index: number;\n  pointIJK: vec3;\n  pointLPS: vec3 | number[];\n};\n\nexport type PointInShapeCallback = ({\n  value,\n  index,\n  pointIJK,\n  pointLPS,\n}: {\n  value: number;\n  index: number;\n  pointIJK: vec3;\n  pointLPS: vec3;\n}) => void;\n\nexport type ShapeFnCriteria = (pointLPS: vec3, pointIJK: vec3) => boolean;\n\n/**\n * For each point in the image (If boundsIJK is not provided, otherwise, for each\n * point in the provided bounding box), It runs the provided callback IF the point\n * passes the provided criteria to be inside the shape (which is defined by the\n * provided pointInShapeFn)\n *\n * @param imageData - The image data object.\n * @param dimensions - The dimensions of the image.\n * @param pointInShapeFn - A function that takes a point in LPS space and returns\n * true if the point is in the shape and false if it is not.\n * @param callback - A function that will be called for\n * every point in the shape.\n * @param boundsIJK - The bounds of the volume in IJK coordinates.\n */\nexport default function pointInShapeCallback(\n  imageData: vtkImageData | Types.CPUImageData,\n  pointInShapeFn: ShapeFnCriteria,\n  callback?: PointInShapeCallback,\n  boundsIJK?: BoundsIJK\n): Array<PointInShape> {\n  let iMin, iMax, jMin, jMax, kMin, kMax;\n\n  let scalarData;\n  const { numComps } = imageData as any;\n\n  // if getScalarData is a method on imageData\n  if ((imageData as Types.CPUImageData).getScalarData) {\n    scalarData = (imageData as Types.CPUImageData).getScalarData();\n  } else {\n    scalarData = (imageData as vtkImageData)\n      .getPointData()\n      .getScalars()\n      .getData();\n  }\n\n  const dimensions = imageData.getDimensions();\n\n  if (!boundsIJK) {\n    iMin = 0;\n    iMax = dimensions[0];\n    jMin = 0;\n    jMax = dimensions[1];\n    kMin = 0;\n    kMax = dimensions[2];\n  } else {\n    [[iMin, iMax], [jMin, jMax], [kMin, kMax]] = boundsIJK;\n  }\n\n  const start = vec3.fromValues(iMin, jMin, kMin);\n\n  const direction = imageData.getDirection();\n  const rowCosines = direction.slice(0, 3);\n  const columnCosines = direction.slice(3, 6);\n  const scanAxisNormal = direction.slice(6, 9);\n\n  const spacing = imageData.getSpacing();\n  const [rowSpacing, columnSpacing, scanAxisSpacing] = spacing;\n\n  // @ts-ignore will be fixed in vtk-master\n  const worldPosStart = imageData.indexToWorld(start);\n\n  const rowStep = vec3.fromValues(\n    rowCosines[0] * rowSpacing,\n    rowCosines[1] * rowSpacing,\n    rowCosines[2] * rowSpacing\n  );\n\n  const columnStep = vec3.fromValues(\n    columnCosines[0] * columnSpacing,\n    columnCosines[1] * columnSpacing,\n    columnCosines[2] * columnSpacing\n  );\n\n  const scanAxisStep = vec3.fromValues(\n    scanAxisNormal[0] * scanAxisSpacing,\n    scanAxisNormal[1] * scanAxisSpacing,\n    scanAxisNormal[2] * scanAxisSpacing\n  );\n\n  const xMultiple =\n    numComps ||\n    scalarData.length / dimensions[2] / dimensions[1] / dimensions[0];\n  const yMultiple = dimensions[0] * xMultiple;\n  const zMultiple = dimensions[1] * yMultiple;\n\n  const pointsInShape: Array<PointInShape> = [];\n\n  const currentPos = vec3.clone(worldPosStart);\n\n  for (let k = kMin; k <= kMax; k++) {\n    const startPosJ = vec3.clone(currentPos);\n\n    for (let j = jMin; j <= jMax; j++) {\n      const startPosI = vec3.clone(currentPos);\n\n      for (let i = iMin; i <= iMax; i++) {\n        const pointIJK: Types.Point3 = [i, j, k];\n\n        // The current world position (pointLPS) is now in currentPos\n        if (pointInShapeFn(currentPos as Types.Point3, pointIJK)) {\n          const index = k * zMultiple + j * yMultiple + i * xMultiple;\n          let value;\n          if (xMultiple > 2) {\n            value = [\n              scalarData[index],\n              scalarData[index + 1],\n              scalarData[index + 2],\n            ];\n          } else {\n            value = scalarData[index];\n          }\n\n          pointsInShape.push({\n            value,\n            index,\n            pointIJK,\n            pointLPS: currentPos.slice(),\n          });\n          if (callback) {\n            callback({ value, index, pointIJK, pointLPS: currentPos });\n          }\n        }\n\n        // Increment currentPos by rowStep for the next iteration\n        vec3.add(currentPos, currentPos, rowStep);\n      }\n\n      // Reset currentPos to the start of the next J line and increment by columnStep\n      vec3.copy(currentPos, startPosI);\n      vec3.add(currentPos, currentPos, columnStep);\n    }\n\n    // Reset currentPos to the start of the next K slice and increment by scanAxisStep\n    vec3.copy(currentPos, startPosJ);\n    vec3.add(currentPos, currentPos, scanAxisStep);\n  }\n\n  return pointsInShape;\n}\n","import { utilities as csUtils } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport type { vtkImageData } from '@kitware/vtk.js/Common/DataModel/ImageData';\nimport { vec3 } from 'gl-matrix';\nimport { pointInSphere } from './math/sphere';\nimport pointInShapeCallback, {\n  PointInShapeCallback,\n} from './pointInShapeCallback';\nimport { BoundsIJK } from '../types';\nimport { getBoundingBoxAroundShape } from './boundingBox';\n\nconst { transformWorldToIndex } = csUtils;\n\n/**\n * Given an imageData, and the great circle top and bottom points of a sphere,\n * this function will run the callback for each point of the imageData that is\n * within the sphere defined by the great circle points. If the viewport\n * is provided, region of interest will be an accurate approximation of the\n * sphere (using viewport camera), and the resulting performance will be\n * better.\n *\n * @privateRemarks great circle also known as orthodrome is the intersection of\n * the sphere and the plane that passes through the center of the sphere\n *\n * @param imageData - The volume imageData\n * @param circlePoints - bottom and top points of the great circle in world coordinates\n * @param callback - A callback function that will be called for each point in the shape.\n */\nexport default function pointInSurroundingSphereCallback(\n  imageData: vtkImageData,\n  circlePoints: [Types.Point3, Types.Point3],\n  callback: PointInShapeCallback,\n  viewport?: Types.IVolumeViewport\n): void {\n  // We can run the sphere equation to determine if a point is inside\n  // the sphere; however, since the imageData dimensions can be quite large, we\n  // can narrow down the search by estimating the bounds of the sphere in index\n  // space.\n  const { boundsIJK, centerWorld, radiusWorld } = _getBounds(\n    circlePoints,\n    imageData,\n    viewport\n  );\n\n  const sphereObj = {\n    center: centerWorld,\n    radius: radiusWorld,\n  };\n\n  pointInShapeCallback(\n    imageData,\n    (pointLPS) => pointInSphere(sphereObj, pointLPS),\n    callback,\n    boundsIJK\n  );\n}\n\nfunction _getBounds(\n  circlePoints: [Types.Point3, Types.Point3],\n  imageData: vtkImageData,\n  viewport\n): {\n  boundsIJK: BoundsIJK;\n  centerWorld: Types.Point3;\n  radiusWorld: number;\n} {\n  const [bottom, top] = circlePoints;\n\n  // Sphere center in world\n  const centerWorld = vec3.fromValues(\n    (bottom[0] + top[0]) / 2,\n    (bottom[1] + top[1]) / 2,\n    (bottom[2] + top[2]) / 2\n  );\n\n  // sphere radius in world\n  const radiusWorld = vec3.distance(bottom, top) / 2;\n\n  let boundsIJK;\n\n  if (!viewport) {\n    // If no viewport is provide (no camera), we can estimate the bounding box\n    // of the sphere in index space.\n    // This is done by calculating the maximum value for radius in the index\n    // space (since the radius is in world space, we need to convert it to index, and\n    // each dimensions can have a different scale factor). Therefore, by finding\n    // the minimum spacing value in the imageData, we can calculate the maximum\n    // radius in index space and use that to calculate the bounds of the sphere\n    // This will not be accurate, but it is a good first approximation.\n    // sphere center in index\n    const centerIJK = transformWorldToIndex(\n      imageData,\n      centerWorld as Types.Point3\n    );\n\n    const spacings = imageData.getSpacing();\n    const minSpacing = Math.min(...spacings);\n\n    const maxRadiusIJK = Math.ceil(radiusWorld / minSpacing);\n\n    boundsIJK = [\n      [centerIJK[0] - maxRadiusIJK, centerIJK[0] + maxRadiusIJK],\n      [centerIJK[1] - maxRadiusIJK, centerIJK[1] + maxRadiusIJK],\n      [centerIJK[2] - maxRadiusIJK, centerIJK[2] + maxRadiusIJK],\n    ];\n\n    return {\n      boundsIJK,\n      centerWorld: centerWorld as Types.Point3,\n      radiusWorld,\n    };\n  }\n\n  boundsIJK = _computeBoundsIJKWithCamera(\n    imageData,\n    viewport,\n    circlePoints,\n    centerWorld,\n    radiusWorld\n  );\n\n  return {\n    boundsIJK,\n    centerWorld: centerWorld as Types.Point3,\n    radiusWorld,\n  };\n}\n\nfunction _computeBoundsIJKWithCamera(\n  imageData,\n  viewport,\n  circlePoints,\n  centerWorld,\n  radiusWorld\n) {\n  const [bottom, top] = circlePoints;\n\n  const dimensions = imageData.getDimensions() as Types.Point3;\n  const camera = viewport.getCamera();\n\n  // Calculate viewRight from the camera, this will get used in order to\n  // calculate circles topLeft and bottomRight on different planes of intersection\n  // between sphere and viewPlane\n  const viewUp = vec3.fromValues(\n    camera.viewUp[0],\n    camera.viewUp[1],\n    camera.viewUp[2]\n  );\n  const viewPlaneNormal = vec3.fromValues(\n    camera.viewPlaneNormal[0],\n    camera.viewPlaneNormal[1],\n    camera.viewPlaneNormal[2]\n  );\n  const viewRight = vec3.create();\n\n  vec3.cross(viewRight, viewUp, viewPlaneNormal);\n\n  // we need to find the bounding box of the sphere in the image, e.g., the\n  // topLeftWorld and bottomRightWorld points of the bounding box.\n  // We go from the sphereCenter in the normal direction of amount radius, and\n  // we go left to find the topLeftWorld point of the bounding box. Next we go\n  // in the opposite direction and go right to find the bottomRightWorld point\n  // of the bounding box.\n  const topLeftWorld = vec3.create();\n  const bottomRightWorld = vec3.create();\n\n  vec3.scaleAndAdd(topLeftWorld, top, viewPlaneNormal, radiusWorld);\n  vec3.scaleAndAdd(bottomRightWorld, bottom, viewPlaneNormal, -radiusWorld);\n\n  // go in the direction of viewRight with the value of radius\n  vec3.scaleAndAdd(topLeftWorld, topLeftWorld, viewRight, -radiusWorld);\n  vec3.scaleAndAdd(bottomRightWorld, bottomRightWorld, viewRight, radiusWorld);\n\n  // convert the world coordinates to index coordinates\n\n  const sphereCornersIJK = [\n    <Types.Point3>transformWorldToIndex(imageData, <Types.Point3>topLeftWorld),\n    <Types.Point3>(\n      transformWorldToIndex(imageData, <Types.Point3>bottomRightWorld)\n    ),\n  ];\n\n  // get the bounding box of the sphere in the image\n  const boundsIJK = getBoundingBoxAroundShape(sphereCornersIJK, dimensions);\n\n  return boundsIJK;\n}\n","export function pointToString(point, decimals = 5) {\n  return (\n    parseFloat(point[0]).toFixed(decimals) +\n    ',' +\n    parseFloat(point[1]).toFixed(decimals) +\n    ',' +\n    parseFloat(point[2]).toFixed(decimals) +\n    ','\n  );\n}\n","import vtkPolyData from '@kitware/vtk.js/Common/DataModel/PolyData';\nimport type { Types } from '@cornerstonejs/core';\nimport { vec3 } from 'gl-matrix';\n\n/**\n * Gets a point from an array of numbers given its index\n * @param points - array of number, each point defined by three consecutive numbers\n * @param idx - index of the point to retrieve\n * @returns\n */\nexport function getPoint(points, idx): Types.Point3 {\n  const idx3 = idx * 3;\n  if (idx3 < points.length) {\n    return vec3.fromValues(\n      points[idx3],\n      points[idx3 + 1],\n      points[idx3 + 2]\n    ) as Types.Point3;\n  }\n}\n\n/**\n * Extract contour point sets from the outline of a poly data actor\n * @param polyData - vtk polyData\n * @returns\n */\nexport function getPolyDataPointIndexes(polyData: vtkPolyData) {\n  const linesData = polyData.getLines().getData();\n  let idx = 0;\n  const lineSegments = new Map<number, number[]>();\n\n  // Populate lineSegments map\n  while (idx < linesData.length) {\n    const segmentSize = linesData[idx++];\n    const segment = [];\n    for (let i = 0; i < segmentSize; i++) {\n      segment.push(linesData[idx + i]);\n    }\n    lineSegments.set(segment[0], segment);\n    idx += segmentSize;\n  }\n\n  const contours = [];\n\n  // Function to find an available starting point\n  const findStartingPoint = (map) => {\n    for (const [key, value] of map.entries()) {\n      if (value !== undefined) {\n        return key;\n      }\n    }\n    return -1;\n  };\n\n  // Build contours\n  let startPoint = findStartingPoint(lineSegments);\n  while (startPoint !== -1) {\n    const contour = [startPoint];\n    while (lineSegments.has(startPoint)) {\n      const nextPoint = lineSegments.get(startPoint)[1];\n      if (lineSegments.has(nextPoint)) {\n        contour.push(nextPoint);\n      }\n      lineSegments.delete(startPoint);\n      startPoint = nextPoint;\n    }\n    contours.push(contour);\n    startPoint = findStartingPoint(lineSegments);\n  }\n\n  return contours.length ? contours : undefined;\n}\n\n/**\n * Extract contour points from a poly data object\n * @param polyData - vtk polyData\n * @returns\n */\nexport function getPolyDataPoints(polyData: vtkPolyData) {\n  const contoursIndexes = getPolyDataPointIndexes(polyData);\n  if (!contoursIndexes) {\n    return;\n  }\n\n  const rawPointsData = polyData.getPoints().getData();\n  return contoursIndexes.map((contourIndexes) =>\n    contourIndexes.map((index) => getPoint(rawPointsData, index))\n  );\n}\n","import { vec3 } from 'gl-matrix';\nimport { utilities as csUtils } from '@cornerstonejs/core';\n\nconst { isEqual } = csUtils;\n\nconst iAxis = vec3.fromValues(1, 0, 0);\nconst jAxis = vec3.fromValues(0, 1, 0);\nconst kAxis = vec3.fromValues(0, 0, 1);\n\nconst axisList = [iAxis, jAxis, kAxis];\n\n/**\n * Determines whether a given rectangle in a 3D space (defined by its corner\n * points in IJK coordinates) is aligned with the IJK axes.\n * @param rectangleCornersIJK - The corner points of the rectangle in IJK coordinates\n * @returns True if the rectangle is aligned with the IJK axes, false otherwise\n */\nfunction isAxisAlignedRectangle(rectangleCornersIJK) {\n  const rectangleVec1 = vec3.subtract(\n    vec3.create(),\n    rectangleCornersIJK[0],\n    rectangleCornersIJK[1]\n  );\n\n  const rectangleVec2 = vec3.subtract(\n    vec3.create(),\n    rectangleCornersIJK[0],\n    rectangleCornersIJK[2]\n  );\n\n  // Calculate the angles with IJK axes for both vectors\n  const anglesVec1 = calculateAnglesWithAxes(rectangleVec1, axisList);\n  const anglesVec2 = calculateAnglesWithAxes(rectangleVec2, axisList);\n\n  // Check if all angles are aligned (0, 90, 180, or 270 degrees)\n  // we could do csUtils.isEqual(angle % 90, 0) but this is more explicit for reading\n  const isAligned = [...anglesVec1, ...anglesVec2].every(\n    (angle) =>\n      isEqual(angle, 0) ||\n      isEqual(angle, 90) ||\n      isEqual(angle, 180) ||\n      isEqual(angle, 270)\n  );\n\n  return isAligned;\n}\n\n// Function to calculate angle with IJK axes\nfunction calculateAnglesWithAxes(vec, axes) {\n  return axes.map((axis) => (vec3.angle(vec, axis) * 180) / Math.PI);\n}\n\nexport { isAxisAlignedRectangle };\n","import {\n  StackViewport,\n  Types,\n  VolumeViewport,\n  eventTarget,\n  EVENTS,\n  utilities as csUtils,\n  getEnabledElement,\n  VideoViewport,\n} from '@cornerstonejs/core';\nimport { ScrollOptions, EventTypes } from '../types';\n\n/**\n * It scrolls one slice in the Stack or Volume Viewport, it uses the options provided\n * to determine the slice to scroll to. For Stack Viewport, it scrolls in the 1 or -1\n * direction, for Volume Viewport, it uses the camera and focal point to determine the\n * slice to scroll to based on the spacings.\n * @param viewport - The viewport in which to scroll\n * @param options - Options to use for scrolling, including direction, invert, and volumeId\n * @returns\n */\nexport default function scroll(\n  viewport: Types.IViewport,\n  options: ScrollOptions\n): void {\n  // check if viewport is disabled then throw error\n  const enabledElement = getEnabledElement(viewport.element);\n\n  if (!enabledElement) {\n    throw new Error('Scroll::Viewport is not enabled (it might be disabled)');\n  }\n\n  if (\n    viewport instanceof StackViewport &&\n    viewport.getImageIds().length === 0\n  ) {\n    throw new Error('Scroll::Stack Viewport has no images');\n  }\n\n  const { type: viewportType } = viewport;\n  const { volumeId, delta, scrollSlabs } = options;\n\n  if (viewport instanceof StackViewport) {\n    viewport.scroll(delta, options.debounceLoading, options.loop);\n  } else if (viewport instanceof VolumeViewport) {\n    scrollVolume(viewport, volumeId, delta, scrollSlabs);\n  } else if (viewport instanceof VideoViewport) {\n    viewport.scroll(delta);\n  } else {\n    throw new Error(`Not implemented for Viewport Type: ${viewportType}`);\n  }\n}\n\nexport function scrollVolume(\n  viewport: VolumeViewport,\n  volumeId: string,\n  delta: number,\n  scrollSlabs = false\n) {\n  const useSlabThickness = scrollSlabs;\n\n  const { numScrollSteps, currentStepIndex, sliceRangeInfo } =\n    csUtils.getVolumeViewportScrollInfo(viewport, volumeId, useSlabThickness);\n\n  if (!sliceRangeInfo) {\n    return;\n  }\n\n  const { sliceRange, spacingInNormalDirection, camera } = sliceRangeInfo;\n  const { focalPoint, viewPlaneNormal, position } = camera;\n\n  const { newFocalPoint, newPosition } = csUtils.snapFocalPointToSlice(\n    focalPoint,\n    position,\n    sliceRange,\n    viewPlaneNormal,\n    spacingInNormalDirection,\n    delta\n  );\n\n  viewport.setCamera({\n    focalPoint: newFocalPoint,\n    position: newPosition,\n  });\n  viewport.render();\n\n  const desiredStepIndex = currentStepIndex + delta;\n\n  const VolumeScrollEventDetail: EventTypes.VolumeScrollOutOfBoundsEventDetail =\n    {\n      volumeId,\n      viewport,\n      delta,\n      desiredStepIndex,\n      currentStepIndex,\n      numScrollSteps,\n      currentImageId: viewport.getCurrentImageId(),\n    };\n\n  if (\n    (desiredStepIndex > numScrollSteps || desiredStepIndex < 0) &&\n    viewport.getCurrentImageId() // Check that we are in the plane of acquistion\n  ) {\n    // One common use case of this trigger might be to load the next\n    // volume in a time series or the next segment of a partially loaded volume.\n\n    csUtils.triggerEvent(\n      eventTarget,\n      EVENTS.VOLUME_SCROLL_OUT_OF_BOUNDS,\n      VolumeScrollEventDetail\n    );\n  } else {\n    csUtils.triggerEvent(\n      eventTarget,\n      EVENTS.VOLUME_VIEWPORT_SCROLL,\n      VolumeScrollEventDetail\n    );\n  }\n}\n","import { utilities as csUtils } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\nimport {\n  AnnotationCompletedEventType,\n  AnnotationModifiedEventType,\n  AnnotationRemovedEventType,\n} from '../../../types/EventTypes';\nimport { state as annotationState } from '../../../stateManagement/annotation';\nimport type AnnotationGroupSelector from '../../../types/AnnotationGroupSelector';\nimport getInterpolationDataCollection from '../../contours/interpolation/getInterpolationDataCollection';\nimport type {\n  InterpolationViewportData,\n  AcceptInterpolationSelector,\n} from '../../../types/InterpolationTypes';\nimport interpolate from '../../contours/interpolation/interpolate';\nimport deleteRelatedAnnotations from './deleteRelatedAnnotations';\nimport { InterpolationROIAnnotation } from '../../../types/ToolSpecificAnnotationTypes';\nimport ChangeTypes from '../../../enums/ChangeTypes';\nimport getViewportForAnnotation from '../../getViewportForAnnotation';\nimport { addContourSegmentationAnnotation } from '../../contourSegmentation/addContourSegmentationAnnotation';\n\nconst { uuidv4 } = csUtils;\n\nconst ChangeTypesForInterpolation = [\n  ChangeTypes.HandlesUpdated,\n  ChangeTypes.InterpolationUpdated,\n];\n\nexport default class InterpolationManager {\n  static toolNames = [];\n\n  static addTool(toolName: string) {\n    if (!this.toolNames.includes(toolName)) {\n      this.toolNames.push(toolName);\n    }\n  }\n\n  /**\n   * Accepts the autogenerated interpolations, marking them as non-autogenerated.\n   * Can provide a selector to choose which ones to accept.\n   *\n   * Rules for which items to select:\n   * 1. Only choose annotations having the same segment index and segmentationID\n   * 2. Exclude all contours having the same interpolation UID as any other contours\n   *    on the same slice.\n   * 3. Exclude autogenerated annotations\n   * 4. Exclude any reset interpolationUIDs (this is a manual operation to allow\n   *    creating a new interpolation)\n   * 5. Find the set of interpolationUID's remaining\n   *    a. If the set is of size 0, assign a new interpolationUID\n   *    b. If the set is of size 1, assign that interpolationUID\n   *    c. Otherwise (optional, otherwise do b for size>1 randomly),\n   *       for every remaining annotation, find the one whose center\n   *       point is closest to the center point of the new annotation.\n   *       Choose that interpolationUID\n   *\n   * To allow creating new interpolated groups, the idea is to just use a new\n   * segment index, then have an operation to update the segment index of an\n   * interpolation set.  That way the user can easily draw/see the difference,\n   * and then merge them as required.\n   * However, the base rules allow creating two contours on a single image to\n   * create a separate set.\n   */\n  static acceptAutoGenerated(\n    annotationGroupSelector: AnnotationGroupSelector,\n    selector: AcceptInterpolationSelector = {}\n  ) {\n    const { toolNames, segmentationId, segmentIndex, sliceIndex } = selector;\n    for (const toolName of toolNames || InterpolationManager.toolNames) {\n      const annotations = annotationState.getAnnotations(\n        toolName,\n        annotationGroupSelector\n      ) as InterpolationROIAnnotation[];\n      if (!annotations?.length) {\n        continue;\n      }\n      for (const annotation of annotations) {\n        const { interpolationUID, data, autoGenerated, metadata } = annotation;\n        if (interpolationUID) {\n          annotation.interpolationCompleted = true;\n        }\n        if (!autoGenerated) {\n          continue;\n        }\n        if (segmentIndex && segmentIndex !== data.segmentation.segmentIndex) {\n          continue;\n        }\n        if (\n          sliceIndex !== undefined &&\n          metadata &&\n          sliceIndex !== metadata.sliceIndex\n        ) {\n          continue;\n        }\n        if (\n          segmentationId &&\n          segmentationId !== data.segmentation.segmentationId\n        ) {\n          continue;\n        }\n        addContourSegmentationAnnotation(annotation);\n        annotation.autoGenerated = false;\n      }\n    }\n  }\n\n  /**\n   * When an annotation is completed, if the configuration includes interpolation,\n   * then find matching interpolations and interpolation between this segmentation\n   * and the other segmentations of the same type.\n   */\n  static handleAnnotationCompleted = (evt: AnnotationCompletedEventType) => {\n    const annotation = evt.detail.annotation as InterpolationROIAnnotation;\n    if (!annotation?.metadata) {\n      return;\n    }\n    const { toolName, originalToolName } = annotation.metadata;\n\n    if (\n      !this.toolNames.includes(toolName) &&\n      !this.toolNames.includes(originalToolName)\n    ) {\n      return;\n    }\n\n    const viewport = getViewportForAnnotation(annotation);\n    if (!viewport) {\n      console.warn('Unable to find viewport for', annotation);\n      return;\n    }\n    const sliceData: Types.ImageSliceData = getSliceData(viewport);\n    const viewportData: InterpolationViewportData = {\n      viewport,\n      sliceData,\n      annotation,\n      interpolationUID: annotation.interpolationUID,\n    };\n    const hasInterpolationUID = !!annotation.interpolationUID;\n    // If any update, triggered on an annotation, then it will be treated as non-autogenerated.\n    annotation.autoGenerated = false;\n    if (hasInterpolationUID) {\n      // This has already been configured with matching details, so just run\n      //  the interpolation again.\n      deleteRelatedAnnotations(viewportData);\n      interpolate(viewportData);\n      return;\n    }\n    const filterData = [\n      {\n        key: 'segmentIndex',\n        value: annotation.data.segmentation.segmentIndex,\n        parentKey: (annotation) => annotation.data.segmentation,\n      },\n      {\n        key: 'viewPlaneNormal',\n        value: annotation.metadata.viewPlaneNormal,\n        parentKey: (annotation) => annotation.metadata,\n      },\n      {\n        key: 'viewUp',\n        value: annotation.metadata.viewUp,\n        parentKey: (annotation) => annotation.metadata,\n      },\n    ];\n    let interpolationAnnotations = getInterpolationDataCollection(\n      viewportData,\n      filterData\n    );\n    // Skip other type of annotation interpolationUID's that are co-located\n    const { sliceIndex } = annotation.metadata;\n    const skipUIDs = new Set<string>();\n    interpolationAnnotations.forEach((interpolationAnnotation) => {\n      if (\n        interpolationAnnotation.interpolationCompleted ||\n        interpolationAnnotation.metadata.sliceIndex === sliceIndex\n      ) {\n        const { interpolationUID } = interpolationAnnotation;\n        skipUIDs.add(interpolationUID);\n      }\n    });\n    interpolationAnnotations = interpolationAnnotations.filter(\n      (interpolationAnnotation) =>\n        !skipUIDs.has(interpolationAnnotation.interpolationUID)\n    );\n\n    // Assign a new interpolationUID (this is checked above, so will be empty initially)\n    annotation.interpolationUID =\n      interpolationAnnotations[0]?.interpolationUID || uuidv4();\n    viewportData.interpolationUID = annotation.interpolationUID;\n    interpolate(viewportData);\n  };\n\n  /**\n   * This method gets called when an annotation changes.  It will then trigger\n   * related already interpolated annotations to be updated with the modified data.\n   */\n  static handleAnnotationUpdate = (evt: AnnotationModifiedEventType) => {\n    const annotation = evt.detail.annotation as InterpolationROIAnnotation;\n    const { changeType = ChangeTypes.HandlesUpdated } = evt.detail;\n    if (!annotation?.metadata) {\n      return;\n    }\n    const { toolName, originalToolName } = annotation.metadata;\n\n    if (\n      (!this.toolNames.includes(toolName) &&\n        !this.toolNames.includes(originalToolName)) ||\n      !ChangeTypesForInterpolation.includes(changeType)\n    ) {\n      return;\n    }\n    const viewport = getViewportForAnnotation(annotation);\n    if (!viewport) {\n      console.warn(\n        'Unable to find matching viewport for annotation interpolation',\n        annotation\n      );\n      return;\n    }\n    if (annotation.autoGenerated) {\n      // Dont fire the annotation changed events here, as that leads to recursion,\n      // although this is in fact completing the event, so trigger the segmentation add\n      addContourSegmentationAnnotation(annotation);\n      annotation.autoGenerated = false;\n    }\n\n    const sliceData: Types.ImageSliceData = getSliceData(viewport);\n    const viewportData: InterpolationViewportData = {\n      viewport,\n      sliceData,\n      annotation,\n      interpolationUID: annotation.interpolationUID,\n      isInterpolationUpdate: changeType === ChangeTypes.InterpolationUpdated,\n    };\n    interpolate(viewportData);\n  };\n\n  /**\n   * Delete interpolated annotations when their endpoints are deleted.\n   */\n  static handleAnnotationDelete = (evt: AnnotationRemovedEventType) => {\n    const annotation = evt.detail.annotation as InterpolationROIAnnotation;\n    if (!annotation?.metadata) {\n      return;\n    }\n    const { toolName } = annotation.metadata;\n\n    if (!this.toolNames.includes(toolName) || annotation.autoGenerated) {\n      return;\n    }\n    const viewport = getViewportForAnnotation(annotation);\n\n    if (!viewport) {\n      console.warn(\n        \"No viewport, can't delete interpolated results\",\n        annotation\n      );\n      return;\n    }\n\n    const sliceData: Types.ImageSliceData = getSliceData(viewport);\n    const viewportData: InterpolationViewportData = {\n      viewport,\n      sliceData,\n      annotation,\n      interpolationUID: annotation.interpolationUID,\n    };\n    // If any update, triggered on an annotation, then it will be treated as non-interpolated.\n    annotation.autoGenerated = false;\n    deleteRelatedAnnotations(viewportData);\n  };\n}\n\nfunction getSliceData(viewport): Types.ImageSliceData {\n  const sliceData: Types.ImageSliceData = {\n    numberOfSlices: viewport.getNumberOfSlices(),\n    imageIndex: viewport.getCurrentImageIdIndex(),\n  };\n  return sliceData;\n}\n","import { generateContourSetsFromLabelmap } from '../contours';\nimport SegmentationRepresentations from '../../enums/SegmentationRepresentations';\nimport findLargestBidirectional from './findLargestBidirectional';\n\nconst { Labelmap } = SegmentationRepresentations;\n\n/**\n * Generates a contour object over the segment, and then uses the contouring to\n * find the largest bidirectional object that can be applied within the acquisition\n * plane that is within the segment index, or the contained segment indices.\n *\n * @param segmentation.segments - a list of segments to apply the contour to.\n * @param segmentation.segments.containedSegmentIndices - a set of segment indexes equivalent to the primary segment\n * @param segmentation.segments.label - the label for the segment\n * @param segmentation.segments.color - the color to use for the segment label\n */\nexport default function contourAndFindLargestBidirectional(segmentation) {\n  const contours = generateContourSetsFromLabelmap({\n    segmentations: segmentation,\n  });\n\n  if (!contours?.length || !contours[0].sliceContours.length) {\n    return;\n  }\n\n  const {\n    representationData,\n    segments = [\n      null,\n      { label: 'Unspecified', color: null, containedSegmentIndices: null },\n    ],\n  } = segmentation;\n  const { volumeId: segVolumeId } = representationData[Labelmap];\n\n  const segmentIndex = segments.findIndex((it) => !!it);\n  if (segmentIndex === -1) {\n    return;\n  }\n  segments[segmentIndex].segmentIndex = segmentIndex;\n  return findLargestBidirectional(\n    contours[0],\n    segVolumeId,\n    segments[segmentIndex]\n  );\n}\n","/**\n * Creates a map that associates each imageId with a set of segmentation imageIds.\n * Note that this function assumes that the imageIds and segmentationImageIds arrays\n * are the same length and same order.\n *\n * @param imageIdsArray - An array of imageIds.\n * @param segmentationImageIds - An array of segmentation imageIds.\n * @returns A map that maps each imageId to a set of segmentation imageIds.\n */\nfunction createImageIdReferenceMap(\n  imageIdsArray: string[],\n  segmentationImageIds: string[]\n): Map<string, string> {\n  const imageIdReferenceMap = new Map<string, string>(\n    imageIdsArray.map((imageId, index) => {\n      return [imageId, segmentationImageIds[index]];\n    })\n  );\n\n  return imageIdReferenceMap;\n}\n\nexport { createImageIdReferenceMap };\n","import type {\n  FloodFillResult,\n  FloodFillGetter,\n  FloodFillOptions,\n} from '../../types';\nimport { Types } from '@cornerstonejs/core';\n\n/**\n * floodFill.js - Taken from MIT OSS lib - https://github.com/tuzz/n-dimensional-flood-fill\n * Refactored to ES6.  Fixed the bounds/visits checks to use integer keys, restricting the\n * total search spacing to +/- 32k in each dimension, but resulting in about a hundred time\n * performance gain for larger regions since JavaScript does not have a hash map to allow the\n * map to work on keys.\n *\n * @param getter The getter to the elements of your data structure,\n *                          e.g. getter(x,y) for a 2D interprettation of your structure.\n * @param seed The seed for your fill. The dimensionality is infered\n *                        by the number of dimensions of the seed.\n * @param options.onFlood - An optional callback to execute when each pixel is flooded.\n *                             e.g. onFlood(x,y).\n * @param options.onBoundary - An optional callback to execute whenever a boundary is reached.\n *                                a boundary could be another segmentIndex, or the edge of your\n *                                data structure (i.e. when your getter returns undefined).\n * @param options.equals - An optional equality method for your datastructure.\n *                            Default is simply value1 = value2.\n * @param options.diagonals - Whether you allow flooding through diagonals. Defaults to false.\n *\n * @returns Flood fill results\n */\nfunction floodFill(\n  getter: FloodFillGetter,\n  seed: Types.Point2 | Types.Point3,\n  options: FloodFillOptions = {}\n): FloodFillResult {\n  const onFlood = options.onFlood;\n  const onBoundary = options.onBoundary;\n  const equals = options.equals;\n  const diagonals = options.diagonals || false;\n  const startNode = get(seed);\n  const permutations = prunedPermutations();\n  const stack = [];\n  const flooded = [];\n  const visits = new Set();\n  const bounds = new Map();\n\n  stack.push({ currentArgs: seed });\n\n  while (stack.length > 0) {\n    flood(stack.pop());\n  }\n\n  return {\n    flooded,\n    boundaries: boundaries(),\n  };\n\n  function flood(job) {\n    const getArgs = job.currentArgs;\n    const prevArgs = job.previousArgs;\n\n    if (visited(getArgs)) {\n      return;\n    }\n    markAsVisited(getArgs);\n\n    if (member(getArgs)) {\n      markAsFlooded(getArgs);\n      pushAdjacent(getArgs);\n    } else {\n      markAsBoundary(prevArgs);\n    }\n  }\n\n  /**\n   * Indicates if the key has been visited.\n   * @param key is a 2 or 3 element vector with values -32768...32767\n   */\n  function visited(key) {\n    const [x, y, z = 0] = key;\n    // Use an integer key value for checking visited, since JavaScript does not\n    // provide a generic hash key indexed hash map.\n    const iKey = x + 32768 + 65536 * (y + 32768 + 65536 * (z + 32768));\n    return visits.has(iKey);\n  }\n\n  function markAsVisited(key) {\n    const [x, y, z = 0] = key;\n    const iKey = x + 32768 + 65536 * (y + 32768 + 65536 * (z + 32768));\n    visits.add(iKey);\n  }\n\n  function member(getArgs) {\n    const node = get(getArgs);\n\n    return equals ? equals(node, startNode) : node === startNode;\n  }\n\n  function markAsFlooded(getArgs) {\n    flooded.push(getArgs);\n    if (onFlood) {\n      //@ts-ignore\n      onFlood(...getArgs);\n    }\n  }\n\n  function markAsBoundary(prevArgs) {\n    const [x, y, z = 0] = prevArgs;\n    // Use an integer key value for checking visited, since JavaScript does not\n    // provide a generic hash key indexed hash map.\n    const iKey = x + 32768 + 65536 * (y + 32768 + 65536 * (z + 32768));\n    bounds.set(iKey, prevArgs);\n    if (onBoundary) {\n      //@ts-ignore\n      onBoundary(...prevArgs);\n    }\n  }\n\n  function pushAdjacent(getArgs) {\n    for (let i = 0; i < permutations.length; i += 1) {\n      const perm = permutations[i];\n      const nextArgs = getArgs.slice(0);\n\n      for (let j = 0; j < getArgs.length; j += 1) {\n        nextArgs[j] += perm[j];\n      }\n\n      stack.push({\n        currentArgs: nextArgs,\n        previousArgs: getArgs,\n      });\n    }\n  }\n\n  function get(getArgs) {\n    //@ts-ignore\n    return getter(...getArgs);\n  }\n\n  // This is a significant performance hit - should be done as a wrapper\n  // only when needed.\n  // function safely(f, args) {\n  //   try {\n  //     return f(...args);\n  //   } catch (error) {\n  //     return;\n  //   }\n  // }\n\n  function prunedPermutations() {\n    const permutations = permute(seed.length);\n\n    return permutations.filter(function (perm) {\n      const count = countNonZeroes(perm);\n\n      return count !== 0 && (count === 1 || diagonals);\n    });\n  }\n\n  function permute(length) {\n    const perms = [];\n\n    const permutation = function (string) {\n      return string.split('').map(function (c) {\n        return parseInt(c, 10) - 1;\n      });\n    };\n\n    for (let i = 0; i < Math.pow(3, length); i += 1) {\n      const string = lpad(i.toString(3), '0', length);\n\n      perms.push(permutation(string));\n    }\n\n    return perms;\n  }\n\n  function boundaries() {\n    const array = Array.from(bounds.values());\n    array.reverse();\n    return array;\n  }\n}\n\nfunction defaultEquals(a, b) {\n  return a === b;\n}\n\nfunction countNonZeroes(array) {\n  let count = 0;\n\n  for (let i = 0; i < array.length; i += 1) {\n    if (array[i] !== 0) {\n      count += 1;\n    }\n  }\n\n  return count;\n}\n\nfunction lpad(string, character, length) {\n  const array = new Array(length + 1);\n  const pad = array.join(character);\n\n  return (pad + string).slice(-length);\n}\n\nexport default floodFill;\n","import { getAnnotation } from '../../stateManagement';\nimport { getSegmentation } from '../../stateManagement/segmentation/segmentationState';\n\n/**\n * Retrieves the index of the hovered contour segmentation annotation for a given segmentation ID.\n *\n * @param segmentationId - The ID of the segmentation.\n * @returns The index of the hovered contour segmentation annotation, or undefined if none is found.\n */\nexport function getHoveredContourSegmentationAnnotation(segmentationId) {\n  const segmentation = getSegmentation(segmentationId);\n  const { annotationUIDsMap } = segmentation.representationData.CONTOUR;\n\n  for (const [segmentIndex, annotationUIDs] of annotationUIDsMap.entries()) {\n    const highlightedAnnotationUID = Array.from(annotationUIDs).find(\n      (annotationUID) => getAnnotation(annotationUID).highlighted\n    );\n\n    if (highlightedAnnotationUID) {\n      return segmentIndex;\n    }\n  }\n\n  return undefined;\n}\n","import { cache, utilities } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\nimport {\n  getSegmentation,\n  getSegmentationIdRepresentations,\n} from '../../stateManagement/segmentation/segmentationState';\nimport {\n  LabelmapSegmentationDataStack,\n  LabelmapSegmentationDataVolume,\n} from '../../types/LabelmapTypes';\nimport { isVolumeSegmentation } from '../../tools/segmentation/strategies/utils/stackVolumeCheck';\n\ntype Options = {\n  viewport?: Types.IViewport;\n  searchRadius?: number;\n};\n\n/**\n * Retrieves the segment index at the border of a labelmap in a segmentation.\n *\n * @param segmentationId - The ID of the segmentation.\n * @param worldPoint - The world coordinates of the point.\n * @param options - Additional options.\n * @param options.viewport - The viewport to use.\n * @param options.searchRadius - The search radius to use.\n * @returns The segment index at the labelmap border, or undefined if not found.\n */\nexport function getSegmentAtLabelmapBorder(\n  segmentationId: string,\n  worldPoint: Types.Point3,\n  { viewport, searchRadius }: Options\n): number {\n  const segmentation = getSegmentation(segmentationId);\n\n  const labelmapData = segmentation.representationData.LABELMAP;\n\n  if (isVolumeSegmentation(labelmapData)) {\n    const { volumeId } = labelmapData as LabelmapSegmentationDataVolume;\n    const segmentationVolume = cache.getVolume(volumeId);\n\n    if (!segmentationVolume) {\n      return;\n    }\n\n    const imageData = segmentationVolume.imageData;\n\n    const segmentIndex = imageData.getScalarValueFromWorld(worldPoint);\n\n    const canvasPoint = viewport.worldToCanvas(worldPoint);\n\n    const onEdge = isSegmentOnEdgeCanvas(\n      canvasPoint as Types.Point2,\n      segmentIndex,\n      viewport,\n      imageData,\n      searchRadius\n    );\n\n    return onEdge ? segmentIndex : undefined;\n  }\n\n  // stack segmentation case\n  const { imageIdReferenceMap } = labelmapData as LabelmapSegmentationDataStack;\n\n  const currentImageId = (viewport as Types.IStackViewport).getCurrentImageId();\n\n  const segmentationImageId = imageIdReferenceMap.get(currentImageId);\n  const image = cache.getImage(segmentationImageId);\n\n  if (!image) {\n    return;\n  }\n\n  // find the first segmentationRepresentationUID for the segmentationId, since\n  // that is what we use as actorUID in the viewport\n\n  const segmentationRepresentations = getSegmentationIdRepresentations(\n    segmentation.segmentationId\n  );\n\n  const { segmentationRepresentationUID } = segmentationRepresentations[0];\n  const segmentationActor = viewport.getActor(segmentationRepresentationUID);\n  const imageData = segmentationActor?.actor.getMapper().getInputData();\n  const indexIJK = utilities.transformWorldToIndex(imageData, worldPoint);\n\n  const dimensions = imageData.getDimensions();\n  const voxelManager = (imageData.voxelManager ||\n    utilities.VoxelManager.createVolumeVoxelManager(\n      dimensions,\n      imageData.getPointData().getScalars().getData()\n    )) as utilities.VoxelManager<number>;\n\n  const segmentIndex = voxelManager.getAtIJKPoint(indexIJK as Types.Point3);\n\n  const onEdge = isSegmentOnEdgeIJK(\n    indexIJK as Types.Point3,\n    dimensions,\n    voxelManager,\n    segmentIndex\n  );\n\n  return onEdge ? segmentIndex : undefined;\n}\n\n/**\n * Checks if a segment is on the edge of a labelmap.\n * @param getNeighborIndex - A function that returns the neighbor index given the delta values.\n * @param segmentIndex - The index of the segment to check.\n * @param searchRadius - The radius within which to search for neighboring segments. Default is 1.\n * @returns A boolean indicating whether the segment is on the edge.\n */\nfunction isSegmentOnEdge(\n  getNeighborIndex: (\n    deltaI: number,\n    deltaJ: number,\n    deltaK: number\n  ) => number | undefined,\n  segmentIndex: number,\n  searchRadius = 1 // Default search radius\n): boolean {\n  const neighborRange = Array.from(\n    { length: 2 * searchRadius + 1 },\n    (_, i) => i - searchRadius\n  );\n\n  for (const deltaI of neighborRange) {\n    for (const deltaJ of neighborRange) {\n      for (const deltaK of neighborRange) {\n        if (deltaI === 0 && deltaJ === 0 && deltaK === 0) {\n          continue; // Skipping the central point\n        }\n\n        const neighborIndex = getNeighborIndex(deltaI, deltaJ, deltaK);\n\n        if (neighborIndex !== undefined && segmentIndex !== neighborIndex) {\n          return true; // On the edge\n        }\n      }\n    }\n  }\n\n  return false; // No edge neighbors found\n}\n\nfunction isSegmentOnEdgeIJK(\n  indexIJK: Types.Point3,\n  dimensions: Types.Point3,\n  voxelManager: any,\n  segmentIndex: number,\n  searchRadius?: number\n): boolean {\n  const getNeighborIndex = (deltaI: number, deltaJ: number, deltaK: number) => {\n    const neighborIJK = [\n      indexIJK[0] + deltaI,\n      indexIJK[1] + deltaJ,\n      indexIJK[2] + deltaK,\n    ];\n\n    return voxelManager.getAtIJK(...neighborIJK);\n  };\n\n  return isSegmentOnEdge(getNeighborIndex, segmentIndex, searchRadius);\n}\n\nfunction isSegmentOnEdgeCanvas(\n  canvasPoint: Types.Point2,\n  segmentIndex: number,\n  viewport: Types.IViewport,\n  imageData: any,\n  searchRadius?: number\n): boolean {\n  const getNeighborIndex = (deltaI: number, deltaJ: number) => {\n    const neighborCanvas = [canvasPoint[0] + deltaI, canvasPoint[1] + deltaJ];\n\n    const worldPoint = viewport.canvasToWorld(neighborCanvas as Types.Point2);\n    return imageData.getScalarValueFromWorld(worldPoint);\n  };\n\n  return isSegmentOnEdge(getNeighborIndex, segmentIndex, searchRadius);\n}\n","import { cache, utilities } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\nimport { SegmentationRepresentations } from '../../enums';\nimport {\n  getSegmentation,\n  getSegmentationIdRepresentations,\n} from '../../stateManagement/segmentation/segmentationState';\nimport {\n  LabelmapSegmentationDataStack,\n  LabelmapSegmentationDataVolume,\n} from '../../types/LabelmapTypes';\nimport { isVolumeSegmentation } from '../../tools/segmentation/strategies/utils/stackVolumeCheck';\nimport { ContourSegmentationAnnotation, Segmentation } from '../../types';\nimport { getAnnotation } from '../../stateManagement';\nimport { isPointInsidePolyline3D } from '../math/polyline';\n\ntype Options = {\n  representationType?: SegmentationRepresentations;\n  viewport?: Types.IViewport;\n};\n\n/**\n * Get the segment at the specified world point in the viewport.\n * @param segmentationId - The ID of the segmentation to get the segment for.\n * @param worldPoint - The world point to get the segment for.\n *\n * @returns The index of the segment at the world point, or undefined if not found.\n */\nexport function getSegmentAtWorldPoint(\n  segmentationId: string,\n  worldPoint: Types.Point3,\n  options = {} as Options\n): number {\n  const segmentation = getSegmentation(segmentationId);\n\n  const representationData = segmentation.representationData;\n\n  // if representationType is not provided, we will use the first representation\n  const desiredRepresentation =\n    options?.representationType ?? Object.keys(representationData)[0];\n\n  if (!desiredRepresentation) {\n    throw new Error(\n      `Segmentation ${segmentationId} does not have any representations`\n    );\n  }\n\n  switch (desiredRepresentation) {\n    case SegmentationRepresentations.Labelmap:\n      return getSegmentAtWorldForLabelmap(segmentation, worldPoint, options);\n    case SegmentationRepresentations.Contour:\n      return getSegmentAtWorldForContour(segmentation, worldPoint, options);\n    default:\n      return;\n  }\n}\n\n/**\n * Retrieves the segment index at a given world point for a labelmap.\n *\n * @param labelmapData - The labelmap segmentation data.\n * @param worldPoint - The world point to retrieve the segment at.\n *\n * @returns The segment index at the given world point, or undefined if not found.\n */\nexport function getSegmentAtWorldForLabelmap(\n  segmentation: Segmentation,\n  worldPoint: Types.Point3,\n  { viewport }: Options\n): number | undefined {\n  const labelmapData = segmentation.representationData.LABELMAP;\n\n  if (isVolumeSegmentation(labelmapData)) {\n    const { volumeId } = labelmapData as LabelmapSegmentationDataVolume;\n    const segmentationVolume = cache.getVolume(volumeId);\n\n    if (!segmentationVolume) {\n      return;\n    }\n\n    const segmentIndex =\n      segmentationVolume.imageData.getScalarValueFromWorld(worldPoint);\n\n    return segmentIndex;\n  }\n\n  // stack segmentation case\n  const { imageIdReferenceMap } = labelmapData as LabelmapSegmentationDataStack;\n\n  const currentImageId = (viewport as Types.IStackViewport).getCurrentImageId();\n\n  const segmentationImageId = imageIdReferenceMap.get(currentImageId);\n  const image = cache.getImage(segmentationImageId);\n\n  if (!image) {\n    return;\n  }\n\n  // find the first segmentationRepresentationUID for the segmentationId, since\n  // that is what we use as actorUID in the viewport\n\n  const segmentationRepresentations = getSegmentationIdRepresentations(\n    segmentation.segmentationId\n  );\n\n  const { segmentationRepresentationUID } = segmentationRepresentations[0];\n\n  const segmentationActor = viewport.getActor(segmentationRepresentationUID);\n  const imageData = segmentationActor?.actor.getMapper().getInputData();\n  const indexIJK = utilities.transformWorldToIndex(imageData, worldPoint);\n\n  const dimensions = imageData.getDimensions();\n  const voxelManager = (imageData.voxelManager ||\n    utilities.VoxelManager.createVolumeVoxelManager(\n      dimensions,\n      imageData.getPointData().getScalars().getData()\n    )) as utilities.VoxelManager<number>;\n\n  const segmentIndex = voxelManager.getAtIJKPoint(indexIJK as Types.Point3);\n\n  return segmentIndex;\n}\n\n/**\n * Retrieves the segment index at a given world point for contour segmentation.\n *\n * @param segmentation - The segmentation data.\n * @param worldPoint - The world point to check.\n * @param options - The options for segmentation.\n * @returns The segment index at the given world point, or undefined if not found.\n */\nexport function getSegmentAtWorldForContour(\n  segmentation: Segmentation,\n  worldPoint: Types.Point3,\n  { viewport }: Options\n): number {\n  const contourData = segmentation.representationData.CONTOUR;\n\n  const segmentIndices = Array.from(contourData.annotationUIDsMap.keys());\n  const { viewPlaneNormal } = viewport.getCamera();\n\n  for (const segmentIndex of segmentIndices) {\n    const annotationsSet = contourData.annotationUIDsMap.get(segmentIndex);\n\n    if (!annotationsSet) {\n      continue;\n    }\n\n    for (const annotationUID of annotationsSet) {\n      const annotation = getAnnotation(\n        annotationUID\n      ) as ContourSegmentationAnnotation;\n\n      if (!annotation) {\n        continue;\n      }\n\n      const { polyline } = annotation.data.contour;\n\n      if (\n        !utilities.isEqual(viewPlaneNormal, annotation.metadata.viewPlaneNormal)\n      ) {\n        continue;\n      }\n\n      // This function checks whether we are inside the contour. It does not\n      // check if we are exactly on the contour, which is highly unlikely given\n      // the canvas pixel resolution of 1 decimal place we have by design.\n      if (isPointInsidePolyline3D(worldPoint, polyline)) {\n        return Number(segmentIndex);\n      }\n    }\n  }\n}\n","import { getToolGroup } from '../../store/ToolGroupManager';\nimport BrushTool from '../../tools/segmentation/BrushTool';\nimport triggerAnnotationRenderForViewportIds from '../triggerAnnotationRenderForViewportIds';\nimport { getRenderingEngine } from '@cornerstonejs/core';\nimport { getBrushToolInstances } from './utilities';\n\n/**\n * Invalidates the brush cursor for a specific tool group.\n * This function triggers the update of the brush being rendered.\n * It also triggers an annotation render for any viewports on the tool group.\n *\n * @param toolGroupId - The ID of the tool group.\n */\nexport function invalidateBrushCursor(toolGroupId: string): void {\n  const toolGroup = getToolGroup(toolGroupId);\n\n  if (toolGroup === undefined) {\n    return;\n  }\n\n  const brushBasedToolInstances = getBrushToolInstances(toolGroupId);\n\n  brushBasedToolInstances.forEach((tool: BrushTool) => {\n    // Invalidate the brush being rendered so it can update.\n    tool.invalidateBrushCursor();\n  });\n\n  // Trigger an annotation render for any viewports on the toolgroup\n  const viewportsInfo = toolGroup.getViewportsInfo();\n\n  const viewportsInfoArray = Object.keys(viewportsInfo).map(\n    (key) => viewportsInfo[key]\n  );\n\n  if (!viewportsInfoArray.length) {\n    return;\n  }\n\n  const { renderingEngineId } = viewportsInfoArray[0];\n\n  // Use helper to get array of viewportIds, or we just end up doing this mapping\n  // ourselves here.\n  const viewportIds = toolGroup.getViewportIds();\n\n  const renderingEngine = getRenderingEngine(renderingEngineId);\n\n  triggerAnnotationRenderForViewportIds(renderingEngine, viewportIds);\n}\n","import { Types } from '@cornerstonejs/core';\nimport { utilities as csUtils } from '@cornerstonejs/core';\nimport { getToolGroup } from '../../store/ToolGroupManager';\nimport BrushTool from '../../tools/segmentation/BrushTool';\nimport { getBoundingBoxAroundShapeIJK } from '../boundingBox/getBoundingBoxAroundShape';\n\nexport type ThresholdInformation = {\n  volume: Types.IImageVolume;\n  lower: number;\n  upper: number;\n};\n\nexport function getBrushToolInstances(toolGroupId: string, toolName?: string) {\n  const toolGroup = getToolGroup(toolGroupId);\n\n  if (toolGroup === undefined) {\n    return;\n  }\n\n  const toolInstances = toolGroup._toolInstances;\n\n  if (!Object.keys(toolInstances).length) {\n    return;\n  }\n\n  if (toolName && toolInstances[toolName]) {\n    return [toolInstances[toolName]];\n  }\n\n  // For each tool that has BrushTool as base class, set the brush size.\n  const brushBasedToolInstances = Object.values(toolInstances).filter(\n    (toolInstance) => toolInstance instanceof BrushTool\n  ) as BrushTool[];\n\n  return brushBasedToolInstances;\n}\n\nconst equalsCheck = (a, b) => {\n  return JSON.stringify(a) === JSON.stringify(b);\n};\n\n/**\n * Given the center of a voxel in world coordinates, calculate the voxel\n * corners in world coords to calculate the voxel overlap in another volume\n */\nexport function getVoxelOverlap(\n  imageData,\n  dimensions,\n  voxelSpacing,\n  voxelCenter\n) {\n  const voxelCornersWorld = [];\n  for (let i = 0; i < 2; i++) {\n    for (let j = 0; j < 2; j++) {\n      for (let k = 0; k < 2; k++) {\n        const point = [...voxelCenter]; // Create a new point from voxelCenter\n        point[0] = point[0] + ((i * 2 - 1) * voxelSpacing[0]) / 2;\n        point[1] = point[1] + ((j * 2 - 1) * voxelSpacing[1]) / 2;\n        point[2] = point[2] + ((k * 2 - 1) * voxelSpacing[2]) / 2;\n        voxelCornersWorld.push(point);\n      }\n    }\n  }\n  const voxelCornersIJK = voxelCornersWorld.map(\n    (world) => csUtils.transformWorldToIndex(imageData, world) as Types.Point3\n  );\n  const overlapBounds = getBoundingBoxAroundShapeIJK(\n    voxelCornersIJK,\n    dimensions\n  );\n\n  return overlapBounds;\n}\n\n/**\n * Prepare a list of volume information objects for callback functions\n */\nexport function processVolumes(\n  segmentationVolume: Types.IImageVolume,\n  thresholdVolumeInformation: ThresholdInformation[]\n) {\n  const { spacing: segmentationSpacing } = segmentationVolume;\n  const scalarData = segmentationVolume.getScalarData();\n\n  // prepare a list of volume information objects for callback functions\n  const volumeInfoList = [];\n  let baseVolumeIdx = 0;\n  for (let i = 0; i < thresholdVolumeInformation.length; i++) {\n    const { imageData, spacing, dimensions } =\n      thresholdVolumeInformation[i].volume;\n\n    const volumeSize =\n      thresholdVolumeInformation[i].volume.getScalarData().length;\n    // discover the index of the volume the segmentation data is based on\n    if (\n      volumeSize === scalarData.length &&\n      equalsCheck(spacing, segmentationSpacing)\n    ) {\n      baseVolumeIdx = i;\n    }\n\n    // prepare information used in callback functions\n    const referenceValues = imageData.getPointData().getScalars().getData();\n    const lower = thresholdVolumeInformation[i].lower;\n    const upper = thresholdVolumeInformation[i].upper;\n\n    volumeInfoList.push({\n      imageData,\n      referenceValues,\n      lower,\n      upper,\n      spacing,\n      dimensions,\n      volumeSize,\n    });\n  }\n\n  return {\n    volumeInfoList,\n    baseVolumeIdx,\n  };\n}\n","import debounce from './debounce';\nimport isObject from './isObject';\n\n/**\n * Creates a throttled function that only invokes `func` at most once per\n * every `wait` milliseconds (or once per browser frame). The throttled function\n * comes with a `cancel` method to cancel delayed `func` invocations and a\n * `flush` method to immediately invoke them. Provide `options` to indicate\n * whether `func` should be invoked on the leading and/or trailing edge of the\n * `wait` timeout. The `func` is invoked with the last arguments provided to the\n * throttled function. Subsequent calls to the throttled function return the\n * result of the last `func` invocation.\n *\n * **Note:** If `leading` and `trailing` options are `true`, `func` is\n * invoked on the trailing edge of the timeout only if the throttled function\n * is invoked more than once during the `wait` timeout.\n *\n * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n * until the next tick, similar to `setTimeout` with a timeout of `0`.\n *\n * If `wait` is omitted in an environment with `requestAnimationFrame`, `func`\n * invocation will be deferred until the next frame is drawn (typically about\n * 16ms).\n *\n * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n * for details over the differences between `throttle` and `debounce`.\n *\n * @param {Function} func The function to throttle.\n * @param {number} [wait=0]\n *  The number of milliseconds to throttle invocations to; if omitted,\n *  `requestAnimationFrame` is used (if available).\n * @param {Object} [options={}] The options object.\n * @param {boolean} [options.leading=true]\n *  Specify invoking on the leading edge of the timeout.\n * @param {boolean} [options.trailing=true]\n *  Specify invoking on the trailing edge of the timeout.\n * @returns {Function} Returns the new throttled function.\n * @example\n *\n * // Avoid excessively updating the position while scrolling.\n * jQuery(window).on('scroll', throttle(updatePosition, 100))\n *\n * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.\n * const throttled = throttle(renewToken, 300000, { 'trailing': false })\n * jQuery(element).on('click', throttled)\n *\n * // Cancel the trailing throttled invocation.\n * jQuery(window).on('popstate', throttled.cancel)\n */\nfunction throttle(func, wait, options) {\n  let leading = true;\n  let trailing = true;\n\n  if (typeof func !== 'function') {\n    throw new TypeError('Expected a function');\n  }\n  if (isObject(options)) {\n    leading = 'leading' in options ? Boolean(options.leading) : leading;\n    trailing = 'trailing' in options ? Boolean(options.trailing) : trailing;\n  }\n\n  return debounce(func, wait, {\n    leading,\n    trailing,\n    maxWait: wait,\n  });\n}\n\nexport default throttle;\n","import { IDistance, IPoints, ITouchPoints } from '../../types';\nimport { Types } from '@cornerstonejs/core';\n\n/**\n * Returns the difference between multiple `IPoints` instances.\n * @param currentPoints - The current points.\n * @param lastPoints - The last points, to be subtracted from the `currentPoints`.\n *\n * @returns The difference in IPoints format\n */\nfunction getDeltaPoints(\n  currentPoints: IPoints[],\n  lastPoints: IPoints[]\n): IPoints {\n  const curr = getMeanPoints(currentPoints);\n  const last = getMeanPoints(lastPoints);\n  return {\n    page: _subtractPoints2D(curr.page, last.page),\n    client: _subtractPoints2D(curr.client, last.client),\n    canvas: _subtractPoints2D(curr.canvas, last.canvas),\n    world: _subtractPoints3D(curr.world, last.world),\n  };\n}\n\n/**\n * Returns the distance between multiple `IPoints` instances.\n * @param currentPoints - The current points.\n * @param lastPoints - The last points, to be subtracted from the `currentPoints`.\n *\n * @returns The distance difference in IDistance format\n */\nfunction getDeltaDistance(\n  currentPoints: IPoints[],\n  lastPoints: IPoints[]\n): IDistance {\n  const curr = getMeanPoints(currentPoints);\n  const last = getMeanPoints(lastPoints);\n  return {\n    page: _getDistance2D(curr.page, last.page),\n    client: _getDistance2D(curr.client, last.client),\n    canvas: _getDistance2D(curr.canvas, last.canvas),\n    world: _getDistance3D(curr.world, last.world),\n  };\n}\n\nfunction getDeltaRotation(\n  currentPoints: ITouchPoints[],\n  lastPoints: ITouchPoints[]\n) {\n  // TODO\n}\n\n/**\n * Returns the distance difference between multiple `IPoints` instances.\n * @param currentPoints - The current points.\n * @param lastPoints -- The last points.\n *\n * @returns The difference in IPoints format\n */\nfunction getDeltaDistanceBetweenIPoints(\n  currentPoints: IPoints[],\n  lastPoints: IPoints[]\n): IDistance {\n  const currentDistance = _getMeanDistanceBetweenAllIPoints(currentPoints);\n  const lastDistance = _getMeanDistanceBetweenAllIPoints(lastPoints);\n  const deltaDistance = {\n    page: currentDistance.page - lastDistance.page,\n    client: currentDistance.client - lastDistance.client,\n    canvas: currentDistance.canvas - lastDistance.canvas,\n    world: currentDistance.world - lastDistance.world,\n  };\n  return deltaDistance;\n}\n\n/**\n * Copies a set of points.\n * @param points - The `IPoints` instance to copy.\n *\n * @returns A copy of the points.\n */\nfunction copyPointsList(points: ITouchPoints[]): ITouchPoints[] {\n  return JSON.parse(JSON.stringify(points));\n}\n\nfunction copyPoints(points: ITouchPoints): ITouchPoints {\n  return JSON.parse(JSON.stringify(points));\n}\n\nfunction getMeanPoints(points: IPoints[]): IPoints {\n  return points.reduce(\n    (prev, curr) => {\n      return {\n        page: [\n          prev.page[0] + curr.page[0] / points.length,\n          prev.page[1] + curr.page[1] / points.length,\n        ],\n        client: [\n          prev.client[0] + curr.client[0] / points.length,\n          prev.client[1] + curr.client[1] / points.length,\n        ],\n        canvas: [\n          prev.canvas[0] + curr.canvas[0] / points.length,\n          prev.canvas[1] + curr.canvas[1] / points.length,\n        ],\n        world: [\n          prev.world[0] + curr.world[0] / points.length,\n          prev.world[1] + curr.world[1] / points.length,\n          prev.world[2] + curr.world[2] / points.length,\n        ],\n      };\n    },\n    {\n      page: [0, 0],\n      client: [0, 0],\n      canvas: [0, 0],\n      world: [0, 0, 0],\n    }\n  );\n}\n\nfunction getMeanTouchPoints(points: ITouchPoints[]): ITouchPoints {\n  return points.reduce(\n    (prev, curr) => {\n      return {\n        page: [\n          prev.page[0] + curr.page[0] / points.length,\n          prev.page[1] + curr.page[1] / points.length,\n        ],\n        client: [\n          prev.client[0] + curr.client[0] / points.length,\n          prev.client[1] + curr.client[1] / points.length,\n        ],\n        canvas: [\n          prev.canvas[0] + curr.canvas[0] / points.length,\n          prev.canvas[1] + curr.canvas[1] / points.length,\n        ],\n        world: [\n          prev.world[0] + curr.world[0] / points.length,\n          prev.world[1] + curr.world[1] / points.length,\n          prev.world[2] + curr.world[2] / points.length,\n        ],\n        touch: {\n          identifier: null,\n          radiusX: prev.touch.radiusX + curr.touch.radiusX / points.length,\n          radiusY: prev.touch.radiusY + curr.touch.radiusY / points.length,\n          force: prev.touch.force + curr.touch.force / points.length,\n          rotationAngle:\n            prev.touch.rotationAngle + curr.touch.rotationAngle / points.length,\n        },\n      };\n    },\n    {\n      page: [0, 0],\n      client: [0, 0],\n      canvas: [0, 0],\n      world: [0, 0, 0],\n      touch: {\n        identifier: null,\n        radiusX: 0,\n        radiusY: 0,\n        force: 0,\n        rotationAngle: 0,\n      },\n    }\n  );\n}\n/**\n * _subtractPoints - Subtracts `point1` from `point0`.\n * @param point0 - The first point.\n * @param point1 - The second point to subtract from the first.\n *\n * @returns The difference.\n */\nfunction _subtractPoints2D(\n  point0: Types.Point2,\n  point1: Types.Point2\n): Types.Point2 {\n  return [point0[0] - point1[0], point0[1] - point1[1]];\n}\n\nfunction _subtractPoints3D(\n  point0: Types.Point3,\n  point1: Types.Point3\n): Types.Point3 {\n  return [point0[0] - point1[0], point0[1] - point1[1], point0[2] - point1[2]];\n}\n\nfunction _getMeanDistanceBetweenAllIPoints(points: IPoints[]): IDistance {\n  // get mean distance between all unordered pairs of points\n  const pairedDistance: IDistance[] = [];\n  for (let i = 0; i < points.length; i++) {\n    for (let j = 0; j < points.length; j++) {\n      if (i < j) {\n        pairedDistance.push({\n          page: _getDistance2D(points[i].page, points[j].page),\n          client: _getDistance2D(points[i].client, points[j].client),\n          canvas: _getDistance2D(points[i].canvas, points[j].canvas),\n          world: _getDistance3D(points[i].world, points[j].world),\n        });\n      }\n    }\n  }\n\n  // take the average distance\n  return pairedDistance.reduce(\n    (prev, curr) => {\n      return {\n        page: prev.page + curr.page / pairedDistance.length,\n        client: prev.client + curr.client / pairedDistance.length,\n        canvas: prev.canvas + curr.canvas / pairedDistance.length,\n        world: prev.world + curr.world / pairedDistance.length,\n      };\n    },\n    {\n      page: 0,\n      client: 0,\n      canvas: 0,\n      world: 0,\n    }\n  );\n}\n\nfunction _getDistance2D(point0: Types.Point2, point1: Types.Point2): number {\n  return Math.sqrt(\n    Math.pow(point0[0] - point1[0], 2) + Math.pow(point0[1] - point1[1], 2)\n  );\n}\n\nfunction _getDistance3D(point0: Types.Point3, point1: Types.Point3): number {\n  return Math.sqrt(\n    Math.pow(point0[0] - point1[0], 2) +\n      Math.pow(point0[1] - point1[1], 2) +\n      Math.pow(point0[2] - point1[2], 2)\n  );\n}\n\nexport {\n  getMeanPoints,\n  getMeanTouchPoints,\n  copyPoints,\n  copyPointsList,\n  getDeltaDistanceBetweenIPoints,\n  getDeltaPoints,\n  getDeltaDistance,\n  getDeltaRotation,\n};\n","import { getRenderingEngine, type Types } from '@cornerstonejs/core';\nimport triggerAnnotationRender from './triggerAnnotationRender';\nimport { getToolGroup } from '../store/ToolGroupManager';\n\n/**\n * Triggers annotation rendering for the specified tool group IDs.\n *\n * @param toolGroupIds - An array of tool group IDs.\n */\nexport function triggerAnnotationRenderForToolGroupIds(\n  toolGroupIds: string[]\n): void {\n  toolGroupIds.forEach((toolGroupId) => {\n    const toolGroup = getToolGroup(toolGroupId);\n\n    if (!toolGroup) {\n      console.warn(`ToolGroup not available for ${toolGroupId}`);\n      return;\n    }\n\n    const viewportsInfo = toolGroup.getViewportsInfo();\n\n    viewportsInfo.forEach((viewportInfo) => {\n      const { renderingEngineId, viewportId } = viewportInfo;\n\n      const renderingEngine = getRenderingEngine(renderingEngineId);\n      if (!renderingEngine) {\n        console.warn(`RenderingEngine not available for ${renderingEngineId}`);\n        return;\n      }\n\n      const viewport = renderingEngine.getViewport(viewportId);\n      triggerAnnotationRender(viewport.element);\n    });\n  });\n}\n\nexport default triggerAnnotationRenderForToolGroupIds;\n","import {\n  cache,\n  StackViewport,\n  Types,\n  BaseVolumeViewport,\n} from '@cornerstonejs/core';\n\nfunction isViewportPreScaled(\n  viewport: Types.IStackViewport | Types.IVolumeViewport,\n  targetId: string\n): boolean {\n  if (viewport instanceof BaseVolumeViewport) {\n    const targetIdTokens = targetId.split('volumeId:');\n    const volumeId =\n      targetIdTokens.length > 1\n        ? targetIdTokens[1].split('?')[0]\n        : targetIdTokens[0];\n    const volume = cache.getVolume(volumeId);\n    return !!volume?.scaling && Object.keys(volume.scaling).length > 0;\n  } else if (viewport instanceof StackViewport) {\n    const { preScale } = viewport.getImageData() || {};\n    return !!preScale?.scaled;\n  } else {\n    return false;\n  }\n}\n\nexport { isViewportPreScaled };\n","import { VolumeViewport } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { vec3 } from 'gl-matrix';\n\n// Todo: merge this utility functionality with Crosshair _jump\n/**\n * Uses the viewport's current camera to jump to a specific world coordinate\n * @param enabledElement - enabled element\n * @param jumpWorld - location in the world to jump to\n * @returns True if successful\n */\nexport default function jumpToWorld(\n  viewport: Types.IVolumeViewport,\n  jumpWorld: Types.Point3\n): true | undefined {\n  // if not instance of volumeViewport, return\n  if (!(viewport instanceof VolumeViewport)) {\n    return;\n  }\n\n  const { focalPoint } = viewport.getCamera();\n\n  const delta: Types.Point3 = [0, 0, 0];\n  vec3.sub(delta, jumpWorld, focalPoint);\n\n  _applyShift(viewport, delta);\n\n  return true;\n}\n\nfunction _applyShift(viewport, delta) {\n  const camera = viewport.getCamera();\n  const normal = camera.viewPlaneNormal;\n\n  const dotProd = vec3.dot(delta, normal);\n  const projectedDelta = vec3.fromValues(normal[0], normal[1], normal[2]);\n\n  vec3.scale(projectedDelta, projectedDelta, dotProd);\n\n  if (\n    Math.abs(projectedDelta[0]) > 1e-3 ||\n    Math.abs(projectedDelta[1]) > 1e-3 ||\n    Math.abs(projectedDelta[2]) > 1e-3\n  ) {\n    const newFocalPoint: Types.Point3 = [0, 0, 0];\n    const newPosition: Types.Point3 = [0, 0, 0];\n\n    vec3.add(newFocalPoint, camera.focalPoint, projectedDelta);\n    vec3.add(newPosition, camera.position, projectedDelta);\n\n    viewport.setCamera({\n      focalPoint: newFocalPoint,\n      position: newPosition,\n    });\n    viewport.render();\n  }\n}\n","import type { Types } from '@cornerstonejs/core';\nimport type { IToolGroup } from '../../types';\nimport { ToolGroupManager } from '../../store';\nimport { ToolModes } from '../../enums';\n\nconst { Active, Passive, Enabled } = ToolModes;\n\n/**\n * Given an array of viewports, returns a list of viewports that have the the specified tool enabled.\n *\n * @param viewports - An array of viewports.\n * @param toolName - The name of the tool to filter on.\n *\n * @returns A filtered array of viewports.\n */\nexport default function filterViewportsWithToolEnabled(\n  viewports: Array<Types.IViewport>,\n  toolName: string\n): Array<Types.IStackViewport | Types.IVolumeViewport> {\n  const numViewports = viewports.length;\n\n  const viewportsWithToolEnabled = [];\n\n  for (let vp = 0; vp < numViewports; vp++) {\n    const viewport = viewports[vp];\n\n    const toolGroup = ToolGroupManager.getToolGroupForViewport(\n      viewport.id,\n      viewport.renderingEngineId\n    );\n\n    if (!toolGroup) {\n      continue;\n    }\n\n    const hasTool = _toolGroupHasActiveEnabledOrPassiveTool(\n      toolGroup,\n      toolName\n    );\n\n    if (hasTool) {\n      viewportsWithToolEnabled.push(viewport);\n    }\n  }\n\n  return viewportsWithToolEnabled;\n}\n\n/**\n * Given a toolGroup, return true if it contains the tool with the given `toolName` and it is\n * active, passive or enabled.\n *\n * @param toolGroup - The `toolGroup` to check.\n * @param toolName - The name of the tool.\n *\n * @returns True if the tool is enabled, passive or active in the `toolGroup`.\n */\nfunction _toolGroupHasActiveEnabledOrPassiveTool(\n  toolGroup: IToolGroup,\n  toolName: string\n) {\n  const { toolOptions } = toolGroup;\n  const tool = toolOptions[toolName];\n\n  if (!tool) {\n    return false;\n  }\n\n  const toolMode = tool.mode;\n\n  return toolMode === Active || toolMode === Passive || toolMode === Enabled;\n}\n","import { vec3 } from 'gl-matrix';\n\n/**\n * It filters the viewports that are looking in the same view as the camera\n * It basically checks if the viewPlaneNormal is parallel to the camera viewPlaneNormal\n * @param viewports - Array of viewports to filter\n * @param camera - Camera to compare against\n * @returns - Array of viewports with the same view\n */\nexport function filterViewportsWithParallelNormals(\n  viewports,\n  camera,\n  EPS = 0.999\n) {\n  return viewports.filter((viewport) => {\n    const vpCamera = viewport.getCamera();\n\n    const isParallel =\n      Math.abs(vec3.dot(vpCamera.viewPlaneNormal, camera.viewPlaneNormal)) >\n      EPS;\n\n    return isParallel;\n  });\n}\n\nexport default filterViewportsWithParallelNormals;\n","import { getEnabledElement } from '@cornerstonejs/core';\nimport filterViewportsWithFrameOfReferenceUID from './filterViewportsWithFrameOfReferenceUID';\nimport filterViewportsWithToolEnabled from './filterViewportsWithToolEnabled';\nimport filterViewportsWithParallelNormals from './filterViewportsWithParallelNormals';\n\n/**\n * Given a cornerstone3D enabled `element`, and a `toolName`, find all viewportIds\n * looking at the same Frame Of Reference that have the tool with the given `toolName`\n * active, passive or enabled.\n *\n * @param element - The target cornerstone3D enabled element.\n * @param toolName - The string toolName.\n * @param requireParallelNormals - If true, only return viewports that have parallel normals.\n *\n * @returns An array of viewportIds.\n */\nexport default function getViewportIdsWithToolToRender(\n  element: HTMLDivElement,\n  toolName: string,\n  requireParallelNormals = true\n): string[] {\n  const enabledElement = getEnabledElement(element);\n  const { renderingEngine, FrameOfReferenceUID } = enabledElement;\n\n  let viewports = renderingEngine.getViewports();\n\n  viewports = filterViewportsWithFrameOfReferenceUID(\n    viewports,\n    FrameOfReferenceUID\n  );\n  viewports = filterViewportsWithToolEnabled(viewports, toolName);\n\n  const viewport = renderingEngine.getViewport(enabledElement.viewportId);\n\n  if (requireParallelNormals) {\n    viewports = filterViewportsWithParallelNormals(\n      viewports,\n      viewport.getCamera()\n    );\n  }\n\n  const viewportIds = viewports.map((vp) => vp.id);\n\n  return viewportIds;\n}\n","import type { Types } from '@cornerstonejs/core';\n\n/**\n * Given an array of viewports, returns a list of viewports that are viewing a\n * world space with the given `FrameOfReferenceUID`.\n *\n * @param viewports - An array of viewports.\n * @param FrameOfReferenceUID - The UID defining a particular world space/Frame Of Reference.\n *\n * @returns A filtered array of viewports.\n */\nexport default function filterViewportsWithFrameOfReferenceUID(\n  viewports: Array<Types.IViewport>,\n  FrameOfReferenceUID: string\n): Array<Types.IStackViewport | Types.IVolumeViewport> {\n  const numViewports = viewports.length;\n  const viewportsWithFrameOfReferenceUID = [];\n\n  for (let vp = 0; vp < numViewports; vp++) {\n    const viewport = viewports[vp];\n\n    if (viewport.getFrameOfReferenceUID() === FrameOfReferenceUID) {\n      viewportsWithFrameOfReferenceUID.push(viewport);\n    }\n  }\n\n  return viewportsWithFrameOfReferenceUID;\n}\n","import { IColorMapPreset } from '@kitware/vtk.js/Rendering/Core/ColorTransferFunction/ColorMaps';\nimport { vec2 } from 'gl-matrix';\nimport { utilities as csUtils, Types } from '@cornerstonejs/core';\nimport type { ColorbarProps, ColorbarVOIRange } from './types';\nimport { isRangeValid, areColorbarRangesEqual } from './common';\nimport { ColorbarRangeTextPosition } from './enums/ColorbarRangeTextPosition';\nimport { ColorbarCanvas } from './ColorbarCanvas';\nimport { ColorbarTicks } from './ColorbarTicks';\nimport isRangeTextPositionValid from './common/isRangeTextPositionValid';\nimport Widget from '../../../widgets/Widget';\n\nconst DEFAULTS = {\n  MULTIPLIER: 1,\n  RANGE_TEXT_POSITION: ColorbarRangeTextPosition.Right,\n  TICKS_BAR_SIZE: 50,\n};\n\ntype ColorbarPoints = {\n  page: Types.Point2;\n  client: Types.Point2;\n  local: Types.Point2;\n};\n\n/**\n * A base colorbar class that is not associated with any viewport. It is\n * possible to click and drag to change the VOI range, shows the ticks during\n * interaction and it can show full image range or VOI range.\n */\nclass Colorbar extends Widget {\n  private _colormaps: Map<string, IColorMapPreset>;\n  private _activeColormapName: string;\n  private _eventListenersManager: csUtils.eventListener.MultiTargetEventListenerManager;\n  private _canvas: ColorbarCanvas;\n  private _ticksBar: ColorbarTicks;\n  private _rangeTextPosition: ColorbarRangeTextPosition;\n\n  private _isMouseOver = false;\n  private _isInteracting = false;\n\n  constructor(props: ColorbarProps) {\n    super(props);\n\n    this._eventListenersManager =\n      new csUtils.eventListener.MultiTargetEventListenerManager();\n    this._colormaps = Colorbar.getColormapsMap(props);\n    this._activeColormapName = Colorbar.getInitialColormapName(props);\n    this._canvas = this._createCanvas(props);\n    this._ticksBar = this._createTicksBar(props);\n    this._rangeTextPosition =\n      props.ticks?.position ?? DEFAULTS.RANGE_TEXT_POSITION;\n\n    this._canvas.appendTo(this.rootElement);\n    this._ticksBar.appendTo(this.rootElement);\n\n    this._addRootElementEventListeners();\n  }\n\n  /**\n   * Returns the active LUT name\n   */\n  public get activeColormapName() {\n    return this._activeColormapName;\n  }\n\n  /**\n   * Set the current active LUT name and re-renders the color bar\n   */\n  public set activeColormapName(colormapName: string) {\n    if (colormapName === this._activeColormapName) {\n      return;\n    }\n\n    const colormap = this._colormaps.get(colormapName);\n\n    if (!colormap) {\n      console.warn(`Invalid colormap name (${colormapName})`);\n      return;\n    }\n\n    this._activeColormapName = colormapName;\n    this._canvas.colormap = colormap;\n  }\n\n  public get imageRange() {\n    return this._canvas.imageRange;\n  }\n\n  public set imageRange(imageRange: ColorbarVOIRange) {\n    this._canvas.imageRange = imageRange;\n    this._ticksBar.imageRange = imageRange;\n  }\n\n  public get voiRange() {\n    return this._canvas.voiRange;\n  }\n\n  public set voiRange(voiRange: ColorbarVOIRange) {\n    const { voiRange: currentVoiRange } = this._canvas;\n\n    if (\n      !isRangeValid(voiRange) ||\n      areColorbarRangesEqual(voiRange, currentVoiRange)\n    ) {\n      return;\n    }\n\n    this._canvas.voiRange = voiRange;\n    this._ticksBar.voiRange = voiRange;\n    this.onVoiChange(voiRange);\n  }\n\n  public get showFullImageRange() {\n    return this._canvas.showFullImageRange;\n  }\n\n  public set showFullImageRange(value: boolean) {\n    this._canvas.showFullImageRange = value;\n    this._ticksBar.showFullPixelValueRange = value;\n  }\n\n  public destroy() {\n    super.destroy();\n    this._eventListenersManager.reset();\n  }\n\n  protected createRootElement(): HTMLElement {\n    const rootElement = document.createElement('div');\n\n    Object.assign(rootElement.style, {\n      position: 'relative',\n      fontSize: '0',\n      width: '100%',\n      height: '100%',\n    });\n\n    return rootElement;\n  }\n\n  protected onContainerResize() {\n    super.onContainerResize();\n    this.updateTicksBar();\n    this._canvas.size = this.containerSize;\n  }\n\n  protected getVOIMultipliers(): [number, number] {\n    return [DEFAULTS.MULTIPLIER, DEFAULTS.MULTIPLIER];\n  }\n\n  protected onVoiChange(voiRange: ColorbarVOIRange) {\n    // no-op\n  }\n\n  protected showTicks() {\n    this.updateTicksBar();\n    this._ticksBar.visible = true;\n  }\n\n  protected hideTicks() {\n    if (this._isInteracting || this._isMouseOver) {\n      return;\n    }\n\n    this._ticksBar.visible = false;\n  }\n\n  private static getColormapsMap(props: ColorbarProps) {\n    const { colormaps } = props;\n\n    return colormaps.reduce(\n      (items, item) => items.set(item.Name, item),\n      new Map<string, IColorMapPreset>()\n    );\n  }\n\n  private static getInitialColormapName(props: ColorbarProps) {\n    const { activeColormapName, colormaps } = props;\n    const colormapExists =\n      !!activeColormapName &&\n      colormaps.some((cm) => cm.Name === activeColormapName);\n\n    return colormapExists ? activeColormapName : colormaps[0].Name;\n  }\n\n  private _createCanvas(props: ColorbarProps) {\n    const { imageRange, voiRange, showFullPixelValueRange } = props;\n    const colormap = this._colormaps.get(this._activeColormapName);\n\n    return new ColorbarCanvas({\n      colormap,\n      imageRange,\n      voiRange: voiRange,\n      showFullPixelValueRange,\n    });\n  }\n\n  public _createTicksBar(props: ColorbarProps): ColorbarTicks {\n    const ticksProps = props.ticks;\n\n    return new ColorbarTicks({\n      imageRange: props.imageRange,\n      voiRange: props.voiRange,\n      ticks: ticksProps,\n      showFullPixelValueRange: props.showFullPixelValueRange,\n    });\n  }\n\n  private _getPointsFromMouseEvent(evt: MouseEvent): ColorbarPoints {\n    const { rootElement: element } = this;\n    const clientPoint: Types.Point2 = [evt.clientX, evt.clientY];\n    const pagePoint: Types.Point2 = [evt.pageX, evt.pageY];\n    const rect = element.getBoundingClientRect();\n    const localPoints: Types.Point2 = [\n      pagePoint[0] - rect.left - window.pageXOffset,\n      pagePoint[1] - rect.top - window.pageYOffset,\n    ];\n\n    return { client: clientPoint, page: pagePoint, local: localPoints };\n  }\n\n  private updateTicksBar() {\n    const { width: containerWidth, height: containerHeight } =\n      this.containerSize;\n\n    // ResizeObserver have not triggered any event when this happen\n    if (containerWidth === 0 && containerHeight === 0) {\n      return;\n    }\n\n    const { _ticksBar: ticksBar, _rangeTextPosition: rangeTextPosition } = this;\n    const isHorizontal = containerWidth >= containerHeight;\n    const width = isHorizontal ? containerWidth : DEFAULTS.TICKS_BAR_SIZE;\n    const height = isHorizontal ? DEFAULTS.TICKS_BAR_SIZE : containerHeight;\n\n    if (\n      !isRangeTextPositionValid(\n        containerWidth,\n        containerHeight,\n        rangeTextPosition\n      )\n    ) {\n      throw new Error(\n        'Invalid rangeTextPosition value for the current colobar orientation'\n      );\n    }\n\n    let ticksBarTop;\n    let ticksBarLeft;\n\n    ticksBar.size = { width, height };\n\n    if (isHorizontal) {\n      ticksBarLeft = 0;\n      ticksBarTop =\n        rangeTextPosition === ColorbarRangeTextPosition.Top\n          ? -height\n          : containerHeight;\n    } else {\n      ticksBarTop = 0;\n      ticksBarLeft =\n        rangeTextPosition === ColorbarRangeTextPosition.Left\n          ? -width\n          : containerWidth;\n    }\n\n    ticksBar.top = ticksBarTop;\n    ticksBar.left = ticksBarLeft;\n  }\n\n  private _mouseOverCallback = (evt) => {\n    this._isMouseOver = true;\n    this.showTicks();\n    evt.stopPropagation();\n  };\n\n  private _mouseOutCallback = (evt) => {\n    this._isMouseOver = false;\n    this.hideTicks();\n    evt.stopPropagation();\n  };\n\n  private _mouseDownCallback = (evt: MouseEvent) => {\n    this._isInteracting = true;\n    this.showTicks();\n    this._addVOIEventListeners(evt);\n    evt.stopPropagation();\n  };\n\n  private _mouseDragCallback = (evt, initialState) => {\n    const multipliers = this.getVOIMultipliers();\n    const currentPoints = this._getPointsFromMouseEvent(evt);\n    const { points: startPoints, voiRange: startVOIRange } = initialState;\n    const canvasDelta = vec2.sub(\n      vec2.create(),\n      currentPoints.local,\n      startPoints.local\n    );\n\n    const wwDelta = canvasDelta[0] * multipliers[0];\n    const wcDelta = canvasDelta[1] * multipliers[1];\n\n    if (!wwDelta && !wcDelta) {\n      return;\n    }\n\n    const { lower: voiLower, upper: voiUpper } = startVOIRange;\n    let { windowWidth, windowCenter } = csUtils.windowLevel.toWindowLevel(\n      voiLower,\n      voiUpper\n    );\n\n    windowWidth = Math.max(windowWidth + wwDelta, 1);\n    windowCenter += wcDelta;\n\n    const newVoiRange = csUtils.windowLevel.toLowHighRange(\n      windowWidth,\n      windowCenter\n    );\n\n    this.voiRange = newVoiRange;\n    evt.stopPropagation();\n    evt.preventDefault();\n  };\n\n  private _mouseUpCallback = (evt) => {\n    this._isInteracting = false;\n    this.hideTicks();\n    this._removeVOIEventListeners();\n    evt.stopPropagation();\n  };\n\n  private _addRootElementEventListeners() {\n    const { _eventListenersManager: manager } = this;\n    const { rootElement: element } = this;\n\n    manager.addEventListener(element, 'mouseover', this._mouseOverCallback);\n    manager.addEventListener(element, 'mouseout', this._mouseOutCallback);\n    manager.addEventListener(\n      element,\n      'mousedown',\n      this._mouseDownCallback as EventListener\n    );\n  }\n\n  private _addVOIEventListeners(evt: MouseEvent) {\n    const { _eventListenersManager: manager } = this;\n    const points = this._getPointsFromMouseEvent(evt);\n    const voiRange = { ...this._canvas.voiRange };\n    const initialDragState = { points, voiRange };\n\n    this._removeVOIEventListeners();\n\n    manager.addEventListener(document, 'voi.mouseup', this._mouseUpCallback);\n    manager.addEventListener(document, 'voi.mousemove', (evt) =>\n      this._mouseDragCallback(evt, initialDragState)\n    );\n  }\n\n  private _removeVOIEventListeners() {\n    const { _eventListenersManager: manager } = this;\n\n    manager.removeEventListener(document, 'voi.mouseup');\n    manager.removeEventListener(document, 'voi.mousemove');\n  }\n}\n\nexport { Colorbar as default, Colorbar };\n","import {\n  eventTarget,\n  VolumeViewport,\n  StackViewport,\n  Types,\n  Enums,\n  utilities,\n  getEnabledElement,\n} from '@cornerstonejs/core';\nimport { Colorbar } from './Colorbar';\nimport type { ViewportColorbarProps, ColorbarVOIRange } from './types';\nimport { getVOIMultipliers } from '../../getVOIMultipliers';\n\nconst { Events } = Enums;\nconst defaultImageRange = { lower: -1000, upper: 1000 };\n/**\n * A colorbar associated with a viewport that updates automatically when the\n * viewport VOI changes or when the stack/volume are updated..\n */\nclass ViewportColorbar extends Colorbar {\n  private _element: HTMLDivElement;\n  private _volumeId: string;\n\n  private _hideTicksTime: number;\n  private _hideTicksTimeoutId: number;\n\n  constructor(props: ViewportColorbarProps) {\n    const { element, volumeId } = props;\n    const imageRange = ViewportColorbar._getImageRange(element, volumeId);\n    const voiRange = ViewportColorbar._getVOIRange(element, volumeId);\n\n    super({ ...props, imageRange, voiRange });\n\n    this._element = element;\n    this._volumeId = volumeId;\n\n    this._addCornerstoneEventListener();\n  }\n\n  public get element() {\n    return this._element;\n  }\n\n  public get enabledElement() {\n    return getEnabledElement(this._element);\n  }\n\n  protected getVOIMultipliers(): [number, number] {\n    const { viewport } = this.enabledElement;\n    return getVOIMultipliers(viewport, this._volumeId);\n  }\n\n  protected onVoiChange(voiRange: ColorbarVOIRange) {\n    super.onVoiChange(voiRange);\n\n    const { viewport } = this.enabledElement;\n\n    if (viewport instanceof StackViewport) {\n      viewport.setProperties({\n        voiRange: voiRange,\n      });\n      viewport.render();\n    } else if (viewport instanceof VolumeViewport) {\n      const { _volumeId: volumeId } = this;\n      const viewportsContainingVolumeUID = utilities.getViewportsWithVolumeId(\n        volumeId,\n        viewport.renderingEngineId\n      );\n\n      viewport.setProperties({ voiRange }, volumeId);\n      viewportsContainingVolumeUID.forEach((vp) => vp.render());\n    }\n  }\n\n  private static _getImageRange(element, volumeId?) {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n\n    const actor = volumeId\n      ? viewport.getActor(volumeId)\n      : viewport.getDefaultActor();\n\n    if (!actor) {\n      return defaultImageRange;\n    }\n\n    const imageData = actor.actor.getMapper().getInputData();\n    const imageRange = imageData.getPointData().getScalars().getRange();\n\n    return imageRange[0] === 0 && imageRange[1] === 0\n      ? defaultImageRange\n      : { lower: imageRange[0], upper: imageRange[1] };\n  }\n\n  private static _getVOIRange(element, volumeId) {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n\n    const volumeActor = volumeId\n      ? viewport.getActor(volumeId)\n      : viewport.getDefaultActor();\n\n    if (!volumeActor || !utilities.isImageActor(volumeActor)) {\n      return defaultImageRange;\n    }\n\n    const voiRange = (volumeActor.actor as Types.ImageActor)\n      .getProperty()\n      .getRGBTransferFunction(0)\n      .getRange();\n\n    return voiRange[0] === 0 && voiRange[1] === 0\n      ? defaultImageRange\n      : { lower: voiRange[0], upper: voiRange[1] };\n  }\n\n  private autoHideTicks = () => {\n    // Avoiding calling setTimeout multiple times when manipulating the VOI\n    // via WindowLevel tool for better performance\n    if (this._hideTicksTimeoutId) {\n      return;\n    }\n\n    const timeLeft = this._hideTicksTime - Date.now();\n\n    if (timeLeft <= 0) {\n      this.hideTicks();\n    } else {\n      this._hideTicksTimeoutId = window.setTimeout(() => {\n        // Recursive call until there is no more time left\n        this._hideTicksTimeoutId = 0;\n        this.autoHideTicks();\n      }, timeLeft);\n    }\n  };\n\n  private showAndAutoHideTicks(interval = 1000) {\n    this._hideTicksTime = Date.now() + interval;\n    this.showTicks();\n    this.autoHideTicks();\n  }\n\n  private _stackNewImageCallback = () => {\n    this.imageRange = ViewportColorbar._getImageRange(this._element);\n  };\n\n  private _imageVolumeModifiedCallback = (\n    evt: Types.EventTypes.ImageVolumeModifiedEvent\n  ) => {\n    const { volumeId } = evt.detail.imageVolume;\n\n    if (volumeId !== this._volumeId) {\n      return;\n    }\n\n    const { _element: element } = this;\n    this.imageRange = ViewportColorbar._getImageRange(element, volumeId);\n  };\n\n  private _viewportVOIModifiedCallback = (\n    evt: Types.EventTypes.VoiModifiedEvent\n  ) => {\n    const { viewportId, volumeId, range: voiRange, colormap } = evt.detail;\n    const { viewport } = this.enabledElement;\n    if (viewportId !== viewport.id || volumeId !== this._volumeId) {\n      return;\n    }\n\n    this.voiRange = voiRange;\n\n    if (colormap) {\n      this.activeColormapName = colormap.name;\n    }\n    this.showAndAutoHideTicks();\n  };\n\n  private _viewportColormapModifiedCallback = (\n    evt: Types.EventTypes.ColormapModifiedEvent\n  ) => {\n    const { viewportId, colormap, volumeId } = evt.detail;\n    const { viewport } = this.enabledElement;\n\n    if (viewportId !== viewport.id || volumeId !== this._volumeId) {\n      return;\n    }\n\n    this.activeColormapName = colormap.name;\n  };\n\n  private _addCornerstoneEventListener() {\n    const { _element: element } = this;\n\n    eventTarget.addEventListener(\n      Events.IMAGE_VOLUME_MODIFIED,\n      this._imageVolumeModifiedCallback\n    );\n\n    element.addEventListener(\n      Events.STACK_NEW_IMAGE,\n      this._stackNewImageCallback\n    );\n\n    element.addEventListener(\n      Events.VOI_MODIFIED,\n      this._viewportVOIModifiedCallback as EventListener\n    );\n\n    element.addEventListener(\n      Events.COLORMAP_MODIFIED,\n      this._viewportColormapModifiedCallback as EventListener\n    );\n  }\n}\n\nexport { ViewportColorbar as default, ViewportColorbar };\n","/**\n * Specify the position of the text/ticks.\n * Left/Right are the valid options for a vertical colorbars and Top/Bottom\n * for the horizontal ones.\n */\nexport enum ColorbarRangeTextPosition {\n  Top = 'top',\n  Left = 'left',\n  Bottom = 'bottom',\n  Right = 'right',\n}\n","\nvar ICRPolySegApp = (() => {\n  var _scriptDir = typeof document !== 'undefined' && document.currentScript ? document.currentScript.src : undefined;\n  \n  return (\nfunction(ICRPolySegApp) {\n  ICRPolySegApp = ICRPolySegApp || {};\n\nvar Module=typeof ICRPolySegApp!=\"undefined\"?ICRPolySegApp:{};var readyPromiseResolve,readyPromiseReject;Module[\"ready\"]=new Promise(function(resolve,reject){readyPromiseResolve=resolve;readyPromiseReject=reject});var moduleOverrides=Object.assign({},Module);var arguments_=[];var thisProgram=\"./this.program\";var quit_=(status,toThrow)=>{throw toThrow};var ENVIRONMENT_IS_WEB=true;var ENVIRONMENT_IS_WORKER=false;var scriptDirectory=\"\";function locateFile(path){if(Module[\"locateFile\"]){return Module[\"locateFile\"](path,scriptDirectory)}return scriptDirectory+path}var read_,readAsync,readBinary,setWindowTitle;if(ENVIRONMENT_IS_WEB||ENVIRONMENT_IS_WORKER){if(ENVIRONMENT_IS_WORKER){scriptDirectory=self.location.href}else if(typeof document!=\"undefined\"&&document.currentScript){scriptDirectory=document.currentScript.src}if(_scriptDir){scriptDirectory=_scriptDir}if(scriptDirectory.indexOf(\"blob:\")!==0){scriptDirectory=scriptDirectory.substr(0,scriptDirectory.replace(/[?#].*/,\"\").lastIndexOf(\"/\")+1)}else{scriptDirectory=\"\"}{read_=url=>{var xhr=new XMLHttpRequest;xhr.open(\"GET\",url,false);xhr.send(null);return xhr.responseText};if(ENVIRONMENT_IS_WORKER){readBinary=url=>{var xhr=new XMLHttpRequest;xhr.open(\"GET\",url,false);xhr.responseType=\"arraybuffer\";xhr.send(null);return new Uint8Array(xhr.response)}}readAsync=(url,onload,onerror)=>{var xhr=new XMLHttpRequest;xhr.open(\"GET\",url,true);xhr.responseType=\"arraybuffer\";xhr.onload=()=>{if(xhr.status==200||xhr.status==0&&xhr.response){onload(xhr.response);return}onerror()};xhr.onerror=onerror;xhr.send(null)}}setWindowTitle=title=>document.title=title}else{}var out=Module[\"print\"]||console.log.bind(console);var err=Module[\"printErr\"]||console.warn.bind(console);Object.assign(Module,moduleOverrides);moduleOverrides=null;if(Module[\"arguments\"])arguments_=Module[\"arguments\"];if(Module[\"thisProgram\"])thisProgram=Module[\"thisProgram\"];if(Module[\"quit\"])quit_=Module[\"quit\"];var POINTER_SIZE=4;var wasmBinary;if(Module[\"wasmBinary\"])wasmBinary=Module[\"wasmBinary\"];var noExitRuntime=Module[\"noExitRuntime\"]||true;if(typeof WebAssembly!=\"object\"){abort(\"no native wasm support detected\")}var wasmMemory;var ABORT=false;var EXITSTATUS;var UTF8Decoder=typeof TextDecoder!=\"undefined\"?new TextDecoder(\"utf8\"):undefined;function UTF8ArrayToString(heapOrArray,idx,maxBytesToRead){var endIdx=idx+maxBytesToRead;var endPtr=idx;while(heapOrArray[endPtr]&&!(endPtr>=endIdx))++endPtr;if(endPtr-idx>16&&heapOrArray.buffer&&UTF8Decoder){return UTF8Decoder.decode(heapOrArray.subarray(idx,endPtr))}var str=\"\";while(idx<endPtr){var u0=heapOrArray[idx++];if(!(u0&128)){str+=String.fromCharCode(u0);continue}var u1=heapOrArray[idx++]&63;if((u0&224)==192){str+=String.fromCharCode((u0&31)<<6|u1);continue}var u2=heapOrArray[idx++]&63;if((u0&240)==224){u0=(u0&15)<<12|u1<<6|u2}else{u0=(u0&7)<<18|u1<<12|u2<<6|heapOrArray[idx++]&63}if(u0<65536){str+=String.fromCharCode(u0)}else{var ch=u0-65536;str+=String.fromCharCode(55296|ch>>10,56320|ch&1023)}}return str}function UTF8ToString(ptr,maxBytesToRead){return ptr?UTF8ArrayToString(HEAPU8,ptr,maxBytesToRead):\"\"}function stringToUTF8Array(str,heap,outIdx,maxBytesToWrite){if(!(maxBytesToWrite>0))return 0;var startIdx=outIdx;var endIdx=outIdx+maxBytesToWrite-1;for(var i=0;i<str.length;++i){var u=str.charCodeAt(i);if(u>=55296&&u<=57343){var u1=str.charCodeAt(++i);u=65536+((u&1023)<<10)|u1&1023}if(u<=127){if(outIdx>=endIdx)break;heap[outIdx++]=u}else if(u<=2047){if(outIdx+1>=endIdx)break;heap[outIdx++]=192|u>>6;heap[outIdx++]=128|u&63}else if(u<=65535){if(outIdx+2>=endIdx)break;heap[outIdx++]=224|u>>12;heap[outIdx++]=128|u>>6&63;heap[outIdx++]=128|u&63}else{if(outIdx+3>=endIdx)break;heap[outIdx++]=240|u>>18;heap[outIdx++]=128|u>>12&63;heap[outIdx++]=128|u>>6&63;heap[outIdx++]=128|u&63}}heap[outIdx]=0;return outIdx-startIdx}function stringToUTF8(str,outPtr,maxBytesToWrite){return stringToUTF8Array(str,HEAPU8,outPtr,maxBytesToWrite)}function lengthBytesUTF8(str){var len=0;for(var i=0;i<str.length;++i){var c=str.charCodeAt(i);if(c<=127){len++}else if(c<=2047){len+=2}else if(c>=55296&&c<=57343){len+=4;++i}else{len+=3}}return len}var buffer,HEAP8,HEAPU8,HEAP16,HEAPU16,HEAP32,HEAPU32,HEAPF32,HEAPF64;function updateGlobalBufferAndViews(buf){buffer=buf;Module[\"HEAP8\"]=HEAP8=new Int8Array(buf);Module[\"HEAP16\"]=HEAP16=new Int16Array(buf);Module[\"HEAP32\"]=HEAP32=new Int32Array(buf);Module[\"HEAPU8\"]=HEAPU8=new Uint8Array(buf);Module[\"HEAPU16\"]=HEAPU16=new Uint16Array(buf);Module[\"HEAPU32\"]=HEAPU32=new Uint32Array(buf);Module[\"HEAPF32\"]=HEAPF32=new Float32Array(buf);Module[\"HEAPF64\"]=HEAPF64=new Float64Array(buf)}var INITIAL_MEMORY=Module[\"INITIAL_MEMORY\"]||16777216;var wasmTable;var __ATPRERUN__=[];var __ATINIT__=[];var __ATMAIN__=[];var __ATPOSTRUN__=[];var runtimeInitialized=false;function keepRuntimeAlive(){return noExitRuntime}function preRun(){if(Module[\"preRun\"]){if(typeof Module[\"preRun\"]==\"function\")Module[\"preRun\"]=[Module[\"preRun\"]];while(Module[\"preRun\"].length){addOnPreRun(Module[\"preRun\"].shift())}}callRuntimeCallbacks(__ATPRERUN__)}function initRuntime(){runtimeInitialized=true;callRuntimeCallbacks(__ATINIT__)}function preMain(){callRuntimeCallbacks(__ATMAIN__)}function postRun(){if(Module[\"postRun\"]){if(typeof Module[\"postRun\"]==\"function\")Module[\"postRun\"]=[Module[\"postRun\"]];while(Module[\"postRun\"].length){addOnPostRun(Module[\"postRun\"].shift())}}callRuntimeCallbacks(__ATPOSTRUN__)}function addOnPreRun(cb){__ATPRERUN__.unshift(cb)}function addOnInit(cb){__ATINIT__.unshift(cb)}function addOnPostRun(cb){__ATPOSTRUN__.unshift(cb)}var runDependencies=0;var runDependencyWatcher=null;var dependenciesFulfilled=null;function addRunDependency(id){runDependencies++;if(Module[\"monitorRunDependencies\"]){Module[\"monitorRunDependencies\"](runDependencies)}}function removeRunDependency(id){runDependencies--;if(Module[\"monitorRunDependencies\"]){Module[\"monitorRunDependencies\"](runDependencies)}if(runDependencies==0){if(runDependencyWatcher!==null){clearInterval(runDependencyWatcher);runDependencyWatcher=null}if(dependenciesFulfilled){var callback=dependenciesFulfilled;dependenciesFulfilled=null;callback()}}}function abort(what){if(Module[\"onAbort\"]){Module[\"onAbort\"](what)}what=\"Aborted(\"+what+\")\";err(what);ABORT=true;EXITSTATUS=1;what+=\". Build with -sASSERTIONS for more info.\";var e=new WebAssembly.RuntimeError(what);readyPromiseReject(e);throw e}var dataURIPrefix=\"data:application/octet-stream;base64,\";function isDataURI(filename){return filename.startsWith(dataURIPrefix)}var wasmBinaryFile;wasmBinaryFile=\"ICRPolySeg.wasm\";if(!isDataURI(wasmBinaryFile)){wasmBinaryFile=locateFile(wasmBinaryFile)}function getBinary(file){try{if(file==wasmBinaryFile&&wasmBinary){return new Uint8Array(wasmBinary)}if(readBinary){return readBinary(file)}throw\"both async and sync fetching of the wasm failed\"}catch(err){abort(err)}}function getBinaryPromise(){if(!wasmBinary&&(ENVIRONMENT_IS_WEB||ENVIRONMENT_IS_WORKER)){if(typeof fetch==\"function\"){return fetch(wasmBinaryFile,{credentials:\"same-origin\"}).then(function(response){if(!response[\"ok\"]){throw\"failed to load wasm binary file at '\"+wasmBinaryFile+\"'\"}return response[\"arrayBuffer\"]()}).catch(function(){return getBinary(wasmBinaryFile)})}}return Promise.resolve().then(function(){return getBinary(wasmBinaryFile)})}function createWasm(){var info={\"a\":asmLibraryArg};function receiveInstance(instance,module){var exports=instance.exports;Module[\"asm\"]=exports;wasmMemory=Module[\"asm\"][\"Q\"];updateGlobalBufferAndViews(wasmMemory.buffer);wasmTable=Module[\"asm\"][\"T\"];addOnInit(Module[\"asm\"][\"R\"]);removeRunDependency(\"wasm-instantiate\")}addRunDependency(\"wasm-instantiate\");function receiveInstantiationResult(result){receiveInstance(result[\"instance\"])}function instantiateArrayBuffer(receiver){return getBinaryPromise().then(function(binary){return WebAssembly.instantiate(binary,info)}).then(function(instance){return instance}).then(receiver,function(reason){err(\"failed to asynchronously prepare wasm: \"+reason);abort(reason)})}function instantiateAsync(){if(!wasmBinary&&typeof WebAssembly.instantiateStreaming==\"function\"&&!isDataURI(wasmBinaryFile)&&typeof fetch==\"function\"){return fetch(wasmBinaryFile,{credentials:\"same-origin\"}).then(function(response){var result=WebAssembly.instantiateStreaming(response,info);return result.then(receiveInstantiationResult,function(reason){err(\"wasm streaming compile failed: \"+reason);err(\"falling back to ArrayBuffer instantiation\");return instantiateArrayBuffer(receiveInstantiationResult)})})}else{return instantiateArrayBuffer(receiveInstantiationResult)}}if(Module[\"instantiateWasm\"]){try{var exports=Module[\"instantiateWasm\"](info,receiveInstance);return exports}catch(e){err(\"Module.instantiateWasm callback failed with error: \"+e);readyPromiseReject(e)}}instantiateAsync().catch(readyPromiseReject);return{}}var ASM_CONSTS={638383:$0=>{if(Module.updateProgress){Module.updateProgress($0)}}};function ExitStatus(status){this.name=\"ExitStatus\";this.message=\"Program terminated with exit(\"+status+\")\";this.status=status}function callRuntimeCallbacks(callbacks){while(callbacks.length>0){callbacks.shift()(Module)}}function ExceptionInfo(excPtr){this.excPtr=excPtr;this.ptr=excPtr-24;this.set_type=function(type){HEAPU32[this.ptr+4>>2]=type};this.get_type=function(){return HEAPU32[this.ptr+4>>2]};this.set_destructor=function(destructor){HEAPU32[this.ptr+8>>2]=destructor};this.get_destructor=function(){return HEAPU32[this.ptr+8>>2]};this.set_refcount=function(refcount){HEAP32[this.ptr>>2]=refcount};this.set_caught=function(caught){caught=caught?1:0;HEAP8[this.ptr+12>>0]=caught};this.get_caught=function(){return HEAP8[this.ptr+12>>0]!=0};this.set_rethrown=function(rethrown){rethrown=rethrown?1:0;HEAP8[this.ptr+13>>0]=rethrown};this.get_rethrown=function(){return HEAP8[this.ptr+13>>0]!=0};this.init=function(type,destructor){this.set_adjusted_ptr(0);this.set_type(type);this.set_destructor(destructor);this.set_refcount(0);this.set_caught(false);this.set_rethrown(false)};this.add_ref=function(){var value=HEAP32[this.ptr>>2];HEAP32[this.ptr>>2]=value+1};this.release_ref=function(){var prev=HEAP32[this.ptr>>2];HEAP32[this.ptr>>2]=prev-1;return prev===1};this.set_adjusted_ptr=function(adjustedPtr){HEAPU32[this.ptr+16>>2]=adjustedPtr};this.get_adjusted_ptr=function(){return HEAPU32[this.ptr+16>>2]};this.get_exception_ptr=function(){var isPointer=___cxa_is_pointer_type(this.get_type());if(isPointer){return HEAPU32[this.excPtr>>2]}var adjusted=this.get_adjusted_ptr();if(adjusted!==0)return adjusted;return this.excPtr}}var exceptionLast=0;var uncaughtExceptionCount=0;function ___cxa_throw(ptr,type,destructor){var info=new ExceptionInfo(ptr);info.init(type,destructor);exceptionLast=ptr;uncaughtExceptionCount++;throw ptr}var SYSCALLS={varargs:undefined,get:function(){SYSCALLS.varargs+=4;var ret=HEAP32[SYSCALLS.varargs-4>>2];return ret},getStr:function(ptr){var ret=UTF8ToString(ptr);return ret}};function ___syscall_getcwd(buf,size){}function ___syscall_getdents64(fd,dirp,count){}function ___syscall_openat(dirfd,path,flags,varargs){SYSCALLS.varargs=varargs}function ___syscall_readlinkat(dirfd,path,buf,bufsize){}function ___syscall_stat64(path,buf){}var structRegistrations={};function runDestructors(destructors){while(destructors.length){var ptr=destructors.pop();var del=destructors.pop();del(ptr)}}function simpleReadValueFromPointer(pointer){return this[\"fromWireType\"](HEAP32[pointer>>2])}var awaitingDependencies={};var registeredTypes={};var typeDependencies={};var char_0=48;var char_9=57;function makeLegalFunctionName(name){if(undefined===name){return\"_unknown\"}name=name.replace(/[^a-zA-Z0-9_]/g,\"$\");var f=name.charCodeAt(0);if(f>=char_0&&f<=char_9){return\"_\"+name}return name}function createNamedFunction(name,body){name=makeLegalFunctionName(name);return new Function(\"body\",\"return function \"+name+\"() {\\n\"+'    \"use strict\";'+\"    return body.apply(this, arguments);\\n\"+\"};\\n\")(body)}function extendError(baseErrorType,errorName){var errorClass=createNamedFunction(errorName,function(message){this.name=errorName;this.message=message;var stack=new Error(message).stack;if(stack!==undefined){this.stack=this.toString()+\"\\n\"+stack.replace(/^Error(:[^\\n]*)?\\n/,\"\")}});errorClass.prototype=Object.create(baseErrorType.prototype);errorClass.prototype.constructor=errorClass;errorClass.prototype.toString=function(){if(this.message===undefined){return this.name}else{return this.name+\": \"+this.message}};return errorClass}var InternalError=undefined;function throwInternalError(message){throw new InternalError(message)}function whenDependentTypesAreResolved(myTypes,dependentTypes,getTypeConverters){myTypes.forEach(function(type){typeDependencies[type]=dependentTypes});function onComplete(typeConverters){var myTypeConverters=getTypeConverters(typeConverters);if(myTypeConverters.length!==myTypes.length){throwInternalError(\"Mismatched type converter count\")}for(var i=0;i<myTypes.length;++i){registerType(myTypes[i],myTypeConverters[i])}}var typeConverters=new Array(dependentTypes.length);var unregisteredTypes=[];var registered=0;dependentTypes.forEach((dt,i)=>{if(registeredTypes.hasOwnProperty(dt)){typeConverters[i]=registeredTypes[dt]}else{unregisteredTypes.push(dt);if(!awaitingDependencies.hasOwnProperty(dt)){awaitingDependencies[dt]=[]}awaitingDependencies[dt].push(()=>{typeConverters[i]=registeredTypes[dt];++registered;if(registered===unregisteredTypes.length){onComplete(typeConverters)}})}});if(0===unregisteredTypes.length){onComplete(typeConverters)}}function __embind_finalize_value_object(structType){var reg=structRegistrations[structType];delete structRegistrations[structType];var rawConstructor=reg.rawConstructor;var rawDestructor=reg.rawDestructor;var fieldRecords=reg.fields;var fieldTypes=fieldRecords.map(field=>field.getterReturnType).concat(fieldRecords.map(field=>field.setterArgumentType));whenDependentTypesAreResolved([structType],fieldTypes,fieldTypes=>{var fields={};fieldRecords.forEach((field,i)=>{var fieldName=field.fieldName;var getterReturnType=fieldTypes[i];var getter=field.getter;var getterContext=field.getterContext;var setterArgumentType=fieldTypes[i+fieldRecords.length];var setter=field.setter;var setterContext=field.setterContext;fields[fieldName]={read:ptr=>{return getterReturnType[\"fromWireType\"](getter(getterContext,ptr))},write:(ptr,o)=>{var destructors=[];setter(setterContext,ptr,setterArgumentType[\"toWireType\"](destructors,o));runDestructors(destructors)}}});return[{name:reg.name,\"fromWireType\":function(ptr){var rv={};for(var i in fields){rv[i]=fields[i].read(ptr)}rawDestructor(ptr);return rv},\"toWireType\":function(destructors,o){for(var fieldName in fields){if(!(fieldName in o)){throw new TypeError('Missing field:  \"'+fieldName+'\"')}}var ptr=rawConstructor();for(fieldName in fields){fields[fieldName].write(ptr,o[fieldName])}if(destructors!==null){destructors.push(rawDestructor,ptr)}return ptr},\"argPackAdvance\":8,\"readValueFromPointer\":simpleReadValueFromPointer,destructorFunction:rawDestructor}]})}function __embind_register_bigint(primitiveType,name,size,minRange,maxRange){}function getShiftFromSize(size){switch(size){case 1:return 0;case 2:return 1;case 4:return 2;case 8:return 3;default:throw new TypeError(\"Unknown type size: \"+size)}}function embind_init_charCodes(){var codes=new Array(256);for(var i=0;i<256;++i){codes[i]=String.fromCharCode(i)}embind_charCodes=codes}var embind_charCodes=undefined;function readLatin1String(ptr){var ret=\"\";var c=ptr;while(HEAPU8[c]){ret+=embind_charCodes[HEAPU8[c++]]}return ret}var BindingError=undefined;function throwBindingError(message){throw new BindingError(message)}function registerType(rawType,registeredInstance,options={}){if(!(\"argPackAdvance\"in registeredInstance)){throw new TypeError(\"registerType registeredInstance requires argPackAdvance\")}var name=registeredInstance.name;if(!rawType){throwBindingError('type \"'+name+'\" must have a positive integer typeid pointer')}if(registeredTypes.hasOwnProperty(rawType)){if(options.ignoreDuplicateRegistrations){return}else{throwBindingError(\"Cannot register type '\"+name+\"' twice\")}}registeredTypes[rawType]=registeredInstance;delete typeDependencies[rawType];if(awaitingDependencies.hasOwnProperty(rawType)){var callbacks=awaitingDependencies[rawType];delete awaitingDependencies[rawType];callbacks.forEach(cb=>cb())}}function __embind_register_bool(rawType,name,size,trueValue,falseValue){var shift=getShiftFromSize(size);name=readLatin1String(name);registerType(rawType,{name:name,\"fromWireType\":function(wt){return!!wt},\"toWireType\":function(destructors,o){return o?trueValue:falseValue},\"argPackAdvance\":8,\"readValueFromPointer\":function(pointer){var heap;if(size===1){heap=HEAP8}else if(size===2){heap=HEAP16}else if(size===4){heap=HEAP32}else{throw new TypeError(\"Unknown boolean type size: \"+name)}return this[\"fromWireType\"](heap[pointer>>shift])},destructorFunction:null})}var emval_free_list=[];var emval_handle_array=[{},{value:undefined},{value:null},{value:true},{value:false}];function __emval_decref(handle){if(handle>4&&0===--emval_handle_array[handle].refcount){emval_handle_array[handle]=undefined;emval_free_list.push(handle)}}function count_emval_handles(){var count=0;for(var i=5;i<emval_handle_array.length;++i){if(emval_handle_array[i]!==undefined){++count}}return count}function get_first_emval(){for(var i=5;i<emval_handle_array.length;++i){if(emval_handle_array[i]!==undefined){return emval_handle_array[i]}}return null}function init_emval(){Module[\"count_emval_handles\"]=count_emval_handles;Module[\"get_first_emval\"]=get_first_emval}var Emval={toValue:handle=>{if(!handle){throwBindingError(\"Cannot use deleted val. handle = \"+handle)}return emval_handle_array[handle].value},toHandle:value=>{switch(value){case undefined:return 1;case null:return 2;case true:return 3;case false:return 4;default:{var handle=emval_free_list.length?emval_free_list.pop():emval_handle_array.length;emval_handle_array[handle]={refcount:1,value:value};return handle}}}};function __embind_register_emval(rawType,name){name=readLatin1String(name);registerType(rawType,{name:name,\"fromWireType\":function(handle){var rv=Emval.toValue(handle);__emval_decref(handle);return rv},\"toWireType\":function(destructors,value){return Emval.toHandle(value)},\"argPackAdvance\":8,\"readValueFromPointer\":simpleReadValueFromPointer,destructorFunction:null})}function floatReadValueFromPointer(name,shift){switch(shift){case 2:return function(pointer){return this[\"fromWireType\"](HEAPF32[pointer>>2])};case 3:return function(pointer){return this[\"fromWireType\"](HEAPF64[pointer>>3])};default:throw new TypeError(\"Unknown float type: \"+name)}}function __embind_register_float(rawType,name,size){var shift=getShiftFromSize(size);name=readLatin1String(name);registerType(rawType,{name:name,\"fromWireType\":function(value){return value},\"toWireType\":function(destructors,value){return value},\"argPackAdvance\":8,\"readValueFromPointer\":floatReadValueFromPointer(name,shift),destructorFunction:null})}function new_(constructor,argumentList){if(!(constructor instanceof Function)){throw new TypeError(\"new_ called with constructor type \"+typeof constructor+\" which is not a function\")}var dummy=createNamedFunction(constructor.name||\"unknownFunctionName\",function(){});dummy.prototype=constructor.prototype;var obj=new dummy;var r=constructor.apply(obj,argumentList);return r instanceof Object?r:obj}function craftInvokerFunction(humanName,argTypes,classType,cppInvokerFunc,cppTargetFunc){var argCount=argTypes.length;if(argCount<2){throwBindingError(\"argTypes array size mismatch! Must at least get return value and 'this' types!\")}var isClassMethodFunc=argTypes[1]!==null&&classType!==null;var needsDestructorStack=false;for(var i=1;i<argTypes.length;++i){if(argTypes[i]!==null&&argTypes[i].destructorFunction===undefined){needsDestructorStack=true;break}}var returns=argTypes[0].name!==\"void\";var argsList=\"\";var argsListWired=\"\";for(var i=0;i<argCount-2;++i){argsList+=(i!==0?\", \":\"\")+\"arg\"+i;argsListWired+=(i!==0?\", \":\"\")+\"arg\"+i+\"Wired\"}var invokerFnBody=\"return function \"+makeLegalFunctionName(humanName)+\"(\"+argsList+\") {\\n\"+\"if (arguments.length !== \"+(argCount-2)+\") {\\n\"+\"throwBindingError('function \"+humanName+\" called with ' + arguments.length + ' arguments, expected \"+(argCount-2)+\" args!');\\n\"+\"}\\n\";if(needsDestructorStack){invokerFnBody+=\"var destructors = [];\\n\"}var dtorStack=needsDestructorStack?\"destructors\":\"null\";var args1=[\"throwBindingError\",\"invoker\",\"fn\",\"runDestructors\",\"retType\",\"classParam\"];var args2=[throwBindingError,cppInvokerFunc,cppTargetFunc,runDestructors,argTypes[0],argTypes[1]];if(isClassMethodFunc){invokerFnBody+=\"var thisWired = classParam.toWireType(\"+dtorStack+\", this);\\n\"}for(var i=0;i<argCount-2;++i){invokerFnBody+=\"var arg\"+i+\"Wired = argType\"+i+\".toWireType(\"+dtorStack+\", arg\"+i+\"); // \"+argTypes[i+2].name+\"\\n\";args1.push(\"argType\"+i);args2.push(argTypes[i+2])}if(isClassMethodFunc){argsListWired=\"thisWired\"+(argsListWired.length>0?\", \":\"\")+argsListWired}invokerFnBody+=(returns?\"var rv = \":\"\")+\"invoker(fn\"+(argsListWired.length>0?\", \":\"\")+argsListWired+\");\\n\";if(needsDestructorStack){invokerFnBody+=\"runDestructors(destructors);\\n\"}else{for(var i=isClassMethodFunc?1:2;i<argTypes.length;++i){var paramName=i===1?\"thisWired\":\"arg\"+(i-2)+\"Wired\";if(argTypes[i].destructorFunction!==null){invokerFnBody+=paramName+\"_dtor(\"+paramName+\"); // \"+argTypes[i].name+\"\\n\";args1.push(paramName+\"_dtor\");args2.push(argTypes[i].destructorFunction)}}}if(returns){invokerFnBody+=\"var ret = retType.fromWireType(rv);\\n\"+\"return ret;\\n\"}else{}invokerFnBody+=\"}\\n\";args1.push(invokerFnBody);var invokerFunction=new_(Function,args1).apply(null,args2);return invokerFunction}function ensureOverloadTable(proto,methodName,humanName){if(undefined===proto[methodName].overloadTable){var prevFunc=proto[methodName];proto[methodName]=function(){if(!proto[methodName].overloadTable.hasOwnProperty(arguments.length)){throwBindingError(\"Function '\"+humanName+\"' called with an invalid number of arguments (\"+arguments.length+\") - expects one of (\"+proto[methodName].overloadTable+\")!\")}return proto[methodName].overloadTable[arguments.length].apply(this,arguments)};proto[methodName].overloadTable=[];proto[methodName].overloadTable[prevFunc.argCount]=prevFunc}}function exposePublicSymbol(name,value,numArguments){if(Module.hasOwnProperty(name)){if(undefined===numArguments||undefined!==Module[name].overloadTable&&undefined!==Module[name].overloadTable[numArguments]){throwBindingError(\"Cannot register public name '\"+name+\"' twice\")}ensureOverloadTable(Module,name,name);if(Module.hasOwnProperty(numArguments)){throwBindingError(\"Cannot register multiple overloads of a function with the same number of arguments (\"+numArguments+\")!\")}Module[name].overloadTable[numArguments]=value}else{Module[name]=value;if(undefined!==numArguments){Module[name].numArguments=numArguments}}}function heap32VectorToArray(count,firstElement){var array=[];for(var i=0;i<count;i++){array.push(HEAPU32[firstElement+i*4>>2])}return array}function replacePublicSymbol(name,value,numArguments){if(!Module.hasOwnProperty(name)){throwInternalError(\"Replacing nonexistant public symbol\")}if(undefined!==Module[name].overloadTable&&undefined!==numArguments){Module[name].overloadTable[numArguments]=value}else{Module[name]=value;Module[name].argCount=numArguments}}function dynCallLegacy(sig,ptr,args){var f=Module[\"dynCall_\"+sig];return args&&args.length?f.apply(null,[ptr].concat(args)):f.call(null,ptr)}var wasmTableMirror=[];function getWasmTableEntry(funcPtr){var func=wasmTableMirror[funcPtr];if(!func){if(funcPtr>=wasmTableMirror.length)wasmTableMirror.length=funcPtr+1;wasmTableMirror[funcPtr]=func=wasmTable.get(funcPtr)}return func}function dynCall(sig,ptr,args){if(sig.includes(\"j\")){return dynCallLegacy(sig,ptr,args)}var rtn=getWasmTableEntry(ptr).apply(null,args);return rtn}function getDynCaller(sig,ptr){var argCache=[];return function(){argCache.length=0;Object.assign(argCache,arguments);return dynCall(sig,ptr,argCache)}}function embind__requireFunction(signature,rawFunction){signature=readLatin1String(signature);function makeDynCaller(){if(signature.includes(\"j\")){return getDynCaller(signature,rawFunction)}return getWasmTableEntry(rawFunction)}var fp=makeDynCaller();if(typeof fp!=\"function\"){throwBindingError(\"unknown function pointer with signature \"+signature+\": \"+rawFunction)}return fp}var UnboundTypeError=undefined;function getTypeName(type){var ptr=___getTypeName(type);var rv=readLatin1String(ptr);_free(ptr);return rv}function throwUnboundTypeError(message,types){var unboundTypes=[];var seen={};function visit(type){if(seen[type]){return}if(registeredTypes[type]){return}if(typeDependencies[type]){typeDependencies[type].forEach(visit);return}unboundTypes.push(type);seen[type]=true}types.forEach(visit);throw new UnboundTypeError(message+\": \"+unboundTypes.map(getTypeName).join([\", \"]))}function __embind_register_function(name,argCount,rawArgTypesAddr,signature,rawInvoker,fn){var argTypes=heap32VectorToArray(argCount,rawArgTypesAddr);name=readLatin1String(name);rawInvoker=embind__requireFunction(signature,rawInvoker);exposePublicSymbol(name,function(){throwUnboundTypeError(\"Cannot call \"+name+\" due to unbound types\",argTypes)},argCount-1);whenDependentTypesAreResolved([],argTypes,function(argTypes){var invokerArgsArray=[argTypes[0],null].concat(argTypes.slice(1));replacePublicSymbol(name,craftInvokerFunction(name,invokerArgsArray,null,rawInvoker,fn),argCount-1);return[]})}function integerReadValueFromPointer(name,shift,signed){switch(shift){case 0:return signed?function readS8FromPointer(pointer){return HEAP8[pointer]}:function readU8FromPointer(pointer){return HEAPU8[pointer]};case 1:return signed?function readS16FromPointer(pointer){return HEAP16[pointer>>1]}:function readU16FromPointer(pointer){return HEAPU16[pointer>>1]};case 2:return signed?function readS32FromPointer(pointer){return HEAP32[pointer>>2]}:function readU32FromPointer(pointer){return HEAPU32[pointer>>2]};default:throw new TypeError(\"Unknown integer type: \"+name)}}function __embind_register_integer(primitiveType,name,size,minRange,maxRange){name=readLatin1String(name);if(maxRange===-1){maxRange=4294967295}var shift=getShiftFromSize(size);var fromWireType=value=>value;if(minRange===0){var bitshift=32-8*size;fromWireType=value=>value<<bitshift>>>bitshift}var isUnsignedType=name.includes(\"unsigned\");var checkAssertions=(value,toTypeName)=>{};var toWireType;if(isUnsignedType){toWireType=function(destructors,value){checkAssertions(value,this.name);return value>>>0}}else{toWireType=function(destructors,value){checkAssertions(value,this.name);return value}}registerType(primitiveType,{name:name,\"fromWireType\":fromWireType,\"toWireType\":toWireType,\"argPackAdvance\":8,\"readValueFromPointer\":integerReadValueFromPointer(name,shift,minRange!==0),destructorFunction:null})}function __embind_register_memory_view(rawType,dataTypeIndex,name){var typeMapping=[Int8Array,Uint8Array,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array];var TA=typeMapping[dataTypeIndex];function decodeMemoryView(handle){handle=handle>>2;var heap=HEAPU32;var size=heap[handle];var data=heap[handle+1];return new TA(buffer,data,size)}name=readLatin1String(name);registerType(rawType,{name:name,\"fromWireType\":decodeMemoryView,\"argPackAdvance\":8,\"readValueFromPointer\":decodeMemoryView},{ignoreDuplicateRegistrations:true})}function __embind_register_std_string(rawType,name){name=readLatin1String(name);var stdStringIsUTF8=name===\"std::string\";registerType(rawType,{name:name,\"fromWireType\":function(value){var length=HEAPU32[value>>2];var payload=value+4;var str;if(stdStringIsUTF8){var decodeStartPtr=payload;for(var i=0;i<=length;++i){var currentBytePtr=payload+i;if(i==length||HEAPU8[currentBytePtr]==0){var maxRead=currentBytePtr-decodeStartPtr;var stringSegment=UTF8ToString(decodeStartPtr,maxRead);if(str===undefined){str=stringSegment}else{str+=String.fromCharCode(0);str+=stringSegment}decodeStartPtr=currentBytePtr+1}}}else{var a=new Array(length);for(var i=0;i<length;++i){a[i]=String.fromCharCode(HEAPU8[payload+i])}str=a.join(\"\")}_free(value);return str},\"toWireType\":function(destructors,value){if(value instanceof ArrayBuffer){value=new Uint8Array(value)}var length;var valueIsOfTypeString=typeof value==\"string\";if(!(valueIsOfTypeString||value instanceof Uint8Array||value instanceof Uint8ClampedArray||value instanceof Int8Array)){throwBindingError(\"Cannot pass non-string to std::string\")}if(stdStringIsUTF8&&valueIsOfTypeString){length=lengthBytesUTF8(value)}else{length=value.length}var base=_malloc(4+length+1);var ptr=base+4;HEAPU32[base>>2]=length;if(stdStringIsUTF8&&valueIsOfTypeString){stringToUTF8(value,ptr,length+1)}else{if(valueIsOfTypeString){for(var i=0;i<length;++i){var charCode=value.charCodeAt(i);if(charCode>255){_free(ptr);throwBindingError(\"String has UTF-16 code units that do not fit in 8 bits\")}HEAPU8[ptr+i]=charCode}}else{for(var i=0;i<length;++i){HEAPU8[ptr+i]=value[i]}}}if(destructors!==null){destructors.push(_free,base)}return base},\"argPackAdvance\":8,\"readValueFromPointer\":simpleReadValueFromPointer,destructorFunction:function(ptr){_free(ptr)}})}var UTF16Decoder=typeof TextDecoder!=\"undefined\"?new TextDecoder(\"utf-16le\"):undefined;function UTF16ToString(ptr,maxBytesToRead){var endPtr=ptr;var idx=endPtr>>1;var maxIdx=idx+maxBytesToRead/2;while(!(idx>=maxIdx)&&HEAPU16[idx])++idx;endPtr=idx<<1;if(endPtr-ptr>32&&UTF16Decoder)return UTF16Decoder.decode(HEAPU8.subarray(ptr,endPtr));var str=\"\";for(var i=0;!(i>=maxBytesToRead/2);++i){var codeUnit=HEAP16[ptr+i*2>>1];if(codeUnit==0)break;str+=String.fromCharCode(codeUnit)}return str}function stringToUTF16(str,outPtr,maxBytesToWrite){if(maxBytesToWrite===undefined){maxBytesToWrite=2147483647}if(maxBytesToWrite<2)return 0;maxBytesToWrite-=2;var startPtr=outPtr;var numCharsToWrite=maxBytesToWrite<str.length*2?maxBytesToWrite/2:str.length;for(var i=0;i<numCharsToWrite;++i){var codeUnit=str.charCodeAt(i);HEAP16[outPtr>>1]=codeUnit;outPtr+=2}HEAP16[outPtr>>1]=0;return outPtr-startPtr}function lengthBytesUTF16(str){return str.length*2}function UTF32ToString(ptr,maxBytesToRead){var i=0;var str=\"\";while(!(i>=maxBytesToRead/4)){var utf32=HEAP32[ptr+i*4>>2];if(utf32==0)break;++i;if(utf32>=65536){var ch=utf32-65536;str+=String.fromCharCode(55296|ch>>10,56320|ch&1023)}else{str+=String.fromCharCode(utf32)}}return str}function stringToUTF32(str,outPtr,maxBytesToWrite){if(maxBytesToWrite===undefined){maxBytesToWrite=2147483647}if(maxBytesToWrite<4)return 0;var startPtr=outPtr;var endPtr=startPtr+maxBytesToWrite-4;for(var i=0;i<str.length;++i){var codeUnit=str.charCodeAt(i);if(codeUnit>=55296&&codeUnit<=57343){var trailSurrogate=str.charCodeAt(++i);codeUnit=65536+((codeUnit&1023)<<10)|trailSurrogate&1023}HEAP32[outPtr>>2]=codeUnit;outPtr+=4;if(outPtr+4>endPtr)break}HEAP32[outPtr>>2]=0;return outPtr-startPtr}function lengthBytesUTF32(str){var len=0;for(var i=0;i<str.length;++i){var codeUnit=str.charCodeAt(i);if(codeUnit>=55296&&codeUnit<=57343)++i;len+=4}return len}function __embind_register_std_wstring(rawType,charSize,name){name=readLatin1String(name);var decodeString,encodeString,getHeap,lengthBytesUTF,shift;if(charSize===2){decodeString=UTF16ToString;encodeString=stringToUTF16;lengthBytesUTF=lengthBytesUTF16;getHeap=()=>HEAPU16;shift=1}else if(charSize===4){decodeString=UTF32ToString;encodeString=stringToUTF32;lengthBytesUTF=lengthBytesUTF32;getHeap=()=>HEAPU32;shift=2}registerType(rawType,{name:name,\"fromWireType\":function(value){var length=HEAPU32[value>>2];var HEAP=getHeap();var str;var decodeStartPtr=value+4;for(var i=0;i<=length;++i){var currentBytePtr=value+4+i*charSize;if(i==length||HEAP[currentBytePtr>>shift]==0){var maxReadBytes=currentBytePtr-decodeStartPtr;var stringSegment=decodeString(decodeStartPtr,maxReadBytes);if(str===undefined){str=stringSegment}else{str+=String.fromCharCode(0);str+=stringSegment}decodeStartPtr=currentBytePtr+charSize}}_free(value);return str},\"toWireType\":function(destructors,value){if(!(typeof value==\"string\")){throwBindingError(\"Cannot pass non-string to C++ string type \"+name)}var length=lengthBytesUTF(value);var ptr=_malloc(4+length+charSize);HEAPU32[ptr>>2]=length>>shift;encodeString(value,ptr+4,length+charSize);if(destructors!==null){destructors.push(_free,ptr)}return ptr},\"argPackAdvance\":8,\"readValueFromPointer\":simpleReadValueFromPointer,destructorFunction:function(ptr){_free(ptr)}})}function __embind_register_value_object(rawType,name,constructorSignature,rawConstructor,destructorSignature,rawDestructor){structRegistrations[rawType]={name:readLatin1String(name),rawConstructor:embind__requireFunction(constructorSignature,rawConstructor),rawDestructor:embind__requireFunction(destructorSignature,rawDestructor),fields:[]}}function __embind_register_value_object_field(structType,fieldName,getterReturnType,getterSignature,getter,getterContext,setterArgumentType,setterSignature,setter,setterContext){structRegistrations[structType].fields.push({fieldName:readLatin1String(fieldName),getterReturnType:getterReturnType,getter:embind__requireFunction(getterSignature,getter),getterContext:getterContext,setterArgumentType:setterArgumentType,setter:embind__requireFunction(setterSignature,setter),setterContext:setterContext})}function __embind_register_void(rawType,name){name=readLatin1String(name);registerType(rawType,{isVoid:true,name:name,\"argPackAdvance\":0,\"fromWireType\":function(){return undefined},\"toWireType\":function(destructors,o){return undefined}})}function requireRegisteredType(rawType,humanName){var impl=registeredTypes[rawType];if(undefined===impl){throwBindingError(humanName+\" has unknown type \"+getTypeName(rawType))}return impl}function __emval_as(handle,returnType,destructorsRef){handle=Emval.toValue(handle);returnType=requireRegisteredType(returnType,\"emval::as\");var destructors=[];var rd=Emval.toHandle(destructors);HEAPU32[destructorsRef>>2]=rd;return returnType[\"toWireType\"](destructors,handle)}var emval_symbols={};function getStringOrSymbol(address){var symbol=emval_symbols[address];if(symbol===undefined){return readLatin1String(address)}return symbol}var emval_methodCallers=[];function __emval_call_void_method(caller,handle,methodName,args){caller=emval_methodCallers[caller];handle=Emval.toValue(handle);methodName=getStringOrSymbol(methodName);caller(handle,methodName,null,args)}function emval_get_global(){if(typeof globalThis==\"object\"){return globalThis}return function(){return Function}()(\"return this\")()}function __emval_get_global(name){if(name===0){return Emval.toHandle(emval_get_global())}else{name=getStringOrSymbol(name);return Emval.toHandle(emval_get_global()[name])}}function emval_addMethodCaller(caller){var id=emval_methodCallers.length;emval_methodCallers.push(caller);return id}function emval_lookupTypes(argCount,argTypes){var a=new Array(argCount);for(var i=0;i<argCount;++i){a[i]=requireRegisteredType(HEAPU32[argTypes+i*POINTER_SIZE>>2],\"parameter \"+i)}return a}var emval_registeredMethods=[];function __emval_get_method_caller(argCount,argTypes){var types=emval_lookupTypes(argCount,argTypes);var retType=types[0];var signatureName=retType.name+\"_$\"+types.slice(1).map(function(t){return t.name}).join(\"_\")+\"$\";var returnId=emval_registeredMethods[signatureName];if(returnId!==undefined){return returnId}var params=[\"retType\"];var args=[retType];var argsList=\"\";for(var i=0;i<argCount-1;++i){argsList+=(i!==0?\", \":\"\")+\"arg\"+i;params.push(\"argType\"+i);args.push(types[1+i])}var functionName=makeLegalFunctionName(\"methodCaller_\"+signatureName);var functionBody=\"return function \"+functionName+\"(handle, name, destructors, args) {\\n\";var offset=0;for(var i=0;i<argCount-1;++i){functionBody+=\"    var arg\"+i+\" = argType\"+i+\".readValueFromPointer(args\"+(offset?\"+\"+offset:\"\")+\");\\n\";offset+=types[i+1][\"argPackAdvance\"]}functionBody+=\"    var rv = handle[name](\"+argsList+\");\\n\";for(var i=0;i<argCount-1;++i){if(types[i+1][\"deleteObject\"]){functionBody+=\"    argType\"+i+\".deleteObject(arg\"+i+\");\\n\"}}if(!retType.isVoid){functionBody+=\"    return retType.toWireType(destructors, rv);\\n\"}functionBody+=\"};\\n\";params.push(functionBody);var invokerFunction=new_(Function,params).apply(null,args);returnId=emval_addMethodCaller(invokerFunction);emval_registeredMethods[signatureName]=returnId;return returnId}function __emval_get_property(handle,key){handle=Emval.toValue(handle);key=Emval.toValue(key);return Emval.toHandle(handle[key])}function __emval_incref(handle){if(handle>4){emval_handle_array[handle].refcount+=1}}function craftEmvalAllocator(argCount){var argsList=\"\";for(var i=0;i<argCount;++i){argsList+=(i!==0?\", \":\"\")+\"arg\"+i}var getMemory=()=>HEAPU32;var functionBody=\"return function emval_allocator_\"+argCount+\"(constructor, argTypes, args) {\\n\"+\"  var HEAPU32 = getMemory();\\n\";for(var i=0;i<argCount;++i){functionBody+=\"var argType\"+i+\" = requireRegisteredType(HEAPU32[((argTypes)>>2)], 'parameter \"+i+\"');\\n\"+\"var arg\"+i+\" = argType\"+i+\".readValueFromPointer(args);\\n\"+\"args += argType\"+i+\"['argPackAdvance'];\\n\"+\"argTypes += 4;\\n\"}functionBody+=\"var obj = new constructor(\"+argsList+\");\\n\"+\"return valueToHandle(obj);\\n\"+\"}\\n\";return new Function(\"requireRegisteredType\",\"Module\",\"valueToHandle\",\"getMemory\",functionBody)(requireRegisteredType,Module,Emval.toHandle,getMemory)}var emval_newers={};function __emval_new(handle,argCount,argTypes,args){handle=Emval.toValue(handle);var newer=emval_newers[argCount];if(!newer){newer=craftEmvalAllocator(argCount);emval_newers[argCount]=newer}return newer(handle,argTypes,args)}function __emval_new_cstring(v){return Emval.toHandle(getStringOrSymbol(v))}function __emval_run_destructors(handle){var destructors=Emval.toValue(handle);runDestructors(destructors);__emval_decref(handle)}function __emval_take_value(type,arg){type=requireRegisteredType(type,\"_emval_take_value\");var v=type[\"readValueFromPointer\"](arg);return Emval.toHandle(v)}function _abort(){abort(\"\")}var readEmAsmArgsArray=[];function readEmAsmArgs(sigPtr,buf){readEmAsmArgsArray.length=0;var ch;buf>>=2;while(ch=HEAPU8[sigPtr++]){buf+=ch!=105&buf;readEmAsmArgsArray.push(ch==105?HEAP32[buf]:HEAPF64[buf++>>1]);++buf}return readEmAsmArgsArray}function runEmAsmFunction(code,sigPtr,argbuf){var args=readEmAsmArgs(sigPtr,argbuf);return ASM_CONSTS[code].apply(null,args)}function _emscripten_asm_const_int(code,sigPtr,argbuf){return runEmAsmFunction(code,sigPtr,argbuf)}function getHeapMax(){return 2147483648}function _emscripten_get_heap_max(){return getHeapMax()}function _emscripten_memcpy_big(dest,src,num){HEAPU8.copyWithin(dest,src,src+num)}function emscripten_realloc_buffer(size){try{wasmMemory.grow(size-buffer.byteLength+65535>>>16);updateGlobalBufferAndViews(wasmMemory.buffer);return 1}catch(e){}}function _emscripten_resize_heap(requestedSize){var oldSize=HEAPU8.length;requestedSize=requestedSize>>>0;var maxHeapSize=getHeapMax();if(requestedSize>maxHeapSize){return false}let alignUp=(x,multiple)=>x+(multiple-x%multiple)%multiple;for(var cutDown=1;cutDown<=4;cutDown*=2){var overGrownHeapSize=oldSize*(1+.2/cutDown);overGrownHeapSize=Math.min(overGrownHeapSize,requestedSize+100663296);var newSize=Math.min(maxHeapSize,alignUp(Math.max(requestedSize,overGrownHeapSize),65536));var replacement=emscripten_realloc_buffer(newSize);if(replacement){return true}}return false}var ENV={};function getExecutableName(){return thisProgram||\"./this.program\"}function getEnvStrings(){if(!getEnvStrings.strings){var lang=(typeof navigator==\"object\"&&navigator.languages&&navigator.languages[0]||\"C\").replace(\"-\",\"_\")+\".UTF-8\";var env={\"USER\":\"web_user\",\"LOGNAME\":\"web_user\",\"PATH\":\"/\",\"PWD\":\"/\",\"HOME\":\"/home/web_user\",\"LANG\":lang,\"_\":getExecutableName()};for(var x in ENV){if(ENV[x]===undefined)delete env[x];else env[x]=ENV[x]}var strings=[];for(var x in env){strings.push(x+\"=\"+env[x])}getEnvStrings.strings=strings}return getEnvStrings.strings}function writeAsciiToMemory(str,buffer,dontAddNull){for(var i=0;i<str.length;++i){HEAP8[buffer++>>0]=str.charCodeAt(i)}if(!dontAddNull)HEAP8[buffer>>0]=0}function _environ_get(__environ,environ_buf){var bufSize=0;getEnvStrings().forEach(function(string,i){var ptr=environ_buf+bufSize;HEAPU32[__environ+i*4>>2]=ptr;writeAsciiToMemory(string,ptr);bufSize+=string.length+1});return 0}function _environ_sizes_get(penviron_count,penviron_buf_size){var strings=getEnvStrings();HEAPU32[penviron_count>>2]=strings.length;var bufSize=0;strings.forEach(function(string){bufSize+=string.length+1});HEAPU32[penviron_buf_size>>2]=bufSize;return 0}function _fd_close(fd){return 52}function _fd_read(fd,iov,iovcnt,pnum){return 52}function _fd_seek(fd,offset_low,offset_high,whence,newOffset){return 70}var printCharBuffers=[null,[],[]];function printChar(stream,curr){var buffer=printCharBuffers[stream];if(curr===0||curr===10){(stream===1?out:err)(UTF8ArrayToString(buffer,0));buffer.length=0}else{buffer.push(curr)}}function _fd_write(fd,iov,iovcnt,pnum){var num=0;for(var i=0;i<iovcnt;i++){var ptr=HEAPU32[iov>>2];var len=HEAPU32[iov+4>>2];iov+=8;for(var j=0;j<len;j++){printChar(fd,HEAPU8[ptr+j])}num+=len}HEAPU32[pnum>>2]=num;return 0}function __isLeapYear(year){return year%4===0&&(year%100!==0||year%400===0)}function __arraySum(array,index){var sum=0;for(var i=0;i<=index;sum+=array[i++]){}return sum}var __MONTH_DAYS_LEAP=[31,29,31,30,31,30,31,31,30,31,30,31];var __MONTH_DAYS_REGULAR=[31,28,31,30,31,30,31,31,30,31,30,31];function __addDays(date,days){var newDate=new Date(date.getTime());while(days>0){var leap=__isLeapYear(newDate.getFullYear());var currentMonth=newDate.getMonth();var daysInCurrentMonth=(leap?__MONTH_DAYS_LEAP:__MONTH_DAYS_REGULAR)[currentMonth];if(days>daysInCurrentMonth-newDate.getDate()){days-=daysInCurrentMonth-newDate.getDate()+1;newDate.setDate(1);if(currentMonth<11){newDate.setMonth(currentMonth+1)}else{newDate.setMonth(0);newDate.setFullYear(newDate.getFullYear()+1)}}else{newDate.setDate(newDate.getDate()+days);return newDate}}return newDate}function intArrayFromString(stringy,dontAddNull,length){var len=length>0?length:lengthBytesUTF8(stringy)+1;var u8array=new Array(len);var numBytesWritten=stringToUTF8Array(stringy,u8array,0,u8array.length);if(dontAddNull)u8array.length=numBytesWritten;return u8array}function writeArrayToMemory(array,buffer){HEAP8.set(array,buffer)}function _strftime(s,maxsize,format,tm){var tm_zone=HEAP32[tm+40>>2];var date={tm_sec:HEAP32[tm>>2],tm_min:HEAP32[tm+4>>2],tm_hour:HEAP32[tm+8>>2],tm_mday:HEAP32[tm+12>>2],tm_mon:HEAP32[tm+16>>2],tm_year:HEAP32[tm+20>>2],tm_wday:HEAP32[tm+24>>2],tm_yday:HEAP32[tm+28>>2],tm_isdst:HEAP32[tm+32>>2],tm_gmtoff:HEAP32[tm+36>>2],tm_zone:tm_zone?UTF8ToString(tm_zone):\"\"};var pattern=UTF8ToString(format);var EXPANSION_RULES_1={\"%c\":\"%a %b %d %H:%M:%S %Y\",\"%D\":\"%m/%d/%y\",\"%F\":\"%Y-%m-%d\",\"%h\":\"%b\",\"%r\":\"%I:%M:%S %p\",\"%R\":\"%H:%M\",\"%T\":\"%H:%M:%S\",\"%x\":\"%m/%d/%y\",\"%X\":\"%H:%M:%S\",\"%Ec\":\"%c\",\"%EC\":\"%C\",\"%Ex\":\"%m/%d/%y\",\"%EX\":\"%H:%M:%S\",\"%Ey\":\"%y\",\"%EY\":\"%Y\",\"%Od\":\"%d\",\"%Oe\":\"%e\",\"%OH\":\"%H\",\"%OI\":\"%I\",\"%Om\":\"%m\",\"%OM\":\"%M\",\"%OS\":\"%S\",\"%Ou\":\"%u\",\"%OU\":\"%U\",\"%OV\":\"%V\",\"%Ow\":\"%w\",\"%OW\":\"%W\",\"%Oy\":\"%y\"};for(var rule in EXPANSION_RULES_1){pattern=pattern.replace(new RegExp(rule,\"g\"),EXPANSION_RULES_1[rule])}var WEEKDAYS=[\"Sunday\",\"Monday\",\"Tuesday\",\"Wednesday\",\"Thursday\",\"Friday\",\"Saturday\"];var MONTHS=[\"January\",\"February\",\"March\",\"April\",\"May\",\"June\",\"July\",\"August\",\"September\",\"October\",\"November\",\"December\"];function leadingSomething(value,digits,character){var str=typeof value==\"number\"?value.toString():value||\"\";while(str.length<digits){str=character[0]+str}return str}function leadingNulls(value,digits){return leadingSomething(value,digits,\"0\")}function compareByDay(date1,date2){function sgn(value){return value<0?-1:value>0?1:0}var compare;if((compare=sgn(date1.getFullYear()-date2.getFullYear()))===0){if((compare=sgn(date1.getMonth()-date2.getMonth()))===0){compare=sgn(date1.getDate()-date2.getDate())}}return compare}function getFirstWeekStartDate(janFourth){switch(janFourth.getDay()){case 0:return new Date(janFourth.getFullYear()-1,11,29);case 1:return janFourth;case 2:return new Date(janFourth.getFullYear(),0,3);case 3:return new Date(janFourth.getFullYear(),0,2);case 4:return new Date(janFourth.getFullYear(),0,1);case 5:return new Date(janFourth.getFullYear()-1,11,31);case 6:return new Date(janFourth.getFullYear()-1,11,30)}}function getWeekBasedYear(date){var thisDate=__addDays(new Date(date.tm_year+1900,0,1),date.tm_yday);var janFourthThisYear=new Date(thisDate.getFullYear(),0,4);var janFourthNextYear=new Date(thisDate.getFullYear()+1,0,4);var firstWeekStartThisYear=getFirstWeekStartDate(janFourthThisYear);var firstWeekStartNextYear=getFirstWeekStartDate(janFourthNextYear);if(compareByDay(firstWeekStartThisYear,thisDate)<=0){if(compareByDay(firstWeekStartNextYear,thisDate)<=0){return thisDate.getFullYear()+1}return thisDate.getFullYear()}return thisDate.getFullYear()-1}var EXPANSION_RULES_2={\"%a\":function(date){return WEEKDAYS[date.tm_wday].substring(0,3)},\"%A\":function(date){return WEEKDAYS[date.tm_wday]},\"%b\":function(date){return MONTHS[date.tm_mon].substring(0,3)},\"%B\":function(date){return MONTHS[date.tm_mon]},\"%C\":function(date){var year=date.tm_year+1900;return leadingNulls(year/100|0,2)},\"%d\":function(date){return leadingNulls(date.tm_mday,2)},\"%e\":function(date){return leadingSomething(date.tm_mday,2,\" \")},\"%g\":function(date){return getWeekBasedYear(date).toString().substring(2)},\"%G\":function(date){return getWeekBasedYear(date)},\"%H\":function(date){return leadingNulls(date.tm_hour,2)},\"%I\":function(date){var twelveHour=date.tm_hour;if(twelveHour==0)twelveHour=12;else if(twelveHour>12)twelveHour-=12;return leadingNulls(twelveHour,2)},\"%j\":function(date){return leadingNulls(date.tm_mday+__arraySum(__isLeapYear(date.tm_year+1900)?__MONTH_DAYS_LEAP:__MONTH_DAYS_REGULAR,date.tm_mon-1),3)},\"%m\":function(date){return leadingNulls(date.tm_mon+1,2)},\"%M\":function(date){return leadingNulls(date.tm_min,2)},\"%n\":function(){return\"\\n\"},\"%p\":function(date){if(date.tm_hour>=0&&date.tm_hour<12){return\"AM\"}return\"PM\"},\"%S\":function(date){return leadingNulls(date.tm_sec,2)},\"%t\":function(){return\"\\t\"},\"%u\":function(date){return date.tm_wday||7},\"%U\":function(date){var days=date.tm_yday+7-date.tm_wday;return leadingNulls(Math.floor(days/7),2)},\"%V\":function(date){var val=Math.floor((date.tm_yday+7-(date.tm_wday+6)%7)/7);if((date.tm_wday+371-date.tm_yday-2)%7<=2){val++}if(!val){val=52;var dec31=(date.tm_wday+7-date.tm_yday-1)%7;if(dec31==4||dec31==5&&__isLeapYear(date.tm_year%400-1)){val++}}else if(val==53){var jan1=(date.tm_wday+371-date.tm_yday)%7;if(jan1!=4&&(jan1!=3||!__isLeapYear(date.tm_year)))val=1}return leadingNulls(val,2)},\"%w\":function(date){return date.tm_wday},\"%W\":function(date){var days=date.tm_yday+7-(date.tm_wday+6)%7;return leadingNulls(Math.floor(days/7),2)},\"%y\":function(date){return(date.tm_year+1900).toString().substring(2)},\"%Y\":function(date){return date.tm_year+1900},\"%z\":function(date){var off=date.tm_gmtoff;var ahead=off>=0;off=Math.abs(off)/60;off=off/60*100+off%60;return(ahead?\"+\":\"-\")+String(\"0000\"+off).slice(-4)},\"%Z\":function(date){return date.tm_zone},\"%%\":function(){return\"%\"}};pattern=pattern.replace(/%%/g,\"\\0\\0\");for(var rule in EXPANSION_RULES_2){if(pattern.includes(rule)){pattern=pattern.replace(new RegExp(rule,\"g\"),EXPANSION_RULES_2[rule](date))}}pattern=pattern.replace(/\\0\\0/g,\"%\");var bytes=intArrayFromString(pattern,false);if(bytes.length>maxsize){return 0}writeArrayToMemory(bytes,s);return bytes.length-1}function _strftime_l(s,maxsize,format,tm,loc){return _strftime(s,maxsize,format,tm)}function _proc_exit(code){EXITSTATUS=code;if(!keepRuntimeAlive()){if(Module[\"onExit\"])Module[\"onExit\"](code);ABORT=true}quit_(code,new ExitStatus(code))}function exitJS(status,implicit){EXITSTATUS=status;_proc_exit(status)}function handleException(e){if(e instanceof ExitStatus||e==\"unwind\"){return EXITSTATUS}quit_(1,e)}InternalError=Module[\"InternalError\"]=extendError(Error,\"InternalError\");embind_init_charCodes();BindingError=Module[\"BindingError\"]=extendError(Error,\"BindingError\");init_emval();UnboundTypeError=Module[\"UnboundTypeError\"]=extendError(Error,\"UnboundTypeError\");var asmLibraryArg={\"b\":___cxa_throw,\"J\":___syscall_getcwd,\"F\":___syscall_getdents64,\"L\":___syscall_openat,\"E\":___syscall_readlinkat,\"G\":___syscall_stat64,\"x\":__embind_finalize_value_object,\"A\":__embind_register_bigint,\"O\":__embind_register_bool,\"N\":__embind_register_emval,\"v\":__embind_register_float,\"g\":__embind_register_function,\"d\":__embind_register_integer,\"c\":__embind_register_memory_view,\"u\":__embind_register_std_string,\"m\":__embind_register_std_wstring,\"y\":__embind_register_value_object,\"e\":__embind_register_value_object_field,\"P\":__embind_register_void,\"r\":__emval_as,\"i\":__emval_call_void_method,\"a\":__emval_decref,\"p\":__emval_get_global,\"j\":__emval_get_method_caller,\"s\":__emval_get_property,\"f\":__emval_incref,\"o\":__emval_new,\"w\":__emval_new_cstring,\"q\":__emval_run_destructors,\"k\":__emval_take_value,\"n\":_abort,\"h\":_emscripten_asm_const_int,\"D\":_emscripten_get_heap_max,\"M\":_emscripten_memcpy_big,\"C\":_emscripten_resize_heap,\"H\":_environ_get,\"I\":_environ_sizes_get,\"l\":_fd_close,\"K\":_fd_read,\"z\":_fd_seek,\"t\":_fd_write,\"B\":_strftime_l};var asm=createWasm();var ___wasm_call_ctors=Module[\"___wasm_call_ctors\"]=function(){return(___wasm_call_ctors=Module[\"___wasm_call_ctors\"]=Module[\"asm\"][\"R\"]).apply(null,arguments)};var _main=Module[\"_main\"]=function(){return(_main=Module[\"_main\"]=Module[\"asm\"][\"S\"]).apply(null,arguments)};var _malloc=Module[\"_malloc\"]=function(){return(_malloc=Module[\"_malloc\"]=Module[\"asm\"][\"U\"]).apply(null,arguments)};var _free=Module[\"_free\"]=function(){return(_free=Module[\"_free\"]=Module[\"asm\"][\"V\"]).apply(null,arguments)};var ___getTypeName=Module[\"___getTypeName\"]=function(){return(___getTypeName=Module[\"___getTypeName\"]=Module[\"asm\"][\"W\"]).apply(null,arguments)};var __embind_initialize_bindings=Module[\"__embind_initialize_bindings\"]=function(){return(__embind_initialize_bindings=Module[\"__embind_initialize_bindings\"]=Module[\"asm\"][\"X\"]).apply(null,arguments)};var ___cxa_is_pointer_type=Module[\"___cxa_is_pointer_type\"]=function(){return(___cxa_is_pointer_type=Module[\"___cxa_is_pointer_type\"]=Module[\"asm\"][\"Y\"]).apply(null,arguments)};var dynCall_viij=Module[\"dynCall_viij\"]=function(){return(dynCall_viij=Module[\"dynCall_viij\"]=Module[\"asm\"][\"Z\"]).apply(null,arguments)};var dynCall_vij=Module[\"dynCall_vij\"]=function(){return(dynCall_vij=Module[\"dynCall_vij\"]=Module[\"asm\"][\"_\"]).apply(null,arguments)};var dynCall_iij=Module[\"dynCall_iij\"]=function(){return(dynCall_iij=Module[\"dynCall_iij\"]=Module[\"asm\"][\"$\"]).apply(null,arguments)};var dynCall_viji=Module[\"dynCall_viji\"]=function(){return(dynCall_viji=Module[\"dynCall_viji\"]=Module[\"asm\"][\"aa\"]).apply(null,arguments)};var dynCall_jiji=Module[\"dynCall_jiji\"]=function(){return(dynCall_jiji=Module[\"dynCall_jiji\"]=Module[\"asm\"][\"ba\"]).apply(null,arguments)};var dynCall_viijii=Module[\"dynCall_viijii\"]=function(){return(dynCall_viijii=Module[\"dynCall_viijii\"]=Module[\"asm\"][\"ca\"]).apply(null,arguments)};var dynCall_iiiiij=Module[\"dynCall_iiiiij\"]=function(){return(dynCall_iiiiij=Module[\"dynCall_iiiiij\"]=Module[\"asm\"][\"da\"]).apply(null,arguments)};var dynCall_iiiiijj=Module[\"dynCall_iiiiijj\"]=function(){return(dynCall_iiiiijj=Module[\"dynCall_iiiiijj\"]=Module[\"asm\"][\"ea\"]).apply(null,arguments)};var dynCall_iiiiiijj=Module[\"dynCall_iiiiiijj\"]=function(){return(dynCall_iiiiiijj=Module[\"dynCall_iiiiiijj\"]=Module[\"asm\"][\"fa\"]).apply(null,arguments)};var ___start_em_js=Module[\"___start_em_js\"]=638316;var ___stop_em_js=Module[\"___stop_em_js\"]=638383;var calledRun;dependenciesFulfilled=function runCaller(){if(!calledRun)run();if(!calledRun)dependenciesFulfilled=runCaller};function callMain(args){var entryFunction=Module[\"_main\"];var argc=0;var argv=0;try{var ret=entryFunction(argc,argv);exitJS(ret,true);return ret}catch(e){return handleException(e)}}function run(args){args=args||arguments_;if(runDependencies>0){return}preRun();if(runDependencies>0){return}function doRun(){if(calledRun)return;calledRun=true;Module[\"calledRun\"]=true;if(ABORT)return;initRuntime();preMain();readyPromiseResolve(Module);if(Module[\"onRuntimeInitialized\"])Module[\"onRuntimeInitialized\"]();if(shouldRunNow)callMain(args);postRun()}if(Module[\"setStatus\"]){Module[\"setStatus\"](\"Running...\");setTimeout(function(){setTimeout(function(){Module[\"setStatus\"](\"\")},1);doRun()},1)}else{doRun()}}if(Module[\"preInit\"]){if(typeof Module[\"preInit\"]==\"function\")Module[\"preInit\"]=[Module[\"preInit\"]];while(Module[\"preInit\"].length>0){Module[\"preInit\"].pop()()}}var shouldRunNow=true;if(Module[\"noInitialRun\"])shouldRunNow=false;run();\n\n\n  return ICRPolySegApp.ready\n}\n);\n})();\nexport default ICRPolySegApp;","import launcher from './ICRPolySeg.js';\r\nimport wasm from './ICRPolySeg.wasm';\r\n\r\nexport default class ICRPolySeg {\r\n  constructor() {\r\n    this._instance;\r\n  }\r\n\r\n  get instance() {\r\n    if (this._instance) {\r\n      return this._instance;\r\n    }\r\n\r\n    throw new Error('ICRPolySeg is not initialized.');\r\n  }\r\n\r\n  async initialize(params = {}) {\r\n    this._instance = await launcher({\r\n      locateFile: (f) => {\r\n        if (f.endsWith('.wasm')) {\r\n          return wasm;\r\n        }\r\n        return f;\r\n      },\r\n      ...params\r\n    });\r\n  }\r\n}\r\n","import { m as macro } from '../../macros2.js';\nimport vtkPolyData from '../../Common/DataModel/PolyData.js';\n\nconst Dir = {\n  Forward: 1,\n  Backward: -1\n};\nconst visited = new Set();\nfunction vtkContourLoopExtraction(publicAPI, model) {\n  publicAPI.requestData = (inData, outData) => {\n    const [input] = inData;\n    if (!outData[0]) {\n      outData[0] = vtkPolyData.newInstance();\n    }\n    const [output] = outData;\n    publicAPI.extractContours(input, output);\n    output.modified();\n  };\n  publicAPI.traverseLoop = (pd, dir, startLineId, startPtId, loopPoints) => {\n    let lineId = startLineId;\n    let lastPtId = startPtId;\n    let terminated = false;\n    let numInserted = 0;\n    while (!terminated) {\n      const {\n        cellPointIds\n      } = pd.getCellPoints(lineId);\n      if (!cellPointIds) {\n        // eslint-disable-next-line no-continue\n        continue;\n      }\n      lastPtId = cellPointIds[0] !== lastPtId ? cellPointIds[0] : cellPointIds[1];\n      numInserted++;\n\n      // parametric point value\n      const t = dir * numInserted;\n      loopPoints.push({\n        t,\n        ptId: lastPtId\n      });\n      const lineCell = pd.getPointCells(lastPtId);\n      if (lineCell.length !== 2 || lastPtId === startPtId) {\n        // looped\n        return lastPtId;\n      }\n      if (lineCell.length === 2) {\n        // continue along loop\n        lineId = lineCell[0] !== lineId ? lineCell[0] : lineCell[1];\n        visited.add(lineId);\n      } else {\n        // empty or invalid cell\n        terminated = true;\n      }\n    }\n    return lastPtId;\n  };\n  publicAPI.extractContours = (input, output) => {\n    const loops = [];\n    visited.clear();\n    const inLines = input.getLines();\n    output.getPoints().setData(Float32Array.from(input.getPoints().getData()));\n\n    // TODO skip if cached input mtime hasn't changed.\n    // iterate over input lines\n    for (let li = 0; li < inLines.getNumberOfCells(); li++) {\n      if (visited.has(li)) {\n        // eslint-disable-next-line no-continue\n        continue;\n      }\n      const {\n        cellPointIds\n      } = input.getCellPoints(li);\n      if (!cellPointIds) {\n        // eslint-disable-next-line no-continue\n        continue;\n      }\n      visited.add(li);\n      const startPtId = cellPointIds[0];\n      const loopPoints = [];\n      loopPoints.push({\n        t: 0,\n        ptId: startPtId\n      });\n      const endPtId = publicAPI.traverseLoop(input, Dir.Forward, li, startPtId, loopPoints);\n      if (startPtId !== endPtId) {\n        // didn't find a loop. Go other direction to see where we end up\n        publicAPI.traverseLoop(input, Dir.Backward, li, startPtId, loopPoints);\n        loopPoints.sort((a, b) => a.t < b.t ? -1 : 1);\n        // make closed contour\n        if (loopPoints.length && loopPoints[0].ptId !== loopPoints[loopPoints.length - 1]?.ptId) {\n          loopPoints.push({\n            ...loopPoints[loopPoints.length - 1]\n          });\n        }\n      }\n      if (loopPoints.length) {\n        loops.push(loopPoints);\n      }\n    }\n\n    // clear output lines\n    const outLines = output.getLines();\n    outLines.resize(0);\n    loops.forEach(loop => {\n      outLines.insertNextCell(loop.map(pt => pt.ptId));\n    });\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n  macro.obj(publicAPI, model);\n  macro.algo(publicAPI, model, 1, 1);\n  vtkContourLoopExtraction(publicAPI);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkContourLoopExtraction');\n\n// ----------------------------------------------------------------------------\n\nvar index = {\n  newInstance,\n  extend\n};\n\nexport { index as default, extend, newInstance };\n","import { expose } from 'comlink';\nimport vtkImageData from '@kitware/vtk.js/Common/DataModel/ImageData';\nimport vtkDataArray from '@kitware/vtk.js/Common/Core/DataArray';\nimport ICRPolySeg from '@icr/polyseg-wasm';\nimport { utilities } from '@cornerstonejs/core';\nimport vtkPlane from '@kitware/vtk.js/Common/DataModel/Plane';\nimport vtkPolyData from '@kitware/vtk.js/Common/DataModel/PolyData';\nimport vtkContourLoopExtraction from '@kitware/vtk.js/Filters/General/ContourLoopExtraction';\nimport vtkCutter from '@kitware/vtk.js/Filters/Core/Cutter';\n\nimport { getBoundingBoxAroundShapeWorld } from '../utilities/boundingBox';\nimport { pointInShapeCallback } from '../utilities';\nimport {\n  containsPoint,\n  getAABB,\n  projectTo2D,\n} from '../utilities/math/polyline';\nimport { isPlaneIntersectingAABB } from '../utilities/planar';\n\n/**\n * Object containing methods for converting between different representations of\n * segmentations (e.g., contour, labelmap, surface, etc.) These logics\n * are used in a webworker to avoid blocking the main thread. You can\n * search for workerManager.executeTask('polySeg', ...) to see\n * how these methods are used.\n *\n * See also the webworker docs at packages/docs/docs/concepts/cornerstone-core/web-worker.md\n * to learn more about how to use webworkers in the context of Cornerstone.\n */\nconst polySegConverters = {\n  /**\n   * The polySeg instance that is used to convert between different representations\n   */\n  polySeg: null,\n  /**\n   * Utilities to keep track of the initialization state of the polySeg instance\n   * and avoid initializing it multiple times\n   */\n  polySegInitializing: false,\n  polySegInitializingPromise: null,\n  /**\n   * This method initializes the polySeg instance and sets it to this.polySeg\n   */\n  async initializePolySeg(progressCallback) {\n    if (this.polySegInitializing) {\n      await this.polySegInitializingPromise;\n      return;\n    }\n\n    if (this.polySeg?.instance) {\n      return;\n    }\n\n    this.polySegInitializing = true;\n    this.polySegInitializingPromise = new Promise((resolve) => {\n      this.polySeg = new ICRPolySeg();\n      this.polySeg\n        .initialize({\n          updateProgress: progressCallback,\n        })\n        .then(() => {\n          this.polySegInitializing = false;\n          resolve();\n        });\n    });\n\n    await this.polySegInitializingPromise;\n  },\n  /**\n   * Converts a contour to a surface using the PolySeg library.\n   * @param {Object} args - The arguments for the conversion.\n   * @param {Array} args.polylines - The polylines representing the contour.\n   * @param {Array} args.numPointsArray - The number of points in each polyline.\n   * @param {...Function} callbacks - Optional callback functions.\n   * @returns {Promise} - A promise that resolves to the converted surface.\n   */\n  async convertContourToSurface(args, ...callbacks) {\n    const { polylines, numPointsArray } = args;\n    const [progressCallback] = callbacks;\n    await this.initializePolySeg(progressCallback);\n    const results = await this.polySeg.instance.convertContourRoiToSurface(\n      polylines,\n      numPointsArray\n    );\n\n    return results;\n  },\n  /**\n   * Converts a labelmap to a surface using the specified arguments.\n   * @param {Object} args - The arguments for the conversion.\n   * @param {Array} args.scalarData - The scalar data of the labelmap.\n   * @param {Array} args.dimensions - The dimensions of the labelmap.\n   * @param {Array} args.spacing - The spacing of the labelmap.\n   * @param {Array} args.direction - The direction of the labelmap.\n   * @param {Array} args.origin - The origin of the labelmap.\n   * @param {number} args.segmentIndex - The segment index of the labelmap.\n   * @param {Function} progressCallback - The callback function for progress updates.\n   * @returns {Promise} - A promise that resolves with the converted surface results.\n   */\n  async convertLabelmapToSurface(args, ...callbacks) {\n    const [progressCallback] = callbacks;\n    await this.initializePolySeg(progressCallback);\n\n    const results = this.polySeg.instance.convertLabelmapToSurface(\n      args.scalarData,\n      args.dimensions,\n      args.spacing,\n      args.direction,\n      args.origin,\n      [args.segmentIndex]\n    );\n    return results;\n  },\n  /**\n   * Converts a contour to a volume labelmap.\n   * @param {Object} args - The arguments for the conversion.\n   * @param {Array} args.segmentIndices - The indices of the segments.\n   * @param {Array} args.scalarData - The scalar data.\n   * @param {Map} args.annotationUIDsInSegmentMap - The map of annotation UIDs in segment.\n   * @param {Array} args.dimensions - The dimensions of the image data.\n   * @param {Array} args.origin - The origin of the image data.\n   * @param {Array} args.direction - The direction of the image data.\n   * @param {Array} args.spacing - The spacing of the image data.\n   * @param {...Function} callbacks - Optional callbacks.\n   * @param {Function} callbacks[0] - The progress callback.\n   * @returns {Array} - The scalar data of the segmentation voxel manager.\n   */\n  async convertContourToVolumeLabelmap(args, ...callbacks) {\n    const [progressCallback] = callbacks;\n    const polySeg = await new ICRPolySeg();\n    await polySeg.initialize({\n      updateProgress: progressCallback,\n    });\n\n    const {\n      segmentIndices,\n      scalarData,\n      annotationUIDsInSegmentMap,\n      dimensions,\n      origin,\n      direction,\n      spacing,\n    } = args;\n\n    const segmentationVoxelManager =\n      utilities.VoxelManager.createVolumeVoxelManager(dimensions, scalarData);\n\n    const imageData = vtkImageData.newInstance();\n    imageData.setDimensions(dimensions);\n    imageData.setOrigin(origin);\n    imageData.setDirection(direction);\n    imageData.setSpacing(spacing);\n\n    const scalarArray = vtkDataArray.newInstance({\n      name: 'Pixels',\n      numberOfComponents: 1,\n      values: scalarData,\n    });\n\n    imageData.getPointData().setScalars(scalarArray);\n\n    imageData.modified();\n\n    for (const index of segmentIndices) {\n      const annotations = annotationUIDsInSegmentMap.get(index);\n\n      for (const annotation of annotations) {\n        if (!annotation.polyline) {\n          continue;\n        }\n\n        const { polyline, holesPolyline } = annotation;\n        const bounds = getBoundingBoxAroundShapeWorld(polyline);\n\n        const [iMin, jMin, kMin] = utilities.transformWorldToIndex(imageData, [\n          bounds[0][0],\n          bounds[1][0],\n          bounds[2][0],\n        ]);\n\n        const [iMax, jMax, kMax] = utilities.transformWorldToIndex(imageData, [\n          bounds[0][1],\n          bounds[1][1],\n          bounds[2][1],\n        ]);\n\n        const { projectedPolyline, sharedDimensionIndex } =\n          projectTo2D(polyline);\n\n        const holes = holesPolyline?.map((hole) => {\n          const { projectedPolyline: projectedHole } = projectTo2D(hole);\n          return projectedHole;\n        });\n\n        const firstDim = (sharedDimensionIndex + 1) % 3;\n        const secondDim = (sharedDimensionIndex + 2) % 3;\n\n        // Run the pointInShapeCallback for the combined bounding box\n        pointInShapeCallback(\n          imageData,\n          (pointLPS) => {\n            const point2D = [pointLPS[firstDim], pointLPS[secondDim]];\n\n            // Check if the point is inside any of the polylines for this segment\n            const isInside = containsPoint(projectedPolyline, point2D, {\n              holes,\n            });\n\n            return isInside;\n          },\n          ({ pointIJK }) => {\n            segmentationVoxelManager.setAtIJKPoint(pointIJK, index);\n          },\n          [\n            [iMin, iMax],\n            [jMin, jMax],\n            [kMin, kMax],\n          ]\n        );\n      }\n    }\n\n    return segmentationVoxelManager.scalarData;\n  },\n  /**\n   * Converts a contour to a stack labelmap.\n   * @param {Object} args - The arguments for the conversion.\n   * @param {Array} callbacks - Optional callbacks for progress updates.\n   * @returns {Promise<Object>} - The converted segmentations information.\n   */\n  async convertContourToStackLabelmap(args, ...callbacks) {\n    const [progressCallback] = callbacks;\n    const polySeg = await new ICRPolySeg();\n    await polySeg.initialize({\n      updateProgress: progressCallback,\n    });\n\n    const { segmentationsInfo, annotationUIDsInSegmentMap, segmentIndices } =\n      args;\n\n    const segmentationVoxelManagers = new Map();\n\n    segmentationsInfo.forEach((segmentationInfo, referencedImageId) => {\n      const { dimensions, scalarData, direction, spacing, origin } =\n        segmentationInfo;\n      const manager = utilities.VoxelManager.createVolumeVoxelManager(\n        dimensions,\n        scalarData\n      );\n\n      const imageData = vtkImageData.newInstance();\n      imageData.setDimensions(dimensions);\n      imageData.setOrigin(origin);\n      imageData.setDirection(direction);\n      imageData.setSpacing(spacing);\n\n      const scalarArray = vtkDataArray.newInstance({\n        name: 'Pixels',\n        numberOfComponents: 1,\n        values: scalarData,\n      });\n\n      imageData.getPointData().setScalars(scalarArray);\n\n      imageData.modified();\n\n      segmentationVoxelManagers.set(referencedImageId, { manager, imageData });\n    });\n\n    for (const index of segmentIndices) {\n      const annotations = annotationUIDsInSegmentMap.get(index);\n\n      for (const annotation of annotations) {\n        if (!annotation.polyline) {\n          continue;\n        }\n\n        const { polyline, holesPolyline, referencedImageId } = annotation;\n        const bounds = getBoundingBoxAroundShapeWorld(polyline);\n\n        const { manager: segmentationVoxelManager, imageData } =\n          segmentationVoxelManagers.get(referencedImageId);\n\n        const [iMin, jMin, kMin] = utilities.transformWorldToIndex(imageData, [\n          bounds[0][0],\n          bounds[1][0],\n          bounds[2][0],\n        ]);\n\n        const [iMax, jMax, kMax] = utilities.transformWorldToIndex(imageData, [\n          bounds[0][1],\n          bounds[1][1],\n          bounds[2][1],\n        ]);\n\n        const { projectedPolyline, sharedDimensionIndex } =\n          projectTo2D(polyline);\n\n        const holes = holesPolyline?.map((hole) => {\n          const { projectedPolyline: projectedHole } = projectTo2D(hole);\n          return projectedHole;\n        });\n\n        const firstDim = (sharedDimensionIndex + 1) % 3;\n        const secondDim = (sharedDimensionIndex + 2) % 3;\n\n        // Run the pointInShapeCallback for the combined bounding box\n        pointInShapeCallback(\n          imageData,\n          (pointLPS) => {\n            const point2D = [pointLPS[firstDim], pointLPS[secondDim]];\n\n            // Check if the point is inside any of the polylines for this segment\n            const isInside = containsPoint(projectedPolyline, point2D, {\n              holes,\n            });\n\n            return isInside;\n          },\n          ({ pointIJK }) => {\n            segmentationVoxelManager.setAtIJKPoint(pointIJK, index);\n          },\n          [\n            [iMin, iMax],\n            [jMin, jMax],\n            [kMin, kMax],\n          ]\n        );\n      }\n    }\n\n    segmentationsInfo.forEach((segmentationInfo, referencedImageId) => {\n      const { manager: segmentationVoxelManager } =\n        segmentationVoxelManagers.get(referencedImageId);\n\n      segmentationInfo.scalarData = segmentationVoxelManager.scalarData;\n    });\n    return segmentationsInfo;\n  },\n  /**\n   * Converts a surface to a volume labelmap.\n   *\n   * @param {Object} args - The arguments for the conversion.\n   * @param {Array} args.points - The points defining the surface.\n   * @param {Array} args.polys - The polygons defining the surface.\n   * @param {Array} args.dimensions - The dimensions of the volume.\n   * @param {Array} args.spacing - The spacing between voxels in the volume.\n   * @param {Array} args.direction - The direction of the volume.\n   * @param {Array} args.origin - The origin of the volume.\n   * @param {Function} progressCallback - The callback function for reporting progress.\n   * @returns {Promise} - A promise that resolves with the converted labelmap.\n   */\n  async convertSurfaceToVolumeLabelmap(args, ...callbacks) {\n    const [progressCallback] = callbacks;\n    await this.initializePolySeg(progressCallback);\n\n    const results = this.polySeg.instance.convertSurfaceToLabelmap(\n      args.points,\n      args.polys,\n      args.dimensions,\n      args.spacing,\n      args.direction,\n      args.origin\n    );\n\n    return results;\n  },\n  /**\n   * Converts surfaces to a volume labelmap.\n   * @param {Object} args - The arguments for the conversion.\n   * @param {Map} args.segmentsInfo - A map containing information about the segments.\n   * @param {Function} progressCallback - A callback function for reporting progress.\n   * @returns {Uint8Array} - The resulting volume labelmap.\n   */\n  async convertSurfacesToVolumeLabelmap(args, ...callbacks) {\n    const [progressCallback] = callbacks;\n    await this.initializePolySeg(progressCallback);\n\n    const { segmentsInfo } = args;\n\n    const promises = Array.from(segmentsInfo.keys()).map((segmentIndex) => {\n      const { points, polys } = segmentsInfo.get(segmentIndex);\n      const result = this.polySeg.instance.convertSurfaceToLabelmap(\n        points,\n        polys,\n        args.dimensions,\n        args.spacing,\n        args.direction,\n        args.origin\n      );\n\n      return {\n        ...result,\n        segmentIndex,\n      };\n    });\n\n    const results = await Promise.all(promises);\n\n    const targetImageData = vtkImageData.newInstance();\n    targetImageData.setDimensions(args.dimensions);\n    targetImageData.setOrigin(args.origin);\n    targetImageData.setSpacing(args.spacing);\n    targetImageData.setDirection(args.direction);\n\n    const totalSize =\n      args.dimensions[0] * args.dimensions[1] * args.dimensions[2];\n\n    const scalarArray = vtkDataArray.newInstance({\n      name: 'Pixels',\n      numberOfComponents: 1,\n      values: new Uint8Array(totalSize),\n    });\n\n    targetImageData.getPointData().setScalars(scalarArray);\n    targetImageData.modified();\n\n    // we need to then consolidate the results into a single volume\n    // by looping into each voxel with pointInShapeCallback\n    // and check if the voxel is inside any of the reconstructed\n    // labelmaps\n\n    const segmentationVoxelManager =\n      utilities.VoxelManager.createVolumeVoxelManager(\n        args.dimensions,\n        targetImageData.getPointData().getScalars().getData()\n      );\n\n    const outputVolumesInfo = results.map((result) => {\n      const { data, dimensions, direction, origin, spacing } = result;\n      const volume = vtkImageData.newInstance();\n      volume.setDimensions(dimensions);\n      volume.setOrigin(origin);\n      volume.setSpacing(spacing);\n      volume.setDirection(direction);\n\n      const scalarArray = vtkDataArray.newInstance({\n        name: 'Pixels',\n        numberOfComponents: 1,\n        values: data,\n      });\n\n      volume.getPointData().setScalars(scalarArray);\n\n      volume.modified();\n\n      const voxelManager = utilities.VoxelManager.createVolumeVoxelManager(\n        dimensions,\n        data\n      );\n\n      const extent = volume.getExtent(); // e.g., [0, 176, 0, 268, 0, 337] for dimensions of [177, 269, 338]\n\n      return {\n        volume,\n        voxelManager,\n        extent,\n        scalarData: data,\n        segmentIndex: result.segmentIndex,\n      };\n    });\n\n    pointInShapeCallback(\n      targetImageData,\n      () => true, // we want to loop into all voxels\n      ({ pointIJK, pointLPS }) => {\n        // Check if the point is inside any of the reconstructed labelmaps\n        // Todo: we can optimize this by returning early if the bounding box\n        // of the point is outside the bounding box of the labelmap\n\n        try {\n          for (const volumeInfo of outputVolumesInfo) {\n            const { volume, extent, voxelManager, segmentIndex } = volumeInfo;\n\n            const index = volume.worldToIndex(pointLPS);\n\n            // check if the ijk point is inside the volume\n            if (\n              index[0] < extent[0] ||\n              index[0] > extent[1] ||\n              index[1] < extent[2] ||\n              index[1] > extent[3] ||\n              index[2] < extent[4] ||\n              index[2] > extent[5]\n            ) {\n              continue;\n            }\n\n            const roundedIndex = index.map(Math.round);\n            const value = voxelManager.getAtIJK(...roundedIndex);\n            if (value > 0) {\n              segmentationVoxelManager.setAtIJKPoint(pointIJK, segmentIndex);\n              break;\n            }\n          }\n        } catch (error) {\n          // right now there is weird error if the point is outside the volume\n        }\n      }\n    );\n\n    return segmentationVoxelManager.scalarData;\n  },\n  getSurfacesAABBs({ surfacesInfo }) {\n    const aabbs = new Map();\n    for (const { points, id } of surfacesInfo) {\n      const aabb = getAABB(points, { numDimensions: 3 });\n      aabbs.set(id, aabb);\n    }\n    return aabbs;\n  },\n  /**\n   * Cuts the surfaces into planes.\n   *\n   * @param {Object} options - The options object.\n   * @param {Array} options.planesInfo - The information about the planes.\n   * @param {Array} options.surfacesInfo - The information about the surfaces.\n   * @param {Function} progressCallback - The callback function for progress updates.\n   * @param {Function} updateCacheCallback - The callback function for updating the cache.\n   */\n  cutSurfacesIntoPlanes(\n    { planesInfo, surfacesInfo, surfacesAABB = new Map() },\n    progressCallback,\n    updateCacheCallback\n  ) {\n    const numberOfPlanes = planesInfo.length;\n    const cutter = vtkCutter.newInstance();\n\n    const plane1 = vtkPlane.newInstance();\n\n    cutter.setCutFunction(plane1);\n\n    const surfacePolyData = vtkPolyData.newInstance();\n\n    try {\n      for (const [index, planeInfo] of planesInfo.entries()) {\n        const { sliceIndex, planes } = planeInfo;\n\n        const polyDataResults = new Map();\n        for (const polyDataInfo of surfacesInfo) {\n          const { points, polys, id } = polyDataInfo;\n\n          const aabb3 =\n            surfacesAABB.get(id) || getAABB(points, { numDimensions: 3 });\n\n          if (!surfacesAABB.has(id)) {\n            surfacesAABB.set(id, aabb3);\n          }\n\n          const { minX, minY, minZ, maxX, maxY, maxZ } = aabb3;\n\n          const { origin, normal } = planes[0];\n\n          // Check if the plane intersects the AABB\n          if (\n            !isPlaneIntersectingAABB(\n              origin,\n              normal,\n              minX,\n              minY,\n              minZ,\n              maxX,\n              maxY,\n              maxZ\n            )\n          ) {\n            continue;\n          }\n\n          surfacePolyData.getPoints().setData(points, 3);\n          surfacePolyData.getPolys().setData(polys, 3);\n          surfacePolyData.modified();\n\n          cutter.setInputData(surfacePolyData);\n          plane1.setOrigin(origin);\n          plane1.setNormal(normal);\n\n          try {\n            cutter.update();\n          } catch (e) {\n            console.warn('Error during clipping', e);\n            continue;\n          }\n\n          const polyData = cutter.getOutputData();\n\n          const cutterOutput = polyData;\n          cutterOutput.buildLinks();\n          const loopExtraction = vtkContourLoopExtraction.newInstance();\n          loopExtraction.setInputData(cutterOutput);\n\n          const loopOutput = loopExtraction.getOutputData();\n          if (polyData) {\n            polyDataResults.set(id, {\n              points: loopOutput.getPoints().getData(),\n              lines: loopOutput.getLines().getData(),\n              numberOfCells: loopOutput.getLines().getNumberOfCells(),\n            });\n          }\n        }\n\n        progressCallback({ progress: (index + 1) / numberOfPlanes });\n\n        updateCacheCallback({ sliceIndex, polyDataResults });\n      }\n    } catch (e) {\n      console.warn('Error during processing', e);\n    } finally {\n      // Cleanup on completion\n      surfacesInfo = null;\n      plane1.delete();\n    }\n  },\n};\n\nexpose(polySegConverters);\n","import { m as macro } from '../../macros2.js';\nimport { b as roundVector, c as clampVector } from '../Core/Math/index.js';\nimport vtkBoundingBox from './BoundingBox.js';\nimport vtkDataSet from './DataSet.js';\nimport vtkStructuredData from './StructuredData.js';\nimport { StructuredType } from './StructuredData/Constants.js';\nimport { mat3, mat4, vec3 } from 'gl-matrix';\n\nconst {\n  vtkErrorMacro\n} = macro;\n\n// ----------------------------------------------------------------------------\n// vtkImageData methods\n// ----------------------------------------------------------------------------\n\nfunction vtkImageData(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkImageData');\n  publicAPI.setExtent = function () {\n    if (model.deleted) {\n      vtkErrorMacro('instance deleted - cannot call any method');\n      return false;\n    }\n    for (var _len = arguments.length, inExtent = new Array(_len), _key = 0; _key < _len; _key++) {\n      inExtent[_key] = arguments[_key];\n    }\n    const extentArray = inExtent.length === 1 ? inExtent[0] : inExtent;\n    if (extentArray.length !== 6) {\n      return false;\n    }\n    const changeDetected = model.extent.some((item, index) => item !== extentArray[index]);\n    if (changeDetected) {\n      model.extent = extentArray.slice();\n      model.dataDescription = vtkStructuredData.getDataDescriptionFromExtent(model.extent);\n      publicAPI.modified();\n    }\n    return changeDetected;\n  };\n  publicAPI.setDimensions = function () {\n    let i;\n    let j;\n    let k;\n    if (model.deleted) {\n      vtkErrorMacro('instance deleted - cannot call any method');\n      return;\n    }\n    if (arguments.length === 1) {\n      const array = arguments.length <= 0 ? undefined : arguments[0];\n      i = array[0];\n      j = array[1];\n      k = array[2];\n    } else if (arguments.length === 3) {\n      i = arguments.length <= 0 ? undefined : arguments[0];\n      j = arguments.length <= 1 ? undefined : arguments[1];\n      k = arguments.length <= 2 ? undefined : arguments[2];\n    } else {\n      vtkErrorMacro('Bad dimension specification');\n      return;\n    }\n    publicAPI.setExtent(0, i - 1, 0, j - 1, 0, k - 1);\n  };\n  publicAPI.getDimensions = () => [model.extent[1] - model.extent[0] + 1, model.extent[3] - model.extent[2] + 1, model.extent[5] - model.extent[4] + 1];\n  publicAPI.getNumberOfCells = () => {\n    const dims = publicAPI.getDimensions();\n    let nCells = 1;\n    for (let i = 0; i < 3; i++) {\n      if (dims[i] === 0) {\n        return 0;\n      }\n      if (dims[i] > 1) {\n        nCells *= dims[i] - 1;\n      }\n    }\n    return nCells;\n  };\n  publicAPI.getNumberOfPoints = () => {\n    const dims = publicAPI.getDimensions();\n    return dims[0] * dims[1] * dims[2];\n  };\n  publicAPI.getPoint = index => {\n    const dims = publicAPI.getDimensions();\n    if (dims[0] === 0 || dims[1] === 0 || dims[2] === 0) {\n      vtkErrorMacro('Requesting a point from an empty image.');\n      return null;\n    }\n    const ijk = new Float64Array(3);\n    switch (model.dataDescription) {\n      case StructuredType.EMPTY:\n        return null;\n      case StructuredType.SINGLE_POINT:\n        break;\n      case StructuredType.X_LINE:\n        ijk[0] = index;\n        break;\n      case StructuredType.Y_LINE:\n        ijk[1] = index;\n        break;\n      case StructuredType.Z_LINE:\n        ijk[2] = index;\n        break;\n      case StructuredType.XY_PLANE:\n        ijk[0] = index % dims[0];\n        ijk[1] = index / dims[0];\n        break;\n      case StructuredType.YZ_PLANE:\n        ijk[1] = index % dims[1];\n        ijk[2] = index / dims[1];\n        break;\n      case StructuredType.XZ_PLANE:\n        ijk[0] = index % dims[0];\n        ijk[2] = index / dims[0];\n        break;\n      case StructuredType.XYZ_GRID:\n        ijk[0] = index % dims[0];\n        ijk[1] = index / dims[0] % dims[1];\n        ijk[2] = index / (dims[0] * dims[1]);\n        break;\n      default:\n        vtkErrorMacro('Invalid dataDescription');\n        break;\n    }\n    const coords = [0, 0, 0];\n    publicAPI.indexToWorld(ijk, coords);\n    return coords;\n  };\n\n  // vtkCell *GetCell(vtkIdType cellId) VTK_OVERRIDE;\n  // void GetCell(vtkIdType cellId, vtkGenericCell *cell) VTK_OVERRIDE;\n  // void GetCellBounds(vtkIdType cellId, double bounds[6]) VTK_OVERRIDE;\n  // virtual vtkIdType FindPoint(double x, double y, double z)\n  // {\n  //   return this->vtkDataSet::FindPoint(x, y, z);\n  // }\n  // vtkIdType FindPoint(double x[3]) VTK_OVERRIDE;\n  // vtkIdType FindCell(\n  //   double x[3], vtkCell *cell, vtkIdType cellId, double tol2,\n  //   int& subId, double pcoords[3], double *weights) VTK_OVERRIDE;\n  // vtkIdType FindCell(\n  //   double x[3], vtkCell *cell, vtkGenericCell *gencell,\n  //   vtkIdType cellId, double tol2, int& subId,\n  //   double pcoords[3], double *weights) VTK_OVERRIDE;\n  // vtkCell *FindAndGetCell(double x[3], vtkCell *cell, vtkIdType cellId,\n  //                                 double tol2, int& subId, double pcoords[3],\n  //                                 double *weights) VTK_OVERRIDE;\n  // int GetCellType(vtkIdType cellId) VTK_OVERRIDE;\n  // void GetCellPoints(vtkIdType cellId, vtkIdList *ptIds) VTK_OVERRIDE\n  //   {vtkStructuredData::GetCellPoints(cellId,ptIds,this->DataDescription,\n  //                                     this->GetDimensions());}\n  // void GetPointCells(vtkIdType ptId, vtkIdList *cellIds) VTK_OVERRIDE\n  //   {vtkStructuredData::GetPointCells(ptId,cellIds,this->GetDimensions());}\n  // void ComputeBounds() VTK_OVERRIDE;\n  // int GetMaxCellSize() VTK_OVERRIDE {return 8;}; //voxel is the largest\n\n  publicAPI.getBounds = () => publicAPI.extentToBounds(publicAPI.getSpatialExtent());\n  publicAPI.extentToBounds = ex => vtkBoundingBox.transformBounds(ex, model.indexToWorld);\n  publicAPI.getSpatialExtent = () => vtkBoundingBox.inflate([...model.extent], 0.5);\n\n  // Internal, shouldn't need to call this manually.\n  publicAPI.computeTransforms = () => {\n    mat4.fromTranslation(model.indexToWorld, model.origin);\n    model.indexToWorld[0] = model.direction[0];\n    model.indexToWorld[1] = model.direction[1];\n    model.indexToWorld[2] = model.direction[2];\n    model.indexToWorld[4] = model.direction[3];\n    model.indexToWorld[5] = model.direction[4];\n    model.indexToWorld[6] = model.direction[5];\n    model.indexToWorld[8] = model.direction[6];\n    model.indexToWorld[9] = model.direction[7];\n    model.indexToWorld[10] = model.direction[8];\n    mat4.scale(model.indexToWorld, model.indexToWorld, model.spacing);\n    mat4.invert(model.worldToIndex, model.indexToWorld);\n  };\n  publicAPI.indexToWorld = function (ain) {\n    let aout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    vec3.transformMat4(aout, ain, model.indexToWorld);\n    return aout;\n  };\n  publicAPI.indexToWorldVec3 = publicAPI.indexToWorld;\n  publicAPI.worldToIndex = function (ain) {\n    let aout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    vec3.transformMat4(aout, ain, model.worldToIndex);\n    return aout;\n  };\n  publicAPI.worldToIndexVec3 = publicAPI.worldToIndex;\n  publicAPI.indexToWorldBounds = function (bin) {\n    let bout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    return vtkBoundingBox.transformBounds(bin, model.indexToWorld, bout);\n  };\n  publicAPI.worldToIndexBounds = function (bin) {\n    let bout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    return vtkBoundingBox.transformBounds(bin, model.worldToIndex, bout);\n  };\n\n  // Make sure the transform is correct\n  publicAPI.onModified(publicAPI.computeTransforms);\n  publicAPI.computeTransforms();\n  publicAPI.getCenter = () => vtkBoundingBox.getCenter(publicAPI.getBounds());\n  publicAPI.computeHistogram = function (worldBounds) {\n    let voxelFunc = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    const bounds = [0, 0, 0, 0, 0, 0];\n    publicAPI.worldToIndexBounds(worldBounds, bounds);\n    const point1 = [0, 0, 0];\n    const point2 = [0, 0, 0];\n    vtkBoundingBox.computeCornerPoints(bounds, point1, point2);\n    roundVector(point1, point1);\n    roundVector(point2, point2);\n    const dimensions = publicAPI.getDimensions();\n    clampVector(point1, [0, 0, 0], [dimensions[0] - 1, dimensions[1] - 1, dimensions[2] - 1], point1);\n    clampVector(point2, [0, 0, 0], [dimensions[0] - 1, dimensions[1] - 1, dimensions[2] - 1], point2);\n    const yStride = dimensions[0];\n    const zStride = dimensions[0] * dimensions[1];\n    const pixels = publicAPI.getPointData().getScalars().getData();\n    let maximum = -Infinity;\n    let minimum = Infinity;\n    let sumOfSquares = 0;\n    let isum = 0;\n    let inum = 0;\n    for (let z = point1[2]; z <= point2[2]; z++) {\n      for (let y = point1[1]; y <= point2[1]; y++) {\n        let index = point1[0] + y * yStride + z * zStride;\n        for (let x = point1[0]; x <= point2[0]; x++) {\n          if (!voxelFunc || voxelFunc([x, y, z], bounds)) {\n            const pixel = pixels[index];\n            if (pixel > maximum) maximum = pixel;\n            if (pixel < minimum) minimum = pixel;\n            sumOfSquares += pixel * pixel;\n            isum += pixel;\n            inum += 1;\n          }\n          ++index;\n        }\n      }\n    }\n    const average = inum > 0 ? isum / inum : 0;\n    const variance = inum ? Math.abs(sumOfSquares / inum - average * average) : 0;\n    const sigma = Math.sqrt(variance);\n    return {\n      minimum,\n      maximum,\n      average,\n      variance,\n      sigma,\n      count: inum\n    };\n  };\n\n  // TODO: use the unimplemented `vtkDataSetAttributes` for scalar length, that is currently also a TODO (GetNumberOfComponents).\n  // Scalar data could be tuples for color information?\n  publicAPI.computeIncrements = function (extent) {\n    let numberOfComponents = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n    const increments = [];\n    let incr = numberOfComponents;\n\n    // Calculate array increment offsets\n    // similar to c++ vtkImageData::ComputeIncrements\n    for (let idx = 0; idx < 3; ++idx) {\n      increments[idx] = incr;\n      incr *= extent[idx * 2 + 1] - extent[idx * 2] + 1;\n    }\n    return increments;\n  };\n\n  /**\n   * @param {Number[]} index the localized `[i,j,k]` pixel array position. Float values will be rounded.\n   * @return {Number} the corresponding flattened index in the scalar array\n   */\n  publicAPI.computeOffsetIndex = _ref => {\n    let [i, j, k] = _ref;\n    const extent = publicAPI.getExtent();\n    const numberOfComponents = publicAPI.getPointData().getScalars().getNumberOfComponents();\n    const increments = publicAPI.computeIncrements(extent, numberOfComponents);\n    // Use the array increments to find the pixel index\n    // similar to c++ vtkImageData::GetArrayPointer\n    // Math.floor to catch \"practically 0\" e^-15 scenarios.\n    return Math.floor((Math.round(i) - extent[0]) * increments[0] + (Math.round(j) - extent[2]) * increments[1] + (Math.round(k) - extent[4]) * increments[2]);\n  };\n\n  /**\n   * @param {Number[]} xyz the [x,y,z] Array in world coordinates\n   * @return {Number|NaN} the corresponding pixel's index in the scalar array\n   */\n  publicAPI.getOffsetIndexFromWorld = xyz => {\n    const extent = publicAPI.getExtent();\n    const index = publicAPI.worldToIndex(xyz);\n\n    // Confirm indexed i,j,k coords are within the bounds of the volume\n    for (let idx = 0; idx < 3; ++idx) {\n      if (index[idx] < extent[idx * 2] || index[idx] > extent[idx * 2 + 1]) {\n        vtkErrorMacro(`GetScalarPointer: Pixel ${index} is not in memory. Current extent = ${extent}`);\n        return NaN;\n      }\n    }\n\n    // Assumed the index here is within 0 <-> scalarData.length, but doesn't hurt to check upstream\n    return publicAPI.computeOffsetIndex(index);\n  };\n  /**\n   * @param {Number[]} xyz the [x,y,z] Array in world coordinates\n   * @param {Number?} comp the scalar component index for multi-component scalars\n   * @return {Number|NaN} the corresponding pixel's scalar value\n   */\n  publicAPI.getScalarValueFromWorld = function (xyz) {\n    let comp = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    const numberOfComponents = publicAPI.getPointData().getScalars().getNumberOfComponents();\n    if (comp < 0 || comp >= numberOfComponents) {\n      vtkErrorMacro(`GetScalarPointer: Scalar Component ${comp} is not within bounds. Current Scalar numberOfComponents: ${numberOfComponents}`);\n      return NaN;\n    }\n    const offsetIndex = publicAPI.getOffsetIndexFromWorld(xyz);\n    if (Number.isNaN(offsetIndex)) {\n      // VTK Error Macro will have been tripped already, no need to do it again,\n      return offsetIndex;\n    }\n    return publicAPI.getPointData().getScalars().getComponent(offsetIndex, comp);\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  direction: null,\n  // a mat3\n  indexToWorld: null,\n  // a mat4\n  worldToIndex: null,\n  // a mat4\n  spacing: [1.0, 1.0, 1.0],\n  origin: [0.0, 0.0, 0.0],\n  extent: [0, -1, 0, -1, 0, -1],\n  dataDescription: StructuredType.EMPTY\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Inheritance\n  vtkDataSet.extend(publicAPI, model, initialValues);\n  if (!model.direction) {\n    model.direction = mat3.identity(new Float64Array(9));\n  } else if (Array.isArray(model.direction)) {\n    model.direction = new Float64Array(model.direction.slice(0, 9));\n  }\n  model.indexToWorld = new Float64Array(16);\n  model.worldToIndex = new Float64Array(16);\n\n  // Set/Get methods\n  macro.get(publicAPI, model, ['indexToWorld', 'worldToIndex']);\n  macro.setGetArray(publicAPI, model, ['origin', 'spacing'], 3);\n  macro.setGetArray(publicAPI, model, ['direction'], 9);\n  macro.getArray(publicAPI, model, ['extent'], 6);\n\n  // Object specific methods\n  vtkImageData(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkImageData');\n\n// ----------------------------------------------------------------------------\n\nvar vtkImageData$1 = {\n  newInstance,\n  extend\n};\n\nexport { vtkImageData$1 as default, extend, newInstance };\n","import { m as macro } from '../../macros2.js';\nimport vtkPolyData from '../../Common/DataModel/PolyData.js';\nimport vtkEdgeLocator from '../../Common/DataModel/EdgeLocator.js';\nimport vtkCaseTable from './ImageMarchingSquares/caseTable.js';\n\nconst {\n  vtkErrorMacro,\n  vtkDebugMacro\n} = macro;\n\n// ----------------------------------------------------------------------------\n// vtkImageMarchingSquares methods\n// ----------------------------------------------------------------------------\n\nfunction vtkImageMarchingSquares(publicAPI, model) {\n  /**\n   * Get the X,Y kernels based on the set slicing mode.\n   * @returns {[number, number]}\n   */\n  function getKernels() {\n    let kernelX = 0; // default K slicing mode\n    let kernelY = 1;\n    if (model.slicingMode === 1) {\n      kernelX = 0;\n      kernelY = 2;\n    } else if (model.slicingMode === 0) {\n      kernelX = 1;\n      kernelY = 2;\n    }\n    return [kernelX, kernelY];\n  }\n\n  // Set our className\n  model.classHierarchy.push('vtkImageMarchingSquares');\n\n  /**\n   * Get the list of contour values.\n   * @returns {number[]}\n   */\n  publicAPI.getContourValues = () => model.contourValues;\n\n  /**\n   * Set the list contour values.\n   * @param {number[]} cValues\n   */\n  publicAPI.setContourValues = cValues => {\n    model.contourValues = cValues;\n    publicAPI.modified();\n  };\n  const ids = [];\n  const pixelScalars = [];\n  const pixelPts = [];\n  const edgeLocator = vtkEdgeLocator.newInstance();\n\n  /**\n   * Retrieve scalars and pixel coordinates.\n   * @param {Vector3} ijk origin of the pixel\n   * @param {Vector3} dims dimensions of the image\n   * @param {TypedArray} scalars list of scalar values\n   * @param {Vector3} increments IJK slice increments\n   * @param {number} kernelX index of the X element\n   * @param {number} kernelY index of the Y element\n   */\n  publicAPI.getPixelScalars = (ijk, dims, scalars, increments, kernelX, kernelY) => {\n    const [i, j, k] = ijk;\n\n    // First get the indices for the pixel\n    ids[0] = k * dims[1] * dims[0] + j * dims[0] + i; // i, j, k\n    ids[1] = ids[0] + increments[kernelX]; // i+1, j, k\n    ids[2] = ids[0] + increments[kernelY]; // i, j+1, k\n    ids[3] = ids[2] + increments[kernelX]; // i+1, j+1, k\n\n    // Now retrieve the scalars\n    for (let ii = 0; ii < 4; ++ii) {\n      pixelScalars[ii] = scalars[ids[ii]];\n    }\n  };\n\n  /**\n   * Retrieve pixel coordinates.\n   * @param {Vector3} ijk origin of the pixel\n   * @param {Vector3} origin origin of the image\n   * @param {Vector3} spacing spacing of the image\n   * @param {number} kernelX index of the X element\n   * @param {number} kernelY index of the Y element\n   */\n  publicAPI.getPixelPoints = (ijk, origin, spacing, kernelX, kernelY) => {\n    const i = ijk[kernelX];\n    const j = ijk[kernelY];\n\n    // (i,i+1),(j,j+1),(k,k+1) - i varies fastest; then j; then k\n    pixelPts[0] = origin[kernelX] + i * spacing[kernelX]; // 0\n    pixelPts[1] = origin[kernelY] + j * spacing[kernelY];\n    pixelPts[2] = pixelPts[0] + spacing[kernelX]; // 1\n    pixelPts[3] = pixelPts[1];\n    pixelPts[4] = pixelPts[0]; // 2\n    pixelPts[5] = pixelPts[1] + spacing[kernelY];\n    pixelPts[6] = pixelPts[2]; // 3\n    pixelPts[7] = pixelPts[5];\n  };\n\n  /**\n   * Produce points and lines for the polydata.\n   * @param {number[]} cVal list of contour values\n   * @param {Vector3} ijk origin of the pixel\n   * @param {Vector3} dims dimensions of the image\n   * @param {Vector3} origin origin of the image\n   * @param {Vector3} spacing sapcing of the image\n   * @param {TypedArray} scalars list of scalar values\n   * @param {number[]} points list of points\n   * @param {number[]} lines list of lines\n   * @param {Vector3} increments IJK slice increments\n   * @param {number} kernelX index of the X element\n   * @param {number} kernelY index of the Y element\n   */\n  publicAPI.produceLines = (cVal, ijk, dims, origin, spacing, scalars, points, lines, increments, kernelX, kernelY) => {\n    const k = ijk[model.slicingMode];\n    const CASE_MASK = [1, 2, 8, 4]; // case table is actually for quad\n    const xyz = [];\n    let pId;\n    publicAPI.getPixelScalars(ijk, dims, scalars, increments, kernelX, kernelY);\n    let index = 0;\n    for (let idx = 0; idx < 4; idx++) {\n      if (pixelScalars[idx] >= cVal) {\n        index |= CASE_MASK[idx]; // eslint-disable-line no-bitwise\n      }\n    }\n\n    const pixelLines = vtkCaseTable.getCase(index);\n    if (pixelLines[0] < 0) {\n      return; // don't get the pixel coordinates, nothing to do\n    }\n\n    publicAPI.getPixelPoints(ijk, origin, spacing, kernelX, kernelY);\n    const z = origin[model.slicingMode] + k * spacing[model.slicingMode];\n    for (let idx = 0; pixelLines[idx] >= 0; idx += 2) {\n      lines.push(2);\n      for (let eid = 0; eid < 2; eid++) {\n        const edgeVerts = vtkCaseTable.getEdge(pixelLines[idx + eid]);\n        pId = undefined;\n        if (model.mergePoints) {\n          pId = edgeLocator.isInsertedEdge(ids[edgeVerts[0]], ids[edgeVerts[1]])?.value;\n        }\n        if (pId === undefined) {\n          const t = (cVal - pixelScalars[edgeVerts[0]]) / (pixelScalars[edgeVerts[1]] - pixelScalars[edgeVerts[0]]);\n          const x0 = pixelPts.slice(edgeVerts[0] * 2, (edgeVerts[0] + 1) * 2);\n          const x1 = pixelPts.slice(edgeVerts[1] * 2, (edgeVerts[1] + 1) * 2);\n          xyz[kernelX] = x0[0] + t * (x1[0] - x0[0]);\n          xyz[kernelY] = x0[1] + t * (x1[1] - x0[1]);\n          xyz[model.slicingMode] = z;\n          pId = points.length / 3;\n          points.push(xyz[0], xyz[1], xyz[2]);\n          if (model.mergePoints) {\n            edgeLocator.insertEdge(ids[edgeVerts[0]], ids[edgeVerts[1]], pId);\n          }\n        }\n        lines.push(pId);\n      }\n    }\n  };\n  publicAPI.requestData = (inData, outData) => {\n    // implement requestData\n    const input = inData[0];\n    if (!input) {\n      vtkErrorMacro('Invalid or missing input');\n      return;\n    }\n    if (model.slicingMode == null || model.slicingMode < 0 || model.slicingMode > 2) {\n      vtkErrorMacro('Invalid or missing slicing mode');\n      return;\n    }\n    console.time('msquares');\n\n    // Retrieve output and volume data\n    const origin = input.getOrigin();\n    const spacing = input.getSpacing();\n    const dims = input.getDimensions();\n    const extent = input.getExtent();\n    const increments = input.computeIncrements(extent);\n    const scalars = input.getPointData().getScalars().getData();\n    const [kernelX, kernelY] = getKernels();\n\n    // Points - dynamic array\n    const points = [];\n\n    // Cells - dynamic array\n    const lines = [];\n\n    // Ensure slice is valid\n    let k = Math.round(model.slice);\n    if (k >= dims[model.slicingMode]) {\n      k = 0;\n    }\n\n    // Loop over all contour values, and then pixels, determine case and process\n    const ijk = [0, 0, 0];\n    ijk[model.slicingMode] = k;\n    for (let cv = 0; cv < model.contourValues.length; ++cv) {\n      for (let j = 0; j < dims[kernelY] - 1; ++j) {\n        ijk[kernelY] = j;\n        for (let i = 0; i < dims[kernelX] - 1; ++i) {\n          ijk[kernelX] = i;\n          publicAPI.produceLines(model.contourValues[cv], ijk, dims, origin, spacing, scalars, points, lines, increments, kernelX, kernelY);\n        }\n      }\n      edgeLocator.initialize();\n    }\n\n    // Update output\n    const polydata = vtkPolyData.newInstance();\n    polydata.getPoints().setData(new Float32Array(points), 3);\n    polydata.getLines().setData(new Uint32Array(lines));\n    outData[0] = polydata;\n    vtkDebugMacro('Produced output');\n    console.timeEnd('msquares');\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  contourValues: [],\n  slicingMode: 2,\n  slice: 0,\n  mergePoints: false\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Make this a VTK object\n  macro.obj(publicAPI, model);\n\n  // Also make it an algorithm with one input and one output\n  macro.algo(publicAPI, model, 1, 1);\n  macro.setGet(publicAPI, model, ['slicingMode', 'slice', 'mergePoints']);\n\n  // Object specific methods\n  macro.algo(publicAPI, model, 1, 1);\n  vtkImageMarchingSquares(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkImageMarchingSquares');\n\n// ----------------------------------------------------------------------------\n\nvar vtkImageMarchingSquares$1 = {\n  newInstance,\n  extend\n};\n\nexport { vtkImageMarchingSquares$1 as default, extend, newInstance };\n","/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nconst proxyMarker = Symbol(\"Comlink.proxy\");\nconst createEndpoint = Symbol(\"Comlink.endpoint\");\nconst releaseProxy = Symbol(\"Comlink.releaseProxy\");\nconst finalizer = Symbol(\"Comlink.finalizer\");\nconst throwMarker = Symbol(\"Comlink.thrown\");\nconst isObject = (val) => (typeof val === \"object\" && val !== null) || typeof val === \"function\";\n/**\n * Internal transfer handle to handle objects marked to proxy.\n */\nconst proxyTransferHandler = {\n    canHandle: (val) => isObject(val) && val[proxyMarker],\n    serialize(obj) {\n        const { port1, port2 } = new MessageChannel();\n        expose(obj, port1);\n        return [port2, [port2]];\n    },\n    deserialize(port) {\n        port.start();\n        return wrap(port);\n    },\n};\n/**\n * Internal transfer handler to handle thrown exceptions.\n */\nconst throwTransferHandler = {\n    canHandle: (value) => isObject(value) && throwMarker in value,\n    serialize({ value }) {\n        let serialized;\n        if (value instanceof Error) {\n            serialized = {\n                isError: true,\n                value: {\n                    message: value.message,\n                    name: value.name,\n                    stack: value.stack,\n                },\n            };\n        }\n        else {\n            serialized = { isError: false, value };\n        }\n        return [serialized, []];\n    },\n    deserialize(serialized) {\n        if (serialized.isError) {\n            throw Object.assign(new Error(serialized.value.message), serialized.value);\n        }\n        throw serialized.value;\n    },\n};\n/**\n * Allows customizing the serialization of certain values.\n */\nconst transferHandlers = new Map([\n    [\"proxy\", proxyTransferHandler],\n    [\"throw\", throwTransferHandler],\n]);\nfunction isAllowedOrigin(allowedOrigins, origin) {\n    for (const allowedOrigin of allowedOrigins) {\n        if (origin === allowedOrigin || allowedOrigin === \"*\") {\n            return true;\n        }\n        if (allowedOrigin instanceof RegExp && allowedOrigin.test(origin)) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction expose(obj, ep = globalThis, allowedOrigins = [\"*\"]) {\n    ep.addEventListener(\"message\", function callback(ev) {\n        if (!ev || !ev.data) {\n            return;\n        }\n        if (!isAllowedOrigin(allowedOrigins, ev.origin)) {\n            console.warn(`Invalid origin '${ev.origin}' for comlink proxy`);\n            return;\n        }\n        const { id, type, path } = Object.assign({ path: [] }, ev.data);\n        const argumentList = (ev.data.argumentList || []).map(fromWireValue);\n        let returnValue;\n        try {\n            const parent = path.slice(0, -1).reduce((obj, prop) => obj[prop], obj);\n            const rawValue = path.reduce((obj, prop) => obj[prop], obj);\n            switch (type) {\n                case \"GET\" /* MessageType.GET */:\n                    {\n                        returnValue = rawValue;\n                    }\n                    break;\n                case \"SET\" /* MessageType.SET */:\n                    {\n                        parent[path.slice(-1)[0]] = fromWireValue(ev.data.value);\n                        returnValue = true;\n                    }\n                    break;\n                case \"APPLY\" /* MessageType.APPLY */:\n                    {\n                        returnValue = rawValue.apply(parent, argumentList);\n                    }\n                    break;\n                case \"CONSTRUCT\" /* MessageType.CONSTRUCT */:\n                    {\n                        const value = new rawValue(...argumentList);\n                        returnValue = proxy(value);\n                    }\n                    break;\n                case \"ENDPOINT\" /* MessageType.ENDPOINT */:\n                    {\n                        const { port1, port2 } = new MessageChannel();\n                        expose(obj, port2);\n                        returnValue = transfer(port1, [port1]);\n                    }\n                    break;\n                case \"RELEASE\" /* MessageType.RELEASE */:\n                    {\n                        returnValue = undefined;\n                    }\n                    break;\n                default:\n                    return;\n            }\n        }\n        catch (value) {\n            returnValue = { value, [throwMarker]: 0 };\n        }\n        Promise.resolve(returnValue)\n            .catch((value) => {\n            return { value, [throwMarker]: 0 };\n        })\n            .then((returnValue) => {\n            const [wireValue, transferables] = toWireValue(returnValue);\n            ep.postMessage(Object.assign(Object.assign({}, wireValue), { id }), transferables);\n            if (type === \"RELEASE\" /* MessageType.RELEASE */) {\n                // detach and deactive after sending release response above.\n                ep.removeEventListener(\"message\", callback);\n                closeEndPoint(ep);\n                if (finalizer in obj && typeof obj[finalizer] === \"function\") {\n                    obj[finalizer]();\n                }\n            }\n        })\n            .catch((error) => {\n            // Send Serialization Error To Caller\n            const [wireValue, transferables] = toWireValue({\n                value: new TypeError(\"Unserializable return value\"),\n                [throwMarker]: 0,\n            });\n            ep.postMessage(Object.assign(Object.assign({}, wireValue), { id }), transferables);\n        });\n    });\n    if (ep.start) {\n        ep.start();\n    }\n}\nfunction isMessagePort(endpoint) {\n    return endpoint.constructor.name === \"MessagePort\";\n}\nfunction closeEndPoint(endpoint) {\n    if (isMessagePort(endpoint))\n        endpoint.close();\n}\nfunction wrap(ep, target) {\n    return createProxy(ep, [], target);\n}\nfunction throwIfProxyReleased(isReleased) {\n    if (isReleased) {\n        throw new Error(\"Proxy has been released and is not useable\");\n    }\n}\nfunction releaseEndpoint(ep) {\n    return requestResponseMessage(ep, {\n        type: \"RELEASE\" /* MessageType.RELEASE */,\n    }).then(() => {\n        closeEndPoint(ep);\n    });\n}\nconst proxyCounter = new WeakMap();\nconst proxyFinalizers = \"FinalizationRegistry\" in globalThis &&\n    new FinalizationRegistry((ep) => {\n        const newCount = (proxyCounter.get(ep) || 0) - 1;\n        proxyCounter.set(ep, newCount);\n        if (newCount === 0) {\n            releaseEndpoint(ep);\n        }\n    });\nfunction registerProxy(proxy, ep) {\n    const newCount = (proxyCounter.get(ep) || 0) + 1;\n    proxyCounter.set(ep, newCount);\n    if (proxyFinalizers) {\n        proxyFinalizers.register(proxy, ep, proxy);\n    }\n}\nfunction unregisterProxy(proxy) {\n    if (proxyFinalizers) {\n        proxyFinalizers.unregister(proxy);\n    }\n}\nfunction createProxy(ep, path = [], target = function () { }) {\n    let isProxyReleased = false;\n    const proxy = new Proxy(target, {\n        get(_target, prop) {\n            throwIfProxyReleased(isProxyReleased);\n            if (prop === releaseProxy) {\n                return () => {\n                    unregisterProxy(proxy);\n                    releaseEndpoint(ep);\n                    isProxyReleased = true;\n                };\n            }\n            if (prop === \"then\") {\n                if (path.length === 0) {\n                    return { then: () => proxy };\n                }\n                const r = requestResponseMessage(ep, {\n                    type: \"GET\" /* MessageType.GET */,\n                    path: path.map((p) => p.toString()),\n                }).then(fromWireValue);\n                return r.then.bind(r);\n            }\n            return createProxy(ep, [...path, prop]);\n        },\n        set(_target, prop, rawValue) {\n            throwIfProxyReleased(isProxyReleased);\n            // FIXME: ES6 Proxy Handler `set` methods are supposed to return a\n            // boolean. To show good will, we return true asynchronously ¯\\_(ツ)_/¯\n            const [value, transferables] = toWireValue(rawValue);\n            return requestResponseMessage(ep, {\n                type: \"SET\" /* MessageType.SET */,\n                path: [...path, prop].map((p) => p.toString()),\n                value,\n            }, transferables).then(fromWireValue);\n        },\n        apply(_target, _thisArg, rawArgumentList) {\n            throwIfProxyReleased(isProxyReleased);\n            const last = path[path.length - 1];\n            if (last === createEndpoint) {\n                return requestResponseMessage(ep, {\n                    type: \"ENDPOINT\" /* MessageType.ENDPOINT */,\n                }).then(fromWireValue);\n            }\n            // We just pretend that `bind()` didn’t happen.\n            if (last === \"bind\") {\n                return createProxy(ep, path.slice(0, -1));\n            }\n            const [argumentList, transferables] = processArguments(rawArgumentList);\n            return requestResponseMessage(ep, {\n                type: \"APPLY\" /* MessageType.APPLY */,\n                path: path.map((p) => p.toString()),\n                argumentList,\n            }, transferables).then(fromWireValue);\n        },\n        construct(_target, rawArgumentList) {\n            throwIfProxyReleased(isProxyReleased);\n            const [argumentList, transferables] = processArguments(rawArgumentList);\n            return requestResponseMessage(ep, {\n                type: \"CONSTRUCT\" /* MessageType.CONSTRUCT */,\n                path: path.map((p) => p.toString()),\n                argumentList,\n            }, transferables).then(fromWireValue);\n        },\n    });\n    registerProxy(proxy, ep);\n    return proxy;\n}\nfunction myFlat(arr) {\n    return Array.prototype.concat.apply([], arr);\n}\nfunction processArguments(argumentList) {\n    const processed = argumentList.map(toWireValue);\n    return [processed.map((v) => v[0]), myFlat(processed.map((v) => v[1]))];\n}\nconst transferCache = new WeakMap();\nfunction transfer(obj, transfers) {\n    transferCache.set(obj, transfers);\n    return obj;\n}\nfunction proxy(obj) {\n    return Object.assign(obj, { [proxyMarker]: true });\n}\nfunction windowEndpoint(w, context = globalThis, targetOrigin = \"*\") {\n    return {\n        postMessage: (msg, transferables) => w.postMessage(msg, targetOrigin, transferables),\n        addEventListener: context.addEventListener.bind(context),\n        removeEventListener: context.removeEventListener.bind(context),\n    };\n}\nfunction toWireValue(value) {\n    for (const [name, handler] of transferHandlers) {\n        if (handler.canHandle(value)) {\n            const [serializedValue, transferables] = handler.serialize(value);\n            return [\n                {\n                    type: \"HANDLER\" /* WireValueType.HANDLER */,\n                    name,\n                    value: serializedValue,\n                },\n                transferables,\n            ];\n        }\n    }\n    return [\n        {\n            type: \"RAW\" /* WireValueType.RAW */,\n            value,\n        },\n        transferCache.get(value) || [],\n    ];\n}\nfunction fromWireValue(value) {\n    switch (value.type) {\n        case \"HANDLER\" /* WireValueType.HANDLER */:\n            return transferHandlers.get(value.name).deserialize(value.value);\n        case \"RAW\" /* WireValueType.RAW */:\n            return value.value;\n    }\n}\nfunction requestResponseMessage(ep, msg, transfers) {\n    return new Promise((resolve) => {\n        const id = generateUUID();\n        ep.addEventListener(\"message\", function l(ev) {\n            if (!ev.data || !ev.data.id || ev.data.id !== id) {\n                return;\n            }\n            ep.removeEventListener(\"message\", l);\n            resolve(ev.data);\n        });\n        if (ep.start) {\n            ep.start();\n        }\n        ep.postMessage(Object.assign({ id }, msg), transfers);\n    });\n}\nfunction generateUUID() {\n    return new Array(4)\n        .fill(0)\n        .map(() => Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(16))\n        .join(\"-\");\n}\n\nexport { createEndpoint, expose, finalizer, proxy, proxyMarker, releaseProxy, transfer, transferHandlers, windowEndpoint, wrap };\n//# sourceMappingURL=comlink.mjs.map\n","import ascending from \"./ascending.js\";\nimport descending from \"./descending.js\";\n\nexport default function bisector(f) {\n  let compare1, compare2, delta;\n\n  // If an accessor is specified, promote it to a comparator. In this case we\n  // can test whether the search value is (self-) comparable. We can’t do this\n  // for a comparator (except for specific, known comparators) because we can’t\n  // tell if the comparator is symmetric, and an asymmetric comparator can’t be\n  // used to test whether a single value is comparable.\n  if (f.length !== 2) {\n    compare1 = ascending;\n    compare2 = (d, x) => ascending(f(d), x);\n    delta = (d, x) => f(d) - x;\n  } else {\n    compare1 = f === ascending || f === descending ? f : zero;\n    compare2 = f;\n    delta = f;\n  }\n\n  function left(a, x, lo = 0, hi = a.length) {\n    if (lo < hi) {\n      if (compare1(x, x) !== 0) return hi;\n      do {\n        const mid = (lo + hi) >>> 1;\n        if (compare2(a[mid], x) < 0) lo = mid + 1;\n        else hi = mid;\n      } while (lo < hi);\n    }\n    return lo;\n  }\n\n  function right(a, x, lo = 0, hi = a.length) {\n    if (lo < hi) {\n      if (compare1(x, x) !== 0) return hi;\n      do {\n        const mid = (lo + hi) >>> 1;\n        if (compare2(a[mid], x) <= 0) lo = mid + 1;\n        else hi = mid;\n      } while (lo < hi);\n    }\n    return lo;\n  }\n\n  function center(a, x, lo = 0, hi = a.length) {\n    const i = left(a, x, lo, hi - 1);\n    return i > lo && delta(a[i - 1], x) > -delta(a[i], x) ? i - 1 : i;\n  }\n\n  return {left, center, right};\n}\n\nfunction zero() {\n  return 0;\n}\n"],"names":["async","renderingEngine","stackInputs","viewportIds","immediateRender","suppressEvents","viewportId","viewport","getViewport","Error","addImages","console","warn","addStackPromises","map","Promise","all","volumeInputs","addVolumePromises","addVolumes","DEFAULT_SETTINGS","Symbol","RUNTIME_SETTINGS","OBJECT_SETTINGS_MAP","DICTIONARY","Settings","constructor","base","dictionary","Object","create","seal","defineProperty","this","value","set","key","get","unset","name","endsWith","deleteCount","namespace","slice","deleteAll","length","prototype","hasOwnProperty","call","startsWith","forEach","callback","iterate","extend","import","root","isPlainObject","keys","dump","context","deepSet","assert","subject","getRuntimeSettings","getDefaultSettings","subfield","defaultSettings","settingObj","setting","split","runtimeSettings","getObjectSettings","from","settings","objectSettingsMap","WeakMap","extendRuntimeSettings","references","last","current","previous","indexOf","isValidKey","prefix","record","failCount","has","add","field","delete","setAll","WeakSet","getPrototypeOf","separator","subKey","subContext","subContextValue","RENDERING_DEFAULTS","MINIMUM_SLAB_THICKNESS","MAXIMUM_RAY_DISTANCE","freeze","RequestType","ViewportStatus","BlendMode","BlendModes","GeometryType","ContourType","DynamicOperatorType","CalibrationTypes","getEnabledElement","element","viewportUid","renderingEngineUid","dataset","getEnabledElementByIds","renderingEngineId","hasBeenDestroyed","FrameOfReferenceUID","getFrameOfReferenceUID","getEnabledElementByViewportId","renderingEngines","i","id","getEnabledElements","enabledElements","getViewports","push","imageLoaders","unknownImageLoader","loadImageFromImageLoader","imageId","options","colonIndex","scheme","substring","loader","undefined","imageLoadObject","promise","then","image","triggerEvent","IMAGE_LOADED","error","errorObject","IMAGE_LOAD_FAILED","loadImageFromCacheOrVolume","ignoreCache","getImageLoadObject","cachedVolumeInfo","getVolumeContainingImageId","volume","loadStatus","loaded","imageIdIndex","convertToCornerstoneImage","cachedImage","getCachedImageBasedOnImageURI","loadImage","priority","requestType","loadAndCacheImage","putImageLoadObject","catch","err","loadAndCacheImages","imageIds","createAndCacheDerivedImage","referencedImageId","preventCache","uuidv4","skipCreateBuffer","onCacheAdd","imagePlaneModule","metaData","rows","columns","TypedArrayConstructor","getBufferConfiguration","targetBufferType","imageScalarData","derivedImageId","type","genericMetadataProvider","metadata","localImage","createAndCacheLocalImage","scalarData","resolve","createAndCacheDerivedImages","referencedImageIds","derivedImageIds","allPromises","newOptions","getDerivedImageId","promises","intercept","windowCenter","windowWidth","color","numComps","slope","minPixelValue","maxPixelValue","voiLUTFunction","getCanvas","height","width","rgba","columnPixelSpacing","rowPixelSpacing","invert","Uint8Array","Float32Array","Uint16Array","Int16Array","sizeInBytes","byteLength","getPixelData","numBytes","cancelLoadImage","filterRequests","additionalDetails","cancelFn","cancelLoadImages","cancelLoadAll","requestPool","getRequestPool","requests","pop","volumeId","loadObject","getVolumeLoadObject","cancel","clearRequestStack","registerImageLoader","imageLoader","registerUnknownImageLoader","oldImageLoader","unregisterAllImageLoaders","createAndCacheDerivedSegmentationImages","createAndCacheDerivedSegmentationImage","createInternalVTKRepresentation","dimensions","spacing","direction","origin","PhotometricInterpretation","numComponents","imageData","dataArrayAttrs","numberOfComponents","setDimensions","setSpacing","setDirection","setOrigin","isDynamicVolume","scalarDataArrays","vtkScalarArray","values","getPointData","addArray","setActiveScalars","addScalarDataArraysToImageData","getScalarDataArrays","scalarArray","setScalars","addScalarDataToImageData","getScalarData","volumeLoaders","unknownVolumeLoader","loadVolumeFromVolumeLoader","volumeLoadObject","setupCacheOptimizationEventListener","VOLUME_LOADED","VOLUME_LOADED_FAILED","loadVolume","createAndCacheVolume","putVolumeLoadObject","createAndCacheDerivedVolume","referencedVolumeId","referencedVolume","getVolume","targetBuffer","scalarLength","volumeScalarData","generateVolumeScalarData","derivedImageData","derivedVolume","createLocalVolume","validDataTypes","includes","cachedVolume","buffer","isCacheable","CACHE_SIZE_EXCEEDED","createAndCacheVolumeFromImages","volumeProps","generateVolumePropsFromImageIds","imagePromises","pixelData","offset","performCacheOptimizationForVolume","registerVolumeLoader","volumeLoader","getVolumeLoaderSchemes","registerUnknownVolumeLoader","oldVolumeLoader","getUnknownVolumeLoaderSchema","createAndCacheDerivedSegmentationVolume","createLocalSegmentationVolume","useNorm16Texture","rendering","use16BitTexture","isVolumeBuffer","sharedArrayBuffer","SharedArrayBuffer","providers","addProvider","provider","splice","removeProvider","removeAllProviders","getMetaData","queries","result","imageLoadPoolManager","R","grabDelay","setMaxSimultaneousRequests","Interaction","Thumbnail","Prefetch","RequestPoolManager","numRequests","interaction","thumbnail","prefetch","compute","awake","maxNumRequests","getMaxSimultaneousRequests","destroy","timeoutHandle","window","clearTimeout","addRequest","requestFn","requestDetails","startGrabbing","filterFunction","filter","sendRequests","requestsToSend","syncImageCount","getNextRequest","requestResult","e","finally","startAgain","interactionPriorities","getSortedPriorityGroups","shift","hasRemainingInteractionRequests","hasRemainingThumbnailRequests","hasRemainingPrefetchRequests","hasRemainingComputeRequests","Compute","setTimeout","Number","sort","a","b","el","detail","event","CustomEvent","cancelable","dispatchEvent","workerRegistry","workerPoolManager","registerWorker","workerName","workerFn","maxWorkerInstances","overwrite","autoTerminateOnIdle","enabled","idleTimeThreshold","idleCheckIntervalId","clearInterval","workerProperties","instances","loadCounters","lastActiveTime","nativeWorkers","Array","fill","worker","getNextWorkerAPI","workerInstances","instance","minLoadIndex","minLoadValue","currentLoadValue","api","index","executeTask","methodName","args","callbacks","reject","finalCallbacks","cb","processing","results","Date","now","setInterval","terminateIdleWorkers","_","terminateWorkerInstance","terminate","workerInstance","transformWorldToIndex","BidirectionalTool","toolProps","defaultToolProps","supportedInteractionTypes","configuration","preventHandleOutsideImage","getTextLines","defaultGetTextLines","super","isPointNearTool","annotation","canvasCoords","proximity","enabledElement","data","points","handles","canvasPoint1","worldToCanvas","canvasPoint2","line","start","x","y","end","distanceToPoint","toolSelectedCallback","evt","eventDetail","highlighted","viewportIdsToRender","getViewportIdsWithToolToRender","getToolName","editData","movingTextBox","_activateModify","hideElementCursor","preventDefault","handleSelectedCallback","handle","handleIndex","worldPosition","findIndex","p","_endCallback","newAnnotation","hasMoved","activeHandleIndex","_deactivateModify","_deactivateDraw","resetElementCursor","firstLineSegmentLength","longAxis","shortAxisPoint0","shortAxisPoint1","longAxisVector","counterClockWisePerpendicularToLongAxis","currentShortAxisVector","shortAxis","isHandleOutsideImage","removeAnnotation","annotationUID","isDrawing","_dragDrawCallback","currentPoints","worldPos","world","canvasCoordPoints","shortAxisDistFromCenter","dx","dy","Math","sqrt","vectorX","vectorY","xMid","yMid","startX","startY","endX","endY","canvasToWorld","invalidated","_dragModifyCallback","deltaPoints","worldPosDelta","textBox","point","_dragModifyHandle","movingHandleIndex","canvasCoordHandlesCurrent","firstLineSegment","secondLineSegment","proposedPoint","proposedCanvasCoord","fixedHandleCanvasCoord","fixedHandleToProposedCoordVec","fixedHandleToOldCoordVec","proposedFirstLineSegment","_movingLongAxisWouldPutItThroughShortAxis","centerOfRotation","angle","_getSignedAngle","firstPointX","firstPointY","secondPointX","secondPointY","rotatedFirstPoint","cos","sin","rotatedFirstPointY","rotatedSecondPoint","rotatedSecondPointY","newFirstPoint","newSecondPoint","translateHandleIndex","canvasCoordsCurrent","longLineSegment","shortLineSegment","longLineSegmentVec","longLineSegmentVecNormalized","proposedToCurrentVec","movementLength","movementAlongLineSegmentLength","newTranslatedPoint","_activateDraw","isInteractingWithTool","addEventListener","Events","MOUSE_UP","MOUSE_DRAG","MOUSE_MOVE","MOUSE_CLICK","TOUCH_TAP","TOUCH_END","TOUCH_DRAG","removeEventListener","renderAnnotation","svgDrawingHelper","renderStatus","annotations","getAnnotations","filterInteractableAnnotationsForElement","targetId","getTargetId","getRenderingEngine","styleSpecifier","toolGroupId","toolName","canvasCoordinates","lineWidth","lineDash","shadow","getAnnotationStyle","cachedStats","unit","_throttledCalculateCachedStats","_calculateCachedStats","activeHandleCanvasCoords","isAnnotationVisible","isAnnotationLocked","handleGroupUID","drawHandles","dataId1","dataId2","lineUID","drawLine","secondLineUID","getLinkedTextBoxStyle","visibility","worldBoundingBox","topLeft","topRight","bottomLeft","bottomRight","textLines","canvasTextBoxCoords","getTextBoxCoordsCanvas","textBoxPosition","textBoxUID","boundingBox","drawLinkedTextBox","left","top","vectorInSecondLineDirection","extendedSecondLineSegment","worldPos1","worldPos2","worldPos3","worldPos4","targetIds","getTargetIdImage","index1","index2","index3","index4","handles1","handles2","scale","scale1","units","units1","scale2","units2","dist1","_calculateLength","dist2","lengthUnit","widthUnit","_isInsideVolume","vector1","vector2","atan2","trailing","addNewAnnotation","camera","getCamera","viewPlaneNormal","viewUp","getReferencedImageId","label","addAnnotation","pos1","pos2","dz","roundNumber","AnnotationTool","A","mouseMoveCallback","filteredAnnotations","canvas","annotationsNeedToBeRedrawn","activateHandleIndex","near","_imagePointNearToolOrHandle","nearToolAndNotMarkedActive","notNearToolAndMarkedActive","statsCalculator","createAnnotation","annotationBaseData","text","baseData","createAnnotationForViewport","getViewReference","createAndAddAnnotation","getHandleNearImagePoint","isCanvasAnnotation","canvasBoundingBox","annotationCanvasCoordinate","specifications","getStyle","fontFamily","fontSize","background","isSuvScaled","BaseVolumeViewport","cache","scaling","PT","scalingModule","suvbw","property","locked","lineOpacity","fillColor","fillOpacity","textbox","defaultLabelmapConfig","renderOutline","outlineWidthActive","outlineWidthInactive","activeSegmentOutlineWidthDelta","renderFill","renderFillInactive","fillAlpha","fillAlphaInactive","outlineOpacity","outlineOpacityInactive","RectangleROIThresholdTool","RectangleROITool","StackViewport","imageVolume","segmentationId","triggerAnnotationRenderForViewportIds","rectangleUID","drawRect","RectangleROIStartEndThresholdTool","numSlicesToPropagate","computePointsInsideVolume","startIndex","getCurrentImageIdIndex","spacingInNormal","endIndex","_getEndSliceIndex","startSlice","endSlice","pointsInVolume","projectionPoints","projectionPointsImageIds","labelmapUID","_computeProjectionPoints","calculatePointsInsideVolume","_computePointsInsideVolume","sliceIndex","min","max","firstOrLastSlice","lineDashToUse","throttle","_calculateCachedStatsTool","startIJK","endIJK","startWorld","indexToWorldVec3","endWorld","distance","newProjectionPoints","dist","newPoint","RectanglePoints","pointsInsideVolume","projectionPoint","worldPos1Index","worldProjectionPointIndex","floor","worldPos2Index","boundsIJK","pointsInShape","pointInShapeCallback","endPos","halfSpacingInNormalDirection","imagePositionPatient","dir","dot","abs","AnnotationFrameRange","frameRangeExtractor","imageIdToFrames","match","range","it","framesToString","isArray","String","framesToImageId","newRangeString","replace","setFrameRange","eventBase","eventTarget","ANNOTATION_MODIFIED","getFrameRange","EPSILON","CONSTANTS","calculateBoundingBox","isWorld","xMin","Infinity","xMax","yMin","yMax","zMin","zMax","is3D","getBoundingBoxAroundShapeIJK","getBoundingBoxAroundShapeWorld","clipBounds","calibratedPixelSpacingMetadataProvider","utilities","Enums","Map","addContourSegmentationAnnotation","parentAnnotationUID","segmentation","segmentIndex","getSegmentation","representationData","CONTOUR","annotationUIDsMap","annotationsUIDsSet","Set","removeContourSegmentationAnnotation","state","size","AnnotationToPointData","TOOL_NAMES","convert","metadataProvider","referenceImageId","validateAnnotation","toolClass","ContourSequence","getContourSequence","ReferencedROINumber","ROIDisplayColor","random","register","polyline","closed","perimeter","point1","point2","pow","firstPoint","lastPoint","isEqual","findHandlePolylineIndex","contour","closestDistance","reduce","closestIndex","testIndex","Labelmap","getContourHolesDataCanvas","worldHoleContours","canvasHoleContours","worldHoleContour","numPoints","canvasHoleContour","getContourHolesDataWorld","childAnnotationUIDs","uid","updateContourPolyline","polylineData","transforms","targetWindingDirection","decimate","epsilon","polylineWorldPoints","currentWindingDirection","parentAnnotation","currentClosedState","lastToFirstDist","windingDirection","reverse","func","wait","lastArgs","lastThis","maxWait","timerId","lastCallTime","lastInvokeTime","leading","maxing","useRAF","requestAnimationFrame","TypeError","invokeFunc","time","thisArg","apply","startTimer","pendingFunc","shouldInvoke","timeSinceLastCall","timerExpired","trailingEdge","timeSinceLastInvoke","timeWaiting","remainingWait","debounced","isInvoking","leadingEdge","Boolean","cancelAnimationFrame","cancelTimer","flush","pending","annotationCanvasPoints","corners","canvasPoints","handlesLeftToRight","_compareX","handlesTopToBottom","_compareY","right","bottom","_determineCorners","centerY","PIXEL_UNITS","SUPPORTED_REGION_DATA_TYPES","SUPPORTED_LENGTH_VARIANT","SUPPORTED_PROBE_VARIANT","UNIT_MAPPING","SQUARE","getCalibratedLengthUnitsAndScale","calibration","hasPixelSpacing","areaUnits","calibrationType","sequenceOfUltrasoundRegions","UNCALIBRATED","imageIndex1","imageIndex2","regions","region","regionLocationMinX0","regionLocationMaxX1","regionLocationMinY0","regionLocationMaxY1","regionDataType","physicalUnitsXDirection","physicalUnitsYDirection","physicalDeltaX","physicalDeltaY","ERMF","USER","ERROR","PROJECTION","getCalibratedProbeUnitsAndValue","imageIndex","supportedRegionsMetadata","find","referencePixelX0","referencePixelY0","yValue","getCalibratedAspect","aspect","getSphereBoundsInfo","circlePoints","centerWorld","radiusWorld","topLeftWorld","bottomRightWorld","getDimensions","viewRight","topLeftIJK","bottomRightIJK","pointsIJK","_computeBoundsIJKWithCamera","getViewportForAnnotation","viewports","intersectAABB","aabb1","aabb2","minX","maxX","minY","maxY","distanceToPointSquared","aabb","aabbWidth","aabbHeight","aabbSize","aabbCenter","translatedPoint","BasicStatsCalculator","sum","sumSquares","squaredDiffSum","count","statsCallback","newValue","newArray","idx","getStatistics","mean","stdDev","stdDevWithSumSquare","named","singleArrayAsNumber","array","val","pointInEllipse","ellipse","pointLPS","inverts","precalculated","precalculatePointInEllipse","xRadius","yRadius","zRadius","invXRadiusSq","invYRadiusSq","invZRadiusSq","center","centerL","centerP","centerS","inside","getCanvasEllipseCorners","ellipseCanvasPoints","distanceToPointSquaredInfo","lineStart","lineEnd","closestPoint","distanceSquared","math","dotProduct","sign","NaN","intersectLine","line1Start","line1End","line2Start","line2End","x1","y1","x2","y2","x3","y3","x4","y4","a1","b1","c1","r3","r4","a2","b2","c2","r1","r2","denom","num","ORIENTATION_TOLERANCE","isPointOnLineSegment","orientation","p1","p2","z1","z2","mirror","mirrorPoint","staticPoint","isClosed","numPolylinePoints","distFirstToLastPoints","containsPoint","numIntersections","holes","hole","shouldClose","maxSegmentIndex","intersects","xIntersection","containsPoints","numPoint","getArea","n","area","j","getSignedArea","refPoint","len","aX","aY","bX","getWindingDirection","getNormal3","vecArea","aZ","bY","bZ","_getAreaVector","getNormal2","areLineSegmentsIntersecting","q1","q2","line1MinX","line1MinY","line1MaxX","line1MaxY","line2MinX","line2MinY","line2MaxX","line2MaxY","orient","onSegment","q","r","orientationValue","getLineSegmentIntersectionsIndexes","intersections","maxI","PARALLEL_LINES_TOLERANCE","getLinesIntersection","diffQ1P1","diffQ2P2","denominator","line1AABB","line2AABB","numerator2","PolylinePointType","PolylinePointPosition","PolylinePointDirection","ensuresNextPointers","polylinePoints","currentPoint","next","getSourceAndTargetPointsList","targetPolyline","sourcePolyline","targetPolylinePoints","sourcePolylinePoints","sourceIntersectionsCache","intersectionPointDirection","Exiting","Entering","pointInside","vertexPoint","Vertex","coordinates","position","Inside","Outside","visited","intersectionsInfo","intersectedLineSegment","sourceLineSegmentId","intersectionCoordinate","coordinate","targetStartPointDistSquared","intersectionInfo","targetEdgePoint","Intersection","Edge","sourceEdgePoint","Unknown","cloned","sourceIntersectionPoints","lineSegmentId","intersectionPoint","lineSegStartDistSquared","getUnvisitedOutsidePoint","mergePolylines","targetNormal","sourceNormal","dotNormals","startPoint","mergedPolyline","subtractPolylines","subtractedPolylines","subtractedPolyline","getFirstLineSegmentIntersectionIndexes","initialI","intersectPolyline","sourceLen","intersectionPointIndexes","DEFAULT_EPSILON","epsilonSquared","partitionQueue","polylinePointFlags","numDecimatedPoints","endPoint","maxDistSquared","maxDistIndex","distSquared","decimatedPolyline","srcIndex","dstIndex","getLineSegmentIntersectionsCoordinates","polylineIndexes","intersection","getClosestLineSegmentIntersection","initialQ2Index","p2Index","q2Index","distances","intersectionPoints","midpoint","minDistance","segment","subPixelResolution","xDir","yDir","getImageData","volumeSpacing","iVector","jVector","kVector","absViewRightDotI","absViewRightDotJ","absViewRightDotK","xSpacing","absViewUpDotI","absViewUpDotJ","absViewUpDotK","ySpacing","closeContourProximity","newCanvasPoint","commonData","log","lastWorldPos","newWorldPos","worldPosDiff","xDist","yDist","numPointsToAdd","lastCanvasPoint","canvasDist","canvasDir","distPerPoint","p1p","p1p2","p1p2Mag","projectionVectorMag","p1p2UnitVector","projectionVector","projectTo2D","sharedDimensionIndex","testPoints","every","points2D","firstDim","secondDim","projectedPolyline","isPointInsidePolyline3D","projectedHoles","hole2D","rect","lineSegments","rectToLineSegments","pointInSphere","sphere","radius","radius2","INSIDE","OUTSIDE","clipT","c","tE","tL","t","clip","box","da","db","pointInShapeFn","iMin","iMax","jMin","jMax","kMin","kMax","getScalars","getData","getDirection","rowCosines","columnCosines","scanAxisNormal","getSpacing","rowSpacing","columnSpacing","scanAxisSpacing","worldPosStart","indexToWorld","rowStep","columnStep","scanAxisStep","xMultiple","yMultiple","zMultiple","currentPos","k","startPosJ","startPosI","pointIJK","pointToString","decimals","parseFloat","toFixed","getPoint","idx3","getPolyDataPointIndexes","polyData","linesData","getLines","segmentSize","contours","findStartingPoint","entries","nextPoint","getPolyDataPoints","contoursIndexes","rawPointsData","getPoints","contourIndexes","axisList","isAxisAlignedRectangle","rectangleCornersIJK","rectangleVec1","rectangleVec2","calculateAnglesWithAxes","vec","axes","axis","PI","scroll","getImageIds","viewportType","delta","scrollSlabs","debounceLoading","loop","VolumeViewport","useSlabThickness","numScrollSteps","currentStepIndex","sliceRangeInfo","sliceRange","spacingInNormalDirection","focalPoint","newFocalPoint","newPosition","setCamera","render","desiredStepIndex","VolumeScrollEventDetail","currentImageId","getCurrentImageId","EVENTS","VOLUME_SCROLL_OUT_OF_BOUNDS","VOLUME_VIEWPORT_SCROLL","scrollVolume","VideoViewport","ChangeTypesForInterpolation","HandlesUpdated","InterpolationUpdated","InterpolationManager","toolNames","addTool","acceptAutoGenerated","annotationGroupSelector","selector","interpolationUID","autoGenerated","interpolationCompleted","handleAnnotationCompleted","originalToolName","viewportData","sliceData","getSliceData","hasInterpolationUID","filterData","parentKey","interpolationAnnotations","skipUIDs","interpolationAnnotation","handleAnnotationUpdate","changeType","isInterpolationUpdate","handleAnnotationDelete","numberOfSlices","getNumberOfSlices","SegmentationRepresentations","createImageIdReferenceMap","imageIdsArray","segmentationImageIds","lpad","string","character","join","getter","seed","onFlood","onBoundary","equals","diagonals","startNode","permutations","perms","permutation","parseInt","toString","permute","perm","countNonZeroes","prunedPermutations","stack","flooded","visits","bounds","currentArgs","flood","boundaries","job","getArgs","prevArgs","previousArgs","z","iKey","markAsVisited","node","member","markAsFlooded","nextArgs","pushAdjacent","markAsBoundary","getHoveredContourSegmentationAnnotation","annotationUIDs","getSegmentAtLabelmapBorder","worldPoint","searchRadius","labelmapData","LABELMAP","segmentationVolume","getScalarValueFromWorld","onEdge","canvasPoint","getNeighborIndex","deltaI","deltaJ","neighborCanvas","isSegmentOnEdge","isSegmentOnEdgeCanvas","imageIdReferenceMap","segmentationImageId","getImage","segmentationRepresentations","getSegmentationIdRepresentations","segmentationRepresentationUID","segmentationActor","getActor","actor","getMapper","getInputData","indexIJK","voxelManager","createVolumeVoxelManager","getAtIJKPoint","deltaK","neighborIJK","getAtIJK","isSegmentOnEdgeIJK","neighborRange","neighborIndex","getSegmentAtWorldPoint","desiredRepresentation","representationType","getSegmentAtWorldForLabelmap","Contour","contourData","segmentIndices","annotationsSet","getSegmentAtWorldForContour","invalidateBrushCursor","toolGroup","getToolGroup","tool","viewportsInfo","getViewportsInfo","viewportsInfoArray","getViewportIds","getBrushToolInstances","toolInstances","_toolInstances","toolInstance","getDeltaPoints","lastPoints","curr","getMeanPoints","page","_subtractPoints2D","client","point0","getDeltaDistance","_getDistance2D","_getDistance3D","getDeltaDistanceBetweenIPoints","currentDistance","_getMeanDistanceBetweenAllIPoints","lastDistance","copyPointsList","JSON","parse","stringify","copyPoints","prev","getMeanTouchPoints","touch","identifier","radiusX","radiusY","force","rotationAngle","pairedDistance","toolGroupIds","viewportInfo","isViewportPreScaled","targetIdTokens","preScale","scaled","jumpToWorld","jumpWorld","normal","dotProd","projectedDelta","_applyShift","Active","Passive","Enabled","ToolModes","filterViewportsWithToolEnabled","numViewports","viewportsWithToolEnabled","vp","_toolGroupHasActiveEnabledOrPassiveTool","toolOptions","toolMode","mode","EPS","vpCamera","requireParallelNormals","viewportsWithFrameOfReferenceUID","filterViewportsWithFrameOfReferenceUID","DEFAULTS","MULTIPLIER","RANGE_TEXT_POSITION","Right","TICKS_BAR_SIZE","Colorbar","props","_isMouseOver","_isInteracting","_mouseOverCallback","showTicks","stopPropagation","_mouseOutCallback","hideTicks","_mouseDownCallback","_addVOIEventListeners","_mouseDragCallback","initialState","multipliers","getVOIMultipliers","_getPointsFromMouseEvent","startPoints","voiRange","startVOIRange","canvasDelta","local","wwDelta","wcDelta","lower","voiLower","upper","voiUpper","newVoiRange","_mouseUpCallback","_removeVOIEventListeners","_eventListenersManager","_colormaps","getColormapsMap","_activeColormapName","getInitialColormapName","_canvas","_createCanvas","_ticksBar","_createTicksBar","_rangeTextPosition","ticks","appendTo","rootElement","_addRootElementEventListeners","activeColormapName","colormapName","colormap","imageRange","currentVoiRange","onVoiChange","showFullImageRange","showFullPixelValueRange","reset","createRootElement","document","createElement","assign","style","onContainerResize","updateTicksBar","containerSize","visible","colormaps","items","item","Name","some","cm","ticksProps","clientPoint","clientX","clientY","pagePoint","pageX","pageY","getBoundingClientRect","pageXOffset","pageYOffset","containerWidth","containerHeight","ticksBar","rangeTextPosition","isHorizontal","ticksBarTop","ticksBarLeft","Top","Left","manager","initialDragState","ColorbarRangeTextPosition","_scriptDir","currentScript","src","ICRPolySegApp","readyPromiseResolve","readyPromiseReject","Module","readBinary","moduleOverrides","arguments_","thisProgram","quit_","status","toThrow","ENVIRONMENT_IS_WEB","ENVIRONMENT_IS_WORKER","scriptDirectory","self","location","href","substr","lastIndexOf","url","xhr","XMLHttpRequest","open","responseType","send","response","out","bind","wasmBinary","POINTER_SIZE","wasmMemory","noExitRuntime","WebAssembly","abort","EXITSTATUS","HEAP8","HEAPU8","HEAP16","HEAPU16","HEAP32","HEAPU32","HEAPF32","HEAPF64","ABORT","UTF8Decoder","TextDecoder","UTF8ArrayToString","heapOrArray","maxBytesToRead","endIdx","endPtr","decode","subarray","str","u0","u1","u2","fromCharCode","ch","UTF8ToString","ptr","stringToUTF8Array","heap","outIdx","maxBytesToWrite","startIdx","u","charCodeAt","lengthBytesUTF8","updateGlobalBufferAndViews","buf","Int8Array","Int32Array","Uint32Array","Float64Array","wasmTable","__ATPRERUN__","__ATINIT__","__ATMAIN__","__ATPOSTRUN__","runDependencies","runDependencyWatcher","dependenciesFulfilled","what","RuntimeError","wasmBinaryFile","path","dataURIPrefix","isDataURI","filename","getBinary","file","ASM_CONSTS","$0","updateProgress","ExitStatus","message","callRuntimeCallbacks","ExceptionInfo","excPtr","set_type","get_type","set_destructor","destructor","get_destructor","set_refcount","refcount","set_caught","caught","get_caught","set_rethrown","rethrown","get_rethrown","init","set_adjusted_ptr","add_ref","release_ref","adjustedPtr","get_adjusted_ptr","get_exception_ptr","___cxa_is_pointer_type","adjusted","SYSCALLS","varargs","getStr","structRegistrations","runDestructors","destructors","del","simpleReadValueFromPointer","pointer","awaitingDependencies","registeredTypes","typeDependencies","char_0","char_9","makeLegalFunctionName","f","createNamedFunction","body","Function","extendError","baseErrorType","errorName","errorClass","InternalError","throwInternalError","whenDependentTypesAreResolved","myTypes","dependentTypes","getTypeConverters","onComplete","typeConverters","myTypeConverters","registerType","unregisteredTypes","registered","dt","getShiftFromSize","embind_charCodes","readLatin1String","ret","BindingError","throwBindingError","rawType","registeredInstance","ignoreDuplicateRegistrations","emval_free_list","emval_handle_array","__emval_decref","count_emval_handles","get_first_emval","Emval","toValue","toHandle","floatReadValueFromPointer","new_","argumentList","dummy","obj","exposePublicSymbol","numArguments","overloadTable","proto","humanName","prevFunc","arguments","argCount","ensureOverloadTable","wasmTableMirror","getWasmTableEntry","funcPtr","dynCall","sig","concat","dynCallLegacy","embind__requireFunction","signature","rawFunction","argCache","fp","UnboundTypeError","getTypeName","___getTypeName","rv","_free","integerReadValueFromPointer","signed","UTF16Decoder","UTF16ToString","maxIdx","codeUnit","stringToUTF16","outPtr","startPtr","numCharsToWrite","lengthBytesUTF16","UTF32ToString","utf32","stringToUTF32","lengthBytesUTF32","requireRegisteredType","impl","emval_symbols","getStringOrSymbol","address","symbol","emval_methodCallers","emval_get_global","globalThis","emval_registeredMethods","emval_newers","readEmAsmArgsArray","runEmAsmFunction","code","sigPtr","argbuf","readEmAsmArgs","emscripten_realloc_buffer","grow","ENV","getEnvStrings","strings","env","navigator","languages","printCharBuffers","printChar","stream","__isLeapYear","year","__MONTH_DAYS_LEAP","__MONTH_DAYS_REGULAR","_strftime","s","maxsize","format","tm","tm_zone","date","tm_sec","tm_min","tm_hour","tm_mday","tm_mon","tm_year","tm_wday","tm_yday","tm_isdst","tm_gmtoff","pattern","EXPANSION_RULES_1","rule","RegExp","WEEKDAYS","MONTHS","leadingSomething","digits","leadingNulls","compareByDay","date1","date2","sgn","compare","getFullYear","getMonth","getDate","getFirstWeekStartDate","janFourth","getDay","getWeekBasedYear","thisDate","days","newDate","getTime","leap","currentMonth","daysInCurrentMonth","setDate","setMonth","setFullYear","__addDays","janFourthThisYear","janFourthNextYear","firstWeekStartThisYear","firstWeekStartNextYear","EXPANSION_RULES_2","twelveHour","__arraySum","jan1","dec31","off","ahead","stringy","dontAddNull","u8array","numBytesWritten","bytes","writeArrayToMemory","_proc_exit","codes","embind_init_charCodes","calledRun","asmLibraryArg","fd","dirp","dirfd","flags","bufsize","structType","reg","rawConstructor","rawDestructor","fieldRecords","fields","getterReturnType","setterArgumentType","fieldTypes","fieldName","getterContext","setter","setterContext","read","write","o","destructorFunction","primitiveType","minRange","maxRange","trueValue","falseValue","wt","rawArgTypesAddr","rawInvoker","fn","argTypes","firstElement","heap32VectorToArray","types","unboundTypes","seen","visit","throwUnboundTypeError","invokerArgsArray","replacePublicSymbol","classType","cppInvokerFunc","cppTargetFunc","isClassMethodFunc","needsDestructorStack","returns","argsList","argsListWired","invokerFnBody","dtorStack","args1","args2","paramName","craftInvokerFunction","fromWireType","bitshift","isUnsignedType","dataTypeIndex","TA","decodeMemoryView","stdStringIsUTF8","payload","decodeStartPtr","currentBytePtr","stringSegment","ArrayBuffer","valueIsOfTypeString","Uint8ClampedArray","_malloc","charCode","charSize","decodeString","encodeString","getHeap","lengthBytesUTF","HEAP","constructorSignature","destructorSignature","getterSignature","setterSignature","isVoid","returnType","destructorsRef","rd","caller","emval_lookupTypes","retType","signatureName","returnId","params","functionBody","invokerFunction","newer","craftEmvalAllocator","v","arg","dest","copyWithin","requestedSize","multiple","oldSize","maxHeapSize","cutDown","overGrownHeapSize","__environ","environ_buf","bufSize","writeAsciiToMemory","penviron_count","penviron_buf_size","iov","iovcnt","pnum","offset_low","offset_high","whence","newOffset","loc","info","receiveInstance","module","exports","unshift","removeRunDependency","receiveInstantiationResult","instantiateArrayBuffer","receiver","fetch","credentials","binary","instantiate","reason","instantiateStreaming","createWasm","callMain","entryFunction","handleException","run","doRun","shouldRunNow","postRun","preRun","runCaller","ready","ICRPolySeg","_instance","initialize","locateFile","Dir","Forward","Backward","DEFAULT_VALUES","publicAPI","model","initialValues","m","algo","requestData","inData","outData","input","output","extractContours","modified","traverseLoop","pd","startLineId","startPtId","loopPoints","lineId","lastPtId","terminated","numInserted","cellPointIds","getCellPoints","ptId","lineCell","getPointCells","loops","clear","inLines","setData","li","getNumberOfCells","outLines","resize","insertNextCell","pt","vtkContourLoopExtraction","newInstance","polySegConverters","polySeg","polySegInitializing","polySegInitializingPromise","initializePolySeg","progressCallback","convertContourToSurface","polylines","numPointsArray","convertContourRoiToSurface","convertLabelmapToSurface","convertContourToVolumeLabelmap","annotationUIDsInSegmentMap","segmentationVoxelManager","holesPolyline","projectedHole","point2D","setAtIJKPoint","convertContourToStackLabelmap","segmentationsInfo","segmentationVoxelManagers","segmentationInfo","convertSurfaceToVolumeLabelmap","convertSurfaceToLabelmap","polys","convertSurfacesToVolumeLabelmap","segmentsInfo","targetImageData","totalSize","outputVolumesInfo","extent","getExtent","volumeInfo","worldToIndex","roundedIndex","round","getSurfacesAABBs","surfacesInfo","aabbs","getAABB","numDimensions","cutSurfacesIntoPlanes","planesInfo","surfacesAABB","updateCacheCallback","numberOfPlanes","cutter","plane1","setCutFunction","surfacePolyData","planeInfo","planes","polyDataResults","polyDataInfo","aabb3","minZ","maxZ","isPlaneIntersectingAABB","getPolys","setInputData","setNormal","update","getOutputData","cutterOutput","buildLinks","loopExtraction","loopOutput","lines","numberOfCells","progress","vtkErrorMacro","dataDescription","EMPTY","setGetArray","getArray","classHierarchy","setExtent","deleted","_len","inExtent","_key","extentArray","changeDetected","dims","nCells","getNumberOfPoints","ijk","SINGLE_POINT","X_LINE","Y_LINE","Z_LINE","XY_PLANE","YZ_PLANE","XZ_PLANE","XYZ_GRID","coords","getBounds","extentToBounds","getSpatialExtent","ex","computeTransforms","ain","aout","worldToIndexVec3","indexToWorldBounds","bin","bout","worldToIndexBounds","onModified","getCenter","computeHistogram","worldBounds","voxelFunc","yStride","zStride","pixels","maximum","minimum","sumOfSquares","isum","inum","pixel","average","variance","sigma","computeIncrements","increments","incr","computeOffsetIndex","_ref","getNumberOfComponents","getOffsetIndexFromWorld","xyz","comp","offsetIndex","isNaN","getComponent","vtkImageData","vtkImageData$1","vtkDebugMacro","vtkImageMarchingSquares","getContourValues","contourValues","setContourValues","cValues","ids","pixelScalars","pixelPts","edgeLocator","getPixelScalars","scalars","kernelX","kernelY","ii","getPixelPoints","produceLines","cVal","slicingMode","CASE_MASK","pId","pixelLines","getCase","eid","edgeVerts","getEdge","mergePoints","isInsertedEdge","x0","insertEdge","getOrigin","getKernels","cv","polydata","timeEnd","setGet","proxyMarker","createEndpoint","releaseProxy","finalizer","throwMarker","isObject","transferHandlers","canHandle","serialize","port1","port2","MessageChannel","expose","deserialize","port","wrap","serialized","isError","ep","allowedOrigins","ev","allowedOrigin","test","isAllowedOrigin","fromWireValue","returnValue","parent","prop","rawValue","proxy","transfers","transferCache","transfer","wireValue","transferables","toWireValue","postMessage","closeEndPoint","endpoint","isMessagePort","close","target","createProxy","throwIfProxyReleased","isReleased","releaseEndpoint","requestResponseMessage","proxyCounter","proxyFinalizers","FinalizationRegistry","newCount","isProxyReleased","Proxy","_target","unregister","unregisterProxy","_thisArg","rawArgumentList","processArguments","construct","registerProxy","processed","arr","handler","serializedValue","msg","MAX_SAFE_INTEGER","l","bisector","compare1","compare2","lo","hi","mid","d","zero"],"sourceRoot":""}