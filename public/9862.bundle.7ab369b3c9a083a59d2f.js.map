{"version":3,"file":"9862.bundle.7ab369b3c9a083a59d2f.js","mappings":"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","sources":["webpack:///../../../extensions/measurement-tracking/src/viewports/TrackedCornerstoneViewport.tsx"],"sourcesContent":["import React, { useState, useEffect, useCallback } from 'react';\r\nimport PropTypes from 'prop-types';\r\n\r\nimport { ViewportActionArrows } from '@ohif/ui-next';\r\nimport { useViewportGrid, Icons, Tooltip, TooltipTrigger, TooltipContent } from '@ohif/ui-next';\r\n\r\nimport { annotation } from '@cornerstonejs/tools';\r\nimport { useTrackedMeasurements } from './../getContextModule';\r\nimport { BaseVolumeViewport, Enums } from '@cornerstonejs/core';\r\nimport { useTranslation } from 'react-i18next';\r\n\r\nfunction TrackedCornerstoneViewport(\r\n  props: withAppTypes<{ viewportId: string; displaySets: AppTypes.DisplaySet[] }>\r\n) {\r\n  const { displaySets, viewportId, servicesManager, extensionManager } = props;\r\n\r\n  const {\r\n    measurementService,\r\n    cornerstoneViewportService,\r\n    viewportGridService,\r\n    viewportActionCornersService,\r\n  } = servicesManager.services;\r\n\r\n  // Todo: handling more than one displaySet on the same viewport\r\n  const displaySet = displaySets[0];\r\n  const { t } = useTranslation('Common');\r\n\r\n  const [viewportGrid] = useViewportGrid();\r\n  const { activeViewportId } = viewportGrid;\r\n\r\n  const [trackedMeasurements, sendTrackedMeasurementsEvent] = useTrackedMeasurements();\r\n\r\n  const [isTracked, setIsTracked] = useState(false);\r\n  const [trackedMeasurementUID, setTrackedMeasurementUID] = useState(null);\r\n  const [viewportElem, setViewportElem] = useState(null);\r\n\r\n  const { trackedSeries } = trackedMeasurements.context;\r\n\r\n  const { SeriesInstanceUID } = displaySet;\r\n\r\n  const updateIsTracked = useCallback(() => {\r\n    const viewport = cornerstoneViewportService.getCornerstoneViewport(viewportId);\r\n\r\n    if (viewport instanceof BaseVolumeViewport) {\r\n      // A current image id will only exist for volume viewports that can have measurements tracked.\r\n      // Typically these are those volume viewports for the series of acquisition.\r\n      const currentImageId = viewport?.getCurrentImageId();\r\n\r\n      if (!currentImageId) {\r\n        if (isTracked) {\r\n          setIsTracked(false);\r\n        }\r\n        return;\r\n      }\r\n    }\r\n\r\n    if (trackedSeries.includes(SeriesInstanceUID) !== isTracked) {\r\n      setIsTracked(!isTracked);\r\n    }\r\n  }, [isTracked, trackedMeasurements, viewportId, SeriesInstanceUID]);\r\n\r\n  const onElementEnabled = useCallback(\r\n    evt => {\r\n      if (evt.detail.element !== viewportElem) {\r\n        // The VOLUME_VIEWPORT_NEW_VOLUME event allows updateIsTracked to reliably fetch the image id for a volume viewport.\r\n        evt.detail.element?.addEventListener(\r\n          Enums.Events.VOLUME_VIEWPORT_NEW_VOLUME,\r\n          updateIsTracked\r\n        );\r\n        setViewportElem(evt.detail.element);\r\n      }\r\n    },\r\n    [updateIsTracked, viewportElem]\r\n  );\r\n\r\n  const onElementDisabled = useCallback(() => {\r\n    viewportElem?.removeEventListener(Enums.Events.VOLUME_VIEWPORT_NEW_VOLUME, updateIsTracked);\r\n  }, [updateIsTracked, viewportElem]);\r\n\r\n  useEffect(updateIsTracked, [updateIsTracked]);\r\n\r\n  useEffect(() => {\r\n    const { unsubscribe } = cornerstoneViewportService.subscribe(\r\n      cornerstoneViewportService.EVENTS.VIEWPORT_DATA_CHANGED,\r\n      props => {\r\n        if (props.viewportId !== viewportId) {\r\n          return;\r\n        }\r\n\r\n        updateIsTracked();\r\n      }\r\n    );\r\n\r\n    return () => {\r\n      unsubscribe();\r\n    };\r\n  }, [updateIsTracked, viewportId]);\r\n\r\n  useEffect(() => {\r\n    if (isTracked) {\r\n      annotation.config.style.setViewportToolStyles(viewportId, {\r\n        ReferenceLines: {\r\n          lineDash: '4,4',\r\n        },\r\n        global: {\r\n          lineDash: '',\r\n        },\r\n      });\r\n\r\n      cornerstoneViewportService.getRenderingEngine().renderViewport(viewportId);\r\n\r\n      return;\r\n    }\r\n\r\n    annotation.config.style.setViewportToolStyles(viewportId, {\r\n      global: {\r\n        lineDash: '4,4',\r\n      },\r\n    });\r\n\r\n    cornerstoneViewportService.getRenderingEngine().renderViewport(viewportId);\r\n\r\n    return () => {\r\n      annotation.config.style.setViewportToolStyles(viewportId, {});\r\n    };\r\n  }, [isTracked]);\r\n\r\n  /**\r\n   * The effect for listening to measurement service measurement added events\r\n   * and in turn firing an event to update the measurement tracking state machine.\r\n   * The TrackedCornerstoneViewport is the best place for this because when\r\n   * a measurement is added, at least one TrackedCornerstoneViewport will be in\r\n   * the DOM and thus can react to the events fired.\r\n   */\r\n  useEffect(() => {\r\n    const added = measurementService.EVENTS.MEASUREMENT_ADDED;\r\n    const addedRaw = measurementService.EVENTS.RAW_MEASUREMENT_ADDED;\r\n    const subscriptions = [];\r\n\r\n    [added, addedRaw].forEach(evt => {\r\n      subscriptions.push(\r\n        measurementService.subscribe(evt, ({ source, measurement }) => {\r\n          const { activeViewportId } = viewportGridService.getState();\r\n\r\n          // Each TrackedCornerstoneViewport receives the MeasurementService's events.\r\n          // Only send the tracked measurements event for the active viewport to avoid\r\n          // sending it more than once.\r\n          if (viewportId === activeViewportId) {\r\n            const {\r\n              referenceStudyUID: StudyInstanceUID,\r\n              referenceSeriesUID: SeriesInstanceUID,\r\n              uid: measurementId,\r\n              toolName,\r\n            } = measurement;\r\n\r\n            sendTrackedMeasurementsEvent('SET_DIRTY', { SeriesInstanceUID });\r\n            sendTrackedMeasurementsEvent('TRACK_SERIES', {\r\n              viewportId,\r\n              StudyInstanceUID,\r\n              SeriesInstanceUID,\r\n              measurementId,\r\n              toolName,\r\n            });\r\n          }\r\n        }).unsubscribe\r\n      );\r\n    });\r\n\r\n    return () => {\r\n      subscriptions.forEach(unsub => {\r\n        unsub();\r\n      });\r\n    };\r\n  }, [measurementService, sendTrackedMeasurementsEvent, viewportId, viewportGridService]);\r\n\r\n  const switchMeasurement = useCallback(\r\n    direction => {\r\n      const newTrackedMeasurementUID = _getNextMeasurementUID(\r\n        direction,\r\n        servicesManager,\r\n        trackedMeasurementUID,\r\n        trackedMeasurements\r\n      );\r\n\r\n      if (!newTrackedMeasurementUID) {\r\n        return;\r\n      }\r\n\r\n      setTrackedMeasurementUID(newTrackedMeasurementUID);\r\n\r\n      measurementService.jumpToMeasurement(viewportId, newTrackedMeasurementUID);\r\n    },\r\n    [measurementService, servicesManager, trackedMeasurementUID, trackedMeasurements, viewportId]\r\n  );\r\n\r\n  useEffect(() => {\r\n    const statusComponent = _getStatusComponent(isTracked, t);\r\n    const arrowsComponent = _getArrowsComponent(\r\n      isTracked,\r\n      switchMeasurement,\r\n      viewportId === activeViewportId\r\n    );\r\n\r\n    viewportActionCornersService.addComponents([\r\n      {\r\n        viewportId,\r\n        id: 'viewportStatusComponent',\r\n        component: statusComponent,\r\n        indexPriority: -100,\r\n        location: viewportActionCornersService.LOCATIONS.topLeft,\r\n      },\r\n      {\r\n        viewportId,\r\n        id: 'viewportActionArrowsComponent',\r\n        component: arrowsComponent,\r\n        indexPriority: 0,\r\n        location: viewportActionCornersService.LOCATIONS.topRight,\r\n      },\r\n    ]);\r\n  }, [activeViewportId, isTracked, switchMeasurement, viewportActionCornersService, viewportId]);\r\n\r\n  const getCornerstoneViewport = () => {\r\n    const { component: Component } = extensionManager.getModuleEntry(\r\n      '@ohif/extension-cornerstone.viewportModule.cornerstone'\r\n    );\r\n\r\n    return (\r\n      <Component\r\n        {...props}\r\n        onElementEnabled={evt => {\r\n          props.onElementEnabled?.(evt);\r\n          onElementEnabled(evt);\r\n        }}\r\n        onElementDisabled={onElementDisabled}\r\n      />\r\n    );\r\n  };\r\n\r\n  return (\r\n    <div className=\"relative flex h-full w-full flex-row overflow-hidden\">\r\n      {getCornerstoneViewport()}\r\n    </div>\r\n  );\r\n}\r\n\r\nTrackedCornerstoneViewport.propTypes = {\r\n  displaySets: PropTypes.arrayOf(PropTypes.object.isRequired).isRequired,\r\n  viewportId: PropTypes.string.isRequired,\r\n  dataSource: PropTypes.object,\r\n  children: PropTypes.node,\r\n};\r\n\r\nfunction _getNextMeasurementUID(\r\n  direction,\r\n  servicesManager: AppTypes.ServicesManager,\r\n  trackedMeasurementId,\r\n  trackedMeasurements\r\n) {\r\n  const { measurementService, viewportGridService } = servicesManager.services;\r\n  const measurements = measurementService.getMeasurements();\r\n\r\n  const { activeViewportId, viewports } = viewportGridService.getState();\r\n  const { displaySetInstanceUIDs: activeViewportDisplaySetInstanceUIDs } =\r\n    viewports.get(activeViewportId);\r\n\r\n  const { trackedSeries } = trackedMeasurements.context;\r\n\r\n  // Get the potentially trackable measurements for the series of the\r\n  // active viewport.\r\n  // The measurements to jump between are the same\r\n  // regardless if this series is tracked or not.\r\n\r\n  const filteredMeasurements = measurements.filter(\r\n    m =>\r\n      trackedSeries.includes(m.referenceSeriesUID) &&\r\n      activeViewportDisplaySetInstanceUIDs.includes(m.displaySetInstanceUID)\r\n  );\r\n\r\n  if (!filteredMeasurements.length) {\r\n    // No measurements on this series.\r\n    return;\r\n  }\r\n\r\n  const measurementCount = filteredMeasurements.length;\r\n\r\n  const uids = filteredMeasurements.map(fm => fm.uid);\r\n  let measurementIndex = uids.findIndex(uid => uid === trackedMeasurementId);\r\n\r\n  if (measurementIndex === -1) {\r\n    // Not tracking a measurement, or previous measurement now deleted, revert to 0.\r\n    measurementIndex = 0;\r\n  } else {\r\n    measurementIndex += direction;\r\n    if (measurementIndex < 0) {\r\n      measurementIndex = measurementCount - 1;\r\n    } else if (measurementIndex === measurementCount) {\r\n      measurementIndex = 0;\r\n    }\r\n  }\r\n\r\n  const newTrackedMeasurementId = uids[measurementIndex];\r\n\r\n  return newTrackedMeasurementId;\r\n}\r\n\r\nconst _getArrowsComponent = (isTracked, switchMeasurement, isActiveViewport) => {\r\n  if (!isTracked) {\r\n    return null;\r\n  }\r\n\r\n  return (\r\n    <ViewportActionArrows\r\n      onArrowsClick={direction => switchMeasurement(direction)}\r\n      className={isActiveViewport ? 'visible' : 'invisible group-hover/pane:visible'}\r\n    />\r\n  );\r\n};\r\n\r\nfunction _getStatusComponent(isTracked, t) {\r\n  if (!isTracked) {\r\n    return null;\r\n  }\r\n\r\n  return (\r\n    <Tooltip>\r\n      <TooltipTrigger asChild>\r\n        <span>\r\n          <Icons.StatusTracking className=\"text-muted-foreground mt-0.5 ml-0.5\" />\r\n        </span>\r\n      </TooltipTrigger>\r\n      <TooltipContent\r\n        align=\"start\"\r\n        side=\"bottom\"\r\n      >\r\n        {isTracked ? (\r\n          <>{t('Series is tracked and can be viewed in the measurement panel')}</>\r\n        ) : (\r\n          <>{t('Measurements for untracked series will not be shown in the measurements panel')}</>\r\n        )}\r\n      </TooltipContent>\r\n    </Tooltip>\r\n  );\r\n}\r\n\r\nexport default TrackedCornerstoneViewport;\r\n"],"names":["TrackedCornerstoneViewport","props","displaySets","viewportId","servicesManager","extensionManager","measurementService","cornerstoneViewportService","viewportGridService","viewportActionCornersService","services","displaySet","t","useTranslation","viewportGrid","useViewportGrid","activeViewportId","trackedMeasurements","sendTrackedMeasurementsEvent","useTrackedMeasurements","isTracked","setIsTracked","useState","trackedMeasurementUID","setTrackedMeasurementUID","viewportElem","setViewportElem","trackedSeries","context","SeriesInstanceUID","updateIsTracked","useCallback","viewport","getCornerstoneViewport","BaseVolumeViewport","currentImageId","getCurrentImageId","includes","onElementEnabled","evt","detail","element","addEventListener","Enums","VOLUME_VIEWPORT_NEW_VOLUME","onElementDisabled","removeEventListener","useEffect","unsubscribe","subscribe","EVENTS","VIEWPORT_DATA_CHANGED","annotation","setViewportToolStyles","ReferenceLines","lineDash","global","getRenderingEngine","renderViewport","added","MEASUREMENT_ADDED","addedRaw","RAW_MEASUREMENT_ADDED","subscriptions","forEach","push","source","measurement","getState","referenceStudyUID","StudyInstanceUID","referenceSeriesUID","uid","measurementId","toolName","unsub","switchMeasurement","direction","newTrackedMeasurementUID","trackedMeasurementId","measurements","getMeasurements","viewports","displaySetInstanceUIDs","activeViewportDisplaySetInstanceUIDs","get","filteredMeasurements","filter","m","displaySetInstanceUID","length","measurementCount","uids","map","fm","measurementIndex","findIndex","_getNextMeasurementUID","jumpToMeasurement","statusComponent","React","Tooltip","TooltipTrigger","asChild","Icons","StatusTracking","className","TooltipContent","align","side","_getStatusComponent","arrowsComponent","_getArrowsComponent","addComponents","id","component","indexPriority","location","LOCATIONS","topLeft","topRight","Component","getModuleEntry","_extends","propTypes","PropTypes","isRequired","dataSource","children","isActiveViewport","ViewportActionArrows","onArrowsClick"],"sourceRoot":""}