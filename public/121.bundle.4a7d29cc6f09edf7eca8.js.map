{"version":3,"file":"121.bundle.4a7d29cc6f09edf7eca8.js","mappings":"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","sources":["webpack:///../../../extensions/cornerstone-dicom-rt/src/utils/promptHydrateRT.ts","webpack:///../../../extensions/cornerstone-dicom-rt/src/viewports/_getStatusComponent.tsx","webpack:///../../../extensions/cornerstone-dicom-rt/src/utils/initRTToolGroup.ts","webpack:///../../../extensions/cornerstone-dicom-rt/src/viewports/OHIFCornerstoneRTViewport.tsx"],"sourcesContent":["import { ButtonEnums } from '@ohif/ui';\n\nconst RESPONSE = {\n  NO_NEVER: -1,\n  CANCEL: 0,\n  HYDRATE_SEG: 5,\n};\n\nfunction promptHydrateRT({\n  servicesManager,\n  rtDisplaySet,\n  viewportId,\n  toolGroupId = 'default',\n  preHydrateCallbacks,\n  hydrateRTDisplaySet,\n}) {\n  const { uiViewportDialogService } = servicesManager.services;\n\n  return new Promise(async function (resolve, reject) {\n    const promptResult = await _askHydrate(uiViewportDialogService, viewportId);\n\n    if (promptResult === RESPONSE.HYDRATE_SEG) {\n      preHydrateCallbacks?.forEach(callback => {\n        callback();\n      });\n\n      const isHydrated = await hydrateRTDisplaySet({\n        rtDisplaySet,\n        viewportId,\n        toolGroupId,\n        servicesManager,\n      });\n\n      resolve(isHydrated);\n    }\n  });\n}\n\nfunction _askHydrate(uiViewportDialogService, viewportId) {\n  return new Promise(function (resolve, reject) {\n    const message = 'Do you want to open this Segmentation?';\n    const actions = [\n      {\n        type: ButtonEnums.type.secondary,\n        text: 'No',\n        value: RESPONSE.CANCEL,\n      },\n      {\n        type: ButtonEnums.type.primary,\n        text: 'Yes',\n        value: RESPONSE.HYDRATE_SEG,\n      },\n    ];\n    const onSubmit = result => {\n      uiViewportDialogService.hide();\n      resolve(result);\n    };\n\n    uiViewportDialogService.show({\n      viewportId,\n      type: 'info',\n      message,\n      actions,\n      onSubmit,\n      onOutsideClick: () => {\n        uiViewportDialogService.hide();\n        resolve(RESPONSE.CANCEL);\n      },\n      onKeyPress: event => {\n        if (event.key === 'Enter') {\n          onSubmit(RESPONSE.HYDRATE_SEG);\n        }\n      },\n    });\n  });\n}\n\nexport default promptHydrateRT;\n","import React from 'react';\nimport { useTranslation } from 'react-i18next';\nimport { Icon, Tooltip } from '@ohif/ui';\n\nexport default function _getStatusComponent({ isHydrated, onStatusClick }) {\n  let ToolTipMessage = null;\n  let StatusIcon = null;\n\n  switch (isHydrated) {\n    case true:\n      StatusIcon = () => <Icon name=\"status-alert\" />;\n\n      ToolTipMessage = () => <div>This Segmentation is loaded in the segmentation panel</div>;\n      break;\n    case false:\n      StatusIcon = () => (\n        <Icon\n          className=\"text-aqua-pale\"\n          name=\"status-untracked\"\n        />\n      );\n\n      ToolTipMessage = () => <div>Click LOAD to load RTSTRUCT.</div>;\n  }\n\n  const StatusArea = () => {\n    const { t } = useTranslation('Common');\n    const loadStr = t('LOAD');\n\n    return (\n      <div className=\"flex h-6 cursor-default text-sm leading-6 text-white\">\n        <div className=\"bg-customgray-100 flex min-w-[45px] items-center rounded-l-xl rounded-r p-1\">\n          <StatusIcon />\n          <span className=\"ml-1\">RTSTRUCT</span>\n        </div>\n        {!isHydrated && (\n          <div\n            className=\"bg-primary-main hover:bg-primary-light ml-1 cursor-pointer rounded px-1.5 hover:text-black\"\n            // Using onMouseUp here because onClick is not working when the viewport is not active and is styled with pointer-events:none\n            onMouseUp={onStatusClick}\n          >\n            {loadStr}\n          </div>\n        )}\n      </div>\n    );\n  };\n\n  return (\n    <>\n      {ToolTipMessage && (\n        <Tooltip\n          content={<ToolTipMessage />}\n          position=\"bottom-left\"\n        >\n          <StatusArea />\n        </Tooltip>\n      )}\n      {!ToolTipMessage && <StatusArea />}\n    </>\n  );\n}\n","function createRTToolGroupAndAddTools(ToolGroupService, customizationService, toolGroupId) {\n  const { tools } = customizationService.get('cornerstone.overlayViewportTools') ?? {};\n\n  return ToolGroupService.createToolGroupAndAddTools(toolGroupId, tools);\n}\n\nexport default createRTToolGroupAndAddTools;\n","import React, { useCallback, useEffect, useRef, useState } from 'react';\nimport PropTypes from 'prop-types';\nimport { useViewportGrid, LoadingIndicatorTotalPercent, ViewportActionArrows } from '@ohif/ui';\n\nimport promptHydrateRT from '../utils/promptHydrateRT';\nimport _getStatusComponent from './_getStatusComponent';\nimport createRTToolGroupAndAddTools from '../utils/initRTToolGroup';\n\nconst RT_TOOLGROUP_BASE_NAME = 'RTToolGroup';\n\nfunction OHIFCornerstoneRTViewport(props) {\n  const {\n    children,\n    displaySets,\n    viewportOptions,\n    servicesManager,\n    extensionManager,\n    commandsManager,\n  } = props;\n\n  const {\n    displaySetService,\n    toolGroupService,\n    segmentationService,\n    uiNotificationService,\n    customizationService,\n    viewportActionCornersService,\n  } = servicesManager.services;\n\n  const viewportId = viewportOptions.viewportId;\n\n  const toolGroupId = `${RT_TOOLGROUP_BASE_NAME}-${viewportId}`;\n\n  // RT viewport will always have a single display set\n  if (displaySets.length > 1) {\n    throw new Error('RT viewport should only have a single display set');\n  }\n\n  const rtDisplaySet = displaySets[0];\n\n  const [viewportGrid, viewportGridService] = useViewportGrid();\n\n  // States\n  const [isToolGroupCreated, setToolGroupCreated] = useState(false);\n  const [selectedSegment, setSelectedSegment] = useState(1);\n\n  // Hydration means that the RT is opened and segments are loaded into the\n  // segmentation panel, and RT is also rendered on any viewport that is in the\n  // same frameOfReferenceUID as the referencedSeriesUID of the RT. However,\n  // loading basically means RT loading over network and bit unpacking of the\n  // RT data.\n  const [isHydrated, setIsHydrated] = useState(rtDisplaySet.isHydrated);\n  const [rtIsLoading, setRtIsLoading] = useState(!rtDisplaySet.isLoaded);\n  const [element, setElement] = useState(null);\n  const [processingProgress, setProcessingProgress] = useState({\n    percentComplete: null,\n    totalSegments: null,\n  });\n\n  // refs\n  const referencedDisplaySetRef = useRef(null);\n\n  const { viewports, activeViewportId } = viewportGrid;\n\n  const referencedDisplaySet = rtDisplaySet.getReferenceDisplaySet();\n  const referencedDisplaySetMetadata = _getReferencedDisplaySetMetadata(referencedDisplaySet);\n\n  referencedDisplaySetRef.current = {\n    displaySet: referencedDisplaySet,\n    metadata: referencedDisplaySetMetadata,\n  };\n  /**\n   * OnElementEnabled callback which is called after the cornerstoneExtension\n   * has enabled the element. Note: we delegate all the image rendering to\n   * cornerstoneExtension, so we don't need to do anything here regarding\n   * the image rendering, element enabling etc.\n   */\n  const onElementEnabled = evt => {\n    setElement(evt.detail.element);\n  };\n\n  const onElementDisabled = () => {\n    setElement(null);\n  };\n\n  const storePresentationState = useCallback(() => {\n    viewportGrid?.viewports.forEach(({ viewportId }) => {\n      commandsManager.runCommand('storePresentation', {\n        viewportId,\n      });\n    });\n  }, [viewportGrid]);\n\n  const hydrateRTDisplaySet = ({ rtDisplaySet, viewportId }) => {\n    commandsManager.runCommand('loadSegmentationDisplaySetsForViewport', {\n      displaySets: [rtDisplaySet],\n      viewportId,\n    });\n  };\n\n  const getCornerstoneViewport = useCallback(() => {\n    const { component: Component } = extensionManager.getModuleEntry(\n      '@ohif/extension-cornerstone.viewportModule.cornerstone'\n    );\n\n    const { displaySet: referencedDisplaySet } = referencedDisplaySetRef.current;\n\n    // Todo: jump to the center of the first segment\n    return (\n      <Component\n        {...props}\n        displaySets={[referencedDisplaySet, rtDisplaySet]}\n        viewportOptions={{\n          viewportType: 'volume',\n          toolGroupId: toolGroupId,\n          orientation: viewportOptions.orientation,\n          viewportId: viewportOptions.viewportId,\n        }}\n        onElementEnabled={evt => {\n          props.onElementEnabled?.(evt);\n          onElementEnabled(evt);\n        }}\n        onElementDisabled={onElementDisabled}\n      ></Component>\n    );\n  }, [viewportId, rtDisplaySet, toolGroupId]);\n\n  const onSegmentChange = useCallback(\n    direction => {\n      const segmentationId = rtDisplaySet.displaySetInstanceUID;\n      const segmentation = segmentationService.getSegmentation(segmentationId);\n\n      const { segments } = segmentation;\n\n      const numberOfSegments = Object.keys(segments).length;\n\n      let newSelectedSegmentIndex = selectedSegment + direction;\n\n      // Segment 0 is always background\n      if (newSelectedSegmentIndex >= numberOfSegments - 1) {\n        newSelectedSegmentIndex = 1;\n      } else if (newSelectedSegmentIndex === 0) {\n        newSelectedSegmentIndex = numberOfSegments - 1;\n      }\n\n      segmentationService.jumpToSegmentCenter(segmentationId, newSelectedSegmentIndex, toolGroupId);\n      setSelectedSegment(newSelectedSegmentIndex);\n    },\n    [selectedSegment]\n  );\n\n  useEffect(() => {\n    if (rtIsLoading) {\n      return;\n    }\n\n    promptHydrateRT({\n      servicesManager,\n      viewportId,\n      rtDisplaySet,\n      preHydrateCallbacks: [storePresentationState],\n      hydrateRTDisplaySet,\n    }).then(isHydrated => {\n      if (isHydrated) {\n        setIsHydrated(true);\n      }\n    });\n  }, [servicesManager, viewportId, rtDisplaySet, rtIsLoading]);\n\n  useEffect(() => {\n    // I'm not sure what is this, since in RT we support Overlapping segments\n    // via contours\n    const { unsubscribe } = segmentationService.subscribe(\n      segmentationService.EVENTS.SEGMENTATION_LOADING_COMPLETE,\n      evt => {\n        if (evt.rtDisplaySet.displaySetInstanceUID === rtDisplaySet.displaySetInstanceUID) {\n          setRtIsLoading(false);\n        }\n\n        if (evt.overlappingSegments) {\n          uiNotificationService.show({\n            title: 'Overlapping Segments',\n            message: 'Overlapping segments detected which is not currently supported',\n            type: 'warning',\n          });\n        }\n      }\n    );\n\n    return () => {\n      unsubscribe();\n    };\n  }, [rtDisplaySet]);\n\n  useEffect(() => {\n    const { unsubscribe } = segmentationService.subscribe(\n      segmentationService.EVENTS.SEGMENT_LOADING_COMPLETE,\n      ({ percentComplete, numSegments }) => {\n        setProcessingProgress({\n          percentComplete,\n          totalSegments: numSegments,\n        });\n      }\n    );\n\n    return () => {\n      unsubscribe();\n    };\n  }, [rtDisplaySet]);\n\n  /**\n   Cleanup the SEG viewport when the viewport is destroyed\n   */\n  useEffect(() => {\n    const onDisplaySetsRemovedSubscription = displaySetService.subscribe(\n      displaySetService.EVENTS.DISPLAY_SETS_REMOVED,\n      ({ displaySetInstanceUIDs }) => {\n        const activeViewport = viewports.get(activeViewportId);\n        if (displaySetInstanceUIDs.includes(activeViewport.displaySetInstanceUID)) {\n          viewportGridService.setDisplaySetsForViewport({\n            viewportId: activeViewportId,\n            displaySetInstanceUIDs: [],\n          });\n        }\n      }\n    );\n\n    return () => {\n      onDisplaySetsRemovedSubscription.unsubscribe();\n    };\n  }, []);\n\n  useEffect(() => {\n    let toolGroup = toolGroupService.getToolGroup(toolGroupId);\n\n    if (toolGroup) {\n      return;\n    }\n\n    toolGroup = createRTToolGroupAndAddTools(toolGroupService, customizationService, toolGroupId);\n\n    setToolGroupCreated(true);\n\n    return () => {\n      // remove the segmentation representations if seg displayset changed\n      segmentationService.removeSegmentationRepresentationFromToolGroup(toolGroupId);\n\n      toolGroupService.destroyToolGroup(toolGroupId);\n    };\n  }, []);\n\n  useEffect(() => {\n    setIsHydrated(rtDisplaySet.isHydrated);\n\n    return () => {\n      // remove the segmentation representations if seg displayset changed\n      segmentationService.removeSegmentationRepresentationFromToolGroup(toolGroupId);\n      referencedDisplaySetRef.current = null;\n    };\n  }, [rtDisplaySet]);\n\n  // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n  let childrenWithProps = null;\n\n  if (\n    !referencedDisplaySetRef.current ||\n    referencedDisplaySet.displaySetInstanceUID !==\n      referencedDisplaySetRef.current.displaySet.displaySetInstanceUID\n  ) {\n    return null;\n  }\n\n  if (children && children.length) {\n    childrenWithProps = children.map((child, index) => {\n      return (\n        child &&\n        React.cloneElement(child, {\n          viewportId,\n          key: index,\n        })\n      );\n    });\n  }\n\n  const onStatusClick = useCallback(async () => {\n    // Before hydrating a RT and make it added to all viewports in the grid\n    // that share the same frameOfReferenceUID, we need to store the viewport grid\n    // presentation state, so that we can restore it after hydrating the RT. This is\n    // required if the user has changed the viewport (other viewport than RT viewport)\n    // presentation state (w/l and invert) and then opens the RT. If we don't store\n    // the presentation state, the viewport will be reset to the default presentation\n    storePresentationState();\n    const isHydrated = await hydrateRTDisplaySet({\n      rtDisplaySet,\n      viewportId,\n    });\n\n    setIsHydrated(isHydrated);\n  }, [hydrateRTDisplaySet, rtDisplaySet, storePresentationState, viewportId]);\n\n  useEffect(() => {\n    viewportActionCornersService.setComponents([\n      {\n        viewportId,\n        id: 'viewportStatusComponent',\n        component: _getStatusComponent({\n          isHydrated,\n          onStatusClick,\n        }),\n        indexPriority: -100,\n        location: viewportActionCornersService.LOCATIONS.topLeft,\n      },\n      {\n        viewportId,\n        id: 'viewportActionArrowsComponent',\n        component: (\n          <ViewportActionArrows\n            key=\"actionArrows\"\n            onArrowsClick={onSegmentChange}\n            className={\n              viewportId === activeViewportId ? 'visible' : 'invisible group-hover:visible'\n            }\n          ></ViewportActionArrows>\n        ),\n        indexPriority: 0,\n        location: viewportActionCornersService.LOCATIONS.topRight,\n      },\n    ]);\n  }, [\n    activeViewportId,\n    isHydrated,\n    onSegmentChange,\n    onStatusClick,\n    viewportActionCornersService,\n    viewportId,\n  ]);\n\n  return (\n    <>\n      <div className=\"relative flex h-full w-full flex-row overflow-hidden\">\n        {rtIsLoading && (\n          <LoadingIndicatorTotalPercent\n            className=\"h-full w-full\"\n            totalNumbers={processingProgress.totalSegments}\n            percentComplete={processingProgress.percentComplete}\n            loadingText=\"Loading RTSTRUCT...\"\n          />\n        )}\n        {getCornerstoneViewport()}\n        {childrenWithProps}\n      </div>\n    </>\n  );\n}\n\nOHIFCornerstoneRTViewport.propTypes = {\n  displaySets: PropTypes.arrayOf(PropTypes.object),\n  viewportId: PropTypes.string.isRequired,\n  dataSource: PropTypes.object,\n  children: PropTypes.node,\n  customProps: PropTypes.object,\n};\n\nOHIFCornerstoneRTViewport.defaultProps = {\n  customProps: {},\n};\n\nfunction _getReferencedDisplaySetMetadata(referencedDisplaySet) {\n  const image0 = referencedDisplaySet.images[0];\n  const referencedDisplaySetMetadata = {\n    PatientID: image0.PatientID,\n    PatientName: image0.PatientName,\n    PatientSex: image0.PatientSex,\n    PatientAge: image0.PatientAge,\n    SliceThickness: image0.SliceThickness,\n    StudyDate: image0.StudyDate,\n    SeriesDescription: image0.SeriesDescription,\n    SeriesInstanceUID: image0.SeriesInstanceUID,\n    SeriesNumber: image0.SeriesNumber,\n    ManufacturerModelName: image0.ManufacturerModelName,\n    SpacingBetweenSlices: image0.SpacingBetweenSlices,\n  };\n\n  return referencedDisplaySetMetadata;\n}\n\nexport default OHIFCornerstoneRTViewport;\n"],"names":["RESPONSE","NO_NEVER","CANCEL","HYDRATE_SEG","servicesManager","rtDisplaySet","viewportId","toolGroupId","preHydrateCallbacks","hydrateRTDisplaySet","uiViewportDialogService","services","Promise","async","resolve","reject","promptResult","message","actions","type","ButtonEnums","secondary","text","value","primary","onSubmit","result","hide","show","onOutsideClick","onKeyPress","event","key","_askHydrate","forEach","callback","_getStatusComponent","isHydrated","onStatusClick","ToolTipMessage","StatusIcon","React","Icon","name","className","StatusArea","t","useTranslation","loadStr","onMouseUp","Tooltip","content","position","ToolGroupService","customizationService","tools","get","createToolGroupAndAddTools","OHIFCornerstoneRTViewport","props","children","displaySets","viewportOptions","extensionManager","commandsManager","displaySetService","toolGroupService","segmentationService","uiNotificationService","viewportActionCornersService","length","Error","viewportGrid","viewportGridService","useViewportGrid","isToolGroupCreated","setToolGroupCreated","useState","selectedSegment","setSelectedSegment","setIsHydrated","rtIsLoading","setRtIsLoading","isLoaded","element","setElement","processingProgress","setProcessingProgress","percentComplete","totalSegments","referencedDisplaySetRef","useRef","viewports","activeViewportId","referencedDisplaySet","getReferenceDisplaySet","referencedDisplaySetMetadata","image0","images","PatientID","PatientName","PatientSex","PatientAge","SliceThickness","StudyDate","SeriesDescription","SeriesInstanceUID","SeriesNumber","ManufacturerModelName","SpacingBetweenSlices","_getReferencedDisplaySetMetadata","current","displaySet","metadata","onElementDisabled","storePresentationState","useCallback","runCommand","getCornerstoneViewport","component","Component","getModuleEntry","_extends","viewportType","orientation","onElementEnabled","evt","detail","onSegmentChange","direction","segmentationId","displaySetInstanceUID","segmentation","getSegmentation","segments","numberOfSegments","Object","keys","newSelectedSegmentIndex","jumpToSegmentCenter","useEffect","promptHydrateRT","then","unsubscribe","subscribe","EVENTS","SEGMENTATION_LOADING_COMPLETE","overlappingSegments","title","SEGMENT_LOADING_COMPLETE","numSegments","onDisplaySetsRemovedSubscription","DISPLAY_SETS_REMOVED","displaySetInstanceUIDs","activeViewport","includes","setDisplaySetsForViewport","toolGroup","getToolGroup","createRTToolGroupAndAddTools","removeSegmentationRepresentationFromToolGroup","destroyToolGroup","childrenWithProps","map","child","index","setComponents","id","indexPriority","location","LOCATIONS","topLeft","ViewportActionArrows","onArrowsClick","topRight","LoadingIndicatorTotalPercent","totalNumbers","loadingText","propTypes","PropTypes","isRequired","dataSource","customProps","defaultProps"],"sourceRoot":""}