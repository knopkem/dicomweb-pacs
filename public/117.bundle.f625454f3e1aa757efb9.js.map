{"version":3,"file":"117.bundle.f625454f3e1aa757efb9.js","mappings":"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","sources":["webpack:///../../../node_modules/@cornerstonejs/core/src/RenderingEngine/helpers/addImageSlicesToViewports.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/RenderingEngine/helpers/addVolumesToViewports.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/Settings.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/constants/rendering.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/constants/epsilon.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/enums/RequestType.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/enums/ViewportStatus.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/enums/BlendModes.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/enums/GeometryType.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/enums/ContourType.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/enums/DynamicOperatorType.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/enums/CalibrationTypes.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/getEnabledElement.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/loaders/imageLoader.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/loaders/volumeLoader.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/metaData.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/requestPool/imageLoadPoolManager.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/requestPool/requestPoolManager.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/utilities/triggerEvent.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/webWorkerManager/webWorkerManager.js","webpack:///../../../node_modules/@cornerstonejs/tools/src/drawingSvg/getSvgDrawingHelper.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/drawingSvg/draw.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/enums/ToolModes.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/store/ToolGroupManager/ToolGroup.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/store/ToolGroupManager/createToolGroup.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/store/ToolGroupManager/destroy.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/store/ToolGroupManager/destroyToolGroup.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/store/ToolGroupManager/getAllToolGroups.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/store/ToolGroupManager/getToolGroup.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/store/ToolGroupManager/getToolGroupsWithToolName.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/annotation/BidirectionalTool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/annotation/PlanarFreehandROITool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/displayTools/SegmentationDisplayTool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/segmentation/RectangleROIThresholdTool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/segmentation/RectangleROIStartEndThresholdTool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/index.ts","webpack:///../../../node_modules/@kitware/vtk.js/Common/DataModel/ImageData.js","webpack:///../../../node_modules/lodash.get/index.js","webpack:///../../../node_modules/comlink/dist/esm/comlink.mjs","webpack:///../../../node_modules/d3-array/src/bisector.js"],"sourcesContent":["import { StackViewport } from '..';\nimport type {\n  IStackViewport,\n  IStackInput,\n  IRenderingEngine,\n} from '../../types';\n\n/**\n * For each provided viewport it adds a volume to the viewport using the\n * provided renderingEngine\n *\n *\n * @param renderingEngine - The rendering engine to use to get viewports from\n * @param volumeInputs - Array of volume inputs including volumeId. Other properties\n * such as visibility, callback, blendMode, slabThickness are optional\n * @param viewportIds - Array of viewport IDs to add the volume to\n * @param immediateRender - If true, the volumes will be rendered immediately\n * @returns A promise that resolves when all volumes have been added\n */\nasync function addImageSlicesToViewports(\n  renderingEngine: IRenderingEngine,\n  stackInputs: Array<IStackInput>,\n  viewportIds: Array<string>,\n  immediateRender = false,\n  suppressEvents = false\n): Promise<void> {\n  // Check if all viewports are volumeViewports\n  for (const viewportId of viewportIds) {\n    const viewport = renderingEngine.getViewport(viewportId);\n\n    if (!viewport) {\n      throw new Error(`Viewport with Id ${viewportId} does not exist`);\n    }\n\n    // if not instance of BaseVolumeViewport, throw\n    if (!(viewport as IStackViewport).addImages) {\n      console.warn(\n        `Viewport with Id ${viewportId} does not have addImages. Cannot add image segmentation to this viewport.`\n      );\n\n      return;\n    }\n  }\n\n  const addStackPromises = viewportIds.map(async (viewportId) => {\n    const viewport = renderingEngine.getViewport(viewportId) as IStackViewport;\n\n    return viewport.addImages(stackInputs, immediateRender, suppressEvents);\n  });\n\n  await Promise.all(addStackPromises);\n}\n\nexport default addImageSlicesToViewports;\n","import BaseVolumeViewport from '../BaseVolumeViewport';\nimport type {\n  IVolumeViewport,\n  IVolumeInput,\n  IRenderingEngine,\n} from '../../types';\n\n/**\n * For each provided viewport it adds a volume to the viewport using the\n * provided renderingEngine\n *\n *\n * @param renderingEngine - The rendering engine to use to get viewports from\n * @param volumeInputs - Array of volume inputs including volumeId. Other properties\n * such as visibility, callback, blendMode, slabThickness are optional\n * @param viewportIds - Array of viewport IDs to add the volume to\n * @param immediateRender - If true, the volumes will be rendered immediately\n * @returns A promise that resolves when all volumes have been added\n */\nasync function addVolumesToViewports(\n  renderingEngine: IRenderingEngine,\n  volumeInputs: Array<IVolumeInput>,\n  viewportIds: Array<string>,\n  immediateRender = false,\n  suppressEvents = false\n): Promise<void> {\n  // Check if all viewports are volumeViewports\n  for (const viewportId of viewportIds) {\n    const viewport = renderingEngine.getViewport(viewportId);\n\n    if (!viewport) {\n      throw new Error(`Viewport with Id ${viewportId} does not exist`);\n    }\n\n    // if not instance of BaseVolumeViewport, throw\n    if (!(viewport instanceof BaseVolumeViewport)) {\n      console.warn(\n        `Viewport with Id ${viewportId} is not a BaseVolumeViewport. Cannot add volume to this viewport.`\n      );\n\n      return;\n    }\n  }\n\n  const addVolumePromises = viewportIds.map(async (viewportId) => {\n    const viewport = renderingEngine.getViewport(viewportId) as IVolumeViewport;\n\n    await viewport.addVolumes(volumeInputs, immediateRender, suppressEvents);\n  });\n\n  await Promise.all(addVolumePromises);\n  return;\n}\n\nexport default addVolumesToViewports;\n","/*\n * Constants\n */\n\nconst DEFAULT_SETTINGS = Symbol('DefaultSettings');\nconst RUNTIME_SETTINGS = Symbol('RuntimeSettings');\nconst OBJECT_SETTINGS_MAP = Symbol('ObjectSettingsMap');\nconst DICTIONARY = Symbol('Dictionary');\n\n/**\n * Settings\n */\nexport default class Settings {\n  constructor(base?: Settings) {\n    const dictionary = Object.create(\n      (base instanceof Settings && DICTIONARY in base\n        ? base[DICTIONARY]\n        : null) as object\n    );\n    Object.seal(\n      Object.defineProperty(this, DICTIONARY, {\n        value: dictionary,\n      })\n    );\n  }\n\n  set(key: string, value: unknown): boolean {\n    return set(this[DICTIONARY], key, value, null);\n  }\n\n  get(key: string): unknown {\n    return get(this[DICTIONARY], key);\n  }\n\n  /**\n   * Unset a specific key or a set of keys within a namespace when the key ends with a dot (ASCII #46).\n   * If the key is \".\", all keys will be removed and this command works as a reset.\n   * @param key - name The key to be unset or a namespace.\n   * @returns boolean\n   */\n  unset(key: string): boolean {\n    return unset(this[DICTIONARY], key + '');\n  }\n\n  forEach(callback: (key: string, value: unknown) => void): void {\n    iterate(this[DICTIONARY], callback);\n  }\n\n  extend(): Settings {\n    return new Settings(this);\n  }\n\n  /**\n   * Recursively import all properties from the given plain JavaScript object.\n   * This method has the opposite effect of the `dump` method.\n   * @param root - The root object whose properties will\n   * be imported.\n   */\n  import(root: Record<string, unknown>): void {\n    if (isPlainObject(root)) {\n      Object.keys(root).forEach((key) => {\n        set(this[DICTIONARY], key, root[key], null);\n      });\n    }\n  }\n\n  /**\n   * Build a JSON representation of the current internal state of this settings\n   * object. The returned object can be safely passed to `JSON.stringify`\n   * function.\n   * @returns The JSON representation of the current\n   * state of this settings instance\n   */\n  dump(): Record<string, unknown> {\n    const context = {};\n    iterate(this[DICTIONARY], (key, value) => {\n      if (typeof value !== 'undefined') {\n        deepSet(context, key, value);\n      }\n    });\n    return context;\n  }\n\n  static assert(subject: Settings): Settings {\n    return subject instanceof Settings\n      ? subject\n      : Settings.getRuntimeSettings();\n  }\n\n  static getDefaultSettings(subfield = null): Settings | any {\n    let defaultSettings = Settings[DEFAULT_SETTINGS];\n    if (!(defaultSettings instanceof Settings)) {\n      defaultSettings = new Settings();\n      Settings[DEFAULT_SETTINGS] = defaultSettings;\n    }\n\n    // Given subfield of 'segmentation' it will return all settings\n    // that starts with segmentation.*\n    if (subfield) {\n      const settingObj = {};\n      defaultSettings.forEach((name: string) => {\n        if (name.startsWith(subfield)) {\n          const setting = name.split(`${subfield}.`)[1];\n          settingObj[setting] = defaultSettings.get(name);\n        }\n      });\n      return settingObj;\n    }\n\n    return defaultSettings;\n  }\n\n  static getRuntimeSettings(): Settings {\n    let runtimeSettings = Settings[RUNTIME_SETTINGS];\n    if (!(runtimeSettings instanceof Settings)) {\n      runtimeSettings = new Settings(Settings.getDefaultSettings());\n      Settings[RUNTIME_SETTINGS] = runtimeSettings;\n    }\n    return runtimeSettings;\n  }\n\n  static getObjectSettings(subject: unknown, from?: unknown): Settings {\n    let settings = null;\n    if (subject instanceof Settings) {\n      settings = subject;\n    } else if (typeof subject === 'object' && subject !== null) {\n      let objectSettingsMap = Settings[OBJECT_SETTINGS_MAP];\n      if (!(objectSettingsMap instanceof WeakMap)) {\n        objectSettingsMap = new WeakMap();\n        Settings[OBJECT_SETTINGS_MAP] = objectSettingsMap;\n      }\n      settings = objectSettingsMap.get(subject);\n      if (!(settings instanceof Settings)) {\n        settings = new Settings(\n          Settings.assert(Settings.getObjectSettings(from))\n        );\n        objectSettingsMap.set(subject, settings);\n      }\n    }\n    return settings;\n  }\n\n  static extendRuntimeSettings(): Settings {\n    return Settings.getRuntimeSettings().extend();\n  }\n}\n\n/*\n * Local Helpers\n */\n\nfunction unset(dictionary: Record<string, unknown>, name: string): boolean {\n  if (name.endsWith('.')) {\n    let deleteCount = 0;\n    const namespace = name;\n    const base = namespace.slice(0, -1);\n    const deleteAll = base.length === 0;\n    for (const key in dictionary) {\n      if (\n        Object.prototype.hasOwnProperty.call(dictionary, key) &&\n        (deleteAll || key.startsWith(namespace) || key === base)\n      ) {\n        delete dictionary[key];\n        ++deleteCount;\n      }\n    }\n    return deleteCount > 0;\n  }\n  return delete dictionary[name];\n}\n\nfunction iterate(\n  dictionary: Record<string, unknown>,\n  callback: (key: string, value: unknown) => void\n): void {\n  for (const key in dictionary) {\n    callback(key, dictionary[key]);\n  }\n}\n\nfunction setAll(\n  dictionary: Record<string, unknown>,\n  prefix: string,\n  record: Record<string, unknown>,\n  references: WeakSet<Record<string, unknown>>\n): boolean {\n  let failCount: number;\n  if (references.has(record)) {\n    return set(dictionary, prefix, null, references);\n  }\n  references.add(record);\n  failCount = 0;\n  for (const field in record) {\n    if (Object.prototype.hasOwnProperty.call(record, field)) {\n      const key = field.length === 0 ? prefix : `${prefix}.${field}`;\n      if (!set(dictionary, key, record[field], references)) {\n        ++failCount;\n      }\n    }\n  }\n  references.delete(record);\n  return failCount === 0;\n}\n\n/**\n * Set the key-value pair on a given dictionary. If the given value is a\n * plain javascript object, every property of that object will also be set.\n * @param dictionary {Record<string, unknown>} The target dictionary\n * @param key {string} The given key\n * @param value {unknown} The given value\n * @param references {WeakSet<Record<string, unknown>>} references is a WeakSet\n *  instance used to keep track of which objects have already been iterated\n *  through preventing thus possible stack overflows caused by cyclic references\n * @returns {boolean} Returns true if every given key-value pair has been\n * successfully set\n */\nfunction set(\n  dictionary: Record<string, unknown>,\n  key: string,\n  value: unknown,\n  references: WeakSet<Record<string, unknown>>\n): boolean {\n  if (isValidKey(key)) {\n    if (isPlainObject(value)) {\n      return setAll(\n        dictionary,\n        key,\n        value as Record<string, unknown>,\n        references instanceof WeakSet ? references : new WeakSet()\n      );\n    }\n    dictionary[key] = value;\n    return true;\n  }\n  return false;\n}\n\nfunction get(dictionary: Record<string, unknown>, key: string): unknown {\n  return dictionary[key];\n}\n\n/**\n * Make sure the -provided key correctly formatted.\n * e.g.:\n *  \"my.cool.property\" (valid)\n *  \"my.cool.property.\" (invalid)\n *  \".my.cool.property\" (invalid)\n *  \"my.cool..property\" (invalid)\n * @param key {string} The property name to be used as key within the internal\n *  dictionary\n * @returns {boolean} True on success, false otherwise\n */\nfunction isValidKey(key: string): boolean {\n  let last: number, current: number, previous: number;\n  if (typeof key !== 'string' || (last = key.length - 1) < 0) {\n    return false;\n  }\n  previous = -1;\n  while ((current = key.indexOf('.', previous + 1)) >= 0) {\n    if (current - previous < 2 || current === last) {\n      return false;\n    }\n    previous = current;\n  }\n  return true;\n}\n\nfunction isPlainObject(subject: unknown) {\n  if (typeof subject === 'object' && subject !== null) {\n    const prototype = Object.getPrototypeOf(subject);\n    if (prototype === Object.prototype || prototype === null) {\n      return true;\n    }\n  }\n  return false;\n}\n\nfunction deepSet(context, key, value) {\n  const separator = key.indexOf('.');\n  if (separator >= 0) {\n    const subKey = key.slice(0, separator);\n    let subContext = context[subKey];\n    if (typeof subContext !== 'object' || subContext === null) {\n      const subContextValue = subContext;\n      subContext = {};\n      if (typeof subContextValue !== 'undefined') {\n        subContext[''] = subContextValue;\n      }\n      context[subKey] = subContext;\n    }\n    deepSet(subContext, key.slice(separator + 1, key.length), value);\n  } else {\n    context[key] = value;\n  }\n}\n\n/**\n * Initial Settings for the repository\n */\nSettings.getDefaultSettings().set('useCursors', true);\n","const RENDERING_DEFAULTS = {\n  MINIMUM_SLAB_THICKNESS: 5e-2,\n  MAXIMUM_RAY_DISTANCE: 1e6,\n};\n\nObject.freeze(RENDERING_DEFAULTS);\n\nexport default RENDERING_DEFAULTS;\n","const EPSILON = 1e-3;\n\nexport default EPSILON;\n","/**\n * Request types for requesting images from the imageLoadPoolManager\n */\nenum RequestType {\n  /** Highest priority for loading*/\n  Interaction = 'interaction',\n  /** Second highest priority for loading*/\n  Thumbnail = 'thumbnail',\n  /** Third highest priority for loading, usually used for image loading in the background*/\n  Prefetch = 'prefetch',\n  /** Lower priority, often used for background computations in the worker */\n  Compute = 'compute',\n}\n\nexport default RequestType;\n","enum ViewportStatus {\n  /** Initial state before any volumes or stacks are available*/\n  NO_DATA = 'noData',\n  /** Stack/volumes are available but are in progress */\n  LOADING = 'loading',\n  /** Ready to be rendered */\n  PRE_RENDER = 'preRender',\n  /** In the midst of a resize */\n  RESIZE = 'resize',\n  /** Rendered image data */\n  RENDERED = 'rendered',\n}\n\nexport default ViewportStatus;\n","import vtkConstants from '@kitware/vtk.js/Rendering/Core/VolumeMapper/Constants';\n\nconst { BlendMode } = vtkConstants;\n\n/**\n * Enums for blendModes for viewport images based on vtk.js\n *\n * It should be noted that if crosshairs are enabled and can modify the slab thickness,\n * then it will not show any difference unless MAXIMUM_INTENSITY_BLEND is set on the viewport\n * as the blend.\n */\nenum BlendModes {\n  /** composite blending - suitable for compositing multiple images */\n  COMPOSITE = BlendMode.COMPOSITE_BLEND,\n  /** maximum intensity projection */\n  MAXIMUM_INTENSITY_BLEND = BlendMode.MAXIMUM_INTENSITY_BLEND,\n  /** minimum intensity projection */\n  MINIMUM_INTENSITY_BLEND = BlendMode.MINIMUM_INTENSITY_BLEND,\n  /** average intensity projection */\n  AVERAGE_INTENSITY_BLEND = BlendMode.AVERAGE_INTENSITY_BLEND,\n}\n\nexport default BlendModes;\n","enum GeometryType {\n  CONTOUR = 'contour',\n  SURFACE = 'Surface',\n}\n\nexport default GeometryType;\n","enum ContourType {\n  CLOSED_PLANAR = 'CLOSED_PLANAR',\n  OPEN_PLANAR = 'OPEN_PLANAR',\n}\n\nexport default ContourType;\n","/**\n * DynamicOperatorType enum for cornerstone-render which defines the operator to use for generateImageFromTimeData.\n * It can be either SUM, AVERAGE or SUBTRACT.\n */\nenum DynamicOperatorType {\n  /** For summing the time frames. */\n  SUM = 'SUM',\n  /** For averaging the time frames. */\n  AVERAGE = 'AVERAGE',\n  /** For subtracting two time frames */\n  SUBTRACT = 'SUBTRACT',\n}\n\nexport default DynamicOperatorType;\n","/**\n * Defines the calibration types available.  These define how the units\n * for measurements are specified.\n */\nexport enum CalibrationTypes {\n  /**\n   * Not applicable means the units are directly defind by the underlying\n   * hardware, such as CT and MR volumetric displays, so no special handling\n   * or notification is required.\n   */\n  NOT_APPLICABLE = '',\n  /**\n   * ERMF is estimated radiographic magnification factor.  This defines how\n   * much the image is magnified at the detector as opposed to the location in\n   * the body of interest.  This occurs because the radiation beam is expanding\n   * and effectively magnifies the image on the detector compared to where the\n   * point of interest in the body is.\n   * This suggests that measurements can be partially trusted, but the user\n   * still needs to be aware that different depths within the body have differing\n   * ERMF values, so precise measurements would still need to be manually calibrated.\n   */\n  ERMF = 'ERMF',\n  /**\n   * User calibration means that the user has provided a custom calibration\n   * specifying how large the image data is.  This type can occur on\n   * volumetric images, eg for scout images that might have invalid spacing\n   * tags.\n   */\n  USER = 'User',\n  /**\n   * A projection calibration means the raw detector size, without any\n   * ERMF applied, meaning that the size in the body cannot be trusted and\n   * that a calibration should be applied.\n   * This is different from Error in that there is simply no magnification\n   * factor applied as opposed to having multiple, inconsistent magnification\n   * factors.\n   */\n  PROJECTION = 'Proj',\n  /**\n   * A region calibration is used for other types of images, typically\n   * ultrasouunds where the distance in the image may mean something other than\n   * physical distance, such as mV or Hz or some other measurement values.\n   */\n  REGION = 'Region',\n  /**\n   * Error is used to define mismatches between various units, such as when\n   * there are two different ERMF values specified.  This is an indication to\n   * NOT trust the measurement values but to manually calibrate.\n   */\n  ERROR = 'Error',\n  /** Uncalibrated image */\n  UNCALIBRATED = 'Uncalibrated',\n}\n\nexport default CalibrationTypes;\n","import getRenderingEngine, {\n  getRenderingEngines,\n} from './RenderingEngine/getRenderingEngine';\nimport { IEnabledElement, IStackViewport, IVolumeViewport } from './types';\n\n/**\n * A convenience method to find an EnabledElement given a reference to its\n * associated element. Commonly used in code that's handling a custom\n * event emitted by this library.\n *\n * @example\n * Using the renderingEngine to find the enabled element:\n * ```javascript\n * const element = getRenderingEngine(renderingEngineId)\n *    .getViewport(viewportId)\n *    .element\n *\n * const enabledElement = getEnabledElement(element)\n * ```\n *\n * @example\n * Using a cornerstone event's \"element\"\n * ```javascript\n * // Our \"cornerstone events\" contain the source element, which is\n * // raised on the viewport's div element\n * const { element } = evt.detail\n * const enabledElement = getEnabledElement(element)\n * ```\n *\n * @param element - a reference to an EnabledElement/Viewport's div element\n * @returns the associated EnabledElement, or undefined if no matching EnabledElement\n * can be found\n */\nexport default function getEnabledElement(\n  element: HTMLDivElement | undefined\n): IEnabledElement | undefined {\n  if (!element) {\n    return;\n  }\n\n  const { viewportUid, renderingEngineUid } = element.dataset;\n\n  return getEnabledElementByIds(viewportUid, renderingEngineUid);\n}\n\n/**\n * Similar to {@link getEnabledElement}, but takes the IDs of the\n * renderingEngine and viewport as parameters to return the associated\n * EnabledElement.\n *\n * @param viewportId - The Id of the viewport\n * @param renderingEngineId - The Id of the rendering engine.\n * @returns The enabled element which is an object that contains the viewport, rendering\n * engine, viewport Id, rendering engine Id, and the Frame of Reference UID.\n */\nexport function getEnabledElementByIds(\n  viewportId: string,\n  renderingEngineId: string\n): IEnabledElement {\n  if (!renderingEngineId || !viewportId) {\n    return;\n  }\n\n  const renderingEngine = getRenderingEngine(renderingEngineId);\n\n  if (!renderingEngine || renderingEngine.hasBeenDestroyed) {\n    return;\n  }\n\n  const viewport = renderingEngine.getViewport(viewportId) as\n    | IStackViewport\n    | IVolumeViewport;\n\n  if (!viewport) {\n    return;\n  }\n\n  const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n\n  return {\n    viewport,\n    renderingEngine,\n    viewportId,\n    renderingEngineId,\n    FrameOfReferenceUID,\n  };\n}\n\n/**\n * Retrieves the enabled element by the specified viewport ID. it searches\n * through all the rendering engines to find the viewport with the specified\n *\n * @param viewportId - The ID of the viewport.\n * @returns The enabled element associated with the specified viewport ID.\n */\nexport function getEnabledElementByViewportId(viewportId: string) {\n  const renderingEngines = getRenderingEngines();\n\n  for (let i = 0; i < renderingEngines.length; i++) {\n    const renderingEngine = renderingEngines[i];\n    const viewport = renderingEngine.getViewport(viewportId);\n\n    if (viewport) {\n      return getEnabledElementByIds(viewportId, renderingEngine.id);\n    }\n  }\n}\n\n/**\n * Get all the enabled elements from all the rendering engines\n * @returns An array of enabled elements.\n */\nexport function getEnabledElements(): IEnabledElement[] {\n  const enabledElements = [];\n\n  const renderingEngines = getRenderingEngines();\n\n  renderingEngines.forEach((renderingEngine) => {\n    const viewports = renderingEngine.getViewports();\n\n    viewports.forEach(({ element }) => {\n      enabledElements.push(getEnabledElement(element));\n    });\n  });\n\n  return enabledElements;\n}\n","import cache from '../cache/cache';\nimport { ImageVolume } from '../cache';\nimport Events from '../enums/Events';\nimport eventTarget from '../eventTarget';\nimport {\n  genericMetadataProvider,\n  getBufferConfiguration,\n  triggerEvent,\n  uuidv4,\n} from '../utilities';\nimport {\n  IImage,\n  ImageLoaderFn,\n  IImageLoadObject,\n  EventTypes,\n  Point2,\n  Point3,\n  Mat3,\n  PixelDataTypedArrayString,\n  PixelDataTypedArray,\n} from '../types';\nimport imageLoadPoolManager from '../requestPool/imageLoadPoolManager';\nimport { metaData } from '../';\n\nexport interface ImageLoaderOptions {\n  priority: number;\n  requestType: string;\n  additionalDetails?: Record<string, unknown>;\n  ignoreCache?: boolean;\n}\n\ninterface DerivedImages {\n  imageIds: Array<string>;\n  promises: Array<Promise<IImage>>;\n}\n\ntype LocalImageOptions = {\n  scalarData?: PixelDataTypedArray;\n  targetBufferType?: PixelDataTypedArrayString;\n  dimensions?: Point2;\n  spacing?: Point3;\n  origin?: Point3;\n  direction?: Mat3;\n  /**\n   * Skip creation of the actual buffer object.\n   * In fact, this creates a very short buffer, as there are lots of places\n   * assuming a buffer exists.\n   * This can be used when there are alternative representations of the image data.\n   */\n  skipCreateBuffer?: boolean;\n  /**\n   * A method to call to update the image object when it gets added to the cache.\n   * This can be used to create alternative representations of the image data,\n   * such as a VoxelManager.\n   */\n  onCacheAdd?: (image: IImage) => void;\n};\n\ntype DerivedImageOptions = LocalImageOptions & {\n  imageId?: string;\n  targetBufferType?: PixelDataTypedArrayString;\n};\n\n/**\n * This module deals with ImageLoaders, loading images and caching images\n */\nconst imageLoaders = {};\nlet unknownImageLoader;\n\n/**\n * Loads an image using a registered Cornerstone Image Loader.\n *\n * The image loader that is used will be\n * determined by the image loader scheme matching against the imageId.\n *\n * @param imageId - A Cornerstone Image Object's imageId\n * @param Options - to be passed to the Image Loader\n *\n * @returns - An Object which can be used to act after an image is loaded or loading fails\n */\nfunction loadImageFromImageLoader(\n  imageId: string,\n  options: ImageLoaderOptions\n): IImageLoadObject {\n  // Extract the image loader scheme: wadors:https://image1 => wadors\n  const colonIndex = imageId.indexOf(':');\n  const scheme = imageId.substring(0, colonIndex);\n  const loader = imageLoaders[scheme];\n  if (loader === undefined || loader === null) {\n    if (unknownImageLoader !== undefined) {\n      return unknownImageLoader(imageId);\n    }\n    throw new Error('loadImageFromImageLoader: no image loader for imageId');\n  }\n  // Load using the registered loader\n  const imageLoadObject = loader(imageId, options);\n  // Broadcast an image loaded event once the image is loaded\n  imageLoadObject.promise.then(\n    function (image) {\n      triggerEvent(eventTarget, Events.IMAGE_LOADED, { image });\n    },\n    function (error) {\n      const errorObject: EventTypes.ImageLoadedFailedEventDetail = {\n        imageId,\n        error,\n      };\n      triggerEvent(eventTarget, Events.IMAGE_LOAD_FAILED, errorObject);\n    }\n  );\n  return imageLoadObject;\n}\n\n/**\n * Gets the imageLoadObject by 1) Looking in to the cache to see if the\n * imageLoadObject has already been cached, 2) Checks inside the volume cache\n * to see if there is a volume that contains the same imageURI for the requested\n * imageID 3) Checks inside the imageCache for similar imageURI that might have\n * been stored as a result of decaching a volume 4) Finally if none were found\n * it request it from the registered imageLoaders.\n *\n * @param imageId - A Cornerstone Image Object's imageId\n * @param options - Options to be passed to the Image Loader\n *\n * @returns An Object which can be used to act after an image is loaded or loading fails\n */\nfunction loadImageFromCacheOrVolume(\n  imageId: string,\n  options: ImageLoaderOptions\n): IImageLoadObject {\n  if (options.ignoreCache) {\n    return loadImageFromImageLoader(imageId, options);\n  }\n\n  // 1. Check inside the image cache for imageId\n  let imageLoadObject = cache.getImageLoadObject(imageId);\n  if (imageLoadObject !== undefined) {\n    return imageLoadObject;\n  }\n  // 2. Check if there exists a volume in the cache containing the imageId,\n  // we copy the pixelData over.\n  const cachedVolumeInfo = cache.getVolumeContainingImageId(imageId);\n  if (cachedVolumeInfo?.volume?.loadStatus?.loaded) {\n    // 2.1 Convert the volume at the specific slice to a cornerstoneImage object.\n    // this will copy the pixel data over.\n    const { volume, imageIdIndex } = cachedVolumeInfo;\n\n    if (volume instanceof ImageVolume) {\n      imageLoadObject = volume.convertToCornerstoneImage(imageId, imageIdIndex);\n    }\n    return imageLoadObject;\n  }\n  // 3. If no volume found, we search inside the imageCache for the imageId\n  // that has the same URI which had been cached if the volume was converted\n  // to an image\n  const cachedImage = cache.getCachedImageBasedOnImageURI(imageId);\n  if (cachedImage) {\n    imageLoadObject = cachedImage.imageLoadObject;\n    return imageLoadObject;\n  }\n  // 4. if not in image cache nor inside the volume cache, we request the\n  // image loaders to load it\n  imageLoadObject = loadImageFromImageLoader(imageId, options);\n\n  return imageLoadObject;\n}\n\n/**\n * Loads an image given an imageId and optional priority and returns a promise\n * which will resolve to the loaded image object or fail if an error occurred.\n * The loaded image is not stored in the cache.\n *\n *\n * @param imageId - A Cornerstone Image Object's imageId\n * @param options - Options to be passed to the Image Loader\n *\n * @returns An Object which can be used to act after an image is loaded or loading fails\n */\nexport function loadImage(\n  imageId: string,\n  options: ImageLoaderOptions = { priority: 0, requestType: 'prefetch' }\n): Promise<IImage> {\n  if (imageId === undefined) {\n    throw new Error('loadImage: parameter imageId must not be undefined');\n  }\n\n  return loadImageFromCacheOrVolume(imageId, options).promise;\n}\n\n/**\n * Loads an image given an imageId and optional priority and returns a promise\n * which will resolve to the loaded image object or fail if an error occurred.\n * The image is stored in the cache.\n *\n * @param imageId -  A Cornerstone Image Object's imageId\n * @param options - Options to be passed to the Image Loader\n *\n * @returns Image Loader Object\n */\nexport function loadAndCacheImage(\n  imageId: string,\n  options: ImageLoaderOptions = { priority: 0, requestType: 'prefetch' }\n): Promise<IImage> {\n  if (imageId === undefined) {\n    throw new Error(\n      'loadAndCacheImage: parameter imageId must not be undefined'\n    );\n  }\n  const imageLoadObject = loadImageFromCacheOrVolume(imageId, options);\n\n  // if not inside cache, store it\n  if (!cache.getImageLoadObject(imageId)) {\n    cache.putImageLoadObject(imageId, imageLoadObject).catch((err) => {\n      console.warn(err);\n    });\n  }\n\n  return imageLoadObject.promise;\n}\n\n/**\n * Load and cache a list of imageIds\n *\n * @param imageIds - list of imageIds\n * @param options - options for loader\n *\n */\nexport function loadAndCacheImages(\n  imageIds: Array<string>,\n  options: ImageLoaderOptions = { priority: 0, requestType: 'prefetch' }\n): Promise<IImage>[] {\n  if (!imageIds || imageIds.length === 0) {\n    throw new Error(\n      'loadAndCacheImages: parameter imageIds must be list of image Ids'\n    );\n  }\n\n  const allPromises = imageIds.map((imageId) => {\n    return loadAndCacheImage(imageId, options);\n  });\n\n  return allPromises;\n}\n\n/**\n * Loads an image given an imageId and optional priority and returns a promise\n * which will resolve to the loaded image object or fail if an error occurred.\n * The image is stored in the cache.\n *\n * @param referencedImageId -  A Cornerstone Image Object's imageId\n * @param options - Options to be passed to the Image Loader\n *\n * @returns Image Loader Object\n */\nexport function createAndCacheDerivedImage(\n  referencedImageId: string,\n  options: DerivedImageOptions = {},\n  preventCache = false\n): Promise<IImage> {\n  if (referencedImageId === undefined) {\n    throw new Error(\n      'createAndCacheDerivedImage: parameter imageId must not be undefined'\n    );\n  }\n\n  if (options.imageId === undefined) {\n    options.imageId = `derived:${uuidv4()}`;\n  }\n\n  const { imageId, skipCreateBuffer, onCacheAdd } = options;\n\n  const imagePlaneModule = metaData.get('imagePlaneModule', referencedImageId);\n\n  const length = imagePlaneModule.rows * imagePlaneModule.columns;\n\n  const { TypedArrayConstructor } = getBufferConfiguration(\n    options.targetBufferType,\n    length\n  );\n\n  // Use a buffer of size 1 for no data\n  const imageScalarData = new TypedArrayConstructor(\n    skipCreateBuffer ? 1 : length\n  );\n  const derivedImageId = imageId;\n\n  ['imagePixelModule', 'imagePlaneModule', 'generalSeriesModule'].forEach(\n    (type) => {\n      genericMetadataProvider.add(derivedImageId, {\n        type,\n        metadata: metaData.get(type, referencedImageId),\n      });\n    }\n  );\n\n  const localImage = createAndCacheLocalImage(\n    { scalarData: imageScalarData, onCacheAdd, skipCreateBuffer },\n    imageId,\n    true\n  );\n\n  const imageLoadObject = {\n    promise: Promise.resolve(localImage),\n  };\n\n  if (!preventCache) {\n    cache.putImageLoadObject(derivedImageId, imageLoadObject);\n  }\n  return imageLoadObject.promise;\n}\n\n/**\n * Load and cache a list of imageIds\n *\n * @param referencedImageIds - list of imageIds\n * @param options\n * @param options.getDerivedImageId - function to get the derived imageId\n * @param options.targetBufferType - target buffer type\n * @param options.skipBufferCreate - avoid creating the buffer\n */\nexport function createAndCacheDerivedImages(\n  referencedImageIds: Array<string>,\n  options: DerivedImageOptions & {\n    getDerivedImageId?: (referencedImageId: string) => string;\n    targetBufferType?: PixelDataTypedArrayString;\n  } = {}\n): DerivedImages {\n  if (referencedImageIds?.length === 0) {\n    throw new Error(\n      'createAndCacheDerivedImages: parameter imageIds must be list of image Ids'\n    );\n  }\n\n  const derivedImageIds = [];\n  const allPromises = referencedImageIds.map((referencedImageId) => {\n    const newOptions: DerivedImageOptions = {\n      imageId:\n        options.getDerivedImageId?.(referencedImageId) || `derived:${uuidv4()}`,\n      ...options,\n    };\n    derivedImageIds.push(newOptions.imageId);\n    return createAndCacheDerivedImage(referencedImageId, newOptions);\n  });\n\n  return { imageIds: derivedImageIds, promises: allPromises };\n}\n\nexport function createAndCacheLocalImage(\n  options: LocalImageOptions,\n  imageId: string,\n  preventCache = false\n): IImage {\n  const imagePlaneModule = metaData.get('imagePlaneModule', imageId);\n\n  const length = imagePlaneModule.rows * imagePlaneModule.columns;\n\n  const image = {\n    imageId: imageId,\n    intercept: 0,\n    windowCenter: 0,\n    windowWidth: 0,\n    color: false,\n    numComps: 1,\n    slope: 1,\n    minPixelValue: 0,\n    maxPixelValue: 255,\n    voiLUTFunction: undefined,\n    rows: imagePlaneModule.rows,\n    columns: imagePlaneModule.columns,\n    getCanvas: undefined, // todo: which canvas?\n    height: imagePlaneModule.rows,\n    width: imagePlaneModule.columns,\n    rgba: undefined, // todo: how\n    columnPixelSpacing: imagePlaneModule.columnPixelSpacing,\n    rowPixelSpacing: imagePlaneModule.rowPixelSpacing,\n    invert: false,\n  } as IImage;\n\n  if (options.scalarData) {\n    const imageScalarData = options.scalarData;\n\n    if (\n      !(\n        imageScalarData instanceof Uint8Array ||\n        imageScalarData instanceof Float32Array ||\n        imageScalarData instanceof Uint16Array ||\n        imageScalarData instanceof Int16Array\n      )\n    ) {\n      throw new Error(\n        'To use createLocalVolume you should pass scalarData of type Uint8Array, Uint16Array, Int16Array or Float32Array'\n      );\n    }\n\n    image.sizeInBytes = imageScalarData.byteLength;\n    image.getPixelData = () => imageScalarData;\n  } else if (options.skipCreateBuffer !== true) {\n    const { numBytes, TypedArrayConstructor } = getBufferConfiguration(\n      options.targetBufferType,\n      length\n    );\n\n    const imageScalarData = new TypedArrayConstructor(length);\n\n    image.sizeInBytes = numBytes;\n    image.getPixelData = () => imageScalarData;\n  }\n\n  // The onCacheAdd may modify the size in bytes for this image, which is ok,\n  // as this is used after resolution for cache storage.  It may also do\n  // thinks like adding alternative representations such as VoxelManager\n  options.onCacheAdd?.(image);\n\n  const imageLoadObject = {\n    promise: Promise.resolve(image),\n  };\n\n  if (!preventCache) {\n    cache.putImageLoadObject(image.imageId, imageLoadObject);\n  }\n\n  return image;\n}\n\n/**\n * Removes the imageId from the request pool manager and executes the `cancel`\n * function if it exists.\n *\n * @param imageId - A Cornerstone Image Object's imageId\n *\n */\nexport function cancelLoadImage(imageId: string): void {\n  const filterFunction = ({ additionalDetails }) => {\n    if (additionalDetails.imageId) {\n      return additionalDetails.imageId !== imageId;\n    }\n\n    // for volumes\n    return true;\n  };\n\n  // Instruct the request pool manager to filter queued\n  // requests to ensure requests we no longer need are\n  // no longer sent.\n  imageLoadPoolManager.filterRequests(filterFunction);\n\n  // TODO: Cancel decoding and retrieval as well (somehow?)\n\n  // cancel image loading if in progress\n  const imageLoadObject = cache.getImageLoadObject(imageId);\n\n  if (imageLoadObject) {\n    imageLoadObject.cancelFn();\n  }\n}\n\n/**\n * Removes the imageIds from the request pool manager and calls the `cancel`\n * function if it exists.\n *\n * @param imageIds - Array of Cornerstone Image Object's imageIds\n *\n */\nexport function cancelLoadImages(imageIds: Array<string>): void {\n  imageIds.forEach((imageId) => cancelLoadImage(imageId));\n}\n\n/**\n * Removes all the ongoing image loads by calling the `cancel` method on each\n * imageLoadObject. If no `cancel` method is available, it will be ignored.\n *\n */\nexport function cancelLoadAll(): void {\n  const requestPool = imageLoadPoolManager.getRequestPool();\n\n  Object.keys(requestPool).forEach((type: string) => {\n    const requests = requestPool[type];\n\n    Object.keys(requests).forEach((priority) => {\n      const requestDetails = requests[priority].pop();\n      const additionalDetails = requestDetails.additionalDetails as any;\n      const { imageId, volumeId } = additionalDetails;\n\n      let loadObject;\n\n      if (imageId) {\n        loadObject = cache.getImageLoadObject(imageId);\n      } else if (volumeId) {\n        loadObject = cache.getVolumeLoadObject(volumeId);\n      }\n      if (loadObject) {\n        loadObject.cancel();\n      }\n    });\n    // resetting the pool types to be empty\n    imageLoadPoolManager.clearRequestStack(type);\n\n    // TODO: Clear retrieval and decoding queues as well\n  });\n}\n\n/**\n * Registers an imageLoader plugin with cornerstone for the specified scheme\n *\n * @param scheme - The scheme to use for this image loader (e.g. 'dicomweb', 'wadouri', 'http')\n * @param imageLoader - A Cornerstone Image Loader function\n */\nexport function registerImageLoader(\n  scheme: string,\n  imageLoader: ImageLoaderFn\n): void {\n  imageLoaders[scheme] = imageLoader;\n}\n/**\n * Registers a new unknownImageLoader and returns the previous one\n *\n * @param imageLoader - A Cornerstone Image Loader\n *\n * @returns The previous Unknown Image Loader\n */\nexport function registerUnknownImageLoader(\n  imageLoader: ImageLoaderFn\n): ImageLoaderFn {\n  const oldImageLoader = unknownImageLoader;\n  unknownImageLoader = imageLoader;\n  return oldImageLoader;\n}\n/**\n * Removes all registered and unknown image loaders. This should be called\n * when the application is unmounted to prevent memory leaks.\n *\n */\nexport function unregisterAllImageLoaders(): void {\n  Object.keys(imageLoaders).forEach(\n    (imageLoader) => delete imageLoaders[imageLoader]\n  );\n  unknownImageLoader = undefined;\n}\n\n/**\n * Creates and caches derived segmentation images based on the referenced imageIds, this\n * is a helper function, we don't have segmentation concept in the cornerstone core; however,\n * this helper would make it clear that the segmentation images SHOULD be Uint8Array type\n * always until we have a better solution.\n *\n * @param referencedImageIds - An array of referenced image IDs.\n * @param options - The options for creating the derived images (default: { targetBufferType: 'Uint8Array' }).\n * @returns The derived images.\n */\nexport function createAndCacheDerivedSegmentationImages(\n  referencedImageIds: Array<string>,\n  options: DerivedImageOptions = {\n    targetBufferType: 'Uint8Array',\n  }\n): DerivedImages {\n  return createAndCacheDerivedImages(referencedImageIds, options);\n}\n\n/**\n * Creates and caches a derived segmentation image based on the referenced image ID.\n * this is a helper function, we don't have segmentation concept in the cornerstone core; however,\n * this helper would make it clear that the segmentation images SHOULD be Uint8Array type\n * always until we have a better solution.\n *\n * @param referencedImageId The ID of the referenced image.\n * @param options The options for creating the derived image (default: { targetBufferType: 'Uint8Array' }).\n * @returns A promise that resolves to the created derived segmentation image.\n */\nexport function createAndCacheDerivedSegmentationImage(\n  referencedImageId: string,\n  options: DerivedImageOptions = {\n    targetBufferType: 'Uint8Array',\n  }\n): Promise<IImage> {\n  return createAndCacheDerivedImage(referencedImageId, options);\n}\n","import '@kitware/vtk.js/Rendering/Profiles/Volume';\n\nimport vtkImageData from '@kitware/vtk.js/Common/DataModel/ImageData';\nimport type { vtkImageData as vtkImageDataType } from '@kitware/vtk.js/Common/DataModel/ImageData';\nimport vtkDataArray from '@kitware/vtk.js/Common/Core/DataArray';\n\nimport { ImageVolume } from '../cache/classes/ImageVolume';\nimport cache from '../cache/cache';\nimport Events from '../enums/Events';\nimport eventTarget from '../eventTarget';\nimport triggerEvent from '../utilities/triggerEvent';\nimport cloneDeep from 'lodash.clonedeep';\n\nimport {\n  generateVolumePropsFromImageIds,\n  getBufferConfiguration,\n  uuidv4,\n} from '../utilities';\nimport {\n  Point3,\n  Metadata,\n  EventTypes,\n  Mat3,\n  IImageVolume,\n  VolumeLoaderFn,\n  IDynamicImageVolume,\n  PixelDataTypedArray,\n  IVolumeLoadObject,\n  PixelDataTypedArrayString,\n} from '../types';\nimport { getConfiguration } from '../init';\nimport {\n  performCacheOptimizationForVolume,\n  setupCacheOptimizationEventListener,\n} from '../utilities/cacheUtils';\n\ninterface VolumeLoaderOptions {\n  imageIds: Array<string>;\n}\n\ninterface DerivedVolumeOptions {\n  volumeId: string;\n  targetBuffer?: {\n    type: PixelDataTypedArrayString;\n    sharedArrayBuffer?: boolean;\n  };\n}\ninterface LocalVolumeOptions {\n  metadata: Metadata;\n  dimensions: Point3;\n  spacing: Point3;\n  origin: Point3;\n  direction: Mat3;\n  scalarData?: PixelDataTypedArray;\n  imageIds?: Array<string>;\n  referencedImageIds?: Array<string>;\n  referencedVolumeId?: string;\n  targetBuffer?: {\n    type: PixelDataTypedArrayString;\n    sharedArrayBuffer?: boolean;\n  };\n}\n\n/**\n * Adds a single scalar data to a 3D volume\n */\nfunction addScalarDataToImageData(\n  imageData: vtkImageDataType,\n  scalarData: PixelDataTypedArray,\n  dataArrayAttrs\n) {\n  const scalarArray = vtkDataArray.newInstance({\n    name: `Pixels`,\n    values: scalarData,\n    ...dataArrayAttrs,\n  });\n\n  imageData.getPointData().setScalars(scalarArray);\n}\n\n/**\n * Adds multiple scalar data (time points) to a 4D volume\n */\nfunction addScalarDataArraysToImageData(\n  imageData: vtkImageDataType,\n  scalarDataArrays: PixelDataTypedArray[],\n  dataArrayAttrs\n) {\n  scalarDataArrays.forEach((scalarData, i) => {\n    const vtkScalarArray = vtkDataArray.newInstance({\n      name: `timePoint-${i}`,\n      values: scalarData,\n      ...dataArrayAttrs,\n    });\n\n    imageData.getPointData().addArray(vtkScalarArray);\n  });\n\n  // Set the first as active otherwise nothing is displayed on the screen\n  imageData.getPointData().setActiveScalars('timePoint-0');\n}\n\nfunction createInternalVTKRepresentation(\n  volume: IImageVolume\n): vtkImageDataType {\n  const { dimensions, metadata, spacing, direction, origin } = volume;\n  const { PhotometricInterpretation } = metadata;\n\n  let numComponents = 1;\n  if (PhotometricInterpretation === 'RGB') {\n    numComponents = 3;\n  }\n\n  const imageData = vtkImageData.newInstance();\n  const dataArrayAttrs = { numberOfComponents: numComponents };\n\n  imageData.setDimensions(dimensions);\n  imageData.setSpacing(spacing);\n  imageData.setDirection(direction);\n  imageData.setOrigin(origin);\n\n  // Add scalar data to 3D or 4D volume\n  if (volume.isDynamicVolume()) {\n    const scalarDataArrays = (<IDynamicImageVolume>(\n      volume\n    )).getScalarDataArrays();\n\n    addScalarDataArraysToImageData(imageData, scalarDataArrays, dataArrayAttrs);\n  } else {\n    const scalarData = volume.getScalarData();\n\n    addScalarDataToImageData(imageData, scalarData, dataArrayAttrs);\n  }\n\n  return imageData;\n}\n\n/**\n * This module deals with VolumeLoaders and loading volumes\n */\n\nconst volumeLoaders = {};\n\nlet unknownVolumeLoader;\n\n/**\n * Load a volume using a registered Cornerstone Volume Loader.\n *\n * The volume loader that is used will be\n * determined by the volume loader scheme matching against the volumeId.\n *\n * @param volumeId - A Cornerstone Volume Object's volumeId\n * @param options - Options to be passed to the Volume Loader. Options\n * contain the ImageIds that is passed to the loader\n *\n * @returns An Object which can be used to act after a volume is loaded or loading fails\n *\n */\nfunction loadVolumeFromVolumeLoader(\n  volumeId: string,\n  options?: VolumeLoaderOptions\n): IVolumeLoadObject {\n  const colonIndex = volumeId.indexOf(':');\n  const scheme = volumeId.substring(0, colonIndex);\n  let loader = volumeLoaders[scheme];\n\n  if (loader === undefined || loader === null) {\n    if (\n      unknownVolumeLoader == null ||\n      typeof unknownVolumeLoader !== 'function'\n    ) {\n      throw new Error(\n        `No volume loader for scheme ${scheme} has been registered`\n      );\n    }\n\n    loader = unknownVolumeLoader;\n  }\n\n  const volumeLoadObject = loader(volumeId, options);\n\n  setupCacheOptimizationEventListener(volumeId);\n\n  // Broadcast a volume loaded event once the image is loaded\n  volumeLoadObject.promise.then(\n    function (volume) {\n      triggerEvent(eventTarget, Events.VOLUME_LOADED, { volume });\n    },\n    function (error) {\n      const errorObject: EventTypes.VolumeLoadedFailedEventDetail = {\n        volumeId,\n        error,\n      };\n\n      triggerEvent(eventTarget, Events.VOLUME_LOADED_FAILED, errorObject);\n    }\n  );\n\n  return volumeLoadObject;\n}\n\n/**\n * Loads a volume given a volumeId and optional priority and returns a promise which will resolve to\n * the loaded image object or fail if an error occurred.  The loaded image is not stored in the cache.\n *\n * @param volumeId - A Cornerstone Image Object's volumeId\n * @param options - Options to be passed to the Volume Loader\n *\n * @returns An Object which can be used to act after an image is loaded or loading fails\n */\nexport function loadVolume(\n  volumeId: string,\n  options: VolumeLoaderOptions = { imageIds: [] }\n): Promise<IImageVolume> {\n  if (volumeId === undefined) {\n    throw new Error('loadVolume: parameter volumeId must not be undefined');\n  }\n\n  let volumeLoadObject = cache.getVolumeLoadObject(volumeId);\n\n  if (volumeLoadObject !== undefined) {\n    return volumeLoadObject.promise;\n  }\n\n  volumeLoadObject = loadVolumeFromVolumeLoader(volumeId, options);\n\n  return volumeLoadObject.promise.then((volume: IImageVolume) => {\n    volume.imageData = createInternalVTKRepresentation(volume);\n    return volume;\n  });\n}\n\n/**\n * Loads an image given an volumeId and optional priority and returns a promise which will resolve to\n * the loaded image object or fail if an error occurred. The image is stored in the cache.\n *\n * @param volumeId - A Cornerstone Image Object's volumeId\n * @param options - Options to be passed to the Volume Loader\n *\n * @returns Volume Loader Object\n */\nexport async function createAndCacheVolume(\n  volumeId: string,\n  options?: VolumeLoaderOptions\n): Promise<Record<string, any>> {\n  if (volumeId === undefined) {\n    throw new Error(\n      'createAndCacheVolume: parameter volumeId must not be undefined'\n    );\n  }\n\n  let volumeLoadObject = cache.getVolumeLoadObject(volumeId);\n\n  if (volumeLoadObject !== undefined) {\n    return volumeLoadObject.promise;\n  }\n\n  volumeLoadObject = loadVolumeFromVolumeLoader(volumeId, options);\n\n  volumeLoadObject.promise.then((volume: IImageVolume) => {\n    volume.imageData = createInternalVTKRepresentation(volume);\n  });\n\n  cache.putVolumeLoadObject(volumeId, volumeLoadObject).catch((err) => {\n    throw err;\n  });\n\n  return volumeLoadObject.promise;\n}\n\n/**\n * Based on a referencedVolumeId, it will build and cache a new volume. If\n * no scalarData is specified in the options, an empty derived volume will be\n * created that matches the image metadata of the referenceVolume. If scalarData\n * is given, it will be used to generate the intensity values for the derivedVolume.\n * Finally, it will save the volume in the cache.\n * @param referencedVolumeId - the volumeId from which the new volume will get its metadata\n * @param options - DerivedVolumeOptions {uid: derivedVolumeUID, targetBuffer: { type: Float32Array | Uint8Array |\n * Uint16Array | Uint32Array  }, scalarData: if provided}\n *\n * @returns ImageVolume\n */\nexport async function createAndCacheDerivedVolume(\n  referencedVolumeId: string,\n  options: DerivedVolumeOptions\n): Promise<IImageVolume> {\n  const referencedVolume = cache.getVolume(referencedVolumeId);\n  if (!referencedVolume) {\n    throw new Error(\n      `Cannot created derived volume: Referenced volume with id ${referencedVolumeId} does not exist.`\n    );\n  }\n\n  let { volumeId } = options;\n  const { targetBuffer } = options;\n\n  if (volumeId === undefined) {\n    volumeId = uuidv4();\n  }\n\n  const { metadata, dimensions, spacing, origin, direction } = referencedVolume;\n  const scalarData = referencedVolume.getScalarData();\n  const scalarLength = scalarData.length;\n\n  const { volumeScalarData, numBytes } = generateVolumeScalarData(\n    targetBuffer,\n    scalarLength\n  );\n\n  // Todo: handle more than one component for segmentation (RGB)\n  const scalarArray = vtkDataArray.newInstance({\n    name: 'Pixels',\n    numberOfComponents: 1,\n    values: volumeScalarData,\n  });\n\n  const derivedImageData = vtkImageData.newInstance();\n\n  derivedImageData.setDimensions(dimensions);\n  derivedImageData.setSpacing(spacing);\n  derivedImageData.setDirection(direction);\n  derivedImageData.setOrigin(origin);\n  derivedImageData.getPointData().setScalars(scalarArray);\n\n  const derivedVolume = new ImageVolume({\n    volumeId,\n    metadata: cloneDeep(metadata),\n    dimensions: [dimensions[0], dimensions[1], dimensions[2]],\n    spacing,\n    origin,\n    direction,\n    imageData: derivedImageData,\n    scalarData: volumeScalarData,\n    sizeInBytes: numBytes,\n    imageIds: [],\n    referencedVolumeId,\n  });\n\n  const volumeLoadObject = {\n    promise: Promise.resolve(derivedVolume),\n  };\n\n  await cache.putVolumeLoadObject(volumeId, volumeLoadObject);\n\n  return derivedVolume;\n}\n\n/**\n * Creates and cache a volume based on a set of provided properties including\n * dimensions, spacing, origin, direction, metadata, scalarData. It should be noted that\n * scalarData should be provided for this function to work. If a volume with the same\n * Id exists in the cache it returns it immediately.\n * @param options -  { scalarData, metadata, dimensions, spacing, origin, direction }\n * @param volumeId - Id of the generated volume\n *\n * @returns ImageVolume\n */\nexport function createLocalVolume(\n  options: LocalVolumeOptions,\n  volumeId: string,\n  preventCache = false\n): IImageVolume {\n  const { metadata, dimensions, spacing, origin, direction, targetBuffer } =\n    options;\n\n  let { scalarData } = options;\n\n  // Define the valid data types for scalarData\n  const validDataTypes = [\n    'Uint8Array',\n    'Float32Array',\n    'Uint16Array',\n    'Int16Array',\n  ];\n\n  const scalarLength = dimensions[0] * dimensions[1] * dimensions[2];\n\n  // Check if scalarData is provided and is of a valid type\n  if (!scalarData || !validDataTypes.includes(scalarData.constructor.name)) {\n    // Check if targetBuffer is provided and has a valid type\n    if (!targetBuffer?.type || !validDataTypes.includes(targetBuffer.type)) {\n      throw new Error(\n        'createLocalVolume: parameter scalarData must be provided and must be either Uint8Array, Float32Array, Uint16Array or Int16Array'\n      );\n    }\n\n    // Generate volume scalar data if scalarData is not provided or invalid\n    ({ volumeScalarData: scalarData } = generateVolumeScalarData(\n      targetBuffer,\n      scalarLength\n    ));\n  }\n\n  // Todo: handle default values for spacing, origin, direction if not provided\n  if (volumeId === undefined) {\n    volumeId = uuidv4();\n  }\n\n  const cachedVolume = cache.getVolume(volumeId);\n\n  if (cachedVolume) {\n    return cachedVolume as IImageVolume;\n  }\n\n  const numBytes = scalarData ? scalarData.buffer.byteLength : scalarLength * 4;\n\n  // check if there is enough space in unallocated + image Cache\n  const isCacheable = cache.isCacheable(numBytes);\n  if (!isCacheable) {\n    throw new Error(Events.CACHE_SIZE_EXCEEDED);\n  }\n\n  const scalarArray = vtkDataArray.newInstance({\n    name: 'Pixels',\n    numberOfComponents: 1,\n    values: scalarData,\n  });\n\n  const imageData = vtkImageData.newInstance();\n\n  imageData.setDimensions(dimensions);\n  imageData.setSpacing(spacing);\n  imageData.setDirection(direction);\n  imageData.setOrigin(origin);\n  imageData.getPointData().setScalars(scalarArray);\n\n  const derivedVolume = new ImageVolume({\n    volumeId,\n    metadata: cloneDeep(metadata),\n    dimensions: [dimensions[0], dimensions[1], dimensions[2]],\n    spacing,\n    origin,\n    direction,\n    imageData: imageData,\n    scalarData,\n    sizeInBytes: numBytes,\n    referencedImageIds: options.referencedImageIds || [],\n    referencedVolumeId: options.referencedVolumeId,\n    imageIds: options.imageIds || [],\n  });\n\n  if (preventCache) {\n    return derivedVolume;\n  }\n\n  const volumeLoadObject = {\n    promise: Promise.resolve(derivedVolume),\n  };\n  cache.putVolumeLoadObject(volumeId, volumeLoadObject);\n\n  return derivedVolume;\n}\n\nexport async function createAndCacheVolumeFromImages(\n  volumeId: string,\n  imageIds: string[],\n  options: {\n    preventCache?: boolean;\n    additionalDetails?: Record<string, any>;\n  } = {}\n): Promise<IImageVolume> {\n  const { preventCache = false } = options;\n\n  if (imageIds === undefined) {\n    throw new Error(\n      'createAndCacheVolumeFromImages: parameter imageIds must not be undefined'\n    );\n  }\n\n  if (volumeId === undefined) {\n    throw new Error(\n      'createAndCacheVolumeFromImages: parameter volumeId must not be undefined'\n    );\n  }\n\n  const cachedVolume = cache.getVolume(volumeId);\n\n  if (cachedVolume) {\n    return Promise.resolve(cachedVolume);\n  }\n\n  const volumeProps = generateVolumePropsFromImageIds(imageIds, volumeId);\n\n  // volume is an empty volume, we need to load the data from the imageIds\n  // into the volume scalarData\n\n  // it is important to get the imageIds from the volumeProps\n  // since they are sorted\n  const imagePromises = volumeProps.imageIds.map((imageId, imageIdIndex) => {\n    const imageLoadObject = cache.getImageLoadObject(imageId);\n\n    return imageLoadObject.promise.then((image) => {\n      const pixelData = image.getPixelData();\n      const offset = imageIdIndex * image.rows * image.columns;\n\n      (volumeProps.scalarData as PixelDataTypedArray).set(pixelData, offset);\n    });\n  });\n\n  await Promise.all(imagePromises);\n\n  const volume = new ImageVolume({\n    ...volumeProps,\n    referencedImageIds: imageIds,\n    ...options,\n  });\n\n  // since we generated the volume from images, we can optimize the cache\n  // by replacing the pixelData of the images with a view of the volume's\n  // scalarData\n  performCacheOptimizationForVolume(volume);\n\n  const volumeLoadObject = {\n    promise: Promise.resolve(volume),\n  };\n\n  if (preventCache) {\n    return volumeLoadObject.promise;\n  }\n\n  cache.putVolumeLoadObject(volumeId, volumeLoadObject);\n\n  return volumeLoadObject.promise;\n}\n\n/**\n * Registers an volumeLoader plugin with cornerstone for the specified scheme\n *\n * @param scheme - The scheme to use for this volume loader (e.g. 'dicomweb', 'wadouri', 'http')\n * @param volumeLoader - A Cornerstone Volume Loader function\n */\nexport function registerVolumeLoader(\n  scheme: string,\n  volumeLoader: VolumeLoaderFn\n): void {\n  volumeLoaders[scheme] = volumeLoader;\n}\n\n/** Gets the array of volume loader schemes */\nexport function getVolumeLoaderSchemes(): string[] {\n  return Object.keys(volumeLoaders);\n}\n\n/**\n * Registers a new unknownVolumeLoader and returns the previous one\n *\n * @param volumeLoader - A Cornerstone Volume Loader\n *\n * @returns The previous Unknown Volume Loader\n */\nexport function registerUnknownVolumeLoader(\n  volumeLoader: VolumeLoaderFn\n): VolumeLoaderFn | undefined {\n  const oldVolumeLoader = unknownVolumeLoader;\n\n  unknownVolumeLoader = volumeLoader;\n\n  return oldVolumeLoader;\n}\n\nexport function getUnknownVolumeLoaderSchema(): string {\n  return unknownVolumeLoader.name;\n}\n\n/**\n * Creates and caches a derived segmentation volume based on a referenced volume.\n * This is basically a utility method since for the segmentations we have to specify\n * Uint8Array as the targetBuffer type for now until we support other types.\n *\n * @param referencedVolumeId - The ID of the referenced volume.\n * @param options - The options for creating the derived volume.\n * @returns A promise that resolves to the created derived segmentation volume.\n */\nexport async function createAndCacheDerivedSegmentationVolume(\n  referencedVolumeId: string,\n  options = {} as DerivedVolumeOptions\n): Promise<IImageVolume> {\n  return createAndCacheDerivedVolume(referencedVolumeId, {\n    ...options,\n    targetBuffer: {\n      type: 'Uint8Array',\n    },\n  });\n}\n\n/**\n * Creates a local segmentation volume.\n *\n * @param options - The options for creating the volume.\n * @param volumeId - The ID of the volume.\n * @param preventCache - Whether to prevent caching the volume.\n * @returns A promise that resolves to the created image volume.\n */\nexport async function createLocalSegmentationVolume(\n  options: LocalVolumeOptions,\n  volumeId: string,\n  preventCache = false\n): Promise<IImageVolume> {\n  if (!options.scalarData) {\n    options.scalarData = new Uint8Array(\n      options.dimensions[0] * options.dimensions[1] * options.dimensions[2]\n    );\n  }\n\n  return createLocalVolume(options, volumeId, preventCache);\n}\n\n/**\n * This function generates volume scalar data based on the provided target buffer and scalar length.\n * It checks if the cache can accommodate the data size and throws an error if it exceeds the cache size.\n * If a shared array buffer is available in the target buffer, it uses that to create the typed array.\n * Otherwise, it creates a typed array based on the scalar length.\n *\n * @param targetBuffer - The target buffer object which may contain a type and a shared array buffer.\n * @param scalarLength - The scalar length for creating the typed array.\n * @param useNorm16Texture - A flag to specify whether to use a 16-bit texture or not.\n * @returns The volume scalar data as a typed array.\n */\nfunction generateVolumeScalarData(\n  targetBuffer: {\n    type: PixelDataTypedArrayString;\n    sharedArrayBuffer?: boolean;\n  },\n  scalarLength: number\n) {\n  const { useNorm16Texture } = getConfiguration().rendering;\n\n  const { TypedArrayConstructor, numBytes } = getBufferConfiguration(\n    targetBuffer?.type,\n    scalarLength,\n    {\n      use16BitTexture: useNorm16Texture,\n      isVolumeBuffer: true,\n    }\n  );\n\n  const isCacheable = cache.isCacheable(numBytes);\n  if (!isCacheable) {\n    throw new Error(Events.CACHE_SIZE_EXCEEDED);\n  }\n\n  let volumeScalarData;\n  if (targetBuffer?.sharedArrayBuffer) {\n    const buffer = new SharedArrayBuffer(numBytes);\n    volumeScalarData = new TypedArrayConstructor(buffer);\n  } else {\n    volumeScalarData = new TypedArrayConstructor(scalarLength);\n  }\n\n  return { volumeScalarData, numBytes };\n}\n","// This module defines a way to access various metadata about an imageId.  This layer of abstraction exists\n// So metadata can be provided in different ways (e.g. by parsing DICOM P10 or by a WADO-RS document)\n\nconst providers = [];\n\n/**\n * Adds a metadata provider with the specified priority\n * @param provider - Metadata provider function\n * @param priority - 0 is default/normal, > 0 is high, < 0 is low\n *\n * @category MetaData\n */\nexport function addProvider(\n  provider: (type: string, ...query: string[]) => any,\n  priority = 0\n): void {\n  let i;\n\n  // Find the right spot to insert this provider based on priority\n  for (i = 0; i < providers.length; i++) {\n    if (providers[i].priority <= priority) {\n      break;\n    }\n  }\n\n  // Insert the decode task at position i\n  providers.splice(i, 0, {\n    priority,\n    provider,\n  });\n}\n\n/**\n * Removes the specified provider\n *\n * @param provider - Metadata provider function\n *\n * @category MetaData\n */\nexport function removeProvider(\n  provider: (type: string, query: any) => { any }\n): void {\n  for (let i = 0; i < providers.length; i++) {\n    if (providers[i].provider === provider) {\n      providers.splice(i, 1);\n\n      break;\n    }\n  }\n}\n\n/**\n * Removes all providers\n *\n * @category MetaData\n */\nexport function removeAllProviders(): void {\n  while (providers.length > 0) {\n    providers.pop();\n  }\n}\n\n/**\n * Gets metadata from the registered metadata providers.  Will call each one from highest priority to lowest\n * until one responds\n *\n * @param type -  The type of metadata requested from the metadata store\n * @param query - The query for the metadata store, often imageId\n *        Some metadata providers support multi-valued strings, which are interpretted\n *        as the provider chooses.\n *\n * @returns The metadata retrieved from the metadata store\n * @category MetaData\n */\nfunction getMetaData(type: string, ...queries): any {\n  // Invoke each provider in priority order until one returns something\n  for (let i = 0; i < providers.length; i++) {\n    const result = providers[i].provider(type, ...queries);\n\n    if (result !== undefined) {\n      return result;\n    }\n  }\n}\n\nexport { getMetaData as get };\n","import { RequestPoolManager } from './requestPoolManager';\nimport RequestType from '../enums/RequestType';\n\n/**\n * You can use the imageLoadPoolManager to load images, by providing a `requestFn`\n * that returns a promise for the image. You can provide a `type` to specify the type of\n * request (interaction, thumbnail, prefetch), and you can provide additional details\n * that will be passed to the requestFn. Below is an example of a requestFn that loads\n * an image from an imageId:\n *\n * ```javascript\n *\n * const priority = -5\n * const requestType = RequestType.Interaction\n * const additionalDetails = { imageId }\n * const options = {\n *   targetBuffer: {\n *     type: 'Float32Array',\n *     offset: null,\n *     length: null,\n *   },\n *   preScale: {\n *     enabled: true,\n *   },\n * }\n *\n * imageLoadPoolManager.addRequest(\n *   loadAndCacheImage(imageId, options).then(() => { // set on viewport}),\n *   requestType,\n *   additionalDetails,\n *   priority\n * )\n * ```\n */\nconst imageLoadPoolManager = new RequestPoolManager('imageLoadPool');\n\nimageLoadPoolManager.grabDelay = 0;\n\nimageLoadPoolManager.setMaxSimultaneousRequests(RequestType.Interaction, 1000);\nimageLoadPoolManager.setMaxSimultaneousRequests(RequestType.Thumbnail, 1000);\nimageLoadPoolManager.setMaxSimultaneousRequests(RequestType.Prefetch, 1000);\n\nexport default imageLoadPoolManager;\n","import RequestType from '../enums/RequestType';\nimport { IImage } from '../types';\nimport { uuidv4 } from '../utilities';\n\ntype AdditionalDetails = {\n  imageId?: string;\n  volumeId?: string;\n};\n\ntype RequestDetailsInterface = {\n  requestFn: () => Promise<IImage | void>;\n  type: RequestType;\n  additionalDetails: AdditionalDetails;\n};\n\ntype RequestPool = {\n  [name in RequestType]: { [key: number]: RequestDetailsInterface[] };\n};\n\n/**\n * RequestPool manager class is a base class that manages the request pools.\n * It is used imageRetrievalPoolManager, and imageLoadPoolManager to retrieve and load images.\n * Previously requestPoolManager was used to manage the retrieval and loading and decoding\n * of the images in a way that new requests were sent after the image was both loaded and decoded\n * which was not performant since it was waiting for the image to be loaded and decoded before\n * sending the next request which is a network request and can be done in parallel.\n * Now, we use separate imageRetrievalPoolManager and imageLoadPoolManager\n * to improve performance and both are extending the RequestPoolManager class which\n * is a basic queueing pool.\n *\n * A new requestPool can be created by instantiating a new RequestPoolManager class.\n *\n * ```javascript\n * const requestPoolManager = new RequestPoolManager()\n * ```\n *\n * ## ImageLoadPoolManager\n *\n * You can use the imageLoadPoolManager to load images, by providing a `requestFn`\n * that returns a promise for the image. You can provide a `type` to specify the type of\n * request (interaction, thumbnail, prefetch), and you can provide additional details\n * that will be passed to the requestFn. Below is an example of a requestFn that loads\n * an image from an imageId:\n *\n * ```javascript\n *\n * const priority = -5\n * const requestType = RequestType.Interaction\n * const additionalDetails = { imageId }\n * const options = {\n *   targetBuffer: {\n *     type: 'Float32Array',\n *     offset: null,\n *     length: null,\n *   },\n *   preScale: {\n *      enabled: true,\n *    },\n * }\n *\n * imageLoadPoolManager.addRequest(\n *   loadAndCacheImage(imageId, options).then(() => { // set on viewport}),\n *   requestType,\n *   additionalDetails,\n *   priority\n * )\n * ```\n * ### ImageRetrievalPoolManager\n * You don't need to directly use the imageRetrievalPoolManager to load images\n * since the imageLoadPoolManager will automatically use it for retrieval. However,\n * maximum number of concurrent requests can be set by calling `setMaxConcurrentRequests`.\n */\nclass RequestPoolManager {\n  private id: string;\n  private awake: boolean;\n  private requestPool: RequestPool;\n  private numRequests = {\n    interaction: 0,\n    thumbnail: 0,\n    prefetch: 0,\n    compute: 0,\n  };\n  /* maximum number of requests of each type. */\n  public maxNumRequests: {\n    interaction: number;\n    thumbnail: number;\n    prefetch: number;\n    compute: number;\n  };\n  /* A public property that is used to set the delay between requests. */\n  public grabDelay: number;\n  private timeoutHandle: number;\n\n  /**\n   * By default a request pool containing three priority groups, one for each\n   * of the request types, is created. Maximum number of requests of each type\n   * is set to 6.\n   */\n  constructor(id?: string) {\n    this.id = id ? id : uuidv4();\n\n    this.requestPool = {\n      interaction: { 0: [] },\n      thumbnail: { 0: [] },\n      prefetch: { 0: [] },\n      compute: { 0: [] },\n    };\n\n    this.grabDelay = 5;\n    this.awake = false;\n\n    this.numRequests = {\n      interaction: 0,\n      thumbnail: 0,\n      prefetch: 0,\n      compute: 0,\n    };\n\n    this.maxNumRequests = {\n      interaction: 6,\n      thumbnail: 6,\n      prefetch: 5,\n      // I believe there is a bug right now, where if there are two workers\n      // and one wants to run a compute job 6 times and the limit is just 5, then\n      // the other worker will never get a chance to run its compute job.\n      // we should probably have a separate limit for compute jobs per worker\n      // context as there is another layer of parallelism there. For this reason\n      // I'm setting the limit to 1000 for now.\n      compute: 1000,\n    };\n  }\n\n  /**\n   * This function sets the maximum number of requests for a given request type.\n   * @param type - The type of request you want to set the max number\n   * of requests for it can be either of interaction, prefetch, or thumbnail.\n   * @param maxNumRequests - The maximum number of requests that can be\n   * made at a time.\n   */\n  public setMaxSimultaneousRequests(\n    type: RequestType,\n    maxNumRequests: number\n  ): void {\n    this.maxNumRequests[type] = maxNumRequests;\n  }\n\n  /**\n   * It returns the maximum number of requests of a given type that can be made\n   * @param type - The type of request.\n   * @returns The maximum number of requests of a given type.\n   */\n  public getMaxSimultaneousRequests(type: RequestType): number {\n    return this.maxNumRequests[type];\n  }\n\n  /**\n   * Stops further fetching of the requests, all the ongoing requests will still\n   * be retrieved\n   */\n  public destroy(): void {\n    if (this.timeoutHandle) {\n      window.clearTimeout(this.timeoutHandle);\n    }\n  }\n\n  /**\n   * Adds the requests to the pool of requests.\n   *\n   * @param requestFn - A function that returns a promise which resolves in the image\n   * @param type - Priority category, it can be either of interaction, prefetch,\n   * or thumbnail.\n   * @param additionalDetails - Additional details that requests can contain.\n   * For instance the volumeId for the volume requests\n   * @param priority - Priority number for each category of requests. Its default\n   * value is priority 0. The lower the priority number, the higher the priority number\n   *\n   */\n  public addRequest(\n    requestFn: () => Promise<IImage | void>,\n    type: RequestType,\n    additionalDetails: Record<string, unknown>,\n    priority = 0\n  ): void {\n    // Describe the request\n    const requestDetails: RequestDetailsInterface = {\n      requestFn,\n      type,\n      additionalDetails,\n    };\n\n    // Check if the priority group exists on the request type\n    if (this.requestPool[type][priority] === undefined) {\n      this.requestPool[type][priority] = [];\n    }\n\n    // Adding the request to the correct priority group of the request type\n    this.requestPool[type][priority].push(requestDetails);\n\n    this.startGrabbing();\n  }\n\n  /**\n   * Filter the requestPoolManager's pool of request based on the result of\n   * provided filter function. The provided filter function needs to return false or true\n   *\n   * @param filterFunction - The filter function for filtering of the requests to keep\n   */\n  public filterRequests(\n    filterFunction: (requestDetails: RequestDetailsInterface) => boolean\n  ): void {\n    Object.keys(this.requestPool).forEach((type: string) => {\n      const requestType = this.requestPool[type];\n      Object.keys(requestType).forEach((priority) => {\n        requestType[priority] = requestType[priority].filter(\n          (requestDetails: RequestDetailsInterface) => {\n            return filterFunction(requestDetails);\n          }\n        );\n      });\n    });\n  }\n\n  /**\n   * Clears the requests specific to the provided type. For instance, the\n   * pool of requests of type 'interaction' can be cleared via this function.\n   *\n   *\n   * @param type - category of the request (either interaction, prefetch or thumbnail)\n   */\n  public clearRequestStack(type: string): void {\n    if (!this.requestPool[type]) {\n      throw new Error(`No category for the type ${type} found`);\n    }\n    this.requestPool[type] = { 0: [] };\n  }\n\n  private sendRequests(type) {\n    const requestsToSend = this.maxNumRequests[type] - this.numRequests[type];\n    let syncImageCount = 0;\n\n    for (let i = 0; i < requestsToSend; i++) {\n      const requestDetails = this.getNextRequest(type);\n      if (requestDetails === null) {\n        return false;\n      } else if (requestDetails) {\n        this.numRequests[type]++;\n        this.awake = true;\n\n        let requestResult;\n        try {\n          requestResult = requestDetails.requestFn();\n        } catch (e) {\n          // This is the only warning one will get, so need a warn message\n          console.warn('sendRequest failed', e);\n        }\n        if (requestResult?.finally) {\n          requestResult.finally(() => {\n            this.numRequests[type]--;\n            this.startAgain();\n          });\n        } else {\n          // Handle non-async request functions too - typically just short circuit ones\n          this.numRequests[type]--;\n          syncImageCount++;\n        }\n      }\n    }\n    if (syncImageCount) {\n      this.startAgain();\n    }\n\n    return true;\n  }\n\n  private getNextRequest(type): RequestDetailsInterface | null {\n    const interactionPriorities = this.getSortedPriorityGroups(type);\n    for (const priority of interactionPriorities) {\n      if (this.requestPool[type][priority].length) {\n        return this.requestPool[type][priority].shift();\n      }\n    }\n\n    return null;\n  }\n\n  protected startGrabbing(): void {\n    const hasRemainingInteractionRequests = this.sendRequests(\n      RequestType.Interaction\n    );\n    const hasRemainingThumbnailRequests = this.sendRequests(\n      RequestType.Thumbnail\n    );\n    const hasRemainingPrefetchRequests = this.sendRequests(\n      RequestType.Prefetch\n    );\n    const hasRemainingComputeRequests = this.sendRequests(RequestType.Compute);\n\n    if (\n      !hasRemainingInteractionRequests &&\n      !hasRemainingThumbnailRequests &&\n      !hasRemainingPrefetchRequests &&\n      !hasRemainingComputeRequests\n    ) {\n      this.awake = false;\n    }\n  }\n\n  protected startAgain(): void {\n    if (!this.awake) {\n      return;\n    }\n\n    if (this.grabDelay !== undefined) {\n      // Prevents calling setTimeout hundreds of times when hundreds of requests\n      // are added which make it slower and works in an unexpected way when\n      // destroy/clearTimeout is called because only the last handle is stored.\n      if (!this.timeoutHandle) {\n        this.timeoutHandle = window.setTimeout(() => {\n          this.timeoutHandle = null;\n          this.startGrabbing();\n        }, this.grabDelay);\n      }\n    } else {\n      this.startGrabbing();\n    }\n  }\n\n  protected getSortedPriorityGroups(type: string): Array<number> {\n    const priorities = Object.keys(this.requestPool[type])\n      .map(Number)\n      .filter((priority) => this.requestPool[type][priority].length)\n      .sort((a, b) => a - b);\n    return priorities;\n  }\n\n  /**\n   * Returns the request pool containing different categories, their priority and\n   * the added request details.\n   *\n   * @returns the request pool which contains different categories, their priority and\n   * the added request details\n   */\n  getRequestPool(): RequestPool {\n    return this.requestPool;\n  }\n}\n\nexport { RequestPoolManager };\n","import eventTarget from '../eventTarget';\n\n/**\n * Small utility to trigger a custom event for a given EventTarget.\n *\n * @example\n *\n * ```javascript\n * triggerEvent(element, Events.IMAGE_RENDERED, { element })\n * ```\n * or it can trigger event on the eventTarget itself\n *\n * ```javascript\n * triggerEvent(eventTarget, CSTOOLS_EVENTS.ANNOTATION_MODIFIED, { viewportId, annotationUID })\n * ```\n *\n * @param el - The element or EventTarget to trigger the event upon\n * @param type - The event type name\n * @param detail - The event detail to be sent\n * @returns false if event is cancelable and at least one of the event handlers\n * which received event called Event.preventDefault(). Otherwise it returns true.\n */\nexport default function triggerEvent(\n  el: EventTarget = eventTarget,\n  type: string,\n  detail: unknown = null\n): boolean {\n  if (!type) {\n    throw new Error('Event type was not defined');\n  }\n\n  const event = new CustomEvent(type, {\n    detail,\n    cancelable: true,\n  });\n\n  return el.dispatchEvent(event);\n}\n","import * as Comlink from 'comlink';\nimport { RequestType } from '../enums/';\nimport { RequestPoolManager } from '../requestPool/requestPoolManager';\n\nclass CentralizedWorkerManager {\n  constructor() {\n    this.workerRegistry = {};\n    this.workerPoolManager = new RequestPoolManager('webworker');\n  }\n\n  /**\n   * Registers a new worker, it doesn't mean that the function will get executed.\n   *\n   * @param workerName - The name of the worker.\n   * @param workerFn - The function that creates a new instance of the worker.\n   * @param options - Optional parameters.\n   * @param options.maxWorkerInstances - The maximum number of instances of this worker that can be created.\n   * For instance if you create a worker with maxWorkerInstances = 2, then only 2 instances of this worker will be created\n   * and in case there are 10 tasks that need to be executed, each will get assigned 5 tasks.\n   * @param options.overwrite - Whether to overwrite the worker if it's already registered.\n   * @param options.autoTerminateOnIdle - Whether to automatically terminate idle workers.\n   */\n  registerWorker(workerName, workerFn, options = {}) {\n    const {\n      maxWorkerInstances = 1,\n      overwrite = false,\n      autoTerminateOnIdle = {\n        enabled: false,\n        idleTimeThreshold: 3000, // 3 seconds\n      },\n    } = options;\n\n    if (this.workerRegistry[workerName] && !overwrite) {\n      console.warn(`Worker type '${workerName}' is already registered...`);\n      return;\n    }\n\n    if (overwrite && this.workerRegistry[workerName]?.idleCheckIntervalId) {\n      clearInterval(this.workerRegistry[workerName].idleCheckIntervalId);\n    }\n\n    const workerProperties = {\n      workerFn: null,\n      instances: [],\n      loadCounters: [],\n      lastActiveTime: [],\n      // used for termination\n      nativeWorkers: [],\n      // auto termination\n      autoTerminateOnIdle: autoTerminateOnIdle.enabled,\n      idleCheckIntervalId: null,\n      idleTimeThreshold: autoTerminateOnIdle.idleTimeThreshold,\n    };\n\n    workerProperties.loadCounters = Array(maxWorkerInstances).fill(0);\n    workerProperties.lastActiveTime = Array(maxWorkerInstances).fill(null);\n\n    for (let i = 0; i < maxWorkerInstances; i++) {\n      const worker = workerFn();\n      workerProperties.instances.push(Comlink.wrap(worker));\n      workerProperties.nativeWorkers.push(worker);\n      workerProperties.workerFn = workerFn;\n    }\n\n    this.workerRegistry[workerName] = workerProperties;\n  }\n\n  getNextWorkerAPI(workerName) {\n    const workerProperties = this.workerRegistry[workerName];\n\n    if (!workerProperties) {\n      console.error(`Worker type '${workerName}' is not registered.`);\n      return null;\n    }\n\n    // Find the worker with the minimum load.\n    const workerInstances = workerProperties.instances.filter(\n      (instance) => instance !== null\n    );\n\n    let minLoadIndex = 0;\n    let minLoadValue = workerProperties.loadCounters[0] || 0;\n    for (let i = 1; i < workerInstances.length; i++) {\n      const currentLoadValue = workerProperties.loadCounters[i] || 0;\n      if (currentLoadValue < minLoadValue) {\n        minLoadIndex = i;\n        minLoadValue = currentLoadValue;\n      }\n    }\n\n    // Check and recreate the worker if it was terminated.\n    if (workerProperties.instances[minLoadIndex] === null) {\n      const worker = workerProperties.workerFn();\n      workerProperties.instances[minLoadIndex] = Comlink.wrap(worker);\n      workerProperties.nativeWorkers[minLoadIndex] = worker;\n    }\n\n    // Update the load counter.\n    workerProperties.loadCounters[minLoadIndex] += 1;\n\n    // return the worker that has the minimum load.\n    return {\n      api: workerProperties.instances[minLoadIndex],\n      index: minLoadIndex,\n    };\n  }\n\n  /**\n   * Executes a task on a worker.\n   *\n   * @param workerName - The name of the worker to execute the task on.\n   * @param methodName - The name of the method to execute on the worker.\n   * @param args - The arguments to pass to the method. Default is an array\n   * You should put your transferable objects in the first argument as object\n   * and from the second argument you can put your non-transferable objects such\n   * as functions, classes, etc.\n   * @param options - An object containing options for the request. Default is an empty object.\n   * @param options.requestType - The type of the request. Default is RequestType.Compute.\n   * @param options.priority - The priority of the request. Default is 0.\n   * @param options.options - Additional options for the request. Default is an empty object.\n   *\n   * @returns A promise that resolves with the result of the task.\n   */\n  executeTask(\n    workerName,\n    methodName,\n    args = {},\n    {\n      requestType = RequestType.Compute,\n      priority = 0,\n      options = {},\n      callbacks = [],\n    } = {}\n  ) {\n    return new Promise((resolve, reject) => {\n      const requestFn = async () => {\n        const { api, index } = this.getNextWorkerAPI(workerName);\n        if (!api) {\n          const error = new Error(\n            `No available worker instance for '${workerName}'`\n          );\n          console.error(error);\n          reject(error);\n          return;\n        }\n\n        try {\n          // fix if any of the args keys are a function then we need to proxy it\n          // for the worker to be able to call it\n          let finalCallbacks = [];\n          if (callbacks.length) {\n            finalCallbacks = callbacks.map((cb) => {\n              return Comlink.proxy(cb);\n            });\n          }\n          const workerProperties = this.workerRegistry[workerName];\n\n          workerProperties.processing = true;\n\n          const results = await api[methodName](args, ...finalCallbacks);\n\n          workerProperties.processing = false;\n          workerProperties.lastActiveTime[index] = Date.now();\n\n          // If auto termination is enabled and the interval is not set, set it.\n          if (\n            workerProperties.autoTerminateOnIdle &&\n            !workerProperties.idleCheckIntervalId &&\n            workerProperties.idleTimeThreshold\n          ) {\n            workerProperties.idleCheckIntervalId = setInterval(() => {\n              this.terminateIdleWorkers(\n                workerName,\n                workerProperties.idleTimeThreshold\n              );\n            }, workerProperties.idleTimeThreshold);\n          }\n\n          resolve(results);\n        } catch (err) {\n          console.error(\n            `Error executing method '${methodName}' on worker '${workerName}':`,\n            err\n          );\n          reject(err);\n        } finally {\n          this.workerRegistry[workerName].loadCounters[index]--;\n        }\n      };\n\n      // I believe there is a bug right now, where if there are two workers\n      // and one wants to run a compute job 6 times and the limit is just 5, then\n      // the other worker will never get a chance to run its compute job.\n      // we should probably have a separate limit for compute jobs per worker\n      // context as there is another layer of parallelism there.\n      this.workerPoolManager.addRequest(\n        requestFn,\n        requestType,\n        options,\n        priority\n      );\n    });\n  }\n\n  terminateIdleWorkers(workerName, idleTimeThreshold) {\n    const workerProperties = this.workerRegistry[workerName];\n\n    if (workerProperties.processing) {\n      return;\n    }\n\n    const now = Date.now();\n\n    workerProperties.instances.forEach((_, index) => {\n      const lastActiveTime = workerProperties.lastActiveTime[index];\n      const isWorkerActive =\n        lastActiveTime !== null && workerProperties.loadCounters[index] > 0;\n      const idleTime = now - lastActiveTime;\n\n      if (!isWorkerActive && idleTime > idleTimeThreshold) {\n        this.terminateWorkerInstance(workerName, index);\n      }\n    });\n  }\n\n  terminate(workerName) {\n    const workerProperties = this.workerRegistry[workerName];\n    if (!workerProperties) {\n      console.error(`Worker type '${workerName}' is not registered.`);\n      return;\n    }\n\n    workerProperties.instances.forEach((_, index) => {\n      this.terminateWorkerInstance(workerName, index);\n    });\n  }\n\n  // New method to handle individual worker termination\n  terminateWorkerInstance(workerName, index) {\n    const workerProperties = this.workerRegistry[workerName];\n    const workerInstance = workerProperties.instances[index];\n\n    if (workerInstance !== null) {\n      workerInstance[Comlink.releaseProxy]();\n      workerProperties.nativeWorkers[index].terminate();\n\n      // Set the worker instance to null after termination\n      workerProperties.instances[index] = null;\n      workerProperties.lastActiveTime[index] = null;\n    }\n  }\n}\n\nexport default CentralizedWorkerManager;\n","import { state } from '../store';\nimport { getEnabledElement } from '@cornerstonejs/core';\nimport { SVGDrawingHelper } from '../types';\n\nconst VIEWPORT_ELEMENT = 'viewport-element';\n\n/**\n * Returns the SVG drawing helper for the given HTML element.\n * @param element - The HTML element to get the SVG drawing helper for.\n * @private\n */\nfunction getSvgDrawingHelper(element: HTMLDivElement): SVGDrawingHelper {\n  const enabledElement = getEnabledElement(element);\n  const { viewportId, renderingEngineId } = enabledElement;\n  const canvasHash = `${viewportId}:${renderingEngineId}`;\n  const svgLayerElement = _getSvgLayer(element);\n\n  // Reset touched\n  Object.keys(state.svgNodeCache[canvasHash]).forEach((cacheKey) => {\n    state.svgNodeCache[canvasHash][cacheKey].touched = false;\n  });\n\n  return {\n    svgLayerElement: svgLayerElement,\n    svgNodeCacheForCanvas: state.svgNodeCache,\n    getSvgNode: getSvgNode.bind(this, canvasHash),\n    appendNode: appendNode.bind(this, svgLayerElement, canvasHash),\n    setNodeTouched: setNodeTouched.bind(this, canvasHash),\n    clearUntouched: clearUntouched.bind(this, svgLayerElement, canvasHash),\n  };\n}\n\n/**\n *\n * @param element\n * @private\n */\nfunction _getSvgLayer(element) {\n  const viewportElement = `.${VIEWPORT_ELEMENT}`;\n  const internalDivElement = element.querySelector(viewportElement);\n\n  // Using :scope to make sure the right svg layer is selected otherwise it\n  // may select one from a nested viewport (eg: AdvancedMagnifyTool).\n  const svgLayer = internalDivElement.querySelector(':scope > .svg-layer');\n\n  return svgLayer;\n}\n\nfunction getSvgNode(canvasHash, cacheKey) {\n  // If state has been reset\n  if (!state.svgNodeCache[canvasHash]) {\n    return;\n  }\n\n  if (state.svgNodeCache[canvasHash][cacheKey]) {\n    return state.svgNodeCache[canvasHash][cacheKey].domRef;\n  }\n}\n\nfunction appendNode(svgLayerElement, canvasHash, svgNode, cacheKey) {\n  // If state has been reset\n  if (!state.svgNodeCache[canvasHash]) {\n    return null;\n  }\n\n  state.svgNodeCache[canvasHash][cacheKey] = {\n    touched: true,\n    domRef: svgNode,\n  };\n\n  svgLayerElement.appendChild(svgNode);\n}\n\nfunction setNodeTouched(canvasHash, cacheKey) {\n  // If state has been reset\n  if (!state.svgNodeCache[canvasHash]) {\n    return;\n  }\n\n  if (state.svgNodeCache[canvasHash][cacheKey]) {\n    state.svgNodeCache[canvasHash][cacheKey].touched = true;\n  }\n}\n\nfunction clearUntouched(svgLayerElement, canvasHash) {\n  // If state has been reset\n  if (!state.svgNodeCache[canvasHash]) {\n    return;\n  }\n\n  Object.keys(state.svgNodeCache[canvasHash]).forEach((cacheKey) => {\n    const cacheEntry = state.svgNodeCache[canvasHash][cacheKey];\n\n    if (!cacheEntry.touched && cacheEntry.domRef) {\n      svgLayerElement.removeChild(cacheEntry.domRef);\n      delete state.svgNodeCache[canvasHash][cacheKey];\n    }\n  });\n}\n\nexport default getSvgDrawingHelper;\n","import getSvgDrawingHelper from './getSvgDrawingHelper';\n\nfunction draw(\n  element: HTMLDivElement,\n  fn: (svgDrawingElement: any) => any\n): void {\n  const svgDrawingHelper = getSvgDrawingHelper(element);\n\n  // Save...\n  fn(svgDrawingHelper);\n  // Restore...\n\n  svgDrawingHelper.clearUntouched();\n}\n\nexport default draw;\n","/**\n * ToolModes - This enum defines the 4 tool states which are available.\n */\nenum ToolModes {\n  /**\n   * Active:\n   * - Can be actively used by mouse/touch events mapped to its `ToolBinding`s.\n   * - Can add data if an annotation tool.\n   * - Can be passively interacted by grabbing a tool or its handles.\n   * - Renders data if the tool has a `renderAnnotation` method.\n   */\n  Active = 'Active',\n  /**\n   * Passive:\n   * - Can be passively interacted by grabbing a tool or its handles.\n   * - Renders data if the tool has a `renderAnnotation` method.\n   */\n  Passive = 'Passive',\n  /**\n   * Enabled:\n   * - Renders data if the tool has a `renderAnnotation` method.\n   */\n  Enabled = 'Enabled',\n  /**\n   * Disabled:\n   * - Annotation does not render.\n   */\n  Disabled = 'Disabled',\n}\n\nexport default ToolModes;\n","import { MouseBindings, ToolModes } from '../../enums';\nimport get from 'lodash.get';\nimport cloneDeep from 'lodash.clonedeep';\nimport {\n  triggerEvent,\n  eventTarget,\n  getRenderingEngine,\n  getRenderingEngines,\n  getEnabledElementByIds,\n  Settings,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\nimport { Events } from '../../enums';\nimport {\n  ToolActivatedEventDetail,\n  ToolModeChangedEventDetail,\n} from '../../types/EventTypes';\nimport { ToolGroupManager, state } from '../index';\nimport {\n  IToolBinding,\n  IToolClassReference,\n  IToolGroup,\n  SetToolBindingsType,\n  ToolOptionsType,\n  ToolConfiguration,\n} from '../../types';\n\nimport { MouseCursor, SVGMouseCursor } from '../../cursors';\nimport { initElementCursor } from '../../cursors/elementCursor';\n\nconst { Active, Passive, Enabled, Disabled } = ToolModes;\n\nconst PRIMARY_BINDINGS = [{ mouseButton: MouseBindings.Primary }];\n\n/**\n * ToolGroup class which is a container for tools and their modes and states.\n * In Cornerstone3DTools, you need to create a tool group in order to use the\n * tools. ToolGroup is a way to share tool configuration, state (enabled, disabled, etc.)\n * across a set of viewports. Tools can set to be activated, enabled or disabled\n * in a toolGroup. You should not directly instantiate a ToolGroup. You need to use\n * ToolGroupManager helpers to create a new toolGroup or get a reference to an existing toolGroup.\n *\n * ```js\n * const toolGroup = csTools.ToolGroupManager.createToolGroup('toolGroupId')\n * ```\n */\nexport default class ToolGroup implements IToolGroup {\n  id: string;\n  viewportsInfo = [];\n  toolOptions = {};\n  currentActivePrimaryToolName: string | null = null;\n  prevActivePrimaryToolName: string | null = null;\n  /**\n   * Options used for restoring a tool\n   */\n  restoreToolOptions = {};\n  _toolInstances = {};\n\n  constructor(id: string) {\n    this.id = id;\n  }\n\n  /**\n   * Get the viewport IDs of all the viewports in the current viewport\n   * @returns An array of viewport IDs.\n   */\n  getViewportIds(): string[] {\n    return this.viewportsInfo.map(({ viewportId }) => viewportId);\n  }\n\n  /**\n   * Returns the toolGroup viewports info which is an array of {viewportId, renderingEngineId}\n   */\n  getViewportsInfo(): Array<Types.IViewportId> {\n    return this.viewportsInfo.slice();\n  }\n\n  /**\n   * Get the tool instance for a given tool name in the toolGroup\n   * @param toolName - The name of the tool.\n   * @returns A tool instance.\n   */\n  public getToolInstance(toolInstanceName: string) {\n    const toolInstance = this._toolInstances[toolInstanceName];\n    if (!toolInstance) {\n      console.warn(\n        `'${toolInstanceName}' is not registered with this toolGroup (${this.id}).`\n      );\n      return;\n    }\n\n    return toolInstance;\n  }\n\n  /**\n   * Retrieves the tool instances associated with this tool group.\n   *\n   * @returns A record containing the tool instances, where the keys are the tool names and the values are the tool instances.\n   */\n  public getToolInstances(): Record<string, any> {\n    return this._toolInstances;\n  }\n\n  /**\n   * Check if a tool is already added to the tool group\n   * @param toolName - Tool name\n   * @returns True if the tool is already added or false otherwise\n   */\n  hasTool(toolName: string): boolean {\n    return !!this._toolInstances[toolName];\n  }\n\n  /**\n   * Add a tool to the tool group with the given tool name and tool configuration.\n   * Note that adding a tool to a tool group will not automatically set the tool\n   * to be active. You must call setToolActive or setToolPassive and other methods\n   * to set the tool to be active or passive or in other states.\n   *\n   * @param toolName - string\n   * @param configuration - Tool configuration objects and a custom statistics calculator if needed\n   */\n  addTool(toolName: string, configuration: ToolConfiguration = {}): void {\n    const toolDefinition = state.tools[toolName];\n    const hasToolName = typeof toolName !== 'undefined' && toolName !== '';\n    const localToolInstance = this.toolOptions[toolName];\n\n    if (!hasToolName) {\n      console.warn(\n        'Tool with configuration did not produce a toolName: ',\n        configuration\n      );\n      return;\n    }\n\n    if (!toolDefinition) {\n      console.warn(\n        `'${toolName}' is not registered with the library. You need to use cornerstoneTools.addTool to register it.`\n      );\n      return;\n    }\n\n    if (localToolInstance) {\n      console.warn(\n        `'${toolName}' is already registered for ToolGroup ${this.id}.`\n      );\n      return;\n    }\n\n    // Should these be renamed higher up, so we don't have to alias?\n    // Wrap in try-catch so 3rd party tools don't explode?\n    const { toolClass: ToolClass } = toolDefinition;\n\n    const toolProps = {\n      name: toolName,\n      toolGroupId: this.id,\n      configuration,\n    };\n\n    const instantiatedTool = new ToolClass(toolProps);\n\n    // API instead of directly exposing schema?\n    // Maybe not here, but feels like a \"must\" for any method outside of the ToolGroup itself\n    this._toolInstances[toolName] = instantiatedTool;\n  }\n\n  public addToolInstance(\n    toolName: string,\n    parentClassName: string,\n    configuration = {}\n  ): void {\n    let ToolClassToUse = state.tools[toolName]\n      ?.toolClass as IToolClassReference;\n\n    if (!ToolClassToUse) {\n      // get parent class constructor\n      const ParentClass = state.tools[parentClassName]\n        .toolClass as IToolClassReference;\n\n      // Todo: could not find a way to make this work with typescript\n      // @ts-ignore\n      class ToolInstance extends ParentClass {}\n      // @ts-ignore\n      ToolInstance.toolName = toolName;\n      // @ts-ignore\n      ToolClassToUse = ToolInstance;\n\n      state.tools[toolName] = {\n        toolClass: ToolInstance as IToolClassReference,\n      };\n    }\n\n    // add the tool to the toolGroup\n    // @ts-ignore\n    this.addTool(ToolClassToUse.toolName, configuration);\n  }\n\n  //   class InstanceTool extends parentClass;\n  // InstanceTool.constructor.toolName = name;\n  // addTool(InstanceTool,configuration)\n  /**\n   * Add a viewport to the ToolGroup. It accepts viewportId and optional\n   * renderingEngineId parameter. If renderingEngineId is not provided,\n   * it checks if cornerstone-core has more than one renderingEngine; If so,\n   * it will throw an error. If cornerstone-core has only one renderingEngine,\n   * it will use that renderingEngine.\n   *\n   * @param viewportId - The unique identifier for the viewport.\n   * @param renderingEngineId - The rendering engine to use.\n   */\n  public addViewport(viewportId: string, renderingEngineId?: string): void {\n    if (typeof viewportId !== 'string') {\n      throw new Error('viewportId must be defined and be a string');\n    }\n\n    const renderingEngines = getRenderingEngines();\n\n    if (!renderingEngineId && renderingEngines.length > 1) {\n      throw new Error(\n        'You must specify a renderingEngineId when there are multiple rendering engines.'\n      );\n    }\n\n    const renderingEngineUIDToUse = renderingEngineId || renderingEngines[0].id;\n\n    // Don't overwrite if it already exists\n    if (\n      !this.viewportsInfo.some(({ viewportId: vpId }) => vpId === viewportId)\n    ) {\n      this.viewportsInfo.push({\n        viewportId,\n        renderingEngineId: renderingEngineUIDToUse,\n      });\n    }\n\n    // Handle the newly added viewport's mouse cursor\n    const toolName = this.getActivePrimaryMouseButtonTool();\n\n    const runtimeSettings = Settings.getRuntimeSettings();\n    if (runtimeSettings.get('useCursors')) {\n      this.setViewportsCursorByToolName(toolName);\n    }\n\n    const eventDetail = {\n      toolGroupId: this.id,\n      viewportId,\n      renderingEngineId: renderingEngineUIDToUse,\n    };\n\n    triggerEvent(eventTarget, Events.TOOLGROUP_VIEWPORT_ADDED, eventDetail);\n  }\n\n  /**\n   * Removes viewport from the toolGroup. If only renderingEngineId is defined\n   * it removes all the viewports with the same renderingEngineId, if viewportId\n   * is also provided, it will remove that specific viewport from the ToolGroup.\n   *\n   * @param renderingEngineId - renderingEngine id\n   * @param viewportId - viewport id\n   */\n  public removeViewports(renderingEngineId: string, viewportId?: string): void {\n    const indices = [];\n\n    this.viewportsInfo.forEach((vpInfo, index) => {\n      let match = false;\n      if (vpInfo.renderingEngineId === renderingEngineId) {\n        match = true;\n\n        if (viewportId && vpInfo.viewportId !== viewportId) {\n          match = false;\n        }\n      }\n      if (match) {\n        indices.push(index);\n      }\n    });\n\n    if (indices.length) {\n      // Note: Traverse the array backwards, such that when we remove items we\n      // do not immediately mess up our loop indicies.\n      for (let i = indices.length - 1; i >= 0; i--) {\n        this.viewportsInfo.splice(indices[i], 1);\n      }\n    }\n\n    const eventDetail = {\n      toolGroupId: this.id,\n      viewportId,\n      renderingEngineId,\n    };\n\n    triggerEvent(eventTarget, Events.TOOLGROUP_VIEWPORT_REMOVED, eventDetail);\n  }\n\n  public setActiveStrategy(toolName: string, strategyName: string) {\n    const toolInstance = this._toolInstances[toolName];\n\n    if (toolInstance === undefined) {\n      console.warn(\n        `Tool ${toolName} not added to toolGroup, can't set tool configuration.`\n      );\n\n      return;\n    }\n\n    toolInstance.setActiveStrategy(strategyName);\n  }\n\n  setToolMode(\n    toolName: string,\n    mode: ToolModes,\n    options = {} as SetToolBindingsType\n  ): void {\n    if (!toolName) {\n      console.warn('setToolMode: toolName must be defined');\n      return;\n    }\n\n    if (mode === ToolModes.Active) {\n      this.setToolActive(\n        toolName,\n        options || this.restoreToolOptions[toolName]\n      );\n      return;\n    }\n\n    if (mode === ToolModes.Passive) {\n      this.setToolPassive(toolName);\n      return;\n    }\n\n    if (mode === ToolModes.Enabled) {\n      this.setToolEnabled(toolName);\n      return;\n    }\n\n    if (mode === ToolModes.Disabled) {\n      this.setToolDisabled(toolName);\n      return;\n    }\n\n    console.warn('setToolMode: mode must be defined');\n  }\n\n  /**\n   * Set the tool mode on the toolGroup to be Active. This means the tool\n   * can be actively used by the defined bindings (e.g., Mouse primary click)\n   *\n   * - Can be actively used by mouse/touch events mapped to its `ToolBinding`s.\n   * - Can add data if an annotation tool.\n   * - Can be passively interacted by grabbing a tool or its handles.\n   * - Renders data if the tool has a `renderAnnotation` method.\n   *\n   * @param toolName - tool name\n   * @param toolBindingsOptions - tool bindings\n   */\n  public setToolActive(\n    toolName: string,\n    toolBindingsOptions = {} as SetToolBindingsType\n  ): void {\n    const toolInstance = this._toolInstances[toolName];\n\n    if (toolInstance === undefined) {\n      console.warn(\n        `Tool ${toolName} not added to toolGroup, can't set tool mode.`\n      );\n\n      return;\n    }\n\n    if (!toolInstance) {\n      console.warn(\n        `'${toolName}' instance ${toolInstance} is not registered with this toolGroup, can't set tool mode.`\n      );\n      return;\n    }\n\n    const prevBindings: IToolBinding[] = this.toolOptions[toolName]\n      ? this.toolOptions[toolName].bindings\n      : [];\n\n    const newBindings = toolBindingsOptions.bindings\n      ? toolBindingsOptions.bindings\n      : [];\n\n    // combine the new bindings with the previous bindings to avoid duplicates\n    // it allows duplicated mouse buttons as long as they don't have same\n    // modifier keys.\n    const bindingsToUse = [...prevBindings, ...newBindings].reduce(\n      (unique, binding) => {\n        const TouchBinding = binding.numTouchPoints !== undefined;\n        const MouseBinding = binding.mouseButton !== undefined;\n\n        if (\n          !unique.some((obj) => hasSameBinding(obj, binding)) &&\n          (TouchBinding || MouseBinding)\n        ) {\n          unique.push(binding);\n        }\n        return unique;\n      },\n      []\n    );\n\n    // We should not override the bindings if they are already set\n    const toolOptions: ToolOptionsType = {\n      bindings: bindingsToUse,\n      mode: Active,\n    };\n\n    this.toolOptions[toolName] = toolOptions;\n    this._toolInstances[toolName].mode = Active;\n\n    // reset the mouse cursor if tool has left click binding\n    const runtimeSettings = Settings.getRuntimeSettings();\n    const useCursor = runtimeSettings.get('useCursors');\n\n    if (this._hasMousePrimaryButtonBinding(toolBindingsOptions) && useCursor) {\n      this.setViewportsCursorByToolName(toolName);\n    } else {\n      // reset to default cursor only if there is no other tool with primary binding\n      const activeToolIdentifier = this.getActivePrimaryMouseButtonTool();\n      if (!activeToolIdentifier && useCursor) {\n        const cursor = MouseCursor.getDefinedCursor('default');\n        this._setCursorForViewports(cursor);\n      }\n    }\n\n    // if it is a primary tool binding, we should store it as the previous primary tool\n    // so that we can restore it when the tool is disabled if desired\n    if (this._hasMousePrimaryButtonBinding(toolBindingsOptions)) {\n      if (this.prevActivePrimaryToolName === null) {\n        this.prevActivePrimaryToolName = toolName;\n      } else {\n        this.prevActivePrimaryToolName = this.currentActivePrimaryToolName;\n      }\n\n      this.currentActivePrimaryToolName = toolName;\n    }\n\n    if (typeof toolInstance.onSetToolActive === 'function') {\n      toolInstance.onSetToolActive();\n    }\n    this._renderViewports();\n\n    const eventDetail: ToolActivatedEventDetail = {\n      toolGroupId: this.id,\n      toolName,\n      toolBindingsOptions,\n    };\n\n    triggerEvent(eventTarget, Events.TOOL_ACTIVATED, eventDetail);\n    this._triggerToolModeChangedEvent(toolName, Active, toolBindingsOptions);\n  }\n\n  /**\n   * Set the tool mode on the toolGroup to be Passive.\n   *\n   * - Can be passively interacted by grabbing a tool or its handles.\n   * - Renders data if the tool has a `renderAnnotation` method.\n   *\n   * @param toolName - tool name\n   * @param options - Options used when setting the tool as passive\n   *  - removeAllBindings: only the primary button bindings are removed but\n   *  if this parameter is set to true all bindings are removed.\n   */\n  public setToolPassive(\n    toolName: string,\n    options?: { removeAllBindings?: boolean | IToolBinding[] }\n  ): void {\n    const toolInstance = this._toolInstances[toolName];\n\n    if (toolInstance === undefined) {\n      console.warn(\n        `Tool ${toolName} not added to toolGroup, can't set tool mode.`\n      );\n\n      return;\n    }\n\n    // We should only remove the primary button bindings and keep\n    // the other ones (Zoom on right click)\n    const prevToolOptions = this.getToolOptions(toolName);\n    const toolOptions = Object.assign(\n      {\n        bindings: prevToolOptions ? prevToolOptions.bindings : [],\n      },\n      prevToolOptions,\n      {\n        mode: Passive,\n      }\n    );\n\n    const matchBindings = Array.isArray(options?.removeAllBindings)\n      ? options.removeAllBindings\n      : this.getDefaultPrimaryBindings();\n\n    // Remove the primary button bindings without modifiers, if they exist\n    toolOptions.bindings = toolOptions.bindings.filter(\n      (binding) =>\n        options?.removeAllBindings !== true &&\n        !matchBindings.some((matchBinding) =>\n          hasSameBinding(binding, matchBinding)\n        )\n      //(binding.mouseButton !== defaultMousePrimary || binding.modifierKey)\n    );\n    // If there are other bindings, set the tool to be active\n    let mode = Passive;\n    if (toolOptions.bindings.length !== 0) {\n      mode = Active;\n      toolOptions.mode = mode;\n    }\n\n    this.toolOptions[toolName] = toolOptions;\n    toolInstance.mode = mode;\n\n    if (typeof toolInstance.onSetToolPassive === 'function') {\n      toolInstance.onSetToolPassive();\n    }\n    this._renderViewports();\n\n    // It would make sense to use `toolInstance.mode` as mode when setting a tool\n    // as passive because it can still be actived in the end but `Passive` must\n    // be used when synchronizing ToolGroups so that other ToolGroups can take the\n    // same action (update tool bindings). Should the event have two different modes\n    // to handle this special case?\n    this._triggerToolModeChangedEvent(toolName, Passive);\n  }\n\n  /**\n   * Set the tool mode on the toolGroup to be Enabled.\n   *\n   * - Renders data if the tool has a `renderAnnotation` method..\n   *\n   * @param toolName - tool name\n   */\n  public setToolEnabled(toolName: string): void {\n    const toolInstance = this._toolInstances[toolName];\n\n    if (toolInstance === undefined) {\n      console.warn(\n        `Tool ${toolName} not added to toolGroup, can't set tool mode.`\n      );\n\n      return;\n    }\n\n    const toolOptions = {\n      bindings: [],\n      mode: Enabled,\n    };\n\n    this.toolOptions[toolName] = toolOptions;\n    toolInstance.mode = Enabled;\n\n    if (typeof toolInstance.onSetToolEnabled === 'function') {\n      toolInstance.onSetToolEnabled();\n    }\n\n    this._renderViewports();\n    this._triggerToolModeChangedEvent(toolName, Enabled);\n  }\n\n  /**\n   * Set the tool mode on the toolGroup to be Disabled.\n   *\n   * - Annotation does not render.\n   *\n   * @param toolName - tool name\n   */\n  public setToolDisabled(toolName: string): void {\n    const toolInstance = this._toolInstances[toolName];\n\n    if (toolInstance === undefined) {\n      console.warn(\n        `Tool ${toolName} not added to toolGroup, can't set tool mode.`\n      );\n\n      return;\n    }\n\n    const toolOptions = {\n      bindings: [],\n      mode: Disabled,\n    };\n\n    this.restoreToolOptions[toolName] = this.toolOptions[toolName];\n\n    this.toolOptions[toolName] = toolOptions;\n    toolInstance.mode = Disabled;\n\n    if (typeof toolInstance.onSetToolDisabled === 'function') {\n      toolInstance.onSetToolDisabled();\n    }\n    this._renderViewports();\n    this._triggerToolModeChangedEvent(toolName, Disabled);\n  }\n\n  /**\n   * Get the options for a given tool\n   * @param toolName - The name of the tool.\n   * @returns the tool options\n   */\n  public getToolOptions(toolName: string): ToolOptionsType {\n    const toolOptionsForTool = this.toolOptions[toolName];\n\n    if (toolOptionsForTool === undefined) {\n      return;\n    }\n\n    return toolOptionsForTool;\n  }\n\n  /**\n   * Find the name of the tool that is Active and has a primary button binding\n   * (Mouse primary click)\n   *\n   * @returns The name of the tool\n   */\n  public getActivePrimaryMouseButtonTool(): string {\n    return Object.keys(this.toolOptions).find((toolName) => {\n      const toolOptions = this.toolOptions[toolName];\n      return (\n        toolOptions.mode === Active &&\n        this._hasMousePrimaryButtonBinding(toolOptions)\n      );\n    });\n  }\n\n  public setViewportsCursorByToolName(\n    toolName: string,\n    strategyName?: string\n  ): void {\n    const cursor = this._getCursor(toolName, strategyName);\n\n    this._setCursorForViewports(cursor);\n  }\n\n  private _getCursor(toolName: string, strategyName?: string): MouseCursor {\n    let cursorName;\n    let cursor;\n\n    if (strategyName) {\n      // Try combinations with strategyName first:\n      // Try with toolName and toolInstanceName first.\n      cursorName = `${toolName}.${strategyName}`;\n\n      cursor = SVGMouseCursor.getDefinedCursor(cursorName, true);\n\n      if (cursor) {\n        return cursor;\n      }\n    }\n\n    // Try with toolName and toolInstanceName first.\n    cursorName = `${toolName}`;\n\n    cursor = SVGMouseCursor.getDefinedCursor(cursorName, true);\n\n    if (cursor) {\n      return cursor;\n    }\n\n    // Try with just toolName.\n    cursorName = toolName;\n\n    cursor = SVGMouseCursor.getDefinedCursor(cursorName, true);\n\n    if (cursor) {\n      return cursor;\n    }\n\n    return MouseCursor.getDefinedCursor('default');\n  }\n\n  _setCursorForViewports(cursor: MouseCursor): void {\n    this.viewportsInfo.forEach(({ renderingEngineId, viewportId }) => {\n      const enabledElement = getEnabledElementByIds(\n        viewportId,\n        renderingEngineId\n      );\n\n      if (!enabledElement) {\n        return;\n      }\n\n      const { viewport } = enabledElement;\n      initElementCursor(viewport.element, cursor);\n    });\n  }\n\n  /**\n   * Set a configuration of a tool by the given toolName.\n   * Use overwrite as true in case you want to overwrite any existing configuration (be careful, depending on config change it might break the annotation flow).\n   */\n  public setToolConfiguration(\n    toolName: string,\n    configuration: ToolConfiguration,\n    overwrite?: boolean\n  ): boolean {\n    const toolInstance = this._toolInstances[toolName];\n    if (toolInstance === undefined) {\n      console.warn(\n        `Tool ${toolName} not present, can't set tool configuration.`\n      );\n      return false;\n    }\n\n    let _configuration;\n\n    if (overwrite) {\n      _configuration = configuration;\n    } else {\n      // We should not deep copy here, it is the job of the application to\n      // deep copy the configuration before passing it to the toolGroup, otherwise\n      // some strange appending behaviour happens for the arrays\n      _configuration = Object.assign(toolInstance.configuration, configuration);\n    }\n\n    toolInstance.configuration = _configuration;\n\n    if (typeof toolInstance.onSetToolConfiguration === 'function') {\n      toolInstance.onSetToolConfiguration();\n    }\n\n    this._renderViewports();\n\n    return true;\n  }\n\n  /**\n   * Returns the default mouse primary button.\n   */\n  public getDefaultMousePrimary(): MouseBindings {\n    return MouseBindings.Primary;\n  }\n\n  /**\n   * Gets an array of bindings that is the full primary binding.\n   * Currently this is just the primary mouse button, but may be extended in the\n   * future to include touch or other binding types.\n   */\n  public getDefaultPrimaryBindings(): IToolBinding[] {\n    return PRIMARY_BINDINGS;\n  }\n\n  /**\n   * Get the configuration of tool. It returns only the config for the given path (in case exists).\n   * ConfigurationPath is the the path of the property to get separated by '.'.\n   *\n   * @example\n   * getToolConfiguration('LengthTool', 'firstLevel.secondLevel')\n   * // get from LengthTool instance the configuration value as being LengthToolInstance[configuration][firstLevel][secondLevel]\n   */\n  getToolConfiguration(toolName: string, configurationPath?: string): any {\n    if (this._toolInstances[toolName] === undefined) {\n      console.warn(\n        `Tool ${toolName} not present, can't set tool configuration.`\n      );\n      return;\n    }\n\n    const _configuration =\n      get(this._toolInstances[toolName].configuration, configurationPath) ||\n      this._toolInstances[toolName].configuration;\n\n    return cloneDeep(_configuration);\n  }\n\n  /**\n   * Gets the name of the previously active tool.\n   * @returns The name of the previously active tool.\n   */\n  public getPrevActivePrimaryToolName(): string {\n    return this.prevActivePrimaryToolName;\n  }\n\n  /**\n   *\n   * @param newToolGroupId - Id of the new (clone) tool group\n   * @param fnToolFilter - Function to filter which tools from this tool group\n   * should be added to the new (clone) one. Example: only annotations tools\n   * can be filtered and added to the new tool group.\n   * @returns A new tool group that is a clone of this one\n   */\n  public clone(\n    newToolGroupId,\n    fnToolFilter: (toolName: string) => void = null\n  ): IToolGroup {\n    let toolGroup = ToolGroupManager.getToolGroup(newToolGroupId);\n\n    if (toolGroup) {\n      console.warn(`ToolGroup ${newToolGroupId} already exists`);\n      return toolGroup;\n    }\n\n    toolGroup = ToolGroupManager.createToolGroup(newToolGroupId);\n    fnToolFilter = fnToolFilter ?? (() => true);\n\n    Object.keys(this._toolInstances)\n      .filter(fnToolFilter)\n      .forEach((toolName) => {\n        const sourceToolInstance = this._toolInstances[toolName];\n        const sourceToolOptions = this.toolOptions[toolName];\n        const sourceToolMode = sourceToolInstance.mode;\n\n        toolGroup.addTool(toolName);\n\n        (toolGroup as unknown as ToolGroup).setToolMode(\n          toolName,\n          sourceToolMode,\n          {\n            bindings: sourceToolOptions.bindings ?? [],\n          }\n        );\n      });\n\n    return toolGroup;\n  }\n\n  /**\n   * Check if the tool binding is set to be primary mouse button.\n   * @param toolOptions - The options for the tool mode.\n   * @returns A boolean value.\n   */\n  private _hasMousePrimaryButtonBinding(toolOptions) {\n    const primaryBindings = this.getDefaultPrimaryBindings();\n    return toolOptions?.bindings?.some((binding) =>\n      primaryBindings.some((primary) => hasSameBinding(binding, primary))\n    );\n  }\n\n  /**\n   * It re-renders the viewports in the toolGroup\n   */\n  private _renderViewports(): void {\n    this.viewportsInfo.forEach(({ renderingEngineId, viewportId }) => {\n      getRenderingEngine(renderingEngineId).renderViewport(viewportId);\n    });\n  }\n\n  /**\n   * Trigger ToolModeChangedEvent when changing the tool mode\n   * @param toolName - Tool name\n   * @param mode - Tool mode\n   * @param toolBindingsOptions - Binding options used when a tool is activated\n   */\n  private _triggerToolModeChangedEvent(\n    toolName: string,\n    mode: ToolModes,\n    toolBindingsOptions?: SetToolBindingsType\n  ): void {\n    const eventDetail: ToolModeChangedEventDetail = {\n      toolGroupId: this.id,\n      toolName,\n      mode,\n      toolBindingsOptions,\n    };\n\n    triggerEvent(eventTarget, Events.TOOL_MODE_CHANGED, eventDetail);\n  }\n}\n\n/**\n * Figure out if the two bindings are the same\n */\nfunction hasSameBinding(\n  binding1: IToolBinding,\n  binding2: IToolBinding\n): boolean {\n  if (binding1.mouseButton !== binding2.mouseButton) {\n    return false;\n  }\n  if (binding1.numTouchPoints !== binding2.numTouchPoints) {\n    return false;\n  }\n\n  return binding1.modifierKey === binding2.modifierKey;\n}\n","import { state } from '../index';\nimport ToolGroup from './ToolGroup';\nimport { IToolGroup } from '../../types';\n\n/**\n * Create a new tool group with the given name. ToolGroups are the new way\n * in Cornerstone3DTools to share tool configuration, state (enabled, disabled, etc.)\n * across a set of viewports.\n *\n * @param toolGroupId - The unique ID of the tool group.\n * @returns A reference to the tool group that was created.\n */\nfunction createToolGroup(toolGroupId: string): IToolGroup | undefined {\n  // Exit early if ID conflict\n  const toolGroupWithIdExists = state.toolGroups.some(\n    (tg) => tg.id === toolGroupId\n  );\n\n  if (toolGroupWithIdExists) {\n    console.warn(`'${toolGroupId}' already exists.`);\n    return;\n  }\n\n  const toolGroup = new ToolGroup(toolGroupId);\n\n  // Update state\n  state.toolGroups.push(toolGroup);\n\n  // Return reference\n  return toolGroup;\n}\n\nexport default createToolGroup;\n","// `BaseManager` or IManager interface for duplicate API between ToolGroup/Synchronizer?\nimport { state as csToolsState } from '../index';\nimport destroyToolGroup from './destroyToolGroup';\n\n// ToolGroups function entirely by their \"state\" being queried and leveraged\n// removing a ToolGroup from state is equivalent to killing it. Calling\n// destroyToolGroup() to make sure the SegmentationDisplayTools\n// have been removed from the toolGroup Viewports. //Todo: this makes more sense\n// to be based on events, but we don't have any toolGroup created/removed events\n\n/**\n * Destroy all tool groups\n */\nfunction destroy(): void {\n  const toolGroups = [...csToolsState.toolGroups];\n\n  for (const toolGroup of toolGroups) {\n    destroyToolGroup(toolGroup.id);\n  }\n\n  csToolsState.toolGroups = [];\n}\n\nexport default destroy;\n","import { state } from '../index';\nimport { removeSegmentationsFromToolGroup } from '../../stateManagement/segmentation';\nimport { segmentationRenderingEngine } from '../../utilities/segmentation/triggerSegmentationRender';\n// ToolGroups function entirely by their \"state\" being queried and leveraged\n// removing a ToolGroup from state is equivalent to killing it\n\n/**\n * Given a tool group Id, destroy the toolGroup. It will also cleanup all segmentations\n * associated with that tool group too\n *\n * @param toolGroupId - The Id of the tool group to be destroyed.\n */\nfunction destroyToolGroup(toolGroupId: string): void {\n  const toolGroupIndex = state.toolGroups.findIndex(\n    (tg) => tg.id === toolGroupId\n  );\n\n  if (toolGroupIndex > -1) {\n    segmentationRenderingEngine.removeToolGroup(toolGroupId);\n    // Todo: this should not happen here)\n    removeSegmentationsFromToolGroup(toolGroupId);\n    state.toolGroups.splice(toolGroupIndex, 1);\n  }\n}\n\nexport default destroyToolGroup;\n","import { state } from '../index';\nimport { IToolGroup } from '../../types';\n\n/**\n * Return the array of tool groups\n * @returns An array of tool groups.\n */\nfunction getAllToolGroups(): Array<IToolGroup> {\n  return state.toolGroups;\n}\n\nexport default getAllToolGroups;\n","import { state } from '../index';\nimport { IToolGroup } from '../../types';\n\n/**\n * Given a tool group Id, return the tool group\n * @param toolGroupId - The Id of the tool group to be retrieved.\n * @returns The tool group that has the same id as the tool group id that was\n * passed in.\n */\nfunction getToolGroup(toolGroupId: string): IToolGroup | undefined {\n  return state.toolGroups.find((s) => s.id === toolGroupId);\n}\n\nexport default getToolGroup;\n","import { state } from '../index';\nimport { IToolGroup } from '../../types';\nimport { ToolModes } from '../../enums';\n\nconst MODES = [ToolModes.Active, ToolModes.Passive, ToolModes.Enabled];\n\n/**\n * Returns the toolGroups that has the given toolName as active, passive\n * or enabled.\n * @param toolName - The name of the tool\n * @returns An array of tool groups.\n */\nfunction getToolGroupsWithToolName(toolName: string): IToolGroup[] | [] {\n  return state.toolGroups.filter(({ toolOptions }) => {\n    const toolGroupToolNames = Object.keys(toolOptions);\n\n    for (let i = 0; i < toolGroupToolNames.length; i++) {\n      if (toolName !== toolGroupToolNames[i]) {\n        continue;\n      }\n\n      /* filter out tools that don't have options */\n      if (!toolOptions[toolName]) {\n        continue;\n      }\n\n      if (MODES.includes(toolOptions[toolName].mode)) {\n        return true;\n      }\n    }\n    return false;\n  });\n}\n\nexport default getToolGroupsWithToolName;\n","import { vec2, vec3 } from 'gl-matrix';\nimport { getEnabledElement, utilities as csUtils } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { getCalibratedLengthUnitsAndScale } from '../../utilities/getCalibratedUnits';\nimport { roundNumber } from '../../utilities';\nimport { AnnotationTool } from '../base';\nimport throttle from '../../utilities/throttle';\nimport {\n  addAnnotation,\n  getAnnotations,\n  removeAnnotation,\n} from '../../stateManagement/annotation/annotationState';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport {\n  triggerAnnotationCompleted,\n  triggerAnnotationModified,\n} from '../../stateManagement/annotation/helpers/state';\nimport {\n  drawLine as drawLineSvg,\n  drawHandles as drawHandlesSvg,\n  drawLinkedTextBox as drawLinkedTextBoxSvg,\n} from '../../drawingSvg';\nimport { state } from '../../store';\nimport { Events } from '../../enums';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport * as lineSegment from '../../utilities/math/line';\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\nimport {\n  resetElementCursor,\n  hideElementCursor,\n} from '../../cursors/elementCursor';\nimport {\n  EventTypes,\n  ToolHandle,\n  TextBoxHandle,\n  PublicToolProps,\n  ToolProps,\n  SVGDrawingHelper,\n} from '../../types';\nimport { BidirectionalAnnotation } from '../../types/ToolSpecificAnnotationTypes';\n\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { StyleSpecifier } from '../../types/AnnotationStyle';\n\nconst { transformWorldToIndex } = csUtils;\n\n/**\n * BidirectionalTool let you draw annotations that measures the length and\n * width at the same time in `mm` unit. It is consisted of two perpendicular lines and\n * a text box. You can use the BidirectionalTool in all planes even in oblique\n * reconstructed planes. Note: annotation tools in cornerstone3DTools exists in the exact location\n * in the physical 3d space, as a result, by default, all annotations that are\n * drawing in the same frameOfReference will get shared between viewports that\n * are in the same frameOfReference.\n *\n * The resulting annotation's data (statistics) and metadata (the\n * state of the viewport while drawing was happening) will get added to the\n * ToolState manager and can be accessed from the ToolState by calling getAnnotations\n * or similar methods.\n *\n * ```js\n * cornerstoneTools.addTool(BidirectionalTool)\n *\n * const toolGroup = ToolGroupManager.createToolGroup('toolGroupId')\n *\n * toolGroup.addTool(BidirectionalTool.toolName)\n *\n * toolGroup.addViewport('viewportId', 'renderingEngineId')\n *\n * toolGroup.setToolActive(BidirectionalTool.toolName, {\n *   bindings: [\n *    {\n *       mouseButton: MouseBindings.Primary, // Left Click\n *     },\n *   ],\n * })\n * ```\n *\n * Read more in the Docs section of the website.\n */\n\nclass BidirectionalTool extends AnnotationTool {\n  static toolName;\n\n  touchDragCallback: any;\n  mouseDragCallback: any;\n  _throttledCalculateCachedStats: any;\n  editData: {\n    annotation: any;\n    viewportIdsToRender: string[];\n    handleIndex?: number;\n    movingTextBox: boolean;\n    newAnnotation?: boolean;\n    hasMoved?: boolean;\n  } | null;\n  isDrawing: boolean;\n  isHandleOutsideImage: boolean;\n  preventHandleOutsideImage: boolean;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        preventHandleOutsideImage: false,\n        getTextLines: defaultGetTextLines,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n\n    this._throttledCalculateCachedStats = throttle(\n      this._calculateCachedStats,\n      100,\n      { trailing: true }\n    );\n  }\n\n  /**\n   * Based on the current position of the mouse and the current imageId to create\n   * a Bidirectional Annotation and stores it in the annotationManager\n   *\n   * @param evt -  EventTypes.NormalizedMouseEventType\n   * @returns The annotation object.\n   *\n   */\n  addNewAnnotation(\n    evt: EventTypes.InteractionEventType\n  ): BidirectionalAnnotation {\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const worldPos = currentPoints.world;\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n\n    this.isDrawing = true;\n\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, viewUp } = camera;\n\n    const referencedImageId = this.getReferencedImageId(\n      viewport,\n      worldPos,\n      viewPlaneNormal,\n      viewUp\n    );\n\n    const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n\n    const annotation: BidirectionalAnnotation = {\n      highlighted: true,\n      invalidated: true,\n      metadata: {\n        toolName: this.getToolName(),\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\n        viewUp: <Types.Point3>[...viewUp],\n        FrameOfReferenceUID,\n        referencedImageId,\n      },\n      data: {\n        handles: {\n          points: [\n            // long\n            <Types.Point3>[...worldPos],\n            <Types.Point3>[...worldPos],\n            // short\n            <Types.Point3>[...worldPos],\n            <Types.Point3>[...worldPos],\n          ],\n          textBox: {\n            hasMoved: false,\n            worldPosition: <Types.Point3>[0, 0, 0],\n            worldBoundingBox: {\n              topLeft: <Types.Point3>[0, 0, 0],\n              topRight: <Types.Point3>[0, 0, 0],\n              bottomLeft: <Types.Point3>[0, 0, 0],\n              bottomRight: <Types.Point3>[0, 0, 0],\n            },\n          },\n          activeHandleIndex: null,\n        },\n        label: '',\n        cachedStats: {},\n      },\n    };\n\n    addAnnotation(annotation, element);\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      handleIndex: 1,\n      movingTextBox: false,\n      newAnnotation: true,\n      hasMoved: false,\n    };\n    this._activateDraw(element);\n\n    hideElementCursor(element);\n\n    evt.preventDefault();\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    return annotation;\n  }\n\n  /**\n   * It returns if the canvas point is near the provided annotation in the provided\n   * element or not. A proximity is passed to the function to determine the\n   * proximity of the point to the annotation in number of pixels.\n   *\n   * @param element - HTML Element\n   * @param annotation - Annotation\n   * @param canvasCoords - Canvas coordinates\n   * @param proximity - Proximity to tool to consider\n   * @returns Boolean, whether the canvas point is near tool\n   */\n  isPointNearTool = (\n    element: HTMLDivElement,\n    annotation: BidirectionalAnnotation,\n    canvasCoords: Types.Point2,\n    proximity: number\n  ): boolean => {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const { data } = annotation;\n    const { points } = data.handles;\n\n    // Check long axis\n    let canvasPoint1 = viewport.worldToCanvas(points[0]);\n    let canvasPoint2 = viewport.worldToCanvas(points[1]);\n\n    let line = {\n      start: {\n        x: canvasPoint1[0],\n        y: canvasPoint1[1],\n      },\n      end: {\n        x: canvasPoint2[0],\n        y: canvasPoint2[1],\n      },\n    };\n\n    let distanceToPoint = lineSegment.distanceToPoint(\n      [line.start.x, line.start.y],\n      [line.end.x, line.end.y],\n      [canvasCoords[0], canvasCoords[1]]\n    );\n\n    if (distanceToPoint <= proximity) {\n      return true;\n    }\n\n    // Check short axis\n    canvasPoint1 = viewport.worldToCanvas(points[2]);\n    canvasPoint2 = viewport.worldToCanvas(points[3]);\n\n    line = {\n      start: {\n        x: canvasPoint1[0],\n        y: canvasPoint1[1],\n      },\n      end: {\n        x: canvasPoint2[0],\n        y: canvasPoint2[1],\n      },\n    };\n\n    distanceToPoint = lineSegment.distanceToPoint(\n      [line.start.x, line.start.y],\n      [line.end.x, line.end.y],\n      [canvasCoords[0], canvasCoords[1]]\n    );\n\n    if (distanceToPoint <= proximity) {\n      return true;\n    }\n\n    return false;\n  };\n\n  /**\n   * Handles the toolSelected callback for bidirectional tool\n   * @param evt - EventTypes.MouseDownEventType\n   * @param annotation - Bidirectional annotation\n   * @param interactionType - interaction type (mouse, touch)\n   */\n  toolSelectedCallback = (\n    evt: EventTypes.InteractionEventType,\n    annotation: BidirectionalAnnotation\n  ): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    annotation.highlighted = true;\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      movingTextBox: false,\n    };\n\n    this._activateModify(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    hideElementCursor(element);\n\n    evt.preventDefault();\n  };\n\n  /**\n   * Executes the callback for when mouse has selected a handle (anchor point) of\n   * the bidirectional tool or when the text box has been selected.\n   *\n   * @param evt - EventTypes.MouseDownEventType\n   * @param annotation - Bidirectional annotation\n   * @param handle - Handle index or selected textBox information\n   * @param interactionType - interaction type (mouse, touch)\n   */\n  handleSelectedCallback = (\n    evt: EventTypes.InteractionEventType,\n    annotation: BidirectionalAnnotation,\n    handle: ToolHandle\n  ): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const data = annotation.data;\n\n    annotation.highlighted = true;\n\n    let movingTextBox = false;\n    let handleIndex;\n\n    if ((handle as TextBoxHandle).worldPosition) {\n      movingTextBox = true;\n    } else {\n      handleIndex = data.handles.points.findIndex((p) => p === handle);\n    }\n\n    // Find viewports to render on drag.\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    hideElementCursor(element);\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      handleIndex,\n      movingTextBox,\n    };\n    this._activateModify(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    evt.preventDefault();\n  };\n\n  /**\n   * Handles the mouse up action for the bidirectional tool. It can be at the end\n   * of the annotation drawing (MouseUpEventType) or when the user clicks and release\n   * the mouse button instantly which let to the annotation to draw without holding\n   * the mouse button (MouseClickEventType).\n   *\n   * @param evt - mouse up or mouse click event types\n   */\n  _endCallback = (evt: EventTypes.InteractionEventType): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, viewportIdsToRender, newAnnotation, hasMoved } =\n      this.editData;\n    const { data } = annotation;\n\n    if (newAnnotation && !hasMoved) {\n      return;\n    }\n\n    data.handles.activeHandleIndex = null;\n\n    this._deactivateModify(element);\n    this._deactivateDraw(element);\n\n    resetElementCursor(element);\n\n    const { renderingEngine } = getEnabledElement(element);\n\n    if (this.editData.handleIndex !== undefined) {\n      const { points } = data.handles;\n      const firstLineSegmentLength = vec3.distance(points[0], points[1]);\n      const secondLineSegmentLength = vec3.distance(points[2], points[3]);\n\n      if (secondLineSegmentLength > firstLineSegmentLength) {\n        // Switch points so [0,1] is the long axis and [2,3] is the short axis.\n\n        const longAxis = [[...points[2]], [...points[3]]];\n\n        const shortAxisPoint0 = [...points[0]];\n        const shortAxisPoint1 = [...points[1]];\n\n        // shortAxis[0->1] should be perpendicular (counter-clockwise) to longAxis[0->1]\n        const longAxisVector = vec2.create();\n\n        vec2.set(\n          longAxisVector,\n          longAxis[1][0] - longAxis[0][0],\n          longAxis[1][1] - longAxis[1][0]\n        );\n\n        const counterClockWisePerpendicularToLongAxis = vec2.create();\n\n        vec2.set(\n          counterClockWisePerpendicularToLongAxis,\n          -longAxisVector[1],\n          longAxisVector[0]\n        );\n\n        const currentShortAxisVector = vec2.create();\n\n        vec2.set(\n          currentShortAxisVector,\n          shortAxisPoint1[0] - shortAxisPoint0[0],\n          shortAxisPoint1[1] - shortAxisPoint0[0]\n        );\n\n        let shortAxis;\n\n        if (\n          vec2.dot(\n            currentShortAxisVector,\n            counterClockWisePerpendicularToLongAxis\n          ) > 0\n        ) {\n          shortAxis = [shortAxisPoint0, shortAxisPoint1];\n        } else {\n          shortAxis = [shortAxisPoint1, shortAxisPoint0];\n        }\n\n        data.handles.points = [\n          longAxis[0],\n          longAxis[1],\n          shortAxis[0],\n          shortAxis[1],\n        ];\n      }\n    }\n\n    if (\n      this.isHandleOutsideImage &&\n      this.configuration.preventHandleOutsideImage\n    ) {\n      removeAnnotation(annotation.annotationUID);\n    }\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    if (newAnnotation) {\n      triggerAnnotationCompleted(annotation);\n    }\n\n    this.editData = null;\n    this.isDrawing = false;\n  };\n\n  /**\n   * @param evt - mouse move event type or mouse drag\n   */\n  _dragDrawCallback = (evt: EventTypes.InteractionEventType): void => {\n    this.isDrawing = true;\n\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine, viewport } = enabledElement;\n    const { worldToCanvas } = viewport;\n    const { annotation, viewportIdsToRender, handleIndex } = this.editData;\n    const { data } = annotation;\n\n    const worldPos = currentPoints.world;\n\n    // Update first move handle\n    data.handles.points[handleIndex] = [...worldPos];\n\n    const canvasCoordPoints = data.handles.points.map(worldToCanvas);\n\n    const canvasCoords = {\n      longLineSegment: {\n        start: {\n          x: canvasCoordPoints[0][0],\n          y: canvasCoordPoints[0][1],\n        },\n        end: {\n          x: canvasCoordPoints[1][0],\n          y: canvasCoordPoints[1][1],\n        },\n      },\n      shortLineSegment: {\n        start: {\n          x: canvasCoordPoints[2][0],\n          y: canvasCoordPoints[2][1],\n        },\n        end: {\n          x: canvasCoordPoints[3][0],\n          y: canvasCoordPoints[3][1],\n        },\n      },\n    };\n\n    // ~~ calculate worldPos of our short axis handles\n    // short axis is perpendicular to long axis, and we set its length to be 2/3 of long axis\n    // (meaning each)\n    const dist = vec2.distance(canvasCoordPoints[0], canvasCoordPoints[1]);\n\n    const shortAxisDistFromCenter = dist / 3;\n    // Calculate long line's incline\n    const dx =\n      canvasCoords.longLineSegment.start.x - canvasCoords.longLineSegment.end.x;\n    const dy =\n      canvasCoords.longLineSegment.start.y - canvasCoords.longLineSegment.end.y;\n    const length = Math.sqrt(dx * dx + dy * dy);\n    const vectorX = dx / length;\n    const vectorY = dy / length;\n    // middle point between long line segment's points\n    const xMid =\n      (canvasCoords.longLineSegment.start.x +\n        canvasCoords.longLineSegment.end.x) /\n      2;\n    const yMid =\n      (canvasCoords.longLineSegment.start.y +\n        canvasCoords.longLineSegment.end.y) /\n      2;\n    // short points 1/3 distance from center of long points\n    const startX = xMid + shortAxisDistFromCenter * vectorY;\n    const startY = yMid - shortAxisDistFromCenter * vectorX;\n    const endX = xMid - shortAxisDistFromCenter * vectorY;\n    const endY = yMid + shortAxisDistFromCenter * vectorX;\n\n    // Update perpendicular line segment's points\n    data.handles.points[2] = viewport.canvasToWorld([startX, startY]);\n    data.handles.points[3] = viewport.canvasToWorld([endX, endY]);\n\n    annotation.invalidated = true;\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    this.editData.hasMoved = true;\n  };\n\n  /**\n   * Mouse drag to edit annotation callback\n   * @param evt - mouse drag event\n   */\n  _dragModifyCallback = (evt: EventTypes.InteractionEventType): void => {\n    this.isDrawing = true;\n\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n    const { annotation, viewportIdsToRender, handleIndex, movingTextBox } =\n      this.editData;\n    const { data } = annotation;\n    if (movingTextBox) {\n      const { deltaPoints } = eventDetail;\n      const worldPosDelta = deltaPoints.world;\n\n      const { textBox } = data.handles;\n      const { worldPosition } = textBox;\n\n      worldPosition[0] += worldPosDelta[0];\n      worldPosition[1] += worldPosDelta[1];\n      worldPosition[2] += worldPosDelta[2];\n\n      textBox.hasMoved = true;\n    } else if (handleIndex === undefined) {\n      // Moving tool\n      const { deltaPoints } = eventDetail;\n      const worldPosDelta = deltaPoints.world;\n      const points = data.handles.points;\n\n      points.forEach((point) => {\n        point[0] += worldPosDelta[0];\n        point[1] += worldPosDelta[1];\n        point[2] += worldPosDelta[2];\n      });\n      annotation.invalidated = true;\n    } else {\n      this._dragModifyHandle(evt);\n      annotation.invalidated = true;\n    }\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  };\n\n  /**\n   * Mouse dragging a handle callback\n   * @param evt - mouse drag event\n   */\n  _dragModifyHandle = (evt: EventTypes.InteractionEventType): void => {\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const { annotation, handleIndex: movingHandleIndex } = this.editData;\n    const { data } = annotation;\n\n    // Moving handle\n    const worldPos = currentPoints.world;\n    const canvasCoordHandlesCurrent = [\n      viewport.worldToCanvas(data.handles.points[0]),\n      viewport.worldToCanvas(data.handles.points[1]),\n      viewport.worldToCanvas(data.handles.points[2]),\n      viewport.worldToCanvas(data.handles.points[3]),\n    ];\n\n    const firstLineSegment = {\n      start: {\n        x: canvasCoordHandlesCurrent[0][0],\n        y: canvasCoordHandlesCurrent[0][1],\n      },\n      end: {\n        x: canvasCoordHandlesCurrent[1][0],\n        y: canvasCoordHandlesCurrent[1][1],\n      },\n    };\n    const secondLineSegment = {\n      start: {\n        x: canvasCoordHandlesCurrent[2][0],\n        y: canvasCoordHandlesCurrent[2][1],\n      },\n      end: {\n        x: canvasCoordHandlesCurrent[3][0],\n        y: canvasCoordHandlesCurrent[3][1],\n      },\n    };\n\n    // Handle we've selected's proposed point\n    const proposedPoint = <Types.Point3>[...worldPos];\n    const proposedCanvasCoord = viewport.worldToCanvas(proposedPoint);\n\n    if (movingHandleIndex === 0 || movingHandleIndex === 1) {\n      const fixedHandleIndex = movingHandleIndex === 0 ? 1 : 0;\n\n      const fixedHandleCanvasCoord =\n        canvasCoordHandlesCurrent[fixedHandleIndex];\n\n      const fixedHandleToProposedCoordVec = vec2.set(\n        vec2.create(),\n        proposedCanvasCoord[0] - fixedHandleCanvasCoord[0],\n        proposedCanvasCoord[1] - fixedHandleCanvasCoord[1]\n      );\n\n      const fixedHandleToOldCoordVec = vec2.set(\n        vec2.create(),\n        canvasCoordHandlesCurrent[movingHandleIndex][0] -\n          fixedHandleCanvasCoord[0],\n        canvasCoordHandlesCurrent[movingHandleIndex][1] -\n          fixedHandleCanvasCoord[1]\n      );\n\n      // normalize vector\n      vec2.normalize(\n        fixedHandleToProposedCoordVec,\n        fixedHandleToProposedCoordVec\n      );\n      vec2.normalize(fixedHandleToOldCoordVec, fixedHandleToOldCoordVec);\n\n      // Check whether this\n      const proposedFirstLineSegment = {\n        start: {\n          x: fixedHandleCanvasCoord[0],\n          y: fixedHandleCanvasCoord[1],\n        },\n        end: {\n          x: proposedCanvasCoord[0],\n          y: proposedCanvasCoord[1],\n        },\n      };\n\n      // Note: this is the case when we are modifying the long axis line segment\n      // and we make it shorter and shorter until its second half size becomes zero\n      // which basically means that any more modification would make the long axis\n      // second half disappear. In this case, we just bail out and do not update\n      // since we don't want to disrupt the bidirectional shape.\n      if (\n        this._movingLongAxisWouldPutItThroughShortAxis(\n          proposedFirstLineSegment,\n          secondLineSegment\n        )\n      ) {\n        return;\n      }\n\n      const centerOfRotation = fixedHandleCanvasCoord;\n\n      const angle = this._getSignedAngle(\n        fixedHandleToOldCoordVec,\n        fixedHandleToProposedCoordVec\n      );\n\n      // rotate handles around the center of rotation, first translate to origin,\n      // then rotate, then translate back\n      let firstPointX = canvasCoordHandlesCurrent[2][0];\n      let firstPointY = canvasCoordHandlesCurrent[2][1];\n\n      let secondPointX = canvasCoordHandlesCurrent[3][0];\n      let secondPointY = canvasCoordHandlesCurrent[3][1];\n\n      // translate to origin\n      firstPointX -= centerOfRotation[0];\n      firstPointY -= centerOfRotation[1];\n\n      secondPointX -= centerOfRotation[0];\n      secondPointY -= centerOfRotation[1];\n\n      // rotate\n      const rotatedFirstPoint =\n        firstPointX * Math.cos(angle) - firstPointY * Math.sin(angle);\n      const rotatedFirstPointY =\n        firstPointX * Math.sin(angle) + firstPointY * Math.cos(angle);\n\n      const rotatedSecondPoint =\n        secondPointX * Math.cos(angle) - secondPointY * Math.sin(angle);\n      const rotatedSecondPointY =\n        secondPointX * Math.sin(angle) + secondPointY * Math.cos(angle);\n\n      // translate back\n      firstPointX = rotatedFirstPoint + centerOfRotation[0];\n      firstPointY = rotatedFirstPointY + centerOfRotation[1];\n\n      secondPointX = rotatedSecondPoint + centerOfRotation[0];\n      secondPointY = rotatedSecondPointY + centerOfRotation[1];\n\n      // update handles\n      const newFirstPoint = viewport.canvasToWorld([firstPointX, firstPointY]);\n      const newSecondPoint = viewport.canvasToWorld([\n        secondPointX,\n        secondPointY,\n      ]);\n\n      // the fixed handle is the one that is not being moved so we\n      // don't need to update it\n      data.handles.points[movingHandleIndex] = proposedPoint;\n      data.handles.points[2] = newFirstPoint;\n      data.handles.points[3] = newSecondPoint;\n    } else {\n      // Translation manipulator\n      const translateHandleIndex = movingHandleIndex === 2 ? 3 : 2;\n\n      const canvasCoordsCurrent = {\n        longLineSegment: {\n          start: firstLineSegment.start,\n          end: firstLineSegment.end,\n        },\n        shortLineSegment: {\n          start: secondLineSegment.start,\n          end: secondLineSegment.end,\n        },\n      };\n\n      const longLineSegmentVec = vec2.subtract(\n        vec2.create(),\n        [\n          canvasCoordsCurrent.longLineSegment.end.x,\n          canvasCoordsCurrent.longLineSegment.end.y,\n        ],\n        [\n          canvasCoordsCurrent.longLineSegment.start.x,\n          canvasCoordsCurrent.longLineSegment.start.y,\n        ]\n      );\n\n      const longLineSegmentVecNormalized = vec2.normalize(\n        vec2.create(),\n        longLineSegmentVec\n      );\n\n      const proposedToCurrentVec = vec2.subtract(\n        vec2.create(),\n        [proposedCanvasCoord[0], proposedCanvasCoord[1]],\n        [\n          canvasCoordHandlesCurrent[movingHandleIndex][0],\n          canvasCoordHandlesCurrent[movingHandleIndex][1],\n        ]\n      );\n\n      const movementLength = vec2.length(proposedToCurrentVec);\n\n      const angle = this._getSignedAngle(\n        longLineSegmentVecNormalized,\n        proposedToCurrentVec\n      );\n\n      const movementAlongLineSegmentLength = Math.cos(angle) * movementLength;\n\n      const newTranslatedPoint = vec2.scaleAndAdd(\n        vec2.create(),\n        [\n          canvasCoordHandlesCurrent[translateHandleIndex][0],\n          canvasCoordHandlesCurrent[translateHandleIndex][1],\n        ],\n        longLineSegmentVecNormalized,\n        movementAlongLineSegmentLength\n      );\n\n      // don't update if it passes through the other line segment\n      if (\n        this._movingLongAxisWouldPutItThroughShortAxis(\n          {\n            start: {\n              x: proposedCanvasCoord[0],\n              y: proposedCanvasCoord[1],\n            },\n            end: {\n              x: newTranslatedPoint[0],\n              y: newTranslatedPoint[1],\n            },\n          },\n          {\n            start: {\n              x: canvasCoordsCurrent.longLineSegment.start.x,\n              y: canvasCoordsCurrent.longLineSegment.start.y,\n            },\n            end: {\n              x: canvasCoordsCurrent.longLineSegment.end.x,\n              y: canvasCoordsCurrent.longLineSegment.end.y,\n            },\n          }\n        )\n      ) {\n        return;\n      }\n\n      const intersectionPoint = lineSegment.intersectLine(\n        [proposedCanvasCoord[0], proposedCanvasCoord[1]],\n        [newTranslatedPoint[0], newTranslatedPoint[1]],\n        [firstLineSegment.start.x, firstLineSegment.start.y],\n        [firstLineSegment.end.x, firstLineSegment.end.y]\n      );\n\n      // don't update if it doesn't intersect\n      if (!intersectionPoint) {\n        return;\n      }\n\n      data.handles.points[translateHandleIndex] = viewport.canvasToWorld(\n        newTranslatedPoint as Types.Point2\n      );\n      data.handles.points[movingHandleIndex] = proposedPoint;\n    }\n  };\n\n  /**\n   * Cancels an ongoing drawing of a bidirectional annotation\n   * @param element - HTML Element\n   */\n  cancel = (element: HTMLDivElement) => {\n    // If it is mid-draw or mid-modify\n    if (this.isDrawing) {\n      this.isDrawing = false;\n      this._deactivateDraw(element);\n      this._deactivateModify(element);\n      resetElementCursor(element);\n\n      const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n      const { data } = annotation;\n\n      annotation.highlighted = false;\n      data.handles.activeHandleIndex = null;\n\n      const { renderingEngine } = getEnabledElement(element);\n\n      triggerAnnotationRenderForViewportIds(\n        renderingEngine,\n        viewportIdsToRender\n      );\n\n      if (newAnnotation) {\n        triggerAnnotationCompleted(annotation);\n      }\n\n      this.editData = null;\n      return annotation.annotationUID;\n    }\n  };\n\n  _activateDraw = (element) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(Events.MOUSE_UP, this._endCallback);\n    element.addEventListener(Events.MOUSE_DRAG, this._dragDrawCallback);\n    element.addEventListener(Events.MOUSE_MOVE, this._dragDrawCallback);\n    element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.addEventListener(\n      Events.TOUCH_TAP,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.TOUCH_END,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.TOUCH_DRAG,\n      this._dragDrawCallback as EventListener\n    );\n  };\n\n  _deactivateDraw = (element) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n    element.removeEventListener(Events.MOUSE_DRAG, this._dragDrawCallback);\n    element.removeEventListener(Events.MOUSE_MOVE, this._dragDrawCallback);\n    element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.removeEventListener(\n      Events.TOUCH_TAP,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_END,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_DRAG,\n      this._dragDrawCallback as EventListener\n    );\n  };\n\n  _activateModify = (element) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(Events.MOUSE_UP, this._endCallback);\n    element.addEventListener(Events.MOUSE_DRAG, this._dragModifyCallback);\n    element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.addEventListener(\n      Events.TOUCH_END,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.TOUCH_DRAG,\n      this._dragModifyCallback as EventListener\n    );\n    element.addEventListener(\n      Events.TOUCH_TAP,\n      this._endCallback as EventListener\n    );\n  };\n\n  _deactivateModify = (element) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n    element.removeEventListener(Events.MOUSE_DRAG, this._dragModifyCallback);\n    element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.removeEventListener(\n      Events.TOUCH_END,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_DRAG,\n      this._dragModifyCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_TAP,\n      this._endCallback as EventListener\n    );\n  };\n\n  /**\n   * it is used to draw the bidirectional annotation in each\n   * request animation frame. It calculates the updated cached statistics if\n   * data is invalidated and cache it.\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    let renderStatus = true;\n    const { viewport } = enabledElement;\n    const { element } = viewport;\n    let annotations = getAnnotations(this.getToolName(), element);\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    annotations = this.filterInteractableAnnotationsForElement(\n      element,\n      annotations\n    );\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    const targetId = this.getTargetId(viewport);\n\n    const renderingEngine = viewport.getRenderingEngine();\n\n    const styleSpecifier: StyleSpecifier = {\n      toolGroupId: this.toolGroupId,\n      toolName: this.getToolName(),\n      viewportId: enabledElement.viewport.id,\n    };\n\n    for (let i = 0; i < annotations.length; i++) {\n      const annotation = annotations[i] as BidirectionalAnnotation;\n      const { annotationUID, data } = annotation;\n      const { points, activeHandleIndex } = data.handles;\n      const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n\n      styleSpecifier.annotationUID = annotationUID;\n\n      const { color, lineWidth, lineDash, shadow } = this.getAnnotationStyle({\n        annotation,\n        styleSpecifier,\n      });\n\n      // If cachedStats does not exist, or the unit is missing (as part of import/hydration etc.),\n      // force to recalculate the stats from the points\n      if (\n        !data.cachedStats[targetId] ||\n        data.cachedStats[targetId].unit == null\n      ) {\n        data.cachedStats[targetId] = {\n          length: null,\n          width: null,\n          unit: null,\n        };\n\n        this._calculateCachedStats(annotation, renderingEngine, enabledElement);\n      } else if (annotation.invalidated) {\n        this._throttledCalculateCachedStats(\n          annotation,\n          renderingEngine,\n          enabledElement\n        );\n      }\n\n      // If rendering engine has been destroyed while rendering\n      if (!viewport.getRenderingEngine()) {\n        console.warn('Rendering Engine has been destroyed');\n        return renderStatus;\n      }\n\n      let activeHandleCanvasCoords;\n\n      if (!isAnnotationVisible(annotationUID)) {\n        continue;\n      }\n\n      if (\n        !isAnnotationLocked(annotation) &&\n        !this.editData &&\n        activeHandleIndex !== null\n      ) {\n        // Not locked or creating and hovering over handle, so render handle.\n        activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n      }\n\n      if (activeHandleCanvasCoords) {\n        const handleGroupUID = '0';\n\n        drawHandlesSvg(\n          svgDrawingHelper,\n          annotationUID,\n          handleGroupUID,\n          activeHandleCanvasCoords,\n          {\n            color,\n          }\n        );\n      }\n\n      const dataId1 = `${annotationUID}-line-1`;\n      const dataId2 = `${annotationUID}-line-2`;\n\n      const lineUID = '0';\n      drawLineSvg(\n        svgDrawingHelper,\n        annotationUID,\n        lineUID,\n        canvasCoordinates[0],\n        canvasCoordinates[1],\n        {\n          color,\n          lineDash,\n          lineWidth,\n          shadow,\n        },\n        dataId1\n      );\n\n      const secondLineUID = '1';\n      drawLineSvg(\n        svgDrawingHelper,\n        annotationUID,\n        secondLineUID,\n        canvasCoordinates[2],\n        canvasCoordinates[3],\n        {\n          color,\n          lineDash,\n          lineWidth,\n          shadow,\n        },\n        dataId2\n      );\n\n      renderStatus = true;\n\n      const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n      if (!options.visibility) {\n        data.handles.textBox = {\n          hasMoved: false,\n          worldPosition: <Types.Point3>[0, 0, 0],\n          worldBoundingBox: {\n            topLeft: <Types.Point3>[0, 0, 0],\n            topRight: <Types.Point3>[0, 0, 0],\n            bottomLeft: <Types.Point3>[0, 0, 0],\n            bottomRight: <Types.Point3>[0, 0, 0],\n          },\n        };\n        continue;\n      }\n\n      const textLines = this.configuration.getTextLines(data, targetId);\n      if (!textLines || textLines.length === 0) {\n        continue;\n      }\n\n      let canvasTextBoxCoords;\n\n      if (!data.handles.textBox.hasMoved) {\n        canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCoordinates);\n\n        data.handles.textBox.worldPosition =\n          viewport.canvasToWorld(canvasTextBoxCoords);\n      }\n\n      const textBoxPosition = viewport.worldToCanvas(\n        data.handles.textBox.worldPosition\n      );\n\n      const textBoxUID = '1';\n      const boundingBox = drawLinkedTextBoxSvg(\n        svgDrawingHelper,\n        annotationUID,\n        textBoxUID,\n        textLines,\n        textBoxPosition,\n        canvasCoordinates,\n        {},\n        options\n      );\n\n      const { x: left, y: top, width, height } = boundingBox;\n\n      data.handles.textBox.worldBoundingBox = {\n        topLeft: viewport.canvasToWorld([left, top]),\n        topRight: viewport.canvasToWorld([left + width, top]),\n        bottomLeft: viewport.canvasToWorld([left, top + height]),\n        bottomRight: viewport.canvasToWorld([left + width, top + height]),\n      };\n    }\n\n    return renderStatus;\n  };\n\n  _movingLongAxisWouldPutItThroughShortAxis = (\n    firstLineSegment,\n    secondLineSegment\n  ) => {\n    const vectorInSecondLineDirection = vec2.create();\n\n    vec2.set(\n      vectorInSecondLineDirection,\n      secondLineSegment.end.x - secondLineSegment.start.x,\n      secondLineSegment.end.y - secondLineSegment.start.y\n    );\n\n    vec2.normalize(vectorInSecondLineDirection, vectorInSecondLineDirection);\n\n    const extendedSecondLineSegment = {\n      start: {\n        x: secondLineSegment.start.x - vectorInSecondLineDirection[0] * 10,\n        y: secondLineSegment.start.y - vectorInSecondLineDirection[1] * 10,\n      },\n      end: {\n        x: secondLineSegment.end.x + vectorInSecondLineDirection[0] * 10,\n        y: secondLineSegment.end.y + vectorInSecondLineDirection[1] * 10,\n      },\n    };\n\n    // Add some buffer in the secondLineSegment when finding the proposedIntersectionPoint\n    // Of points to stop us getting stack when rotating quickly.\n\n    const proposedIntersectionPoint = lineSegment.intersectLine(\n      [extendedSecondLineSegment.start.x, extendedSecondLineSegment.start.y],\n      [extendedSecondLineSegment.end.x, extendedSecondLineSegment.end.y],\n      [firstLineSegment.start.x, firstLineSegment.start.y],\n      [firstLineSegment.end.x, firstLineSegment.end.y]\n    );\n\n    const wouldPutThroughShortAxis = !proposedIntersectionPoint;\n\n    return wouldPutThroughShortAxis;\n  };\n\n  _calculateLength(pos1, pos2) {\n    const dx = pos1[0] - pos2[0];\n    const dy = pos1[1] - pos2[1];\n    const dz = pos1[2] - pos2[2];\n\n    return Math.sqrt(dx * dx + dy * dy + dz * dz);\n  }\n\n  _calculateCachedStats = (annotation, renderingEngine, enabledElement) => {\n    const { data } = annotation;\n    const { element } = enabledElement.viewport;\n\n    const worldPos1 = data.handles.points[0];\n    const worldPos2 = data.handles.points[1];\n    const worldPos3 = data.handles.points[2];\n    const worldPos4 = data.handles.points[3];\n\n    const { cachedStats } = data;\n    const targetIds = Object.keys(cachedStats);\n\n    for (let i = 0; i < targetIds.length; i++) {\n      const targetId = targetIds[i];\n\n      const image = this.getTargetIdImage(targetId, renderingEngine);\n\n      // If image does not exists for the targetId, skip. This can be due\n      // to various reasons such as if the target was a volumeViewport, and\n      // the volumeViewport has been decached in the meantime.\n      if (!image) {\n        continue;\n      }\n\n      const { imageData, dimensions } = image;\n      const index1 = transformWorldToIndex(imageData, worldPos1);\n      const index2 = transformWorldToIndex(imageData, worldPos2);\n      const index3 = transformWorldToIndex(imageData, worldPos3);\n      const index4 = transformWorldToIndex(imageData, worldPos4);\n\n      const handles1 = [index1, index2];\n      const handles2 = [index3, index4];\n\n      const { scale: scale1, units: units1 } = getCalibratedLengthUnitsAndScale(\n        image,\n        handles1\n      );\n\n      const { scale: scale2, units: units2 } = getCalibratedLengthUnitsAndScale(\n        image,\n        handles2\n      );\n\n      const dist1 = this._calculateLength(worldPos1, worldPos2) / scale1;\n      const dist2 = this._calculateLength(worldPos3, worldPos4) / scale2;\n      const length = dist1 > dist2 ? dist1 : dist2;\n      const width = dist1 > dist2 ? dist2 : dist1;\n\n      const lengthUnit = dist1 > dist2 ? units1 : units2;\n      const widthUnit = dist1 > dist2 ? units2 : units1;\n\n      this._isInsideVolume(index1, index2, index3, index4, dimensions)\n        ? (this.isHandleOutsideImage = false)\n        : (this.isHandleOutsideImage = true);\n\n      cachedStats[targetId] = {\n        length,\n        width,\n        unit: units1,\n        lengthUnit,\n        widthUnit,\n      };\n    }\n\n    annotation.invalidated = false;\n\n    // Dispatching annotation modified\n    triggerAnnotationModified(annotation, element);\n\n    return cachedStats;\n  };\n\n  _isInsideVolume = (index1, index2, index3, index4, dimensions): boolean => {\n    return (\n      csUtils.indexWithinDimensions(index1, dimensions) &&\n      csUtils.indexWithinDimensions(index2, dimensions) &&\n      csUtils.indexWithinDimensions(index3, dimensions) &&\n      csUtils.indexWithinDimensions(index4, dimensions)\n    );\n  };\n\n  _getSignedAngle = (vector1, vector2) => {\n    return Math.atan2(\n      vector1[0] * vector2[1] - vector1[1] * vector2[0],\n      vector1[0] * vector2[0] + vector1[1] * vector2[1]\n    );\n  };\n}\n\nfunction defaultGetTextLines(data, targetId): string[] {\n  const { cachedStats, label } = data;\n  const { length, width, unit, lengthUnit, widthUnit } = cachedStats[targetId];\n\n  const textLines = [];\n  if (label) {\n    textLines.push(label);\n  }\n  if (length === undefined) {\n    return textLines;\n  }\n\n  // spaceBetweenSlices & pixelSpacing &\n  // magnitude in each direction? Otherwise, this is \"px\"?\n  textLines.push(\n    `L: ${roundNumber(length)} ${lengthUnit || unit}`,\n    `W: ${roundNumber(width)} ${widthUnit || unit}`\n  );\n\n  return textLines;\n}\n\nBidirectionalTool.toolName = 'Bidirectional';\nexport default BidirectionalTool;\n","import {\n  CONSTANTS,\n  getEnabledElement,\n  VolumeViewport,\n  utilities as csUtils,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\nimport { vec3 } from 'gl-matrix';\n\nimport { getCalibratedLengthUnitsAndScale } from '../../utilities/getCalibratedUnits';\nimport { math, roundNumber } from '../../utilities';\nimport { polyline } from '../../utilities/math';\nimport { filterAnnotationsForDisplay } from '../../utilities/planar';\nimport throttle from '../../utilities/throttle';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport registerDrawLoop from './planarFreehandROITool/drawLoop';\nimport registerEditLoopCommon from './planarFreehandROITool/editLoopCommon';\nimport registerClosedContourEditLoop from './planarFreehandROITool/closedContourEditLoop';\nimport registerOpenContourEditLoop from './planarFreehandROITool/openContourEditLoop';\nimport registerOpenContourEndEditLoop from './planarFreehandROITool/openContourEndEditLoop';\nimport registerRenderMethods from './planarFreehandROITool/renderMethods';\nimport type {\n  EventTypes,\n  ToolHandle,\n  Annotation,\n  Annotations,\n  AnnotationStyle,\n  PublicToolProps,\n  ToolProps,\n  SVGDrawingHelper,\n  AnnotationRenderContext,\n} from '../../types';\nimport { triggerAnnotationModified } from '../../stateManagement/annotation/helpers/state';\nimport { drawLinkedTextBox } from '../../drawingSvg';\nimport { PlanarFreehandROIAnnotation } from '../../types/ToolSpecificAnnotationTypes';\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\nimport { PlanarFreehandROICommonData } from '../../utilities/math/polyline/planarFreehandROIInternalTypes';\n\nimport { getLineSegmentIntersectionsCoordinates } from '../../utilities/math/polyline';\nimport pointInShapeCallback from '../../utilities/pointInShapeCallback';\nimport { isViewportPreScaled } from '../../utilities/viewport/isViewportPreScaled';\nimport { getModalityUnit } from '../../utilities/getModalityUnit';\nimport { BasicStatsCalculator } from '../../utilities/math/basic';\nimport calculatePerimeter from '../../utilities/contours/calculatePerimeter';\nimport ContourSegmentationBaseTool from '../base/ContourSegmentationBaseTool';\nimport { KeyboardBindings, ChangeTypes } from '../../enums';\n\nconst { pointCanProjectOnLine } = polyline;\nconst { EPSILON } = CONSTANTS;\n\nconst PARALLEL_THRESHOLD = 1 - EPSILON;\n\n/**\n * PlanarFreehandROITool lets you draw annotations that define an arbitrarily drawn region.\n * You can use the PlanarFreehandROITool in all perpendicular views (axial, sagittal, coronal),\n * support for oblique views is possible, but not yet supported, due to the implementation of\n * `getSubPixelSpacingAndXYDirections`.\n *\n * The resulting annotation's data and metadata (the\n * state of the viewport while drawing was happening) will get added to the\n * ToolState manager and can be accessed from the ToolState by calling getAnnotations\n * or similar methods.\n *\n * PlanarFreehandROITool annotation can be smoothed on drawing completion. This is a configured based approach.\n * The smoothing process uses b-spline algorithm and consider 4 configurations properties:\n * - smoothing.smoothOnAdd: to tell whether it should be smoothed or not (for editing it is considered the property smoothOnEdit) (default: false)\n * - smoothing.smoothOnEdit: to tell whether it should be smoothed or not when editing (default: false)\n * - smoothing.knotsRatioPercentageOnAdd: percentage of points from Segment that are likely to be considered knots during smoothing (for editing it is considered the property knotsRatioPercentageOnEdit) ( default: 40)\n * - smoothing.knotsRatioPercentageOnEdit: same as knotsRatioPercentageOnAdd but applicable only when editing the tool (default: 40)\n *\n * So, with that said the smoothing might occur when:\n * - drawing is done (i.e mouse is released) and smoothing.smoothOnAdd is true. smoothing algorithm uses knotsRatioPercentageOnAdd\n * - edit drawing is done (i.e mouse is released) and smoothing.smoothOnEdit is true. smoothing algorithm uses knotsRatioPercentageOnEdit and its only applied to changed segment\n * smoothing does not occur when:\n * - smoothing.smoothOnAdd is false and drawing is completed\n * - smoothing.smoothOnEdit is false and edit is completed\n * - drawing still happening (editing or not)\n *\n * The result of smoothing will be removal of some of the outliers\n * Changing tool configuration (see below) you can fine-tune the smoothing process by changing knotsRatioPercentageOnAdd and knotsRatioPercentageOnEdit value, which smaller values produces a more agressive smoothing.\n * A smaller value of knotsRatioPercentageOnAdd/knotsRatioPercentageOnEdit produces a more aggressive smoothing.\n *\n * ```js\n * cornerstoneTools.addTool(PlanarFreehandROITool)\n *\n * const toolGroup = ToolGroupManager.createToolGroup('toolGroupId')\n *\n * toolGroup.addTool(PlanarFreehandROITool.toolName)\n *\n * toolGroup.addViewport('viewportId', 'renderingEngineId')\n *\n * toolGroup.setToolActive(PlanarFreehandROITool.toolName, {\n *   bindings: [\n *    {\n *       mouseButton: MouseBindings.Primary, // Left Click\n *     },\n *   ],\n * })\n *\n * // set smoothing aggressiveness while adding new annotation (ps: this does not change if smoothing is ON or OFF)\n * toolGroup.setToolConfiguration(PlanarFreehandROITool.toolName, {\n *   smoothing: { knotsRatioPercentageOnAdd: 30 },\n * });\n *\n * // set smoothing to be ON while editing only\n * toolGroup.setToolConfiguration(PlanarFreehandROITool.toolName, {\n *   smoothing: { smoothOnAdd: false, smoothOnEdit: true  },\n * });\n * ```\n *\n *\n * Read more in the Docs section of the website.\n */\n\nclass PlanarFreehandROITool extends ContourSegmentationBaseTool {\n  static toolName;\n\n  public touchDragCallback: any;\n  public mouseDragCallback: any;\n  _throttledCalculateCachedStats: any;\n  private commonData?: PlanarFreehandROICommonData;\n  isDrawing = false;\n  isEditingClosed = false;\n  isEditingOpen = false;\n\n  protected activateDraw: (\n    evt: EventTypes.InteractionEventType,\n    annotation: PlanarFreehandROIAnnotation,\n    viewportIdsToRender: string[]\n  ) => void;\n  private activateClosedContourEdit: (\n    evt: EventTypes.InteractionEventType,\n    annotation: PlanarFreehandROIAnnotation,\n    viewportIdsToRender: string[]\n  ) => void;\n  private activateOpenContourEdit: (\n    evt: EventTypes.InteractionEventType,\n    annotation: PlanarFreehandROIAnnotation,\n    viewportIdsToRender: string[]\n  ) => void;\n  private activateOpenContourEndEdit: (\n    evt: EventTypes.InteractionEventType,\n    annotation: PlanarFreehandROIAnnotation,\n    viewportIdsToRender: string[],\n    handle: ToolHandle | null\n  ) => void;\n  private cancelDrawing: (element: HTMLDivElement) => void;\n  private cancelClosedContourEdit: (element: HTMLDivElement) => void;\n  private cancelOpenContourEdit: (element: HTMLDivElement) => void;\n\n  private renderContour: (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper,\n    annotation: PlanarFreehandROIAnnotation\n  ) => void;\n  private renderContourBeingDrawn: (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper,\n    annotation: PlanarFreehandROIAnnotation\n  ) => void;\n  private renderClosedContourBeingEdited: (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper,\n    annotation: PlanarFreehandROIAnnotation\n  ) => void;\n  private renderOpenContourBeingEdited: (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper,\n    annotation: PlanarFreehandROIAnnotation\n  ) => void;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        shadow: true,\n        preventHandleOutsideImage: false,\n        /**\n         * Specify which modifier key is used to add a hole to a contour. The\n         * modifier must be pressed when the first point of a new contour is added.\n         */\n        contourHoleAdditionModifierKey: KeyboardBindings.Shift,\n        alwaysRenderOpenContourHandles: {\n          // When true, always render end points when you have an open contour, rather\n          // than just rendering a line.\n          enabled: false,\n          // When enabled, use this radius to draw the endpoints whilst not hovering.\n          radius: 2,\n        },\n        allowOpenContours: true,\n        // Proximity in canvas coordinates used to join contours.\n        closeContourProximity: 10,\n        // The proximity at which we fallback to the simplest grabbing logic for\n        // determining what index of the contour to start editing.\n        checkCanvasEditFallbackProximity: 6,\n        // For closed contours, make them clockwise\n        // This can be useful if contours are compared between slices, eg for\n        // interpolation, and does not cause problems otherwise so defaulting to true.\n        makeClockWise: true,\n        // The relative distance that points should be dropped along the polyline\n        // in units of the image pixel spacing. A value of 1 means that nodes must\n        // be placed no closed than the image spacing apart. A value of 4 means that 4\n        // nodes should be placed within the space of one image pixel size. A higher\n        // value gives more finesse to the tool/smoother lines, but the value cannot\n        // be infinite as the lines become very computationally expensive to draw.\n        subPixelResolution: 4,\n        /**\n         * Smoothing is used to remove jagged irregularities in the polyline,\n         * as opposed to interpolation, which is used to create new polylines\n         * between existing polylines.\n         */\n        smoothing: {\n          smoothOnAdd: false,\n          smoothOnEdit: false, // used for edit only\n          knotsRatioPercentageOnAdd: 40,\n          knotsRatioPercentageOnEdit: 40,\n        },\n        /**\n         * Interpolation is the creation of new segmentations in between the\n         * existing segmentations/indices.  Note that this does not apply to\n         * ROI values, since those annotations are individual annotations, not\n         * connected in any way to each other, whereas segmentations are intended\n         * to be connected 2d + 1 dimension (time or space or other) volumes.\n         */\n        interpolation: {\n          enabled: false,\n          // Callback to update the annotation or perform other action when the\n          // interpolation is complete.\n          onInterpolationComplete: null,\n        },\n        /**\n         * The polyline may get processed in order to reduce the number of points\n         * for better performance and storage.\n         */\n        decimate: {\n          enabled: false,\n          /** A maximum given distance 'epsilon' to decide if a point should or\n           * shouldn't be added the resulting polyline which will have a lower\n           * number of points for higher `epsilon` values.\n           */\n          epsilon: 0.1,\n        },\n        calculateStats: true,\n        getTextLines: defaultGetTextLines,\n        statsCalculator: BasicStatsCalculator,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n\n    // Register event loops and rendering logic, which are stored in different\n    // Files due to their complexity/size.\n    registerDrawLoop(this);\n    registerEditLoopCommon(this);\n    registerClosedContourEditLoop(this);\n    registerOpenContourEditLoop(this);\n    registerOpenContourEndEditLoop(this);\n    registerRenderMethods(this);\n\n    this._throttledCalculateCachedStats = throttle(\n      this._calculateCachedStats,\n      100,\n      { trailing: true }\n    );\n  }\n\n  /**\n   * Based on the current position of the mouse and the current image, creates\n   * a `PlanarFreehandROIAnnotation` and stores it in the annotationManager.\n   *\n   * @param evt - `EventTypes.NormalizedMouseEventType`\n   * @returns The `PlanarFreehandROIAnnotation` object.\n   */\n  addNewAnnotation = (\n    evt: EventTypes.InteractionEventType\n  ): PlanarFreehandROIAnnotation => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    const annotation = this.createAnnotation(\n      evt\n    ) as PlanarFreehandROIAnnotation;\n\n    this.addAnnotation(annotation, element);\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.activateDraw(evt, annotation, viewportIdsToRender);\n\n    evt.preventDefault();\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    return annotation;\n  };\n\n  /**\n   * Begins an edit of an open contour, when the mouse has selected a handle\n   * (end) of the open contour.\n   *\n   * @param evt - `EventTypes.MouseDownEventType`\n   * @param annotation - `PlanarFreehandROIAnnotation` annotation.\n   * @param handle - The handle index, 0 for the start and 1 for the end.\n   * @param interactionType - interaction type (mouse, touch)\n   */\n  handleSelectedCallback = (\n    evt: EventTypes.InteractionEventType,\n    annotation: PlanarFreehandROIAnnotation,\n    handle: ToolHandle\n  ): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.activateOpenContourEndEdit(\n      evt,\n      annotation,\n      viewportIdsToRender,\n      handle\n    );\n  };\n\n  /**\n   * Edits the open or closed contour when the line is grabbed and dragged.\n   */\n  toolSelectedCallback = (\n    evt: EventTypes.InteractionEventType,\n    annotation: PlanarFreehandROIAnnotation\n  ): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    if (annotation.data.contour.closed) {\n      this.activateClosedContourEdit(evt, annotation, viewportIdsToRender);\n    } else {\n      this.activateOpenContourEdit(evt, annotation, viewportIdsToRender);\n    }\n\n    evt.preventDefault();\n  };\n\n  /**\n   * Returns if the canvas point is near the line of the given annotation in the\n   * provided element or not. A proximity is passed to the function to determine the\n   * proximity of the point to the annotation in number of pixels.\n   *\n   * @param element - HTML Element\n   * @param annotation - The `PlanarFreehandROIAnnotation`.\n   * @param canvasCoords - Canvas coordinates\n   * @param proximity - Proximity to tool to consider\n   * @returns Boolean, whether the canvas point is near tool\n   */\n  isPointNearTool = (\n    element: HTMLDivElement,\n    annotation: PlanarFreehandROIAnnotation,\n    canvasCoords: Types.Point2,\n    proximity: number\n  ): boolean => {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n\n    const { polyline: points } = annotation.data.contour;\n\n    // NOTE: It is implemented this way so that we do not double calculate\n    // points when number crunching adjacent line segments.\n    let previousPoint = viewport.worldToCanvas(points[0]);\n\n    for (let i = 1; i < points.length; i++) {\n      const p1 = previousPoint;\n      const p2 = viewport.worldToCanvas(points[i]);\n      const canProject = pointCanProjectOnLine(canvasCoords, p1, p2, proximity);\n\n      if (canProject) {\n        return true;\n      }\n\n      previousPoint = p2;\n    }\n\n    if (!annotation.data.contour.closed) {\n      // Contour is open, don't check last point to first point.\n      return false;\n    }\n\n    // check last point to first point\n    const pStart = viewport.worldToCanvas(points[0]);\n    const pEnd = viewport.worldToCanvas(points[points.length - 1]);\n\n    return pointCanProjectOnLine(canvasCoords, pStart, pEnd, proximity);\n  };\n\n  public cancel = (element: HTMLDivElement): void => {\n    const isDrawing = this.isDrawing;\n    const isEditingOpen = this.isEditingOpen;\n    const isEditingClosed = this.isEditingClosed;\n\n    if (isDrawing) {\n      this.cancelDrawing(element);\n    } else if (isEditingOpen) {\n      this.cancelOpenContourEdit(element);\n    } else if (isEditingClosed) {\n      this.cancelClosedContourEdit(element);\n    }\n  };\n\n  /**\n   * @override We need to override this method as the tool doesn't always have\n   * `handles`, which means `filterAnnotationsForDisplay` fails inside\n   * `filterAnnotationsWithinSlice`.\n   */\n  public filterInteractableAnnotationsForElement(\n    element: HTMLDivElement,\n    annotations: Annotations\n  ): Annotations | undefined {\n    if (!annotations || !annotations.length) {\n      return;\n    }\n\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n\n    let annotationsToDisplay;\n\n    if (viewport instanceof VolumeViewport) {\n      const camera = viewport.getCamera();\n\n      const { spacingInNormalDirection } =\n        csUtils.getTargetVolumeAndSpacingInNormalDir(viewport, camera);\n\n      // Get data with same normal and within the same slice\n      annotationsToDisplay = this.filterAnnotationsWithinSlice(\n        annotations,\n        camera,\n        spacingInNormalDirection\n      );\n    } else {\n      // Use the default `filterAnnotationsForDisplay` utility, as the stack\n      // path doesn't require handles.\n      annotationsToDisplay = filterAnnotationsForDisplay(viewport, annotations);\n    }\n\n    return annotationsToDisplay;\n  }\n\n  /**\n   * Altered version of the `utilities.planar.filterAnnotationsWithinSlice`,\n   * which uses the polyline position rather than the handle. As the polyline is\n   * always present.\n   */\n  private filterAnnotationsWithinSlice(\n    annotations: Annotations,\n    camera: Types.ICamera,\n    spacingInNormalDirection: number\n  ): Annotations {\n    const { viewPlaneNormal } = camera;\n\n    const annotationsWithParallelNormals = annotations.filter(\n      (td: Annotation) => {\n        const annotationViewPlaneNormal = td.metadata.viewPlaneNormal;\n\n        const isParallel =\n          Math.abs(vec3.dot(viewPlaneNormal, annotationViewPlaneNormal)) >\n          PARALLEL_THRESHOLD;\n\n        return annotationViewPlaneNormal && isParallel;\n      }\n    ) as PlanarFreehandROIAnnotation[];\n\n    // No in plane annotations.\n    if (!annotationsWithParallelNormals.length) {\n      return [];\n    }\n\n    // Annotation should be within the slice, which means that it should be between\n    // camera's focalPoint +/- spacingInNormalDirection.\n\n    const halfSpacingInNormalDirection = spacingInNormalDirection / 2;\n    const { focalPoint } = camera;\n\n    const annotationsWithinSlice = [];\n\n    for (const annotation of annotationsWithParallelNormals) {\n      const data = annotation.data;\n      const point = data.contour.polyline[0];\n\n      if (!annotation.isVisible) {\n        continue;\n      }\n\n      // A = point\n      // B = focal point\n      // P = normal\n\n      // B-A dot P  => Distance in the view direction.\n      // this should be less than half the slice distance.\n\n      const dir = vec3.create();\n\n      vec3.sub(dir, focalPoint, point);\n\n      const dot = vec3.dot(dir, viewPlaneNormal);\n\n      if (Math.abs(dot) < halfSpacingInNormalDirection) {\n        annotationsWithinSlice.push(annotation);\n      }\n    }\n\n    return annotationsWithinSlice;\n  }\n\n  protected isContourSegmentationTool(): boolean {\n    // Disable contour segmentation behavior because it shall be activated only\n    // for PlanarFreehandContourSegmentationTool\n    return false;\n  }\n\n  protected createAnnotation(evt: EventTypes.InteractionEventType): Annotation {\n    const worldPos = evt.detail.currentPoints.world;\n    const contourAnnotation = super.createAnnotation(evt);\n\n    const onInterpolationComplete = (annotation) => {\n      // Clear out the handles because they aren't used for straight freeform\n      annotation.data.handles.points.length = 0;\n    };\n\n    const annotation = <PlanarFreehandROIAnnotation>csUtils.deepMerge(\n      contourAnnotation,\n      {\n        data: {\n          contour: {\n            polyline: [<Types.Point3>[...worldPos]],\n          },\n          label: '',\n          cachedStats: {},\n        },\n        onInterpolationComplete,\n      }\n    );\n\n    return annotation;\n  }\n\n  protected getAnnotationStyle(context) {\n    // This method exists only because `super` cannot be called from\n    // _getRenderingOptions() which is in an external file.\n    return super.getAnnotationStyle(context);\n  }\n\n  protected renderAnnotationInstance(\n    renderContext: AnnotationRenderContext\n  ): boolean {\n    const { enabledElement, targetId, svgDrawingHelper } = renderContext;\n    const annotation = renderContext.annotation as PlanarFreehandROIAnnotation;\n\n    let renderStatus = false;\n    const { viewport, renderingEngine } = enabledElement;\n\n    const isDrawing = this.isDrawing;\n    const isEditingOpen = this.isEditingOpen;\n    const isEditingClosed = this.isEditingClosed;\n\n    if (!(isDrawing || isEditingOpen || isEditingClosed)) {\n      // No annotations are currently being modified, so we can just use the\n      // render contour method to render all of them\n      this.renderContour(enabledElement, svgDrawingHelper, annotation);\n    } else {\n      // The active annotation will need special rendering treatment. Render all\n      // other annotations not being interacted with using the standard renderContour\n      // rendering path.\n      const activeAnnotationUID = this.commonData.annotation.annotationUID;\n\n      if (annotation.annotationUID === activeAnnotationUID) {\n        if (isDrawing) {\n          this.renderContourBeingDrawn(\n            enabledElement,\n            svgDrawingHelper,\n            annotation\n          );\n        } else if (isEditingClosed) {\n          this.renderClosedContourBeingEdited(\n            enabledElement,\n            svgDrawingHelper,\n            annotation\n          );\n        } else if (isEditingOpen) {\n          this.renderOpenContourBeingEdited(\n            enabledElement,\n            svgDrawingHelper,\n            annotation\n          );\n        } else {\n          throw new Error(\n            `Unknown ${this.getToolName()} annotation rendering state`\n          );\n        }\n      } else {\n        this.renderContour(enabledElement, svgDrawingHelper, annotation);\n      }\n\n      // Todo: return boolean flag for each rendering route in the planar tool.\n      renderStatus = true;\n    }\n\n    if (!this.configuration.calculateStats) {\n      return;\n    }\n\n    this._calculateStatsIfActive(\n      annotation,\n      targetId,\n      viewport,\n      renderingEngine,\n      enabledElement\n    );\n\n    this._renderStats(annotation, viewport, enabledElement, svgDrawingHelper);\n\n    return renderStatus;\n  }\n\n  _calculateStatsIfActive(\n    annotation: PlanarFreehandROIAnnotation,\n    targetId: string,\n    viewport,\n    renderingEngine,\n    enabledElement\n  ) {\n    const activeAnnotationUID = this.commonData?.annotation.annotationUID;\n\n    if (\n      annotation.annotationUID === activeAnnotationUID &&\n      !this.commonData?.movingTextBox\n    ) {\n      return;\n    }\n\n    if (!this.commonData?.movingTextBox) {\n      const { data } = annotation;\n      if (\n        !data.cachedStats[targetId] ||\n        data.cachedStats[targetId].areaUnit == null\n      ) {\n        data.cachedStats[targetId] = {\n          Modality: null,\n          area: null,\n          max: null,\n          mean: null,\n          stdDev: null,\n          areaUnit: null,\n        };\n\n        this._calculateCachedStats(\n          annotation,\n          viewport,\n          renderingEngine,\n          enabledElement\n        );\n      } else if (annotation.invalidated) {\n        this._throttledCalculateCachedStats(\n          annotation,\n          viewport,\n          renderingEngine,\n          enabledElement\n        );\n      }\n    }\n  }\n\n  private _calculateCachedStats = (\n    annotation,\n    viewport,\n    renderingEngine,\n    enabledElement\n  ) => {\n    const { data } = annotation;\n    const { cachedStats } = data;\n    const { polyline: points, closed } = data.contour;\n\n    const targetIds = Object.keys(cachedStats);\n\n    for (let i = 0; i < targetIds.length; i++) {\n      const targetId = targetIds[i];\n      const image = this.getTargetIdImage(targetId, renderingEngine);\n\n      // If image does not exists for the targetId, skip. This can be due\n      // to various reasons such as if the target was a volumeViewport, and\n      // the volumeViewport has been decached in the meantime.\n      if (!image) {\n        continue;\n      }\n\n      const { imageData, metadata } = image;\n      const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n\n      // Using an arbitrary start point (canvasPoint), calculate the\n      // mm spacing for the canvas in the X and Y directions.\n      const canvasPoint = canvasCoordinates[0];\n      const originalWorldPoint = viewport.canvasToWorld(canvasPoint);\n      const deltaXPoint = viewport.canvasToWorld([\n        canvasPoint[0] + 1,\n        canvasPoint[1],\n      ]);\n      const deltaYPoint = viewport.canvasToWorld([\n        canvasPoint[0],\n        canvasPoint[1] + 1,\n      ]);\n\n      const deltaInX = vec3.distance(originalWorldPoint, deltaXPoint);\n      const deltaInY = vec3.distance(originalWorldPoint, deltaYPoint);\n\n      const worldPosIndex = csUtils.transformWorldToIndex(imageData, points[0]);\n      worldPosIndex[0] = Math.floor(worldPosIndex[0]);\n      worldPosIndex[1] = Math.floor(worldPosIndex[1]);\n      worldPosIndex[2] = Math.floor(worldPosIndex[2]);\n\n      let iMin = worldPosIndex[0];\n      let iMax = worldPosIndex[0];\n\n      let jMin = worldPosIndex[1];\n      let jMax = worldPosIndex[1];\n\n      let kMin = worldPosIndex[2];\n      let kMax = worldPosIndex[2];\n\n      for (let j = 1; j < points.length; j++) {\n        const worldPosIndex = csUtils.transformWorldToIndex(\n          imageData,\n          points[j]\n        );\n        worldPosIndex[0] = Math.floor(worldPosIndex[0]);\n        worldPosIndex[1] = Math.floor(worldPosIndex[1]);\n        worldPosIndex[2] = Math.floor(worldPosIndex[2]);\n        iMin = Math.min(iMin, worldPosIndex[0]);\n        iMax = Math.max(iMax, worldPosIndex[0]);\n\n        jMin = Math.min(jMin, worldPosIndex[1]);\n        jMax = Math.max(jMax, worldPosIndex[1]);\n\n        kMin = Math.min(kMin, worldPosIndex[2]);\n        kMax = Math.max(kMax, worldPosIndex[2]);\n      }\n\n      const worldPosIndex2 = csUtils.transformWorldToIndex(\n        imageData,\n        points[1]\n      );\n      worldPosIndex2[0] = Math.floor(worldPosIndex2[0]);\n      worldPosIndex2[1] = Math.floor(worldPosIndex2[1]);\n      worldPosIndex2[2] = Math.floor(worldPosIndex2[2]);\n\n      const { scale, areaUnits } = getCalibratedLengthUnitsAndScale(\n        image,\n        () => {\n          const polyline = data.contour.polyline;\n          const numPoints = polyline.length;\n          const projectedPolyline = new Array(numPoints);\n\n          for (let i = 0; i < numPoints; i++) {\n            projectedPolyline[i] = viewport.worldToCanvas(polyline[i]);\n          }\n\n          const {\n            maxX: canvasMaxX,\n            maxY: canvasMaxY,\n            minX: canvasMinX,\n            minY: canvasMinY,\n          } = math.polyline.getAABB(projectedPolyline);\n\n          const topLeftBBWorld = viewport.canvasToWorld([\n            canvasMinX,\n            canvasMinY,\n          ]);\n\n          const topLeftBBIndex = csUtils.transformWorldToIndex(\n            imageData,\n            topLeftBBWorld\n          );\n\n          const bottomRightBBWorld = viewport.canvasToWorld([\n            canvasMaxX,\n            canvasMaxY,\n          ]);\n\n          const bottomRightBBIndex = csUtils.transformWorldToIndex(\n            imageData,\n            bottomRightBBWorld\n          );\n\n          return [topLeftBBIndex, bottomRightBBIndex];\n        }\n      );\n      let area = polyline.getArea(canvasCoordinates) / scale / scale;\n      // Convert from canvas_pixels ^2 to mm^2\n      area *= deltaInX * deltaInY;\n\n      // Expand bounding box\n      const iDelta = 0.01 * (iMax - iMin);\n      const jDelta = 0.01 * (jMax - jMin);\n      const kDelta = 0.01 * (kMax - kMin);\n\n      iMin = Math.floor(iMin - iDelta);\n      iMax = Math.ceil(iMax + iDelta);\n      jMin = Math.floor(jMin - jDelta);\n      jMax = Math.ceil(jMax + jDelta);\n      kMin = Math.floor(kMin - kDelta);\n      kMax = Math.ceil(kMax + kDelta);\n\n      const boundsIJK = [\n        [iMin, iMax],\n        [jMin, jMax],\n        [kMin, kMax],\n      ] as [Types.Point2, Types.Point2, Types.Point2];\n\n      const worldPosEnd = imageData.indexToWorld([iMax, jMax, kMax]);\n      const canvasPosEnd = viewport.worldToCanvas(worldPosEnd);\n\n      let curRow = 0;\n      let intersections = [];\n      let intersectionCounter = 0;\n      const pointsInShape = pointInShapeCallback(\n        imageData,\n        (pointLPS, pointIJK) => {\n          let result = true;\n          const point = viewport.worldToCanvas(pointLPS);\n          if (point[1] != curRow) {\n            intersectionCounter = 0;\n            curRow = point[1];\n            intersections = getLineSegmentIntersectionsCoordinates(\n              canvasCoordinates,\n              point,\n              [canvasPosEnd[0], point[1]]\n            );\n            intersections.sort(\n              (function (index) {\n                return function (a, b) {\n                  return a[index] === b[index]\n                    ? 0\n                    : a[index] < b[index]\n                    ? -1\n                    : 1;\n                };\n              })(0)\n            );\n          }\n          if (intersections.length && point[0] > intersections[0][0]) {\n            intersections.shift();\n            intersectionCounter++;\n          }\n          if (intersectionCounter % 2 === 0) {\n            result = false;\n          }\n          return result;\n        },\n        this.configuration.statsCalculator.statsCallback,\n        boundsIJK\n      );\n\n      const modalityUnitOptions = {\n        isPreScaled: isViewportPreScaled(viewport, targetId),\n        isSuvScaled: this.isSuvScaled(\n          viewport,\n          targetId,\n          annotation.metadata.referencedImageId\n        ),\n      };\n\n      const modalityUnit = getModalityUnit(\n        metadata.Modality,\n        annotation.metadata.referencedImageId,\n        modalityUnitOptions\n      );\n\n      const stats = this.configuration.statsCalculator.getStatistics();\n\n      cachedStats[targetId] = {\n        Modality: metadata.Modality,\n        area,\n        perimeter: calculatePerimeter(canvasCoordinates, closed),\n        mean: stats.mean?.value,\n        max: stats.max?.value,\n        stdDev: stats.stdDev?.value,\n        statsArray: stats.array,\n        pointsInShape: pointsInShape,\n        areaUnit: areaUnits,\n        modalityUnit,\n      };\n    }\n\n    triggerAnnotationModified(\n      annotation,\n      enabledElement.viewport.element,\n      ChangeTypes.StatsUpdated\n    );\n\n    annotation.invalidated = false;\n\n    return cachedStats;\n  };\n\n  private _renderStats = (\n    annotation,\n    viewport,\n    enabledElement,\n    svgDrawingHelper\n  ) => {\n    const { data } = <PlanarFreehandROIAnnotation>annotation;\n    const targetId = this.getTargetId(viewport);\n\n    const styleSpecifier: AnnotationStyle.StyleSpecifier = {\n      toolGroupId: this.toolGroupId,\n      toolName: this.getToolName(),\n      viewportId: enabledElement.viewport.id,\n    };\n\n    const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n    if (!options.visibility) {\n      return;\n    }\n\n    const textLines = this.configuration.getTextLines(data, targetId);\n    if (!textLines || textLines.length === 0) {\n      return;\n    }\n\n    const canvasCoordinates = data.contour.polyline.map((p) =>\n      viewport.worldToCanvas(p)\n    );\n    if (!data.handles.textBox.hasMoved) {\n      const canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCoordinates);\n\n      data.handles.textBox.worldPosition =\n        viewport.canvasToWorld(canvasTextBoxCoords);\n    }\n\n    const textBoxPosition = viewport.worldToCanvas(\n      data.handles.textBox.worldPosition\n    );\n\n    const textBoxUID = '1';\n    const boundingBox = drawLinkedTextBox(\n      svgDrawingHelper,\n      annotation.annotationUID ?? '',\n      textBoxUID,\n      textLines,\n      textBoxPosition,\n      canvasCoordinates,\n      {},\n      options\n    );\n\n    const { x: left, y: top, width, height } = boundingBox;\n\n    data.handles.textBox.worldBoundingBox = {\n      topLeft: viewport.canvasToWorld([left, top]),\n      topRight: viewport.canvasToWorld([left + width, top]),\n      bottomLeft: viewport.canvasToWorld([left, top + height]),\n      bottomRight: viewport.canvasToWorld([left + width, top + height]),\n    };\n  };\n}\n\nfunction defaultGetTextLines(data, targetId): string[] {\n  const cachedVolumeStats = data.cachedStats[targetId];\n  const {\n    area,\n    mean,\n    stdDev,\n    perimeter,\n    max,\n    isEmptyArea,\n    areaUnit,\n    modalityUnit,\n  } = cachedVolumeStats || {};\n\n  const textLines: string[] = [];\n\n  if (area) {\n    const areaLine = isEmptyArea\n      ? `Area: Oblique not supported`\n      : `Area: ${roundNumber(area)} ${areaUnit}`;\n    textLines.push(areaLine);\n  }\n\n  if (mean) {\n    textLines.push(`Mean: ${roundNumber(mean)} ${modalityUnit}`);\n  }\n\n  if (max) {\n    textLines.push(`Max: ${roundNumber(max)} ${modalityUnit}`);\n  }\n\n  if (stdDev) {\n    textLines.push(`Std Dev: ${roundNumber(stdDev)} ${modalityUnit}`);\n  }\n\n  if (perimeter) {\n    textLines.push(`Perimeter: ${roundNumber(perimeter)} ${modalityUnit}`);\n  }\n\n  return textLines;\n}\n\nPlanarFreehandROITool.toolName = 'PlanarFreehandROI';\nexport default PlanarFreehandROITool;\n","import {\n  getEnabledElementByIds,\n  Types,\n  utilities as csUtils,\n} from '@cornerstonejs/core';\nimport Representations from '../../enums/SegmentationRepresentations';\nimport { config as segmentationConfig } from '../../stateManagement/segmentation';\nimport { setSegmentationVisibility } from '../../stateManagement/segmentation/config/segmentationVisibility';\nimport { getSegmentationRepresentations } from '../../stateManagement/segmentation/segmentationState';\nimport { getToolGroup } from '../../store/ToolGroupManager';\nimport { PublicToolProps, ToolProps } from '../../types';\nimport { BaseTool } from '../base';\n\nimport {\n  SegmentationRepresentationConfig,\n  ToolGroupSpecificRepresentation,\n} from '../../types/SegmentationStateTypes';\nimport { surfaceDisplay } from './Surface';\nimport { contourDisplay } from './Contour';\nimport { labelmapDisplay } from './Labelmap';\nimport SegmentationRepresentations from '../../enums/SegmentationRepresentations';\nimport { addTool, state } from '../../store';\nimport PlanarFreehandContourSegmentationTool from '../annotation/PlanarFreehandContourSegmentationTool';\n\nconst planarContourToolName = PlanarFreehandContourSegmentationTool.toolName;\n/**\n * In Cornerstone3DTools, displaying of segmentations are handled by the SegmentationDisplayTool.\n * Generally, any Segmentation can be viewed in various representations such as\n * labelmap (3d), contours, surface etc. As of now, Cornerstone3DTools only implements\n * Labelmap representation.\n *\n * SegmentationDisplayTool works at ToolGroup level, and is responsible for displaying the\n * segmentation representation for ALL viewports of a toolGroup, this way we can support complex\n * scenarios for displaying segmentations.\n *\n * Current Limitations:\n * - Only supports rendering of the volumetric segmentations in 3D space. (StackViewport segmentations are not supported yet)\n * - Labelmap representation is the only supported representation for now.\n *\n * Similar to other tools in Cornerstone3DTools, the SegmentationDisplayTool should\n * be added to the CornerstoneTools by calling cornerstoneTools.addTool(SegmentationDisplayTool)\n * and a toolGroup should be created for it using the ToolGroupManager API, finally\n * viewports information such as viewportId and renderingEngineId should be provided\n * to the toolGroup and the SegmentationDisplayTool should be set to be activated.\n *\n *\n */\nclass SegmentationDisplayTool extends BaseTool {\n  static toolName;\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      configuration: {},\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n  }\n\n  onSetToolEnabled(): void {\n    const toolGroupId = this.toolGroupId;\n    const toolGroupSegmentationRepresentations =\n      getSegmentationRepresentations(toolGroupId);\n\n    if (\n      !toolGroupSegmentationRepresentations ||\n      toolGroupSegmentationRepresentations.length === 0\n    ) {\n      return;\n    }\n\n    // for each segmentationData, make the visibility true\n    toolGroupSegmentationRepresentations.forEach(\n      (segmentationRepresentation) => {\n        setSegmentationVisibility(\n          toolGroupId,\n          segmentationRepresentation.segmentationRepresentationUID,\n          true\n        );\n      }\n    );\n  }\n\n  onSetToolDisabled(): void {\n    const toolGroupId = this.toolGroupId;\n    const toolGroupSegmentationRepresentations =\n      getSegmentationRepresentations(toolGroupId);\n\n    if (\n      !toolGroupSegmentationRepresentations ||\n      toolGroupSegmentationRepresentations.length === 0\n    ) {\n      return;\n    }\n\n    // for each segmentationData, make the visibility false\n    toolGroupSegmentationRepresentations.forEach(\n      (segmentationRepresentation) => {\n        setSegmentationVisibility(\n          toolGroupId,\n          segmentationRepresentation.segmentationRepresentationUID,\n          false\n        );\n      }\n    );\n  }\n\n  /**\n   * It is used to trigger the render for each segmentations in the toolGroup.\n   * Based on the segmentation representation type, it will call the corresponding\n   * render function.\n   *\n   * @param toolGroupId - the toolGroupId\n   */\n  renderSegmentation = (toolGroupId: string): void => {\n    const toolGroup = getToolGroup(toolGroupId);\n\n    if (!toolGroup) {\n      return;\n    }\n\n    const toolGroupSegmentationRepresentations =\n      getSegmentationRepresentations(toolGroupId);\n\n    if (\n      !toolGroupSegmentationRepresentations ||\n      toolGroupSegmentationRepresentations.length === 0\n    ) {\n      return;\n    }\n\n    // toolGroup Viewports\n    const toolGroupViewports = toolGroup.viewportsInfo.map(\n      ({ renderingEngineId, viewportId }) => {\n        const enabledElement = getEnabledElementByIds(\n          viewportId,\n          renderingEngineId\n        );\n\n        if (enabledElement) {\n          return enabledElement.viewport;\n        }\n      }\n    );\n\n    // Render each segmentationData, in each viewport in the toolGroup\n    const segmentationRenderList = toolGroupSegmentationRepresentations.map(\n      (representation: ToolGroupSpecificRepresentation) => {\n        const config = this._getMergedRepresentationsConfig(toolGroupId);\n\n        const viewportsRenderList = [];\n\n        const renderers = {\n          [Representations.Labelmap]: labelmapDisplay,\n          [Representations.Contour]: contourDisplay,\n          [Representations.Surface]: surfaceDisplay,\n        };\n\n        if (representation.type === SegmentationRepresentations.Contour) {\n          // if the representation is contour we need to make sure\n          // that the planarFreeHandTool is added to the toolGroup\n          this.addPlanarFreeHandToolIfAbsent(toolGroupId);\n        }\n\n        const display = renderers[representation.type];\n\n        for (const viewport of toolGroupViewports) {\n          const renderedViewport = display.render(\n            viewport as Types.IVolumeViewport,\n            representation,\n            config\n          );\n\n          viewportsRenderList.push(renderedViewport);\n        }\n        return viewportsRenderList;\n      }\n    );\n\n    Promise.allSettled(segmentationRenderList).then(() => {\n      // for all viewports in the toolGroup trigger a re-render\n      toolGroupViewports.forEach((viewport) => {\n        viewport.render();\n      });\n    });\n  };\n\n  addPlanarFreeHandToolIfAbsent(toolGroupId) {\n    // if it is contour we should check if the toolGroup and more importantly\n    // the cornerstoneTools have the planarFreeHandTool added\n    if (!(planarContourToolName in state.tools)) {\n      addTool(PlanarFreehandContourSegmentationTool);\n    }\n\n    const toolGroup = getToolGroup(toolGroupId);\n\n    // check if toolGroup has this tool\n    if (!toolGroup.hasTool(planarContourToolName)) {\n      toolGroup.addTool(planarContourToolName);\n      toolGroup.setToolPassive(planarContourToolName);\n    }\n  }\n\n  /**\n   * Merge the toolGroup specific configuration with the default global configuration\n   * @param toolGroupId\n   * @returns\n   */\n  _getMergedRepresentationsConfig(\n    toolGroupId: string\n  ): SegmentationRepresentationConfig {\n    const toolGroupConfig =\n      segmentationConfig.getToolGroupSpecificConfig(toolGroupId);\n    const globalConfig = segmentationConfig.getGlobalConfig();\n\n    // merge two configurations and override the global config\n    const mergedConfig = csUtils.deepMerge(globalConfig, toolGroupConfig);\n\n    return mergedConfig;\n  }\n}\n\nSegmentationDisplayTool.toolName = 'SegmentationDisplay';\nexport default SegmentationDisplayTool;\n","import {\n  getEnabledElement,\n  cache,\n  StackViewport,\n  utilities as csUtils,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { addAnnotation, getAnnotations } from '../../stateManagement';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\n\nimport {\n  drawHandles as drawHandlesSvg,\n  drawRect as drawRectSvg,\n} from '../../drawingSvg';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport { hideElementCursor } from '../../cursors/elementCursor';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport { triggerAnnotationModified } from '../../stateManagement/annotation/helpers/state';\nimport {\n  PublicToolProps,\n  ToolProps,\n  EventTypes,\n  SVGDrawingHelper,\n} from '../../types';\nimport { RectangleROIThresholdAnnotation } from '../../types/ToolSpecificAnnotationTypes';\nimport RectangleROITool from '../annotation/RectangleROITool';\nimport { StyleSpecifier } from '../../types/AnnotationStyle';\n\n/**\n * This tool is exactly the RectangleROITool but only draws a rectangle on the image,\n * and by using utility functions such as thresholdByRange and thresholdByROIStat it can be used to\n * create a segmentation. This tool, however, does not calculate the statistics\n * as RectangleROITool does.\n */\nclass RectangleROIThresholdTool extends RectangleROITool {\n  static toolName;\n  _throttledCalculateCachedStats: any;\n  editData: {\n    annotation: any;\n    viewportIdsToRender: string[];\n    handleIndex?: number;\n    newAnnotation?: boolean;\n    hasMoved?: boolean;\n  } | null;\n  isDrawing: boolean;\n  isHandleOutsideImage: boolean;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        shadow: true,\n        preventHandleOutsideImage: false,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n  }\n\n  /**\n   * Based on the current position of the mouse and the enabledElement it creates\n   * the edit data for the tool.\n   *\n   * @param evt -  EventTypes.NormalizedMouseEventType\n   * @returns The annotation object.\n   *\n   */\n  addNewAnnotation = (evt: EventTypes.InteractionEventType) => {\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const worldPos = currentPoints.world;\n\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n\n    this.isDrawing = true;\n\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, viewUp } = camera;\n\n    const targetId = this.getTargetId(viewport);\n    let referencedImageId, volumeId;\n\n    if (viewport instanceof StackViewport) {\n      referencedImageId = targetId.split('imageId:')[1];\n    } else {\n      volumeId = csUtils.getVolumeId(targetId);\n      const imageVolume = cache.getVolume(volumeId);\n      referencedImageId = csUtils.getClosestImageId(\n        imageVolume,\n        worldPos,\n        viewPlaneNormal\n      );\n    }\n\n    const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n    // Todo: how not to store enabledElement on the annotation, segmentationModule needs the element to\n    // decide on the active segmentIndex, active segmentationIndex etc.\n    const annotation = {\n      highlighted: true,\n      invalidated: true,\n      metadata: {\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\n        enabledElement,\n        viewUp: <Types.Point3>[...viewUp],\n        FrameOfReferenceUID,\n        referencedImageId,\n        toolName: this.getToolName(),\n        volumeId,\n      },\n      data: {\n        label: '',\n        handles: {\n          // No need a textBox\n          textBox: {\n            hasMoved: false,\n            worldPosition: null,\n            worldBoundingBox: null,\n          },\n          points: [\n            <Types.Point3>[...worldPos],\n            <Types.Point3>[...worldPos],\n            <Types.Point3>[...worldPos],\n            <Types.Point3>[...worldPos],\n          ],\n          activeHandleIndex: null,\n        },\n        segmentationId: null,\n      },\n    };\n\n    addAnnotation(annotation, element);\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      handleIndex: 3,\n      newAnnotation: true,\n      hasMoved: false,\n    };\n    this._activateDraw(element);\n\n    hideElementCursor(element);\n\n    evt.preventDefault();\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    return annotation;\n  };\n\n  /**\n   * it is used to draw the RectangleROI Threshold annotation in each\n   * request animation frame.\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    let renderStatus = false;\n    const { viewport } = enabledElement;\n    const { element } = viewport;\n    let annotations = getAnnotations(this.getToolName(), element);\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    annotations = this.filterInteractableAnnotationsForElement(\n      element,\n      annotations\n    );\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    const styleSpecifier: StyleSpecifier = {\n      toolGroupId: this.toolGroupId,\n      toolName: this.getToolName(),\n      viewportId: enabledElement.viewport.id,\n    };\n\n    for (let i = 0; i < annotations.length; i++) {\n      const annotation = annotations[i] as RectangleROIThresholdAnnotation;\n      const { annotationUID, data } = annotation;\n      const { points, activeHandleIndex } = data.handles;\n      const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n\n      styleSpecifier.annotationUID = annotationUID;\n\n      const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);\n      const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\n      const color = this.getStyle('color', styleSpecifier, annotation);\n\n      // If rendering engine has been destroyed while rendering\n      if (!viewport.getRenderingEngine()) {\n        console.warn('Rendering Engine has been destroyed');\n        return renderStatus;\n      }\n\n      // Todo: This is not correct way to add the event trigger,\n      // this will trigger on all mouse hover too. Problem is that we don't\n      // have a cached stats mechanism for this tool yet?\n      triggerAnnotationModified(annotation, element);\n\n      let activeHandleCanvasCoords;\n\n      if (!isAnnotationVisible(annotationUID)) {\n        continue;\n      }\n\n      if (\n        !isAnnotationLocked(annotation) &&\n        !this.editData &&\n        activeHandleIndex !== null\n      ) {\n        // Not locked or creating and hovering over handle, so render handle.\n        activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n      }\n\n      if (activeHandleCanvasCoords) {\n        const handleGroupUID = '0';\n\n        drawHandlesSvg(\n          svgDrawingHelper,\n          annotationUID,\n          handleGroupUID,\n          activeHandleCanvasCoords,\n          {\n            color,\n          }\n        );\n      }\n\n      const rectangleUID = '0';\n      drawRectSvg(\n        svgDrawingHelper,\n        annotationUID,\n        rectangleUID,\n        canvasCoordinates[0],\n        canvasCoordinates[3],\n        {\n          color,\n          lineDash,\n          lineWidth,\n        }\n      );\n\n      renderStatus = true;\n    }\n\n    return renderStatus;\n  };\n}\n\nRectangleROIThresholdTool.toolName = 'RectangleROIThreshold';\nexport default RectangleROIThresholdTool;\n","import {\n  getEnabledElement,\n  cache,\n  StackViewport,\n  metaData,\n  utilities as csUtils,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { vec3 } from 'gl-matrix';\nimport {\n  addAnnotation,\n  getAnnotations,\n  removeAnnotation,\n} from '../../stateManagement';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport { triggerAnnotationModified } from '../../stateManagement/annotation/helpers/state';\nimport {\n  drawHandles as drawHandlesSvg,\n  drawRect as drawRectSvg,\n} from '../../drawingSvg';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport throttle from '../../utilities/throttle';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport {\n  hideElementCursor,\n  resetElementCursor,\n} from '../../cursors/elementCursor';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { triggerAnnotationCompleted } from '../../stateManagement/annotation/helpers/state';\n\nimport {\n  PublicToolProps,\n  ToolProps,\n  EventTypes,\n  SVGDrawingHelper,\n} from '../../types';\nimport { RectangleROIStartEndThresholdAnnotation } from '../../types/ToolSpecificAnnotationTypes';\nimport RectangleROITool from '../annotation/RectangleROITool';\nimport { StyleSpecifier } from '../../types/AnnotationStyle';\nimport { pointInShapeCallback } from '../../utilities/';\n\nconst { transformWorldToIndex } = csUtils;\n\n/**\n * This tool is similar to the RectangleROIThresholdTool which\n * only draws a rectangle on the image, and by using utility functions\n * such as thresholdByRange and thresholdByROIStat it can be used to\n * create a segmentation. The only difference is that it only acts on the\n * acquisition plane and not the 3D volume, and accepts a start and end\n * slice, and renders a dashed rectangle on the image between the start and end\n * but a solid rectangle on start and end slice. Utility functions should be used\n * to modify the start and end slice.\n * // Todo: right now only the first slice has grabbable handles, need to make\n * // it so that the handles are grabbable on all slices.\n */\nclass RectangleROIStartEndThresholdTool extends RectangleROITool {\n  static toolName;\n  _throttledCalculateCachedStats: any;\n  editData: {\n    annotation: any;\n    viewportIdsToRender: string[];\n    handleIndex?: number;\n    newAnnotation?: boolean;\n    hasMoved?: boolean;\n  } | null;\n  isDrawing: boolean;\n  isHandleOutsideImage: boolean;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      configuration: {\n        numSlicesToPropagate: 10,\n        computePointsInsideVolume: false,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n\n    this._throttledCalculateCachedStats = throttle(\n      this._calculateCachedStatsTool,\n      100,\n      { trailing: true }\n    );\n  }\n\n  /**\n   * Based on the current position of the mouse and the enabledElement it creates\n   * the edit data for the tool.\n   *\n   * @param evt -  EventTypes.NormalizedMouseEventType\n   * @returns The annotation object.\n   *\n   */\n  addNewAnnotation = (evt: EventTypes.InteractionEventType) => {\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const worldPos = currentPoints.world;\n\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n\n    this.isDrawing = true;\n\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, viewUp } = camera;\n\n    let referencedImageId, imageVolume, volumeId;\n    if (viewport instanceof StackViewport) {\n      throw new Error('Stack Viewport Not implemented');\n    } else {\n      const targetId = this.getTargetId(viewport);\n      volumeId = csUtils.getVolumeId(targetId);\n      imageVolume = cache.getVolume(volumeId);\n      referencedImageId = csUtils.getClosestImageId(\n        imageVolume,\n        worldPos,\n        viewPlaneNormal\n      );\n    }\n\n    if (!referencedImageId) {\n      throw new Error('This tool does not work on non-acquisition planes');\n    }\n\n    const startIndex = viewport.getCurrentImageIdIndex();\n    const spacingInNormal = csUtils.getSpacingInNormalDirection(\n      imageVolume,\n      viewPlaneNormal\n    );\n\n    // We cannot simply add numSlicesToPropagate to startIndex because\n    // the order of imageIds can be from top to bottom or bottom to top and\n    // we want to make sure it is always propagated in the direction of the\n    // view and also to make sure we don't go out of bounds.\n    const endIndex = this._getEndSliceIndex(\n      imageVolume,\n      worldPos,\n      spacingInNormal,\n      viewPlaneNormal\n    );\n\n    const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n\n    const annotation = {\n      highlighted: true,\n      invalidated: true,\n      metadata: {\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\n        enabledElement,\n        viewUp: <Types.Point3>[...viewUp],\n        FrameOfReferenceUID,\n        referencedImageId,\n        toolName: this.getToolName(),\n        volumeId,\n        spacingInNormal,\n      },\n      data: {\n        label: '',\n        startSlice: startIndex,\n        endSlice: endIndex,\n        cachedStats: {\n          pointsInVolume: [],\n          projectionPoints: [],\n          projectionPointsImageIds: [referencedImageId],\n        },\n        handles: {\n          // No need a textBox\n          textBox: {\n            hasMoved: false,\n            worldPosition: null,\n            worldBoundingBox: null,\n          },\n          points: [\n            <Types.Point3>[...worldPos],\n            <Types.Point3>[...worldPos],\n            <Types.Point3>[...worldPos],\n            <Types.Point3>[...worldPos],\n          ],\n          activeHandleIndex: null,\n        },\n        labelmapUID: null,\n      },\n    };\n\n    // update the projection points in 3D space, since we are projecting\n    // the points to the slice plane, we need to make sure the points are\n    // computed for later export\n    this._computeProjectionPoints(annotation, imageVolume);\n\n    addAnnotation(annotation, element);\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      handleIndex: 3,\n      newAnnotation: true,\n      hasMoved: false,\n    };\n    this._activateDraw(element);\n\n    hideElementCursor(element);\n\n    evt.preventDefault();\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    return annotation;\n  };\n\n  _endCallback = (evt: EventTypes.InteractionEventType): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, viewportIdsToRender, newAnnotation, hasMoved } =\n      this.editData;\n    const { data } = annotation;\n\n    if (newAnnotation && !hasMoved) {\n      return;\n    }\n\n    data.handles.activeHandleIndex = null;\n\n    this._deactivateModify(element);\n    this._deactivateDraw(element);\n\n    resetElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n\n    this.editData = null;\n    this.isDrawing = false;\n\n    if (\n      this.isHandleOutsideImage &&\n      this.configuration.preventHandleOutsideImage\n    ) {\n      removeAnnotation(annotation.annotationUID);\n    }\n\n    const targetId = this.getTargetId(enabledElement.viewport);\n    const imageVolume = cache.getVolume(targetId.split(/volumeId:|\\?/)[1]);\n\n    if (this.configuration.calculatePointsInsideVolume) {\n      this._computePointsInsideVolume(annotation, imageVolume, enabledElement);\n    }\n\n    triggerAnnotationRenderForViewportIds(\n      enabledElement.renderingEngine,\n      viewportIdsToRender\n    );\n\n    if (newAnnotation) {\n      triggerAnnotationCompleted(annotation);\n    }\n  };\n\n  // Todo: make it work for planes other than acquisition planes\n  _computeProjectionPoints(\n    annotation: RectangleROIStartEndThresholdAnnotation,\n    imageVolume: Types.IImageVolume\n  ): void {\n    const { data, metadata } = annotation;\n    const { viewPlaneNormal, spacingInNormal } = metadata;\n    const { imageData } = imageVolume;\n    const { startSlice, endSlice } = data;\n    const { points } = data.handles;\n\n    const startIJK = transformWorldToIndex(imageData, points[0]);\n\n    if (startIJK[2] !== startSlice) {\n      throw new Error('Start slice does not match');\n    }\n\n    // substitute the end slice index 2 with startIJK index 2\n    const endIJK = vec3.fromValues(startIJK[0], startIJK[1], endSlice);\n\n    const startWorld = vec3.create();\n    imageData.indexToWorldVec3(startIJK, startWorld);\n\n    const endWorld = vec3.create();\n    imageData.indexToWorldVec3(endIJK, endWorld);\n\n    // distance between start and end slice in the world coordinate\n    const distance = vec3.distance(startWorld, endWorld);\n\n    // for each point inside points, navigate in the direction of the viewPlaneNormal\n    // with amount of spacingInNormal, and calculate the next slice until we reach the distance\n    const newProjectionPoints = [];\n    for (let dist = 0; dist < distance; dist += spacingInNormal) {\n      newProjectionPoints.push(\n        points.map((point) => {\n          const newPoint = vec3.create();\n          vec3.scaleAndAdd(newPoint, point, viewPlaneNormal, dist);\n          return Array.from(newPoint);\n        })\n      );\n    }\n\n    data.cachedStats.projectionPoints = newProjectionPoints;\n\n    // Find the imageIds for the projection points\n    const projectionPointsImageIds = [];\n    for (const RectanglePoints of newProjectionPoints) {\n      const imageId = csUtils.getClosestImageId(\n        imageVolume,\n        RectanglePoints[0],\n        viewPlaneNormal\n      );\n      projectionPointsImageIds.push(imageId);\n    }\n\n    data.cachedStats.projectionPointsImageIds = projectionPointsImageIds;\n  }\n\n  //This function return all the points inside the ROI for every slices between startSlice and endSlice\n  _computePointsInsideVolume(annotation, imageVolume, enabledElement) {\n    const { data } = annotation;\n    const projectionPoints = data.cachedStats.projectionPoints;\n\n    const pointsInsideVolume: Types.Point3[][] = [[]];\n\n    for (let i = 0; i < projectionPoints.length; i++) {\n      // If image does not exists for the targetId, skip. This can be due\n      // to various reasons such as if the target was a volumeViewport, and\n      // the volumeViewport has been decached in the meantime.\n      if (!imageVolume) {\n        continue;\n      }\n\n      const projectionPoint = projectionPoints[i][0];\n\n      const worldPos1 = data.handles.points[0];\n      const worldPos2 = data.handles.points[3];\n\n      const { dimensions, imageData } = imageVolume;\n\n      const worldPos1Index = transformWorldToIndex(imageData, worldPos1);\n      //We only need to change the Z of our bounds so we are getting the Z from the current projection point\n      const worldProjectionPointIndex = transformWorldToIndex(\n        imageData,\n        projectionPoint\n      );\n\n      worldPos1Index[0] = Math.floor(worldPos1Index[0]);\n      worldPos1Index[1] = Math.floor(worldPos1Index[1]);\n      worldPos1Index[2] = Math.floor(worldProjectionPointIndex[2]);\n\n      const worldPos2Index = transformWorldToIndex(imageData, worldPos2);\n\n      worldPos2Index[0] = Math.floor(worldPos2Index[0]);\n      worldPos2Index[1] = Math.floor(worldPos2Index[1]);\n      worldPos2Index[2] = Math.floor(worldProjectionPointIndex[2]);\n\n      // Check if one of the indexes are inside the volume, this then gives us\n      // Some area to do stats over.\n\n      if (this._isInsideVolume(worldPos1Index, worldPos2Index, dimensions)) {\n        this.isHandleOutsideImage = false;\n        const iMin = Math.min(worldPos1Index[0], worldPos2Index[0]);\n        const iMax = Math.max(worldPos1Index[0], worldPos2Index[0]);\n\n        const jMin = Math.min(worldPos1Index[1], worldPos2Index[1]);\n        const jMax = Math.max(worldPos1Index[1], worldPos2Index[1]);\n\n        const kMin = Math.min(worldPos1Index[2], worldPos2Index[2]);\n        const kMax = Math.max(worldPos1Index[2], worldPos2Index[2]);\n\n        const boundsIJK = [\n          [iMin, iMax],\n          [jMin, jMax],\n          [kMin, kMax],\n        ] as [Types.Point2, Types.Point2, Types.Point2];\n\n        const pointsInShape = pointInShapeCallback(\n          imageData,\n          () => true,\n          null,\n          boundsIJK\n        );\n\n        //@ts-ignore\n        pointsInsideVolume.push(pointsInShape);\n      }\n    }\n    data.cachedStats.pointsInVolume = pointsInsideVolume;\n  }\n\n  _calculateCachedStatsTool(annotation, enabledElement) {\n    const data = annotation.data;\n    const { viewport } = enabledElement;\n\n    const { cachedStats } = data;\n    const targetId = this.getTargetId(viewport);\n    const imageVolume = cache.getVolume(targetId.split(/volumeId:|\\?/)[1]);\n\n    // Todo: this shouldn't be here, this is a performance issue\n    // Since we are extending the RectangleROI class, we need to\n    // bring the logic for handle to some cachedStats calculation\n    this._computeProjectionPoints(annotation, imageVolume);\n\n    annotation.invalidated = false;\n\n    // Dispatching annotation modified\n    triggerAnnotationModified(annotation, viewport.element);\n\n    return cachedStats;\n  }\n\n  /**\n   * it is used to draw the rectangleROIStartEnd annotation in each\n   * request animation frame.\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    let renderStatus = false;\n    const { viewport } = enabledElement;\n\n    const annotations = getAnnotations(this.getToolName(), viewport.element);\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    const sliceIndex = viewport.getCurrentImageIdIndex();\n\n    const styleSpecifier: StyleSpecifier = {\n      toolGroupId: this.toolGroupId,\n      toolName: this.getToolName(),\n      viewportId: enabledElement.viewport.id,\n    };\n\n    for (let i = 0; i < annotations.length; i++) {\n      const annotation = annotations[\n        i\n      ] as RectangleROIStartEndThresholdAnnotation;\n      const { annotationUID, data } = annotation;\n      const { startSlice, endSlice } = data;\n      const { points, activeHandleIndex } = data.handles;\n\n      const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n\n      styleSpecifier.annotationUID = annotationUID;\n\n      const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);\n      const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\n      const color = this.getStyle('color', styleSpecifier, annotation);\n      // range of slices to render based on the start and end slice, like\n      // np.arange\n\n      // if indexIJK is outside the start/end slice, we don't render\n      if (\n        sliceIndex < Math.min(startSlice, endSlice) ||\n        sliceIndex > Math.max(startSlice, endSlice)\n      ) {\n        continue;\n      }\n\n      // WE HAVE TO CACHE STATS BEFORE FETCHING TEXT\n\n      if (annotation.invalidated) {\n        this._throttledCalculateCachedStats(annotation, enabledElement);\n      }\n\n      // if it is inside the start/end slice, but not exactly the first or\n      // last slice, we render the line in dash, but not the handles\n      let firstOrLastSlice = false;\n      if (sliceIndex === startSlice || sliceIndex === endSlice) {\n        firstOrLastSlice = true;\n      }\n\n      // If rendering engine has been destroyed while rendering\n      if (!viewport.getRenderingEngine()) {\n        console.warn('Rendering Engine has been destroyed');\n        return renderStatus;\n      }\n\n      let activeHandleCanvasCoords;\n\n      if (!isAnnotationVisible(annotationUID)) {\n        continue;\n      }\n\n      if (\n        !isAnnotationLocked(annotation) &&\n        !this.editData &&\n        activeHandleIndex !== null &&\n        firstOrLastSlice\n      ) {\n        // Not locked or creating and hovering over handle, so render handle.\n        activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n      }\n\n      if (activeHandleCanvasCoords) {\n        const handleGroupUID = '0';\n\n        drawHandlesSvg(\n          svgDrawingHelper,\n          annotationUID,\n          handleGroupUID,\n          activeHandleCanvasCoords,\n          {\n            color,\n          }\n        );\n      }\n\n      let lineDashToUse = lineDash;\n\n      if (!firstOrLastSlice) {\n        lineDashToUse = 2;\n      }\n\n      const rectangleUID = '0';\n      drawRectSvg(\n        svgDrawingHelper,\n        annotationUID,\n        rectangleUID,\n        canvasCoordinates[0],\n        canvasCoordinates[3],\n        {\n          color,\n          lineDash: lineDashToUse,\n          lineWidth,\n        }\n      );\n\n      renderStatus = true;\n    }\n\n    return renderStatus;\n  };\n\n  _getEndSliceIndex(\n    imageVolume: Types.IImageVolume,\n    worldPos: Types.Point3,\n    spacingInNormal: number,\n    viewPlaneNormal: Types.Point3\n  ): number | undefined {\n    const numSlicesToPropagate = this.configuration.numSlicesToPropagate;\n\n    // get end position by moving from worldPos in the direction of viewplaneNormal\n    // with amount of numSlicesToPropagate * spacingInNormal\n    const endPos = vec3.create();\n    vec3.scaleAndAdd(\n      endPos,\n      worldPos,\n      viewPlaneNormal,\n      numSlicesToPropagate * spacingInNormal\n    );\n\n    const halfSpacingInNormalDirection = spacingInNormal / 2;\n    // Loop through imageIds of the imageVolume and find the one that is closest to endPos\n    const { imageIds } = imageVolume;\n    let imageIdIndex;\n    for (let i = 0; i < imageIds.length; i++) {\n      const imageId = imageIds[i];\n\n      const { imagePositionPatient } = metaData.get(\n        'imagePlaneModule',\n        imageId\n      );\n\n      const dir = vec3.create();\n      vec3.sub(dir, endPos, imagePositionPatient);\n\n      const dot = vec3.dot(dir, viewPlaneNormal);\n\n      if (Math.abs(dot) < halfSpacingInNormalDirection) {\n        imageIdIndex = i;\n      }\n    }\n\n    return imageIdIndex;\n  }\n}\n\nRectangleROIStartEndThresholdTool.toolName = 'RectangleROIStartEndThreshold';\nexport default RectangleROIStartEndThresholdTool;\n","import { utilities } from '@cornerstonejs/core';\n\nimport {\n  getAnnotationNearPoint,\n  getAnnotationNearPointOnEnabledElement,\n} from './getAnnotationNearPoint';\n\n// Lodash/common JS functionality\nimport debounce from './debounce';\nimport throttle from './throttle';\nimport isObject from './isObject';\nimport clip from './clip';\nimport calibrateImageSpacing from './calibrateImageSpacing';\nimport {\n  getCalibratedLengthUnitsAndScale,\n  getCalibratedProbeUnitsAndValue,\n  getCalibratedAspect,\n} from './getCalibratedUnits';\nimport triggerAnnotationRenderForViewportIds from './triggerAnnotationRenderForViewportIds';\nimport triggerAnnotationRenderForToolGroupIds from './triggerAnnotationRenderForToolGroupIds';\nimport triggerAnnotationRender from './triggerAnnotationRender';\nimport jumpToSlice from './viewport/jumpToSlice';\n\nimport pointInShapeCallback from './pointInShapeCallback';\nimport { getSphereBoundsInfo } from './getSphereBoundsInfo';\nimport scroll from './scroll';\nimport { pointToString } from './pointToString';\nimport annotationFrameRange from './annotationFrameRange';\nimport pointInSurroundingSphereCallback from './pointInSurroundingSphereCallback';\nimport getViewportForAnnotation from './getViewportForAnnotation';\n\n// name spaces\nimport * as contours from './contours';\nimport * as segmentation from './segmentation';\nimport * as drawing from './drawing';\nimport * as math from './math';\nimport * as planar from './planar';\nimport * as viewportFilters from './viewportFilters';\nimport * as orientation from './orientation';\nimport * as cine from './cine';\nimport * as boundingBox from './boundingBox';\nimport * as planarFreehandROITool from './planarFreehandROITool';\nimport * as rectangleROITool from './rectangleROITool';\nimport { stackPrefetch, stackContextPrefetch } from './stackPrefetch';\nimport * as viewport from './viewport';\nimport * as touch from './touch';\nimport * as dynamicVolume from './dynamicVolume';\nimport * as polyDataUtils from './polyData/utils';\nimport * as voi from './voi';\nimport * as contourSegmentation from './contourSegmentation';\n\nconst roundNumber = utilities.roundNumber;\n\n// Events\nimport { triggerEvent } from '@cornerstonejs/core';\n\nexport {\n  math,\n  planar,\n  viewportFilters,\n  drawing,\n  debounce,\n  dynamicVolume,\n  throttle,\n  orientation,\n  isObject,\n  touch,\n  triggerEvent,\n  calibrateImageSpacing,\n  getCalibratedLengthUnitsAndScale,\n  getCalibratedProbeUnitsAndValue,\n  getCalibratedAspect,\n  segmentation,\n  contours,\n  triggerAnnotationRenderForViewportIds,\n  triggerAnnotationRenderForToolGroupIds,\n  triggerAnnotationRender,\n  pointInShapeCallback,\n  getSphereBoundsInfo,\n  getAnnotationNearPoint,\n  getViewportForAnnotation,\n  getAnnotationNearPointOnEnabledElement,\n  jumpToSlice,\n  pointInSurroundingSphereCallback,\n  viewport,\n  cine,\n  clip,\n  boundingBox,\n  rectangleROITool,\n  planarFreehandROITool,\n  stackPrefetch,\n  stackContextPrefetch,\n  scroll,\n  roundNumber,\n  pointToString,\n  polyDataUtils,\n  voi,\n  annotationFrameRange,\n  contourSegmentation,\n};\n","import { m as macro } from '../../macros2.js';\nimport { b as roundVector, c as clampVector } from '../Core/Math/index.js';\nimport vtkBoundingBox from './BoundingBox.js';\nimport vtkDataSet from './DataSet.js';\nimport vtkStructuredData from './StructuredData.js';\nimport { StructuredType } from './StructuredData/Constants.js';\nimport { mat3, mat4, vec3 } from 'gl-matrix';\n\nconst {\n  vtkErrorMacro\n} = macro;\n\n// ----------------------------------------------------------------------------\n// vtkImageData methods\n// ----------------------------------------------------------------------------\n\nfunction vtkImageData(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkImageData');\n  publicAPI.setExtent = function () {\n    if (model.deleted) {\n      vtkErrorMacro('instance deleted - cannot call any method');\n      return false;\n    }\n    for (var _len = arguments.length, inExtent = new Array(_len), _key = 0; _key < _len; _key++) {\n      inExtent[_key] = arguments[_key];\n    }\n    const extentArray = inExtent.length === 1 ? inExtent[0] : inExtent;\n    if (extentArray.length !== 6) {\n      return false;\n    }\n    const changeDetected = model.extent.some((item, index) => item !== extentArray[index]);\n    if (changeDetected) {\n      model.extent = extentArray.slice();\n      model.dataDescription = vtkStructuredData.getDataDescriptionFromExtent(model.extent);\n      publicAPI.modified();\n    }\n    return changeDetected;\n  };\n  publicAPI.setDimensions = function () {\n    let i;\n    let j;\n    let k;\n    if (model.deleted) {\n      vtkErrorMacro('instance deleted - cannot call any method');\n      return;\n    }\n    if (arguments.length === 1) {\n      const array = arguments.length <= 0 ? undefined : arguments[0];\n      i = array[0];\n      j = array[1];\n      k = array[2];\n    } else if (arguments.length === 3) {\n      i = arguments.length <= 0 ? undefined : arguments[0];\n      j = arguments.length <= 1 ? undefined : arguments[1];\n      k = arguments.length <= 2 ? undefined : arguments[2];\n    } else {\n      vtkErrorMacro('Bad dimension specification');\n      return;\n    }\n    publicAPI.setExtent(0, i - 1, 0, j - 1, 0, k - 1);\n  };\n  publicAPI.getDimensions = () => [model.extent[1] - model.extent[0] + 1, model.extent[3] - model.extent[2] + 1, model.extent[5] - model.extent[4] + 1];\n  publicAPI.getNumberOfCells = () => {\n    const dims = publicAPI.getDimensions();\n    let nCells = 1;\n    for (let i = 0; i < 3; i++) {\n      if (dims[i] === 0) {\n        return 0;\n      }\n      if (dims[i] > 1) {\n        nCells *= dims[i] - 1;\n      }\n    }\n    return nCells;\n  };\n  publicAPI.getNumberOfPoints = () => {\n    const dims = publicAPI.getDimensions();\n    return dims[0] * dims[1] * dims[2];\n  };\n  publicAPI.getPoint = index => {\n    const dims = publicAPI.getDimensions();\n    if (dims[0] === 0 || dims[1] === 0 || dims[2] === 0) {\n      vtkErrorMacro('Requesting a point from an empty image.');\n      return null;\n    }\n    const ijk = new Float64Array(3);\n    switch (model.dataDescription) {\n      case StructuredType.EMPTY:\n        return null;\n      case StructuredType.SINGLE_POINT:\n        break;\n      case StructuredType.X_LINE:\n        ijk[0] = index;\n        break;\n      case StructuredType.Y_LINE:\n        ijk[1] = index;\n        break;\n      case StructuredType.Z_LINE:\n        ijk[2] = index;\n        break;\n      case StructuredType.XY_PLANE:\n        ijk[0] = index % dims[0];\n        ijk[1] = index / dims[0];\n        break;\n      case StructuredType.YZ_PLANE:\n        ijk[1] = index % dims[1];\n        ijk[2] = index / dims[1];\n        break;\n      case StructuredType.XZ_PLANE:\n        ijk[0] = index % dims[0];\n        ijk[2] = index / dims[0];\n        break;\n      case StructuredType.XYZ_GRID:\n        ijk[0] = index % dims[0];\n        ijk[1] = index / dims[0] % dims[1];\n        ijk[2] = index / (dims[0] * dims[1]);\n        break;\n      default:\n        vtkErrorMacro('Invalid dataDescription');\n        break;\n    }\n    const coords = [0, 0, 0];\n    publicAPI.indexToWorld(ijk, coords);\n    return coords;\n  };\n\n  // vtkCell *GetCell(vtkIdType cellId) VTK_OVERRIDE;\n  // void GetCell(vtkIdType cellId, vtkGenericCell *cell) VTK_OVERRIDE;\n  // void GetCellBounds(vtkIdType cellId, double bounds[6]) VTK_OVERRIDE;\n  // virtual vtkIdType FindPoint(double x, double y, double z)\n  // {\n  //   return this->vtkDataSet::FindPoint(x, y, z);\n  // }\n  // vtkIdType FindPoint(double x[3]) VTK_OVERRIDE;\n  // vtkIdType FindCell(\n  //   double x[3], vtkCell *cell, vtkIdType cellId, double tol2,\n  //   int& subId, double pcoords[3], double *weights) VTK_OVERRIDE;\n  // vtkIdType FindCell(\n  //   double x[3], vtkCell *cell, vtkGenericCell *gencell,\n  //   vtkIdType cellId, double tol2, int& subId,\n  //   double pcoords[3], double *weights) VTK_OVERRIDE;\n  // vtkCell *FindAndGetCell(double x[3], vtkCell *cell, vtkIdType cellId,\n  //                                 double tol2, int& subId, double pcoords[3],\n  //                                 double *weights) VTK_OVERRIDE;\n  // int GetCellType(vtkIdType cellId) VTK_OVERRIDE;\n  // void GetCellPoints(vtkIdType cellId, vtkIdList *ptIds) VTK_OVERRIDE\n  //   {vtkStructuredData::GetCellPoints(cellId,ptIds,this->DataDescription,\n  //                                     this->GetDimensions());}\n  // void GetPointCells(vtkIdType ptId, vtkIdList *cellIds) VTK_OVERRIDE\n  //   {vtkStructuredData::GetPointCells(ptId,cellIds,this->GetDimensions());}\n  // void ComputeBounds() VTK_OVERRIDE;\n  // int GetMaxCellSize() VTK_OVERRIDE {return 8;}; //voxel is the largest\n\n  publicAPI.getBounds = () => publicAPI.extentToBounds(publicAPI.getSpatialExtent());\n  publicAPI.extentToBounds = ex => vtkBoundingBox.transformBounds(ex, model.indexToWorld);\n  publicAPI.getSpatialExtent = () => vtkBoundingBox.inflate([...model.extent], 0.5);\n\n  // Internal, shouldn't need to call this manually.\n  publicAPI.computeTransforms = () => {\n    mat4.fromTranslation(model.indexToWorld, model.origin);\n    model.indexToWorld[0] = model.direction[0];\n    model.indexToWorld[1] = model.direction[1];\n    model.indexToWorld[2] = model.direction[2];\n    model.indexToWorld[4] = model.direction[3];\n    model.indexToWorld[5] = model.direction[4];\n    model.indexToWorld[6] = model.direction[5];\n    model.indexToWorld[8] = model.direction[6];\n    model.indexToWorld[9] = model.direction[7];\n    model.indexToWorld[10] = model.direction[8];\n    mat4.scale(model.indexToWorld, model.indexToWorld, model.spacing);\n    mat4.invert(model.worldToIndex, model.indexToWorld);\n  };\n  publicAPI.indexToWorld = function (ain) {\n    let aout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    vec3.transformMat4(aout, ain, model.indexToWorld);\n    return aout;\n  };\n  publicAPI.indexToWorldVec3 = publicAPI.indexToWorld;\n  publicAPI.worldToIndex = function (ain) {\n    let aout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    vec3.transformMat4(aout, ain, model.worldToIndex);\n    return aout;\n  };\n  publicAPI.worldToIndexVec3 = publicAPI.worldToIndex;\n  publicAPI.indexToWorldBounds = function (bin) {\n    let bout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    return vtkBoundingBox.transformBounds(bin, model.indexToWorld, bout);\n  };\n  publicAPI.worldToIndexBounds = function (bin) {\n    let bout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    return vtkBoundingBox.transformBounds(bin, model.worldToIndex, bout);\n  };\n\n  // Make sure the transform is correct\n  publicAPI.onModified(publicAPI.computeTransforms);\n  publicAPI.computeTransforms();\n  publicAPI.getCenter = () => vtkBoundingBox.getCenter(publicAPI.getBounds());\n  publicAPI.computeHistogram = function (worldBounds) {\n    let voxelFunc = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    const bounds = [0, 0, 0, 0, 0, 0];\n    publicAPI.worldToIndexBounds(worldBounds, bounds);\n    const point1 = [0, 0, 0];\n    const point2 = [0, 0, 0];\n    vtkBoundingBox.computeCornerPoints(bounds, point1, point2);\n    roundVector(point1, point1);\n    roundVector(point2, point2);\n    const dimensions = publicAPI.getDimensions();\n    clampVector(point1, [0, 0, 0], [dimensions[0] - 1, dimensions[1] - 1, dimensions[2] - 1], point1);\n    clampVector(point2, [0, 0, 0], [dimensions[0] - 1, dimensions[1] - 1, dimensions[2] - 1], point2);\n    const yStride = dimensions[0];\n    const zStride = dimensions[0] * dimensions[1];\n    const pixels = publicAPI.getPointData().getScalars().getData();\n    let maximum = -Infinity;\n    let minimum = Infinity;\n    let sumOfSquares = 0;\n    let isum = 0;\n    let inum = 0;\n    for (let z = point1[2]; z <= point2[2]; z++) {\n      for (let y = point1[1]; y <= point2[1]; y++) {\n        let index = point1[0] + y * yStride + z * zStride;\n        for (let x = point1[0]; x <= point2[0]; x++) {\n          if (!voxelFunc || voxelFunc([x, y, z], bounds)) {\n            const pixel = pixels[index];\n            if (pixel > maximum) maximum = pixel;\n            if (pixel < minimum) minimum = pixel;\n            sumOfSquares += pixel * pixel;\n            isum += pixel;\n            inum += 1;\n          }\n          ++index;\n        }\n      }\n    }\n    const average = inum > 0 ? isum / inum : 0;\n    const variance = inum ? Math.abs(sumOfSquares / inum - average * average) : 0;\n    const sigma = Math.sqrt(variance);\n    return {\n      minimum,\n      maximum,\n      average,\n      variance,\n      sigma,\n      count: inum\n    };\n  };\n\n  // TODO: use the unimplemented `vtkDataSetAttributes` for scalar length, that is currently also a TODO (GetNumberOfComponents).\n  // Scalar data could be tuples for color information?\n  publicAPI.computeIncrements = function (extent) {\n    let numberOfComponents = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n    const increments = [];\n    let incr = numberOfComponents;\n\n    // Calculate array increment offsets\n    // similar to c++ vtkImageData::ComputeIncrements\n    for (let idx = 0; idx < 3; ++idx) {\n      increments[idx] = incr;\n      incr *= extent[idx * 2 + 1] - extent[idx * 2] + 1;\n    }\n    return increments;\n  };\n\n  /**\n   * @param {Number[]} index the localized `[i,j,k]` pixel array position. Float values will be rounded.\n   * @return {Number} the corresponding flattened index in the scalar array\n   */\n  publicAPI.computeOffsetIndex = _ref => {\n    let [i, j, k] = _ref;\n    const extent = publicAPI.getExtent();\n    const numberOfComponents = publicAPI.getPointData().getScalars().getNumberOfComponents();\n    const increments = publicAPI.computeIncrements(extent, numberOfComponents);\n    // Use the array increments to find the pixel index\n    // similar to c++ vtkImageData::GetArrayPointer\n    // Math.floor to catch \"practically 0\" e^-15 scenarios.\n    return Math.floor((Math.round(i) - extent[0]) * increments[0] + (Math.round(j) - extent[2]) * increments[1] + (Math.round(k) - extent[4]) * increments[2]);\n  };\n\n  /**\n   * @param {Number[]} xyz the [x,y,z] Array in world coordinates\n   * @return {Number|NaN} the corresponding pixel's index in the scalar array\n   */\n  publicAPI.getOffsetIndexFromWorld = xyz => {\n    const extent = publicAPI.getExtent();\n    const index = publicAPI.worldToIndex(xyz);\n\n    // Confirm indexed i,j,k coords are within the bounds of the volume\n    for (let idx = 0; idx < 3; ++idx) {\n      if (index[idx] < extent[idx * 2] || index[idx] > extent[idx * 2 + 1]) {\n        vtkErrorMacro(`GetScalarPointer: Pixel ${index} is not in memory. Current extent = ${extent}`);\n        return NaN;\n      }\n    }\n\n    // Assumed the index here is within 0 <-> scalarData.length, but doesn't hurt to check upstream\n    return publicAPI.computeOffsetIndex(index);\n  };\n  /**\n   * @param {Number[]} xyz the [x,y,z] Array in world coordinates\n   * @param {Number?} comp the scalar component index for multi-component scalars\n   * @return {Number|NaN} the corresponding pixel's scalar value\n   */\n  publicAPI.getScalarValueFromWorld = function (xyz) {\n    let comp = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    const numberOfComponents = publicAPI.getPointData().getScalars().getNumberOfComponents();\n    if (comp < 0 || comp >= numberOfComponents) {\n      vtkErrorMacro(`GetScalarPointer: Scalar Component ${comp} is not within bounds. Current Scalar numberOfComponents: ${numberOfComponents}`);\n      return NaN;\n    }\n    const offsetIndex = publicAPI.getOffsetIndexFromWorld(xyz);\n    if (Number.isNaN(offsetIndex)) {\n      // VTK Error Macro will have been tripped already, no need to do it again,\n      return offsetIndex;\n    }\n    return publicAPI.getPointData().getScalars().getComponent(offsetIndex, comp);\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  direction: null,\n  // a mat3\n  indexToWorld: null,\n  // a mat4\n  worldToIndex: null,\n  // a mat4\n  spacing: [1.0, 1.0, 1.0],\n  origin: [0.0, 0.0, 0.0],\n  extent: [0, -1, 0, -1, 0, -1],\n  dataDescription: StructuredType.EMPTY\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Inheritance\n  vtkDataSet.extend(publicAPI, model, initialValues);\n  if (!model.direction) {\n    model.direction = mat3.identity(new Float64Array(9));\n  } else if (Array.isArray(model.direction)) {\n    model.direction = new Float64Array(model.direction.slice(0, 9));\n  }\n  model.indexToWorld = new Float64Array(16);\n  model.worldToIndex = new Float64Array(16);\n\n  // Set/Get methods\n  macro.get(publicAPI, model, ['indexToWorld', 'worldToIndex']);\n  macro.setGetArray(publicAPI, model, ['origin', 'spacing'], 3);\n  macro.setGetArray(publicAPI, model, ['direction'], 9);\n  macro.getArray(publicAPI, model, ['extent'], 6);\n\n  // Object specific methods\n  vtkImageData(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkImageData');\n\n// ----------------------------------------------------------------------------\n\nvar vtkImageData$1 = {\n  newInstance,\n  extend\n};\n\nexport { vtkImageData$1 as default, extend, newInstance };\n","/**\n * lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright jQuery Foundation and other contributors <https://jquery.org/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** Used as the `TypeError` message for \"Functions\" methods. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0;\n\n/** `Object#toString` result references. */\nvar funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    symbolTag = '[object Symbol]';\n\n/** Used to match property names within property paths. */\nvar reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/,\n    reIsPlainProp = /^\\w*$/,\n    reLeadingDot = /^\\./,\n    rePropName = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g;\n\n/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n */\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n\n/** Used to match backslashes in property paths. */\nvar reEscapeChar = /\\\\(\\\\)?/g;\n\n/** Used to detect host constructors (Safari). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\n/**\n * Gets the value at `key` of `object`.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction getValue(object, key) {\n  return object == null ? undefined : object[key];\n}\n\n/**\n * Checks if `value` is a host object in IE < 9.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a host object, else `false`.\n */\nfunction isHostObject(value) {\n  // Many host objects are `Object` objects that can coerce to strings\n  // despite having improperly defined `toString` methods.\n  var result = false;\n  if (value != null && typeof value.toString != 'function') {\n    try {\n      result = !!(value + '');\n    } catch (e) {}\n  }\n  return result;\n}\n\n/** Used for built-in method references. */\nvar arrayProto = Array.prototype,\n    funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to detect overreaching core-js shims. */\nvar coreJsData = root['__core-js_shared__'];\n\n/** Used to detect methods masquerading as native. */\nvar maskSrcKey = (function() {\n  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n  return uid ? ('Symbol(src)_1.' + uid) : '';\n}());\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objectToString = objectProto.toString;\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/** Built-in value references. */\nvar Symbol = root.Symbol,\n    splice = arrayProto.splice;\n\n/* Built-in method references that are verified to be native. */\nvar Map = getNative(root, 'Map'),\n    nativeCreate = getNative(Object, 'create');\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolToString = symbolProto ? symbolProto.toString : undefined;\n\n/**\n * Creates a hash object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Hash(entries) {\n  var index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the hash.\n *\n * @private\n * @name clear\n * @memberOf Hash\n */\nfunction hashClear() {\n  this.__data__ = nativeCreate ? nativeCreate(null) : {};\n}\n\n/**\n * Removes `key` and its value from the hash.\n *\n * @private\n * @name delete\n * @memberOf Hash\n * @param {Object} hash The hash to modify.\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction hashDelete(key) {\n  return this.has(key) && delete this.__data__[key];\n}\n\n/**\n * Gets the hash value for `key`.\n *\n * @private\n * @name get\n * @memberOf Hash\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction hashGet(key) {\n  var data = this.__data__;\n  if (nativeCreate) {\n    var result = data[key];\n    return result === HASH_UNDEFINED ? undefined : result;\n  }\n  return hasOwnProperty.call(data, key) ? data[key] : undefined;\n}\n\n/**\n * Checks if a hash value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Hash\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction hashHas(key) {\n  var data = this.__data__;\n  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);\n}\n\n/**\n * Sets the hash `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Hash\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the hash instance.\n */\nfunction hashSet(key, value) {\n  var data = this.__data__;\n  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\n  return this;\n}\n\n// Add methods to `Hash`.\nHash.prototype.clear = hashClear;\nHash.prototype['delete'] = hashDelete;\nHash.prototype.get = hashGet;\nHash.prototype.has = hashHas;\nHash.prototype.set = hashSet;\n\n/**\n * Creates an list cache object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction ListCache(entries) {\n  var index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the list cache.\n *\n * @private\n * @name clear\n * @memberOf ListCache\n */\nfunction listCacheClear() {\n  this.__data__ = [];\n}\n\n/**\n * Removes `key` and its value from the list cache.\n *\n * @private\n * @name delete\n * @memberOf ListCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction listCacheDelete(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    return false;\n  }\n  var lastIndex = data.length - 1;\n  if (index == lastIndex) {\n    data.pop();\n  } else {\n    splice.call(data, index, 1);\n  }\n  return true;\n}\n\n/**\n * Gets the list cache value for `key`.\n *\n * @private\n * @name get\n * @memberOf ListCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction listCacheGet(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  return index < 0 ? undefined : data[index][1];\n}\n\n/**\n * Checks if a list cache value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf ListCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction listCacheHas(key) {\n  return assocIndexOf(this.__data__, key) > -1;\n}\n\n/**\n * Sets the list cache `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf ListCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the list cache instance.\n */\nfunction listCacheSet(key, value) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    data.push([key, value]);\n  } else {\n    data[index][1] = value;\n  }\n  return this;\n}\n\n// Add methods to `ListCache`.\nListCache.prototype.clear = listCacheClear;\nListCache.prototype['delete'] = listCacheDelete;\nListCache.prototype.get = listCacheGet;\nListCache.prototype.has = listCacheHas;\nListCache.prototype.set = listCacheSet;\n\n/**\n * Creates a map cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction MapCache(entries) {\n  var index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the map.\n *\n * @private\n * @name clear\n * @memberOf MapCache\n */\nfunction mapCacheClear() {\n  this.__data__ = {\n    'hash': new Hash,\n    'map': new (Map || ListCache),\n    'string': new Hash\n  };\n}\n\n/**\n * Removes `key` and its value from the map.\n *\n * @private\n * @name delete\n * @memberOf MapCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction mapCacheDelete(key) {\n  return getMapData(this, key)['delete'](key);\n}\n\n/**\n * Gets the map value for `key`.\n *\n * @private\n * @name get\n * @memberOf MapCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction mapCacheGet(key) {\n  return getMapData(this, key).get(key);\n}\n\n/**\n * Checks if a map value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf MapCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction mapCacheHas(key) {\n  return getMapData(this, key).has(key);\n}\n\n/**\n * Sets the map `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf MapCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the map cache instance.\n */\nfunction mapCacheSet(key, value) {\n  getMapData(this, key).set(key, value);\n  return this;\n}\n\n// Add methods to `MapCache`.\nMapCache.prototype.clear = mapCacheClear;\nMapCache.prototype['delete'] = mapCacheDelete;\nMapCache.prototype.get = mapCacheGet;\nMapCache.prototype.has = mapCacheHas;\nMapCache.prototype.set = mapCacheSet;\n\n/**\n * Gets the index at which the `key` is found in `array` of key-value pairs.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} key The key to search for.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction assocIndexOf(array, key) {\n  var length = array.length;\n  while (length--) {\n    if (eq(array[length][0], key)) {\n      return length;\n    }\n  }\n  return -1;\n}\n\n/**\n * The base implementation of `_.get` without support for default values.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @returns {*} Returns the resolved value.\n */\nfunction baseGet(object, path) {\n  path = isKey(path, object) ? [path] : castPath(path);\n\n  var index = 0,\n      length = path.length;\n\n  while (object != null && index < length) {\n    object = object[toKey(path[index++])];\n  }\n  return (index && index == length) ? object : undefined;\n}\n\n/**\n * The base implementation of `_.isNative` without bad shim checks.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function,\n *  else `false`.\n */\nfunction baseIsNative(value) {\n  if (!isObject(value) || isMasked(value)) {\n    return false;\n  }\n  var pattern = (isFunction(value) || isHostObject(value)) ? reIsNative : reIsHostCtor;\n  return pattern.test(toSource(value));\n}\n\n/**\n * The base implementation of `_.toString` which doesn't convert nullish\n * values to empty strings.\n *\n * @private\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n */\nfunction baseToString(value) {\n  // Exit early for strings to avoid a performance hit in some environments.\n  if (typeof value == 'string') {\n    return value;\n  }\n  if (isSymbol(value)) {\n    return symbolToString ? symbolToString.call(value) : '';\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\n/**\n * Casts `value` to a path array if it's not one.\n *\n * @private\n * @param {*} value The value to inspect.\n * @returns {Array} Returns the cast property path array.\n */\nfunction castPath(value) {\n  return isArray(value) ? value : stringToPath(value);\n}\n\n/**\n * Gets the data for `map`.\n *\n * @private\n * @param {Object} map The map to query.\n * @param {string} key The reference key.\n * @returns {*} Returns the map data.\n */\nfunction getMapData(map, key) {\n  var data = map.__data__;\n  return isKeyable(key)\n    ? data[typeof key == 'string' ? 'string' : 'hash']\n    : data.map;\n}\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  var value = getValue(object, key);\n  return baseIsNative(value) ? value : undefined;\n}\n\n/**\n * Checks if `value` is a property name and not a property path.\n *\n * @private\n * @param {*} value The value to check.\n * @param {Object} [object] The object to query keys on.\n * @returns {boolean} Returns `true` if `value` is a property name, else `false`.\n */\nfunction isKey(value, object) {\n  if (isArray(value)) {\n    return false;\n  }\n  var type = typeof value;\n  if (type == 'number' || type == 'symbol' || type == 'boolean' ||\n      value == null || isSymbol(value)) {\n    return true;\n  }\n  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||\n    (object != null && value in Object(object));\n}\n\n/**\n * Checks if `value` is suitable for use as unique object key.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n */\nfunction isKeyable(value) {\n  var type = typeof value;\n  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n    ? (value !== '__proto__')\n    : (value === null);\n}\n\n/**\n * Checks if `func` has its source masked.\n *\n * @private\n * @param {Function} func The function to check.\n * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n */\nfunction isMasked(func) {\n  return !!maskSrcKey && (maskSrcKey in func);\n}\n\n/**\n * Converts `string` to a property path array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the property path array.\n */\nvar stringToPath = memoize(function(string) {\n  string = toString(string);\n\n  var result = [];\n  if (reLeadingDot.test(string)) {\n    result.push('');\n  }\n  string.replace(rePropName, function(match, number, quote, string) {\n    result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));\n  });\n  return result;\n});\n\n/**\n * Converts `value` to a string key if it's not a string or symbol.\n *\n * @private\n * @param {*} value The value to inspect.\n * @returns {string|symbol} Returns the key.\n */\nfunction toKey(value) {\n  if (typeof value == 'string' || isSymbol(value)) {\n    return value;\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\n/**\n * Converts `func` to its source code.\n *\n * @private\n * @param {Function} func The function to process.\n * @returns {string} Returns the source code.\n */\nfunction toSource(func) {\n  if (func != null) {\n    try {\n      return funcToString.call(func);\n    } catch (e) {}\n    try {\n      return (func + '');\n    } catch (e) {}\n  }\n  return '';\n}\n\n/**\n * Creates a function that memoizes the result of `func`. If `resolver` is\n * provided, it determines the cache key for storing the result based on the\n * arguments provided to the memoized function. By default, the first argument\n * provided to the memoized function is used as the map cache key. The `func`\n * is invoked with the `this` binding of the memoized function.\n *\n * **Note:** The cache is exposed as the `cache` property on the memoized\n * function. Its creation may be customized by replacing the `_.memoize.Cache`\n * constructor with one whose instances implement the\n * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)\n * method interface of `delete`, `get`, `has`, and `set`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to have its output memoized.\n * @param {Function} [resolver] The function to resolve the cache key.\n * @returns {Function} Returns the new memoized function.\n * @example\n *\n * var object = { 'a': 1, 'b': 2 };\n * var other = { 'c': 3, 'd': 4 };\n *\n * var values = _.memoize(_.values);\n * values(object);\n * // => [1, 2]\n *\n * values(other);\n * // => [3, 4]\n *\n * object.a = 2;\n * values(object);\n * // => [1, 2]\n *\n * // Modify the result cache.\n * values.cache.set(object, ['a', 'b']);\n * values(object);\n * // => ['a', 'b']\n *\n * // Replace `_.memoize.Cache`.\n * _.memoize.Cache = WeakMap;\n */\nfunction memoize(func, resolver) {\n  if (typeof func != 'function' || (resolver && typeof resolver != 'function')) {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  var memoized = function() {\n    var args = arguments,\n        key = resolver ? resolver.apply(this, args) : args[0],\n        cache = memoized.cache;\n\n    if (cache.has(key)) {\n      return cache.get(key);\n    }\n    var result = func.apply(this, args);\n    memoized.cache = cache.set(key, result);\n    return result;\n  };\n  memoized.cache = new (memoize.Cache || MapCache);\n  return memoized;\n}\n\n// Assign cache to `_.memoize`.\nmemoize.Cache = MapCache;\n\n/**\n * Performs a\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * comparison between two values to determine if they are equivalent.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.eq(object, object);\n * // => true\n *\n * _.eq(object, other);\n * // => false\n *\n * _.eq('a', 'a');\n * // => true\n *\n * _.eq('a', Object('a'));\n * // => false\n *\n * _.eq(NaN, NaN);\n * // => true\n */\nfunction eq(value, other) {\n  return value === other || (value !== value && other !== other);\n}\n\n/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 8-9 which returns 'object' for typed array and other constructors.\n  var tag = isObject(value) ? objectToString.call(value) : '';\n  return tag == funcTag || tag == genTag;\n}\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return !!value && (type == 'object' || type == 'function');\n}\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return !!value && typeof value == 'object';\n}\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && objectToString.call(value) == symbolTag);\n}\n\n/**\n * Converts `value` to a string. An empty string is returned for `null`\n * and `undefined` values. The sign of `-0` is preserved.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n * @example\n *\n * _.toString(null);\n * // => ''\n *\n * _.toString(-0);\n * // => '-0'\n *\n * _.toString([1, 2, 3]);\n * // => '1,2,3'\n */\nfunction toString(value) {\n  return value == null ? '' : baseToString(value);\n}\n\n/**\n * Gets the value at `path` of `object`. If the resolved value is\n * `undefined`, the `defaultValue` is returned in its place.\n *\n * @static\n * @memberOf _\n * @since 3.7.0\n * @category Object\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @param {*} [defaultValue] The value returned for `undefined` resolved values.\n * @returns {*} Returns the resolved value.\n * @example\n *\n * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n *\n * _.get(object, 'a[0].b.c');\n * // => 3\n *\n * _.get(object, ['a', '0', 'b', 'c']);\n * // => 3\n *\n * _.get(object, 'a.b.c', 'default');\n * // => 'default'\n */\nfunction get(object, path, defaultValue) {\n  var result = object == null ? undefined : baseGet(object, path);\n  return result === undefined ? defaultValue : result;\n}\n\nmodule.exports = get;\n","/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nconst proxyMarker = Symbol(\"Comlink.proxy\");\nconst createEndpoint = Symbol(\"Comlink.endpoint\");\nconst releaseProxy = Symbol(\"Comlink.releaseProxy\");\nconst finalizer = Symbol(\"Comlink.finalizer\");\nconst throwMarker = Symbol(\"Comlink.thrown\");\nconst isObject = (val) => (typeof val === \"object\" && val !== null) || typeof val === \"function\";\n/**\n * Internal transfer handle to handle objects marked to proxy.\n */\nconst proxyTransferHandler = {\n    canHandle: (val) => isObject(val) && val[proxyMarker],\n    serialize(obj) {\n        const { port1, port2 } = new MessageChannel();\n        expose(obj, port1);\n        return [port2, [port2]];\n    },\n    deserialize(port) {\n        port.start();\n        return wrap(port);\n    },\n};\n/**\n * Internal transfer handler to handle thrown exceptions.\n */\nconst throwTransferHandler = {\n    canHandle: (value) => isObject(value) && throwMarker in value,\n    serialize({ value }) {\n        let serialized;\n        if (value instanceof Error) {\n            serialized = {\n                isError: true,\n                value: {\n                    message: value.message,\n                    name: value.name,\n                    stack: value.stack,\n                },\n            };\n        }\n        else {\n            serialized = { isError: false, value };\n        }\n        return [serialized, []];\n    },\n    deserialize(serialized) {\n        if (serialized.isError) {\n            throw Object.assign(new Error(serialized.value.message), serialized.value);\n        }\n        throw serialized.value;\n    },\n};\n/**\n * Allows customizing the serialization of certain values.\n */\nconst transferHandlers = new Map([\n    [\"proxy\", proxyTransferHandler],\n    [\"throw\", throwTransferHandler],\n]);\nfunction isAllowedOrigin(allowedOrigins, origin) {\n    for (const allowedOrigin of allowedOrigins) {\n        if (origin === allowedOrigin || allowedOrigin === \"*\") {\n            return true;\n        }\n        if (allowedOrigin instanceof RegExp && allowedOrigin.test(origin)) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction expose(obj, ep = globalThis, allowedOrigins = [\"*\"]) {\n    ep.addEventListener(\"message\", function callback(ev) {\n        if (!ev || !ev.data) {\n            return;\n        }\n        if (!isAllowedOrigin(allowedOrigins, ev.origin)) {\n            console.warn(`Invalid origin '${ev.origin}' for comlink proxy`);\n            return;\n        }\n        const { id, type, path } = Object.assign({ path: [] }, ev.data);\n        const argumentList = (ev.data.argumentList || []).map(fromWireValue);\n        let returnValue;\n        try {\n            const parent = path.slice(0, -1).reduce((obj, prop) => obj[prop], obj);\n            const rawValue = path.reduce((obj, prop) => obj[prop], obj);\n            switch (type) {\n                case \"GET\" /* MessageType.GET */:\n                    {\n                        returnValue = rawValue;\n                    }\n                    break;\n                case \"SET\" /* MessageType.SET */:\n                    {\n                        parent[path.slice(-1)[0]] = fromWireValue(ev.data.value);\n                        returnValue = true;\n                    }\n                    break;\n                case \"APPLY\" /* MessageType.APPLY */:\n                    {\n                        returnValue = rawValue.apply(parent, argumentList);\n                    }\n                    break;\n                case \"CONSTRUCT\" /* MessageType.CONSTRUCT */:\n                    {\n                        const value = new rawValue(...argumentList);\n                        returnValue = proxy(value);\n                    }\n                    break;\n                case \"ENDPOINT\" /* MessageType.ENDPOINT */:\n                    {\n                        const { port1, port2 } = new MessageChannel();\n                        expose(obj, port2);\n                        returnValue = transfer(port1, [port1]);\n                    }\n                    break;\n                case \"RELEASE\" /* MessageType.RELEASE */:\n                    {\n                        returnValue = undefined;\n                    }\n                    break;\n                default:\n                    return;\n            }\n        }\n        catch (value) {\n            returnValue = { value, [throwMarker]: 0 };\n        }\n        Promise.resolve(returnValue)\n            .catch((value) => {\n            return { value, [throwMarker]: 0 };\n        })\n            .then((returnValue) => {\n            const [wireValue, transferables] = toWireValue(returnValue);\n            ep.postMessage(Object.assign(Object.assign({}, wireValue), { id }), transferables);\n            if (type === \"RELEASE\" /* MessageType.RELEASE */) {\n                // detach and deactive after sending release response above.\n                ep.removeEventListener(\"message\", callback);\n                closeEndPoint(ep);\n                if (finalizer in obj && typeof obj[finalizer] === \"function\") {\n                    obj[finalizer]();\n                }\n            }\n        })\n            .catch((error) => {\n            // Send Serialization Error To Caller\n            const [wireValue, transferables] = toWireValue({\n                value: new TypeError(\"Unserializable return value\"),\n                [throwMarker]: 0,\n            });\n            ep.postMessage(Object.assign(Object.assign({}, wireValue), { id }), transferables);\n        });\n    });\n    if (ep.start) {\n        ep.start();\n    }\n}\nfunction isMessagePort(endpoint) {\n    return endpoint.constructor.name === \"MessagePort\";\n}\nfunction closeEndPoint(endpoint) {\n    if (isMessagePort(endpoint))\n        endpoint.close();\n}\nfunction wrap(ep, target) {\n    return createProxy(ep, [], target);\n}\nfunction throwIfProxyReleased(isReleased) {\n    if (isReleased) {\n        throw new Error(\"Proxy has been released and is not useable\");\n    }\n}\nfunction releaseEndpoint(ep) {\n    return requestResponseMessage(ep, {\n        type: \"RELEASE\" /* MessageType.RELEASE */,\n    }).then(() => {\n        closeEndPoint(ep);\n    });\n}\nconst proxyCounter = new WeakMap();\nconst proxyFinalizers = \"FinalizationRegistry\" in globalThis &&\n    new FinalizationRegistry((ep) => {\n        const newCount = (proxyCounter.get(ep) || 0) - 1;\n        proxyCounter.set(ep, newCount);\n        if (newCount === 0) {\n            releaseEndpoint(ep);\n        }\n    });\nfunction registerProxy(proxy, ep) {\n    const newCount = (proxyCounter.get(ep) || 0) + 1;\n    proxyCounter.set(ep, newCount);\n    if (proxyFinalizers) {\n        proxyFinalizers.register(proxy, ep, proxy);\n    }\n}\nfunction unregisterProxy(proxy) {\n    if (proxyFinalizers) {\n        proxyFinalizers.unregister(proxy);\n    }\n}\nfunction createProxy(ep, path = [], target = function () { }) {\n    let isProxyReleased = false;\n    const proxy = new Proxy(target, {\n        get(_target, prop) {\n            throwIfProxyReleased(isProxyReleased);\n            if (prop === releaseProxy) {\n                return () => {\n                    unregisterProxy(proxy);\n                    releaseEndpoint(ep);\n                    isProxyReleased = true;\n                };\n            }\n            if (prop === \"then\") {\n                if (path.length === 0) {\n                    return { then: () => proxy };\n                }\n                const r = requestResponseMessage(ep, {\n                    type: \"GET\" /* MessageType.GET */,\n                    path: path.map((p) => p.toString()),\n                }).then(fromWireValue);\n                return r.then.bind(r);\n            }\n            return createProxy(ep, [...path, prop]);\n        },\n        set(_target, prop, rawValue) {\n            throwIfProxyReleased(isProxyReleased);\n            // FIXME: ES6 Proxy Handler `set` methods are supposed to return a\n            // boolean. To show good will, we return true asynchronously ¯\\_(ツ)_/¯\n            const [value, transferables] = toWireValue(rawValue);\n            return requestResponseMessage(ep, {\n                type: \"SET\" /* MessageType.SET */,\n                path: [...path, prop].map((p) => p.toString()),\n                value,\n            }, transferables).then(fromWireValue);\n        },\n        apply(_target, _thisArg, rawArgumentList) {\n            throwIfProxyReleased(isProxyReleased);\n            const last = path[path.length - 1];\n            if (last === createEndpoint) {\n                return requestResponseMessage(ep, {\n                    type: \"ENDPOINT\" /* MessageType.ENDPOINT */,\n                }).then(fromWireValue);\n            }\n            // We just pretend that `bind()` didn’t happen.\n            if (last === \"bind\") {\n                return createProxy(ep, path.slice(0, -1));\n            }\n            const [argumentList, transferables] = processArguments(rawArgumentList);\n            return requestResponseMessage(ep, {\n                type: \"APPLY\" /* MessageType.APPLY */,\n                path: path.map((p) => p.toString()),\n                argumentList,\n            }, transferables).then(fromWireValue);\n        },\n        construct(_target, rawArgumentList) {\n            throwIfProxyReleased(isProxyReleased);\n            const [argumentList, transferables] = processArguments(rawArgumentList);\n            return requestResponseMessage(ep, {\n                type: \"CONSTRUCT\" /* MessageType.CONSTRUCT */,\n                path: path.map((p) => p.toString()),\n                argumentList,\n            }, transferables).then(fromWireValue);\n        },\n    });\n    registerProxy(proxy, ep);\n    return proxy;\n}\nfunction myFlat(arr) {\n    return Array.prototype.concat.apply([], arr);\n}\nfunction processArguments(argumentList) {\n    const processed = argumentList.map(toWireValue);\n    return [processed.map((v) => v[0]), myFlat(processed.map((v) => v[1]))];\n}\nconst transferCache = new WeakMap();\nfunction transfer(obj, transfers) {\n    transferCache.set(obj, transfers);\n    return obj;\n}\nfunction proxy(obj) {\n    return Object.assign(obj, { [proxyMarker]: true });\n}\nfunction windowEndpoint(w, context = globalThis, targetOrigin = \"*\") {\n    return {\n        postMessage: (msg, transferables) => w.postMessage(msg, targetOrigin, transferables),\n        addEventListener: context.addEventListener.bind(context),\n        removeEventListener: context.removeEventListener.bind(context),\n    };\n}\nfunction toWireValue(value) {\n    for (const [name, handler] of transferHandlers) {\n        if (handler.canHandle(value)) {\n            const [serializedValue, transferables] = handler.serialize(value);\n            return [\n                {\n                    type: \"HANDLER\" /* WireValueType.HANDLER */,\n                    name,\n                    value: serializedValue,\n                },\n                transferables,\n            ];\n        }\n    }\n    return [\n        {\n            type: \"RAW\" /* WireValueType.RAW */,\n            value,\n        },\n        transferCache.get(value) || [],\n    ];\n}\nfunction fromWireValue(value) {\n    switch (value.type) {\n        case \"HANDLER\" /* WireValueType.HANDLER */:\n            return transferHandlers.get(value.name).deserialize(value.value);\n        case \"RAW\" /* WireValueType.RAW */:\n            return value.value;\n    }\n}\nfunction requestResponseMessage(ep, msg, transfers) {\n    return new Promise((resolve) => {\n        const id = generateUUID();\n        ep.addEventListener(\"message\", function l(ev) {\n            if (!ev.data || !ev.data.id || ev.data.id !== id) {\n                return;\n            }\n            ep.removeEventListener(\"message\", l);\n            resolve(ev.data);\n        });\n        if (ep.start) {\n            ep.start();\n        }\n        ep.postMessage(Object.assign({ id }, msg), transfers);\n    });\n}\nfunction generateUUID() {\n    return new Array(4)\n        .fill(0)\n        .map(() => Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(16))\n        .join(\"-\");\n}\n\nexport { createEndpoint, expose, finalizer, proxy, proxyMarker, releaseProxy, transfer, transferHandlers, windowEndpoint, wrap };\n//# sourceMappingURL=comlink.mjs.map\n","import ascending from \"./ascending.js\";\nimport descending from \"./descending.js\";\n\nexport default function bisector(f) {\n  let compare1, compare2, delta;\n\n  // If an accessor is specified, promote it to a comparator. In this case we\n  // can test whether the search value is (self-) comparable. We can’t do this\n  // for a comparator (except for specific, known comparators) because we can’t\n  // tell if the comparator is symmetric, and an asymmetric comparator can’t be\n  // used to test whether a single value is comparable.\n  if (f.length !== 2) {\n    compare1 = ascending;\n    compare2 = (d, x) => ascending(f(d), x);\n    delta = (d, x) => f(d) - x;\n  } else {\n    compare1 = f === ascending || f === descending ? f : zero;\n    compare2 = f;\n    delta = f;\n  }\n\n  function left(a, x, lo = 0, hi = a.length) {\n    if (lo < hi) {\n      if (compare1(x, x) !== 0) return hi;\n      do {\n        const mid = (lo + hi) >>> 1;\n        if (compare2(a[mid], x) < 0) lo = mid + 1;\n        else hi = mid;\n      } while (lo < hi);\n    }\n    return lo;\n  }\n\n  function right(a, x, lo = 0, hi = a.length) {\n    if (lo < hi) {\n      if (compare1(x, x) !== 0) return hi;\n      do {\n        const mid = (lo + hi) >>> 1;\n        if (compare2(a[mid], x) <= 0) lo = mid + 1;\n        else hi = mid;\n      } while (lo < hi);\n    }\n    return lo;\n  }\n\n  function center(a, x, lo = 0, hi = a.length) {\n    const i = left(a, x, lo, hi - 1);\n    return i > lo && delta(a[i - 1], x) > -delta(a[i], x) ? i - 1 : i;\n  }\n\n  return {left, center, right};\n}\n\nfunction zero() {\n  return 0;\n}\n"],"names":["async","renderingEngine","stackInputs","viewportIds","immediateRender","suppressEvents","viewportId","viewport","getViewport","Error","addImages","console","warn","addStackPromises","map","Promise","all","volumeInputs","addVolumePromises","addVolumes","DEFAULT_SETTINGS","Symbol","RUNTIME_SETTINGS","OBJECT_SETTINGS_MAP","DICTIONARY","Settings","constructor","base","dictionary","Object","create","seal","defineProperty","this","value","set","key","get","unset","name","endsWith","deleteCount","namespace","slice","deleteAll","length","prototype","hasOwnProperty","call","startsWith","forEach","callback","iterate","extend","import","root","isPlainObject","keys","dump","context","deepSet","assert","subject","getRuntimeSettings","getDefaultSettings","subfield","defaultSettings","settingObj","setting","split","runtimeSettings","getObjectSettings","from","settings","objectSettingsMap","WeakMap","extendRuntimeSettings","references","last","current","previous","indexOf","isValidKey","prefix","record","failCount","has","add","field","delete","setAll","WeakSet","getPrototypeOf","separator","subKey","subContext","subContextValue","RENDERING_DEFAULTS","MINIMUM_SLAB_THICKNESS","MAXIMUM_RAY_DISTANCE","freeze","RequestType","ViewportStatus","BlendMode","BlendModes","GeometryType","ContourType","DynamicOperatorType","CalibrationTypes","getEnabledElement","element","viewportUid","renderingEngineUid","dataset","getEnabledElementByIds","renderingEngineId","hasBeenDestroyed","FrameOfReferenceUID","getFrameOfReferenceUID","getEnabledElementByViewportId","renderingEngines","i","id","getEnabledElements","enabledElements","getViewports","push","imageLoaders","unknownImageLoader","loadImageFromImageLoader","imageId","options","colonIndex","scheme","substring","loader","undefined","imageLoadObject","promise","then","image","triggerEvent","IMAGE_LOADED","error","errorObject","IMAGE_LOAD_FAILED","loadImageFromCacheOrVolume","ignoreCache","getImageLoadObject","cachedVolumeInfo","getVolumeContainingImageId","volume","loadStatus","loaded","imageIdIndex","convertToCornerstoneImage","cachedImage","getCachedImageBasedOnImageURI","loadImage","priority","requestType","loadAndCacheImage","putImageLoadObject","catch","err","loadAndCacheImages","imageIds","createAndCacheDerivedImage","referencedImageId","preventCache","uuidv4","skipCreateBuffer","onCacheAdd","imagePlaneModule","metaData","rows","columns","TypedArrayConstructor","getBufferConfiguration","targetBufferType","imageScalarData","derivedImageId","type","genericMetadataProvider","metadata","localImage","createAndCacheLocalImage","scalarData","resolve","createAndCacheDerivedImages","referencedImageIds","derivedImageIds","allPromises","newOptions","getDerivedImageId","promises","intercept","windowCenter","windowWidth","color","numComps","slope","minPixelValue","maxPixelValue","voiLUTFunction","getCanvas","height","width","rgba","columnPixelSpacing","rowPixelSpacing","invert","Uint8Array","Float32Array","Uint16Array","Int16Array","sizeInBytes","byteLength","getPixelData","numBytes","cancelLoadImage","filterRequests","additionalDetails","cancelFn","cancelLoadImages","cancelLoadAll","requestPool","getRequestPool","requests","pop","volumeId","loadObject","getVolumeLoadObject","cancel","clearRequestStack","registerImageLoader","imageLoader","registerUnknownImageLoader","oldImageLoader","unregisterAllImageLoaders","createAndCacheDerivedSegmentationImages","createAndCacheDerivedSegmentationImage","createInternalVTKRepresentation","dimensions","spacing","direction","origin","PhotometricInterpretation","numComponents","imageData","dataArrayAttrs","numberOfComponents","setDimensions","setSpacing","setDirection","setOrigin","isDynamicVolume","scalarDataArrays","vtkScalarArray","values","getPointData","addArray","setActiveScalars","addScalarDataArraysToImageData","getScalarDataArrays","scalarArray","setScalars","addScalarDataToImageData","getScalarData","volumeLoaders","unknownVolumeLoader","loadVolumeFromVolumeLoader","volumeLoadObject","setupCacheOptimizationEventListener","VOLUME_LOADED","VOLUME_LOADED_FAILED","loadVolume","createAndCacheVolume","putVolumeLoadObject","createAndCacheDerivedVolume","referencedVolumeId","referencedVolume","getVolume","targetBuffer","scalarLength","volumeScalarData","generateVolumeScalarData","derivedImageData","derivedVolume","createLocalVolume","validDataTypes","includes","cachedVolume","buffer","isCacheable","CACHE_SIZE_EXCEEDED","createAndCacheVolumeFromImages","volumeProps","generateVolumePropsFromImageIds","imagePromises","pixelData","offset","performCacheOptimizationForVolume","registerVolumeLoader","volumeLoader","getVolumeLoaderSchemes","registerUnknownVolumeLoader","oldVolumeLoader","getUnknownVolumeLoaderSchema","createAndCacheDerivedSegmentationVolume","createLocalSegmentationVolume","useNorm16Texture","rendering","use16BitTexture","isVolumeBuffer","sharedArrayBuffer","SharedArrayBuffer","providers","addProvider","provider","splice","removeProvider","removeAllProviders","getMetaData","queries","result","imageLoadPoolManager","R","grabDelay","setMaxSimultaneousRequests","Interaction","Thumbnail","Prefetch","RequestPoolManager","numRequests","interaction","thumbnail","prefetch","compute","awake","maxNumRequests","getMaxSimultaneousRequests","destroy","timeoutHandle","window","clearTimeout","addRequest","requestFn","requestDetails","startGrabbing","filterFunction","filter","sendRequests","requestsToSend","syncImageCount","getNextRequest","requestResult","e","finally","startAgain","interactionPriorities","getSortedPriorityGroups","shift","hasRemainingInteractionRequests","hasRemainingThumbnailRequests","hasRemainingPrefetchRequests","hasRemainingComputeRequests","Compute","setTimeout","Number","sort","a","b","el","detail","event","CustomEvent","cancelable","dispatchEvent","workerRegistry","workerPoolManager","registerWorker","workerName","workerFn","maxWorkerInstances","overwrite","autoTerminateOnIdle","enabled","idleTimeThreshold","idleCheckIntervalId","clearInterval","workerProperties","instances","loadCounters","lastActiveTime","nativeWorkers","Array","fill","worker","getNextWorkerAPI","workerInstances","instance","minLoadIndex","minLoadValue","currentLoadValue","api","index","executeTask","methodName","args","callbacks","reject","finalCallbacks","cb","processing","results","Date","now","setInterval","terminateIdleWorkers","_","terminateWorkerInstance","terminate","workerInstance","VIEWPORT_ELEMENT","getSvgNode","canvasHash","cacheKey","svgNodeCache","domRef","appendNode","svgLayerElement","svgNode","touched","appendChild","setNodeTouched","clearUntouched","cacheEntry","removeChild","enabledElement","viewportElement","internalDivElement","querySelector","_getSvgLayer","svgNodeCacheForCanvas","bind","fn","svgDrawingHelper","ToolModes","Active","Passive","Enabled","Disabled","PRIMARY_BINDINGS","mouseButton","MouseBindings","Primary","ToolGroup","viewportsInfo","toolOptions","currentActivePrimaryToolName","prevActivePrimaryToolName","restoreToolOptions","_toolInstances","getViewportIds","getViewportsInfo","getToolInstance","toolInstanceName","toolInstance","getToolInstances","hasTool","toolName","addTool","configuration","toolDefinition","tools","hasToolName","localToolInstance","toolClass","ToolClass","instantiatedTool","toolGroupId","addToolInstance","parentClassName","ToolClassToUse","ParentClass","ToolInstance","addViewport","getRenderingEngines","renderingEngineUIDToUse","some","vpId","getActivePrimaryMouseButtonTool","setViewportsCursorByToolName","eventDetail","eventTarget","Events","TOOLGROUP_VIEWPORT_ADDED","removeViewports","indices","vpInfo","match","TOOLGROUP_VIEWPORT_REMOVED","setActiveStrategy","strategyName","setToolMode","mode","setToolDisabled","setToolEnabled","setToolPassive","setToolActive","toolBindingsOptions","bindings","reduce","unique","binding","TouchBinding","numTouchPoints","MouseBinding","obj","hasSameBinding","useCursor","_hasMousePrimaryButtonBinding","cursor","MouseCursor","getDefinedCursor","_setCursorForViewports","onSetToolActive","_renderViewports","TOOL_ACTIVATED","_triggerToolModeChangedEvent","prevToolOptions","getToolOptions","assign","matchBindings","isArray","removeAllBindings","getDefaultPrimaryBindings","matchBinding","onSetToolPassive","onSetToolEnabled","onSetToolDisabled","toolOptionsForTool","find","_getCursor","cursorName","SVGMouseCursor","initElementCursor","setToolConfiguration","_configuration","onSetToolConfiguration","getDefaultMousePrimary","getToolConfiguration","configurationPath","getPrevActivePrimaryToolName","clone","newToolGroupId","fnToolFilter","toolGroup","sourceToolInstance","sourceToolOptions","sourceToolMode","primaryBindings","primary","getRenderingEngine","renderViewport","TOOL_MODE_CHANGED","binding1","binding2","modifierKey","toolGroups","tg","toolGroupIndex","findIndex","removeToolGroup","removeSegmentationsFromToolGroup","s","MODES","toolGroupToolNames","transformWorldToIndex","BidirectionalTool","toolProps","defaultToolProps","supportedInteractionTypes","preventHandleOutsideImage","getTextLines","defaultGetTextLines","super","isPointNearTool","annotation","canvasCoords","proximity","data","points","handles","canvasPoint1","worldToCanvas","canvasPoint2","line","start","x","y","end","distanceToPoint","toolSelectedCallback","evt","highlighted","viewportIdsToRender","getViewportIdsWithToolToRender","getToolName","editData","movingTextBox","_activateModify","hideElementCursor","preventDefault","handleSelectedCallback","handle","handleIndex","worldPosition","p","_endCallback","newAnnotation","hasMoved","activeHandleIndex","_deactivateModify","_deactivateDraw","resetElementCursor","firstLineSegmentLength","longAxis","shortAxisPoint0","shortAxisPoint1","longAxisVector","counterClockWisePerpendicularToLongAxis","currentShortAxisVector","shortAxis","isHandleOutsideImage","removeAnnotation","annotationUID","isDrawing","_dragDrawCallback","currentPoints","worldPos","world","canvasCoordPoints","shortAxisDistFromCenter","dx","dy","Math","sqrt","vectorX","vectorY","xMid","yMid","startX","startY","endX","endY","canvasToWorld","invalidated","_dragModifyCallback","deltaPoints","worldPosDelta","textBox","point","_dragModifyHandle","movingHandleIndex","canvasCoordHandlesCurrent","firstLineSegment","secondLineSegment","proposedPoint","proposedCanvasCoord","fixedHandleCanvasCoord","fixedHandleToProposedCoordVec","fixedHandleToOldCoordVec","proposedFirstLineSegment","_movingLongAxisWouldPutItThroughShortAxis","centerOfRotation","angle","_getSignedAngle","firstPointX","firstPointY","secondPointX","secondPointY","rotatedFirstPoint","cos","sin","rotatedFirstPointY","rotatedSecondPoint","rotatedSecondPointY","newFirstPoint","newSecondPoint","translateHandleIndex","canvasCoordsCurrent","longLineSegment","shortLineSegment","longLineSegmentVec","longLineSegmentVecNormalized","proposedToCurrentVec","movementLength","movementAlongLineSegmentLength","newTranslatedPoint","_activateDraw","isInteractingWithTool","addEventListener","MOUSE_UP","MOUSE_DRAG","MOUSE_MOVE","MOUSE_CLICK","TOUCH_TAP","TOUCH_END","TOUCH_DRAG","removeEventListener","renderAnnotation","renderStatus","annotations","getAnnotations","filterInteractableAnnotationsForElement","targetId","getTargetId","styleSpecifier","canvasCoordinates","lineWidth","lineDash","shadow","getAnnotationStyle","cachedStats","unit","_throttledCalculateCachedStats","_calculateCachedStats","activeHandleCanvasCoords","isAnnotationVisible","isAnnotationLocked","handleGroupUID","drawHandles","dataId1","dataId2","lineUID","drawLine","secondLineUID","getLinkedTextBoxStyle","visibility","worldBoundingBox","topLeft","topRight","bottomLeft","bottomRight","textLines","canvasTextBoxCoords","getTextBoxCoordsCanvas","textBoxPosition","textBoxUID","boundingBox","drawLinkedTextBox","left","top","vectorInSecondLineDirection","extendedSecondLineSegment","worldPos1","worldPos2","worldPos3","worldPos4","targetIds","getTargetIdImage","index1","index2","index3","index4","handles1","handles2","scale","scale1","units","units1","scale2","units2","dist1","_calculateLength","dist2","lengthUnit","widthUnit","_isInsideVolume","vector1","vector2","atan2","trailing","addNewAnnotation","camera","getCamera","viewPlaneNormal","viewUp","getReferencedImageId","label","addAnnotation","pos1","pos2","dz","roundNumber","pointCanProjectOnLine","polyline","EPSILON","CONSTANTS","PARALLEL_THRESHOLD","PlanarFreehandROITool","contourHoleAdditionModifierKey","KeyboardBindings","Shift","alwaysRenderOpenContourHandles","radius","allowOpenContours","closeContourProximity","checkCanvasEditFallbackProximity","makeClockWise","subPixelResolution","smoothing","smoothOnAdd","smoothOnEdit","knotsRatioPercentageOnAdd","knotsRatioPercentageOnEdit","interpolation","onInterpolationComplete","decimate","epsilon","calculateStats","statsCalculator","BasicStatsCalculator","isEditingClosed","isEditingOpen","createAnnotation","activateDraw","activateOpenContourEndEdit","contour","closed","activateClosedContourEdit","activateOpenContourEdit","previousPoint","p1","p2","pStart","pEnd","cancelDrawing","cancelOpenContourEdit","cancelClosedContourEdit","canvasPoint","originalWorldPoint","deltaXPoint","deltaYPoint","deltaInX","deltaInY","worldPosIndex","floor","iMin","iMax","jMin","jMax","kMin","kMax","j","min","max","worldPosIndex2","areaUnits","numPoints","projectedPolyline","maxX","canvasMaxX","maxY","canvasMaxY","minX","canvasMinX","minY","canvasMinY","math","topLeftBBWorld","topLeftBBIndex","bottomRightBBWorld","area","iDelta","jDelta","kDelta","ceil","boundsIJK","worldPosEnd","indexToWorld","canvasPosEnd","curRow","intersections","intersectionCounter","pointsInShape","pointLPS","pointIJK","getLineSegmentIntersectionsCoordinates","statsCallback","modalityUnitOptions","isPreScaled","isSuvScaled","modalityUnit","Modality","stats","getStatistics","perimeter","mean","stdDev","statsArray","array","areaUnit","ChangeTypes","StatsUpdated","_renderStats","annotationsToDisplay","VolumeViewport","spacingInNormalDirection","filterAnnotationsWithinSlice","filterAnnotationsForDisplay","annotationsWithParallelNormals","td","annotationViewPlaneNormal","isParallel","abs","halfSpacingInNormalDirection","focalPoint","annotationsWithinSlice","isVisible","dir","dot","isContourSegmentationTool","contourAnnotation","renderAnnotationInstance","renderContext","activeAnnotationUID","commonData","renderContourBeingDrawn","renderClosedContourBeingEdited","renderOpenContourBeingEdited","renderContour","_calculateStatsIfActive","cachedVolumeStats","isEmptyArea","areaLine","planarContourToolName","SegmentationDisplayTool","renderSegmentation","getToolGroup","toolGroupSegmentationRepresentations","getSegmentationRepresentations","toolGroupViewports","segmentationRenderList","representation","config","_getMergedRepresentationsConfig","viewportsRenderList","renderers","Labelmap","Contour","Surface","addPlanarFreeHandToolIfAbsent","display","renderedViewport","render","allSettled","segmentationRepresentation","setSegmentationVisibility","segmentationRepresentationUID","toolGroupConfig","globalConfig","RectangleROIThresholdTool","RectangleROITool","StackViewport","imageVolume","cache","segmentationId","triggerAnnotationRenderForViewportIds","getStyle","rectangleUID","drawRect","RectangleROIStartEndThresholdTool","numSlicesToPropagate","computePointsInsideVolume","startIndex","getCurrentImageIdIndex","spacingInNormal","endIndex","_getEndSliceIndex","startSlice","endSlice","pointsInVolume","projectionPoints","projectionPointsImageIds","labelmapUID","_computeProjectionPoints","calculatePointsInsideVolume","_computePointsInsideVolume","sliceIndex","firstOrLastSlice","lineDashToUse","throttle","_calculateCachedStatsTool","startIJK","endIJK","startWorld","indexToWorldVec3","endWorld","distance","newProjectionPoints","dist","newPoint","RectanglePoints","pointsInsideVolume","projectionPoint","worldPos1Index","worldProjectionPointIndex","worldPos2Index","pointInShapeCallback","endPos","imagePositionPatient","utilities","vtkErrorMacro","m","DEFAULT_VALUES","worldToIndex","extent","dataDescription","EMPTY","publicAPI","model","initialValues","arguments","Float64Array","setGetArray","getArray","classHierarchy","setExtent","deleted","_len","inExtent","_key","extentArray","changeDetected","item","modified","k","getDimensions","getNumberOfCells","dims","nCells","getNumberOfPoints","getPoint","ijk","SINGLE_POINT","X_LINE","Y_LINE","Z_LINE","XY_PLANE","YZ_PLANE","XZ_PLANE","XYZ_GRID","coords","getBounds","extentToBounds","getSpatialExtent","ex","computeTransforms","ain","aout","worldToIndexVec3","indexToWorldBounds","bin","bout","worldToIndexBounds","onModified","getCenter","computeHistogram","worldBounds","voxelFunc","bounds","point1","point2","c","yStride","zStride","pixels","getScalars","getData","maximum","minimum","Infinity","sumOfSquares","isum","inum","z","pixel","average","variance","sigma","count","computeIncrements","increments","incr","idx","computeOffsetIndex","_ref","getExtent","getNumberOfComponents","round","getOffsetIndexFromWorld","xyz","NaN","getScalarValueFromWorld","comp","offsetIndex","isNaN","getComponent","vtkImageData","vtkImageData$1","newInstance","HASH_UNDEFINED","INFINITY","funcTag","genTag","symbolTag","reIsDeepProp","reIsPlainProp","reLeadingDot","rePropName","reEscapeChar","reIsHostCtor","freeGlobal","g","freeSelf","self","Function","uid","arrayProto","funcProto","objectProto","coreJsData","maskSrcKey","exec","IE_PROTO","funcToString","toString","objectToString","reIsNative","RegExp","replace","Map","getNative","nativeCreate","symbolProto","symbolToString","Hash","entries","clear","entry","ListCache","MapCache","assocIndexOf","other","baseGet","object","path","isSymbol","test","isKey","stringToPath","toKey","baseIsNative","isObject","func","pattern","tag","isFunction","isHostObject","toSource","getMapData","__data__","getValue","memoize","string","baseToString","number","quote","resolver","TypeError","memoized","apply","Cache","isObjectLike","module","exports","defaultValue","proxyMarker","createEndpoint","releaseProxy","finalizer","throwMarker","val","transferHandlers","canHandle","serialize","port1","port2","MessageChannel","expose","deserialize","port","wrap","serialized","isError","message","stack","ep","globalThis","allowedOrigins","ev","allowedOrigin","isAllowedOrigin","argumentList","fromWireValue","returnValue","parent","prop","rawValue","proxy","transfers","transferCache","transfer","wireValue","transferables","toWireValue","postMessage","closeEndPoint","endpoint","isMessagePort","close","target","createProxy","throwIfProxyReleased","isReleased","releaseEndpoint","requestResponseMessage","proxyCounter","proxyFinalizers","FinalizationRegistry","newCount","isProxyReleased","Proxy","_target","unregister","unregisterProxy","r","_thisArg","rawArgumentList","processArguments","construct","register","registerProxy","processed","v","arr","concat","handler","serializedValue","msg","random","MAX_SAFE_INTEGER","join","l","bisector","f","compare1","compare2","delta","lo","hi","mid","d","zero","center","right"],"sourceRoot":""}