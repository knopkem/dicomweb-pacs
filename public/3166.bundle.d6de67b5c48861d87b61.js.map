{"version":3,"file":"3166.bundle.d6de67b5c48861d87b61.js","mappings":"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","sources":["webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/helpers/toArray.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/helpers/codeMeaningEquals.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/Cornerstone/MeasurementReport.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/Cornerstone/cornerstone4Tag.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/Cornerstone/Length.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/Cornerstone/FreehandRoi.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/Cornerstone/Bidirectional.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/Cornerstone/EllipticalRoi.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/Cornerstone/CircleRoi.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/Cornerstone/ArrowAnnotate.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/Cornerstone/CobbAngle.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/Cornerstone/Angle.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/Cornerstone/RectangleRoi.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/helpers/getDatasetsFromImages.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/Cornerstone/Segmentation_3X.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/helpers/compareArrays.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/helpers/checkOrientation.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/helpers/checkIfPerpendicular.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/enums/Events.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/Cornerstone/Segmentation_4X.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/Cornerstone/Segmentation.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/Cornerstone/ParametricMap.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/Cornerstone/index.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/Cornerstone3D/cornerstone3DTag.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/helpers/copyStudyTags.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/Cornerstone3D/CodingScheme.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/Cornerstone3D/MeasurementReport.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/Cornerstone3D/BaseAdapter3D.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/Cornerstone3D/ArrowAnnotate.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/Cornerstone3D/Bidirectional.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/Cornerstone3D/Angle.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/Cornerstone3D/CobbAngle.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/Cornerstone3D/CircleROI.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/Cornerstone3D/EllipticalROI.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/Cornerstone3D/RectangleROI.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/Cornerstone3D/Length.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/Cornerstone3D/PlanarFreehandROI.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/Cornerstone3D/Probe.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/Cornerstone3D/UltrasoundDirectional.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/Cornerstone3D/Segmentation/generateSegmentation.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/Cornerstone3D/Segmentation/generateLabelMaps2DFrom3D.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/Cornerstone3D/Segmentation/compactMergeSegData.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/Cornerstone3D/Segmentation/labelmapImagesFromBuffer.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/Cornerstone3D/Segmentation/generateToolState.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/Cornerstone3D/ParametricMap/generateToolState.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/Cornerstone3D/RTStruct/utilities/getReferencedFrameOfReferenceSequence.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/Cornerstone3D/RTStruct/utilities/getReferencedSeriesSequence.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/Cornerstone3D/RTStruct/utilities/getStructureSetModule.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/Cornerstone3D/RTStruct/RTSS.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/Cornerstone3D/RTStruct/utilities/getRTROIObservationsSequence.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/Cornerstone3D/RTStruct/utilities/getPatientModule.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/Cornerstone3D/RTStruct/utilities/getRTSeriesModule.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/Cornerstone3D/RTStruct/index.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/Cornerstone3D/KeyImage.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/Cornerstone3D/index.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/VTKjs/Segmentation.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/VTKjs/index.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/index.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/helpers/downloadDICOMData.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/enums/ChangeTypes.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/enums/Events.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/enums/SegmentationRepresentations.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/enums/StrategyCallbacks.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/enums/ToolBindings.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/enums/ToolModes.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/enums/Touch.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/enums/AnnotationStyleStates.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/enums/WorkerTypes.js","webpack:///../../../node_modules/iota-array/iota.js","webpack:///../../../node_modules/is-buffer/index.js","webpack:///../../../node_modules/ndarray/ndarray.js"],"sourcesContent":["const toArray = x => Array.isArray(x) ? x : [x];\n\nexport { toArray };\n","const codeMeaningEquals = codeMeaningName => {\n  return contentItem => {\n    return contentItem.ConceptNameCodeSequence.CodeMeaning === codeMeaningName;\n  };\n};\n\nexport { codeMeaningEquals };\n","import { utilities, derivations, normalizers, data } from 'dcmjs';\nimport { toArray } from '../helpers/toArray.js';\nimport { codeMeaningEquals } from '../helpers/codeMeaningEquals.js';\nimport 'buffer';\n\nconst {\n  TID1500,\n  addAccessors\n} = utilities;\nconst {\n  StructuredReport\n} = derivations;\nconst {\n  Normalizer\n} = normalizers;\nconst {\n  TID1500MeasurementReport,\n  TID1501MeasurementGroup\n} = TID1500;\nconst {\n  DicomMetaDictionary\n} = data;\nconst FINDING = {\n  CodingSchemeDesignator: \"DCM\",\n  CodeValue: \"121071\"\n};\nconst FINDING_SITE = {\n  CodingSchemeDesignator: \"SCT\",\n  CodeValue: \"363698007\"\n};\nconst FINDING_SITE_OLD = {\n  CodingSchemeDesignator: \"SRT\",\n  CodeValue: \"G-C0E3\"\n};\nconst codeValueMatch = (group, code, oldCode) => {\n  const {\n    ConceptNameCodeSequence\n  } = group;\n  if (!ConceptNameCodeSequence) {\n    return;\n  }\n  const {\n    CodingSchemeDesignator,\n    CodeValue\n  } = ConceptNameCodeSequence;\n  return CodingSchemeDesignator == code.CodingSchemeDesignator && CodeValue == code.CodeValue || oldCode && CodingSchemeDesignator == oldCode.CodingSchemeDesignator && CodeValue == oldCode.CodeValue;\n};\nfunction getTID300ContentItem(tool, ReferencedSOPSequence, adapterClass) {\n  const args = adapterClass.getTID300RepresentationArguments(tool);\n  args.ReferencedSOPSequence = ReferencedSOPSequence;\n  const TID300Measurement = new adapterClass.TID300Representation(args);\n  return TID300Measurement;\n}\nfunction getMeasurementGroup(toolType, toolData, ReferencedSOPSequence) {\n  const toolTypeData = toolData[toolType];\n  const toolClass = MeasurementReport.CORNERSTONE_TOOL_CLASSES_BY_TOOL_TYPE[toolType];\n  if (!toolTypeData || !toolTypeData.data || !toolTypeData.data.length || !toolClass) {\n    return;\n  }\n\n  // Loop through the array of tool instances\n  // for this tool\n  const Measurements = toolTypeData.data.map(tool => {\n    return getTID300ContentItem(tool, ReferencedSOPSequence, toolClass);\n  });\n  return new TID1501MeasurementGroup(Measurements);\n}\nclass MeasurementReport {\n  static getSetupMeasurementData(MeasurementGroup) {\n    const {\n      ContentSequence\n    } = MeasurementGroup;\n    const contentSequenceArr = toArray(ContentSequence);\n    const findingGroup = contentSequenceArr.find(group => codeValueMatch(group, FINDING));\n    const findingSiteGroups = contentSequenceArr.filter(group => codeValueMatch(group, FINDING_SITE, FINDING_SITE_OLD)) || [];\n    const NUMGroup = contentSequenceArr.find(group => group.ValueType === \"NUM\");\n    const SCOORDGroup = toArray(NUMGroup.ContentSequence).find(group => group.ValueType === \"SCOORD\");\n    const {\n      ReferencedSOPSequence\n    } = SCOORDGroup.ContentSequence;\n    const {\n      ReferencedSOPInstanceUID,\n      ReferencedFrameNumber\n    } = ReferencedSOPSequence;\n    const defaultState = {\n      sopInstanceUid: ReferencedSOPInstanceUID,\n      frameIndex: ReferencedFrameNumber || 1,\n      complete: true,\n      finding: findingGroup ? addAccessors(findingGroup.ConceptCodeSequence) : undefined,\n      findingSites: findingSiteGroups.map(fsg => {\n        return addAccessors(fsg.ConceptCodeSequence);\n      })\n    };\n    if (defaultState.finding) {\n      defaultState.description = defaultState.finding.CodeMeaning;\n    }\n    const findingSite = defaultState.findingSites && defaultState.findingSites[0];\n    if (findingSite) {\n      defaultState.location = findingSite[0] && findingSite[0].CodeMeaning || findingSite.CodeMeaning;\n    }\n    return {\n      defaultState,\n      findingGroup,\n      findingSiteGroups,\n      NUMGroup,\n      SCOORDGroup,\n      ReferencedSOPSequence,\n      ReferencedSOPInstanceUID,\n      ReferencedFrameNumber\n    };\n  }\n  static generateReport(toolState, metadataProvider, options) {\n    // ToolState for array of imageIDs to a Report\n    // Assume Cornerstone metadata provider has access to Study / Series / Sop Instance UID\n\n    let allMeasurementGroups = [];\n    const firstImageId = Object.keys(toolState)[0];\n    if (!firstImageId) {\n      throw new Error(\"No measurements provided.\");\n    }\n\n    /* Patient ID\n    Warning - Missing attribute or value that would be needed to build DICOMDIR - Patient ID\n    Warning - Missing attribute or value that would be needed to build DICOMDIR - Study Date\n    Warning - Missing attribute or value that would be needed to build DICOMDIR - Study Time\n    Warning - Missing attribute or value that would be needed to build DICOMDIR - Study ID\n     */\n    const generalSeriesModule = metadataProvider.get(\"generalSeriesModule\", firstImageId);\n\n    //const sopCommonModule = metadataProvider.get('sopCommonModule', firstImageId);\n\n    // NOTE: We are getting the Series and Study UIDs from the first imageId of the toolState\n    // which means that if the toolState is for multiple series, the report will have the incorrect\n    // SeriesInstanceUIDs\n    const {\n      studyInstanceUID,\n      seriesInstanceUID\n    } = generalSeriesModule;\n\n    // Loop through each image in the toolData\n    Object.keys(toolState).forEach(imageId => {\n      const sopCommonModule = metadataProvider.get(\"sopCommonModule\", imageId);\n      const frameNumber = metadataProvider.get(\"frameNumber\", imageId);\n      const toolData = toolState[imageId];\n      const toolTypes = Object.keys(toolData);\n      const ReferencedSOPSequence = {\n        ReferencedSOPClassUID: sopCommonModule.sopClassUID,\n        ReferencedSOPInstanceUID: sopCommonModule.sopInstanceUID\n      };\n      if (Normalizer.isMultiframeSOPClassUID(sopCommonModule.sopClassUID)) {\n        ReferencedSOPSequence.ReferencedFrameNumber = frameNumber;\n      }\n\n      // Loop through each tool type for the image\n      const measurementGroups = [];\n      toolTypes.forEach(toolType => {\n        const group = getMeasurementGroup(toolType, toolData, ReferencedSOPSequence);\n        if (group) {\n          measurementGroups.push(group);\n        }\n      });\n      allMeasurementGroups = allMeasurementGroups.concat(measurementGroups);\n    });\n    const MeasurementReport = new TID1500MeasurementReport({\n      TID1501MeasurementGroups: allMeasurementGroups\n    }, options);\n\n    // TODO: what is the correct metaheader\n    // http://dicom.nema.org/medical/Dicom/current/output/chtml/part10/chapter_7.html\n    // TODO: move meta creation to happen in derivations.js\n    const fileMetaInformationVersionArray = new Uint8Array(2);\n    fileMetaInformationVersionArray[1] = 1;\n    const derivationSourceDataset = {\n      StudyInstanceUID: studyInstanceUID,\n      SeriesInstanceUID: seriesInstanceUID\n      //SOPInstanceUID: sopInstanceUID, // TODO: Necessary?\n      //SOPClassUID: sopClassUID,\n    };\n    const _meta = {\n      FileMetaInformationVersion: {\n        Value: [fileMetaInformationVersionArray.buffer],\n        vr: \"OB\"\n      },\n      //MediaStorageSOPClassUID\n      //MediaStorageSOPInstanceUID: sopCommonModule.sopInstanceUID,\n      TransferSyntaxUID: {\n        Value: [\"1.2.840.10008.1.2.1\"],\n        vr: \"UI\"\n      },\n      ImplementationClassUID: {\n        Value: [DicomMetaDictionary.uid()],\n        // TODO: could be git hash or other valid id\n        vr: \"UI\"\n      },\n      ImplementationVersionName: {\n        Value: [\"dcmjs\"],\n        vr: \"SH\"\n      }\n    };\n    const _vrMap = {\n      PixelData: \"OW\"\n    };\n    derivationSourceDataset._meta = _meta;\n    derivationSourceDataset._vrMap = _vrMap;\n    const report = new StructuredReport([derivationSourceDataset]);\n    const contentItem = MeasurementReport.contentItem(derivationSourceDataset);\n\n    // Merge the derived dataset with the content from the Measurement Report\n    report.dataset = Object.assign(report.dataset, contentItem);\n    report.dataset._meta = _meta;\n    report.dataset.SpecificCharacterSet = \"ISO_IR 192\";\n    return report;\n  }\n\n  /**\n   * Generate Cornerstone tool state from dataset\n   * @param {object} dataset dataset\n   * @param {object} hooks\n   * @param {function} hooks.getToolClass Function to map dataset to a tool class\n   * @returns\n   */\n  static generateToolState(dataset) {\n    let hooks = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    // For now, bail out if the dataset is not a TID1500 SR with length measurements\n    if (dataset.ContentTemplateSequence.TemplateIdentifier !== \"1500\") {\n      throw new Error(\"This package can currently only interpret DICOM SR TID 1500\");\n    }\n    const REPORT = \"Imaging Measurements\";\n    const GROUP = \"Measurement Group\";\n    const TRACKING_IDENTIFIER = \"Tracking Identifier\";\n\n    // Identify the Imaging Measurements\n    const imagingMeasurementContent = toArray(dataset.ContentSequence).find(codeMeaningEquals(REPORT));\n\n    // Retrieve the Measurements themselves\n    const measurementGroups = toArray(imagingMeasurementContent.ContentSequence).filter(codeMeaningEquals(GROUP));\n\n    // For each of the supported measurement types, compute the measurement data\n    const measurementData = {};\n    const cornerstoneToolClasses = MeasurementReport.CORNERSTONE_TOOL_CLASSES_BY_UTILITY_TYPE;\n    const registeredToolClasses = [];\n    Object.keys(cornerstoneToolClasses).forEach(key => {\n      registeredToolClasses.push(cornerstoneToolClasses[key]);\n      measurementData[key] = [];\n    });\n    measurementGroups.forEach(measurementGroup => {\n      const measurementGroupContentSequence = toArray(measurementGroup.ContentSequence);\n      const TrackingIdentifierGroup = measurementGroupContentSequence.find(contentItem => contentItem.ConceptNameCodeSequence.CodeMeaning === TRACKING_IDENTIFIER);\n      const TrackingIdentifierValue = TrackingIdentifierGroup.TextValue;\n      const toolClass = hooks.getToolClass ? hooks.getToolClass(measurementGroup, dataset, registeredToolClasses) : registeredToolClasses.find(tc => tc.isValidCornerstoneTrackingIdentifier(TrackingIdentifierValue));\n      if (toolClass) {\n        const measurement = toolClass.getMeasurementData(measurementGroup);\n        console.log(`=== ${toolClass.toolType} ===`);\n        console.log(measurement);\n        measurementData[toolClass.toolType].push(measurement);\n      }\n    });\n\n    // NOTE: There is no way of knowing the cornerstone imageIds as that could be anything.\n    // That is up to the consumer to derive from the SOPInstanceUIDs.\n    return measurementData;\n  }\n  static registerTool(toolClass) {\n    MeasurementReport.CORNERSTONE_TOOL_CLASSES_BY_UTILITY_TYPE[toolClass.utilityToolType] = toolClass;\n    MeasurementReport.CORNERSTONE_TOOL_CLASSES_BY_TOOL_TYPE[toolClass.toolType] = toolClass;\n    MeasurementReport.MEASUREMENT_BY_TOOLTYPE[toolClass.toolType] = toolClass.utilityToolType;\n  }\n}\nMeasurementReport.MEASUREMENT_BY_TOOLTYPE = {};\nMeasurementReport.CORNERSTONE_TOOL_CLASSES_BY_UTILITY_TYPE = {};\nMeasurementReport.CORNERSTONE_TOOL_CLASSES_BY_TOOL_TYPE = {};\n\nexport { MeasurementReport as default };\n","var CORNERSTONE_4_TAG = \"cornerstoneTools@^4.0.0\";\n\nexport { CORNERSTONE_4_TAG as default };\n","import { utilities } from 'dcmjs';\nimport MeasurementReport from './MeasurementReport.js';\nimport CORNERSTONE_4_TAG from './cornerstone4Tag.js';\n\nconst {\n  Length: TID300Length\n} = utilities.TID300;\nconst LENGTH = \"Length\";\nclass Length {\n  // TODO: this function is required for all Cornerstone Tool Adapters, since it is called by MeasurementReport.\n  static getMeasurementData(MeasurementGroup) {\n    const {\n      defaultState,\n      NUMGroup,\n      SCOORDGroup\n    } = MeasurementReport.getSetupMeasurementData(MeasurementGroup);\n    const state = {\n      ...defaultState,\n      length: NUMGroup.MeasuredValueSequence.NumericValue,\n      toolType: Length.toolType,\n      handles: {\n        start: {},\n        end: {},\n        textBox: {\n          hasMoved: false,\n          movesIndependently: false,\n          drawnIndependently: true,\n          allowedOutsideImage: true,\n          hasBoundingBox: true\n        }\n      }\n    };\n    [state.handles.start.x, state.handles.start.y, state.handles.end.x, state.handles.end.y] = SCOORDGroup.GraphicData;\n    return state;\n  }\n  static getTID300RepresentationArguments(tool) {\n    const {\n      handles,\n      finding,\n      findingSites\n    } = tool;\n    const point1 = handles.start;\n    const point2 = handles.end;\n    const distance = tool.length;\n    const trackingIdentifierTextValue = \"cornerstoneTools@^4.0.0:Length\";\n    return {\n      point1,\n      point2,\n      distance,\n      trackingIdentifierTextValue,\n      finding,\n      findingSites: findingSites || []\n    };\n  }\n}\nLength.toolType = LENGTH;\nLength.utilityToolType = LENGTH;\nLength.TID300Representation = TID300Length;\nLength.isValidCornerstoneTrackingIdentifier = TrackingIdentifier => {\n  if (!TrackingIdentifier.includes(\":\")) {\n    return false;\n  }\n  const [cornerstone4Tag, toolType] = TrackingIdentifier.split(\":\");\n  if (cornerstone4Tag !== CORNERSTONE_4_TAG) {\n    return false;\n  }\n  return toolType === LENGTH;\n};\nMeasurementReport.registerTool(Length);\n\nexport { Length as default };\n","import { utilities } from 'dcmjs';\nimport MeasurementReport from './MeasurementReport.js';\nimport CORNERSTONE_4_TAG from './cornerstone4Tag.js';\n\nconst {\n  Polyline: TID300Polyline\n} = utilities.TID300;\nclass FreehandRoi {\n  static getMeasurementData(MeasurementGroup) {\n    const {\n      defaultState,\n      SCOORDGroup,\n      NUMGroup\n    } = MeasurementReport.getSetupMeasurementData(MeasurementGroup);\n    const state = {\n      ...defaultState,\n      toolType: FreehandRoi.toolType,\n      handles: {\n        points: [],\n        textBox: {\n          active: false,\n          hasMoved: false,\n          movesIndependently: false,\n          drawnIndependently: true,\n          allowedOutsideImage: true,\n          hasBoundingBox: true\n        }\n      },\n      cachedStats: {\n        area: NUMGroup ? NUMGroup.MeasuredValueSequence.NumericValue : 0\n      },\n      color: undefined,\n      invalidated: true\n    };\n    const {\n      GraphicData\n    } = SCOORDGroup;\n    for (let i = 0; i < GraphicData.length; i += 2) {\n      state.handles.points.push({\n        x: GraphicData[i],\n        y: GraphicData[i + 1]\n      });\n    }\n    return state;\n  }\n  static getTID300RepresentationArguments(tool) {\n    const {\n      handles,\n      finding,\n      findingSites,\n      cachedStats = {}\n    } = tool;\n    const {\n      points\n    } = handles;\n    const {\n      area = 0,\n      perimeter = 0\n    } = cachedStats;\n    const trackingIdentifierTextValue = \"cornerstoneTools@^4.0.0:FreehandRoi\";\n    return {\n      points,\n      area,\n      perimeter,\n      trackingIdentifierTextValue,\n      finding,\n      findingSites: findingSites || []\n    };\n  }\n}\nFreehandRoi.toolType = \"FreehandRoi\";\nFreehandRoi.utilityToolType = \"FreehandRoi\";\nFreehandRoi.TID300Representation = TID300Polyline;\nFreehandRoi.isValidCornerstoneTrackingIdentifier = TrackingIdentifier => {\n  if (!TrackingIdentifier.includes(\":\")) {\n    return false;\n  }\n  const [cornerstone4Tag, toolType] = TrackingIdentifier.split(\":\");\n  if (cornerstone4Tag !== CORNERSTONE_4_TAG) {\n    return false;\n  }\n  return toolType === FreehandRoi.toolType;\n};\nMeasurementReport.registerTool(FreehandRoi);\n\nexport { FreehandRoi as default };\n","import { utilities } from 'dcmjs';\nimport MeasurementReport from './MeasurementReport.js';\nimport CORNERSTONE_4_TAG from './cornerstone4Tag.js';\nimport { toArray } from '../helpers/toArray.js';\nimport 'buffer';\n\nconst {\n  Bidirectional: TID300Bidirectional\n} = utilities.TID300;\nconst BIDIRECTIONAL = \"Bidirectional\";\nconst LONG_AXIS = \"Long Axis\";\nconst SHORT_AXIS = \"Short Axis\";\nconst FINDING = \"121071\";\nconst FINDING_SITE = \"G-C0E3\";\nclass Bidirectional {\n  // TODO: this function is required for all Cornerstone Tool Adapters, since it is called by MeasurementReport.\n  static getMeasurementData(MeasurementGroup) {\n    const {\n      ContentSequence\n    } = MeasurementGroup;\n    const findingGroup = toArray(ContentSequence).find(group => group.ConceptNameCodeSequence.CodeValue === FINDING);\n    const findingSiteGroups = toArray(ContentSequence).filter(group => group.ConceptNameCodeSequence.CodeValue === FINDING_SITE);\n    const longAxisNUMGroup = toArray(ContentSequence).find(group => group.ConceptNameCodeSequence.CodeMeaning === LONG_AXIS);\n    const longAxisSCOORDGroup = toArray(longAxisNUMGroup.ContentSequence).find(group => group.ValueType === \"SCOORD\");\n    const shortAxisNUMGroup = toArray(ContentSequence).find(group => group.ConceptNameCodeSequence.CodeMeaning === SHORT_AXIS);\n    const shortAxisSCOORDGroup = toArray(shortAxisNUMGroup.ContentSequence).find(group => group.ValueType === \"SCOORD\");\n    const {\n      ReferencedSOPSequence\n    } = longAxisSCOORDGroup.ContentSequence;\n    const {\n      ReferencedSOPInstanceUID,\n      ReferencedFrameNumber\n    } = ReferencedSOPSequence;\n\n    // Long axis\n\n    const longestDiameter = String(longAxisNUMGroup.MeasuredValueSequence.NumericValue);\n    const shortestDiameter = String(shortAxisNUMGroup.MeasuredValueSequence.NumericValue);\n    const bottomRight = {\n      x: Math.max(longAxisSCOORDGroup.GraphicData[0], longAxisSCOORDGroup.GraphicData[2], shortAxisSCOORDGroup.GraphicData[0], shortAxisSCOORDGroup.GraphicData[2]),\n      y: Math.max(longAxisSCOORDGroup.GraphicData[1], longAxisSCOORDGroup.GraphicData[3], shortAxisSCOORDGroup.GraphicData[1], shortAxisSCOORDGroup.GraphicData[3])\n    };\n    const state = {\n      sopInstanceUid: ReferencedSOPInstanceUID,\n      frameIndex: ReferencedFrameNumber || 1,\n      toolType: Bidirectional.toolType,\n      active: false,\n      handles: {\n        start: {\n          x: longAxisSCOORDGroup.GraphicData[0],\n          y: longAxisSCOORDGroup.GraphicData[1],\n          drawnIndependently: false,\n          allowedOutsideImage: false,\n          active: false,\n          highlight: false,\n          index: 0\n        },\n        end: {\n          x: longAxisSCOORDGroup.GraphicData[2],\n          y: longAxisSCOORDGroup.GraphicData[3],\n          drawnIndependently: false,\n          allowedOutsideImage: false,\n          active: false,\n          highlight: false,\n          index: 1\n        },\n        perpendicularStart: {\n          x: shortAxisSCOORDGroup.GraphicData[0],\n          y: shortAxisSCOORDGroup.GraphicData[1],\n          drawnIndependently: false,\n          allowedOutsideImage: false,\n          active: false,\n          highlight: false,\n          index: 2\n        },\n        perpendicularEnd: {\n          x: shortAxisSCOORDGroup.GraphicData[2],\n          y: shortAxisSCOORDGroup.GraphicData[3],\n          drawnIndependently: false,\n          allowedOutsideImage: false,\n          active: false,\n          highlight: false,\n          index: 3\n        },\n        textBox: {\n          highlight: false,\n          hasMoved: true,\n          active: false,\n          movesIndependently: false,\n          drawnIndependently: true,\n          allowedOutsideImage: true,\n          hasBoundingBox: true,\n          x: bottomRight.x + 10,\n          y: bottomRight.y + 10\n        }\n      },\n      invalidated: false,\n      isCreating: false,\n      longestDiameter,\n      shortestDiameter,\n      toolName: \"Bidirectional\",\n      visible: true,\n      finding: findingGroup ? findingGroup.ConceptCodeSequence : undefined,\n      findingSites: findingSiteGroups.map(fsg => fsg.ConceptCodeSequence)\n    };\n    return state;\n  }\n  static getTID300RepresentationArguments(tool) {\n    const {\n      start,\n      end,\n      perpendicularStart,\n      perpendicularEnd\n    } = tool.handles;\n    const {\n      shortestDiameter,\n      longestDiameter,\n      finding,\n      findingSites\n    } = tool;\n    const trackingIdentifierTextValue = \"cornerstoneTools@^4.0.0:Bidirectional\";\n    return {\n      longAxis: {\n        point1: start,\n        point2: end\n      },\n      shortAxis: {\n        point1: perpendicularStart,\n        point2: perpendicularEnd\n      },\n      longAxisLength: longestDiameter,\n      shortAxisLength: shortestDiameter,\n      trackingIdentifierTextValue,\n      finding: finding,\n      findingSites: findingSites || []\n    };\n  }\n}\nBidirectional.toolType = BIDIRECTIONAL;\nBidirectional.utilityToolType = BIDIRECTIONAL;\nBidirectional.TID300Representation = TID300Bidirectional;\nBidirectional.isValidCornerstoneTrackingIdentifier = TrackingIdentifier => {\n  if (!TrackingIdentifier.includes(\":\")) {\n    return false;\n  }\n  const [cornerstone4Tag, toolType] = TrackingIdentifier.split(\":\");\n  if (cornerstone4Tag !== CORNERSTONE_4_TAG) {\n    return false;\n  }\n  return toolType === BIDIRECTIONAL;\n};\nMeasurementReport.registerTool(Bidirectional);\n\nexport { Bidirectional as default };\n","import { utilities } from 'dcmjs';\nimport MeasurementReport from './MeasurementReport.js';\nimport CORNERSTONE_4_TAG from './cornerstone4Tag.js';\n\nconst {\n  Ellipse: TID300Ellipse\n} = utilities.TID300;\nconst ELLIPTICALROI = \"EllipticalRoi\";\nclass EllipticalRoi {\n  // TODO: this function is required for all Cornerstone Tool Adapters, since it is called by MeasurementReport.\n  static getMeasurementData(MeasurementGroup) {\n    const {\n      defaultState,\n      NUMGroup,\n      SCOORDGroup\n    } = MeasurementReport.getSetupMeasurementData(MeasurementGroup);\n    const {\n      GraphicData\n    } = SCOORDGroup;\n    const majorAxis = [{\n      x: GraphicData[0],\n      y: GraphicData[1]\n    }, {\n      x: GraphicData[2],\n      y: GraphicData[3]\n    }];\n    const minorAxis = [{\n      x: GraphicData[4],\n      y: GraphicData[5]\n    }, {\n      x: GraphicData[6],\n      y: GraphicData[7]\n    }];\n\n    // Calculate two opposite corners of box defined by two axes.\n\n    const minorAxisLength = Math.sqrt(Math.pow(minorAxis[0].x - minorAxis[1].x, 2) + Math.pow(minorAxis[0].y - minorAxis[1].y, 2));\n    const minorAxisDirection = {\n      x: (minorAxis[1].x - minorAxis[0].x) / minorAxisLength,\n      y: (minorAxis[1].y - minorAxis[0].y) / minorAxisLength\n    };\n    const halfMinorAxisLength = minorAxisLength / 2;\n\n    // First end point of major axis + half minor axis vector\n    const corner1 = {\n      x: majorAxis[0].x + minorAxisDirection.x * halfMinorAxisLength,\n      y: majorAxis[0].y + minorAxisDirection.y * halfMinorAxisLength\n    };\n\n    // Second end point of major axis - half of minor axis vector\n    const corner2 = {\n      x: majorAxis[1].x - minorAxisDirection.x * halfMinorAxisLength,\n      y: majorAxis[1].y - minorAxisDirection.y * halfMinorAxisLength\n    };\n    const state = {\n      ...defaultState,\n      toolType: EllipticalRoi.toolType,\n      active: false,\n      cachedStats: {\n        area: NUMGroup ? NUMGroup.MeasuredValueSequence.NumericValue : 0\n      },\n      handles: {\n        end: {\n          x: corner1.x,\n          y: corner1.y,\n          highlight: false,\n          active: false\n        },\n        initialRotation: 0,\n        start: {\n          x: corner2.x,\n          y: corner2.y,\n          highlight: false,\n          active: false\n        },\n        textBox: {\n          hasMoved: false,\n          movesIndependently: false,\n          drawnIndependently: true,\n          allowedOutsideImage: true,\n          hasBoundingBox: true\n        }\n      },\n      invalidated: true,\n      visible: true\n    };\n    return state;\n  }\n  static getTID300RepresentationArguments(tool) {\n    const {\n      cachedStats = {},\n      handles,\n      finding,\n      findingSites\n    } = tool;\n    const {\n      start,\n      end\n    } = handles;\n    const {\n      area\n    } = cachedStats;\n    const halfXLength = Math.abs(start.x - end.x) / 2;\n    const halfYLength = Math.abs(start.y - end.y) / 2;\n    const points = [];\n    const center = {\n      x: (start.x + end.x) / 2,\n      y: (start.y + end.y) / 2\n    };\n    if (halfXLength > halfYLength) {\n      // X-axis major\n      // Major axis\n      points.push({\n        x: center.x - halfXLength,\n        y: center.y\n      });\n      points.push({\n        x: center.x + halfXLength,\n        y: center.y\n      });\n      // Minor axis\n      points.push({\n        x: center.x,\n        y: center.y - halfYLength\n      });\n      points.push({\n        x: center.x,\n        y: center.y + halfYLength\n      });\n    } else {\n      // Y-axis major\n      // Major axis\n      points.push({\n        x: center.x,\n        y: center.y - halfYLength\n      });\n      points.push({\n        x: center.x,\n        y: center.y + halfYLength\n      });\n      // Minor axis\n      points.push({\n        x: center.x - halfXLength,\n        y: center.y\n      });\n      points.push({\n        x: center.x + halfXLength,\n        y: center.y\n      });\n    }\n    const trackingIdentifierTextValue = \"cornerstoneTools@^4.0.0:EllipticalRoi\";\n    return {\n      area,\n      points,\n      trackingIdentifierTextValue,\n      finding,\n      findingSites: findingSites || []\n    };\n  }\n}\nEllipticalRoi.toolType = ELLIPTICALROI;\nEllipticalRoi.utilityToolType = ELLIPTICALROI;\nEllipticalRoi.TID300Representation = TID300Ellipse;\nEllipticalRoi.isValidCornerstoneTrackingIdentifier = TrackingIdentifier => {\n  if (!TrackingIdentifier.includes(\":\")) {\n    return false;\n  }\n  const [cornerstone4Tag, toolType] = TrackingIdentifier.split(\":\");\n  if (cornerstone4Tag !== CORNERSTONE_4_TAG) {\n    return false;\n  }\n  return toolType === ELLIPTICALROI;\n};\nMeasurementReport.registerTool(EllipticalRoi);\n\nexport { EllipticalRoi as default };\n","import { utilities } from 'dcmjs';\nimport MeasurementReport from './MeasurementReport.js';\nimport CORNERSTONE_4_TAG from './cornerstone4Tag.js';\n\nconst {\n  Circle: TID300Circle\n} = utilities.TID300;\nconst CIRCLEROI = \"CircleRoi\";\nclass CircleRoi {\n  /** Gets the measurement data for cornerstone, given DICOM SR measurement data. */\n  static getMeasurementData(MeasurementGroup) {\n    const {\n      defaultState,\n      NUMGroup,\n      SCOORDGroup\n    } = MeasurementReport.getSetupMeasurementData(MeasurementGroup);\n    const {\n      GraphicData\n    } = SCOORDGroup;\n    const center = {\n      x: GraphicData[0],\n      y: GraphicData[1]\n    };\n    const end = {\n      x: GraphicData[2],\n      y: GraphicData[3]\n    };\n    const state = {\n      ...defaultState,\n      toolType: CircleRoi.toolType,\n      active: false,\n      cachedStats: {\n        area: NUMGroup ? NUMGroup.MeasuredValueSequence.NumericValue : 0,\n        // Dummy values to be updated by cornerstone\n        radius: 0,\n        perimeter: 0\n      },\n      handles: {\n        end: {\n          ...end,\n          highlight: false,\n          active: false\n        },\n        initialRotation: 0,\n        start: {\n          ...center,\n          highlight: false,\n          active: false\n        },\n        textBox: {\n          hasMoved: false,\n          movesIndependently: false,\n          drawnIndependently: true,\n          allowedOutsideImage: true,\n          hasBoundingBox: true\n        }\n      },\n      invalidated: true,\n      visible: true\n    };\n    return state;\n  }\n\n  /**\n   * Gets the TID 300 representation of a circle, given the cornerstone representation.\n   *\n   * @param {Object} tool\n   * @returns\n   */\n  static getTID300RepresentationArguments(tool) {\n    const {\n      cachedStats = {},\n      handles,\n      finding,\n      findingSites\n    } = tool;\n    const {\n      start: center,\n      end\n    } = handles;\n    const {\n      area,\n      radius\n    } = cachedStats;\n    const perimeter = 2 * Math.PI * radius;\n    const points = [];\n    points.push(center);\n    points.push(end);\n    const trackingIdentifierTextValue = \"cornerstoneTools@^4.0.0:CircleRoi\";\n    return {\n      area,\n      perimeter,\n      radius,\n      points,\n      trackingIdentifierTextValue,\n      finding,\n      findingSites: findingSites || []\n    };\n  }\n}\nCircleRoi.toolType = CIRCLEROI;\nCircleRoi.utilityToolType = CIRCLEROI;\nCircleRoi.TID300Representation = TID300Circle;\nCircleRoi.isValidCornerstoneTrackingIdentifier = TrackingIdentifier => {\n  if (!TrackingIdentifier.includes(\":\")) {\n    return false;\n  }\n  const [cornerstone4Tag, toolType] = TrackingIdentifier.split(\":\");\n  if (cornerstone4Tag !== CORNERSTONE_4_TAG) {\n    return false;\n  }\n  return toolType === CIRCLEROI;\n};\nMeasurementReport.registerTool(CircleRoi);\n\nexport { CircleRoi as default };\n","import { utilities } from 'dcmjs';\nimport MeasurementReport from './MeasurementReport.js';\nimport CORNERSTONE_4_TAG from './cornerstone4Tag.js';\n\nconst {\n  Point: TID300Point\n} = utilities.TID300;\nconst ARROW_ANNOTATE = \"ArrowAnnotate\";\nconst CORNERSTONEFREETEXT = \"CORNERSTONEFREETEXT\";\nclass ArrowAnnotate {\n  static getMeasurementData(MeasurementGroup) {\n    const {\n      defaultState,\n      SCOORDGroup,\n      findingGroup\n    } = MeasurementReport.getSetupMeasurementData(MeasurementGroup);\n    const text = findingGroup.ConceptCodeSequence.CodeMeaning;\n    const {\n      GraphicData\n    } = SCOORDGroup;\n    const state = {\n      ...defaultState,\n      toolType: ArrowAnnotate.toolType,\n      active: false,\n      handles: {\n        start: {\n          x: GraphicData[0],\n          y: GraphicData[1],\n          highlight: true,\n          active: false\n        },\n        // Use a generic offset if the stored data doesn't have the endpoint, otherwise\n        // use the actual endpoint.\n        end: {\n          x: GraphicData.length == 4 ? GraphicData[2] : GraphicData[0] + 20,\n          y: GraphicData.length == 4 ? GraphicData[3] : GraphicData[1] + 20,\n          highlight: true,\n          active: false\n        },\n        textBox: {\n          hasMoved: false,\n          movesIndependently: false,\n          drawnIndependently: true,\n          allowedOutsideImage: true,\n          hasBoundingBox: true\n        }\n      },\n      invalidated: true,\n      text,\n      visible: true\n    };\n    return state;\n  }\n  static getTID300RepresentationArguments(tool) {\n    const points = [tool.handles.start, tool.handles.end];\n    const {\n      findingSites\n    } = tool;\n    let {\n      finding\n    } = tool;\n    const TID300RepresentationArguments = {\n      points,\n      trackingIdentifierTextValue: `cornerstoneTools@^4.0.0:ArrowAnnotate`,\n      findingSites: findingSites || []\n    };\n\n    // If freetext finding isn't present, add it from the tool text.\n    if (!finding || finding.CodeValue !== CORNERSTONEFREETEXT) {\n      finding = {\n        CodeValue: CORNERSTONEFREETEXT,\n        CodingSchemeDesignator: \"CST4\",\n        CodeMeaning: tool.text\n      };\n    }\n    TID300RepresentationArguments.finding = finding;\n    return TID300RepresentationArguments;\n  }\n}\nArrowAnnotate.toolType = ARROW_ANNOTATE;\nArrowAnnotate.utilityToolType = ARROW_ANNOTATE;\nArrowAnnotate.TID300Representation = TID300Point;\nArrowAnnotate.isValidCornerstoneTrackingIdentifier = TrackingIdentifier => {\n  if (!TrackingIdentifier.includes(\":\")) {\n    return false;\n  }\n  const [cornerstone4Tag, toolType] = TrackingIdentifier.split(\":\");\n  if (cornerstone4Tag !== CORNERSTONE_4_TAG) {\n    return false;\n  }\n  return toolType === ARROW_ANNOTATE;\n};\nMeasurementReport.registerTool(ArrowAnnotate);\n\nexport { ArrowAnnotate as default };\n","import { utilities } from 'dcmjs';\nimport MeasurementReport from './MeasurementReport.js';\nimport CORNERSTONE_4_TAG from './cornerstone4Tag.js';\n\nconst {\n  CobbAngle: TID300CobbAngle\n} = utilities.TID300;\nconst COBB_ANGLE = \"CobbAngle\";\nclass CobbAngle {\n  // TODO: this function is required for all Cornerstone Tool Adapters, since it is called by MeasurementReport.\n  static getMeasurementData(MeasurementGroup) {\n    const {\n      defaultState,\n      NUMGroup,\n      SCOORDGroup\n    } = MeasurementReport.getSetupMeasurementData(MeasurementGroup);\n    const state = {\n      ...defaultState,\n      rAngle: NUMGroup.MeasuredValueSequence.NumericValue,\n      toolType: CobbAngle.toolType,\n      handles: {\n        start: {},\n        end: {},\n        start2: {\n          highlight: true,\n          drawnIndependently: true\n        },\n        end2: {\n          highlight: true,\n          drawnIndependently: true\n        },\n        textBox: {\n          hasMoved: false,\n          movesIndependently: false,\n          drawnIndependently: true,\n          allowedOutsideImage: true,\n          hasBoundingBox: true\n        }\n      }\n    };\n    [state.handles.start.x, state.handles.start.y, state.handles.end.x, state.handles.end.y, state.handles.start2.x, state.handles.start2.y, state.handles.end2.x, state.handles.end2.y] = SCOORDGroup.GraphicData;\n    return state;\n  }\n  static getTID300RepresentationArguments(tool) {\n    const {\n      handles,\n      finding,\n      findingSites\n    } = tool;\n    const point1 = handles.start;\n    const point2 = handles.end;\n    const point3 = handles.start2;\n    const point4 = handles.end2;\n    const rAngle = tool.rAngle;\n    const trackingIdentifierTextValue = \"cornerstoneTools@^4.0.0:CobbAngle\";\n    return {\n      point1,\n      point2,\n      point3,\n      point4,\n      rAngle,\n      trackingIdentifierTextValue,\n      finding,\n      findingSites: findingSites || []\n    };\n  }\n}\nCobbAngle.toolType = COBB_ANGLE;\nCobbAngle.utilityToolType = COBB_ANGLE;\nCobbAngle.TID300Representation = TID300CobbAngle;\nCobbAngle.isValidCornerstoneTrackingIdentifier = TrackingIdentifier => {\n  if (!TrackingIdentifier.includes(\":\")) {\n    return false;\n  }\n  const [cornerstone4Tag, toolType] = TrackingIdentifier.split(\":\");\n  if (cornerstone4Tag !== CORNERSTONE_4_TAG) {\n    return false;\n  }\n  return toolType === COBB_ANGLE;\n};\nMeasurementReport.registerTool(CobbAngle);\n\nexport { CobbAngle as default };\n","import { utilities } from 'dcmjs';\nimport MeasurementReport from './MeasurementReport.js';\nimport CORNERSTONE_4_TAG from './cornerstone4Tag.js';\n\nconst {\n  Angle: TID300Angle\n} = utilities.TID300;\nconst ANGLE = \"Angle\";\nclass Angle {\n  /**\n   * Generate TID300 measurement data for a plane angle measurement - use a Angle, but label it as Angle\n   */\n  static getMeasurementData(MeasurementGroup) {\n    const {\n      defaultState,\n      NUMGroup,\n      SCOORDGroup\n    } = MeasurementReport.getSetupMeasurementData(MeasurementGroup);\n    const state = {\n      ...defaultState,\n      rAngle: NUMGroup.MeasuredValueSequence.NumericValue,\n      toolType: Angle.toolType,\n      handles: {\n        start: {},\n        middle: {},\n        end: {},\n        textBox: {\n          hasMoved: false,\n          movesIndependently: false,\n          drawnIndependently: true,\n          allowedOutsideImage: true,\n          hasBoundingBox: true\n        }\n      }\n    };\n    [state.handles.start.x, state.handles.start.y, state.handles.middle.x, state.handles.middle.y, state.handles.middle.x, state.handles.middle.y, state.handles.end.x, state.handles.end.y] = SCOORDGroup.GraphicData;\n    return state;\n  }\n  static getTID300RepresentationArguments(tool) {\n    const {\n      handles,\n      finding,\n      findingSites\n    } = tool;\n    const point1 = handles.start;\n    const point2 = handles.middle;\n    const point3 = handles.middle;\n    const point4 = handles.end;\n    const rAngle = tool.rAngle;\n    const trackingIdentifierTextValue = \"cornerstoneTools@^4.0.0:Angle\";\n    return {\n      point1,\n      point2,\n      point3,\n      point4,\n      rAngle,\n      trackingIdentifierTextValue,\n      finding,\n      findingSites: findingSites || []\n    };\n  }\n}\nAngle.toolType = ANGLE;\nAngle.utilityToolType = ANGLE;\nAngle.TID300Representation = TID300Angle;\nAngle.isValidCornerstoneTrackingIdentifier = TrackingIdentifier => {\n  if (!TrackingIdentifier.includes(\":\")) {\n    return false;\n  }\n  const [cornerstone4Tag, toolType] = TrackingIdentifier.split(\":\");\n  if (cornerstone4Tag !== CORNERSTONE_4_TAG) {\n    return false;\n  }\n  return toolType === ANGLE;\n};\nMeasurementReport.registerTool(Angle);\n\nexport { Angle as default };\n","import { utilities } from 'dcmjs';\nimport MeasurementReport from './MeasurementReport.js';\nimport CORNERSTONE_4_TAG from './cornerstone4Tag.js';\n\nconst {\n  Polyline: TID300Polyline\n} = utilities.TID300;\nclass RectangleRoi {\n  static getMeasurementData(MeasurementGroup) {\n    const {\n      defaultState,\n      SCOORDGroup,\n      NUMGroup\n    } = MeasurementReport.getSetupMeasurementData(MeasurementGroup);\n    const state = {\n      ...defaultState,\n      toolType: RectangleRoi.toolType,\n      handles: {\n        start: {},\n        end: {},\n        textBox: {\n          active: false,\n          hasMoved: false,\n          movesIndependently: false,\n          drawnIndependently: true,\n          allowedOutsideImage: true,\n          hasBoundingBox: true\n        },\n        initialRotation: 0\n      },\n      cachedStats: {\n        area: NUMGroup ? NUMGroup.MeasuredValueSequence.NumericValue : 0\n      },\n      color: undefined,\n      invalidated: true\n    };\n    const intermediate = {};\n    [state.handles.start.x, state.handles.start.y, intermediate.x, intermediate.y, state.handles.end.x, state.handles.end.y] = SCOORDGroup.GraphicData;\n    return state;\n  }\n  static getTID300RepresentationArguments(tool) {\n    const {\n      finding,\n      findingSites,\n      cachedStats = {},\n      handles\n    } = tool;\n    const {\n      start,\n      end\n    } = handles;\n    const points = [start, {\n      x: start.x,\n      y: end.y\n    }, end, {\n      x: end.x,\n      y: start.y\n    }];\n    const {\n      area,\n      perimeter\n    } = cachedStats;\n    const trackingIdentifierTextValue = \"cornerstoneTools@^4.0.0:RectangleRoi\";\n    return {\n      points,\n      area,\n      perimeter,\n      trackingIdentifierTextValue,\n      finding,\n      findingSites: findingSites || []\n    };\n  }\n}\nRectangleRoi.toolType = \"RectangleRoi\";\nRectangleRoi.utilityToolType = \"RectangleRoi\";\nRectangleRoi.TID300Representation = TID300Polyline;\nRectangleRoi.isValidCornerstoneTrackingIdentifier = TrackingIdentifier => {\n  if (!TrackingIdentifier.includes(\":\")) {\n    return false;\n  }\n  const [cornerstone4Tag, toolType] = TrackingIdentifier.split(\":\");\n  if (cornerstone4Tag !== CORNERSTONE_4_TAG) {\n    return false;\n  }\n  return toolType === RectangleRoi.toolType;\n};\nMeasurementReport.registerTool(RectangleRoi);\n\nexport { RectangleRoi as default };\n","import { data, normalizers } from 'dcmjs';\n\nconst {\n  DicomMessage,\n  DicomMetaDictionary\n} = data;\nconst {\n  Normalizer\n} = normalizers;\nfunction getDatasetsFromImages(images, isMultiframe, options) {\n  const datasets = [];\n  if (isMultiframe) {\n    const image = images[0];\n    const arrayBuffer = image.data.byteArray.buffer;\n    const dicomData = DicomMessage.readFile(arrayBuffer);\n    const dataset = DicomMetaDictionary.naturalizeDataset(dicomData.dict);\n    dataset._meta = DicomMetaDictionary.namifyDataset(dicomData.meta);\n    datasets.push(dataset);\n  } else {\n    for (let i = 0; i < images.length; i++) {\n      const image = images[i];\n      const arrayBuffer = image.data.byteArray.buffer;\n      const dicomData = DicomMessage.readFile(arrayBuffer);\n      const dataset = DicomMetaDictionary.naturalizeDataset(dicomData.dict);\n      dataset._meta = DicomMetaDictionary.namifyDataset(dicomData.meta);\n      datasets.push(dataset);\n    }\n  }\n  if (options?.SpecificCharacterSet) {\n    datasets.forEach(dataset => dataset.SpecificCharacterSet = options.SpecificCharacterSet);\n  }\n  return Normalizer.normalizeToDataset(datasets);\n}\n\nexport { getDatasetsFromImages as default };\n","import { utilities, log, normalizers, derivations } from 'dcmjs';\nimport ndarray from 'ndarray';\nimport getDatasetsFromImages from '../helpers/getDatasetsFromImages.js';\n\nconst {\n  rotateDirectionCosinesInPlane,\n  flipImageOrientationPatient: flipIOP,\n  flipMatrix2D,\n  rotateMatrix902D\n} = utilities.orientation;\nconst {\n  datasetToBlob,\n  BitArray,\n  DicomMessage,\n  DicomMetaDictionary\n} = utilities;\nconst {\n  Normalizer\n} = normalizers;\nconst {\n  Segmentation: SegmentationDerivation\n} = derivations;\nconst Segmentation = {\n  generateSegmentation,\n  generateToolState\n};\n\n/**\n *\n * @typedef {Object} BrushData\n * @property {Object} toolState - The cornerstoneTools global toolState.\n * @property {Object[]} segments - The cornerstoneTools segment metadata that corresponds to the\n *                                 seriesInstanceUid.\n */\n\n/**\n * generateSegmentation - Generates cornerstoneTools brush data, given a stack of\n * imageIds, images and the cornerstoneTools brushData.\n *\n * @param  {object[]} images    An array of the cornerstone image objects.\n * @param  {BrushData} brushData and object containing the brushData.\n * @returns {type}           description\n */\nfunction generateSegmentation(images, brushData) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {\n    includeSliceSpacing: true\n  };\n  const {\n    toolState,\n    segments\n  } = brushData;\n\n  // Calculate the dimensions of the data cube.\n  const image0 = images[0];\n  const dims = {\n    x: image0.columns,\n    y: image0.rows,\n    z: images.length\n  };\n  dims.xy = dims.x * dims.y;\n  const numSegments = _getSegCount(seg, segments);\n  if (!numSegments) {\n    throw new Error(\"No segments to export!\");\n  }\n  const isMultiframe = image0.imageId.includes(\"?frame\");\n  const seg = _createSegFromImages(images, isMultiframe, options);\n  const {\n    referencedFramesPerSegment,\n    segmentIndicies\n  } = _getNumberOfFramesPerSegment(toolState, images, segments);\n  let NumberOfFrames = 0;\n  for (let i = 0; i < referencedFramesPerSegment.length; i++) {\n    NumberOfFrames += referencedFramesPerSegment[i].length;\n  }\n  seg.setNumberOfFrames(NumberOfFrames);\n  for (let i = 0; i < segmentIndicies.length; i++) {\n    const segmentIndex = segmentIndicies[i];\n    const referencedFrameIndicies = referencedFramesPerSegment[i];\n\n    // Frame numbers start from 1.\n    const referencedFrameNumbers = referencedFrameIndicies.map(element => {\n      return element + 1;\n    });\n    const segment = segments[segmentIndex];\n    seg.addSegment(segment, _extractCornerstoneToolsPixelData(segmentIndex, referencedFrameIndicies, toolState, images, dims), referencedFrameNumbers);\n  }\n  seg.bitPackPixelData();\n  const segBlob = datasetToBlob(seg.dataset);\n  return segBlob;\n}\nfunction _extractCornerstoneToolsPixelData(segmentIndex, referencedFrames, toolState, images, dims) {\n  const pixelData = new Uint8Array(dims.xy * referencedFrames.length);\n  let pixelDataIndex = 0;\n  for (let i = 0; i < referencedFrames.length; i++) {\n    const frame = referencedFrames[i];\n    const imageId = images[frame].imageId;\n    const imageIdSpecificToolState = toolState[imageId];\n    const brushPixelData = imageIdSpecificToolState.brush.data[segmentIndex].pixelData;\n    for (let p = 0; p < brushPixelData.length; p++) {\n      pixelData[pixelDataIndex] = brushPixelData[p];\n      pixelDataIndex++;\n    }\n  }\n  return pixelData;\n}\nfunction _getNumberOfFramesPerSegment(toolState, images, segments) {\n  const segmentIndicies = [];\n  const referencedFramesPerSegment = [];\n  for (let i = 0; i < segments.length; i++) {\n    if (segments[i]) {\n      segmentIndicies.push(i);\n      referencedFramesPerSegment.push([]);\n    }\n  }\n  for (let z = 0; z < images.length; z++) {\n    const imageId = images[z].imageId;\n    const imageIdSpecificToolState = toolState[imageId];\n    for (let i = 0; i < segmentIndicies.length; i++) {\n      const segIdx = segmentIndicies[i];\n      if (imageIdSpecificToolState && imageIdSpecificToolState.brush && imageIdSpecificToolState.brush.data && imageIdSpecificToolState.brush.data[segIdx] && imageIdSpecificToolState.brush.data[segIdx].pixelData) {\n        referencedFramesPerSegment[i].push(z);\n      }\n    }\n  }\n  return {\n    referencedFramesPerSegment,\n    segmentIndicies\n  };\n}\nfunction _getSegCount(seg, segments) {\n  let numSegments = 0;\n  for (let i = 0; i < segments.length; i++) {\n    if (segments[i]) {\n      numSegments++;\n    }\n  }\n  return numSegments;\n}\n\n/**\n * _createSegFromImages - description\n *\n * @param  {Object[]} images    An array of the cornerstone image objects.\n * @param  {Boolean} isMultiframe Whether the images are multiframe.\n * @returns {Object}              The Seg derived dataSet.\n */\nfunction _createSegFromImages(images, isMultiframe, options) {\n  const multiframe = getDatasetsFromImages(images, isMultiframe);\n  return new SegmentationDerivation([multiframe], options);\n}\n\n/**\n * generateToolState - Given a set of cornrstoneTools imageIds and a Segmentation buffer,\n * derive cornerstoneTools toolState and brush metadata.\n *\n * @param  {string[]} imageIds    An array of the imageIds.\n * @param  {ArrayBuffer} arrayBuffer The SEG arrayBuffer.\n * @param {*} metadataProvider\n * @returns {Object}  The toolState and an object from which the\n *                    segment metadata can be derived.\n */\nfunction generateToolState(imageIds, arrayBuffer, metadataProvider) {\n  const dicomData = DicomMessage.readFile(arrayBuffer);\n  const dataset = DicomMetaDictionary.naturalizeDataset(dicomData.dict);\n  dataset._meta = DicomMetaDictionary.namifyDataset(dicomData.meta);\n  const multiframe = Normalizer.normalizeToDataset([dataset]);\n  const imagePlaneModule = metadataProvider.get(\"imagePlaneModule\", imageIds[0]);\n  if (!imagePlaneModule) {\n    console.warn(\"Insufficient metadata, imagePlaneModule missing.\");\n  }\n  const ImageOrientationPatient = Array.isArray(imagePlaneModule.rowCosines) ? [...imagePlaneModule.rowCosines, ...imagePlaneModule.columnCosines] : [imagePlaneModule.rowCosines.x, imagePlaneModule.rowCosines.y, imagePlaneModule.rowCosines.z, imagePlaneModule.columnCosines.x, imagePlaneModule.columnCosines.y, imagePlaneModule.columnCosines.z];\n\n  // Get IOP from ref series, compute supported orientations:\n  const validOrientations = getValidOrientations(ImageOrientationPatient);\n  const SharedFunctionalGroupsSequence = multiframe.SharedFunctionalGroupsSequence;\n  const sharedImageOrientationPatient = SharedFunctionalGroupsSequence.PlaneOrientationSequence ? SharedFunctionalGroupsSequence.PlaneOrientationSequence.ImageOrientationPatient : undefined;\n  const sliceLength = multiframe.Columns * multiframe.Rows;\n  const segMetadata = getSegmentMetadata(multiframe);\n  const pixelData = unpackPixelData(multiframe);\n  const PerFrameFunctionalGroupsSequence = multiframe.PerFrameFunctionalGroupsSequence;\n  const toolState = {};\n  let inPlane = true;\n  for (let i = 0; i < PerFrameFunctionalGroupsSequence.length; i++) {\n    const PerFrameFunctionalGroups = PerFrameFunctionalGroupsSequence[i];\n    const ImageOrientationPatientI = sharedImageOrientationPatient || PerFrameFunctionalGroups.PlaneOrientationSequence.ImageOrientationPatient;\n    const pixelDataI2D = ndarray(new Uint8Array(pixelData.buffer, i * sliceLength, sliceLength), [multiframe.Rows, multiframe.Columns]);\n    const alignedPixelDataI = alignPixelDataWithSourceData(pixelDataI2D, ImageOrientationPatientI, validOrientations);\n    if (!alignedPixelDataI) {\n      console.warn(\"This segmentation object is not in-plane with the source data. Bailing out of IO. It'd be better to render this with vtkjs. \");\n      inPlane = false;\n      break;\n    }\n    const segmentIndex = PerFrameFunctionalGroups.SegmentIdentificationSequence.ReferencedSegmentNumber - 1;\n    let SourceImageSequence;\n    if (SharedFunctionalGroupsSequence.DerivationImageSequence && SharedFunctionalGroupsSequence.DerivationImageSequence.SourceImageSequence) {\n      SourceImageSequence = SharedFunctionalGroupsSequence.DerivationImageSequence.SourceImageSequence[i];\n    } else {\n      SourceImageSequence = PerFrameFunctionalGroups.DerivationImageSequence.SourceImageSequence;\n    }\n    const imageId = getImageIdOfSourceImage(SourceImageSequence, imageIds, metadataProvider);\n    addImageIdSpecificBrushToolState(toolState, imageId, segmentIndex, alignedPixelDataI);\n  }\n  if (!inPlane) {\n    return;\n  }\n  return {\n    toolState,\n    segMetadata\n  };\n}\n\n/**\n * unpackPixelData - Unpacks bitpacked pixelData if the Segmentation is BINARY.\n *\n * @param  {Object} multiframe The multiframe dataset.\n * @return {Uint8Array}      The unpacked pixelData.\n */\nfunction unpackPixelData(multiframe) {\n  const segType = multiframe.SegmentationType;\n  if (segType === \"BINARY\") {\n    return BitArray.unpack(multiframe.PixelData);\n  }\n  const pixelData = new Uint8Array(multiframe.PixelData);\n  const max = multiframe.MaximumFractionalValue;\n  const onlyMaxAndZero = pixelData.find(element => element !== 0 && element !== max) === undefined;\n  if (!onlyMaxAndZero) {\n    log.warn(\"This is a fractional segmentation, which is not currently supported.\");\n    return;\n  }\n  log.warn(\"This segmentation object is actually binary... processing as such.\");\n  return pixelData;\n}\n\n/**\n * addImageIdSpecificBrushToolState - Adds brush pixel data to cornerstoneTools\n * formatted toolState object.\n *\n * @param  {Object} toolState    The toolState object to modify\n * @param  {String} imageId      The imageId of the toolState to add the data.\n * @param  {Number} segmentIndex The index of the segment data being added.\n * @param  {Ndarray} pixelData2D  The pixelData in Ndarry 2D format.\n */\nfunction addImageIdSpecificBrushToolState(toolState, imageId, segmentIndex, pixelData2D) {\n  if (!toolState[imageId]) {\n    toolState[imageId] = {};\n    toolState[imageId].brush = {};\n    toolState[imageId].brush.data = [];\n  } else if (!toolState[imageId].brush) {\n    toolState[imageId].brush = {};\n    toolState[imageId].brush.data = [];\n  } else if (!toolState[imageId].brush.data) {\n    toolState[imageId].brush.data = [];\n  }\n  toolState[imageId].brush.data[segmentIndex] = {};\n  const brushDataI = toolState[imageId].brush.data[segmentIndex];\n  brushDataI.pixelData = new Uint8Array(pixelData2D.data.length);\n  const cToolsPixelData = brushDataI.pixelData;\n  for (let p = 0; p < cToolsPixelData.length; p++) {\n    if (pixelData2D.data[p]) {\n      cToolsPixelData[p] = 1;\n    } else {\n      cToolsPixelData[p] = 0;\n    }\n  }\n}\n\n/**\n * getImageIdOfSourceImage - Returns the Cornerstone imageId of the source image.\n *\n * @param  {Object} SourceImageSequence Sequence describing the source image.\n * @param  {String[]} imageIds          A list of imageIds.\n * @param  {Object} metadataProvider    A Cornerstone metadataProvider to query\n *                                      metadata from imageIds.\n * @return {String}                     The corresponding imageId.\n */\nfunction getImageIdOfSourceImage(SourceImageSequence, imageIds, metadataProvider) {\n  const {\n    ReferencedSOPInstanceUID,\n    ReferencedFrameNumber\n  } = SourceImageSequence;\n  return ReferencedFrameNumber ? getImageIdOfReferencedFrame(ReferencedSOPInstanceUID, ReferencedFrameNumber, imageIds, metadataProvider) : getImageIdOfReferencedSingleFramedSOPInstance(ReferencedSOPInstanceUID, imageIds, metadataProvider);\n}\n\n/**\n * getImageIdOfReferencedSingleFramedSOPInstance - Returns the imageId\n * corresponding to the specified sopInstanceUid for single-frame images.\n *\n * @param  {String} sopInstanceUid   The sopInstanceUid of the desired image.\n * @param  {String[]} imageIds         The list of imageIds.\n * @param  {Object} metadataProvider The metadataProvider to obtain sopInstanceUids\n *                                 from the cornerstone imageIds.\n * @return {String}                  The imageId that corresponds to the sopInstanceUid.\n */\nfunction getImageIdOfReferencedSingleFramedSOPInstance(sopInstanceUid, imageIds, metadataProvider) {\n  return imageIds.find(imageId => {\n    const sopCommonModule = metadataProvider.get(\"sopCommonModule\", imageId);\n    if (!sopCommonModule) {\n      return;\n    }\n    return sopCommonModule.sopInstanceUID === sopInstanceUid;\n  });\n}\n\n/**\n * getImageIdOfReferencedFrame - Returns the imageId corresponding to the\n * specified sopInstanceUid and frameNumber for multi-frame images.\n *\n * @param  {String} sopInstanceUid   The sopInstanceUid of the desired image.\n * @param  {Number} frameNumber      The frame number.\n * @param  {String} imageIds         The list of imageIds.\n * @param  {Object} metadataProvider The metadataProvider to obtain sopInstanceUids\n *                                   from the cornerstone imageIds.\n * @return {String}                  The imageId that corresponds to the sopInstanceUid.\n */\nfunction getImageIdOfReferencedFrame(sopInstanceUid, frameNumber, imageIds, metadataProvider) {\n  const imageId = imageIds.find(imageId => {\n    const sopCommonModule = metadataProvider.get(\"sopCommonModule\", imageId);\n    if (!sopCommonModule) {\n      return;\n    }\n    const imageIdFrameNumber = Number(imageId.split(\"frame=\")[1]);\n    return (\n      //frameNumber is zero indexed for cornerstoneDICOMImageLoader image Ids.\n      sopCommonModule.sopInstanceUID === sopInstanceUid && imageIdFrameNumber === frameNumber - 1\n    );\n  });\n  return imageId;\n}\n\n/**\n * getValidOrientations - returns an array of valid orientations.\n *\n * @param  iop - The row (0..2) an column (3..5) direction cosines.\n * @return  An array of valid orientations.\n */\nfunction getValidOrientations(iop) {\n  const orientations = [];\n\n  // [0,  1,  2]: 0,   0hf,   0vf\n  // [3,  4,  5]: 90,  90hf,  90vf\n  // [6, 7]:      180, 270\n\n  orientations[0] = iop;\n  orientations[1] = flipIOP.h(iop);\n  orientations[2] = flipIOP.v(iop);\n  const iop90 = rotateDirectionCosinesInPlane(iop, Math.PI / 2);\n  orientations[3] = iop90;\n  orientations[4] = flipIOP.h(iop90);\n  orientations[5] = flipIOP.v(iop90);\n  orientations[6] = rotateDirectionCosinesInPlane(iop, Math.PI);\n  orientations[7] = rotateDirectionCosinesInPlane(iop, 1.5 * Math.PI);\n  return orientations;\n}\n\n/**\n * alignPixelDataWithSourceData -\n *\n * @param pixelData2D - The data to align.\n * @param iop - The orientation of the image slice.\n * @param orientations - An array of valid imageOrientationPatient values.\n * @return The aligned pixelData.\n */\nfunction alignPixelDataWithSourceData(pixelData2D, iop, orientations) {\n  if (compareIOP(iop, orientations[0])) {\n    //Same orientation.\n    return pixelData2D;\n  } else if (compareIOP(iop, orientations[1])) {\n    //Flipped vertically.\n    return flipMatrix2D.v(pixelData2D);\n  } else if (compareIOP(iop, orientations[2])) {\n    //Flipped horizontally.\n    return flipMatrix2D.h(pixelData2D);\n  } else if (compareIOP(iop, orientations[3])) {\n    //Rotated 90 degrees.\n    return rotateMatrix902D(pixelData2D);\n  } else if (compareIOP(iop, orientations[4])) {\n    //Rotated 90 degrees and fliped horizontally.\n    return flipMatrix2D.h(rotateMatrix902D(pixelData2D));\n  } else if (compareIOP(iop, orientations[5])) {\n    //Rotated 90 degrees and fliped vertically.\n    return flipMatrix2D.v(rotateMatrix902D(pixelData2D));\n  } else if (compareIOP(iop, orientations[6])) {\n    //Rotated 180 degrees. // TODO -> Do this more effeciently, there is a 1:1 mapping like 90 degree rotation.\n    return rotateMatrix902D(rotateMatrix902D(pixelData2D));\n  } else if (compareIOP(iop, orientations[7])) {\n    //Rotated 270 degrees.  // TODO -> Do this more effeciently, there is a 1:1 mapping like 90 degree rotation.\n    return rotateMatrix902D(rotateMatrix902D(rotateMatrix902D(pixelData2D)));\n  }\n}\nconst dx = 1e-5;\n\n/**\n * compareIOP - Returns true if iop1 and iop2 are equal\n * within a tollerance, dx.\n *\n * @param  iop1 - An ImageOrientationPatient array.\n * @param  iop2 - An ImageOrientationPatient array.\n * @return True if iop1 and iop2 are equal.\n */\nfunction compareIOP(iop1, iop2) {\n  return Math.abs(iop1[0] - iop2[0]) < dx && Math.abs(iop1[1] - iop2[1]) < dx && Math.abs(iop1[2] - iop2[2]) < dx && Math.abs(iop1[3] - iop2[3]) < dx && Math.abs(iop1[4] - iop2[4]) < dx && Math.abs(iop1[5] - iop2[5]) < dx;\n}\nfunction getSegmentMetadata(multiframe) {\n  const data = [];\n  const segmentSequence = multiframe.SegmentSequence;\n  if (Array.isArray(segmentSequence)) {\n    for (let segIdx = 0; segIdx < segmentSequence.length; segIdx++) {\n      data.push(segmentSequence[segIdx]);\n    }\n  } else {\n    // Only one segment, will be stored as an object.\n    data.push(segmentSequence);\n  }\n  return {\n    seriesInstanceUid: multiframe.ReferencedSeriesSequence.SeriesInstanceUID,\n    data\n  };\n}\n\nexport { Segmentation as default };\n","import { utilities } from 'dcmjs';\n\nconst {\n  nearlyEqual\n} = utilities.orientation;\nfunction compareArrays(array1, array2, tolerance) {\n  if (array1.length !== array2.length) {\n    return false;\n  }\n  for (let i = 0; i < array1.length; ++i) {\n    if (!nearlyEqual(array1[i], array2[i], tolerance)) {\n      return false;\n    }\n  }\n  return true;\n}\n\nexport { compareArrays as default };\n","import checkIfPerpendicular from './checkIfPerpendicular.js';\nimport compareArrays from './compareArrays.js';\n\nfunction checkOrientation(multiframe, validOrientations, sourceDataDimensions, tolerance) {\n  const {\n    SharedFunctionalGroupsSequence,\n    PerFrameFunctionalGroupsSequence\n  } = multiframe;\n  const sharedImageOrientationPatient = SharedFunctionalGroupsSequence.PlaneOrientationSequence ? SharedFunctionalGroupsSequence.PlaneOrientationSequence.ImageOrientationPatient : undefined;\n  const PerFrameFunctionalGroups = PerFrameFunctionalGroupsSequence[0];\n  const iop = sharedImageOrientationPatient || PerFrameFunctionalGroups.PlaneOrientationSequence.ImageOrientationPatient;\n  const inPlane = validOrientations.some(operation => compareArrays(iop, operation, tolerance));\n  if (inPlane) {\n    return \"Planar\";\n  }\n  if (checkIfPerpendicular(iop, validOrientations[0], tolerance) && sourceDataDimensions.includes(multiframe.Rows) && sourceDataDimensions.includes(multiframe.Columns)) {\n    return \"Perpendicular\";\n  }\n  return \"Oblique\";\n}\n\nexport { checkOrientation as default };\n","function checkIfPerpendicular(iop1, iop2, tolerance) {\n  const absDotColumnCosines = Math.abs(iop1[0] * iop2[0] + iop1[1] * iop2[1] + iop1[2] * iop2[2]);\n  const absDotRowCosines = Math.abs(iop1[3] * iop2[3] + iop1[4] * iop2[4] + iop1[5] * iop2[5]);\n  return (absDotColumnCosines < tolerance || Math.abs(absDotColumnCosines - 1) < tolerance) && (absDotRowCosines < tolerance || Math.abs(absDotRowCosines - 1) < tolerance);\n}\n\nexport { checkIfPerpendicular as default };\n","var Events;\n(function (Events) {\n  Events[\"SEGMENTATION_LOAD_PROGRESS\"] = \"CORNERSTONE_ADAPTER_SEGMENTATION_LOAD_PROGRESS\";\n})(Events || (Events = {}));\n\nexport { Events };\n","import { utilities, log, data, normalizers, derivations } from 'dcmjs';\nimport ndarray from 'ndarray';\nimport getDatasetsFromImages from '../helpers/getDatasetsFromImages.js';\nimport checkOrientation from '../helpers/checkOrientation.js';\nimport compareArrays from '../helpers/compareArrays.js';\nimport { Events } from '../enums/Events.js';\n\nconst {\n  rotateDirectionCosinesInPlane,\n  flipImageOrientationPatient: flipIOP,\n  flipMatrix2D,\n  rotateMatrix902D\n} = utilities.orientation;\nconst {\n  BitArray,\n  DicomMessage,\n  DicomMetaDictionary\n} = data;\nconst {\n  Normalizer\n} = normalizers;\nconst {\n  Segmentation: SegmentationDerivation\n} = derivations;\nconst {\n  encode,\n  decode\n} = utilities.compression;\n\n/**\n *\n * @typedef {Object} BrushData\n * @property {Object} toolState - The cornerstoneTools global toolState.\n * @property {Object[]} segments - The cornerstoneTools segment metadata that corresponds to the\n *                                 seriesInstanceUid.\n */\nconst generateSegmentationDefaultOptions = {\n  includeSliceSpacing: true,\n  rleEncode: false\n};\n\n/**\n * generateSegmentation - Generates cornerstoneTools brush data, given a stack of\n * imageIds, images and the cornerstoneTools brushData.\n *\n * @param  {object[]} images An array of cornerstone images that contain the source\n *                           data under `image.data.byteArray.buffer`.\n * @param  {Object|Object[]} inputLabelmaps3D The cornerstone `Labelmap3D` object, or an array of objects.\n * @param  {Object} userOptions Options to pass to the segmentation derivation and `fillSegmentation`.\n * @returns {Blob}\n */\nfunction generateSegmentation(images, inputLabelmaps3D) {\n  let userOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const isMultiframe = isMultiframeImage(images[0]);\n  const segmentation = _createSegFromImages(images, isMultiframe, userOptions);\n  return fillSegmentation(segmentation, inputLabelmaps3D, userOptions);\n}\n\n/**\n * Fills a given segmentation object with data from the input labelmaps3D\n *\n * @param segmentation - The segmentation object to be filled.\n * @param inputLabelmaps3D - An array of 3D labelmaps, or a single 3D labelmap.\n * @param userOptions - Optional configuration settings. Will override the default options.\n *\n * @returns {object} The filled segmentation object.\n */\nfunction fillSegmentation(segmentation, inputLabelmaps3D) {\n  let userOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const options = Object.assign({}, generateSegmentationDefaultOptions, userOptions);\n\n  // Use another variable so we don't redefine labelmaps3D.\n  const labelmaps3D = Array.isArray(inputLabelmaps3D) ? inputLabelmaps3D : [inputLabelmaps3D];\n  let numberOfFrames = 0;\n  const referencedFramesPerLabelmap = [];\n  for (let labelmapIndex = 0; labelmapIndex < labelmaps3D.length; labelmapIndex++) {\n    const labelmap3D = labelmaps3D[labelmapIndex];\n    const {\n      labelmaps2D,\n      metadata\n    } = labelmap3D;\n    const referencedFramesPerSegment = [];\n    for (let i = 1; i < metadata.length; i++) {\n      if (metadata[i]) {\n        referencedFramesPerSegment[i] = [];\n      }\n    }\n    for (let i = 0; i < labelmaps2D.length; i++) {\n      const labelmap2D = labelmaps2D[i];\n      if (labelmaps2D[i]) {\n        const {\n          segmentsOnLabelmap\n        } = labelmap2D;\n        segmentsOnLabelmap.forEach(segmentIndex => {\n          if (segmentIndex !== 0) {\n            referencedFramesPerSegment[segmentIndex].push(i);\n            numberOfFrames++;\n          }\n        });\n      }\n    }\n    referencedFramesPerLabelmap[labelmapIndex] = referencedFramesPerSegment;\n  }\n  segmentation.setNumberOfFrames(numberOfFrames);\n  for (let labelmapIndex = 0; labelmapIndex < labelmaps3D.length; labelmapIndex++) {\n    const referencedFramesPerSegment = referencedFramesPerLabelmap[labelmapIndex];\n    const labelmap3D = labelmaps3D[labelmapIndex];\n    const {\n      metadata\n    } = labelmap3D;\n    for (let segmentIndex = 1; segmentIndex < referencedFramesPerSegment.length; segmentIndex++) {\n      const referencedFrameIndicies = referencedFramesPerSegment[segmentIndex];\n      if (referencedFrameIndicies) {\n        // Frame numbers start from 1.\n        const referencedFrameNumbers = referencedFrameIndicies.map(element => {\n          return element + 1;\n        });\n        const segmentMetadata = metadata[segmentIndex];\n        const labelmaps = _getLabelmapsFromReferencedFrameIndicies(labelmap3D, referencedFrameIndicies);\n        segmentation.addSegmentFromLabelmap(segmentMetadata, labelmaps, segmentIndex, referencedFrameNumbers);\n      }\n    }\n  }\n  if (options.rleEncode) {\n    const rleEncodedFrames = encode(segmentation.dataset.PixelData, numberOfFrames, segmentation.dataset.Rows, segmentation.dataset.Columns);\n\n    // Must use fractional now to RLE encode, as the DICOM standard only allows BitStored && BitsAllocated\n    // to be 1 for BINARY. This is not ideal and there should be a better format for compression in this manner\n    // added to the standard.\n    segmentation.assignToDataset({\n      BitsAllocated: \"8\",\n      BitsStored: \"8\",\n      HighBit: \"7\",\n      SegmentationType: \"FRACTIONAL\",\n      SegmentationFractionalType: \"PROBABILITY\",\n      MaximumFractionalValue: \"255\"\n    });\n    segmentation.dataset._meta.TransferSyntaxUID = {\n      Value: [\"1.2.840.10008.1.2.5\"],\n      vr: \"UI\"\n    };\n    segmentation.dataset.SpecificCharacterSet = \"ISO_IR 192\";\n    segmentation.dataset._vrMap.PixelData = \"OB\";\n    segmentation.dataset.PixelData = rleEncodedFrames;\n  } else {\n    // If no rleEncoding, at least bitpack the data.\n    segmentation.bitPackPixelData();\n  }\n  return segmentation;\n}\nfunction _getLabelmapsFromReferencedFrameIndicies(labelmap3D, referencedFrameIndicies) {\n  const {\n    labelmaps2D\n  } = labelmap3D;\n  const labelmaps = [];\n  for (let i = 0; i < referencedFrameIndicies.length; i++) {\n    const frame = referencedFrameIndicies[i];\n    labelmaps.push(labelmaps2D[frame].pixelData);\n  }\n  return labelmaps;\n}\n\n/**\n * _createSegFromImages - description\n *\n * @param  {Object[]} images    An array of the cornerstone image objects.\n * @param  {Boolean} isMultiframe Whether the images are multiframe.\n * @returns {Object}              The Seg derived dataSet.\n */\nfunction _createSegFromImages(images, isMultiframe, options) {\n  const multiframe = getDatasetsFromImages(images, isMultiframe);\n  return new SegmentationDerivation([multiframe], options);\n}\n\n/**\n * generateToolState - Given a set of cornerstoneTools imageIds and a Segmentation buffer,\n * derive cornerstoneTools toolState and brush metadata.\n *\n * @param  {string[]} referencedImageIds - An array for referenced image imageIds.\n * @param  {ArrayBuffer} arrayBuffer - The SEG arrayBuffer.\n * @param  {*} metadataProvider.\n * @param  {obj} options - Options object.\n *\n * @return {[]ArrayBuffer}a list of array buffer for each labelMap\n * @return {Object} an object from which the segment metadata can be derived\n * @return {[][][]} 2D list containing the track of segments per frame\n * @return {[][][]} 3D list containing the track of segments per frame for each labelMap\n *                  (available only for the overlapping case).\n */\nasync function generateToolState(referencedImageIds, arrayBuffer, metadataProvider, options) {\n  const {\n    skipOverlapping = false,\n    tolerance = 1e-3,\n    TypedArrayConstructor = Uint8Array,\n    maxBytesPerChunk = 199000000,\n    eventTarget = null,\n    triggerEvent = null\n  } = options;\n  const dicomData = DicomMessage.readFile(arrayBuffer);\n  const dataset = DicomMetaDictionary.naturalizeDataset(dicomData.dict);\n  dataset._meta = DicomMetaDictionary.namifyDataset(dicomData.meta);\n  const multiframe = Normalizer.normalizeToDataset([dataset]);\n  const imagePlaneModule = metadataProvider.get(\"imagePlaneModule\", referencedImageIds[0]);\n  const generalSeriesModule = metadataProvider.get(\"generalSeriesModule\", referencedImageIds[0]);\n  const SeriesInstanceUID = generalSeriesModule.seriesInstanceUID;\n  if (!imagePlaneModule) {\n    console.warn(\"Insufficient metadata, imagePlaneModule missing.\");\n  }\n  const ImageOrientationPatient = Array.isArray(imagePlaneModule.rowCosines) ? [...imagePlaneModule.rowCosines, ...imagePlaneModule.columnCosines] : [imagePlaneModule.rowCosines.x, imagePlaneModule.rowCosines.y, imagePlaneModule.rowCosines.z, imagePlaneModule.columnCosines.x, imagePlaneModule.columnCosines.y, imagePlaneModule.columnCosines.z];\n\n  // Get IOP from ref series, compute supported orientations:\n  const validOrientations = getValidOrientations(ImageOrientationPatient);\n  const sliceLength = multiframe.Columns * multiframe.Rows;\n  const segMetadata = getSegmentMetadata(multiframe, SeriesInstanceUID);\n  const TransferSyntaxUID = multiframe._meta.TransferSyntaxUID.Value[0];\n  let pixelData;\n  let pixelDataChunks;\n  if (TransferSyntaxUID === \"1.2.840.10008.1.2.5\") {\n    const rleEncodedFrames = Array.isArray(multiframe.PixelData) ? multiframe.PixelData : [multiframe.PixelData];\n    pixelData = decode(rleEncodedFrames, multiframe.Rows, multiframe.Columns);\n    if (multiframe.BitsStored === 1) {\n      console.warn(\"No implementation for rle + bitbacking.\");\n      return;\n    }\n\n    // Todo: need to test this with rle data\n    pixelDataChunks = [pixelData];\n  } else {\n    pixelDataChunks = unpackPixelData(multiframe, {\n      maxBytesPerChunk\n    });\n    if (!pixelDataChunks) {\n      throw new Error(\"Fractional segmentations are not yet supported\");\n    }\n  }\n  const orientation = checkOrientation(multiframe, validOrientations, [imagePlaneModule.rows, imagePlaneModule.columns, referencedImageIds.length], tolerance);\n\n  // Pre-compute the sop UID to imageId index map so that in the for loop\n  // we don't have to call metadataProvider.get() for each imageId over\n  // and over again.\n  const sopUIDImageIdIndexMap = referencedImageIds.reduce((acc, imageId) => {\n    const {\n      sopInstanceUID\n    } = metadataProvider.get(\"generalImageModule\", imageId);\n    acc[sopInstanceUID] = imageId;\n    return acc;\n  }, {});\n  let overlapping = false;\n  if (!skipOverlapping) {\n    overlapping = checkSEGsOverlapping(pixelDataChunks, multiframe, referencedImageIds, validOrientations, metadataProvider, tolerance, TypedArrayConstructor, sopUIDImageIdIndexMap);\n  }\n  let insertFunction;\n  switch (orientation) {\n    case \"Planar\":\n      if (overlapping) {\n        insertFunction = insertOverlappingPixelDataPlanar;\n      } else {\n        insertFunction = insertPixelDataPlanar;\n      }\n      break;\n    case \"Perpendicular\":\n      //insertFunction = insertPixelDataPerpendicular;\n      throw new Error(\"Segmentations orthogonal to the acquisition plane of the source data are not yet supported.\");\n    case \"Oblique\":\n      throw new Error(\"Segmentations oblique to the acquisition plane of the source data are not yet supported.\");\n  }\n\n  /* if SEGs are overlapping:\n  1) the labelmapBuffer will contain M volumes which have non-overlapping segments;\n  2) segmentsOnFrame will have M * numberOfFrames values to track in which labelMap are the segments;\n  3) insertFunction will return the number of LabelMaps\n  4) generateToolState return is an array*/\n\n  const segmentsOnFrameArray = [];\n  segmentsOnFrameArray[0] = [];\n  const segmentsOnFrame = [];\n  const arrayBufferLength = sliceLength * referencedImageIds.length * TypedArrayConstructor.BYTES_PER_ELEMENT;\n  const labelmapBufferArray = [];\n  labelmapBufferArray[0] = new ArrayBuffer(arrayBufferLength);\n\n  // Pre-compute the indices and metadata so that we don't have to call\n  // a function for each imageId in the for loop.\n  const imageIdMaps = referencedImageIds.reduce((acc, curr, index) => {\n    acc.indices[curr] = index;\n    acc.metadata[curr] = metadataProvider.get(\"instance\", curr);\n    return acc;\n  }, {\n    indices: {},\n    metadata: {}\n  });\n\n  // This is the centroid calculation for each segment Index, the data structure\n  // is a Map with key = segmentIndex and value = {imageIdIndex: centroid, ...}\n  // later on we will use this data structure to calculate the centroid of the\n  // segment in the labelmapBuffer\n  const segmentsPixelIndices = new Map();\n  const overlappingSegments = await insertFunction(segmentsOnFrame, segmentsOnFrameArray, labelmapBufferArray, pixelDataChunks, multiframe, referencedImageIds, validOrientations, metadataProvider, tolerance, TypedArrayConstructor, segmentsPixelIndices, sopUIDImageIdIndexMap, imageIdMaps, eventTarget, triggerEvent);\n\n  // calculate the centroid of each segment\n  const centroidXYZ = new Map();\n  segmentsPixelIndices.forEach((imageIdIndexBufferIndex, segmentIndex) => {\n    const centroids = calculateCentroid(imageIdIndexBufferIndex, multiframe, metadataProvider, referencedImageIds);\n    centroidXYZ.set(segmentIndex, centroids);\n  });\n  return {\n    labelmapBufferArray,\n    segMetadata,\n    segmentsOnFrame,\n    segmentsOnFrameArray,\n    centroids: centroidXYZ,\n    overlappingSegments\n  };\n}\n\n// function insertPixelDataPerpendicular(\n//     segmentsOnFrame,\n//     labelmapBuffer,\n//     pixelData,\n//     multiframe,\n//     imageIds,\n//     validOrientations,\n//     metadataProvider\n// ) {\n//     const {\n//         SharedFunctionalGroupsSequence,\n//         PerFrameFunctionalGroupsSequence,\n//         Rows,\n//         Columns\n//     } = multiframe;\n\n//     const firstImagePlaneModule = metadataProvider.get(\n//         \"imagePlaneModule\",\n//         imageIds[0]\n//     );\n\n//     const lastImagePlaneModule = metadataProvider.get(\n//         \"imagePlaneModule\",\n//         imageIds[imageIds.length - 1]\n//     );\n\n//     console.log(firstImagePlaneModule);\n//     console.log(lastImagePlaneModule);\n\n//     const corners = [\n//         ...getCorners(firstImagePlaneModule),\n//         ...getCorners(lastImagePlaneModule)\n//     ];\n\n//     console.log(`corners:`);\n//     console.log(corners);\n\n//     const indexToWorld = mat4.create();\n\n//     const ippFirstFrame = firstImagePlaneModule.imagePositionPatient;\n//     const rowCosines = Array.isArray(firstImagePlaneModule.rowCosines)\n//         ? [...firstImagePlaneModule.rowCosines]\n//         : [\n//               firstImagePlaneModule.rowCosines.x,\n//               firstImagePlaneModule.rowCosines.y,\n//               firstImagePlaneModule.rowCosines.z\n//           ];\n\n//     const columnCosines = Array.isArray(firstImagePlaneModule.columnCosines)\n//         ? [...firstImagePlaneModule.columnCosines]\n//         : [\n//               firstImagePlaneModule.columnCosines.x,\n//               firstImagePlaneModule.columnCosines.y,\n//               firstImagePlaneModule.columnCosines.z\n//           ];\n\n//     const { pixelSpacing } = firstImagePlaneModule;\n\n//     mat4.set(\n//         indexToWorld,\n//         // Column 1\n//         0,\n//         0,\n//         0,\n//         ippFirstFrame[0],\n//         // Column 2\n//         0,\n//         0,\n//         0,\n//         ippFirstFrame[1],\n//         // Column 3\n//         0,\n//         0,\n//         0,\n//         ippFirstFrame[2],\n//         // Column 4\n//         0,\n//         0,\n//         0,\n//         1\n//     );\n\n//     // TODO -> Get origin and (x,y,z) increments to build a translation matrix:\n//     // TODO -> Equation C.7.6.2.1-1\n\n//     // | cx*di rx* Xx 0 |  |x|\n//     // | cy*di ry Xy 0 |  |y|\n//     // | cz*di rz Xz 0 |  |z|\n//     // | tx ty tz 1 |  |1|\n\n//     // const [\n//     //     0, 0 , 0 , 0,\n//     //     0, 0 , 0 , 0,\n//     //     0, 0 , 0 , 0,\n//     //     ipp[0], ipp[1] , ipp[2] , 1,\n//     // ]\n\n//     // Each frame:\n\n//     // Find which corner the first voxel lines up with (one of 8 corners.)\n\n//     // Find how i,j,k orient with respect to source volume.\n//     // Go through each frame, find location in source to start, and whether to increment +/ix,+/-y,+/-z\n//     //   through each voxel.\n\n//     // [1,0,0,0,1,0]\n\n//     // const [\n\n//     // ]\n\n//     // Invert transformation matrix to get worldToIndex\n\n//     // Apply world to index on each point to fill up the matrix.\n\n//     // const sharedImageOrientationPatient = SharedFunctionalGroupsSequence.PlaneOrientationSequence\n//     //     ? SharedFunctionalGroupsSequence.PlaneOrientationSequence\n//     //           .ImageOrientationPatient\n//     //     : undefined;\n//     // const sliceLength = Columns * Rows;\n// }\n\n// function getCorners(imagePlaneModule) {\n//     // console.log(imagePlaneModule);\n\n//     const {\n//         rows,\n//         columns,\n//         rowCosines,\n//         columnCosines,\n//         imagePositionPatient: ipp,\n//         rowPixelSpacing,\n//         columnPixelSpacing\n//     } = imagePlaneModule;\n\n//     const rowLength = columns * columnPixelSpacing;\n//     const columnLength = rows * rowPixelSpacing;\n\n//     const entireRowVector = [\n//         rowLength * columnCosines[0],\n//         rowLength * columnCosines[1],\n//         rowLength * columnCosines[2]\n//     ];\n\n//     const entireColumnVector = [\n//         columnLength * rowCosines[0],\n//         columnLength * rowCosines[1],\n//         columnLength * rowCosines[2]\n//     ];\n\n//     const topLeft = [ipp[0], ipp[1], ipp[2]];\n//     const topRight = [\n//         topLeft[0] + entireRowVector[0],\n//         topLeft[1] + entireRowVector[1],\n//         topLeft[2] + entireRowVector[2]\n//     ];\n//     const bottomLeft = [\n//         topLeft[0] + entireColumnVector[0],\n//         topLeft[1] + entireColumnVector[1],\n//         topLeft[2] + entireColumnVector[2]\n//     ];\n\n//     const bottomRight = [\n//         bottomLeft[0] + entireRowVector[0],\n//         bottomLeft[1] + entireRowVector[1],\n//         bottomLeft[2] + entireRowVector[2]\n//     ];\n\n//     return [topLeft, topRight, bottomLeft, bottomRight];\n// }\n\n/**\n * Find the reference frame of the segmentation frame in the source data.\n *\n * @param  {Object}      multiframe        dicom metadata\n * @param  {Int}         frameSegment      frame dicom index\n * @param  {String[]}    imageIds          A list of imageIds.\n * @param  {Object}      sopUIDImageIdIndexMap  A map of SOPInstanceUID to imageId\n * @param  {Float}       tolerance         The tolerance parameter\n *\n * @returns {String}     Returns the imageId\n */\nfunction findReferenceSourceImageId(multiframe, frameSegment, imageIds, metadataProvider, tolerance, sopUIDImageIdIndexMap) {\n  let imageId = undefined;\n  if (!multiframe) {\n    return imageId;\n  }\n  const {\n    FrameOfReferenceUID,\n    PerFrameFunctionalGroupsSequence,\n    SourceImageSequence,\n    ReferencedSeriesSequence\n  } = multiframe;\n  if (!PerFrameFunctionalGroupsSequence || PerFrameFunctionalGroupsSequence.length === 0) {\n    return imageId;\n  }\n  const PerFrameFunctionalGroup = PerFrameFunctionalGroupsSequence[frameSegment];\n  if (!PerFrameFunctionalGroup) {\n    return imageId;\n  }\n  let frameSourceImageSequence = undefined;\n  if (PerFrameFunctionalGroup.DerivationImageSequence) {\n    let DerivationImageSequence = PerFrameFunctionalGroup.DerivationImageSequence;\n    if (Array.isArray(DerivationImageSequence)) {\n      if (DerivationImageSequence.length !== 0) {\n        DerivationImageSequence = DerivationImageSequence[0];\n      } else {\n        DerivationImageSequence = undefined;\n      }\n    }\n    if (DerivationImageSequence) {\n      frameSourceImageSequence = DerivationImageSequence.SourceImageSequence;\n      if (Array.isArray(frameSourceImageSequence)) {\n        if (frameSourceImageSequence.length !== 0) {\n          frameSourceImageSequence = frameSourceImageSequence[0];\n        } else {\n          frameSourceImageSequence = undefined;\n        }\n      }\n    }\n  } else if (SourceImageSequence && SourceImageSequence.length !== 0) {\n    console.warn(\"DerivationImageSequence not present, using SourceImageSequence assuming SEG has the same geometry as the source image.\");\n    frameSourceImageSequence = SourceImageSequence[frameSegment];\n  }\n  if (frameSourceImageSequence) {\n    imageId = getImageIdOfSourceImageBySourceImageSequence(frameSourceImageSequence, sopUIDImageIdIndexMap);\n  }\n  if (imageId === undefined && ReferencedSeriesSequence) {\n    const referencedSeriesSequence = Array.isArray(ReferencedSeriesSequence) ? ReferencedSeriesSequence[0] : ReferencedSeriesSequence;\n    const ReferencedSeriesInstanceUID = referencedSeriesSequence.SeriesInstanceUID;\n    imageId = getImageIdOfSourceImagebyGeometry(ReferencedSeriesInstanceUID, FrameOfReferenceUID, PerFrameFunctionalGroup, imageIds, metadataProvider, tolerance);\n  }\n  return imageId;\n}\n\n/**\n * Checks if there is any overlapping segmentations.\n *  @returns {boolean} Returns a flag if segmentations overlapping\n */\n\nfunction checkSEGsOverlapping(pixelData, multiframe, imageIds, validOrientations, metadataProvider, tolerance, TypedArrayConstructor, sopUIDImageIdIndexMap) {\n  const {\n    SharedFunctionalGroupsSequence,\n    PerFrameFunctionalGroupsSequence,\n    SegmentSequence,\n    Rows,\n    Columns\n  } = multiframe;\n  let numberOfSegs = SegmentSequence.length;\n  if (numberOfSegs < 2) {\n    return false;\n  }\n  const sharedImageOrientationPatient = SharedFunctionalGroupsSequence.PlaneOrientationSequence ? SharedFunctionalGroupsSequence.PlaneOrientationSequence.ImageOrientationPatient : undefined;\n  const sliceLength = Columns * Rows;\n  const groupsLen = PerFrameFunctionalGroupsSequence.length;\n\n  /** sort groupsLen to have all the segments for each frame in an array\n   * frame 2 : 1, 2\n   * frame 4 : 1, 3\n   * frame 5 : 4\n   */\n\n  let frameSegmentsMapping = new Map();\n  for (let frameSegment = 0; frameSegment < groupsLen; ++frameSegment) {\n    const segmentIndex = getSegmentIndex(multiframe, frameSegment);\n    if (segmentIndex === undefined) {\n      console.warn(\"Could not retrieve the segment index for frame segment \" + frameSegment + \", skipping this frame.\");\n      continue;\n    }\n    const imageId = findReferenceSourceImageId(multiframe, frameSegment, imageIds, metadataProvider, tolerance, sopUIDImageIdIndexMap);\n    if (!imageId) {\n      console.warn(\"Image not present in stack, can't import frame : \" + frameSegment + \".\");\n      continue;\n    }\n    const imageIdIndex = imageIds.findIndex(element => element === imageId);\n    if (frameSegmentsMapping.has(imageIdIndex)) {\n      let segmentArray = frameSegmentsMapping.get(imageIdIndex);\n      if (!segmentArray.includes(frameSegment)) {\n        segmentArray.push(frameSegment);\n        frameSegmentsMapping.set(imageIdIndex, segmentArray);\n      }\n    } else {\n      frameSegmentsMapping.set(imageIdIndex, [frameSegment]);\n    }\n  }\n  for (let [, role] of frameSegmentsMapping.entries()) {\n    let temp2DArray = new TypedArrayConstructor(sliceLength).fill(0);\n    for (let i = 0; i < role.length; ++i) {\n      const frameSegment = role[i];\n      const PerFrameFunctionalGroups = PerFrameFunctionalGroupsSequence[frameSegment];\n      const ImageOrientationPatientI = sharedImageOrientationPatient || PerFrameFunctionalGroups.PlaneOrientationSequence.ImageOrientationPatient;\n      const view = readFromUnpackedChunks(pixelData, frameSegment * sliceLength, sliceLength);\n      const pixelDataI2D = ndarray(view, [Rows, Columns]);\n      const alignedPixelDataI = alignPixelDataWithSourceData(pixelDataI2D, ImageOrientationPatientI, validOrientations, tolerance);\n      if (!alignedPixelDataI) {\n        console.warn(\"Individual SEG frames are out of plane with respect to the first SEG frame, this is not yet supported, skipping this frame.\");\n        continue;\n      }\n      const data = alignedPixelDataI.data;\n      for (let j = 0, len = data.length; j < len; ++j) {\n        if (data[j] !== 0) {\n          temp2DArray[j]++;\n          if (temp2DArray[j] > 1) {\n            return true;\n          }\n        }\n      }\n    }\n  }\n  return false;\n}\nfunction insertOverlappingPixelDataPlanar(segmentsOnFrame, segmentsOnFrameArray, labelmapBufferArray, pixelData, multiframe, imageIds, validOrientations, metadataProvider, tolerance, TypedArrayConstructor, segmentsPixelIndices, sopUIDImageIdIndexMap) {\n  const {\n    SharedFunctionalGroupsSequence,\n    PerFrameFunctionalGroupsSequence,\n    Rows,\n    Columns\n  } = multiframe;\n  const sharedImageOrientationPatient = SharedFunctionalGroupsSequence.PlaneOrientationSequence ? SharedFunctionalGroupsSequence.PlaneOrientationSequence.ImageOrientationPatient : undefined;\n  const sliceLength = Columns * Rows;\n  const arrayBufferLength = sliceLength * imageIds.length * TypedArrayConstructor.BYTES_PER_ELEMENT;\n  // indicate the number of labelMaps\n  let M = 1;\n\n  // indicate the current labelMap array index;\n  let m = 0;\n\n  // temp array for checking overlaps\n  let tempBuffer = labelmapBufferArray[m].slice(0);\n\n  // temp list for checking overlaps\n  let tempSegmentsOnFrame = structuredClone(segmentsOnFrameArray[m]);\n\n  /** split overlapping SEGs algorithm for each segment:\n   *  A) copy the labelmapBuffer in the array with index 0\n   *  B) add the segment pixel per pixel on the copied buffer from (A)\n   *  C) if no overlap, copy the results back on the orignal array from (A)\n   *  D) if overlap, repeat increasing the index m up to M (if out of memory, add new buffer in the array and M++);\n   */\n\n  let numberOfSegs = multiframe.SegmentSequence.length;\n  for (let segmentIndexToProcess = 1; segmentIndexToProcess <= numberOfSegs; ++segmentIndexToProcess) {\n    for (let i = 0, groupsLen = PerFrameFunctionalGroupsSequence.length; i < groupsLen; ++i) {\n      const PerFrameFunctionalGroups = PerFrameFunctionalGroupsSequence[i];\n      const segmentIndex = getSegmentIndex(multiframe, i);\n      if (segmentIndex === undefined) {\n        throw new Error(\"Could not retrieve the segment index. Aborting segmentation loading.\");\n      }\n      if (segmentIndex !== segmentIndexToProcess) {\n        continue;\n      }\n      const ImageOrientationPatientI = sharedImageOrientationPatient || PerFrameFunctionalGroups.PlaneOrientationSequence.ImageOrientationPatient;\n\n      // Since we moved to the chunks approach, we need to read the data\n      // and handle scenarios where the portion of data is in one chunk\n      // and the other portion is in another chunk\n      const view = readFromUnpackedChunks(pixelData, i * sliceLength, sliceLength);\n      const pixelDataI2D = ndarray(view, [Rows, Columns]);\n      const alignedPixelDataI = alignPixelDataWithSourceData(pixelDataI2D, ImageOrientationPatientI, validOrientations, tolerance);\n      if (!alignedPixelDataI) {\n        throw new Error(\"Individual SEG frames are out of plane with respect to the first SEG frame. \" + \"This is not yet supported. Aborting segmentation loading.\");\n      }\n      const imageId = findReferenceSourceImageId(multiframe, i, imageIds, metadataProvider, tolerance, sopUIDImageIdIndexMap);\n      if (!imageId) {\n        console.warn(\"Image not present in stack, can't import frame : \" + i + \".\");\n        continue;\n      }\n      const sourceImageMetadata = metadataProvider.get(\"instance\", imageId);\n      if (Rows !== sourceImageMetadata.Rows || Columns !== sourceImageMetadata.Columns) {\n        throw new Error(\"Individual SEG frames have different geometry dimensions (Rows and Columns) \" + \"respect to the source image reference frame. This is not yet supported. \" + \"Aborting segmentation loading. \");\n      }\n      const imageIdIndex = imageIds.findIndex(element => element === imageId);\n      const byteOffset = sliceLength * imageIdIndex * TypedArrayConstructor.BYTES_PER_ELEMENT;\n      const labelmap2DView = new TypedArrayConstructor(tempBuffer, byteOffset, sliceLength);\n      const data = alignedPixelDataI.data;\n      let segmentOnFrame = false;\n      for (let j = 0, len = alignedPixelDataI.data.length; j < len; ++j) {\n        if (data[j]) {\n          if (labelmap2DView[j] !== 0) {\n            m++;\n            if (m >= M) {\n              labelmapBufferArray[m] = new ArrayBuffer(arrayBufferLength);\n              segmentsOnFrameArray[m] = [];\n              M++;\n            }\n            tempBuffer = labelmapBufferArray[m].slice(0);\n            tempSegmentsOnFrame = structuredClone(segmentsOnFrameArray[m]);\n            i = 0;\n            break;\n          } else {\n            labelmap2DView[j] = segmentIndex;\n            segmentOnFrame = true;\n          }\n        }\n      }\n      if (segmentOnFrame) {\n        if (!tempSegmentsOnFrame[imageIdIndex]) {\n          tempSegmentsOnFrame[imageIdIndex] = [];\n        }\n        tempSegmentsOnFrame[imageIdIndex].push(segmentIndex);\n        if (!segmentsOnFrame[imageIdIndex]) {\n          segmentsOnFrame[imageIdIndex] = [];\n        }\n        segmentsOnFrame[imageIdIndex].push(segmentIndex);\n      }\n    }\n    labelmapBufferArray[m] = tempBuffer.slice(0);\n    segmentsOnFrameArray[m] = structuredClone(tempSegmentsOnFrame);\n\n    // reset temp variables/buffers for new segment\n    m = 0;\n    tempBuffer = labelmapBufferArray[m].slice(0);\n    tempSegmentsOnFrame = structuredClone(segmentsOnFrameArray[m]);\n  }\n}\nconst getSegmentIndex = (multiframe, frame) => {\n  const {\n    PerFrameFunctionalGroupsSequence,\n    SharedFunctionalGroupsSequence\n  } = multiframe;\n  const PerFrameFunctionalGroups = PerFrameFunctionalGroupsSequence[frame];\n  return PerFrameFunctionalGroups && PerFrameFunctionalGroups.SegmentIdentificationSequence ? PerFrameFunctionalGroups.SegmentIdentificationSequence.ReferencedSegmentNumber : SharedFunctionalGroupsSequence.SegmentIdentificationSequence ? SharedFunctionalGroupsSequence.SegmentIdentificationSequence.ReferencedSegmentNumber : undefined;\n};\nfunction insertPixelDataPlanar(segmentsOnFrame, segmentsOnFrameArray, labelmapBufferArray, pixelData, multiframe, imageIds, validOrientations, metadataProvider, tolerance, TypedArrayConstructor, segmentsPixelIndices, sopUIDImageIdIndexMap, imageIdMaps, eventTarget, triggerEvent) {\n  const {\n    SharedFunctionalGroupsSequence,\n    PerFrameFunctionalGroupsSequence,\n    Rows,\n    Columns\n  } = multiframe;\n  const sharedImageOrientationPatient = SharedFunctionalGroupsSequence.PlaneOrientationSequence ? SharedFunctionalGroupsSequence.PlaneOrientationSequence.ImageOrientationPatient : undefined;\n  const sliceLength = Columns * Rows;\n  let i = 0;\n  const groupsLen = PerFrameFunctionalGroupsSequence.length;\n  const chunkSize = Math.ceil(groupsLen / 10); // 10% of total length\n\n  const shouldTriggerEvent = triggerEvent && eventTarget;\n  let overlapping = false;\n  // Below, we chunk the processing of the frames to avoid blocking the main thread\n  // if the segmentation is large. We also use a promise to allow the caller to\n  // wait for the processing to finish.\n  return new Promise(resolve => {\n    function processInChunks() {\n      // process one chunk\n      for (let end = Math.min(i + chunkSize, groupsLen); i < end; ++i) {\n        const PerFrameFunctionalGroups = PerFrameFunctionalGroupsSequence[i];\n        const ImageOrientationPatientI = sharedImageOrientationPatient || PerFrameFunctionalGroups.PlaneOrientationSequence.ImageOrientationPatient;\n        const view = readFromUnpackedChunks(pixelData, i * sliceLength, sliceLength);\n        const pixelDataI2D = ndarray(view, [Rows, Columns]);\n        const alignedPixelDataI = alignPixelDataWithSourceData(pixelDataI2D, ImageOrientationPatientI, validOrientations, tolerance);\n        if (!alignedPixelDataI) {\n          throw new Error(\"Individual SEG frames are out of plane with respect to the first SEG frame. \" + \"This is not yet supported. Aborting segmentation loading.\");\n        }\n        const segmentIndex = getSegmentIndex(multiframe, i);\n        if (segmentIndex === undefined) {\n          throw new Error(\"Could not retrieve the segment index. Aborting segmentation loading.\");\n        }\n        if (!segmentsPixelIndices.has(segmentIndex)) {\n          segmentsPixelIndices.set(segmentIndex, {});\n        }\n        const imageId = findReferenceSourceImageId(multiframe, i, imageIds, metadataProvider, tolerance, sopUIDImageIdIndexMap);\n        if (!imageId) {\n          console.warn(\"Image not present in stack, can't import frame : \" + i + \".\");\n          continue;\n        }\n        const sourceImageMetadata = imageIdMaps.metadata[imageId];\n        if (Rows !== sourceImageMetadata.Rows || Columns !== sourceImageMetadata.Columns) {\n          throw new Error(\"Individual SEG frames have different geometry dimensions (Rows and Columns) \" + \"respect to the source image reference frame. This is not yet supported. \" + \"Aborting segmentation loading. \");\n        }\n        const imageIdIndex = imageIdMaps.indices[imageId];\n        const byteOffset = sliceLength * imageIdIndex * TypedArrayConstructor.BYTES_PER_ELEMENT;\n        const labelmap2DView = new TypedArrayConstructor(labelmapBufferArray[0], byteOffset, sliceLength);\n        const data = alignedPixelDataI.data;\n        const indexCache = [];\n        for (let j = 0, len = alignedPixelDataI.data.length; j < len; ++j) {\n          if (data[j]) {\n            for (let x = j; x < len; ++x) {\n              if (data[x]) {\n                if (!overlapping && labelmap2DView[x] !== 0) {\n                  overlapping = true;\n                }\n                labelmap2DView[x] = segmentIndex;\n                indexCache.push(x);\n              }\n            }\n            if (!segmentsOnFrame[imageIdIndex]) {\n              segmentsOnFrame[imageIdIndex] = [];\n            }\n            segmentsOnFrame[imageIdIndex].push(segmentIndex);\n            break;\n          }\n        }\n        const segmentIndexObject = segmentsPixelIndices.get(segmentIndex);\n        segmentIndexObject[imageIdIndex] = indexCache;\n        segmentsPixelIndices.set(segmentIndex, segmentIndexObject);\n      }\n\n      // trigger an event after each chunk\n      if (shouldTriggerEvent) {\n        const percentComplete = Math.round(i / groupsLen * 100);\n        triggerEvent(eventTarget, Events.SEGMENTATION_LOAD_PROGRESS, {\n          percentComplete\n        });\n      }\n\n      // schedule next chunk\n      if (i < groupsLen) {\n        setTimeout(processInChunks, 0);\n      } else {\n        // resolve the Promise when all chunks have been processed\n        resolve(overlapping);\n      }\n    }\n    processInChunks();\n  });\n}\n\n/**\n * unpackPixelData - Unpacks bit packed pixelData if the Segmentation is BINARY.\n *\n * @param  {Object} multiframe The multiframe dataset.\n * @param  {Object} options    Options for the unpacking.\n * @return {Uint8Array}      The unpacked pixelData.\n */\nfunction unpackPixelData(multiframe, options) {\n  const segType = multiframe.SegmentationType;\n  let data;\n  if (Array.isArray(multiframe.PixelData)) {\n    data = multiframe.PixelData[0];\n  } else {\n    data = multiframe.PixelData;\n  }\n  if (data === undefined) {\n    log.error(\"This segmentation pixelData is undefined.\");\n  }\n  if (segType === \"BINARY\") {\n    // For extreme big data, we can't unpack the data at once and we need to\n    // chunk it and unpack each chunk separately.\n    // MAX 2GB is the limit right now to allocate a buffer\n    return getUnpackedChunks(data, options.maxBytesPerChunk);\n  }\n  const pixelData = new Uint8Array(data);\n  const max = multiframe.MaximumFractionalValue;\n  const onlyMaxAndZero = pixelData.find(element => element !== 0 && element !== max) === undefined;\n  if (!onlyMaxAndZero) {\n    // This is a fractional segmentation, which is not currently supported.\n    return;\n  }\n  log.warn(\"This segmentation object is actually binary... processing as such.\");\n  return pixelData;\n}\nfunction getUnpackedChunks(data, maxBytesPerChunk) {\n  var bitArray = new Uint8Array(data);\n  var chunks = [];\n  var maxBitsPerChunk = maxBytesPerChunk * 8;\n  var numberOfChunks = Math.ceil(bitArray.length * 8 / maxBitsPerChunk);\n  for (var i = 0; i < numberOfChunks; i++) {\n    var startBit = i * maxBitsPerChunk;\n    var endBit = Math.min(startBit + maxBitsPerChunk, bitArray.length * 8);\n    var startByte = Math.floor(startBit / 8);\n    var endByte = Math.ceil(endBit / 8);\n    var chunk = bitArray.slice(startByte, endByte);\n    var unpackedChunk = BitArray.unpack(chunk);\n    chunks.push(unpackedChunk);\n  }\n  return chunks;\n}\n\n/**\n * getImageIdOfSourceImageBySourceImageSequence - Returns the Cornerstone imageId of the source image.\n *\n * @param  {Object}   SourceImageSequence  Sequence describing the source image.\n * @param  {String[]} imageIds             A list of imageIds.\n * @param  {Object}   sopUIDImageIdIndexMap A map of SOPInstanceUIDs to imageIds.\n * @return {String}                        The corresponding imageId.\n */\nfunction getImageIdOfSourceImageBySourceImageSequence(SourceImageSequence, sopUIDImageIdIndexMap) {\n  const {\n    ReferencedSOPInstanceUID,\n    ReferencedFrameNumber\n  } = SourceImageSequence;\n  const baseImageId = sopUIDImageIdIndexMap[ReferencedSOPInstanceUID];\n  if (!baseImageId) {\n    console.warn(`No imageId found for SOPInstanceUID: ${ReferencedSOPInstanceUID}`);\n    return undefined;\n  }\n  if (ReferencedFrameNumber !== undefined) {\n    if (baseImageId.includes(\"frames/\")) {\n      return baseImageId.replace(/frames\\/\\d+/, `frames/${ReferencedFrameNumber}`);\n    } else if (baseImageId.includes(\"frame=\")) {\n      return baseImageId.replace(/frame=\\d+/, `frame=${ReferencedFrameNumber - 1}`);\n    } else {\n      if (baseImageId.includes(\"wadors:\")) {\n        return `${baseImageId}/frames/${ReferencedFrameNumber}`;\n      } else {\n        return `${baseImageId}?frame=${ReferencedFrameNumber - 1}`;\n      }\n    }\n  }\n  return baseImageId;\n}\n\n/**\n * Determines if an image is a multiframe image based on its metadata.\n *\n * @param {Object} imageMetadata - The metadata object for the image\n * @param {number} [imageMetadata.NumberOfFrames] - The number of frames in the image\n * @returns {boolean} True if the image is a multiframe image (NumberOfFrames > 1)\n */\nfunction isMultiframeImage(imageMetadata) {\n  return imageMetadata && imageMetadata.NumberOfFrames > 1;\n}\n\n/**\n * getImageIdOfSourceImagebyGeometry - Returns the Cornerstone imageId of the source image.\n *\n * @param  {String}    ReferencedSeriesInstanceUID    Referenced series of the source image.\n * @param  {String}    FrameOfReferenceUID            Frame of reference.\n * @param  {Object}    PerFrameFunctionalGroup        Sequence describing segmentation reference attributes per frame.\n * @param  {String[]}  imageIds                       A list of imageIds.\n * @param  {Object}    sopUIDImageIdIndexMap          A map of SOPInstanceUIDs to imageIds.\n * @param  {Float}     tolerance                      The tolerance parameter\n *\n * @return {String}                                   The corresponding imageId.\n */\nfunction getImageIdOfSourceImagebyGeometry(ReferencedSeriesInstanceUID, FrameOfReferenceUID, PerFrameFunctionalGroup, imageIds, metadataProvider, tolerance) {\n  if (!ReferencedSeriesInstanceUID || !PerFrameFunctionalGroup.PlanePositionSequence?.[0]?.ImagePositionPatient) {\n    return undefined;\n  }\n  const segFramePosition = PerFrameFunctionalGroup.PlanePositionSequence[0].ImagePositionPatient;\n  for (let imageId of imageIds) {\n    const sourceImageMetadata = metadataProvider.get(\"instance\", imageId);\n    if (!sourceImageMetadata) {\n      continue;\n    }\n    const isMultiframe = isMultiframeImage(sourceImageMetadata);\n    if (!sourceImageMetadata.ImagePositionPatient || sourceImageMetadata.FrameOfReferenceUID !== FrameOfReferenceUID || sourceImageMetadata.SeriesInstanceUID !== ReferencedSeriesInstanceUID) {\n      continue;\n    }\n\n    // For multiframe images, check each frame's position\n    if (isMultiframe) {\n      const framePosition = metadataProvider.get(\"imagePlaneModule\", imageId)?.imagePositionPatient;\n      if (framePosition && compareArrays(segFramePosition, framePosition, tolerance)) {\n        return imageId;\n      }\n    } else if (compareArrays(segFramePosition, sourceImageMetadata.ImagePositionPatient, tolerance)) {\n      return imageId;\n    }\n  }\n  return undefined;\n}\n\n/**\n * getValidOrientations - returns an array of valid orientations.\n *\n * @param  {Number[6]} iop The row (0..2) an column (3..5) direction cosines.\n * @return {Number[8][6]} An array of valid orientations.\n */\nfunction getValidOrientations(iop) {\n  const orientations = [];\n\n  // [0,  1,  2]: 0,   0hf,   0vf\n  // [3,  4,  5]: 90,  90hf,  90vf\n  // [6, 7]:      180, 270\n\n  orientations[0] = iop;\n  orientations[1] = flipIOP.h(iop);\n  orientations[2] = flipIOP.v(iop);\n  const iop90 = rotateDirectionCosinesInPlane(iop, Math.PI / 2);\n  orientations[3] = iop90;\n  orientations[4] = flipIOP.h(iop90);\n  orientations[5] = flipIOP.v(iop90);\n  orientations[6] = rotateDirectionCosinesInPlane(iop, Math.PI);\n  orientations[7] = rotateDirectionCosinesInPlane(iop, 1.5 * Math.PI);\n  return orientations;\n}\n\n/**\n * alignPixelDataWithSourceData -\n *\n * @param {Ndarray} pixelData2D - The data to align.\n * @param {Number[6]} iop - The orientation of the image slice.\n * @param {Number[8][6]} orientations - An array of valid imageOrientationPatient values.\n * @param {Number} tolerance.\n * @return {Ndarray} The aligned pixelData.\n */\nfunction alignPixelDataWithSourceData(pixelData2D, iop, orientations, tolerance) {\n  if (compareArrays(iop, orientations[0], tolerance)) {\n    return pixelData2D;\n  } else if (compareArrays(iop, orientations[1], tolerance)) {\n    // Flipped vertically.\n\n    // Undo Flip\n    return flipMatrix2D.v(pixelData2D);\n  } else if (compareArrays(iop, orientations[2], tolerance)) {\n    // Flipped horizontally.\n\n    // Unfo flip\n    return flipMatrix2D.h(pixelData2D);\n  } else if (compareArrays(iop, orientations[3], tolerance)) {\n    //Rotated 90 degrees\n\n    // Rotate back\n    return rotateMatrix902D(pixelData2D);\n  } else if (compareArrays(iop, orientations[4], tolerance)) {\n    //Rotated 90 degrees and fliped horizontally.\n\n    // Undo flip and rotate back.\n    return rotateMatrix902D(flipMatrix2D.h(pixelData2D));\n  } else if (compareArrays(iop, orientations[5], tolerance)) {\n    // Rotated 90 degrees and fliped vertically\n\n    // Unfo flip and rotate back.\n    return rotateMatrix902D(flipMatrix2D.v(pixelData2D));\n  } else if (compareArrays(iop, orientations[6], tolerance)) {\n    // Rotated 180 degrees. // TODO -> Do this more effeciently, there is a 1:1 mapping like 90 degree rotation.\n\n    return rotateMatrix902D(rotateMatrix902D(pixelData2D));\n  } else if (compareArrays(iop, orientations[7], tolerance)) {\n    // Rotated 270 degrees\n\n    // Rotate back.\n    return rotateMatrix902D(rotateMatrix902D(rotateMatrix902D(pixelData2D)));\n  }\n}\nfunction getSegmentMetadata(multiframe, seriesInstanceUid) {\n  const segmentSequence = multiframe.SegmentSequence;\n  let data = [];\n  if (Array.isArray(segmentSequence)) {\n    data = [undefined, ...segmentSequence];\n  } else {\n    // Only one segment, will be stored as an object.\n    data = [undefined, segmentSequence];\n  }\n  return {\n    seriesInstanceUid,\n    data\n  };\n}\n\n/**\n * Reads a range of bytes from an array of ArrayBuffer chunks and\n * aggregate them into a new Uint8Array.\n *\n * @param {ArrayBuffer[]} chunks - An array of ArrayBuffer chunks.\n * @param {number} offset - The offset of the first byte to read.\n * @param {number} length - The number of bytes to read.\n * @returns {Uint8Array} A new Uint8Array containing the requested bytes.\n */\nfunction readFromUnpackedChunks(chunks, offset, length) {\n  const mapping = getUnpackedOffsetAndLength(chunks, offset, length);\n\n  // If all the data is in one chunk, we can just slice that chunk\n  if (mapping.start.chunkIndex === mapping.end.chunkIndex) {\n    return new Uint8Array(chunks[mapping.start.chunkIndex].buffer, mapping.start.offset, length);\n  } else {\n    // If the data spans multiple chunks, we need to create a new Uint8Array and copy the data from each chunk\n    let result = new Uint8Array(length);\n    let resultOffset = 0;\n    for (let i = mapping.start.chunkIndex; i <= mapping.end.chunkIndex; i++) {\n      let start = i === mapping.start.chunkIndex ? mapping.start.offset : 0;\n      let end = i === mapping.end.chunkIndex ? mapping.end.offset : chunks[i].length;\n      result.set(new Uint8Array(chunks[i].buffer, start, end - start), resultOffset);\n      resultOffset += end - start;\n    }\n    return result;\n  }\n}\nfunction getUnpackedOffsetAndLength(chunks, offset, length) {\n  var totalBytes = chunks.reduce((total, chunk) => total + chunk.length, 0);\n  if (offset < 0 || offset + length > totalBytes) {\n    throw new Error(\"Offset and length out of bounds\");\n  }\n  var startChunkIndex = 0;\n  var startOffsetInChunk = offset;\n  while (startOffsetInChunk >= chunks[startChunkIndex].length) {\n    startOffsetInChunk -= chunks[startChunkIndex].length;\n    startChunkIndex++;\n  }\n  var endChunkIndex = startChunkIndex;\n  var endOffsetInChunk = startOffsetInChunk + length;\n  while (endOffsetInChunk > chunks[endChunkIndex].length) {\n    endOffsetInChunk -= chunks[endChunkIndex].length;\n    endChunkIndex++;\n  }\n  return {\n    start: {\n      chunkIndex: startChunkIndex,\n      offset: startOffsetInChunk\n    },\n    end: {\n      chunkIndex: endChunkIndex,\n      offset: endOffsetInChunk\n    }\n  };\n}\nfunction calculateCentroid(imageIdIndexBufferIndex, multiframe, metadataProvider, imageIds) {\n  let xAcc = 0;\n  let yAcc = 0;\n  let zAcc = 0;\n  let worldXAcc = 0;\n  let worldYAcc = 0;\n  let worldZAcc = 0;\n  let count = 0;\n  for (const [imageIdIndex, bufferIndices] of Object.entries(imageIdIndexBufferIndex)) {\n    const z = Number(imageIdIndex);\n    if (!bufferIndices || bufferIndices.length === 0) {\n      continue;\n    }\n\n    // Get metadata for this slice\n    const imageId = imageIds[z];\n    const imagePlaneModule = metadataProvider.get(\"imagePlaneModule\", imageId);\n    if (!imagePlaneModule) {\n      console.debug(\"Missing imagePlaneModule metadata for centroid calculation\");\n      continue;\n    }\n    const {\n      imagePositionPatient,\n      rowCosines,\n      columnCosines,\n      rowPixelSpacing,\n      columnPixelSpacing\n    } = imagePlaneModule;\n    for (const bufferIndex of bufferIndices) {\n      const y = Math.floor(bufferIndex / multiframe.Rows);\n      const x = bufferIndex % multiframe.Rows;\n\n      // Image coordinates\n      xAcc += x;\n      yAcc += y;\n      zAcc += z;\n\n      // Calculate world coordinates\n      // P(world) = P(image) * IOP * spacing + IPP\n      const worldX = imagePositionPatient[0] + x * rowCosines[0] * columnPixelSpacing + y * columnCosines[0] * rowPixelSpacing;\n      const worldY = imagePositionPatient[1] + x * rowCosines[1] * columnPixelSpacing + y * columnCosines[1] * rowPixelSpacing;\n      const worldZ = imagePositionPatient[2] + x * rowCosines[2] * columnPixelSpacing + y * columnCosines[2] * rowPixelSpacing;\n      worldXAcc += worldX;\n      worldYAcc += worldY;\n      worldZAcc += worldZ;\n      count++;\n    }\n  }\n  return {\n    image: {\n      x: Math.floor(xAcc / count),\n      y: Math.floor(yAcc / count),\n      z: Math.floor(zAcc / count)\n    },\n    world: {\n      x: worldXAcc / count,\n      y: worldYAcc / count,\n      z: worldZAcc / count\n    },\n    count\n  };\n}\nconst Segmentation = {\n  generateSegmentation,\n  generateToolState,\n  fillSegmentation\n};\n\nexport { _createSegFromImages, _getLabelmapsFromReferencedFrameIndicies, alignPixelDataWithSourceData, calculateCentroid, checkSEGsOverlapping, Segmentation as default, fillSegmentation, findReferenceSourceImageId, generateSegmentation, generateToolState, getImageIdOfSourceImageBySourceImageSequence, getImageIdOfSourceImagebyGeometry, getSegmentIndex, getSegmentMetadata, getUnpackedChunks, getUnpackedOffsetAndLength, getValidOrientations, insertOverlappingPixelDataPlanar, insertPixelDataPlanar, readFromUnpackedChunks, unpackPixelData };\n","import Segmentation$1 from './Segmentation_3X.js';\nimport Segmentation from './Segmentation_4X.js';\n\n/**\n * generateSegmentation - Generates a DICOM Segmentation object given cornerstoneTools data.\n *\n * @param  {object[]} images    An array of the cornerstone image objects.\n * @param  {Object|Object[]} labelmaps3DorBrushData For 4.X: The cornerstone `Labelmap3D` object, or an array of objects.\n *                                                  For 3.X: the BrushData.\n * @param  {number} cornerstoneToolsVersion The cornerstoneTools major version to map against.\n * @returns {Object}\n */\nfunction generateSegmentation(images, labelmaps3DorBrushData) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {\n    includeSliceSpacing: true\n  };\n  let cornerstoneToolsVersion = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 4;\n  if (cornerstoneToolsVersion === 4) {\n    return Segmentation.generateSegmentation(images, labelmaps3DorBrushData, options);\n  }\n  if (cornerstoneToolsVersion === 3) {\n    return Segmentation$1.generateSegmentation(images, labelmaps3DorBrushData, options);\n  }\n  console.warn(`No generateSegmentation adapter for cornerstone version ${cornerstoneToolsVersion}, exiting.`);\n}\n\n/**\n * generateToolState - Given a set of cornerstoneTools imageIds and a Segmentation buffer,\n * derive cornerstoneTools toolState and brush metadata.\n *\n * @param  {string[]} imageIds    An array of the imageIds.\n * @param  {ArrayBuffer} arrayBuffer The SEG arrayBuffer.\n * @param {*} metadataProvider\n * @param  {boolean} skipOverlapping - skip checks for overlapping segs, default value false.\n * @param  {number} tolerance - default value 1.e-3.\n * @param  {number} cornerstoneToolsVersion - default value 4.\n *\n * @returns {Object}  The toolState and an object from which the\n *                    segment metadata can be derived.\n */\nfunction generateToolState(imageIds, arrayBuffer, metadataProvider) {\n  let skipOverlapping = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  let tolerance = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1e-3;\n  let cornerstoneToolsVersion = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 4;\n  if (cornerstoneToolsVersion === 4) {\n    return Segmentation.generateToolState(imageIds, arrayBuffer, metadataProvider, skipOverlapping, tolerance);\n  }\n  if (cornerstoneToolsVersion === 3) {\n    return Segmentation$1.generateToolState(imageIds, arrayBuffer, metadataProvider);\n  }\n  console.warn(`No generateToolState adapter for cornerstone version ${cornerstoneToolsVersion}, exiting.`);\n}\n\n/**\n * fillSegmentation - Fills a derived segmentation dataset with cornerstoneTools `LabelMap3D` data.\n *\n * @param  {object[]} segmentation An empty segmentation derived dataset.\n * @param  {Object|Object[]} inputLabelmaps3D The cornerstone `Labelmap3D` object, or an array of objects.\n * @param  {Object} userOptions Options object to override default options.\n * @returns {Blob}           description\n */\nfunction fillSegmentation(segmentation, inputLabelmaps3D) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {\n    includeSliceSpacing: true\n  };\n  let cornerstoneToolsVersion = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 4;\n  if (cornerstoneToolsVersion === 4) {\n    return Segmentation.fillSegmentation(segmentation, inputLabelmaps3D, options);\n  }\n  console.warn(`No generateSegmentation adapter for cornerstone version ${cornerstoneToolsVersion}, exiting.`);\n}\n\nexport { fillSegmentation, generateSegmentation, generateToolState };\n","import { log, data, normalizers } from 'dcmjs';\nimport checkOrientation from '../helpers/checkOrientation.js';\nimport compareArrays from '../helpers/compareArrays.js';\n\nconst {\n  DicomMessage,\n  DicomMetaDictionary\n} = data;\nconst {\n  Normalizer\n} = normalizers;\nasync function generateToolState(imageIds, arrayBuffer, metadataProvider) {\n  let tolerance = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1e-3;\n  const dicomData = DicomMessage.readFile(arrayBuffer);\n  const dataset = DicomMetaDictionary.naturalizeDataset(dicomData.dict);\n  dataset._meta = DicomMetaDictionary.namifyDataset(dicomData.meta);\n  const multiframe = Normalizer.normalizeToDataset([dataset]);\n  const imagePlaneModule = metadataProvider.get(\"imagePlaneModule\", imageIds[0]);\n  if (!imagePlaneModule) {\n    console.warn(\"Insufficient metadata, imagePlaneModule missing.\");\n  }\n  const ImageOrientationPatient = Array.isArray(imagePlaneModule.rowCosines) ? [...imagePlaneModule.rowCosines, ...imagePlaneModule.columnCosines] : [imagePlaneModule.rowCosines.x, imagePlaneModule.rowCosines.y, imagePlaneModule.rowCosines.z, imagePlaneModule.columnCosines.x, imagePlaneModule.columnCosines.y, imagePlaneModule.columnCosines.z];\n  const validOrientations = [ImageOrientationPatient];\n  const pixelData = getPixelData(multiframe);\n  const orientation = checkOrientation(multiframe, validOrientations, [imagePlaneModule.rows, imagePlaneModule.columns, imageIds.length], tolerance);\n  const sopUIDImageIdIndexMap = imageIds.reduce((acc, imageId) => {\n    const {\n      sopInstanceUID\n    } = metadataProvider.get(\"generalImageModule\", imageId);\n    acc[sopInstanceUID] = imageId;\n    return acc;\n  }, {});\n  if (orientation !== \"Planar\") {\n    const orientationText = {\n      Perpendicular: \"orthogonal\",\n      Oblique: \"oblique\"\n    };\n    throw new Error(`Parametric maps ${orientationText[orientation]} to the acquisition plane of the source data are not yet supported.`);\n  }\n  const imageIdMaps = imageIds.reduce((acc, curr, index) => {\n    acc.indices[curr] = index;\n    acc.metadata[curr] = metadataProvider.get(\"instance\", curr);\n    return acc;\n  }, {\n    indices: {},\n    metadata: {}\n  });\n  await insertPixelDataPlanar(pixelData, multiframe, imageIds, metadataProvider, tolerance, sopUIDImageIdIndexMap, imageIdMaps);\n  return {\n    pixelData\n  };\n}\nfunction insertPixelDataPlanar(sourcePixelData, multiframe, imageIds, metadataProvider, tolerance, sopUIDImageIdIndexMap, imageIdMaps) {\n  const targetPixelData = new sourcePixelData.constructor(sourcePixelData.length);\n  const {\n    PerFrameFunctionalGroupsSequence,\n    Rows,\n    Columns\n  } = multiframe;\n  const sliceLength = Columns * Rows;\n  const numSlices = PerFrameFunctionalGroupsSequence.length;\n  for (let i = 0; i < numSlices; i++) {\n    const sourceSliceDataView = new sourcePixelData.constructor(sourcePixelData.buffer, i * sliceLength, sliceLength);\n    const imageId = findReferenceSourceImageId(multiframe, i, imageIds, metadataProvider, tolerance, sopUIDImageIdIndexMap);\n    if (!imageId) {\n      console.warn(\"Image not present in stack, can't import frame : \" + i + \".\");\n      continue;\n    }\n    const sourceImageMetadata = imageIdMaps.metadata[imageId];\n    if (Rows !== sourceImageMetadata.Rows || Columns !== sourceImageMetadata.Columns) {\n      throw new Error(\"Parametric map have different geometry dimensions (Rows and Columns) \" + \"respect to the source image reference frame. This is not yet supported.\");\n    }\n    const imageIdIndex = imageIdMaps.indices[imageId];\n    const byteOffset = sliceLength * imageIdIndex * targetPixelData.BYTES_PER_ELEMENT;\n    const targetSliceDataView = new targetPixelData.constructor(targetPixelData.buffer, byteOffset, sliceLength);\n    targetSliceDataView.set(sourceSliceDataView);\n  }\n  return targetPixelData;\n}\nfunction getPixelData(multiframe) {\n  let TypedArrayClass;\n  let data;\n  if (multiframe.PixelData) {\n    const validTypedArrays = multiframe.BitsAllocated === 16 ? [Uint16Array, Int16Array] : [Uint32Array, Int32Array];\n    TypedArrayClass = validTypedArrays[multiframe.PixelRepresentation ?? 0];\n    data = multiframe.PixelData;\n  } else if (multiframe.FloatPixelData) {\n    TypedArrayClass = Float32Array;\n    data = multiframe.FloatPixelData;\n  } else if (multiframe.DoubleFloatPixelData) {\n    TypedArrayClass = Float64Array;\n    data = multiframe.DoubleFloatPixelData;\n  }\n  if (data === undefined) {\n    log.error(\"This parametric map pixel data is undefined.\");\n  }\n  if (Array.isArray(data)) {\n    data = data[0];\n  }\n  return new TypedArrayClass(data);\n}\nfunction findReferenceSourceImageId(multiframe, frameSegment, imageIds, metadataProvider, tolerance, sopUIDImageIdIndexMap) {\n  let imageId = undefined;\n  if (!multiframe) {\n    return imageId;\n  }\n  const {\n    FrameOfReferenceUID,\n    PerFrameFunctionalGroupsSequence,\n    SourceImageSequence,\n    ReferencedSeriesSequence\n  } = multiframe;\n  if (!PerFrameFunctionalGroupsSequence || PerFrameFunctionalGroupsSequence.length === 0) {\n    return imageId;\n  }\n  const PerFrameFunctionalGroup = PerFrameFunctionalGroupsSequence[frameSegment];\n  if (!PerFrameFunctionalGroup) {\n    return imageId;\n  }\n  let frameSourceImageSequence = undefined;\n  if (PerFrameFunctionalGroup.DerivationImageSequence) {\n    let DerivationImageSequence = PerFrameFunctionalGroup.DerivationImageSequence;\n    if (Array.isArray(DerivationImageSequence)) {\n      if (DerivationImageSequence.length !== 0) {\n        DerivationImageSequence = DerivationImageSequence[0];\n      } else {\n        DerivationImageSequence = undefined;\n      }\n    }\n    if (DerivationImageSequence) {\n      frameSourceImageSequence = DerivationImageSequence.SourceImageSequence;\n      if (Array.isArray(frameSourceImageSequence)) {\n        if (frameSourceImageSequence.length !== 0) {\n          frameSourceImageSequence = frameSourceImageSequence[0];\n        } else {\n          frameSourceImageSequence = undefined;\n        }\n      }\n    }\n  } else if (SourceImageSequence && SourceImageSequence.length !== 0) {\n    console.warn(\"DerivationImageSequence not present, using SourceImageSequence assuming SEG has the same geometry as the source image.\");\n    frameSourceImageSequence = SourceImageSequence[frameSegment];\n  }\n  if (frameSourceImageSequence) {\n    imageId = getImageIdOfSourceImageBySourceImageSequence(frameSourceImageSequence, sopUIDImageIdIndexMap);\n  }\n  if (imageId === undefined && ReferencedSeriesSequence) {\n    const referencedSeriesSequence = Array.isArray(ReferencedSeriesSequence) ? ReferencedSeriesSequence[0] : ReferencedSeriesSequence;\n    const ReferencedSeriesInstanceUID = referencedSeriesSequence.SeriesInstanceUID;\n    imageId = getImageIdOfSourceImagebyGeometry(ReferencedSeriesInstanceUID, FrameOfReferenceUID, PerFrameFunctionalGroup, imageIds, metadataProvider, tolerance);\n  }\n  return imageId;\n}\nfunction getImageIdOfSourceImageBySourceImageSequence(SourceImageSequence, sopUIDImageIdIndexMap) {\n  const {\n    ReferencedSOPInstanceUID,\n    ReferencedFrameNumber\n  } = SourceImageSequence;\n  return ReferencedFrameNumber ? getImageIdOfReferencedFrame(ReferencedSOPInstanceUID, ReferencedFrameNumber, sopUIDImageIdIndexMap) : sopUIDImageIdIndexMap[ReferencedSOPInstanceUID];\n}\nfunction getImageIdOfSourceImagebyGeometry(ReferencedSeriesInstanceUID, FrameOfReferenceUID, PerFrameFunctionalGroup, imageIds, metadataProvider, tolerance) {\n  if (ReferencedSeriesInstanceUID === undefined || PerFrameFunctionalGroup.PlanePositionSequence === undefined || PerFrameFunctionalGroup.PlanePositionSequence[0] === undefined || PerFrameFunctionalGroup.PlanePositionSequence[0].ImagePositionPatient === undefined) {\n    return undefined;\n  }\n  for (let imageIdsIndex = 0; imageIdsIndex < imageIds.length; ++imageIdsIndex) {\n    const sourceImageMetadata = metadataProvider.get(\"instance\", imageIds[imageIdsIndex]);\n    if (sourceImageMetadata === undefined || sourceImageMetadata.ImagePositionPatient === undefined || sourceImageMetadata.FrameOfReferenceUID !== FrameOfReferenceUID || sourceImageMetadata.SeriesInstanceUID !== ReferencedSeriesInstanceUID) {\n      continue;\n    }\n    if (compareArrays(PerFrameFunctionalGroup.PlanePositionSequence[0].ImagePositionPatient, sourceImageMetadata.ImagePositionPatient, tolerance)) {\n      return imageIds[imageIdsIndex];\n    }\n  }\n}\nfunction getImageIdOfReferencedFrame(sopInstanceUid, frameNumber, sopUIDImageIdIndexMap) {\n  const imageId = sopUIDImageIdIndexMap[sopInstanceUid];\n  if (!imageId) {\n    return;\n  }\n  const imageIdFrameNumber = Number(imageId.split(\"frame=\")[1]);\n  return imageIdFrameNumber === frameNumber - 1 ? imageId : undefined;\n}\nconst ParametricMapObj = {\n  generateToolState\n};\n\nexport { ParametricMapObj as ParametricMap, ParametricMapObj as default };\n","import MeasurementReport from './MeasurementReport.js';\nimport Length from './Length.js';\nimport FreehandRoi from './FreehandRoi.js';\nimport Bidirectional from './Bidirectional.js';\nimport EllipticalRoi from './EllipticalRoi.js';\nimport CircleRoi from './CircleRoi.js';\nimport ArrowAnnotate from './ArrowAnnotate.js';\nimport CobbAngle from './CobbAngle.js';\nimport Angle from './Angle.js';\nimport RectangleRoi from './RectangleRoi.js';\nimport * as Segmentation from './Segmentation.js';\nimport ParametricMapObj from './ParametricMap.js';\n\nconst CornerstoneSR = {\n  Length,\n  FreehandRoi,\n  Bidirectional,\n  EllipticalRoi,\n  CircleRoi,\n  ArrowAnnotate,\n  MeasurementReport,\n  CobbAngle,\n  Angle,\n  RectangleRoi\n};\nconst CornerstoneSEG = {\n  Segmentation\n};\nconst CornerstonePMAP = {\n  ParametricMap: ParametricMapObj\n};\n\nexport { CornerstonePMAP, CornerstoneSEG, CornerstoneSR };\n","var CORNERSTONE_3D_TAG = \"Cornerstone3DTools@^0.1.0\";\n\nexport { CORNERSTONE_3D_TAG as default };\n","const patientTags = [\"PatientName\", \"PatientID\", \"PatientBirthDate\", \"PatientBirthTime\", \"PatientID\", \"IssuerOfPatientID\", \"OtherPatientIDs\", \"OtherPatientIDsSequence\", \"PatientSex\", \"PatientIdentityRemoved\", \"DeidentificationMethodCodeSequence\"];\nconst studyTags = [\"StudyDate\", \"StudyTime\", \"StudyStatusID\", \"StudyPriorityID\", \"StudyInstanceUID\", \"StudyDescription\", \"AccessionNumber\", \"StudyID\", \"ReferringPhysicianName\", \"BodyPartExamined\", \"TimezoneOffsetFromUTC\"];\nconst patientStudyTags = [...patientTags, ...studyTags];\nfunction copyStudyTags(src) {\n  const study = {\n    _meta: src._meta,\n    _vrMap: src._vrMap\n  };\n  for (const tagKey of patientStudyTags) {\n    const value = src[tagKey];\n    if (value === undefined) {\n      continue;\n    }\n    study[tagKey] = value;\n  }\n  return study;\n}\n\nexport { copyStudyTags, patientStudyTags, patientTags, studyTags };\n","// This is a custom coding scheme defined to store some annotations from Cornerstone.\n// Note: CodeMeaning is VR type LO, which means we only actually support 64 characters\n// here this is fine for most labels, but may be problematic at some point.\nconst CORNERSTONEFREETEXT = \"CORNERSTONEFREETEXT\";\n\n// Cornerstone specified coding scheme for storing findings\nconst CodingSchemeDesignator = \"CORNERSTONEJS\";\nconst CodingScheme = {\n  CodingSchemeDesignator,\n  codeValues: {\n    CORNERSTONEFREETEXT\n  }\n};\n\nexport { CodingScheme as default };\n","import { utilities, derivations, normalizers, data } from 'dcmjs';\nimport CORNERSTONE_3D_TAG from './cornerstone3DTag.js';\nimport { toArray } from '../helpers/toArray.js';\nimport { codeMeaningEquals } from '../helpers/codeMeaningEquals.js';\nimport 'buffer';\nimport { copyStudyTags } from '../helpers/copyStudyTags.js';\nimport CodingScheme from './CodingScheme.js';\n\nvar _MeasurementReport;\nconst {\n  TID1500,\n  addAccessors\n} = utilities;\nconst {\n  StructuredReport\n} = derivations;\nconst {\n  Normalizer\n} = normalizers;\nconst {\n  TID1500MeasurementReport,\n  TID1501MeasurementGroup\n} = TID1500;\nconst {\n  DicomMetaDictionary\n} = data;\nconst FINDING = {\n  CodingSchemeDesignator: \"DCM\",\n  CodeValue: \"121071\"\n};\nconst FINDING_SITE = {\n  CodingSchemeDesignator: \"SCT\",\n  CodeValue: \"363698007\"\n};\nconst FINDING_SITE_OLD = {\n  CodingSchemeDesignator: \"SRT\",\n  CodeValue: \"G-C0E3\"\n};\nclass MeasurementReport {\n  static getTID300ContentItem(tool, ReferencedSOPSequence, toolClass, worldToImageCoords) {\n    const args = toolClass.getTID300RepresentationArguments(tool, worldToImageCoords);\n    args.ReferencedSOPSequence = ReferencedSOPSequence;\n    const TID300Measurement = new toolClass.TID300Representation(args);\n    return TID300Measurement;\n  }\n  static getMeasurementGroup(toolType, toolData, ReferencedSOPSequence, worldToImageCoords) {\n    const toolTypeData = toolData[toolType];\n    const toolClass = this.measurementAdapterByToolType.get(toolType);\n    if (!toolTypeData || !toolTypeData.data || !toolTypeData.data.length || !toolClass) {\n      return;\n    }\n    const Measurements = toolTypeData.data.map(tool => {\n      return this.getTID300ContentItem(tool, ReferencedSOPSequence, toolClass, worldToImageCoords);\n    });\n    return new TID1501MeasurementGroup(Measurements);\n  }\n  static getCornerstoneLabelFromDefaultState(defaultState) {\n    const {\n      findingSites = [],\n      finding\n    } = defaultState;\n    const cornersoneFreeTextCodingValue = CodingScheme.codeValues.CORNERSTONEFREETEXT;\n    const freeTextLabel = findingSites.find(fs => fs.CodeValue === cornersoneFreeTextCodingValue);\n    if (freeTextLabel) {\n      return freeTextLabel.CodeMeaning;\n    }\n    if (finding && finding.CodeValue === cornersoneFreeTextCodingValue) {\n      return finding.CodeMeaning;\n    }\n  }\n  static generateDatasetMeta() {\n    const fileMetaInformationVersionArray = new Uint8Array(2);\n    fileMetaInformationVersionArray[1] = 1;\n    const _meta = {\n      FileMetaInformationVersion: {\n        Value: [fileMetaInformationVersionArray.buffer],\n        vr: \"OB\"\n      },\n      TransferSyntaxUID: {\n        Value: [\"1.2.840.10008.1.2.1\"],\n        vr: \"UI\"\n      },\n      ImplementationClassUID: {\n        Value: [DicomMetaDictionary.uid()],\n        vr: \"UI\"\n      },\n      ImplementationVersionName: {\n        Value: [\"dcmjs\"],\n        vr: \"SH\"\n      }\n    };\n    return _meta;\n  }\n  static getSetupMeasurementData(MeasurementGroup, sopInstanceUIDToImageIdMap, metadata, toolType) {\n    const {\n      ContentSequence\n    } = MeasurementGroup;\n    const contentSequenceArr = toArray(ContentSequence);\n    const findingGroup = contentSequenceArr.find(group => this.codeValueMatch(group, FINDING));\n    const findingSiteGroups = contentSequenceArr.filter(group => this.codeValueMatch(group, FINDING_SITE, FINDING_SITE_OLD)) || [];\n    const NUMGroup = contentSequenceArr.find(group => group.ValueType === \"NUM\");\n    const SCOORDGroup = toArray(NUMGroup.ContentSequence).find(group => group.ValueType === \"SCOORD\");\n    const {\n      ReferencedSOPSequence\n    } = SCOORDGroup.ContentSequence;\n    const {\n      ReferencedSOPInstanceUID,\n      ReferencedFrameNumber\n    } = ReferencedSOPSequence;\n    const referencedImageId = sopInstanceUIDToImageIdMap[ReferencedSOPInstanceUID];\n    const imagePlaneModule = metadata.get(\"imagePlaneModule\", referencedImageId);\n    const finding = findingGroup ? addAccessors(findingGroup.ConceptCodeSequence) : undefined;\n    const findingSites = findingSiteGroups.map(fsg => {\n      return addAccessors(fsg.ConceptCodeSequence);\n    });\n    const defaultState = {\n      description: undefined,\n      sopInstanceUid: ReferencedSOPInstanceUID,\n      annotation: {\n        annotationUID: DicomMetaDictionary.uid(),\n        metadata: {\n          toolName: toolType,\n          referencedImageId,\n          FrameOfReferenceUID: imagePlaneModule.frameOfReferenceUID,\n          label: \"\"\n        },\n        data: undefined\n      },\n      finding,\n      findingSites\n    };\n    if (defaultState.finding) {\n      defaultState.description = defaultState.finding.CodeMeaning;\n    }\n    defaultState.annotation.metadata.label = MeasurementReport.getCornerstoneLabelFromDefaultState(defaultState);\n    return {\n      defaultState,\n      NUMGroup,\n      SCOORDGroup,\n      ReferencedSOPSequence,\n      ReferencedSOPInstanceUID,\n      ReferencedFrameNumber\n    };\n  }\n  static generateReport(toolState, metadataProvider, worldToImageCoords, options) {\n    let allMeasurementGroups = [];\n    const sopInstanceUIDsToSeriesInstanceUIDMap = {};\n    const derivationSourceDatasets = [];\n    const _meta = MeasurementReport.generateDatasetMeta();\n    Object.keys(toolState).forEach(imageId => {\n      const sopCommonModule = metadataProvider.get(\"sopCommonModule\", imageId);\n      const instance = metadataProvider.get(\"instance\", imageId);\n      const {\n        sopInstanceUID,\n        sopClassUID\n      } = sopCommonModule;\n      const {\n        SeriesInstanceUID: seriesInstanceUID\n      } = instance;\n      sopInstanceUIDsToSeriesInstanceUIDMap[sopInstanceUID] = seriesInstanceUID;\n      if (!derivationSourceDatasets.find(dsd => dsd.SeriesInstanceUID === seriesInstanceUID)) {\n        const derivationSourceDataset = MeasurementReport.generateDerivationSourceDataset(instance);\n        derivationSourceDatasets.push(derivationSourceDataset);\n      }\n      const frameNumber = metadataProvider.get(\"frameNumber\", imageId);\n      const toolData = toolState[imageId];\n      const toolTypes = Object.keys(toolData);\n      const ReferencedSOPSequence = {\n        ReferencedSOPClassUID: sopClassUID,\n        ReferencedSOPInstanceUID: sopInstanceUID,\n        ReferencedFrameNumber: undefined\n      };\n      if (instance && instance.NumberOfFrames && instance.NumberOfFrames > 1 || Normalizer.isMultiframeSOPClassUID(sopClassUID)) {\n        ReferencedSOPSequence.ReferencedFrameNumber = frameNumber;\n      }\n      const measurementGroups = [];\n      toolTypes.forEach(toolType => {\n        const group = this.getMeasurementGroup(toolType, toolData, ReferencedSOPSequence, worldToImageCoords);\n        if (group) {\n          measurementGroups.push(group);\n        }\n      });\n      allMeasurementGroups = allMeasurementGroups.concat(measurementGroups);\n    });\n    const tid1500MeasurementReport = new TID1500MeasurementReport({\n      TID1501MeasurementGroups: allMeasurementGroups\n    }, options);\n    const report = new StructuredReport(derivationSourceDatasets, options);\n    const contentItem = tid1500MeasurementReport.contentItem(derivationSourceDatasets, {\n      ...options,\n      sopInstanceUIDsToSeriesInstanceUIDMap\n    });\n    report.dataset = Object.assign(report.dataset, contentItem);\n    report.dataset._meta = _meta;\n    report.SpecificCharacterSet = \"ISO_IR 192\";\n    return report;\n  }\n  static generateToolState(dataset, sopInstanceUIDToImageIdMap, imageToWorldCoords, metadata, hooks) {\n    if (dataset.ContentTemplateSequence.TemplateIdentifier !== \"1500\") {\n      throw new Error(\"This package can currently only interpret DICOM SR TID 1500\");\n    }\n    const REPORT = \"Imaging Measurements\";\n    const GROUP = \"Measurement Group\";\n    const TRACKING_IDENTIFIER = \"Tracking Identifier\";\n    const TRACKING_UNIQUE_IDENTIFIER = \"Tracking Unique Identifier\";\n    const imagingMeasurementContent = toArray(dataset.ContentSequence).find(codeMeaningEquals(REPORT));\n    const measurementGroups = toArray(imagingMeasurementContent.ContentSequence).filter(codeMeaningEquals(GROUP));\n    const measurementData = {};\n    measurementGroups.forEach(measurementGroup => {\n      try {\n        const measurementGroupContentSequence = toArray(measurementGroup.ContentSequence);\n        const trackingIdentifierGroup = measurementGroupContentSequence.find(contentItem => contentItem.ConceptNameCodeSequence.CodeMeaning === TRACKING_IDENTIFIER);\n        const {\n          TextValue: trackingIdentifierValue\n        } = trackingIdentifierGroup;\n        const trackingUniqueIdentifierGroup = measurementGroupContentSequence.find(contentItem => contentItem.ConceptNameCodeSequence.CodeMeaning === TRACKING_UNIQUE_IDENTIFIER);\n        const trackingUniqueIdentifierValue = trackingUniqueIdentifierGroup?.UID;\n        const toolAdapter = hooks?.getToolClass?.(measurementGroup, dataset, this.measurementAdapterByToolType) || this.getAdapterForTrackingIdentifier(trackingIdentifierValue);\n        if (toolAdapter) {\n          const measurement = toolAdapter.getMeasurementData(measurementGroup, sopInstanceUIDToImageIdMap, imageToWorldCoords, metadata, trackingIdentifierValue);\n          measurement.TrackingUniqueIdentifier = trackingUniqueIdentifierValue;\n          console.log(`=== ${toolAdapter.toolType} ===`);\n          console.log(measurement);\n          measurementData[toolAdapter.toolType] ||= [];\n          measurementData[toolAdapter.toolType].push(measurement);\n        }\n      } catch (e) {\n        console.warn(\"Unable to generate tool state for\", measurementGroup, e);\n      }\n    });\n    return measurementData;\n  }\n  static registerTool(toolAdapter) {\n    let replace = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    const registerName = toolAdapter.toolType;\n    if (this.measurementAdapterByToolType.has(registerName)) {\n      if (!replace) {\n        throw new Error(`The registered tool name ${registerName} already exists in adapters, use a different toolType or use replace`);\n      }\n      if (typeof replace === \"function\") {\n        replace(this.measurementAdapterByToolType.get(registerName));\n      }\n    }\n    this.measurementAdapterByToolType.set(toolAdapter.toolType, toolAdapter);\n    this.measurementAdapterByTrackingIdentifier.set(toolAdapter.trackingIdentifierTextValue, toolAdapter);\n  }\n  static registerTrackingIdentifier(toolClass) {\n    for (var _len = arguments.length, trackingIdentifiers = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      trackingIdentifiers[_key - 1] = arguments[_key];\n    }\n    for (const identifier of trackingIdentifiers) {\n      this.measurementAdapterByTrackingIdentifier.set(identifier, toolClass);\n    }\n  }\n  static getAdapterForTrackingIdentifier(trackingIdentifier) {\n    const adapter = this.measurementAdapterByTrackingIdentifier.get(trackingIdentifier);\n    if (adapter) {\n      return adapter;\n    }\n    for (const adapterTest of [...this.measurementAdapterByToolType.values()]) {\n      if (adapterTest.isValidCornerstoneTrackingIdentifier(trackingIdentifier)) {\n        this.measurementAdapterByTrackingIdentifier.set(trackingIdentifier, adapterTest);\n        return adapterTest;\n      }\n    }\n  }\n}\n_MeasurementReport = MeasurementReport;\n_MeasurementReport.CORNERSTONE_3D_TAG = CORNERSTONE_3D_TAG;\n_MeasurementReport.measurementAdapterByToolType = new Map();\n_MeasurementReport.measurementAdapterByTrackingIdentifier = new Map();\n_MeasurementReport.codeValueMatch = (group, code, oldCode) => {\n  const {\n    ConceptNameCodeSequence\n  } = group;\n  if (!ConceptNameCodeSequence) {\n    return;\n  }\n  const {\n    CodingSchemeDesignator,\n    CodeValue\n  } = ConceptNameCodeSequence;\n  return CodingSchemeDesignator == code.CodingSchemeDesignator && CodeValue == code.CodeValue || oldCode && CodingSchemeDesignator == oldCode.CodingSchemeDesignator && CodeValue == oldCode.CodeValue;\n};\n_MeasurementReport.generateDerivationSourceDataset = instance => {\n  _MeasurementReport.generateDatasetMeta();\n  const derivationSourceDataset = copyStudyTags(instance);\n  return derivationSourceDataset;\n};\n\nexport { MeasurementReport as default };\n","import CORNERSTONE_3D_TAG from './cornerstone3DTag.js';\nimport MeasurementReport from './MeasurementReport.js';\n\nclass BaseAdapter3D {\n  static init(toolType, representation, options) {\n    this.toolType = toolType;\n    if (BaseAdapter3D.toolType) {\n      throw new Error(`Base adapter tool type set to ${this.toolType} while setting ${toolType}`);\n    }\n    this.parentType = options?.parentType;\n    this.trackingIdentifiers = new Set();\n    this.TID300Representation = representation;\n    if (this.parentType) {\n      this.trackingIdentifierTextValue = `${CORNERSTONE_3D_TAG}:${this.parentType}:${this.toolType}`;\n      const alternateTrackingIdentifier = `${CORNERSTONE_3D_TAG}:${this.toolType}`;\n      this.trackingIdentifiers.add(alternateTrackingIdentifier);\n    } else {\n      this.trackingIdentifierTextValue = `${CORNERSTONE_3D_TAG}:${toolType}`;\n    }\n    this.trackingIdentifiers.add(this.trackingIdentifierTextValue);\n    MeasurementReport.registerTool(this);\n  }\n  static registerLegacy() {\n    this.trackingIdentifiers.add(`cornerstoneTools@^4.0.0:${this.toolType}`);\n  }\n  static registerSubType(adapter, toolType, replace) {\n    const subAdapter = Object.create(adapter);\n    subAdapter.init(toolType, adapter.TID300Representation, {\n      parentType: adapter.parentType || adapter.toolType,\n      replace\n    });\n    return subAdapter;\n  }\n  static isValidCornerstoneTrackingIdentifier(trackingIdentifier) {\n    if (this.trackingIdentifiers.has(trackingIdentifier)) {\n      return true;\n    }\n    if (!trackingIdentifier.includes(\":\")) {\n      return false;\n    }\n    return trackingIdentifier.startsWith(this.trackingIdentifierTextValue);\n  }\n  static getMeasurementData(MeasurementGroup, sopInstanceUIDToImageIdMap, _imageToWorldCoords, metadata, trackingIdentifier) {\n    const {\n      defaultState: state,\n      ReferencedFrameNumber\n    } = MeasurementReport.getSetupMeasurementData(MeasurementGroup, sopInstanceUIDToImageIdMap, metadata, this.toolType);\n    state.annotation.data = {\n      cachedStats: {},\n      frameNumber: ReferencedFrameNumber,\n      seriesLevel: trackingIdentifier?.indexOf(\":Series\") > 0\n    };\n    return state;\n  }\n  static getTID300RepresentationArguments(tool, worldToImageCoords) {\n    const {\n      data,\n      metadata\n    } = tool;\n    const {\n      finding,\n      findingSites\n    } = tool;\n    const {\n      referencedImageId\n    } = metadata;\n    if (!referencedImageId) {\n      throw new Error(\"Probe.getTID300RepresentationArguments: referencedImageId is not defined\");\n    }\n    const {\n      handles: {\n        points = []\n      }\n    } = data;\n    const pointsImage = points.map(point => {\n      const pointImage = worldToImageCoords(referencedImageId, point);\n      return {\n        x: pointImage[0],\n        y: pointImage[1]\n      };\n    });\n    const tidArguments = {\n      points: pointsImage,\n      trackingIdentifierTextValue: this.trackingIdentifierTextValue,\n      findingSites: findingSites || [],\n      finding\n    };\n    return tidArguments;\n  }\n}\n\nexport { BaseAdapter3D as default };\n","import MeasurementReport from './MeasurementReport.js';\nimport { utilities } from 'dcmjs';\nimport BaseAdapter3D from './BaseAdapter3D.js';\nimport CodingScheme from './CodingScheme.js';\n\nvar _ArrowAnnotate;\nconst {\n  Point: TID300Point\n} = utilities.TID300;\nconst {\n  codeValues\n} = CodingScheme;\nclass ArrowAnnotate extends BaseAdapter3D {\n  static getMeasurementData(MeasurementGroup, sopInstanceUIDToImageIdMap, imageToWorldCoords, metadata, _trackingIdentifier) {\n    const {\n      defaultState,\n      SCOORDGroup,\n      ReferencedFrameNumber\n    } = MeasurementReport.getSetupMeasurementData(MeasurementGroup, sopInstanceUIDToImageIdMap, metadata, ArrowAnnotate.toolType);\n    const referencedImageId = defaultState.annotation.metadata.referencedImageId;\n    const text = defaultState.annotation.metadata.label;\n    const {\n      GraphicData\n    } = SCOORDGroup;\n    const worldCoords = [];\n    for (let i = 0; i < GraphicData.length; i += 2) {\n      const point = imageToWorldCoords(referencedImageId, [GraphicData[i], GraphicData[i + 1]]);\n      worldCoords.push(point);\n    }\n    if (worldCoords.length === 1) {\n      const imagePixelModule = metadata.get(\"imagePixelModule\", referencedImageId);\n      let xOffset = 10;\n      let yOffset = 10;\n      if (imagePixelModule) {\n        const {\n          columns,\n          rows\n        } = imagePixelModule;\n        xOffset = columns / 10;\n        yOffset = rows / 10;\n      }\n      const secondPoint = imageToWorldCoords(referencedImageId, [GraphicData[0] + xOffset, GraphicData[1] + yOffset]);\n      worldCoords.push(secondPoint);\n    }\n    const state = defaultState;\n    state.annotation.data = {\n      text,\n      handles: {\n        arrowFirst: true,\n        points: [worldCoords[0], worldCoords[1]],\n        activeHandleIndex: 0,\n        textBox: {\n          hasMoved: false\n        }\n      },\n      frameNumber: ReferencedFrameNumber\n    };\n    return state;\n  }\n  static getTID300RepresentationArguments(tool, worldToImageCoords) {\n    const {\n      data,\n      metadata,\n      findingSites\n    } = tool;\n    let {\n      finding\n    } = tool;\n    const {\n      referencedImageId\n    } = metadata;\n    if (!referencedImageId) {\n      throw new Error(\"ArrowAnnotate.getTID300RepresentationArguments: referencedImageId is not defined\");\n    }\n    const {\n      points,\n      arrowFirst\n    } = data.handles;\n    let point;\n    let point2;\n    if (arrowFirst) {\n      point = points[0];\n      point2 = points[1];\n    } else {\n      point = points[1];\n      point2 = points[0];\n    }\n    const pointImage = worldToImageCoords(referencedImageId, point);\n    const pointImage2 = worldToImageCoords(referencedImageId, point2);\n    const TID300RepresentationArguments = {\n      points: [{\n        x: pointImage[0],\n        y: pointImage[1]\n      }, {\n        x: pointImage2[0],\n        y: pointImage2[1]\n      }],\n      trackingIdentifierTextValue: this.trackingIdentifierTextValue,\n      findingSites: findingSites || [],\n      finding\n    };\n    if (!finding || finding.CodeValue !== codeValues.CORNERSTONEFREETEXT) {\n      finding = {\n        CodeValue: codeValues.CORNERSTONEFREETEXT,\n        CodingSchemeDesignator: CodingScheme.CodingSchemeDesignator,\n        CodeMeaning: data.text\n      };\n    }\n    return TID300RepresentationArguments;\n  }\n}\n_ArrowAnnotate = ArrowAnnotate;\n(() => {\n  _ArrowAnnotate.init(\"ArrowAnnotate\", TID300Point);\n  _ArrowAnnotate.registerLegacy();\n})();\n\nexport { ArrowAnnotate as default };\n","import { utilities } from 'dcmjs';\nimport MeasurementReport from './MeasurementReport.js';\nimport { toArray } from '../helpers/toArray.js';\nimport 'buffer';\nimport BaseAdapter3D from './BaseAdapter3D.js';\n\nvar _Bidirectional;\nconst {\n  Bidirectional: TID300Bidirectional\n} = utilities.TID300;\nconst LONG_AXIS = \"Long Axis\";\nconst SHORT_AXIS = \"Short Axis\";\nclass Bidirectional extends BaseAdapter3D {\n  static getMeasurementData(MeasurementGroup, sopInstanceUIDToImageIdMap, imageToWorldCoords, metadata) {\n    const {\n      defaultState,\n      ReferencedFrameNumber\n    } = MeasurementReport.getSetupMeasurementData(MeasurementGroup, sopInstanceUIDToImageIdMap, metadata, Bidirectional.toolType);\n    const referencedImageId = defaultState.annotation.metadata.referencedImageId;\n    const {\n      ContentSequence\n    } = MeasurementGroup;\n    const longAxisNUMGroup = toArray(ContentSequence).find(group => group.ConceptNameCodeSequence.CodeMeaning === LONG_AXIS);\n    const longAxisSCOORDGroup = toArray(longAxisNUMGroup.ContentSequence).find(group => group.ValueType === \"SCOORD\");\n    const shortAxisNUMGroup = toArray(ContentSequence).find(group => group.ConceptNameCodeSequence.CodeMeaning === SHORT_AXIS);\n    const shortAxisSCOORDGroup = toArray(shortAxisNUMGroup.ContentSequence).find(group => group.ValueType === \"SCOORD\");\n    const worldCoords = [];\n    [longAxisSCOORDGroup, shortAxisSCOORDGroup].forEach(group => {\n      const {\n        GraphicData\n      } = group;\n      for (let i = 0; i < GraphicData.length; i += 2) {\n        const point = imageToWorldCoords(referencedImageId, [GraphicData[i], GraphicData[i + 1]]);\n        worldCoords.push(point);\n      }\n    });\n    const state = defaultState;\n    state.annotation.data = {\n      handles: {\n        points: [worldCoords[0], worldCoords[1], worldCoords[2], worldCoords[3]],\n        activeHandleIndex: 0,\n        textBox: {\n          hasMoved: false\n        }\n      },\n      cachedStats: {\n        [`imageId:${referencedImageId}`]: {\n          length: longAxisNUMGroup.MeasuredValueSequence.NumericValue,\n          width: shortAxisNUMGroup.MeasuredValueSequence.NumericValue\n        }\n      },\n      frameNumber: ReferencedFrameNumber\n    };\n    return state;\n  }\n  static getTID300RepresentationArguments(tool, worldToImageCoords) {\n    const {\n      data,\n      finding,\n      findingSites,\n      metadata\n    } = tool;\n    const {\n      cachedStats = {},\n      handles\n    } = data;\n    const {\n      referencedImageId\n    } = metadata;\n    if (!referencedImageId) {\n      throw new Error(\"Bidirectional.getTID300RepresentationArguments: referencedImageId is not defined\");\n    }\n    const {\n      length,\n      width\n    } = cachedStats[`imageId:${referencedImageId}`] || {};\n    const {\n      points\n    } = handles;\n    const firstPointPairs = [points[0], points[1]];\n    const secondPointPairs = [points[2], points[3]];\n    const firstPointPairsDistance = Math.sqrt(Math.pow(firstPointPairs[0][0] - firstPointPairs[1][0], 2) + Math.pow(firstPointPairs[0][1] - firstPointPairs[1][1], 2) + Math.pow(firstPointPairs[0][2] - firstPointPairs[1][2], 2));\n    const secondPointPairsDistance = Math.sqrt(Math.pow(secondPointPairs[0][0] - secondPointPairs[1][0], 2) + Math.pow(secondPointPairs[0][1] - secondPointPairs[1][1], 2) + Math.pow(secondPointPairs[0][2] - secondPointPairs[1][2], 2));\n    let shortAxisPoints;\n    let longAxisPoints;\n    if (firstPointPairsDistance > secondPointPairsDistance) {\n      shortAxisPoints = firstPointPairs;\n      longAxisPoints = secondPointPairs;\n    } else {\n      shortAxisPoints = secondPointPairs;\n      longAxisPoints = firstPointPairs;\n    }\n    const longAxisStartImage = worldToImageCoords(referencedImageId, shortAxisPoints[0]);\n    const longAxisEndImage = worldToImageCoords(referencedImageId, shortAxisPoints[1]);\n    const shortAxisStartImage = worldToImageCoords(referencedImageId, longAxisPoints[0]);\n    const shortAxisEndImage = worldToImageCoords(referencedImageId, longAxisPoints[1]);\n    return {\n      longAxis: {\n        point1: {\n          x: longAxisStartImage[0],\n          y: longAxisStartImage[1]\n        },\n        point2: {\n          x: longAxisEndImage[0],\n          y: longAxisEndImage[1]\n        }\n      },\n      shortAxis: {\n        point1: {\n          x: shortAxisStartImage[0],\n          y: shortAxisStartImage[1]\n        },\n        point2: {\n          x: shortAxisEndImage[0],\n          y: shortAxisEndImage[1]\n        }\n      },\n      longAxisLength: length,\n      shortAxisLength: width,\n      trackingIdentifierTextValue: this.trackingIdentifierTextValue,\n      finding: finding,\n      findingSites: findingSites || []\n    };\n  }\n}\n_Bidirectional = Bidirectional;\n(() => {\n  _Bidirectional.init(\"Bidirectional\", TID300Bidirectional);\n  _Bidirectional.registerLegacy();\n})();\n\nexport { Bidirectional as default };\n","import { utilities } from 'dcmjs';\nimport MeasurementReport from './MeasurementReport.js';\nimport BaseAdapter3D from './BaseAdapter3D.js';\n\nvar _Angle;\nconst {\n  CobbAngle: TID300CobbAngle\n} = utilities.TID300;\nclass Angle extends BaseAdapter3D {\n  static getMeasurementData(MeasurementGroup, sopInstanceUIDToImageIdMap, imageToWorldCoords, metadata) {\n    const {\n      defaultState,\n      NUMGroup,\n      SCOORDGroup,\n      ReferencedFrameNumber\n    } = MeasurementReport.getSetupMeasurementData(MeasurementGroup, sopInstanceUIDToImageIdMap, metadata, Angle.toolType);\n    const referencedImageId = defaultState.annotation.metadata.referencedImageId;\n    const {\n      GraphicData\n    } = SCOORDGroup;\n    const worldCoords = [];\n    for (let i = 0; i < GraphicData.length; i += 2) {\n      const point = imageToWorldCoords(referencedImageId, [GraphicData[i], GraphicData[i + 1]]);\n      worldCoords.push(point);\n    }\n    const state = defaultState;\n    state.annotation.data = {\n      handles: {\n        points: [worldCoords[0], worldCoords[1], worldCoords[3]],\n        activeHandleIndex: 0,\n        textBox: {\n          hasMoved: false\n        }\n      },\n      cachedStats: {\n        [`imageId:${referencedImageId}`]: {\n          angle: NUMGroup ? NUMGroup.MeasuredValueSequence.NumericValue : null\n        }\n      },\n      frameNumber: ReferencedFrameNumber\n    };\n    return state;\n  }\n  static getTID300RepresentationArguments(tool, worldToImageCoords) {\n    const {\n      data,\n      finding,\n      findingSites,\n      metadata\n    } = tool;\n    const {\n      cachedStats = {},\n      handles\n    } = data;\n    const {\n      referencedImageId\n    } = metadata;\n    if (!referencedImageId) {\n      throw new Error(\"Angle.getTID300RepresentationArguments: referencedImageId is not defined\");\n    }\n    const start1 = worldToImageCoords(referencedImageId, handles.points[0]);\n    const middle = worldToImageCoords(referencedImageId, handles.points[1]);\n    const end = worldToImageCoords(referencedImageId, handles.points[2]);\n    const point1 = {\n      x: start1[0],\n      y: start1[1]\n    };\n    const point2 = {\n      x: middle[0],\n      y: middle[1]\n    };\n    const point3 = point2;\n    const point4 = {\n      x: end[0],\n      y: end[1]\n    };\n    const {\n      angle\n    } = cachedStats[`imageId:${referencedImageId}`] || {};\n    return {\n      point1,\n      point2,\n      point3,\n      point4,\n      rAngle: angle,\n      trackingIdentifierTextValue: this.trackingIdentifierTextValue,\n      finding,\n      findingSites: findingSites || []\n    };\n  }\n}\n_Angle = Angle;\n(() => {\n  _Angle.init(\"Angle\", TID300CobbAngle);\n  _Angle.registerLegacy();\n})();\n\nexport { Angle as default };\n","import { utilities } from 'dcmjs';\nimport MeasurementReport from './MeasurementReport.js';\nimport BaseAdapter3D from './BaseAdapter3D.js';\n\nvar _CobbAngle;\nconst {\n  CobbAngle: TID300CobbAngle\n} = utilities.TID300;\nclass CobbAngle extends BaseAdapter3D {\n  static getMeasurementData(MeasurementGroup, sopInstanceUIDToImageIdMap, imageToWorldCoords, metadata) {\n    const {\n      defaultState,\n      NUMGroup,\n      SCOORDGroup,\n      ReferencedFrameNumber\n    } = MeasurementReport.getSetupMeasurementData(MeasurementGroup, sopInstanceUIDToImageIdMap, metadata, CobbAngle.toolType);\n    const referencedImageId = defaultState.annotation.metadata.referencedImageId;\n    const {\n      GraphicData\n    } = SCOORDGroup;\n    const worldCoords = [];\n    for (let i = 0; i < GraphicData.length; i += 2) {\n      const point = imageToWorldCoords(referencedImageId, [GraphicData[i], GraphicData[i + 1]]);\n      worldCoords.push(point);\n    }\n    const state = defaultState;\n    state.annotation.data = {\n      handles: {\n        points: [worldCoords[0], worldCoords[1], worldCoords[2], worldCoords[3]],\n        activeHandleIndex: 0,\n        textBox: {\n          hasMoved: false\n        }\n      },\n      cachedStats: {\n        [`imageId:${referencedImageId}`]: {\n          angle: NUMGroup ? NUMGroup.MeasuredValueSequence.NumericValue : null\n        }\n      },\n      frameNumber: ReferencedFrameNumber\n    };\n    return state;\n  }\n  static getTID300RepresentationArguments(tool, worldToImageCoords) {\n    const {\n      data,\n      finding,\n      findingSites,\n      metadata\n    } = tool;\n    const {\n      cachedStats = {},\n      handles\n    } = data;\n    const {\n      referencedImageId\n    } = metadata;\n    if (!referencedImageId) {\n      throw new Error(\"CobbAngle.getTID300RepresentationArguments: referencedImageId is not defined\");\n    }\n    const start1 = worldToImageCoords(referencedImageId, handles.points[0]);\n    const end1 = worldToImageCoords(referencedImageId, handles.points[1]);\n    const start2 = worldToImageCoords(referencedImageId, handles.points[2]);\n    const end2 = worldToImageCoords(referencedImageId, handles.points[3]);\n    const point1 = {\n      x: start1[0],\n      y: start1[1]\n    };\n    const point2 = {\n      x: end1[0],\n      y: end1[1]\n    };\n    const point3 = {\n      x: start2[0],\n      y: start2[1]\n    };\n    const point4 = {\n      x: end2[0],\n      y: end2[1]\n    };\n    const {\n      angle\n    } = cachedStats[`imageId:${referencedImageId}`] || {};\n    return {\n      point1,\n      point2,\n      point3,\n      point4,\n      rAngle: angle,\n      trackingIdentifierTextValue: this.trackingIdentifierTextValue,\n      finding,\n      findingSites: findingSites || []\n    };\n  }\n}\n_CobbAngle = CobbAngle;\n(() => {\n  _CobbAngle.init(\"CobbAngle\", TID300CobbAngle);\n  _CobbAngle.registerLegacy();\n})();\n\nexport { CobbAngle as default };\n","import { utilities } from 'dcmjs';\nimport MeasurementReport from './MeasurementReport.js';\nimport BaseAdapter3D from './BaseAdapter3D.js';\n\nvar _CircleROI;\nconst {\n  Circle: TID300Circle\n} = utilities.TID300;\nclass CircleROI extends BaseAdapter3D {\n  static getMeasurementData(MeasurementGroup, sopInstanceUIDToImageIdMap, imageToWorldCoords, metadata) {\n    const {\n      defaultState,\n      NUMGroup,\n      SCOORDGroup,\n      ReferencedFrameNumber\n    } = MeasurementReport.getSetupMeasurementData(MeasurementGroup, sopInstanceUIDToImageIdMap, metadata, CircleROI.toolType);\n    const referencedImageId = defaultState.annotation.metadata.referencedImageId;\n    const {\n      GraphicData\n    } = SCOORDGroup;\n    const pointsWorld = [];\n    for (let i = 0; i < GraphicData.length; i += 2) {\n      const worldPos = imageToWorldCoords(referencedImageId, [GraphicData[i], GraphicData[i + 1]]);\n      pointsWorld.push(worldPos);\n    }\n    const state = defaultState;\n    state.annotation.data = {\n      handles: {\n        points: [...pointsWorld],\n        activeHandleIndex: 0,\n        textBox: {\n          hasMoved: false\n        }\n      },\n      cachedStats: {\n        [`imageId:${referencedImageId}`]: {\n          area: NUMGroup ? NUMGroup.MeasuredValueSequence.NumericValue : 0,\n          radius: 0,\n          perimeter: 0\n        }\n      },\n      frameNumber: ReferencedFrameNumber\n    };\n    return state;\n  }\n  static getTID300RepresentationArguments(tool, worldToImageCoords) {\n    const {\n      data,\n      finding,\n      findingSites,\n      metadata\n    } = tool;\n    const {\n      cachedStats = {},\n      handles\n    } = data;\n    const {\n      referencedImageId\n    } = metadata;\n    if (!referencedImageId) {\n      throw new Error(\"CircleROI.getTID300RepresentationArguments: referencedImageId is not defined\");\n    }\n    const center = worldToImageCoords(referencedImageId, handles.points[0]);\n    const end = worldToImageCoords(referencedImageId, handles.points[1]);\n    const points = [];\n    points.push({\n      x: center[0],\n      y: center[1]\n    });\n    points.push({\n      x: end[0],\n      y: end[1]\n    });\n    const {\n      area,\n      radius\n    } = cachedStats[`imageId:${referencedImageId}`] || {};\n    const perimeter = 2 * Math.PI * radius;\n    return {\n      area,\n      perimeter,\n      radius,\n      points,\n      trackingIdentifierTextValue: this.trackingIdentifierTextValue,\n      finding,\n      findingSites: findingSites || []\n    };\n  }\n}\n_CircleROI = CircleROI;\n(() => {\n  _CircleROI.init(\"CircleROI\", TID300Circle);\n  _CircleROI.registerLegacy();\n})();\n\nexport { CircleROI as default };\n","import { vec3 } from 'gl-matrix';\nimport { utilities } from 'dcmjs';\nimport MeasurementReport from './MeasurementReport.js';\nimport BaseAdapter3D from './BaseAdapter3D.js';\n\nvar _EllipticalROI;\nconst {\n  Ellipse: TID300Ellipse\n} = utilities.TID300;\nconst EPSILON = 1e-4;\nclass EllipticalROI extends BaseAdapter3D {\n  static getMeasurementData(MeasurementGroup, sopInstanceUIDToImageIdMap, imageToWorldCoords, metadata) {\n    const {\n      defaultState,\n      NUMGroup,\n      SCOORDGroup,\n      ReferencedFrameNumber\n    } = MeasurementReport.getSetupMeasurementData(MeasurementGroup, sopInstanceUIDToImageIdMap, metadata, EllipticalROI.toolType);\n    const referencedImageId = defaultState.annotation.metadata.referencedImageId;\n    const {\n      GraphicData\n    } = SCOORDGroup;\n    const pointsWorld = [];\n    for (let i = 0; i < GraphicData.length; i += 2) {\n      const worldPos = imageToWorldCoords(referencedImageId, [GraphicData[i], GraphicData[i + 1]]);\n      pointsWorld.push(worldPos);\n    }\n    const majorAxisStart = vec3.fromValues(...pointsWorld[0]);\n    const majorAxisEnd = vec3.fromValues(...pointsWorld[1]);\n    const minorAxisStart = vec3.fromValues(...pointsWorld[2]);\n    const minorAxisEnd = vec3.fromValues(...pointsWorld[3]);\n    const majorAxisVec = vec3.create();\n    vec3.sub(majorAxisVec, majorAxisEnd, majorAxisStart);\n    vec3.normalize(majorAxisVec, majorAxisVec);\n    const minorAxisVec = vec3.create();\n    vec3.sub(minorAxisVec, minorAxisEnd, minorAxisStart);\n    vec3.normalize(minorAxisVec, minorAxisVec);\n    const imagePlaneModule = metadata.get(\"imagePlaneModule\", referencedImageId);\n    if (!imagePlaneModule) {\n      throw new Error(\"imageId does not have imagePlaneModule metadata\");\n    }\n    const {\n      columnCosines\n    } = imagePlaneModule;\n    const columnCosinesVec = vec3.fromValues(columnCosines[0], columnCosines[1], columnCosines[2]);\n    const projectedMajorAxisOnColVec = vec3.dot(columnCosinesVec, majorAxisVec);\n    const projectedMinorAxisOnColVec = vec3.dot(columnCosinesVec, minorAxisVec);\n    const absoluteOfMajorDotProduct = Math.abs(projectedMajorAxisOnColVec);\n    const absoluteOfMinorDotProduct = Math.abs(projectedMinorAxisOnColVec);\n    let ellipsePoints = [];\n    if (Math.abs(absoluteOfMajorDotProduct - 1) < EPSILON) {\n      ellipsePoints = [pointsWorld[0], pointsWorld[1], pointsWorld[2], pointsWorld[3]];\n    } else if (Math.abs(absoluteOfMinorDotProduct - 1) < EPSILON) {\n      ellipsePoints = [pointsWorld[2], pointsWorld[3], pointsWorld[0], pointsWorld[1]];\n    } else {\n      console.warn(\"OBLIQUE ELLIPSE NOT YET SUPPORTED\");\n    }\n    const state = defaultState;\n    state.annotation.data = {\n      handles: {\n        points: [...ellipsePoints],\n        activeHandleIndex: 0,\n        textBox: {\n          hasMoved: false\n        }\n      },\n      cachedStats: {\n        [`imageId:${referencedImageId}`]: {\n          area: NUMGroup ? NUMGroup.MeasuredValueSequence.NumericValue : 0\n        }\n      },\n      frameNumber: ReferencedFrameNumber\n    };\n    return state;\n  }\n  static getTID300RepresentationArguments(tool, worldToImageCoords) {\n    const {\n      data,\n      finding,\n      findingSites,\n      metadata\n    } = tool;\n    const {\n      cachedStats = {},\n      handles\n    } = data;\n    const rotation = data.initialRotation || 0;\n    const {\n      referencedImageId\n    } = metadata;\n    if (!referencedImageId) {\n      throw new Error(\"EllipticalROI.getTID300RepresentationArguments: referencedImageId is not defined\");\n    }\n    let top, bottom, left, right;\n    if (rotation == 90 || rotation == 270) {\n      bottom = worldToImageCoords(referencedImageId, handles.points[2]);\n      top = worldToImageCoords(referencedImageId, handles.points[3]);\n      left = worldToImageCoords(referencedImageId, handles.points[0]);\n      right = worldToImageCoords(referencedImageId, handles.points[1]);\n    } else {\n      top = worldToImageCoords(referencedImageId, handles.points[0]);\n      bottom = worldToImageCoords(referencedImageId, handles.points[1]);\n      left = worldToImageCoords(referencedImageId, handles.points[2]);\n      right = worldToImageCoords(referencedImageId, handles.points[3]);\n    }\n    const topBottomLength = Math.abs(top[1] - bottom[1]);\n    const leftRightLength = Math.abs(left[0] - right[0]);\n    const points = [];\n    if (topBottomLength > leftRightLength) {\n      points.push({\n        x: top[0],\n        y: top[1]\n      });\n      points.push({\n        x: bottom[0],\n        y: bottom[1]\n      });\n      points.push({\n        x: left[0],\n        y: left[1]\n      });\n      points.push({\n        x: right[0],\n        y: right[1]\n      });\n    } else {\n      points.push({\n        x: left[0],\n        y: left[1]\n      });\n      points.push({\n        x: right[0],\n        y: right[1]\n      });\n      points.push({\n        x: top[0],\n        y: top[1]\n      });\n      points.push({\n        x: bottom[0],\n        y: bottom[1]\n      });\n    }\n    const {\n      area\n    } = cachedStats[`imageId:${referencedImageId}`] || {};\n    return {\n      area,\n      points,\n      trackingIdentifierTextValue: this.trackingIdentifierTextValue,\n      finding,\n      findingSites: findingSites || []\n    };\n  }\n}\n_EllipticalROI = EllipticalROI;\n_EllipticalROI.init(\"EllipticalROI\", TID300Ellipse);\n\nexport { EllipticalROI as default };\n","import { utilities } from 'dcmjs';\nimport MeasurementReport from './MeasurementReport.js';\nimport BaseAdapter3D from './BaseAdapter3D.js';\n\nvar _RectangleROI;\nconst {\n  Polyline: TID300Polyline\n} = utilities.TID300;\nclass RectangleROI extends BaseAdapter3D {\n  static getMeasurementData(MeasurementGroup, sopInstanceUIDToImageIdMap, imageToWorldCoords, metadata) {\n    const {\n      defaultState,\n      NUMGroup,\n      SCOORDGroup,\n      ReferencedFrameNumber\n    } = MeasurementReport.getSetupMeasurementData(MeasurementGroup, sopInstanceUIDToImageIdMap, metadata, RectangleROI.toolType);\n    const referencedImageId = defaultState.annotation.metadata.referencedImageId;\n    const {\n      GraphicData\n    } = SCOORDGroup;\n    const worldCoords = [];\n    for (let i = 0; i < GraphicData.length; i += 2) {\n      const point = imageToWorldCoords(referencedImageId, [GraphicData[i], GraphicData[i + 1]]);\n      worldCoords.push(point);\n    }\n    const state = defaultState;\n    state.annotation.data = {\n      handles: {\n        points: [worldCoords[0], worldCoords[1], worldCoords[3], worldCoords[2]],\n        activeHandleIndex: 0,\n        textBox: {\n          hasMoved: false\n        }\n      },\n      cachedStats: {\n        [`imageId:${referencedImageId}`]: {\n          area: NUMGroup ? NUMGroup.MeasuredValueSequence.NumericValue : null\n        }\n      },\n      frameNumber: ReferencedFrameNumber\n    };\n    return state;\n  }\n  static getTID300RepresentationArguments(tool, worldToImageCoords) {\n    const {\n      data,\n      finding,\n      findingSites,\n      metadata\n    } = tool;\n    const {\n      cachedStats = {},\n      handles\n    } = data;\n    const {\n      referencedImageId\n    } = metadata;\n    if (!referencedImageId) {\n      throw new Error(\"CobbAngle.getTID300RepresentationArguments: referencedImageId is not defined\");\n    }\n    const corners = handles.points.map(point => worldToImageCoords(referencedImageId, point));\n    const {\n      area,\n      perimeter\n    } = cachedStats;\n    return {\n      points: [corners[0], corners[1], corners[3], corners[2], corners[0]],\n      area,\n      perimeter,\n      trackingIdentifierTextValue: this.trackingIdentifierTextValue,\n      finding,\n      findingSites: findingSites || []\n    };\n  }\n}\n_RectangleROI = RectangleROI;\n(() => {\n  _RectangleROI.init(\"RectangleROI\", TID300Polyline);\n  _RectangleROI.registerLegacy();\n})();\n\nexport { RectangleROI as default };\n","import { utilities } from 'dcmjs';\nimport MeasurementReport from './MeasurementReport.js';\nimport BaseAdapter3D from './BaseAdapter3D.js';\n\nvar _Length;\nconst {\n  Length: TID300Length\n} = utilities.TID300;\nconst LENGTH = \"Length\";\nclass Length extends BaseAdapter3D {\n  static getMeasurementData(MeasurementGroup, sopInstanceUIDToImageIdMap, imageToWorldCoords, metadata) {\n    const {\n      defaultState,\n      NUMGroup,\n      SCOORDGroup,\n      ReferencedFrameNumber\n    } = MeasurementReport.getSetupMeasurementData(MeasurementGroup, sopInstanceUIDToImageIdMap, metadata, this.toolType);\n    const referencedImageId = defaultState.annotation.metadata.referencedImageId;\n    const {\n      GraphicData\n    } = SCOORDGroup;\n    const worldCoords = [];\n    for (let i = 0; i < GraphicData.length; i += 2) {\n      const point = imageToWorldCoords(referencedImageId, [GraphicData[i], GraphicData[i + 1]]);\n      worldCoords.push(point);\n    }\n    const state = defaultState;\n    state.annotation.data = {\n      handles: {\n        points: [worldCoords[0], worldCoords[1]],\n        activeHandleIndex: 0,\n        textBox: {\n          hasMoved: false\n        }\n      },\n      cachedStats: {\n        [`imageId:${referencedImageId}`]: {\n          length: NUMGroup ? NUMGroup.MeasuredValueSequence.NumericValue : 0\n        }\n      },\n      frameNumber: ReferencedFrameNumber\n    };\n    return state;\n  }\n  static getTID300RepresentationArguments(tool, worldToImageCoords) {\n    const {\n      data,\n      finding,\n      findingSites,\n      metadata\n    } = tool;\n    const {\n      cachedStats = {},\n      handles\n    } = data;\n    const {\n      referencedImageId\n    } = metadata;\n    if (!referencedImageId) {\n      throw new Error(\"Length.getTID300RepresentationArguments: referencedImageId is not defined\");\n    }\n    const start = worldToImageCoords(referencedImageId, handles.points[0]);\n    const end = worldToImageCoords(referencedImageId, handles.points[1]);\n    const point1 = {\n      x: start[0],\n      y: start[1]\n    };\n    const point2 = {\n      x: end[0],\n      y: end[1]\n    };\n    const {\n      length: distance\n    } = cachedStats[`imageId:${referencedImageId}`] || {};\n    return {\n      point1,\n      point2,\n      distance,\n      trackingIdentifierTextValue: this.trackingIdentifierTextValue,\n      finding,\n      findingSites: findingSites || []\n    };\n  }\n}\n_Length = Length;\n(() => {\n  _Length.init(LENGTH, TID300Length);\n  _Length.registerLegacy();\n})();\n\nexport { Length as default };\n","import MeasurementReport from './MeasurementReport.js';\nimport { utilities } from 'dcmjs';\nimport { vec3 } from 'gl-matrix';\nimport BaseAdapter3D from './BaseAdapter3D.js';\n\nvar _PlanarFreehandROI;\nconst {\n  Polyline: TID300Polyline\n} = utilities.TID300;\nclass PlanarFreehandROI extends BaseAdapter3D {\n  static getMeasurementData(MeasurementGroup, sopInstanceUIDToImageIdMap, imageToWorldCoords, metadata) {\n    const {\n      defaultState,\n      NUMGroup,\n      SCOORDGroup,\n      ReferencedFrameNumber\n    } = MeasurementReport.getSetupMeasurementData(MeasurementGroup, sopInstanceUIDToImageIdMap, metadata, PlanarFreehandROI.toolType);\n    const referencedImageId = defaultState.annotation.metadata.referencedImageId;\n    const {\n      GraphicData\n    } = SCOORDGroup;\n    const worldCoords = [];\n    for (let i = 0; i < GraphicData.length; i += 2) {\n      const point = imageToWorldCoords(referencedImageId, [GraphicData[i], GraphicData[i + 1]]);\n      worldCoords.push(point);\n    }\n    const distanceBetweenFirstAndLastPoint = vec3.distance(worldCoords[worldCoords.length - 1], worldCoords[0]);\n    let isOpenContour = true;\n    if (distanceBetweenFirstAndLastPoint < this.closedContourThreshold) {\n      worldCoords.pop();\n      isOpenContour = false;\n    }\n    const points = [];\n    if (isOpenContour) {\n      points.push(worldCoords[0], worldCoords[worldCoords.length - 1]);\n    }\n    const state = defaultState;\n    state.annotation.data = {\n      contour: {\n        polyline: worldCoords,\n        closed: !isOpenContour\n      },\n      handles: {\n        points,\n        activeHandleIndex: null,\n        textBox: {\n          hasMoved: false\n        }\n      },\n      cachedStats: {\n        [`imageId:${referencedImageId}`]: {\n          area: NUMGroup ? NUMGroup.MeasuredValueSequence.NumericValue : null\n        }\n      },\n      frameNumber: ReferencedFrameNumber\n    };\n    return state;\n  }\n  static getTID300RepresentationArguments(tool, worldToImageCoords) {\n    const {\n      data,\n      finding,\n      findingSites,\n      metadata\n    } = tool;\n    const {\n      polyline,\n      closed\n    } = data.contour;\n    const isOpenContour = closed !== true;\n    const {\n      referencedImageId\n    } = metadata;\n    if (!referencedImageId) {\n      throw new Error(\"PlanarFreehandROI.getTID300RepresentationArguments: referencedImageId is not defined\");\n    }\n    const points = polyline.map(worldPos => worldToImageCoords(referencedImageId, worldPos));\n    if (!isOpenContour) {\n      const firstPoint = points[0];\n      points.push([firstPoint[0], firstPoint[1]]);\n    }\n    const {\n      area,\n      areaUnit,\n      modalityUnit,\n      perimeter,\n      mean,\n      max,\n      stdDev\n    } = data.cachedStats[`imageId:${referencedImageId}`] || {};\n    return {\n      points,\n      area,\n      areaUnit,\n      perimeter,\n      modalityUnit,\n      mean,\n      max,\n      stdDev,\n      trackingIdentifierTextValue: this.trackingIdentifierTextValue,\n      finding,\n      findingSites: findingSites || []\n    };\n  }\n}\n_PlanarFreehandROI = PlanarFreehandROI;\n_PlanarFreehandROI.closedContourThreshold = 1e-5;\n_PlanarFreehandROI.init(\"PlanarFreehandROI\", TID300Polyline);\n\nexport { PlanarFreehandROI as default };\n","import { utilities } from 'dcmjs';\nimport MeasurementReport from './MeasurementReport.js';\nimport BaseAdapter3D from './BaseAdapter3D.js';\n\nvar _Probe;\nconst {\n  Point: TID300Point\n} = utilities.TID300;\nclass Probe extends BaseAdapter3D {\n  static getMeasurementData(MeasurementGroup, sopInstanceUIDToImageIdMap, imageToWorldCoords, metadata, trackingIdentifier) {\n    const state = super.getMeasurementData(MeasurementGroup, sopInstanceUIDToImageIdMap, imageToWorldCoords, metadata, trackingIdentifier);\n    const {\n      defaultState,\n      SCOORDGroup\n    } = MeasurementReport.getSetupMeasurementData(MeasurementGroup, sopInstanceUIDToImageIdMap, metadata, Probe.toolType);\n    const referencedImageId = defaultState.annotation.metadata.referencedImageId;\n    const {\n      GraphicData\n    } = SCOORDGroup;\n    const worldCoords = [];\n    for (let i = 0; i < GraphicData.length; i += 2) {\n      const point = imageToWorldCoords(referencedImageId, [GraphicData[i], GraphicData[i + 1]]);\n      worldCoords.push(point);\n    }\n    state.annotation.data = {\n      ...state.annotation.data,\n      handles: {\n        points: worldCoords,\n        activeHandleIndex: null,\n        textBox: {\n          hasMoved: false\n        }\n      }\n    };\n    return state;\n  }\n}\n_Probe = Probe;\n(() => {\n  _Probe.init(\"Probe\", TID300Point);\n  _Probe.registerLegacy();\n})();\n\nexport { Probe as default };\n","import { utilities } from 'dcmjs';\nimport MeasurementReport from './MeasurementReport.js';\nimport BaseAdapter3D from './BaseAdapter3D.js';\n\nvar _UltrasoundDirectional;\nconst {\n  Length: TID300Length\n} = utilities.TID300;\nclass UltrasoundDirectional extends BaseAdapter3D {\n  static getMeasurementData(MeasurementGroup, sopInstanceUIDToImageIdMap, imageToWorldCoords, metadata) {\n    const {\n      defaultState,\n      SCOORDGroup,\n      ReferencedFrameNumber\n    } = MeasurementReport.getSetupMeasurementData(MeasurementGroup, sopInstanceUIDToImageIdMap, metadata, UltrasoundDirectional.toolType);\n    const referencedImageId = defaultState.annotation.metadata.referencedImageId;\n    const {\n      GraphicData\n    } = SCOORDGroup;\n    const worldCoords = [];\n    for (let i = 0; i < GraphicData.length; i += 2) {\n      const point = imageToWorldCoords(referencedImageId, [GraphicData[i], GraphicData[i + 1]]);\n      worldCoords.push(point);\n    }\n    const state = defaultState;\n    state.annotation.data = {\n      handles: {\n        points: [worldCoords[0], worldCoords[1]],\n        activeHandleIndex: 0,\n        textBox: {\n          hasMoved: false\n        }\n      },\n      cachedStats: {},\n      frameNumber: ReferencedFrameNumber\n    };\n    return state;\n  }\n  static getTID300RepresentationArguments(tool, worldToImageCoords) {\n    const {\n      data,\n      finding,\n      findingSites,\n      metadata\n    } = tool;\n    const {\n      handles\n    } = data;\n    const {\n      referencedImageId\n    } = metadata;\n    if (!referencedImageId) {\n      throw new Error(\"UltrasoundDirectionalTool.getTID300RepresentationArguments: referencedImageId is not defined\");\n    }\n    const start = worldToImageCoords(referencedImageId, handles.points[0]);\n    const end = worldToImageCoords(referencedImageId, handles.points[1]);\n    const point1 = {\n      x: start[0],\n      y: start[1]\n    };\n    const point2 = {\n      x: end[0],\n      y: end[1]\n    };\n    return {\n      point1,\n      point2,\n      trackingIdentifierTextValue: this.trackingIdentifierTextValue,\n      finding,\n      findingSites: findingSites || []\n    };\n  }\n}\n_UltrasoundDirectional = UltrasoundDirectional;\n_UltrasoundDirectional.init(\"UltrasoundDirectionalTool\", TID300Length);\n\nexport { UltrasoundDirectional as default };\n","import { normalizers, derivations } from 'dcmjs';\nimport { fillSegmentation } from '../../Cornerstone/Segmentation_4X.js';\n\nconst {\n  Normalizer\n} = normalizers;\nconst {\n  Segmentation: SegmentationDerivation\n} = derivations;\nfunction generateSegmentation(images, labelmaps, metadata) {\n  let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  const segmentation = _createMultiframeSegmentationFromReferencedImages(images, metadata, options);\n  return fillSegmentation(segmentation, labelmaps, options);\n}\nfunction _createMultiframeSegmentationFromReferencedImages(images, metadata, options) {\n  const datasets = images.map(image => {\n    const instance = metadata.get(\"instance\", image.imageId);\n    return {\n      ...image,\n      ...instance,\n      SOPClassUID: instance.SopClassUID || instance.SOPClassUID,\n      SOPInstanceUID: instance.SopInstanceUID || instance.SOPInstanceUID,\n      PixelData: image.voxelManager.getScalarData(),\n      _vrMap: {\n        PixelData: \"OW\"\n      },\n      _meta: {}\n    };\n  });\n  const multiframe = Normalizer.normalizeToDataset(datasets);\n  if (!multiframe) {\n    throw new Error(\"Failed to normalize the multiframe dataset, the data is not multi-frame.\");\n  }\n  return new SegmentationDerivation([multiframe], options);\n}\n\nexport { generateSegmentation };\n","function generateLabelMaps2DFrom3D(labelmap3D) {\n  const {\n    scalarData,\n    dimensions\n  } = labelmap3D;\n  const labelmaps2D = [];\n  const segmentsOnLabelmap3D = new Set();\n  for (let z = 0; z < dimensions[2]; z++) {\n    const pixelData = scalarData.slice(z * dimensions[0] * dimensions[1], (z + 1) * dimensions[0] * dimensions[1]);\n    const segmentsOnLabelmap = [];\n    for (let i = 0; i < pixelData.length; i++) {\n      const segment = pixelData[i];\n      if (!segmentsOnLabelmap.includes(segment) && segment !== 0) {\n        segmentsOnLabelmap.push(segment);\n      }\n    }\n    const labelmap2D = {\n      segmentsOnLabelmap,\n      pixelData,\n      rows: dimensions[1],\n      columns: dimensions[0]\n    };\n    if (segmentsOnLabelmap.length === 0) {\n      continue;\n    }\n    segmentsOnLabelmap.forEach(segmentIndex => {\n      segmentsOnLabelmap3D.add(segmentIndex);\n    });\n    labelmaps2D[dimensions[2] - 1 - z] = labelmap2D;\n  }\n  labelmap3D.segmentsOnLabelmap = Array.from(segmentsOnLabelmap3D);\n  labelmap3D.labelmaps2D = labelmaps2D;\n  return labelmap3D;\n}\n\nexport { generateLabelMaps2DFrom3D };\n","const checkHasOverlapping = _ref => {\n  let {\n    largerArray,\n    currentTestedArray,\n    newArray\n  } = _ref;\n  return largerArray.some((_, currentImageIndex) => {\n    const originalImagePixelData = currentTestedArray[currentImageIndex];\n    const newImagePixelData = newArray[currentImageIndex];\n    if (!originalImagePixelData || !newImagePixelData) {\n      return false;\n    }\n    return originalImagePixelData.some((originalPixel, currentPixelIndex) => {\n      const newPixel = newImagePixelData[currentPixelIndex];\n      return originalPixel && newPixel;\n    });\n  });\n};\nconst compactMergeSegmentDataWithoutInformationLoss = _ref2 => {\n  let {\n    arrayOfSegmentData,\n    newSegmentData\n  } = _ref2;\n  if (arrayOfSegmentData.length === 0) {\n    arrayOfSegmentData.push(newSegmentData);\n    return;\n  }\n  for (let currentTestedIndex = 0; currentTestedIndex < arrayOfSegmentData.length; currentTestedIndex++) {\n    const currentTestedArray = arrayOfSegmentData[currentTestedIndex];\n    const originalArrayIsLarger = currentTestedArray.length > newSegmentData.length;\n    const largerArray = originalArrayIsLarger ? currentTestedArray : newSegmentData;\n    const hasOverlapping = checkHasOverlapping({\n      currentTestedArray,\n      largerArray,\n      newArray: newSegmentData\n    });\n    if (hasOverlapping) {\n      continue;\n    }\n    largerArray.forEach((_, currentImageIndex) => {\n      const originalImagePixelData = currentTestedArray[currentImageIndex];\n      const newImagePixelData = newSegmentData[currentImageIndex];\n      if (!originalImagePixelData && !newImagePixelData || !newImagePixelData) {\n        return;\n      }\n      if (!originalImagePixelData) {\n        currentTestedArray[currentImageIndex] = newImagePixelData;\n        return;\n      }\n      const mergedPixelData = originalImagePixelData.map((originalPixel, currentPixelIndex) => {\n        const newPixel = newImagePixelData[currentPixelIndex];\n        return originalPixel || newPixel;\n      });\n      currentTestedArray[currentImageIndex] = mergedPixelData;\n    });\n    return;\n  }\n  arrayOfSegmentData.push(newSegmentData);\n};\n\nexport { compactMergeSegmentDataWithoutInformationLoss };\n","import { triggerEvent, eventTarget, imageLoader } from '@cornerstonejs/core';\nimport { utilities as utilities$1 } from '@cornerstonejs/tools';\nimport { utilities, data, normalizers } from 'dcmjs';\nimport ndarray from 'ndarray';\nimport checkOrientation from '../../helpers/checkOrientation.js';\nimport { getValidOrientations, getSegmentMetadata, unpackPixelData, calculateCentroid, readFromUnpackedChunks, alignPixelDataWithSourceData, getSegmentIndex, findReferenceSourceImageId } from '../../Cornerstone/Segmentation_4X.js';\nimport { compactMergeSegmentDataWithoutInformationLoss } from './compactMergeSegData.js';\nimport { Events } from '../../enums/Events.js';\n\nconst {\n  DicomMessage,\n  DicomMetaDictionary\n} = data;\nconst {\n  Normalizer\n} = normalizers;\nconst {\n  decode\n} = utilities.compression;\nconst updateSegmentsOnFrame = _ref => {\n  let {\n    segmentsOnFrame,\n    imageIdIndex,\n    segmentIndex\n  } = _ref;\n  if (!segmentsOnFrame[imageIdIndex]) {\n    segmentsOnFrame[imageIdIndex] = [];\n  }\n  segmentsOnFrame[imageIdIndex].push(segmentIndex);\n};\nconst updateSegmentsPixelIndices = _ref2 => {\n  let {\n    segmentsPixelIndices,\n    segmentIndex,\n    imageIdIndex,\n    indexCache\n  } = _ref2;\n  if (!segmentsPixelIndices.has(segmentIndex)) {\n    segmentsPixelIndices.set(segmentIndex, {});\n  }\n  const segmentIndexObject = segmentsPixelIndices.get(segmentIndex);\n  segmentIndexObject[imageIdIndex] = indexCache;\n  segmentsPixelIndices.set(segmentIndex, segmentIndexObject);\n};\nconst extractInfoFromPerFrameFunctionalGroups = _ref3 => {\n  let {\n    PerFrameFunctionalGroups,\n    sequenceIndex,\n    sopUIDImageIdIndexMap,\n    multiframe\n  } = _ref3;\n  const referencedSOPInstanceUid = PerFrameFunctionalGroups.DerivationImageSequence[0].SourceImageSequence[0].ReferencedSOPInstanceUID;\n  const referencedImageId = sopUIDImageIdIndexMap[referencedSOPInstanceUid];\n  const segmentIndex = getSegmentIndex(multiframe, sequenceIndex);\n  return {\n    referencedSOPInstanceUid,\n    referencedImageId,\n    segmentIndex\n  };\n};\nasync function createLabelmapsFromBufferInternal(referencedImageIds, arrayBuffer, metadataProvider, options) {\n  const {\n    tolerance = 1e-3,\n    TypedArrayConstructor = Uint8Array,\n    maxBytesPerChunk = 199000000\n  } = options;\n  const dicomData = DicomMessage.readFile(arrayBuffer);\n  const dataset = DicomMetaDictionary.naturalizeDataset(dicomData.dict);\n  dataset._meta = DicomMetaDictionary.namifyDataset(dicomData.meta);\n  const multiframe = Normalizer.normalizeToDataset([dataset]);\n  const imagePlaneModule = metadataProvider.get(\"imagePlaneModule\", referencedImageIds[0]);\n  const generalSeriesModule = metadataProvider.get(\"generalSeriesModule\", referencedImageIds[0]);\n  const SeriesInstanceUID = generalSeriesModule.seriesInstanceUID;\n  if (!imagePlaneModule) {\n    console.warn(\"Insufficient metadata, imagePlaneModule missing.\");\n  }\n  const ImageOrientationPatient = Array.isArray(imagePlaneModule.rowCosines) ? [...imagePlaneModule.rowCosines, ...imagePlaneModule.columnCosines] : [imagePlaneModule.rowCosines.x, imagePlaneModule.rowCosines.y, imagePlaneModule.rowCosines.z, imagePlaneModule.columnCosines.x, imagePlaneModule.columnCosines.y, imagePlaneModule.columnCosines.z];\n  const validOrientations = getValidOrientations(ImageOrientationPatient);\n  const segMetadata = getSegmentMetadata(multiframe, SeriesInstanceUID);\n  const TransferSyntaxUID = multiframe._meta.TransferSyntaxUID.Value[0];\n  let pixelData;\n  let pixelDataChunks;\n  if (TransferSyntaxUID === \"1.2.840.10008.1.2.5\") {\n    const rleEncodedFrames = Array.isArray(multiframe.PixelData) ? multiframe.PixelData : [multiframe.PixelData];\n    pixelData = decode(rleEncodedFrames, multiframe.Rows, multiframe.Columns);\n    if (multiframe.BitsStored === 1) {\n      console.warn(\"No implementation for rle + bit packing.\");\n      return;\n    }\n    pixelDataChunks = [pixelData];\n  } else {\n    pixelDataChunks = unpackPixelData(multiframe, {\n      maxBytesPerChunk\n    });\n    if (!pixelDataChunks) {\n      throw new Error(\"Fractional segmentations are not yet supported\");\n    }\n  }\n  const orientation = checkOrientation(multiframe, validOrientations, [imagePlaneModule.rows, imagePlaneModule.columns, referencedImageIds.length], tolerance);\n  const sopUIDImageIdIndexMap = referencedImageIds.reduce((acc, imageId) => {\n    const {\n      sopInstanceUID\n    } = metadataProvider.get(\"generalImageModule\", imageId);\n    acc[sopInstanceUID] = imageId;\n    return acc;\n  }, {});\n  let insertFunction;\n  switch (orientation) {\n    case \"Planar\":\n      insertFunction = insertPixelDataPlanar;\n      break;\n    case \"Perpendicular\":\n      throw new Error(\"Segmentations orthogonal to the acquisition plane of the source data are not yet supported.\");\n    case \"Oblique\":\n      throw new Error(\"Segmentations oblique to the acquisition plane of the source data are not yet supported.\");\n  }\n  const segmentsOnFrame = [];\n  const imageIdMaps = {\n    indices: {},\n    metadata: {}\n  };\n  const labelMapImages = [];\n  for (let i = 0; i < referencedImageIds.length; i++) {\n    const referenceImageId = referencedImageIds[i];\n    imageIdMaps.indices[referenceImageId] = i;\n    imageIdMaps.metadata[referenceImageId] = metadataProvider.get(\"instance\", referenceImageId);\n    const labelMapImage = imageLoader.createAndCacheDerivedLabelmapImage(referenceImageId);\n    labelMapImages.push(labelMapImage);\n  }\n  const segmentsPixelIndices = new Map();\n  const {\n    hasOverlappingSegments,\n    arrayOfLabelMapImages\n  } = await insertFunction({\n    segmentsOnFrame,\n    labelMapImages,\n    pixelDataChunks,\n    multiframe,\n    referencedImageIds,\n    validOrientations,\n    metadataProvider,\n    tolerance,\n    segmentsPixelIndices,\n    sopUIDImageIdIndexMap,\n    imageIdMaps,\n    TypedArrayConstructor\n  });\n  const centroidXYZ = new Map();\n  segmentsPixelIndices.forEach((imageIdIndexBufferIndex, segmentIndex) => {\n    const centroids = calculateCentroid(imageIdIndexBufferIndex, multiframe, metadataProvider, referencedImageIds);\n    centroidXYZ.set(segmentIndex, centroids);\n  });\n  return {\n    labelMapImages: arrayOfLabelMapImages,\n    segMetadata,\n    segmentsOnFrame,\n    centroids: centroidXYZ,\n    overlappingSegments: hasOverlappingSegments\n  };\n}\nconst throttledTriggerLoadProgressEvent = utilities$1.throttle(percentComplete => {\n  triggerEvent(eventTarget, Events.SEGMENTATION_LOAD_PROGRESS, {\n    percentComplete\n  });\n}, 200);\nfunction insertPixelDataPlanar(_ref4) {\n  let {\n    segmentsOnFrame,\n    labelMapImages,\n    pixelDataChunks,\n    multiframe,\n    referencedImageIds,\n    validOrientations,\n    metadataProvider,\n    tolerance,\n    segmentsPixelIndices,\n    sopUIDImageIdIndexMap,\n    imageIdMaps\n  } = _ref4;\n  const {\n    SharedFunctionalGroupsSequence,\n    PerFrameFunctionalGroupsSequence,\n    Rows,\n    Columns\n  } = multiframe;\n  const sharedImageOrientationPatient = SharedFunctionalGroupsSequence.PlaneOrientationSequence ? SharedFunctionalGroupsSequence.PlaneOrientationSequence.ImageOrientationPatient : undefined;\n  const sliceLength = Columns * Rows;\n  const groupsLen = PerFrameFunctionalGroupsSequence.length;\n  let overlapping = false;\n  return new Promise(resolve => {\n    const percentImagesPerChunk = 0.1;\n    const imagesPerChunk = Math.ceil(groupsLen * percentImagesPerChunk);\n    const processChunk = firstIndex => {\n      for (let i = firstIndex; i < firstIndex + imagesPerChunk && i < groupsLen; i++) {\n        const PerFrameFunctionalGroups = PerFrameFunctionalGroupsSequence[i];\n        const ImageOrientationPatientI = sharedImageOrientationPatient || PerFrameFunctionalGroups.PlaneOrientationSequence.ImageOrientationPatient;\n        const view = readFromUnpackedChunks(pixelDataChunks, i * sliceLength, sliceLength);\n        const pixelDataI2D = ndarray(view, [Rows, Columns]);\n        const alignedPixelDataI = alignPixelDataWithSourceData(pixelDataI2D, ImageOrientationPatientI, validOrientations, tolerance);\n        if (!alignedPixelDataI) {\n          throw new Error(\"Individual SEG frames are out of plane with respect to the first SEG frame. \" + \"This is not yet supported. Aborting segmentation loading.\");\n        }\n        const segmentIndex = getSegmentIndex(multiframe, i);\n        if (segmentIndex === undefined) {\n          throw new Error(\"Could not retrieve the segment index. Aborting segmentation loading.\");\n        }\n        if (!segmentsPixelIndices.has(segmentIndex)) {\n          segmentsPixelIndices.set(segmentIndex, {});\n        }\n        const imageId = findReferenceSourceImageId(multiframe, i, referencedImageIds, metadataProvider, tolerance, sopUIDImageIdIndexMap);\n        if (!imageId) {\n          console.warn(\"Image not present in stack, can't import frame : \" + i + \".\");\n          return;\n        }\n        const sourceImageMetadata = imageIdMaps.metadata[imageId];\n        if (Rows !== sourceImageMetadata.Rows || Columns !== sourceImageMetadata.Columns) {\n          throw new Error(\"Individual SEG frames have different geometry dimensions (Rows and Columns) \" + \"respect to the source image reference frame. This is not yet supported. \" + \"Aborting segmentation loading. \");\n        }\n        const imageIdIndex = imageIdMaps.indices[imageId];\n        const labelmapImage = labelMapImages[imageIdIndex];\n        const labelmap2DView = labelmapImage.getPixelData();\n        const data = alignedPixelDataI.data;\n        const indexCache = [];\n        for (let k = 0, len = alignedPixelDataI.data.length; k < len; ++k) {\n          if (data[k]) {\n            for (let x = k; x < len; ++x) {\n              if (data[x]) {\n                if (!overlapping && labelmap2DView[x] !== 0) {\n                  overlapping = true;\n                  return resolve(insertOverlappingPixelDataPlanar({\n                    segmentsOnFrame,\n                    labelMapImages,\n                    pixelDataChunks,\n                    multiframe,\n                    referencedImageIds,\n                    validOrientations,\n                    metadataProvider,\n                    tolerance,\n                    segmentsPixelIndices,\n                    sopUIDImageIdIndexMap,\n                    imageIdMaps\n                  }));\n                }\n                labelmap2DView[x] = segmentIndex;\n                indexCache.push(x);\n              }\n            }\n            if (!segmentsOnFrame[imageIdIndex]) {\n              segmentsOnFrame[imageIdIndex] = [];\n            }\n            segmentsOnFrame[imageIdIndex].push(segmentIndex);\n            break;\n          }\n        }\n        const segmentIndexObject = segmentsPixelIndices.get(segmentIndex);\n        segmentIndexObject[imageIdIndex] = indexCache;\n        segmentsPixelIndices.set(segmentIndex, segmentIndexObject);\n      }\n      const percentComplete = Math.round(firstIndex / groupsLen * 100);\n      throttledTriggerLoadProgressEvent(percentComplete);\n      if (firstIndex < groupsLen) {\n        setTimeout(() => processChunk(firstIndex + imagesPerChunk), 0);\n      } else {\n        resolve({\n          hasOverlappingSegments: false,\n          arrayOfLabelMapImages: [labelMapImages]\n        });\n      }\n    };\n    processChunk(0);\n  });\n}\nconst getAlignedPixelData = _ref5 => {\n  let {\n    sharedImageOrientationPatient,\n    PerFrameFunctionalGroups,\n    pixelDataChunks,\n    sequenceIndex,\n    sliceLength,\n    Rows,\n    Columns,\n    validOrientations,\n    tolerance\n  } = _ref5;\n  const ImageOrientationPatientI = sharedImageOrientationPatient || PerFrameFunctionalGroups.PlaneOrientationSequence.ImageOrientationPatient;\n  const view = readFromUnpackedChunks(pixelDataChunks, sequenceIndex * sliceLength, sliceLength);\n  const pixelDataI2D = ndarray(view, [Rows, Columns]);\n  const alignedPixelDataI = alignPixelDataWithSourceData(pixelDataI2D, ImageOrientationPatientI, validOrientations, tolerance);\n  if (!alignedPixelDataI) {\n    throw new Error(\"Individual SEG frames are out of plane with respect to the first SEG frame. \" + \"This is not yet supported. Aborting segmentation loading.\");\n  }\n  return alignedPixelDataI;\n};\nconst checkImageDimensions = _ref6 => {\n  let {\n    metadataProvider,\n    imageId,\n    Rows,\n    Columns\n  } = _ref6;\n  const sourceImageMetadata = metadataProvider.get(\"instance\", imageId);\n  if (Rows !== sourceImageMetadata.Rows || Columns !== sourceImageMetadata.Columns) {\n    throw new Error(\"Individual SEG frames have different geometry dimensions (Rows and Columns) \" + \"respect to the source image reference frame. This is not yet supported. \" + \"Aborting segmentation loading. \");\n  }\n};\nconst getArrayOfLabelMapImagesWithSegmentData = _ref7 => {\n  let {\n    arrayOfSegmentData,\n    referencedImageIds\n  } = _ref7;\n  let largestArray = [];\n  for (let i = 0; i < arrayOfSegmentData.length; i++) {\n    const segmentData = arrayOfSegmentData[i];\n    if (segmentData.length > largestArray.length) {\n      largestArray = segmentData;\n    }\n  }\n  return arrayOfSegmentData.map(arr => {\n    const labelMapImages = referencedImageIds.map((referencedImageId, i) => {\n      const hasEmptySegmentData = !arr[i];\n      const labelMapImage = imageLoader.createAndCacheDerivedLabelmapImage(referencedImageId);\n      const pixelData = labelMapImage.getPixelData();\n      if (!hasEmptySegmentData) {\n        for (let j = 0; j < pixelData.length; j++) {\n          pixelData[j] = arr[i][j];\n        }\n      }\n      return labelMapImage;\n    }).filter(Boolean);\n    return labelMapImages;\n  });\n};\nfunction insertOverlappingPixelDataPlanar(_ref8) {\n  let {\n    segmentsOnFrame,\n    labelMapImages,\n    pixelDataChunks,\n    multiframe,\n    referencedImageIds,\n    validOrientations,\n    metadataProvider,\n    tolerance,\n    segmentsPixelIndices,\n    sopUIDImageIdIndexMap,\n    imageIdMaps\n  } = _ref8;\n  const {\n    SharedFunctionalGroupsSequence,\n    PerFrameFunctionalGroupsSequence,\n    Rows,\n    Columns\n  } = multiframe;\n  const sharedImageOrientationPatient = SharedFunctionalGroupsSequence.PlaneOrientationSequence ? SharedFunctionalGroupsSequence.PlaneOrientationSequence.ImageOrientationPatient : undefined;\n  const sliceLength = Columns * Rows;\n  const arrayOfSegmentData = getArrayOfSegmentData({\n    sliceLength,\n    Rows,\n    Columns,\n    validOrientations,\n    metadataProvider,\n    imageIdMaps,\n    segmentsOnFrame,\n    tolerance,\n    pixelDataChunks,\n    PerFrameFunctionalGroupsSequence,\n    labelMapImages,\n    sopUIDImageIdIndexMap,\n    multiframe,\n    sharedImageOrientationPatient,\n    segmentsPixelIndices\n  });\n  const arrayOfLabelMapImagesWithSegmentData = getArrayOfLabelMapImagesWithSegmentData({\n    arrayOfSegmentData,\n    referencedImageIds\n  });\n  return {\n    arrayOfLabelMapImages: arrayOfLabelMapImagesWithSegmentData,\n    hasOverlappingSegments: true\n  };\n}\nconst getArrayOfSegmentData = _ref9 => {\n  let {\n    sliceLength,\n    Rows,\n    Columns,\n    validOrientations,\n    metadataProvider,\n    imageIdMaps,\n    segmentsOnFrame,\n    tolerance,\n    pixelDataChunks,\n    PerFrameFunctionalGroupsSequence,\n    labelMapImages,\n    sopUIDImageIdIndexMap,\n    multiframe,\n    sharedImageOrientationPatient,\n    segmentsPixelIndices\n  } = _ref9;\n  const arrayOfSegmentData = [];\n  const numberOfSegments = multiframe.SegmentSequence.length;\n  for (let currentSegmentIndex = 1; currentSegmentIndex <= numberOfSegments; ++currentSegmentIndex) {\n    const segmentData = getSegmentData({\n      PerFrameFunctionalGroupsSequence,\n      labelMapImages,\n      sopUIDImageIdIndexMap,\n      multiframe,\n      segmentIndex: currentSegmentIndex,\n      sliceLength,\n      Rows,\n      Columns,\n      validOrientations,\n      tolerance,\n      pixelDataChunks,\n      sharedImageOrientationPatient,\n      metadataProvider,\n      imageIdMaps,\n      segmentsOnFrame,\n      segmentsPixelIndices\n    });\n    compactMergeSegmentDataWithoutInformationLoss({\n      arrayOfSegmentData,\n      newSegmentData: segmentData\n    });\n  }\n  return arrayOfSegmentData;\n};\nconst getSegmentData = _ref10 => {\n  let {\n    PerFrameFunctionalGroupsSequence,\n    labelMapImages,\n    sopUIDImageIdIndexMap,\n    multiframe,\n    segmentIndex,\n    sliceLength,\n    Rows,\n    Columns,\n    validOrientations,\n    tolerance,\n    pixelDataChunks,\n    sharedImageOrientationPatient,\n    metadataProvider,\n    imageIdMaps,\n    segmentsOnFrame,\n    segmentsPixelIndices\n  } = _ref10;\n  const segmentData = [];\n  for (let currentLabelMapImageIndex = 0; currentLabelMapImageIndex < labelMapImages.length; currentLabelMapImageIndex++) {\n    const currentLabelMapImage = labelMapImages[currentLabelMapImageIndex];\n    const referencedImageId = currentLabelMapImage.referencedImageId;\n    const PerFrameFunctionalGroupsIndex = PerFrameFunctionalGroupsSequence.findIndex((PerFrameFunctionalGroups, currentSequenceIndex) => {\n      const {\n        segmentIndex: groupsSegmentIndex,\n        referencedImageId: groupsReferenceImageId\n      } = extractInfoFromPerFrameFunctionalGroups({\n        PerFrameFunctionalGroups,\n        sequenceIndex: currentSequenceIndex,\n        sopUIDImageIdIndexMap,\n        multiframe\n      });\n      const isCorrectPerFrameFunctionalGroup = groupsSegmentIndex === segmentIndex && groupsReferenceImageId === currentLabelMapImage.referencedImageId;\n      return isCorrectPerFrameFunctionalGroup;\n    });\n    if (PerFrameFunctionalGroupsIndex === -1) {\n      continue;\n    }\n    const PerFrameFunctionalGroups = PerFrameFunctionalGroupsSequence[PerFrameFunctionalGroupsIndex];\n    const alignedPixelDataI = getAlignedPixelData({\n      sharedImageOrientationPatient,\n      PerFrameFunctionalGroups,\n      pixelDataChunks,\n      sequenceIndex: PerFrameFunctionalGroupsIndex,\n      sliceLength,\n      Rows,\n      Columns,\n      validOrientations,\n      tolerance\n    });\n    checkImageDimensions({\n      metadataProvider,\n      Rows,\n      Columns,\n      imageId: referencedImageId\n    });\n    const indexCache = [];\n    const segmentationDataForImageId = alignedPixelDataI.data.map((pixel, pixelIndex) => {\n      const pixelValue = pixel ? segmentIndex : 0;\n      if (pixelValue) {\n        indexCache.push(pixelIndex);\n      }\n      return pixel ? segmentIndex : 0;\n    });\n    const hasWrittenSegmentationData = indexCache.length > 0;\n    if (hasWrittenSegmentationData) {\n      segmentData[currentLabelMapImageIndex] = segmentationDataForImageId;\n    }\n    const imageIdIndex = imageIdMaps.indices[referencedImageId];\n    updateSegmentsOnFrame({\n      imageIdIndex,\n      segmentIndex,\n      segmentsOnFrame\n    });\n    updateSegmentsPixelIndices({\n      imageIdIndex,\n      segmentIndex,\n      segmentsPixelIndices,\n      indexCache\n    });\n  }\n  return segmentData;\n};\n\nexport { createLabelmapsFromBufferInternal, insertOverlappingPixelDataPlanar, insertPixelDataPlanar };\n","import { generateToolState as generateToolState$1 } from '../../Cornerstone/Segmentation.js';\nimport { createLabelmapsFromBufferInternal } from './labelmapImagesFromBuffer.js';\n\nfunction generateToolState(imageIds, arrayBuffer, metadataProvider) {\n  let skipOverlapping = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  let tolerance = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1e-3;\n  let cs3dVersion = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 4;\n  return generateToolState$1(imageIds, arrayBuffer, metadataProvider, skipOverlapping, tolerance, cs3dVersion);\n}\nfunction createFromDICOMSegBuffer(referencedImageIds, arrayBuffer, _ref) {\n  let {\n    metadataProvider,\n    tolerance = 1e-3\n  } = _ref;\n  return createLabelmapsFromBufferInternal(referencedImageIds, arrayBuffer, metadataProvider, {\n    tolerance\n  });\n}\n\nexport { createFromDICOMSegBuffer, generateToolState };\n","import { CornerstonePMAP } from '../../Cornerstone/index.js';\n\nconst {\n  ParametricMap\n} = CornerstonePMAP;\nconst {\n  generateToolState: generateToolStateCornerstone\n} = ParametricMap;\nfunction generateToolState(imageIds, arrayBuffer, metadataProvider) {\n  let skipOverlapping = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  let tolerance = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1e-3;\n  return generateToolStateCornerstone(imageIds, arrayBuffer, metadataProvider, skipOverlapping, tolerance);\n}\n\nexport { generateToolState };\n","function getReferencedFrameOfReferenceSequence(metadata, metadataProvider, dataset) {\n  const {\n    referencedImageId: imageId,\n    FrameOfReferenceUID\n  } = metadata;\n  const instance = metadataProvider.get(\"instance\", imageId);\n  const {\n    SeriesInstanceUID\n  } = instance;\n  const {\n    ReferencedSeriesSequence\n  } = dataset;\n  return [{\n    FrameOfReferenceUID,\n    RTReferencedStudySequence: [{\n      ReferencedSOPClassUID: dataset.SOPClassUID,\n      ReferencedSOPInstanceUID: dataset.SOPInstanceUID,\n      RTReferencedSeriesSequence: [{\n        SeriesInstanceUID,\n        ContourImageSequence: [...ReferencedSeriesSequence[0].ReferencedInstanceSequence]\n      }]\n    }]\n  }];\n}\n\nexport { getReferencedFrameOfReferenceSequence as default };\n","function getReferencedSeriesSequence(metadata, _index, metadataProvider, DicomMetadataStore) {\n  // grab imageId from toolData\n  const {\n    referencedImageId: imageId\n  } = metadata;\n  const instance = metadataProvider.get(\"instance\", imageId);\n  const {\n    SeriesInstanceUID,\n    StudyInstanceUID\n  } = instance;\n  const ReferencedSeriesSequence = [];\n  if (SeriesInstanceUID) {\n    const series = DicomMetadataStore.getSeries(StudyInstanceUID, SeriesInstanceUID);\n    const ReferencedSeries = {\n      SeriesInstanceUID,\n      ReferencedInstanceSequence: []\n    };\n    series.instances.forEach(instance => {\n      const {\n        SOPInstanceUID,\n        SOPClassUID\n      } = instance;\n      ReferencedSeries.ReferencedInstanceSequence.push({\n        ReferencedSOPClassUID: SOPClassUID,\n        ReferencedSOPInstanceUID: SOPInstanceUID\n      });\n    });\n    ReferencedSeriesSequence.push(ReferencedSeries);\n  }\n  return ReferencedSeriesSequence;\n}\n\nexport { getReferencedSeriesSequence as default };\n","function getStructureSetModule(contour, index) {\n  const {\n    FrameOfReferenceUID\n  } = contour.metadata;\n  return {\n    ROINumber: index + 1,\n    ROIName: contour.name || `Todo: name ${index + 1}`,\n    ROIDescription: `Todo: description ${index + 1}`,\n    ROIGenerationAlgorithm: \"Todo: algorithm\",\n    ReferencedFrameOfReferenceUID: FrameOfReferenceUID\n  };\n}\n\nexport { getStructureSetModule as default };\n","import { utilities } from '@cornerstonejs/tools';\nimport dcmjs from 'dcmjs';\nimport getPatientModule from './utilities/getPatientModule.js';\nimport getReferencedFrameOfReferenceSequence from './utilities/getReferencedFrameOfReferenceSequence.js';\nimport getReferencedSeriesSequence from './utilities/getReferencedSeriesSequence.js';\nimport getRTROIObservationsSequence from './utilities/getRTROIObservationsSequence.js';\nimport getRTSeriesModule from './utilities/getRTSeriesModule.js';\nimport getStructureSetModule from './utilities/getStructureSetModule.js';\n\nconst {\n  generateContourSetsFromLabelmap,\n  AnnotationToPointData\n} = utilities.contours;\nconst {\n  DicomMetaDictionary\n} = dcmjs.data;\nasync function generateRTSSFromSegmentations(segmentations, metadataProvider, DicomMetadataStore) {\n  const roiContours = [];\n  const contourSets = await generateContourSetsFromLabelmap({\n    segmentations\n  });\n  contourSets.forEach((contourSet, segIndex) => {\n    if (contourSet) {\n      const contourSequence = [];\n      contourSet.sliceContours.forEach(sliceContour => {\n        const sopCommon = metadataProvider.get(\"sopCommonModule\", sliceContour.referencedImageId);\n        const ReferencedSOPClassUID = sopCommon.sopClassUID;\n        const ReferencedSOPInstanceUID = sopCommon.sopInstanceUID;\n        const ContourImageSequence = [{\n          ReferencedSOPClassUID,\n          ReferencedSOPInstanceUID\n        }];\n        const sliceContourPolyData = sliceContour.polyData;\n        sliceContour.contours.forEach((contour, index) => {\n          const ContourGeometricType = contour.type;\n          const NumberOfContourPoints = contour.contourPoints.length;\n          const ContourData = [];\n          contour.contourPoints.forEach(point => {\n            const pointData = sliceContourPolyData.points[point];\n            pointData[0] = +pointData[0].toFixed(2);\n            pointData[1] = +pointData[1].toFixed(2);\n            pointData[2] = +pointData[2].toFixed(2);\n            ContourData.push(pointData[0]);\n            ContourData.push(pointData[1]);\n            ContourData.push(pointData[2]);\n          });\n          contourSequence.push({\n            ContourImageSequence,\n            ContourGeometricType,\n            NumberOfContourPoints,\n            ContourNumber: index + 1,\n            ContourData\n          });\n        });\n      });\n      const segLabel = contourSet.label || `Segment ${segIndex + 1}`;\n      const ROIContour = {\n        name: segLabel,\n        description: segLabel,\n        contourSequence,\n        color: contourSet.color,\n        metadata: contourSet.metadata\n      };\n      roiContours.push(ROIContour);\n    }\n  });\n  const rtMetadata = {\n    name: segmentations.label,\n    label: segmentations.label\n  };\n  const dataset = _initializeDataset(rtMetadata, roiContours[0].metadata, metadataProvider);\n  roiContours.forEach((contour, index) => {\n    const roiContour = {\n      ROIDisplayColor: contour.color || [255, 0, 0],\n      ContourSequence: contour.contourSequence,\n      ReferencedROINumber: index + 1\n    };\n    dataset.StructureSetROISequence.push(getStructureSetModule(contour, index));\n    dataset.ROIContourSequence.push(roiContour);\n    dataset.ReferencedSeriesSequence = getReferencedSeriesSequence(contour.metadata, index, metadataProvider, DicomMetadataStore);\n    dataset.ReferencedFrameOfReferenceSequence = getReferencedFrameOfReferenceSequence(contour.metadata, metadataProvider, dataset);\n  });\n  const fileMetaInformationVersionArray = new Uint8Array(2);\n  fileMetaInformationVersionArray[1] = 1;\n  const _meta = {\n    FileMetaInformationVersion: {\n      Value: [fileMetaInformationVersionArray.buffer],\n      vr: \"OB\"\n    },\n    TransferSyntaxUID: {\n      Value: [\"1.2.840.10008.1.2.1\"],\n      vr: \"UI\"\n    },\n    ImplementationClassUID: {\n      Value: [DicomMetaDictionary.uid()],\n      vr: \"UI\"\n    },\n    ImplementationVersionName: {\n      Value: [\"dcmjs\"],\n      vr: \"SH\"\n    }\n  };\n  dataset._meta = _meta;\n  dataset.SpecificCharacterSet = \"ISO_IR 192\";\n  return dataset;\n}\nfunction generateRTSSFromAnnotations(annotations, metadataProvider, DicomMetadataStore) {\n  const rtMetadata = {\n    name: \"RTSS from Annotations\",\n    label: \"RTSS from Annotations\"\n  };\n  const dataset = _initializeDataset(rtMetadata, annotations[0].metadata, metadataProvider);\n  annotations.forEach((annotation, index) => {\n    const ContourSequence = AnnotationToPointData.convert(annotation, index, metadataProvider);\n    dataset.StructureSetROISequence.push(getStructureSetModule(annotation, index));\n    dataset.ROIContourSequence.push(ContourSequence);\n    dataset.RTROIObservationsSequence.push(getRTROIObservationsSequence(annotation, index));\n    dataset.ReferencedSeriesSequence = getReferencedSeriesSequence(annotation.metadata, index, metadataProvider, DicomMetadataStore);\n    dataset.ReferencedFrameOfReferenceSequence = getReferencedFrameOfReferenceSequence(annotation.metadata, metadataProvider, dataset);\n  });\n  const fileMetaInformationVersionArray = new Uint8Array(2);\n  fileMetaInformationVersionArray[1] = 1;\n  const _meta = {\n    FileMetaInformationVersion: {\n      Value: [fileMetaInformationVersionArray.buffer],\n      vr: \"OB\"\n    },\n    TransferSyntaxUID: {\n      Value: [\"1.2.840.10008.1.2.1\"],\n      vr: \"UI\"\n    },\n    ImplementationClassUID: {\n      Value: [DicomMetaDictionary.uid()],\n      vr: \"UI\"\n    },\n    ImplementationVersionName: {\n      Value: [\"dcmjs\"],\n      vr: \"SH\"\n    }\n  };\n  dataset._meta = _meta;\n  dataset.SpecificCharacterSet = \"ISO_IR 192\";\n  return dataset;\n}\nfunction _initializeDataset(rtMetadata, imgMetadata, metadataProvider) {\n  const rtSOPInstanceUID = DicomMetaDictionary.uid();\n  const {\n    referencedImageId: imageId,\n    FrameOfReferenceUID\n  } = imgMetadata;\n  const {\n    studyInstanceUID\n  } = metadataProvider.get(\"generalSeriesModule\", imageId);\n  const patientModule = getPatientModule(imageId, metadataProvider);\n  const rtSeriesModule = getRTSeriesModule(DicomMetaDictionary);\n  return {\n    StructureSetROISequence: [],\n    ROIContourSequence: [],\n    RTROIObservationsSequence: [],\n    ReferencedSeriesSequence: [],\n    ReferencedFrameOfReferenceSequence: [],\n    ...patientModule,\n    ...rtSeriesModule,\n    StudyInstanceUID: studyInstanceUID,\n    SOPClassUID: \"1.2.840.10008.5.1.4.1.1.481.3\",\n    SOPInstanceUID: rtSOPInstanceUID,\n    Manufacturer: \"dcmjs\",\n    Modality: \"RTSTRUCT\",\n    FrameOfReferenceUID,\n    PositionReferenceIndicator: \"\",\n    StructureSetLabel: rtMetadata.label || \"\",\n    StructureSetName: rtMetadata.name || \"\",\n    ReferringPhysicianName: \"\",\n    OperatorsName: \"\",\n    StructureSetDate: DicomMetaDictionary.date(),\n    StructureSetTime: DicomMetaDictionary.time(),\n    _meta: null\n  };\n}\n\nexport { generateRTSSFromAnnotations, generateRTSSFromSegmentations };\n","function getRTROIObservationsSequence(toolData, index) {\n  return {\n    ObservationNumber: index + 1,\n    ReferencedROINumber: index + 1,\n    RTROIInterpretedType: \"Todo: type\",\n    ROIInterpreter: \"Todo: interpreter\"\n  };\n}\n\nexport { getRTROIObservationsSequence as default };\n","function getPatientModule(imageId, metadataProvider) {\n  const generalSeriesModule = metadataProvider.get(\"generalSeriesModule\", imageId);\n  const generalStudyModule = metadataProvider.get(\"generalStudyModule\", imageId);\n  const patientStudyModule = metadataProvider.get(\"patientStudyModule\", imageId);\n  const patientModule = metadataProvider.get(\"patientModule\", imageId);\n  const patientDemographicModule = metadataProvider.get(\"patientDemographicModule\", imageId);\n  return {\n    Modality: generalSeriesModule.modality,\n    PatientID: patientModule.patientId,\n    PatientName: patientModule.patientName,\n    PatientBirthDate: \"\",\n    PatientAge: patientStudyModule.patientAge,\n    PatientSex: patientDemographicModule.patientSex,\n    PatientWeight: patientStudyModule.patientWeight,\n    StudyDate: generalStudyModule.studyDate,\n    StudyTime: generalStudyModule.studyTime,\n    StudyID: \"ToDo\",\n    AccessionNumber: generalStudyModule.accessionNumber\n  };\n}\n\nexport { getPatientModule as default };\n","function getRTSeriesModule(DicomMetaDictionary) {\n  return {\n    SeriesInstanceUID: DicomMetaDictionary.uid(),\n    // generate a new series instance uid\n    SeriesNumber: \"99\" // Todo:: what should be the series number?\n  };\n}\n\nexport { getRTSeriesModule as default };\n","import { utilities } from '@cornerstonejs/tools';\nexport { generateRTSSFromAnnotations, generateRTSSFromSegmentations } from './RTSS.js';\n\nconst {\n  generateContourSetsFromLabelmap\n} = utilities.contours;\n\nexport { generateContourSetsFromLabelmap };\n","import { utilities } from 'dcmjs';\nimport Probe from './Probe.js';\n\nvar _KeyImage;\nconst {\n  Point: TID300Point\n} = utilities.TID300;\nclass KeyImage extends Probe {\n  static getMeasurementData(measurementGroup, sopInstanceUIDToImageIdMap, imageToWorldCoords, metadata, trackingIdentifier) {\n    const baseData = super.getMeasurementData(measurementGroup, sopInstanceUIDToImageIdMap, imageToWorldCoords, metadata, trackingIdentifier);\n    const {\n      data\n    } = baseData.annotation;\n    data.isPoint = trackingIdentifier.indexOf(\"Point\") !== -1;\n    return baseData;\n  }\n  static getTID300RepresentationArguments(tool, worldToImageCoords) {\n    const tid300Arguments = super.getTID300RepresentationArguments(tool, worldToImageCoords);\n    const {\n      data\n    } = tool;\n    if (data.isPoint) {\n      if (data.seriesLevel) {\n        tid300Arguments.trackingIdentifierTextValue = this.trackingSeriesPointIdentifier;\n      } else {\n        tid300Arguments.trackingIdentifierTextValue = this.trackingPointIdentifier;\n      }\n    }\n    if (data.seriesLevel) {\n      tid300Arguments.trackingIdentifierTextValue = this.trackingSeriesIdentifier;\n    }\n    if (!tid300Arguments.points.length) {\n      tid300Arguments.points.push({\n        x: 0,\n        y: 0\n      });\n    }\n    return tid300Arguments;\n  }\n}\n_KeyImage = KeyImage;\n_KeyImage.init(\"KeyImage\", TID300Point, {\n  parentType: Probe.toolType\n});\n_KeyImage.trackingSeriesIdentifier = `${_KeyImage.trackingIdentifierTextValue}:Series`;\n_KeyImage.trackingPointIdentifier = `${_KeyImage.trackingIdentifierTextValue}:Point`;\n_KeyImage.trackingSeriesPointIdentifier = `${_KeyImage.trackingIdentifierTextValue}:SeriesPoint`;\n\nexport { KeyImage, KeyImage as default };\n","import MeasurementReport from './MeasurementReport.js';\nimport CodingScheme from './CodingScheme.js';\nimport CORNERSTONE_3D_TAG from './cornerstone3DTag.js';\nimport ArrowAnnotate from './ArrowAnnotate.js';\nimport Bidirectional from './Bidirectional.js';\nimport Angle from './Angle.js';\nimport CobbAngle from './CobbAngle.js';\nimport CircleROI from './CircleROI.js';\nimport EllipticalROI from './EllipticalROI.js';\nimport RectangleROI from './RectangleROI.js';\nimport Length from './Length.js';\nimport PlanarFreehandROI from './PlanarFreehandROI.js';\nimport Probe from './Probe.js';\nimport UltrasoundDirectional from './UltrasoundDirectional.js';\nimport BaseAdapter3D from './BaseAdapter3D.js';\nimport * as index from './Segmentation/index.js';\nimport * as index$1 from './ParametricMap/index.js';\nimport * as index$2 from './RTStruct/index.js';\nimport KeyImage from './KeyImage.js';\n\nconst Cornerstone3DSR = {\n  BaseAdapter3D,\n  Bidirectional,\n  CobbAngle,\n  Angle,\n  Length,\n  CircleROI,\n  EllipticalROI,\n  RectangleROI,\n  ArrowAnnotate,\n  Probe,\n  PlanarFreehandROI,\n  UltrasoundDirectional,\n  KeyImage,\n  MeasurementReport,\n  CodeScheme: CodingScheme,\n  CORNERSTONE_3D_TAG\n};\nconst Cornerstone3DSEG = {\n  Segmentation: index\n};\nconst Cornerstone3DPMAP = {\n  ParametricMap: index$1\n};\nconst Cornerstone3DRT = {\n  RTSS: index$2\n};\n\nexport { Cornerstone3DPMAP, Cornerstone3DRT, Cornerstone3DSEG, Cornerstone3DSR };\n","import { data } from 'dcmjs';\n\nconst {\n  Colors,\n  BitArray\n} = data;\n\n// TODO: Is there a better name for this? RGBAInt?\n// Should we move it to Colors.js\nfunction dicomlab2RGBA(cielab) {\n  const rgba = Colors.dicomlab2RGB(cielab).map(x => Math.round(x * 255));\n  rgba.push(255);\n  return rgba;\n}\n\n// TODO: Copied these functions in from VTK Math so we don't need a dependency.\n// I guess we should put them somewhere\n// https://github.com/Kitware/vtk-js/blob/master/Sources/Common/Core/Math/index.js\nfunction cross(x, y, out) {\n  const Zx = x[1] * y[2] - x[2] * y[1];\n  const Zy = x[2] * y[0] - x[0] * y[2];\n  const Zz = x[0] * y[1] - x[1] * y[0];\n  out[0] = Zx;\n  out[1] = Zy;\n  out[2] = Zz;\n}\nfunction norm(x) {\n  let n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 3;\n  switch (n) {\n    case 1:\n      return Math.abs(x);\n    case 2:\n      return Math.sqrt(x[0] * x[0] + x[1] * x[1]);\n    case 3:\n      return Math.sqrt(x[0] * x[0] + x[1] * x[1] + x[2] * x[2]);\n    default:\n      {\n        let sum = 0;\n        for (let i = 0; i < n; i++) {\n          sum += x[i] * x[i];\n        }\n        return Math.sqrt(sum);\n      }\n  }\n}\nfunction normalize(x) {\n  const den = norm(x);\n  if (den !== 0.0) {\n    x[0] /= den;\n    x[1] /= den;\n    x[2] /= den;\n  }\n  return den;\n}\nfunction subtract(a, b, out) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  out[2] = a[2] - b[2];\n}\n\n// TODO: This is a useful utility on its own. We should move it somewhere?\n// dcmjs.adapters.vtk.Multiframe? dcmjs.utils?\nfunction geometryFromFunctionalGroups(dataset, PerFrameFunctionalGroups) {\n  const geometry = {};\n  const pixelMeasures = dataset.SharedFunctionalGroupsSequence.PixelMeasuresSequence;\n  const planeOrientation = dataset.SharedFunctionalGroupsSequence.PlaneOrientationSequence;\n\n  // Find the origin of the volume from the PerFrameFunctionalGroups' ImagePositionPatient values\n  //\n  // TODO: assumes sorted frames. This should read the ImagePositionPatient from each frame and\n  // sort them to obtain the first and last position along the acquisition axis.\n  const firstFunctionalGroup = PerFrameFunctionalGroups[0];\n  const lastFunctionalGroup = PerFrameFunctionalGroups[PerFrameFunctionalGroups.length - 1];\n  const firstPosition = firstFunctionalGroup.PlanePositionSequence.ImagePositionPatient.map(Number);\n  const lastPosition = lastFunctionalGroup.PlanePositionSequence.ImagePositionPatient.map(Number);\n  geometry.origin = firstPosition;\n\n  // NB: DICOM PixelSpacing is defined as Row then Column,\n  // unlike ImageOrientationPatient\n  geometry.spacing = [pixelMeasures.PixelSpacing[1], pixelMeasures.PixelSpacing[0], pixelMeasures.SpacingBetweenSlices].map(Number);\n  geometry.dimensions = [dataset.Columns, dataset.Rows, PerFrameFunctionalGroups.length].map(Number);\n  const orientation = planeOrientation.ImageOrientationPatient.map(Number);\n  const columnStepToPatient = orientation.slice(0, 3);\n  const rowStepToPatient = orientation.slice(3, 6);\n  geometry.planeNormal = [];\n  cross(columnStepToPatient, rowStepToPatient, geometry.planeNormal);\n  geometry.sliceStep = [];\n  subtract(lastPosition, firstPosition, geometry.sliceStep);\n  normalize(geometry.sliceStep);\n  geometry.direction = columnStepToPatient.concat(rowStepToPatient).concat(geometry.sliceStep);\n  return geometry;\n}\nclass Segmentation {\n  constructor() {}\n\n  /**\n   * Produces an array of Segments from an input DICOM Segmentation dataset\n   *\n   * Segments are returned with Geometry values that can be used to create\n   * VTK Image Data objects.\n   *\n   * @example Example usage to create VTK Volume actors from each segment:\n   *\n   * const actors = [];\n   * const segments = generateToolState(dataset);\n   * segments.forEach(segment => {\n   *   // now make actors using the segment information\n   *   const scalarArray = vtk.Common.Core.vtkDataArray.newInstance({\n   *        name: \"Scalars\",\n   *        numberOfComponents: 1,\n   *        values: segment.pixelData,\n   *    });\n   *\n   *    const imageData = vtk.Common.DataModel.vtkImageData.newInstance();\n   *    imageData.getPointData().setScalars(scalarArray);\n   *    imageData.setDimensions(geometry.dimensions);\n   *    imageData.setSpacing(geometry.spacing);\n   *    imageData.setOrigin(geometry.origin);\n   *    imageData.setDirection(geometry.direction);\n   *\n   *    const mapper = vtk.Rendering.Core.vtkVolumeMapper.newInstance();\n   *    mapper.setInputData(imageData);\n   *    mapper.setSampleDistance(2.);\n   *\n   *    const actor = vtk.Rendering.Core.vtkVolume.newInstance();\n   *    actor.setMapper(mapper);\n   *\n   *    actors.push(actor);\n   * });\n   *\n   * @param dataset\n   * @return {{}}\n   */\n  static generateSegments(dataset) {\n    if (dataset.SegmentSequence.constructor.name !== \"Array\") {\n      dataset.SegmentSequence = [dataset.SegmentSequence];\n    }\n    dataset.SegmentSequence.forEach(segment => {\n      // TODO: other interesting fields could be extracted from the segment\n      // TODO: Read SegmentsOverlay field\n      // http://dicom.nema.org/medical/dicom/current/output/chtml/part03/sect_C.8.20.2.html\n\n      // TODO: Looks like vtkColor only wants RGB in 0-1 values.\n      // Why was this example converting to RGBA with 0-255 values?\n      const color = dicomlab2RGBA(segment.RecommendedDisplayCIELabValue);\n      segments[segment.SegmentNumber] = {\n        color,\n        functionalGroups: [],\n        offset: null,\n        size: null,\n        pixelData: null\n      };\n    });\n\n    // make a list of functional groups per segment\n    dataset.PerFrameFunctionalGroupsSequence.forEach(functionalGroup => {\n      const segmentNumber = functionalGroup.SegmentIdentificationSequence.ReferencedSegmentNumber;\n      segments[segmentNumber].functionalGroups.push(functionalGroup);\n    });\n\n    // determine per-segment index into the pixel data\n    // TODO: only handles one-bit-per pixel\n    const frameSize = Math.ceil(dataset.Rows * dataset.Columns / 8);\n    let nextOffset = 0;\n    Object.keys(segments).forEach(segmentNumber => {\n      const segment = segments[segmentNumber];\n      segment.numberOfFrames = segment.functionalGroups.length;\n      segment.size = segment.numberOfFrames * frameSize;\n      segment.offset = nextOffset;\n      nextOffset = segment.offset + segment.size;\n      const packedSegment = dataset.PixelData.slice(segment.offset, nextOffset);\n      segment.pixelData = BitArray.unpack(packedSegment);\n      const geometry = geometryFromFunctionalGroups(dataset, segment.functionalGroups);\n      segment.geometry = geometry;\n    });\n    return segments;\n  }\n}\n\nexport { Segmentation as default };\n","import Segmentation from './Segmentation.js';\n\nconst VTKjsSEG = {\n  Segmentation\n};\n\nexport { VTKjsSEG };\n","import { CornerstoneSR, CornerstoneSEG, CornerstonePMAP } from './Cornerstone/index.js';\nimport { Cornerstone3DSR, Cornerstone3DSEG, Cornerstone3DPMAP, Cornerstone3DRT } from './Cornerstone3D/index.js';\nimport { VTKjsSEG } from './VTKjs/index.js';\nimport './enums/Events.js';\nimport 'dcmjs';\nimport 'buffer';\n\nconst adaptersSR = {\n  Cornerstone: CornerstoneSR,\n  Cornerstone3D: Cornerstone3DSR\n};\nconst adaptersSEG = {\n  Cornerstone: CornerstoneSEG,\n  Cornerstone3D: Cornerstone3DSEG,\n  VTKjs: VTKjsSEG\n};\nconst adaptersPMAP = {\n  Cornerstone: CornerstonePMAP,\n  Cornerstone3D: Cornerstone3DPMAP\n};\nconst adaptersRT = {\n  Cornerstone3D: Cornerstone3DRT\n};\n\nexport { adaptersPMAP, adaptersRT, adaptersSEG, adaptersSR };\n","import { data } from 'dcmjs';\nimport { Buffer } from 'buffer';\n\nconst {\n  datasetToDict\n} = data;\nfunction downloadDICOMData(bufferOrDataset, filename) {\n  let blob;\n  if (bufferOrDataset instanceof ArrayBuffer) {\n    blob = new Blob([bufferOrDataset], {\n      type: \"application/dicom\"\n    });\n  } else {\n    if (!bufferOrDataset._meta) {\n      throw new Error(\"Dataset must have a _meta property\");\n    }\n    const buffer = Buffer.from(datasetToDict(bufferOrDataset).write());\n    blob = new Blob([buffer], {\n      type: \"application/dicom\"\n    });\n  }\n  const link = document.createElement(\"a\");\n  link.href = window.URL.createObjectURL(blob);\n  link.download = filename;\n  link.click();\n}\n\nexport { downloadDICOMData };\n","var ChangeTypes;\n(function (ChangeTypes) {\n    ChangeTypes[\"Interaction\"] = \"Interaction\";\n    ChangeTypes[\"HandlesUpdated\"] = \"HandlesUpdated\";\n    ChangeTypes[\"StatsUpdated\"] = \"StatsUpdated\";\n    ChangeTypes[\"InitialSetup\"] = \"InitialSetup\";\n    ChangeTypes[\"Completed\"] = \"Completed\";\n    ChangeTypes[\"InterpolationUpdated\"] = \"InterpolationUpdated\";\n    ChangeTypes[\"History\"] = \"History\";\n    ChangeTypes[\"MetadataReferenceModified\"] = \"MetadataReferenceModified\";\n    ChangeTypes[\"LabelChange\"] = \"LabelChange\";\n})(ChangeTypes || (ChangeTypes = {}));\nexport default ChangeTypes;\n","var Events;\n(function (Events) {\n    Events[\"TOOL_ACTIVATED\"] = \"CORNERSTONE_TOOLS_TOOL_ACTIVATED\";\n    Events[\"TOOLGROUP_VIEWPORT_ADDED\"] = \"CORNERSTONE_TOOLS_TOOLGROUP_VIEWPORT_ADDED\";\n    Events[\"TOOLGROUP_VIEWPORT_REMOVED\"] = \"CORNERSTONE_TOOLS_TOOLGROUP_VIEWPORT_REMOVED\";\n    Events[\"TOOL_MODE_CHANGED\"] = \"CORNERSTONE_TOOLS_TOOL_MODE_CHANGED\";\n    Events[\"CROSSHAIR_TOOL_CENTER_CHANGED\"] = \"CORNERSTONE_TOOLS_CROSSHAIR_TOOL_CENTER_CHANGED\";\n    Events[\"ANNOTATION_ADDED\"] = \"CORNERSTONE_TOOLS_ANNOTATION_ADDED\";\n    Events[\"ANNOTATION_COMPLETED\"] = \"CORNERSTONE_TOOLS_ANNOTATION_COMPLETED\";\n    Events[\"ANNOTATION_MODIFIED\"] = \"CORNERSTONE_TOOLS_ANNOTATION_MODIFIED\";\n    Events[\"ANNOTATION_REMOVED\"] = \"CORNERSTONE_TOOLS_ANNOTATION_REMOVED\";\n    Events[\"ANNOTATION_SELECTION_CHANGE\"] = \"CORNERSTONE_TOOLS_ANNOTATION_SELECTION_CHANGE\";\n    Events[\"ANNOTATION_LOCK_CHANGE\"] = \"CORNERSTONE_TOOLS_ANNOTATION_LOCK_CHANGE\";\n    Events[\"ANNOTATION_VISIBILITY_CHANGE\"] = \"CORNERSTONE_TOOLS_ANNOTATION_VISIBILITY_CHANGE\";\n    Events[\"ANNOTATION_RENDERED\"] = \"CORNERSTONE_TOOLS_ANNOTATION_RENDERED\";\n    Events[\"ANNOTATION_INTERPOLATION_PROCESS_COMPLETED\"] = \"CORNERSTONE_TOOLS_ANNOTATION_INTERPOLATION_PROCESS_COMPLETED\";\n    Events[\"INTERPOLATED_ANNOTATIONS_REMOVED\"] = \"CORNERSTONE_TOOLS_INTERPOLATED_ANNOTATIONS_REMOVED\";\n    Events[\"SEGMENTATION_MODIFIED\"] = \"CORNERSTONE_TOOLS_SEGMENTATION_MODIFIED\";\n    Events[\"SEGMENTATION_RENDERED\"] = \"CORNERSTONE_TOOLS_SEGMENTATION_RENDERED\";\n    Events[\"SEGMENTATION_REPRESENTATION_ADDED\"] = \"CORNERSTONE_TOOLS_SEGMENTATION_REPRESENTATION_ADDED\";\n    Events[\"SEGMENTATION_ADDED\"] = \"CORNERSTONE_TOOLS_SEGMENTATION_ADDED\";\n    Events[\"SEGMENTATION_REPRESENTATION_MODIFIED\"] = \"CORNERSTONE_TOOLS_SEGMENTATION_REPRESENTATION_MODIFIED\";\n    Events[\"SEGMENTATION_REMOVED\"] = \"CORNERSTONE_TOOLS_SEGMENTATION_REMOVED\";\n    Events[\"SEGMENTATION_REPRESENTATION_REMOVED\"] = \"CORNERSTONE_TOOLS_SEGMENTATION_REPRESENTATION_REMOVED\";\n    Events[\"SEGMENTATION_DATA_MODIFIED\"] = \"CORNERSTONE_TOOLS_SEGMENTATION_DATA_MODIFIED\";\n    Events[\"HISTORY_UNDO\"] = \"CORNERSTONE_TOOLS_HISTORY_UNDO\";\n    Events[\"HISTORY_REDO\"] = \"CORNERSTONE_TOOLS_HISTORY_REDO\";\n    Events[\"KEY_DOWN\"] = \"CORNERSTONE_TOOLS_KEY_DOWN\";\n    Events[\"KEY_UP\"] = \"CORNERSTONE_TOOLS_KEY_UP\";\n    Events[\"MOUSE_DOWN\"] = \"CORNERSTONE_TOOLS_MOUSE_DOWN\";\n    Events[\"MOUSE_UP\"] = \"CORNERSTONE_TOOLS_MOUSE_UP\";\n    Events[\"MOUSE_DOWN_ACTIVATE\"] = \"CORNERSTONE_TOOLS_MOUSE_DOWN_ACTIVATE\";\n    Events[\"MOUSE_DRAG\"] = \"CORNERSTONE_TOOLS_MOUSE_DRAG\";\n    Events[\"MOUSE_MOVE\"] = \"CORNERSTONE_TOOLS_MOUSE_MOVE\";\n    Events[\"MOUSE_CLICK\"] = \"CORNERSTONE_TOOLS_MOUSE_CLICK\";\n    Events[\"MOUSE_DOUBLE_CLICK\"] = \"CORNERSTONE_TOOLS_MOUSE_DOUBLE_CLICK\";\n    Events[\"MOUSE_WHEEL\"] = \"CORNERSTONE_TOOLS_MOUSE_WHEEL\";\n    Events[\"TOUCH_START\"] = \"CORNERSTONE_TOOLS_TOUCH_START\";\n    Events[\"TOUCH_START_ACTIVATE\"] = \"CORNERSTONE_TOOLS_TOUCH_START_ACTIVATE\";\n    Events[\"TOUCH_PRESS\"] = \"CORNERSTONE_TOOLS_TOUCH_PRESS\";\n    Events[\"TOUCH_DRAG\"] = \"CORNERSTONE_TOOLS_TOUCH_DRAG\";\n    Events[\"TOUCH_END\"] = \"CORNERSTONE_TOOLS_TOUCH_END\";\n    Events[\"TOUCH_TAP\"] = \"CORNERSTONE_TOOLS_TAP\";\n    Events[\"TOUCH_SWIPE\"] = \"CORNERSTONE_TOOLS_SWIPE\";\n})(Events || (Events = {}));\nexport default Events;\n","var SegmentationRepresentations;\n(function (SegmentationRepresentations) {\n    SegmentationRepresentations[\"Labelmap\"] = \"Labelmap\";\n    SegmentationRepresentations[\"Contour\"] = \"Contour\";\n    SegmentationRepresentations[\"Surface\"] = \"Surface\";\n})(SegmentationRepresentations || (SegmentationRepresentations = {}));\nexport default SegmentationRepresentations;\n","var StrategyCallbacks;\n(function (StrategyCallbacks) {\n    StrategyCallbacks[\"OnInteractionStart\"] = \"onInteractionStart\";\n    StrategyCallbacks[\"OnInteractionEnd\"] = \"onInteractionEnd\";\n    StrategyCallbacks[\"Preview\"] = \"preview\";\n    StrategyCallbacks[\"RejectPreview\"] = \"rejectPreview\";\n    StrategyCallbacks[\"AcceptPreview\"] = \"acceptPreview\";\n    StrategyCallbacks[\"Fill\"] = \"fill\";\n    StrategyCallbacks[\"Interpolate\"] = \"interpolate\";\n    StrategyCallbacks[\"StrategyFunction\"] = \"strategyFunction\";\n    StrategyCallbacks[\"CreateIsInThreshold\"] = \"createIsInThreshold\";\n    StrategyCallbacks[\"Initialize\"] = \"initialize\";\n    StrategyCallbacks[\"INTERNAL_setValue\"] = \"setValue\";\n    StrategyCallbacks[\"AddPreview\"] = \"addPreview\";\n    StrategyCallbacks[\"ComputeInnerCircleRadius\"] = \"computeInnerCircleRadius\";\n    StrategyCallbacks[\"GetStatistics\"] = \"getStatistics\";\n    StrategyCallbacks[\"EnsureImageVolumeFor3DManipulation\"] = \"ensureImageVolumeFor3DManipulation\";\n    StrategyCallbacks[\"EnsureSegmentationVolumeFor3DManipulation\"] = \"ensureSegmentationVolumeFor3DManipulation\";\n})(StrategyCallbacks || (StrategyCallbacks = {}));\nexport default StrategyCallbacks;\n","var MouseBindings;\n(function (MouseBindings) {\n    MouseBindings[MouseBindings[\"Primary\"] = 1] = \"Primary\";\n    MouseBindings[MouseBindings[\"Secondary\"] = 2] = \"Secondary\";\n    MouseBindings[MouseBindings[\"Primary_And_Secondary\"] = 3] = \"Primary_And_Secondary\";\n    MouseBindings[MouseBindings[\"Auxiliary\"] = 4] = \"Auxiliary\";\n    MouseBindings[MouseBindings[\"Primary_And_Auxiliary\"] = 5] = \"Primary_And_Auxiliary\";\n    MouseBindings[MouseBindings[\"Secondary_And_Auxiliary\"] = 6] = \"Secondary_And_Auxiliary\";\n    MouseBindings[MouseBindings[\"Primary_And_Secondary_And_Auxiliary\"] = 7] = \"Primary_And_Secondary_And_Auxiliary\";\n    MouseBindings[MouseBindings[\"Fourth_Button\"] = 8] = \"Fourth_Button\";\n    MouseBindings[MouseBindings[\"Fifth_Button\"] = 16] = \"Fifth_Button\";\n    MouseBindings[MouseBindings[\"Wheel\"] = 524288] = \"Wheel\";\n    MouseBindings[MouseBindings[\"Wheel_Primary\"] = 524289] = \"Wheel_Primary\";\n})(MouseBindings || (MouseBindings = {}));\nvar KeyboardBindings;\n(function (KeyboardBindings) {\n    KeyboardBindings[KeyboardBindings[\"Shift\"] = 16] = \"Shift\";\n    KeyboardBindings[KeyboardBindings[\"Ctrl\"] = 17] = \"Ctrl\";\n    KeyboardBindings[KeyboardBindings[\"Alt\"] = 18] = \"Alt\";\n    KeyboardBindings[KeyboardBindings[\"Meta\"] = 91] = \"Meta\";\n    KeyboardBindings[KeyboardBindings[\"ShiftCtrl\"] = 1617] = \"ShiftCtrl\";\n    KeyboardBindings[KeyboardBindings[\"ShiftAlt\"] = 1618] = \"ShiftAlt\";\n    KeyboardBindings[KeyboardBindings[\"ShiftMeta\"] = 1691] = \"ShiftMeta\";\n    KeyboardBindings[KeyboardBindings[\"CtrlAlt\"] = 1718] = \"CtrlAlt\";\n    KeyboardBindings[KeyboardBindings[\"CtrlMeta\"] = 1791] = \"CtrlMeta\";\n    KeyboardBindings[KeyboardBindings[\"AltMeta\"] = 1891] = \"AltMeta\";\n})(KeyboardBindings || (KeyboardBindings = {}));\nexport { MouseBindings, KeyboardBindings };\n","var ToolModes;\n(function (ToolModes) {\n    ToolModes[\"Active\"] = \"Active\";\n    ToolModes[\"Passive\"] = \"Passive\";\n    ToolModes[\"Enabled\"] = \"Enabled\";\n    ToolModes[\"Disabled\"] = \"Disabled\";\n})(ToolModes || (ToolModes = {}));\nexport default ToolModes;\n","var Swipe;\n(function (Swipe) {\n    Swipe[\"UP\"] = \"UP\";\n    Swipe[\"DOWN\"] = \"DOWN\";\n    Swipe[\"LEFT\"] = \"LEFT\";\n    Swipe[\"RIGHT\"] = \"RIGHT\";\n})(Swipe || (Swipe = {}));\nexport { Swipe };\n","var AnnotationStyleStates;\n(function (AnnotationStyleStates) {\n    AnnotationStyleStates[\"Default\"] = \"\";\n    AnnotationStyleStates[\"Highlighted\"] = \"Highlighted\";\n    AnnotationStyleStates[\"Selected\"] = \"Selected\";\n    AnnotationStyleStates[\"Locked\"] = \"Locked\";\n    AnnotationStyleStates[\"AutoGenerated\"] = \"AutoGenerated\";\n})(AnnotationStyleStates || (AnnotationStyleStates = {}));\nexport default AnnotationStyleStates;\n","var ChangeTypes;\n(function (ChangeTypes) {\n    ChangeTypes[\"POLYSEG_CONTOUR_TO_LABELMAP\"] = \"Converting Contour to Labelmap\";\n    ChangeTypes[\"POLYSEG_SURFACE_TO_LABELMAP\"] = \"Converting Surfaces to Labelmap\";\n    ChangeTypes[\"POLYSEG_CONTOUR_TO_SURFACE\"] = \"Converting Contour to Surface\";\n    ChangeTypes[\"POLYSEG_LABELMAP_TO_SURFACE\"] = \"Converting Labelmap to Surface\";\n    ChangeTypes[\"SURFACE_CLIPPING\"] = \"Clipping Surfaces\";\n    ChangeTypes[\"COMPUTE_STATISTICS\"] = \"Computing Statistics\";\n    ChangeTypes[\"INTERPOLATE_LABELMAP\"] = \"Interpolating Labelmap\";\n    ChangeTypes[\"COMPUTE_LARGEST_BIDIRECTIONAL\"] = \"Computing Largest Bidirectional\";\n    ChangeTypes[\"GENERATE_CONTOUR_SETS\"] = \"Generating Contour Sets\";\n})(ChangeTypes || (ChangeTypes = {}));\nexport default ChangeTypes;\n","\"use strict\"\n\nfunction iota(n) {\n  var result = new Array(n)\n  for(var i=0; i<n; ++i) {\n    result[i] = i\n  }\n  return result\n}\n\nmodule.exports = iota","/*!\n * Determine if an object is a Buffer\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n\nmodule.exports = function isBuffer (obj) {\n  return obj != null && obj.constructor != null &&\n    typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)\n}\n","var iota = require(\"iota-array\")\nvar isBuffer = require(\"is-buffer\")\n\nvar hasTypedArrays  = ((typeof Float64Array) !== \"undefined\")\n\nfunction compare1st(a, b) {\n  return a[0] - b[0]\n}\n\nfunction order() {\n  var stride = this.stride\n  var terms = new Array(stride.length)\n  var i\n  for(i=0; i<terms.length; ++i) {\n    terms[i] = [Math.abs(stride[i]), i]\n  }\n  terms.sort(compare1st)\n  var result = new Array(terms.length)\n  for(i=0; i<result.length; ++i) {\n    result[i] = terms[i][1]\n  }\n  return result\n}\n\nfunction compileConstructor(dtype, dimension) {\n  var className = [\"View\", dimension, \"d\", dtype].join(\"\")\n  if(dimension < 0) {\n    className = \"View_Nil\" + dtype\n  }\n  var useGetters = (dtype === \"generic\")\n\n  if(dimension === -1) {\n    //Special case for trivial arrays\n    var code =\n      \"function \"+className+\"(a){this.data=a;};\\\nvar proto=\"+className+\".prototype;\\\nproto.dtype='\"+dtype+\"';\\\nproto.index=function(){return -1};\\\nproto.size=0;\\\nproto.dimension=-1;\\\nproto.shape=proto.stride=proto.order=[];\\\nproto.lo=proto.hi=proto.transpose=proto.step=\\\nfunction(){return new \"+className+\"(this.data);};\\\nproto.get=proto.set=function(){};\\\nproto.pick=function(){return null};\\\nreturn function construct_\"+className+\"(a){return new \"+className+\"(a);}\"\n    var procedure = new Function(code)\n    return procedure()\n  } else if(dimension === 0) {\n    //Special case for 0d arrays\n    var code =\n      \"function \"+className+\"(a,d) {\\\nthis.data = a;\\\nthis.offset = d\\\n};\\\nvar proto=\"+className+\".prototype;\\\nproto.dtype='\"+dtype+\"';\\\nproto.index=function(){return this.offset};\\\nproto.dimension=0;\\\nproto.size=1;\\\nproto.shape=\\\nproto.stride=\\\nproto.order=[];\\\nproto.lo=\\\nproto.hi=\\\nproto.transpose=\\\nproto.step=function \"+className+\"_copy() {\\\nreturn new \"+className+\"(this.data,this.offset)\\\n};\\\nproto.pick=function \"+className+\"_pick(){\\\nreturn TrivialArray(this.data);\\\n};\\\nproto.valueOf=proto.get=function \"+className+\"_get(){\\\nreturn \"+(useGetters ? \"this.data.get(this.offset)\" : \"this.data[this.offset]\")+\n\"};\\\nproto.set=function \"+className+\"_set(v){\\\nreturn \"+(useGetters ? \"this.data.set(this.offset,v)\" : \"this.data[this.offset]=v\")+\"\\\n};\\\nreturn function construct_\"+className+\"(a,b,c,d){return new \"+className+\"(a,d)}\"\n    var procedure = new Function(\"TrivialArray\", code)\n    return procedure(CACHED_CONSTRUCTORS[dtype][0])\n  }\n\n  var code = [\"'use strict'\"]\n\n  //Create constructor for view\n  var indices = iota(dimension)\n  var args = indices.map(function(i) { return \"i\"+i })\n  var index_str = \"this.offset+\" + indices.map(function(i) {\n        return \"this.stride[\" + i + \"]*i\" + i\n      }).join(\"+\")\n  var shapeArg = indices.map(function(i) {\n      return \"b\"+i\n    }).join(\",\")\n  var strideArg = indices.map(function(i) {\n      return \"c\"+i\n    }).join(\",\")\n  code.push(\n    \"function \"+className+\"(a,\" + shapeArg + \",\" + strideArg + \",d){this.data=a\",\n      \"this.shape=[\" + shapeArg + \"]\",\n      \"this.stride=[\" + strideArg + \"]\",\n      \"this.offset=d|0}\",\n    \"var proto=\"+className+\".prototype\",\n    \"proto.dtype='\"+dtype+\"'\",\n    \"proto.dimension=\"+dimension)\n\n  //view.size:\n  code.push(\"Object.defineProperty(proto,'size',{get:function \"+className+\"_size(){\\\nreturn \"+indices.map(function(i) { return \"this.shape[\"+i+\"]\" }).join(\"*\"),\n\"}})\")\n\n  //view.order:\n  if(dimension === 1) {\n    code.push(\"proto.order=[0]\")\n  } else {\n    code.push(\"Object.defineProperty(proto,'order',{get:\")\n    if(dimension < 4) {\n      code.push(\"function \"+className+\"_order(){\")\n      if(dimension === 2) {\n        code.push(\"return (Math.abs(this.stride[0])>Math.abs(this.stride[1]))?[1,0]:[0,1]}})\")\n      } else if(dimension === 3) {\n        code.push(\n\"var s0=Math.abs(this.stride[0]),s1=Math.abs(this.stride[1]),s2=Math.abs(this.stride[2]);\\\nif(s0>s1){\\\nif(s1>s2){\\\nreturn [2,1,0];\\\n}else if(s0>s2){\\\nreturn [1,2,0];\\\n}else{\\\nreturn [1,0,2];\\\n}\\\n}else if(s0>s2){\\\nreturn [2,0,1];\\\n}else if(s2>s1){\\\nreturn [0,1,2];\\\n}else{\\\nreturn [0,2,1];\\\n}}})\")\n      }\n    } else {\n      code.push(\"ORDER})\")\n    }\n  }\n\n  //view.set(i0, ..., v):\n  code.push(\n\"proto.set=function \"+className+\"_set(\"+args.join(\",\")+\",v){\")\n  if(useGetters) {\n    code.push(\"return this.data.set(\"+index_str+\",v)}\")\n  } else {\n    code.push(\"return this.data[\"+index_str+\"]=v}\")\n  }\n\n  //view.get(i0, ...):\n  code.push(\"proto.get=function \"+className+\"_get(\"+args.join(\",\")+\"){\")\n  if(useGetters) {\n    code.push(\"return this.data.get(\"+index_str+\")}\")\n  } else {\n    code.push(\"return this.data[\"+index_str+\"]}\")\n  }\n\n  //view.index:\n  code.push(\n    \"proto.index=function \"+className+\"_index(\", args.join(), \"){return \"+index_str+\"}\")\n\n  //view.hi():\n  code.push(\"proto.hi=function \"+className+\"_hi(\"+args.join(\",\")+\"){return new \"+className+\"(this.data,\"+\n    indices.map(function(i) {\n      return [\"(typeof i\",i,\"!=='number'||i\",i,\"<0)?this.shape[\", i, \"]:i\", i,\"|0\"].join(\"\")\n    }).join(\",\")+\",\"+\n    indices.map(function(i) {\n      return \"this.stride[\"+i + \"]\"\n    }).join(\",\")+\",this.offset)}\")\n\n  //view.lo():\n  var a_vars = indices.map(function(i) { return \"a\"+i+\"=this.shape[\"+i+\"]\" })\n  var c_vars = indices.map(function(i) { return \"c\"+i+\"=this.stride[\"+i+\"]\" })\n  code.push(\"proto.lo=function \"+className+\"_lo(\"+args.join(\",\")+\"){var b=this.offset,d=0,\"+a_vars.join(\",\")+\",\"+c_vars.join(\",\"))\n  for(var i=0; i<dimension; ++i) {\n    code.push(\n\"if(typeof i\"+i+\"==='number'&&i\"+i+\">=0){\\\nd=i\"+i+\"|0;\\\nb+=c\"+i+\"*d;\\\na\"+i+\"-=d}\")\n  }\n  code.push(\"return new \"+className+\"(this.data,\"+\n    indices.map(function(i) {\n      return \"a\"+i\n    }).join(\",\")+\",\"+\n    indices.map(function(i) {\n      return \"c\"+i\n    }).join(\",\")+\",b)}\")\n\n  //view.step():\n  code.push(\"proto.step=function \"+className+\"_step(\"+args.join(\",\")+\"){var \"+\n    indices.map(function(i) {\n      return \"a\"+i+\"=this.shape[\"+i+\"]\"\n    }).join(\",\")+\",\"+\n    indices.map(function(i) {\n      return \"b\"+i+\"=this.stride[\"+i+\"]\"\n    }).join(\",\")+\",c=this.offset,d=0,ceil=Math.ceil\")\n  for(var i=0; i<dimension; ++i) {\n    code.push(\n\"if(typeof i\"+i+\"==='number'){\\\nd=i\"+i+\"|0;\\\nif(d<0){\\\nc+=b\"+i+\"*(a\"+i+\"-1);\\\na\"+i+\"=ceil(-a\"+i+\"/d)\\\n}else{\\\na\"+i+\"=ceil(a\"+i+\"/d)\\\n}\\\nb\"+i+\"*=d\\\n}\")\n  }\n  code.push(\"return new \"+className+\"(this.data,\"+\n    indices.map(function(i) {\n      return \"a\" + i\n    }).join(\",\")+\",\"+\n    indices.map(function(i) {\n      return \"b\" + i\n    }).join(\",\")+\",c)}\")\n\n  //view.transpose():\n  var tShape = new Array(dimension)\n  var tStride = new Array(dimension)\n  for(var i=0; i<dimension; ++i) {\n    tShape[i] = \"a[i\"+i+\"]\"\n    tStride[i] = \"b[i\"+i+\"]\"\n  }\n  code.push(\"proto.transpose=function \"+className+\"_transpose(\"+args+\"){\"+\n    args.map(function(n,idx) { return n + \"=(\" + n + \"===undefined?\" + idx + \":\" + n + \"|0)\"}).join(\";\"),\n    \"var a=this.shape,b=this.stride;return new \"+className+\"(this.data,\"+tShape.join(\",\")+\",\"+tStride.join(\",\")+\",this.offset)}\")\n\n  //view.pick():\n  code.push(\"proto.pick=function \"+className+\"_pick(\"+args+\"){var a=[],b=[],c=this.offset\")\n  for(var i=0; i<dimension; ++i) {\n    code.push(\"if(typeof i\"+i+\"==='number'&&i\"+i+\">=0){c=(c+this.stride[\"+i+\"]*i\"+i+\")|0}else{a.push(this.shape[\"+i+\"]);b.push(this.stride[\"+i+\"])}\")\n  }\n  code.push(\"var ctor=CTOR_LIST[a.length+1];return ctor(this.data,a,b,c)}\")\n\n  //Add return statement\n  code.push(\"return function construct_\"+className+\"(data,shape,stride,offset){return new \"+className+\"(data,\"+\n    indices.map(function(i) {\n      return \"shape[\"+i+\"]\"\n    }).join(\",\")+\",\"+\n    indices.map(function(i) {\n      return \"stride[\"+i+\"]\"\n    }).join(\",\")+\",offset)}\")\n\n  //Compile procedure\n  var procedure = new Function(\"CTOR_LIST\", \"ORDER\", code.join(\"\\n\"))\n  return procedure(CACHED_CONSTRUCTORS[dtype], order)\n}\n\nfunction arrayDType(data) {\n  if(isBuffer(data)) {\n    return \"buffer\"\n  }\n  if(hasTypedArrays) {\n    switch(Object.prototype.toString.call(data)) {\n      case \"[object Float64Array]\":\n        return \"float64\"\n      case \"[object Float32Array]\":\n        return \"float32\"\n      case \"[object Int8Array]\":\n        return \"int8\"\n      case \"[object Int16Array]\":\n        return \"int16\"\n      case \"[object Int32Array]\":\n        return \"int32\"\n      case \"[object Uint8Array]\":\n        return \"uint8\"\n      case \"[object Uint16Array]\":\n        return \"uint16\"\n      case \"[object Uint32Array]\":\n        return \"uint32\"\n      case \"[object Uint8ClampedArray]\":\n        return \"uint8_clamped\"\n      case \"[object BigInt64Array]\":\n        return \"bigint64\"\n      case \"[object BigUint64Array]\":\n        return \"biguint64\"\n    }\n  }\n  if(Array.isArray(data)) {\n    return \"array\"\n  }\n  return \"generic\"\n}\n\nvar CACHED_CONSTRUCTORS = {\n  \"float32\":[],\n  \"float64\":[],\n  \"int8\":[],\n  \"int16\":[],\n  \"int32\":[],\n  \"uint8\":[],\n  \"uint16\":[],\n  \"uint32\":[],\n  \"array\":[],\n  \"uint8_clamped\":[],\n  \"bigint64\": [],\n  \"biguint64\": [],\n  \"buffer\":[],\n  \"generic\":[]\n}\n\n;(function() {\n  for(var id in CACHED_CONSTRUCTORS) {\n    CACHED_CONSTRUCTORS[id].push(compileConstructor(id, -1))\n  }\n});\n\nfunction wrappedNDArrayCtor(data, shape, stride, offset) {\n  if(data === undefined) {\n    var ctor = CACHED_CONSTRUCTORS.array[0]\n    return ctor([])\n  } else if(typeof data === \"number\") {\n    data = [data]\n  }\n  if(shape === undefined) {\n    shape = [ data.length ]\n  }\n  var d = shape.length\n  if(stride === undefined) {\n    stride = new Array(d)\n    for(var i=d-1, sz=1; i>=0; --i) {\n      stride[i] = sz\n      sz *= shape[i]\n    }\n  }\n  if(offset === undefined) {\n    offset = 0\n    for(var i=0; i<d; ++i) {\n      if(stride[i] < 0) {\n        offset -= (shape[i]-1)*stride[i]\n      }\n    }\n  }\n  var dtype = arrayDType(data)\n  var ctor_list = CACHED_CONSTRUCTORS[dtype]\n  while(ctor_list.length <= d+1) {\n    ctor_list.push(compileConstructor(dtype, ctor_list.length-1))\n  }\n  var ctor = ctor_list[d+1]\n  return ctor(data, shape, stride, offset)\n}\n\nmodule.exports = wrappedNDArrayCtor\n"],"names":["toArray","x","Array","isArray","codeMeaningEquals","codeMeaningName","contentItem","ConceptNameCodeSequence","CodeMeaning","TID1500","addAccessors","StructuredReport","Normalizer","TID1500MeasurementReport","TID1501MeasurementGroup","DicomMetaDictionary","FINDING","CodingSchemeDesignator","CodeValue","FINDING_SITE","FINDING_SITE_OLD","codeValueMatch","group","code","oldCode","getMeasurementGroup","toolType","toolData","ReferencedSOPSequence","toolTypeData","toolClass","MeasurementReport","CORNERSTONE_TOOL_CLASSES_BY_TOOL_TYPE","data","length","Measurements","map","tool","adapterClass","args","getTID300RepresentationArguments","TID300Representation","getTID300ContentItem","getSetupMeasurementData","MeasurementGroup","ContentSequence","contentSequenceArr","findingGroup","find","findingSiteGroups","filter","NUMGroup","ValueType","SCOORDGroup","ReferencedSOPInstanceUID","ReferencedFrameNumber","defaultState","sopInstanceUid","frameIndex","complete","finding","ConceptCodeSequence","undefined","findingSites","fsg","description","findingSite","location","generateReport","toolState","metadataProvider","options","allMeasurementGroups","firstImageId","Object","keys","Error","generalSeriesModule","get","studyInstanceUID","seriesInstanceUID","forEach","imageId","sopCommonModule","frameNumber","toolTypes","ReferencedSOPClassUID","sopClassUID","sopInstanceUID","isMultiframeSOPClassUID","measurementGroups","push","concat","TID1501MeasurementGroups","fileMetaInformationVersionArray","Uint8Array","derivationSourceDataset","StudyInstanceUID","SeriesInstanceUID","_meta","FileMetaInformationVersion","Value","buffer","vr","TransferSyntaxUID","ImplementationClassUID","uid","ImplementationVersionName","_vrMap","PixelData","report","dataset","assign","SpecificCharacterSet","generateToolState","hooks","arguments","ContentTemplateSequence","TemplateIdentifier","imagingMeasurementContent","measurementData","cornerstoneToolClasses","CORNERSTONE_TOOL_CLASSES_BY_UTILITY_TYPE","registeredToolClasses","key","measurementGroup","TrackingIdentifierValue","TextValue","getToolClass","tc","isValidCornerstoneTrackingIdentifier","measurement","getMeasurementData","console","log","registerTool","utilityToolType","MEASUREMENT_BY_TOOLTYPE","CORNERSTONE_4_TAG","Length","TID300Length","TID300","LENGTH","state","MeasuredValueSequence","NumericValue","handles","start","end","textBox","hasMoved","movesIndependently","drawnIndependently","allowedOutsideImage","hasBoundingBox","y","GraphicData","point1","point2","distance","trackingIdentifierTextValue","TrackingIdentifier","includes","cornerstone4Tag","split","Polyline","TID300Polyline","FreehandRoi","points","active","cachedStats","area","color","invalidated","i","perimeter","Bidirectional","TID300Bidirectional","BIDIRECTIONAL","longAxisNUMGroup","longAxisSCOORDGroup","shortAxisNUMGroup","shortAxisSCOORDGroup","longestDiameter","String","shortestDiameter","bottomRight","Math","max","highlight","index","perpendicularStart","perpendicularEnd","isCreating","toolName","visible","longAxis","shortAxis","longAxisLength","shortAxisLength","Ellipse","TID300Ellipse","ELLIPTICALROI","EllipticalRoi","majorAxis","minorAxis","minorAxisLength","sqrt","pow","minorAxisDirection","halfMinorAxisLength","corner1","corner2","initialRotation","halfXLength","abs","halfYLength","center","Circle","TID300Circle","CIRCLEROI","CircleRoi","radius","PI","Point","TID300Point","ARROW_ANNOTATE","CORNERSTONEFREETEXT","ArrowAnnotate","text","TID300RepresentationArguments","CobbAngle","TID300CobbAngle","COBB_ANGLE","rAngle","start2","end2","point3","point4","Angle","TID300Angle","ANGLE","middle","RectangleRoi","intermediate","DicomMessage","getDatasetsFromImages","images","isMultiframe","datasets","arrayBuffer","byteArray","dicomData","readFile","naturalizeDataset","dict","namifyDataset","meta","normalizeToDataset","rotateDirectionCosinesInPlane","flipImageOrientationPatient","flipIOP","flipMatrix2D","rotateMatrix902D","orientation","datasetToBlob","BitArray","Segmentation","SegmentationDerivation","generateSegmentation","brushData","includeSliceSpacing","segments","image0","dims","columns","rows","z","xy","seg","numSegments","_getSegCount","multiframe","_createSegFromImages","referencedFramesPerSegment","segmentIndicies","imageIdSpecificToolState","segIdx","brush","pixelData","_getNumberOfFramesPerSegment","NumberOfFrames","setNumberOfFrames","segmentIndex","referencedFrameIndicies","referencedFrameNumbers","element","segment","addSegment","_extractCornerstoneToolsPixelData","bitPackPixelData","imageIds","imagePlaneModule","warn","validOrientations","iop","orientations","h","v","iop90","getValidOrientations","rowCosines","columnCosines","SharedFunctionalGroupsSequence","sharedImageOrientationPatient","PlaneOrientationSequence","ImageOrientationPatient","sliceLength","Columns","Rows","segMetadata","segmentSequence","SegmentSequence","seriesInstanceUid","ReferencedSeriesSequence","getSegmentMetadata","segType","SegmentationType","unpack","MaximumFractionalValue","onlyMaxAndZero","unpackPixelData","PerFrameFunctionalGroupsSequence","inPlane","PerFrameFunctionalGroups","ImageOrientationPatientI","alignedPixelDataI","alignPixelDataWithSourceData","SegmentIdentificationSequence","ReferencedSegmentNumber","SourceImageSequence","DerivationImageSequence","addImageIdSpecificBrushToolState","getImageIdOfSourceImage","referencedFrames","pixelDataIndex","brushPixelData","p","pixelData2D","brushDataI","cToolsPixelData","imageIdFrameNumber","Number","getImageIdOfReferencedFrame","getImageIdOfReferencedSingleFramedSOPInstance","compareIOP","dx","iop1","iop2","nearlyEqual","compareArrays","array1","array2","tolerance","checkOrientation","sourceDataDimensions","some","operation","absDotColumnCosines","absDotRowCosines","checkIfPerpendicular","Events","encode","decode","compression","generateSegmentationDefaultOptions","rleEncode","fillSegmentation","segmentation","inputLabelmaps3D","userOptions","labelmaps3D","numberOfFrames","referencedFramesPerLabelmap","labelmapIndex","labelmap3D","labelmaps2D","metadata","labelmap2D","segmentsOnLabelmap","segmentMetadata","labelmaps","_getLabelmapsFromReferencedFrameIndicies","addSegmentFromLabelmap","rleEncodedFrames","assignToDataset","BitsAllocated","BitsStored","HighBit","SegmentationFractionalType","frame","findReferenceSourceImageId","frameSegment","sopUIDImageIdIndexMap","FrameOfReferenceUID","PerFrameFunctionalGroup","frameSourceImageSequence","baseImageId","replace","getImageIdOfSourceImageBySourceImageSequence","ReferencedSeriesInstanceUID","PlanePositionSequence","ImagePositionPatient","segFramePosition","sourceImageMetadata","isMultiframeImage","framePosition","imagePositionPatient","getImageIdOfSourceImagebyGeometry","insertOverlappingPixelDataPlanar","segmentsOnFrame","segmentsOnFrameArray","labelmapBufferArray","TypedArrayConstructor","segmentsPixelIndices","arrayBufferLength","BYTES_PER_ELEMENT","M","m","tempBuffer","slice","tempSegmentsOnFrame","structuredClone","numberOfSegs","segmentIndexToProcess","groupsLen","getSegmentIndex","view","readFromUnpackedChunks","imageIdIndex","findIndex","labelmap2DView","segmentOnFrame","j","len","ArrayBuffer","insertPixelDataPlanar","imageIdMaps","eventTarget","triggerEvent","chunkSize","ceil","shouldTriggerEvent","overlapping","Promise","resolve","processInChunks","min","has","set","indices","byteOffset","indexCache","segmentIndexObject","percentComplete","round","SEGMENTATION_LOAD_PROGRESS","setTimeout","error","maxBytesPerChunk","bitArray","chunks","maxBitsPerChunk","numberOfChunks","startBit","endBit","startByte","floor","endByte","chunk","unpackedChunk","getUnpackedChunks","imageMetadata","offset","mapping","totalBytes","reduce","total","startChunkIndex","startOffsetInChunk","endChunkIndex","endOffsetInChunk","chunkIndex","getUnpackedOffsetAndLength","result","resultOffset","calculateCentroid","imageIdIndexBufferIndex","xAcc","yAcc","zAcc","worldXAcc","worldYAcc","worldZAcc","count","bufferIndices","entries","debug","rowPixelSpacing","columnPixelSpacing","bufferIndex","image","world","async","referencedImageIds","skipOverlapping","pixelDataChunks","acc","insertFunction","frameSegmentsMapping","Map","segmentArray","role","temp2DArray","fill","checkSEGsOverlapping","curr","overlappingSegments","centroidXYZ","centroids","labelmaps3DorBrushData","cornerstoneToolsVersion","imageIdsIndex","CornerstoneSR","CornerstoneSEG","CornerstonePMAP","ParametricMap","TypedArrayClass","Uint16Array","Int16Array","Uint32Array","Int32Array","PixelRepresentation","FloatPixelData","Float32Array","DoubleFloatPixelData","Float64Array","getPixelData","Perpendicular","Oblique","sourcePixelData","targetPixelData","constructor","numSlices","sourceSliceDataView","CORNERSTONE_3D_TAG","patientStudyTags","CodingScheme","codeValues","_MeasurementReport","worldToImageCoords","this","measurementAdapterByToolType","getCornerstoneLabelFromDefaultState","cornersoneFreeTextCodingValue","freeTextLabel","fs","generateDatasetMeta","sopInstanceUIDToImageIdMap","referencedImageId","annotation","annotationUID","frameOfReferenceUID","label","sopInstanceUIDsToSeriesInstanceUIDMap","derivationSourceDatasets","instance","dsd","generateDerivationSourceDataset","tid1500MeasurementReport","imageToWorldCoords","measurementGroupContentSequence","trackingIdentifierGroup","trackingIdentifierValue","trackingUniqueIdentifierGroup","trackingUniqueIdentifierValue","UID","toolAdapter","getAdapterForTrackingIdentifier","TrackingUniqueIdentifier","e","registerName","measurementAdapterByTrackingIdentifier","registerTrackingIdentifier","_len","trackingIdentifiers","_key","identifier","trackingIdentifier","adapter","adapterTest","values","src","study","tagKey","value","copyStudyTags","BaseAdapter3D","init","representation","parentType","Set","alternateTrackingIdentifier","add","registerLegacy","registerSubType","subAdapter","create","startsWith","_imageToWorldCoords","seriesLevel","indexOf","point","pointImage","_ArrowAnnotate","_trackingIdentifier","worldCoords","imagePixelModule","xOffset","yOffset","secondPoint","arrowFirst","activeHandleIndex","pointImage2","_Bidirectional","width","firstPointPairs","secondPointPairs","shortAxisPoints","longAxisPoints","longAxisStartImage","longAxisEndImage","shortAxisStartImage","shortAxisEndImage","_Angle","angle","start1","_CobbAngle","end1","_CircleROI","CircleROI","pointsWorld","worldPos","EPSILON","EllipticalROI","majorAxisStart","majorAxisEnd","minorAxisStart","minorAxisEnd","majorAxisVec","minorAxisVec","columnCosinesVec","projectedMajorAxisOnColVec","projectedMinorAxisOnColVec","absoluteOfMajorDotProduct","absoluteOfMinorDotProduct","ellipsePoints","rotation","top","bottom","left","right","_RectangleROI","RectangleROI","corners","_Length","_PlanarFreehandROI","PlanarFreehandROI","isOpenContour","closedContourThreshold","pop","contour","polyline","closed","firstPoint","areaUnit","modalityUnit","mean","stdDev","_Probe","Probe","super","UltrasoundDirectional","SOPClassUID","SopClassUID","SOPInstanceUID","SopInstanceUID","voxelManager","getScalarData","_createMultiframeSegmentationFromReferencedImages","generateLabelMaps2DFrom3D","scalarData","dimensions","segmentsOnLabelmap3D","from","checkHasOverlapping","_ref","largerArray","currentTestedArray","newArray","_","currentImageIndex","originalImagePixelData","newImagePixelData","originalPixel","currentPixelIndex","newPixel","compactMergeSegmentDataWithoutInformationLoss","_ref2","arrayOfSegmentData","newSegmentData","currentTestedIndex","mergedPixelData","updateSegmentsOnFrame","updateSegmentsPixelIndices","extractInfoFromPerFrameFunctionalGroups","_ref3","sequenceIndex","referencedSOPInstanceUid","throttledTriggerLoadProgressEvent","utilities","_ref4","labelMapImages","imagesPerChunk","processChunk","firstIndex","k","hasOverlappingSegments","arrayOfLabelMapImages","getAlignedPixelData","_ref5","checkImageDimensions","_ref6","getArrayOfLabelMapImagesWithSegmentData","_ref7","largestArray","segmentData","arr","hasEmptySegmentData","labelMapImage","imageLoader","Boolean","_ref8","getArrayOfSegmentData","_ref9","numberOfSegments","currentSegmentIndex","getSegmentData","_ref10","currentLabelMapImageIndex","currentLabelMapImage","PerFrameFunctionalGroupsIndex","currentSequenceIndex","groupsSegmentIndex","groupsReferenceImageId","segmentationDataForImageId","pixel","pixelIndex","createFromDICOMSegBuffer","referenceImageId","createLabelmapsFromBufferInternal","generateToolStateCornerstone","getReferencedFrameOfReferenceSequence","RTReferencedStudySequence","RTReferencedSeriesSequence","ContourImageSequence","ReferencedInstanceSequence","getReferencedSeriesSequence","_index","DicomMetadataStore","series","getSeries","ReferencedSeries","instances","getStructureSetModule","ROINumber","ROIName","name","ROIDescription","ROIGenerationAlgorithm","ReferencedFrameOfReferenceUID","generateContourSetsFromLabelmap","AnnotationToPointData","generateRTSSFromSegmentations","segmentations","roiContours","contourSet","segIndex","contourSequence","sliceContours","sliceContour","sopCommon","sliceContourPolyData","polyData","contours","ContourGeometricType","type","NumberOfContourPoints","contourPoints","ContourData","pointData","toFixed","ContourNumber","segLabel","ROIContour","_initializeDataset","roiContour","ROIDisplayColor","ContourSequence","ReferencedROINumber","StructureSetROISequence","ROIContourSequence","ReferencedFrameOfReferenceSequence","generateRTSSFromAnnotations","annotations","convert","RTROIObservationsSequence","ObservationNumber","RTROIInterpretedType","ROIInterpreter","getRTROIObservationsSequence","rtMetadata","imgMetadata","rtSOPInstanceUID","patientModule","generalStudyModule","patientStudyModule","patientDemographicModule","Modality","modality","PatientID","patientId","PatientName","patientName","PatientBirthDate","PatientAge","patientAge","PatientSex","patientSex","PatientWeight","patientWeight","StudyDate","studyDate","StudyTime","studyTime","StudyID","AccessionNumber","accessionNumber","getPatientModule","rtSeriesModule","SeriesNumber","getRTSeriesModule","Manufacturer","PositionReferenceIndicator","StructureSetLabel","StructureSetName","ReferringPhysicianName","OperatorsName","StructureSetDate","date","StructureSetTime","time","_KeyImage","KeyImage","baseData","isPoint","tid300Arguments","trackingSeriesPointIdentifier","trackingPointIdentifier","trackingSeriesIdentifier","Cornerstone3DSR","CodeScheme","Cornerstone3DSEG","Cornerstone3DPMAP","Cornerstone3DRT","RTSS","Colors","normalize","den","n","sum","norm","adaptersSR","Cornerstone","Cornerstone3D","adaptersSEG","VTKjs","generateSegments","cielab","rgba","dicomlab2RGB","dicomlab2RGBA","RecommendedDisplayCIELabValue","SegmentNumber","functionalGroups","size","functionalGroup","segmentNumber","frameSize","nextOffset","packedSegment","geometry","pixelMeasures","PixelMeasuresSequence","planeOrientation","firstFunctionalGroup","lastFunctionalGroup","firstPosition","lastPosition","origin","spacing","PixelSpacing","SpacingBetweenSlices","columnStepToPatient","rowStepToPatient","a","b","out","planeNormal","Zx","Zy","Zz","cross","sliceStep","direction","geometryFromFunctionalGroups","adaptersPMAP","adaptersRT","datasetToDict","downloadDICOMData","bufferOrDataset","filename","blob","Blob","write","link","document","createElement","href","window","URL","createObjectURL","download","click","ChangeTypes","SegmentationRepresentations","StrategyCallbacks","MouseBindings","KeyboardBindings","ToolModes","Swipe","AnnotationStyleStates","module","exports","obj","isBuffer","iota","hasTypedArrays","compare1st","order","stride","terms","sort","compileConstructor","dtype","dimension","className","join","useGetters","Function","procedure","CACHED_CONSTRUCTORS","index_str","shapeArg","strideArg","a_vars","c_vars","tShape","tStride","idx","shape","ctor","array","d","sz","prototype","toString","call","arrayDType","ctor_list"],"sourceRoot":""}