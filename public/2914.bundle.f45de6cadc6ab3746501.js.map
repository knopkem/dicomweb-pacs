{"version":3,"file":"2914.bundle.f45de6cadc6ab3746501.js","mappings":"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","sources":["webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/_getHash.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/shared/getMouseModifier.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/resetAnnotationManager.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/utilities/defineProperties.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/events/triggerSegmentationAdded.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/events/triggerSegmentationModified.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/events/triggerSegmentationRemoved.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/events/triggerSegmentationRepresentationModified.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/events/triggerSegmentationRepresentationRemoved.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/helpers/internalGetHiddenSegmentIndices.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/store/ToolGroupManager/getToolGroupsWithToolName.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/planarFreehandROITool/closedContourEditLoop.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/planarFreehandROITool/drawLoop.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/planarFreehandROITool/editLoopCommon.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/planarFreehandROITool/findOpenUShapedContourVectorToPeak.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/planarFreehandROITool/openContourEditLoop.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/planarFreehandROITool/openContourEndEditLoop.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/planarFreehandROITool/renderMethods.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/base/AnnotationTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/base/ContourBaseTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/base/ContourSegmentationBaseTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/displayTools/Contour/contourConfig.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/displayTools/Contour/contourHandler/handleContourSegmentation.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/displayTools/Contour/contourHandler/utils.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/displayTools/Contour/removeContourFromElement.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/displayTools/Labelmap/addVolumesAsIndependentComponents.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/displayTools/Labelmap/addLabelmapToElement.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/displayTools/Labelmap/labelmapConfig.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/displayTools/Labelmap/removeLabelmapFromElement.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/displayTools/Surface/addOrUpdateSurfaceToElement.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/displayTools/Surface/removeSurfaceFromElement.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/BrushStrategy.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/compositions/determineSegmentIndex.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/compositions/dynamicThreshold.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/compositions/erase.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/compositions/islandRemovalComposition.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/compositions/preview.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/compositions/regionFill.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/compositions/setValue.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/utils/handleUseSegmentCenterIndex.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/compositions/threshold.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/compositions/labelmapStatistics.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/compositions/index.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/eraseCircle.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/eraseSphere.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/fillSphere.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/utils/getStrategyData.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/RectangleROIStartEndThreshold.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/interpolation/getInterpolationData.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/interpolation/getInterpolationDataCollection.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/interpolation/createPolylineToolData.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/interpolation/findAnnotationForInterpolation.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/interpolation/selectHandles.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/interpolation/interpolate.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/interpolation/updateChildInterpolationUID.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/basic/BasicStatsCalculator.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/ellipse/getCanvasEllipseCorners.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/line/distanceToPoint.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/line/intersectLine.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/rectangle/distanceToPoint.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/planarFreehandROITool/interpolation/interpolateSegmentPoints.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/planarFreehandROITool/interpolation/algorithms/bspline.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/planarFreehandROITool/smoothPoints.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/planar/filterAnnotationsForDisplay.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/planar/filterAnnotationsWithinPlane.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/planar/filterAnnotationsWithinSlice.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/planar/getPointInLineOfSightWithCriteria.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/planar/getWorldWidthAndHeightFromCorners.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/planar/getWorldWidthAndHeightFromTwoPoints.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/planar/isPlaneIntersectingAABB.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/InterpolationManager/deleteRelatedAnnotations.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/computeAndAddRepresentation.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/getSVGStyleForSegment.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/viewportFilters/getViewportIdsWithToolToRender.js"],"sourcesContent":["function _getHash(annotationUID, drawingElementType, nodeUID) {\n    return `${annotationUID}::${drawingElementType}::${nodeUID}`;\n}\nexport default _getHash;\n","import { KeyboardBindings as kb } from '../../enums';\nconst getMouseModifierKey = (evt) => {\n    if (evt.shiftKey) {\n        if (evt.ctrlKey) {\n            return kb.ShiftCtrl;\n        }\n        if (evt.altKey) {\n            return kb.ShiftAlt;\n        }\n        if (evt.metaKey) {\n            return kb.ShiftMeta;\n        }\n        return kb.Shift;\n    }\n    if (evt.ctrlKey) {\n        if (evt.altKey) {\n            return kb.CtrlAlt;\n        }\n        if (evt.metaKey) {\n            return kb.CtrlMeta;\n        }\n        return kb.Ctrl;\n    }\n    if (evt.altKey) {\n        return (evt.metaKey && kb.AltMeta) || kb.Alt;\n    }\n    if (evt.metaKey) {\n        return kb.Meta;\n    }\n    return undefined;\n};\nexport default getMouseModifierKey;\n","import { checkAndDefineCachedStatsProperty, checkAndDefineTextBoxProperty, } from './utilities/defineProperties';\nimport { checkAndSetAnnotationLocked } from './annotationLocking';\nimport { checkAndSetAnnotationVisibility } from './annotationVisibility';\nimport { defaultFrameOfReferenceSpecificAnnotationManager } from './FrameOfReferenceSpecificAnnotationManager';\nimport { setAnnotationManager } from './annotationState';\nconst defaultManager = defaultFrameOfReferenceSpecificAnnotationManager;\nconst preprocessingFn = (annotation) => {\n    annotation = checkAndDefineTextBoxProperty(annotation);\n    annotation = checkAndDefineCachedStatsProperty(annotation);\n    const uid = annotation.annotationUID;\n    const isLocked = checkAndSetAnnotationLocked(uid);\n    annotation.isLocked = isLocked;\n    const isVisible = checkAndSetAnnotationVisibility(uid);\n    annotation.isVisible = isVisible;\n    return annotation;\n};\ndefaultManager.setPreprocessingFn(preprocessingFn);\nsetAnnotationManager(defaultManager);\nexport function resetAnnotationManager() {\n    setAnnotationManager(defaultManager);\n}\n","const checkAndDefineTextBoxProperty = (annotation) => {\n    if (!annotation.data) {\n        annotation.data = {};\n    }\n    if (!annotation.data.handles) {\n        annotation.data.handles = {};\n    }\n    if (!annotation.data.handles.textBox) {\n        annotation.data.handles.textBox = {};\n    }\n    return annotation;\n};\nconst checkAndDefineCachedStatsProperty = (annotation) => {\n    if (!annotation.data) {\n        annotation.data = {};\n    }\n    if (!annotation.data.cachedStats) {\n        annotation.data.cachedStats = {};\n    }\n    return annotation;\n};\nexport { checkAndDefineTextBoxProperty, checkAndDefineCachedStatsProperty };\n","import { triggerEvent, eventTarget } from '@cornerstonejs/core';\nimport { Events } from '../../../enums';\nexport function triggerSegmentationAdded(segmentationId) {\n    const eventDetail = {\n        segmentationId,\n    };\n    triggerEvent(eventTarget, Events.SEGMENTATION_ADDED, eventDetail);\n}\n","import { triggerEvent, eventTarget } from '@cornerstonejs/core';\nimport { Events } from '../../../enums';\nexport function triggerSegmentationModified(segmentationId) {\n    const eventDetail = {\n        segmentationId,\n    };\n    triggerEvent(eventTarget, Events.SEGMENTATION_MODIFIED, eventDetail);\n}\n","import { triggerEvent, eventTarget } from '@cornerstonejs/core';\nimport { Events } from '../../../enums';\nexport function triggerSegmentationRemoved(segmentationId) {\n    const eventDetail = {\n        segmentationId,\n    };\n    triggerEvent(eventTarget, Events.SEGMENTATION_REMOVED, eventDetail);\n}\n","import { triggerEvent, eventTarget } from '@cornerstonejs/core';\nimport { Events } from '../../../enums';\nexport function triggerSegmentationRepresentationModified(viewportId, segmentationId, type) {\n    const eventDetail = {\n        segmentationId,\n        type,\n        viewportId,\n    };\n    triggerEvent(eventTarget, Events.SEGMENTATION_REPRESENTATION_MODIFIED, eventDetail);\n}\n","import { triggerEvent, eventTarget } from '@cornerstonejs/core';\nimport { Events } from '../../../enums';\nexport function triggerSegmentationRepresentationRemoved(viewportId, segmentationId, type) {\n    const eventDetail = {\n        viewportId,\n        segmentationId,\n        type,\n    };\n    triggerEvent(eventTarget, Events.SEGMENTATION_REPRESENTATION_REMOVED, eventDetail);\n}\n","import { getSegmentationRepresentation } from '../getSegmentationRepresentation';\nexport function internalGetHiddenSegmentIndices(viewportId, specifier) {\n    const representation = getSegmentationRepresentation(viewportId, specifier);\n    if (!representation) {\n        return new Set();\n    }\n    const segmentsHidden = Object.entries(representation.segments).reduce((acc, [segmentIndex, segment]) => {\n        if (!segment.visible) {\n            acc.add(Number(segmentIndex));\n        }\n        return acc;\n    }, new Set());\n    return segmentsHidden;\n}\n","import { state } from '../state';\nimport { ToolModes } from '../../enums';\nconst MODES = [ToolModes.Active, ToolModes.Passive, ToolModes.Enabled];\nfunction getToolGroupsWithToolName(toolName) {\n    return state.toolGroups.filter(({ toolOptions }) => {\n        const toolGroupToolNames = Object.keys(toolOptions);\n        for (let i = 0; i < toolGroupToolNames.length; i++) {\n            if (toolName !== toolGroupToolNames[i]) {\n                continue;\n            }\n            if (!toolOptions[toolName]) {\n                continue;\n            }\n            if (MODES.includes(toolOptions[toolName].mode)) {\n                return true;\n            }\n        }\n        return false;\n    });\n}\nexport default getToolGroupsWithToolName;\n","import { vec3, vec2 } from 'gl-matrix';\nimport { getEnabledElement } from '@cornerstonejs/core';\nimport { state } from '../../../store/state';\nimport { Events } from '../../../enums';\nimport { resetElementCursor, hideElementCursor, } from '../../../cursors/elementCursor';\nimport { polyline } from '../../../utilities/math';\nimport { ContourWindingDirection } from '../../../types/ContourAnnotation';\nimport { getInterpolatedPoints, shouldSmooth, } from '../../../utilities/planarFreehandROITool/smoothPoints';\nimport triggerAnnotationRenderForViewportIds from '../../../utilities/triggerAnnotationRenderForViewportIds';\nimport updateContourPolyline from '../../../utilities/contours/updateContourPolyline';\nimport { triggerAnnotationModified } from '../../../stateManagement/annotation/helpers/state';\nconst { getSubPixelSpacingAndXYDirections, addCanvasPointsToArray, getArea } = polyline;\nfunction activateClosedContourEdit(evt, annotation, viewportIdsToRender) {\n    this.isEditingClosed = true;\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const canvasPos = currentPoints.canvas;\n    const enabledElement = getEnabledElement(element);\n    if (!enabledElement) {\n        return;\n    }\n    const { viewport } = enabledElement;\n    const prevCanvasPoints = annotation.data.contour.polyline.map(viewport.worldToCanvas);\n    const { spacing, xDir, yDir } = getSubPixelSpacingAndXYDirections(viewport, this.configuration.subPixelResolution);\n    this.editData = {\n        prevCanvasPoints,\n        editCanvasPoints: [canvasPos],\n        startCrossingIndex: undefined,\n        editIndex: 0,\n        annotation,\n    };\n    this.commonData = {\n        annotation,\n        viewportIdsToRender,\n        spacing,\n        xDir,\n        yDir,\n        movingTextBox: false,\n    };\n    state.isInteractingWithTool = true;\n    element.addEventListener(Events.MOUSE_UP, this.mouseUpClosedContourEditCallback);\n    element.addEventListener(Events.MOUSE_DRAG, this.mouseDragClosedContourEditCallback);\n    element.addEventListener(Events.MOUSE_CLICK, this.mouseUpClosedContourEditCallback);\n    element.addEventListener(Events.TOUCH_END, this.mouseUpClosedContourEditCallback);\n    element.addEventListener(Events.TOUCH_DRAG, this.mouseDragClosedContourEditCallback);\n    element.addEventListener(Events.TOUCH_TAP, this.mouseUpClosedContourEditCallback);\n    hideElementCursor(element);\n}\nfunction deactivateClosedContourEdit(element) {\n    state.isInteractingWithTool = false;\n    element.removeEventListener(Events.MOUSE_UP, this.mouseUpClosedContourEditCallback);\n    element.removeEventListener(Events.MOUSE_DRAG, this.mouseDragClosedContourEditCallback);\n    element.removeEventListener(Events.MOUSE_CLICK, this.mouseUpClosedContourEditCallback);\n    element.removeEventListener(Events.TOUCH_END, this.mouseUpClosedContourEditCallback);\n    element.removeEventListener(Events.TOUCH_DRAG, this.mouseDragClosedContourEditCallback);\n    element.removeEventListener(Events.TOUCH_TAP, this.mouseUpClosedContourEditCallback);\n    resetElementCursor(element);\n}\nfunction mouseDragClosedContourEditCallback(evt) {\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const worldPos = currentPoints.world;\n    const canvasPos = currentPoints.canvas;\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const { viewportIdsToRender, xDir, yDir, spacing } = this.commonData;\n    const { editIndex, editCanvasPoints, startCrossingIndex, annotation } = this.editData;\n    this.createMemo(element, annotation);\n    const lastCanvasPoint = editCanvasPoints[editCanvasPoints.length - 1];\n    const lastWorldPoint = viewport.canvasToWorld(lastCanvasPoint);\n    const worldPosDiff = vec3.create();\n    vec3.subtract(worldPosDiff, worldPos, lastWorldPoint);\n    const xDist = Math.abs(vec3.dot(worldPosDiff, xDir));\n    const yDist = Math.abs(vec3.dot(worldPosDiff, yDir));\n    if (xDist <= spacing[0] && yDist <= spacing[1]) {\n        return;\n    }\n    if (startCrossingIndex !== undefined) {\n        this.checkAndRemoveCrossesOnEditLine(evt);\n    }\n    const numPointsAdded = addCanvasPointsToArray(element, editCanvasPoints, canvasPos, this.commonData);\n    const currentEditIndex = editIndex + numPointsAdded;\n    this.editData.editIndex = currentEditIndex;\n    if (startCrossingIndex === undefined && editCanvasPoints.length > 1) {\n        this.checkForFirstCrossing(evt, true);\n    }\n    this.editData.snapIndex = this.findSnapIndex();\n    if (this.editData.snapIndex === -1) {\n        this.finishEditAndStartNewEdit(evt);\n        return;\n    }\n    this.editData.fusedCanvasPoints = this.fuseEditPointsWithClosedContour(evt);\n    if (startCrossingIndex !== undefined &&\n        this.checkForSecondCrossing(evt, true)) {\n        this.removePointsAfterSecondCrossing(true);\n        this.finishEditAndStartNewEdit(evt);\n    }\n    triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n}\nfunction finishEditAndStartNewEdit(evt) {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n    const { annotation, viewportIdsToRender } = this.commonData;\n    const { fusedCanvasPoints, editCanvasPoints } = this.editData;\n    updateContourPolyline(annotation, {\n        points: fusedCanvasPoints,\n        closed: true,\n        targetWindingDirection: ContourWindingDirection.Clockwise,\n    }, viewport);\n    if (annotation.autoGenerated) {\n        annotation.autoGenerated = false;\n    }\n    triggerAnnotationModified(annotation, element);\n    const lastEditCanvasPoint = editCanvasPoints.pop();\n    this.editData = {\n        prevCanvasPoints: fusedCanvasPoints,\n        editCanvasPoints: [lastEditCanvasPoint],\n        startCrossingIndex: undefined,\n        editIndex: 0,\n        snapIndex: undefined,\n        annotation,\n    };\n    triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n}\nfunction fuseEditPointsWithClosedContour(evt) {\n    const { prevCanvasPoints, editCanvasPoints, startCrossingIndex, snapIndex } = this.editData;\n    if (startCrossingIndex === undefined || snapIndex === undefined) {\n        return;\n    }\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const augmentedEditCanvasPoints = [...editCanvasPoints];\n    addCanvasPointsToArray(element, augmentedEditCanvasPoints, prevCanvasPoints[snapIndex], this.commonData);\n    if (augmentedEditCanvasPoints.length > editCanvasPoints.length) {\n        augmentedEditCanvasPoints.pop();\n    }\n    let lowIndex;\n    let highIndex;\n    if (startCrossingIndex > snapIndex) {\n        lowIndex = snapIndex;\n        highIndex = startCrossingIndex;\n    }\n    else {\n        lowIndex = startCrossingIndex;\n        highIndex = snapIndex;\n    }\n    const distanceBetweenLowAndFirstPoint = vec2.distance(prevCanvasPoints[lowIndex], augmentedEditCanvasPoints[0]);\n    const distanceBetweenLowAndLastPoint = vec2.distance(prevCanvasPoints[lowIndex], augmentedEditCanvasPoints[augmentedEditCanvasPoints.length - 1]);\n    const distanceBetweenHighAndFirstPoint = vec2.distance(prevCanvasPoints[highIndex], augmentedEditCanvasPoints[0]);\n    const distanceBetweenHighAndLastPoint = vec2.distance(prevCanvasPoints[highIndex], augmentedEditCanvasPoints[augmentedEditCanvasPoints.length - 1]);\n    const pointSet1 = [];\n    for (let i = 0; i < lowIndex; i++) {\n        const canvasPoint = prevCanvasPoints[i];\n        pointSet1.push([canvasPoint[0], canvasPoint[1]]);\n    }\n    let inPlaceDistance = distanceBetweenLowAndFirstPoint + distanceBetweenHighAndLastPoint;\n    let reverseDistance = distanceBetweenLowAndLastPoint + distanceBetweenHighAndFirstPoint;\n    if (inPlaceDistance < reverseDistance) {\n        for (let i = 0; i < augmentedEditCanvasPoints.length; i++) {\n            const canvasPoint = augmentedEditCanvasPoints[i];\n            pointSet1.push([canvasPoint[0], canvasPoint[1]]);\n        }\n    }\n    else {\n        for (let i = augmentedEditCanvasPoints.length - 1; i >= 0; i--) {\n            const canvasPoint = augmentedEditCanvasPoints[i];\n            pointSet1.push([canvasPoint[0], canvasPoint[1]]);\n        }\n    }\n    for (let i = highIndex; i < prevCanvasPoints.length; i++) {\n        const canvasPoint = prevCanvasPoints[i];\n        pointSet1.push([canvasPoint[0], canvasPoint[1]]);\n    }\n    const pointSet2 = [];\n    for (let i = lowIndex; i < highIndex; i++) {\n        const canvasPoint = prevCanvasPoints[i];\n        pointSet2.push([canvasPoint[0], canvasPoint[1]]);\n    }\n    inPlaceDistance =\n        distanceBetweenHighAndFirstPoint + distanceBetweenLowAndLastPoint;\n    reverseDistance =\n        distanceBetweenHighAndLastPoint + distanceBetweenLowAndFirstPoint;\n    if (inPlaceDistance < reverseDistance) {\n        for (let i = 0; i < augmentedEditCanvasPoints.length; i++) {\n            const canvasPoint = augmentedEditCanvasPoints[i];\n            pointSet2.push([canvasPoint[0], canvasPoint[1]]);\n        }\n    }\n    else {\n        for (let i = augmentedEditCanvasPoints.length - 1; i >= 0; i--) {\n            const canvasPoint = augmentedEditCanvasPoints[i];\n            pointSet2.push([canvasPoint[0], canvasPoint[1]]);\n        }\n    }\n    const areaPointSet1 = getArea(pointSet1);\n    const areaPointSet2 = getArea(pointSet2);\n    const pointsToRender = areaPointSet1 > areaPointSet2 ? pointSet1 : pointSet2;\n    return pointsToRender;\n}\nfunction mouseUpClosedContourEditCallback(evt) {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    this.completeClosedContourEdit(element);\n}\nfunction completeClosedContourEdit(element) {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const { annotation, viewportIdsToRender } = this.commonData;\n    this.doneEditMemo();\n    const { fusedCanvasPoints, prevCanvasPoints } = this.editData;\n    if (fusedCanvasPoints) {\n        const updatedPoints = shouldSmooth(this.configuration, annotation)\n            ? getInterpolatedPoints(this.configuration, fusedCanvasPoints, prevCanvasPoints)\n            : fusedCanvasPoints;\n        const decimateConfig = this.configuration?.decimate || {};\n        updateContourPolyline(annotation, {\n            points: updatedPoints,\n            closed: true,\n            targetWindingDirection: ContourWindingDirection.Clockwise,\n        }, viewport, {\n            decimate: {\n                enabled: !!decimateConfig.enabled,\n                epsilon: decimateConfig.epsilon,\n            },\n        });\n        if (annotation.autoGenerated) {\n            annotation.autoGenerated = false;\n        }\n        triggerAnnotationModified(annotation, element);\n    }\n    this.isEditingClosed = false;\n    this.editData = undefined;\n    this.commonData = undefined;\n    triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n    this.deactivateClosedContourEdit(element);\n}\nfunction cancelClosedContourEdit(element) {\n    this.completeClosedContourEdit(element);\n}\nfunction registerClosedContourEditLoop(toolInstance) {\n    toolInstance.activateClosedContourEdit =\n        activateClosedContourEdit.bind(toolInstance);\n    toolInstance.deactivateClosedContourEdit =\n        deactivateClosedContourEdit.bind(toolInstance);\n    toolInstance.mouseDragClosedContourEditCallback =\n        mouseDragClosedContourEditCallback.bind(toolInstance);\n    toolInstance.mouseUpClosedContourEditCallback =\n        mouseUpClosedContourEditCallback.bind(toolInstance);\n    toolInstance.finishEditAndStartNewEdit =\n        finishEditAndStartNewEdit.bind(toolInstance);\n    toolInstance.fuseEditPointsWithClosedContour =\n        fuseEditPointsWithClosedContour.bind(toolInstance);\n    toolInstance.cancelClosedContourEdit =\n        cancelClosedContourEdit.bind(toolInstance);\n    toolInstance.completeClosedContourEdit =\n        completeClosedContourEdit.bind(toolInstance);\n}\nexport default registerClosedContourEditLoop;\n","import { getEnabledElement, utilities } from '@cornerstonejs/core';\nimport { resetElementCursor, hideElementCursor, } from '../../../cursors/elementCursor';\nimport { ChangeTypes, Events } from '../../../enums';\nimport { state } from '../../../store/state';\nimport { vec3 } from 'gl-matrix';\nimport { shouldSmooth, getInterpolatedPoints, } from '../../../utilities/planarFreehandROITool/smoothPoints';\nimport getMouseModifierKey from '../../../eventDispatchers/shared/getMouseModifier';\nimport triggerAnnotationRenderForViewportIds from '../../../utilities/triggerAnnotationRenderForViewportIds';\nimport { triggerAnnotationModified, triggerContourAnnotationCompleted, } from '../../../stateManagement/annotation/helpers/state';\nimport findOpenUShapedContourVectorToPeak from './findOpenUShapedContourVectorToPeak';\nimport { polyline } from '../../../utilities/math';\nimport { removeAnnotation } from '../../../stateManagement/annotation/annotationState';\nimport { ContourWindingDirection } from '../../../types/ContourAnnotation';\nconst { addCanvasPointsToArray, pointsAreWithinCloseContourProximity, getFirstLineSegmentIntersectionIndexes, getSubPixelSpacingAndXYDirections, } = polyline;\nfunction activateDraw(evt, annotation, viewportIdsToRender) {\n    this.isDrawing = true;\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const canvasPos = currentPoints.canvas;\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const contourHoleProcessingEnabled = getMouseModifierKey(evt.detail.event) ===\n        this.configuration.contourHoleAdditionModifierKey;\n    const { spacing, xDir, yDir } = getSubPixelSpacingAndXYDirections(viewport, this.configuration.subPixelResolution) || {};\n    if (!spacing || !xDir || !yDir) {\n        return;\n    }\n    this.drawData = {\n        canvasPoints: [canvasPos],\n        polylineIndex: 0,\n        contourHoleProcessingEnabled,\n        newAnnotation: true,\n    };\n    this.commonData = {\n        annotation,\n        viewportIdsToRender,\n        spacing,\n        xDir,\n        yDir,\n        movingTextBox: false,\n    };\n    state.isInteractingWithTool = true;\n    element.addEventListener(Events.MOUSE_UP, this.mouseUpDrawCallback);\n    element.addEventListener(Events.MOUSE_DRAG, this.mouseDragDrawCallback);\n    element.addEventListener(Events.MOUSE_CLICK, this.mouseUpDrawCallback);\n    element.addEventListener(Events.TOUCH_END, this.mouseUpDrawCallback);\n    element.addEventListener(Events.TOUCH_DRAG, this.mouseDragDrawCallback);\n    element.addEventListener(Events.TOUCH_TAP, this.mouseUpDrawCallback);\n    hideElementCursor(element);\n}\nfunction deactivateDraw(element) {\n    state.isInteractingWithTool = false;\n    element.removeEventListener(Events.MOUSE_UP, this.mouseUpDrawCallback);\n    element.removeEventListener(Events.MOUSE_DRAG, this.mouseDragDrawCallback);\n    element.removeEventListener(Events.MOUSE_CLICK, this.mouseUpDrawCallback);\n    element.removeEventListener(Events.TOUCH_END, this.mouseUpDrawCallback);\n    element.removeEventListener(Events.TOUCH_DRAG, this.mouseDragDrawCallback);\n    element.removeEventListener(Events.TOUCH_TAP, this.mouseUpDrawCallback);\n    resetElementCursor(element);\n}\nfunction mouseDragDrawCallback(evt) {\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const worldPos = currentPoints.world;\n    const canvasPos = currentPoints.canvas;\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const { annotation, viewportIdsToRender, xDir, yDir, spacing, movingTextBox, } = this.commonData;\n    const { polylineIndex, canvasPoints, newAnnotation } = this.drawData;\n    this.createMemo(element, annotation, { newAnnotation });\n    const lastCanvasPoint = canvasPoints[canvasPoints.length - 1];\n    const lastWorldPoint = viewport.canvasToWorld(lastCanvasPoint);\n    const worldPosDiff = vec3.create();\n    vec3.subtract(worldPosDiff, worldPos, lastWorldPoint);\n    const xDist = Math.abs(vec3.dot(worldPosDiff, xDir));\n    const yDist = Math.abs(vec3.dot(worldPosDiff, yDir));\n    if (xDist <= spacing[0] && yDist <= spacing[1]) {\n        return;\n    }\n    if (movingTextBox) {\n        this.isDrawing = false;\n        const { deltaPoints } = eventDetail;\n        const worldPosDelta = deltaPoints.world;\n        const { textBox } = annotation.data.handles;\n        const { worldPosition } = textBox;\n        worldPosition[0] += worldPosDelta[0];\n        worldPosition[1] += worldPosDelta[1];\n        worldPosition[2] += worldPosDelta[2];\n        textBox.hasMoved = true;\n    }\n    else {\n        const crossingIndex = this.findCrossingIndexDuringCreate(evt);\n        if (crossingIndex !== undefined) {\n            this.applyCreateOnCross(evt, crossingIndex);\n        }\n        else {\n            const numPointsAdded = addCanvasPointsToArray(element, canvasPoints, canvasPos, this.commonData);\n            this.drawData.polylineIndex = polylineIndex + numPointsAdded;\n        }\n        annotation.invalidated = true;\n    }\n    triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n    if (annotation.invalidated) {\n        triggerAnnotationModified(annotation, element, ChangeTypes.HandlesUpdated);\n    }\n}\nfunction mouseUpDrawCallback(evt) {\n    const { allowOpenContours } = this.configuration;\n    const { canvasPoints, contourHoleProcessingEnabled } = this.drawData;\n    const firstPoint = canvasPoints[0];\n    const lastPoint = canvasPoints[canvasPoints.length - 1];\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    this.doneEditMemo();\n    this.drawData.newAnnotation = false;\n    if (allowOpenContours &&\n        !pointsAreWithinCloseContourProximity(firstPoint, lastPoint, this.configuration.closeContourProximity)) {\n        this.completeDrawOpenContour(element, { contourHoleProcessingEnabled });\n    }\n    else {\n        this.completeDrawClosedContour(element, { contourHoleProcessingEnabled });\n    }\n}\nfunction completeDrawClosedContour(element, options) {\n    this.removeCrossedLinesOnCompleteDraw();\n    const { canvasPoints } = this.drawData;\n    const { contourHoleProcessingEnabled, minPointsToSave } = options ?? {};\n    if (minPointsToSave && canvasPoints.length < minPointsToSave) {\n        return false;\n    }\n    if (this.haltDrawing(element, canvasPoints)) {\n        return false;\n    }\n    const { annotation, viewportIdsToRender } = this.commonData;\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n    addCanvasPointsToArray(element, canvasPoints, canvasPoints[0], this.commonData);\n    canvasPoints.pop();\n    const updatedPoints = shouldSmooth(this.configuration, annotation)\n        ? getInterpolatedPoints(this.configuration, canvasPoints)\n        : canvasPoints;\n    this.updateContourPolyline(annotation, {\n        points: updatedPoints,\n        closed: true,\n        targetWindingDirection: ContourWindingDirection.Clockwise,\n    }, viewport);\n    const { textBox } = annotation.data.handles;\n    if (!textBox?.hasMoved) {\n        triggerContourAnnotationCompleted(annotation, contourHoleProcessingEnabled);\n    }\n    this.isDrawing = false;\n    this.drawData = undefined;\n    this.commonData = undefined;\n    triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n    this.deactivateDraw(element);\n    return true;\n}\nfunction removeCrossedLinesOnCompleteDraw() {\n    const { canvasPoints } = this.drawData;\n    const numPoints = canvasPoints.length;\n    const endToStart = [canvasPoints[0], canvasPoints[numPoints - 1]];\n    const canvasPointsMinusEnds = canvasPoints.slice(0, -1).slice(1);\n    const lineSegment = getFirstLineSegmentIntersectionIndexes(canvasPointsMinusEnds, endToStart[0], endToStart[1], false);\n    if (lineSegment) {\n        const indexToRemoveUpTo = lineSegment[1];\n        if (indexToRemoveUpTo === 1) {\n            this.drawData.canvasPoints = canvasPoints.splice(1);\n        }\n        else {\n            this.drawData.canvasPoints = canvasPoints.splice(0, indexToRemoveUpTo);\n        }\n    }\n}\nfunction completeDrawOpenContour(element, options) {\n    const { canvasPoints } = this.drawData;\n    const { contourHoleProcessingEnabled } = options ?? {};\n    if (this.haltDrawing(element, canvasPoints)) {\n        return false;\n    }\n    const { annotation, viewportIdsToRender } = this.commonData;\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n    const updatedPoints = shouldSmooth(this.configuration, annotation)\n        ? getInterpolatedPoints(this.configuration, canvasPoints)\n        : canvasPoints;\n    this.updateContourPolyline(annotation, {\n        points: updatedPoints,\n        closed: false,\n    }, viewport);\n    const { textBox } = annotation.data.handles;\n    const worldPoints = annotation.data.contour.polyline;\n    annotation.data.handles.points = [\n        worldPoints[0],\n        worldPoints[worldPoints.length - 1],\n    ];\n    if (annotation.data.isOpenUShapeContour) {\n        annotation.data.openUShapeContourVectorToPeak =\n            findOpenUShapedContourVectorToPeak(canvasPoints, viewport);\n    }\n    if (!textBox.hasMoved) {\n        triggerContourAnnotationCompleted(annotation, contourHoleProcessingEnabled);\n    }\n    this.isDrawing = false;\n    this.drawData = undefined;\n    this.commonData = undefined;\n    triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n    this.deactivateDraw(element);\n    return true;\n}\nfunction findCrossingIndexDuringCreate(evt) {\n    const eventDetail = evt.detail;\n    const { currentPoints, lastPoints } = eventDetail;\n    const canvasPos = currentPoints.canvas;\n    const lastCanvasPoint = lastPoints.canvas;\n    const { canvasPoints } = this.drawData;\n    const pointsLessLastOne = canvasPoints.slice(0, -1);\n    const lineSegment = getFirstLineSegmentIntersectionIndexes(pointsLessLastOne, canvasPos, lastCanvasPoint, false);\n    if (lineSegment === undefined) {\n        return;\n    }\n    const crossingIndex = lineSegment[0];\n    return crossingIndex;\n}\nfunction applyCreateOnCross(evt, crossingIndex) {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const { canvasPoints, contourHoleProcessingEnabled } = this.drawData;\n    const { annotation, viewportIdsToRender } = this.commonData;\n    addCanvasPointsToArray(element, canvasPoints, canvasPoints[crossingIndex], this.commonData);\n    canvasPoints.pop();\n    const remainingPoints = canvasPoints.slice(crossingIndex);\n    const newArea = polyline.getArea(remainingPoints);\n    if (utilities.isEqual(newArea, 0)) {\n        canvasPoints.splice(crossingIndex + 1);\n        return;\n    }\n    canvasPoints.splice(0, crossingIndex);\n    const options = { contourHoleProcessingEnabled, minPointsToSave: 3 };\n    if (this.completeDrawClosedContour(element, options)) {\n        this.activateClosedContourEdit(evt, annotation, viewportIdsToRender);\n    }\n}\nfunction cancelDrawing(element) {\n    const { allowOpenContours } = this.configuration;\n    const { canvasPoints, contourHoleProcessingEnabled } = this.drawData;\n    const firstPoint = canvasPoints[0];\n    const lastPoint = canvasPoints[canvasPoints.length - 1];\n    if (allowOpenContours &&\n        !pointsAreWithinCloseContourProximity(firstPoint, lastPoint, this.configuration.closeContourProximity)) {\n        this.completeDrawOpenContour(element, { contourHoleProcessingEnabled });\n    }\n    else {\n        this.completeDrawClosedContour(element, { contourHoleProcessingEnabled });\n    }\n}\nfunction shouldHaltDrawing(canvasPoints, subPixelResolution) {\n    const minPoints = Math.max(subPixelResolution * 3, 3);\n    return canvasPoints.length < minPoints;\n}\nfunction haltDrawing(element, canvasPoints) {\n    const { subPixelResolution } = this.configuration;\n    if (shouldHaltDrawing(canvasPoints, subPixelResolution)) {\n        const { annotation, viewportIdsToRender } = this.commonData;\n        const enabledElement = getEnabledElement(element);\n        const { renderingEngine } = enabledElement;\n        removeAnnotation(annotation.annotationUID);\n        this.isDrawing = false;\n        this.drawData = undefined;\n        this.commonData = undefined;\n        triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        this.deactivateDraw(element);\n        return true;\n    }\n    return false;\n}\nfunction registerDrawLoop(toolInstance) {\n    toolInstance.activateDraw = activateDraw.bind(toolInstance);\n    toolInstance.deactivateDraw = deactivateDraw.bind(toolInstance);\n    toolInstance.applyCreateOnCross = applyCreateOnCross.bind(toolInstance);\n    toolInstance.findCrossingIndexDuringCreate =\n        findCrossingIndexDuringCreate.bind(toolInstance);\n    toolInstance.completeDrawOpenContour =\n        completeDrawOpenContour.bind(toolInstance);\n    toolInstance.removeCrossedLinesOnCompleteDraw =\n        removeCrossedLinesOnCompleteDraw.bind(toolInstance);\n    toolInstance.mouseDragDrawCallback = mouseDragDrawCallback.bind(toolInstance);\n    toolInstance.mouseUpDrawCallback = mouseUpDrawCallback.bind(toolInstance);\n    toolInstance.completeDrawClosedContour =\n        completeDrawClosedContour.bind(toolInstance);\n    toolInstance.cancelDrawing = cancelDrawing.bind(toolInstance);\n    toolInstance.haltDrawing = haltDrawing.bind(toolInstance);\n}\nexport default registerDrawLoop;\n","import { vec2 } from 'gl-matrix';\nimport { polyline } from '../../../utilities/math';\nconst { addCanvasPointsToArray, getFirstLineSegmentIntersectionIndexes } = polyline;\nfunction checkForFirstCrossing(evt, isClosedContour) {\n    const eventDetail = evt.detail;\n    const { element, currentPoints, lastPoints } = eventDetail;\n    const canvasPos = currentPoints.canvas;\n    const lastCanvasPoint = lastPoints.canvas;\n    const { editCanvasPoints, prevCanvasPoints } = this.editData;\n    const crossedLineSegment = getFirstLineSegmentIntersectionIndexes(prevCanvasPoints, canvasPos, lastCanvasPoint, isClosedContour);\n    if (crossedLineSegment) {\n        this.editData.startCrossingIndex = crossedLineSegment[0];\n        this.removePointsUpUntilFirstCrossing(isClosedContour);\n    }\n    else if (prevCanvasPoints.length >= 2) {\n        if (editCanvasPoints.length >\n            this.configuration.checkCanvasEditFallbackProximity) {\n            const firstEditCanvasPoint = editCanvasPoints[0];\n            const distanceIndexPairs = [];\n            for (let i = 0; i < prevCanvasPoints.length; i++) {\n                const prevCanvasPoint = prevCanvasPoints[i];\n                const distance = vec2.distance(prevCanvasPoint, firstEditCanvasPoint);\n                distanceIndexPairs.push({ distance, index: i });\n            }\n            distanceIndexPairs.sort((a, b) => a.distance - b.distance);\n            const twoClosestDistanceIndexPairs = [\n                distanceIndexPairs[0],\n                distanceIndexPairs[1],\n            ];\n            const lowestIndex = Math.min(twoClosestDistanceIndexPairs[0].index, twoClosestDistanceIndexPairs[1].index);\n            this.editData.startCrossingIndex = lowestIndex;\n        }\n        else {\n            const dir = vec2.create();\n            vec2.subtract(dir, editCanvasPoints[1], editCanvasPoints[0]);\n            vec2.normalize(dir, dir);\n            const proximity = 6;\n            const extendedPoint = [\n                editCanvasPoints[0][0] - dir[0] * proximity,\n                editCanvasPoints[0][1] - dir[1] * proximity,\n            ];\n            const crossedLineSegmentFromExtendedPoint = getFirstLineSegmentIntersectionIndexes(prevCanvasPoints, extendedPoint, editCanvasPoints[0], isClosedContour);\n            if (crossedLineSegmentFromExtendedPoint) {\n                const pointsToPrepend = [extendedPoint];\n                addCanvasPointsToArray(element, pointsToPrepend, editCanvasPoints[0], this.commonData);\n                editCanvasPoints.unshift(...pointsToPrepend);\n                this.removePointsUpUntilFirstCrossing(isClosedContour);\n                this.editData.editIndex = editCanvasPoints.length - 1;\n                this.editData.startCrossingIndex =\n                    crossedLineSegmentFromExtendedPoint[0];\n            }\n        }\n    }\n}\nfunction removePointsUpUntilFirstCrossing(isClosedContour) {\n    const { editCanvasPoints, prevCanvasPoints } = this.editData;\n    let numPointsToRemove = 0;\n    for (let i = 0; i < editCanvasPoints.length - 1; i++) {\n        const firstLine = [editCanvasPoints[i], editCanvasPoints[i + 1]];\n        const didCrossLine = !!getFirstLineSegmentIntersectionIndexes(prevCanvasPoints, firstLine[0], firstLine[1], isClosedContour);\n        numPointsToRemove++;\n        if (didCrossLine) {\n            break;\n        }\n    }\n    editCanvasPoints.splice(0, numPointsToRemove);\n    this.editData.editIndex = editCanvasPoints.length - 1;\n}\nfunction checkForSecondCrossing(evt, isClosedContour) {\n    const eventDetail = evt.detail;\n    const { currentPoints, lastPoints } = eventDetail;\n    const canvasPos = currentPoints.canvas;\n    const lastCanvasPoint = lastPoints.canvas;\n    const { prevCanvasPoints } = this.editData;\n    const crossedLineSegment = getFirstLineSegmentIntersectionIndexes(prevCanvasPoints, canvasPos, lastCanvasPoint, isClosedContour);\n    if (!crossedLineSegment) {\n        return false;\n    }\n    return true;\n}\nfunction removePointsAfterSecondCrossing(isClosedContour) {\n    const { prevCanvasPoints, editCanvasPoints } = this.editData;\n    for (let i = editCanvasPoints.length - 1; i > 0; i--) {\n        const lastLine = [editCanvasPoints[i], editCanvasPoints[i - 1]];\n        const didCrossLine = !!getFirstLineSegmentIntersectionIndexes(prevCanvasPoints, lastLine[0], lastLine[1], isClosedContour);\n        editCanvasPoints.pop();\n        if (didCrossLine) {\n            break;\n        }\n    }\n}\nfunction findSnapIndex() {\n    const { editCanvasPoints, prevCanvasPoints, startCrossingIndex } = this.editData;\n    if (startCrossingIndex === undefined) {\n        return;\n    }\n    const lastEditCanvasPoint = editCanvasPoints[editCanvasPoints.length - 1];\n    const distanceIndexPairs = [];\n    for (let i = 0; i < prevCanvasPoints.length; i++) {\n        const prevCanvasPoint = prevCanvasPoints[i];\n        const distance = vec2.distance(prevCanvasPoint, lastEditCanvasPoint);\n        distanceIndexPairs.push({ distance, index: i });\n    }\n    distanceIndexPairs.sort((a, b) => a.distance - b.distance);\n    const editCanvasPointsLessLastOne = editCanvasPoints.slice(0, -1);\n    for (let i = 0; i < distanceIndexPairs.length; i++) {\n        const { index } = distanceIndexPairs[i];\n        const snapCanvasPosition = prevCanvasPoints[index];\n        const lastEditCanvasPoint = editCanvasPoints[editCanvasPoints.length - 1];\n        const crossedLineSegment = getFirstLineSegmentIntersectionIndexes(editCanvasPointsLessLastOne, snapCanvasPosition, lastEditCanvasPoint, false);\n        if (!crossedLineSegment) {\n            return index;\n        }\n    }\n    return -1;\n}\nfunction checkAndRemoveCrossesOnEditLine(evt) {\n    const eventDetail = evt.detail;\n    const { currentPoints, lastPoints } = eventDetail;\n    const canvasPos = currentPoints.canvas;\n    const lastCanvasPoint = lastPoints.canvas;\n    const { editCanvasPoints } = this.editData;\n    const editCanvasPointsLessLastOne = editCanvasPoints.slice(0, -2);\n    const crossedLineSegment = getFirstLineSegmentIntersectionIndexes(editCanvasPointsLessLastOne, canvasPos, lastCanvasPoint, false);\n    if (!crossedLineSegment) {\n        return;\n    }\n    const editIndexCrossed = crossedLineSegment[0];\n    const numPointsToRemove = editCanvasPoints.length - editIndexCrossed;\n    for (let i = 0; i < numPointsToRemove; i++) {\n        editCanvasPoints.pop();\n    }\n}\nfunction registerEditLoopCommon(toolInstance) {\n    toolInstance.checkForFirstCrossing = checkForFirstCrossing.bind(toolInstance);\n    toolInstance.removePointsUpUntilFirstCrossing =\n        removePointsUpUntilFirstCrossing.bind(toolInstance);\n    toolInstance.checkForSecondCrossing =\n        checkForSecondCrossing.bind(toolInstance);\n    toolInstance.findSnapIndex = findSnapIndex.bind(toolInstance);\n    toolInstance.removePointsAfterSecondCrossing =\n        removePointsAfterSecondCrossing.bind(toolInstance);\n    toolInstance.checkAndRemoveCrossesOnEditLine =\n        checkAndRemoveCrossesOnEditLine.bind(toolInstance);\n}\nexport default registerEditLoopCommon;\n","import { vec2 } from 'gl-matrix';\nexport default function findOpenUShapedContourVectorToPeak(canvasPoints, viewport) {\n    const first = canvasPoints[0];\n    const last = canvasPoints[canvasPoints.length - 1];\n    const firstToLastUnitVector = vec2.create();\n    vec2.set(firstToLastUnitVector, last[0] - first[0], last[1] - first[1]);\n    vec2.normalize(firstToLastUnitVector, firstToLastUnitVector);\n    const normalVector1 = vec2.create();\n    const normalVector2 = vec2.create();\n    vec2.set(normalVector1, -firstToLastUnitVector[1], firstToLastUnitVector[0]);\n    vec2.set(normalVector2, firstToLastUnitVector[1], -firstToLastUnitVector[0]);\n    const centerOfFirstToLast = [\n        (first[0] + last[0]) / 2,\n        (first[1] + last[1]) / 2,\n    ];\n    const furthest = {\n        dist: 0,\n        index: null,\n    };\n    for (let i = 0; i < canvasPoints.length; i++) {\n        const canvasPoint = canvasPoints[i];\n        const distance = vec2.dist(canvasPoint, centerOfFirstToLast);\n        if (distance > furthest.dist) {\n            furthest.dist = distance;\n            furthest.index = i;\n        }\n    }\n    const toFurthest = [\n        canvasPoints[furthest.index],\n        centerOfFirstToLast,\n    ];\n    const toFurthestWorld = toFurthest.map(viewport.canvasToWorld);\n    return toFurthestWorld;\n}\nexport function findOpenUShapedContourVectorToPeakOnRender(enabledElement, annotation) {\n    const { viewport } = enabledElement;\n    const canvasPoints = annotation.data.contour.polyline.map(viewport.worldToCanvas);\n    return findOpenUShapedContourVectorToPeak(canvasPoints, viewport);\n}\n","import { vec3, vec2 } from 'gl-matrix';\nimport { getEnabledElement } from '@cornerstonejs/core';\nimport { state } from '../../../store/state';\nimport { Events } from '../../../enums';\nimport { resetElementCursor, hideElementCursor, } from '../../../cursors/elementCursor';\nimport { polyline } from '../../../utilities/math';\nimport { shouldSmooth, getInterpolatedPoints, } from '../../../utilities/planarFreehandROITool/smoothPoints';\nimport triggerAnnotationRenderForViewportIds from '../../../utilities/triggerAnnotationRenderForViewportIds';\nimport updateContourPolyline from '../../../utilities/contours/updateContourPolyline';\nimport findOpenUShapedContourVectorToPeak from './findOpenUShapedContourVectorToPeak';\nimport { triggerAnnotationModified } from '../../../stateManagement/annotation/helpers/state';\nconst { addCanvasPointsToArray, getSubPixelSpacingAndXYDirections } = polyline;\nfunction activateOpenContourEdit(evt, annotation, viewportIdsToRender) {\n    this.isEditingOpen = true;\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const canvasPos = currentPoints.canvas;\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    this.doneEditMemo();\n    const prevCanvasPoints = annotation.data.contour.polyline.map(viewport.worldToCanvas);\n    const { spacing, xDir, yDir } = getSubPixelSpacingAndXYDirections(viewport, this.configuration.subPixelResolution);\n    this.editData = {\n        prevCanvasPoints,\n        editCanvasPoints: [canvasPos],\n        startCrossingIndex: undefined,\n        editIndex: 0,\n    };\n    this.commonData = {\n        annotation,\n        viewportIdsToRender,\n        spacing,\n        xDir,\n        yDir,\n        movingTextBox: false,\n    };\n    state.isInteractingWithTool = true;\n    element.addEventListener(Events.MOUSE_UP, this.mouseUpOpenContourEditCallback);\n    element.addEventListener(Events.MOUSE_DRAG, this.mouseDragOpenContourEditCallback);\n    element.addEventListener(Events.MOUSE_CLICK, this.mouseUpOpenContourEditCallback);\n    element.addEventListener(Events.TOUCH_END, this.mouseUpOpenContourEditCallback);\n    element.addEventListener(Events.TOUCH_DRAG, this.mouseDragOpenContourEditCallback);\n    element.addEventListener(Events.TOUCH_TAP, this.mouseUpOpenContourEditCallback);\n    hideElementCursor(element);\n}\nfunction deactivateOpenContourEdit(element) {\n    state.isInteractingWithTool = false;\n    element.removeEventListener(Events.MOUSE_UP, this.mouseUpOpenContourEditCallback);\n    element.removeEventListener(Events.MOUSE_DRAG, this.mouseDragOpenContourEditCallback);\n    element.removeEventListener(Events.MOUSE_CLICK, this.mouseUpOpenContourEditCallback);\n    element.removeEventListener(Events.TOUCH_END, this.mouseUpOpenContourEditCallback);\n    element.removeEventListener(Events.TOUCH_DRAG, this.mouseDragOpenContourEditCallback);\n    element.removeEventListener(Events.TOUCH_TAP, this.mouseUpOpenContourEditCallback);\n    resetElementCursor(element);\n}\nfunction mouseDragOpenContourEditCallback(evt) {\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const worldPos = currentPoints.world;\n    const canvasPos = currentPoints.canvas;\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const { viewportIdsToRender, xDir, yDir, spacing } = this.commonData;\n    const { editIndex, editCanvasPoints, startCrossingIndex } = this.editData;\n    const lastCanvasPoint = editCanvasPoints[editCanvasPoints.length - 1];\n    const lastWorldPoint = viewport.canvasToWorld(lastCanvasPoint);\n    const worldPosDiff = vec3.create();\n    this.createMemo(element, this.commonData.annotation);\n    vec3.subtract(worldPosDiff, worldPos, lastWorldPoint);\n    const xDist = Math.abs(vec3.dot(worldPosDiff, xDir));\n    const yDist = Math.abs(vec3.dot(worldPosDiff, yDir));\n    if (xDist <= spacing[0] && yDist <= spacing[1]) {\n        return;\n    }\n    if (startCrossingIndex !== undefined) {\n        this.checkAndRemoveCrossesOnEditLine(evt);\n    }\n    const numPointsAdded = addCanvasPointsToArray(element, editCanvasPoints, canvasPos, this.commonData);\n    const currentEditIndex = editIndex + numPointsAdded;\n    this.editData.editIndex = currentEditIndex;\n    if (startCrossingIndex === undefined && editCanvasPoints.length > 1) {\n        this.checkForFirstCrossing(evt, false);\n    }\n    this.editData.snapIndex = this.findSnapIndex();\n    this.editData.fusedCanvasPoints = this.fuseEditPointsWithOpenContour(evt);\n    if (startCrossingIndex !== undefined &&\n        this.checkForSecondCrossing(evt, false)) {\n        this.removePointsAfterSecondCrossing(false);\n        this.finishEditOpenOnSecondCrossing(evt);\n    }\n    else if (this.checkIfShouldOverwriteAnEnd(evt)) {\n        this.openContourEditOverwriteEnd(evt);\n    }\n    triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n}\nfunction openContourEditOverwriteEnd(evt) {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const { annotation, viewportIdsToRender } = this.commonData;\n    const fusedCanvasPoints = this.fuseEditPointsForOpenContourEndEdit();\n    updateContourPolyline(annotation, {\n        points: fusedCanvasPoints,\n        closed: false,\n    }, viewport);\n    const worldPoints = annotation.data.contour.polyline;\n    annotation.data.handles.points = [\n        worldPoints[0],\n        worldPoints[worldPoints.length - 1],\n    ];\n    annotation.data.handles.activeHandleIndex = 1;\n    triggerAnnotationModified(annotation, element);\n    this.isEditingOpen = false;\n    this.editData = undefined;\n    this.commonData = undefined;\n    this.doneEditMemo();\n    this.deactivateOpenContourEdit(element);\n    this.activateOpenContourEndEdit(evt, annotation, viewportIdsToRender, null);\n}\nfunction checkIfShouldOverwriteAnEnd(evt) {\n    const eventDetail = evt.detail;\n    const { currentPoints, lastPoints } = eventDetail;\n    const canvasPos = currentPoints.canvas;\n    const lastCanvasPos = lastPoints.canvas;\n    const { snapIndex, prevCanvasPoints, startCrossingIndex } = this.editData;\n    if (startCrossingIndex === undefined || snapIndex === undefined) {\n        return false;\n    }\n    if (snapIndex === -1) {\n        return true;\n    }\n    if (snapIndex !== 0 && snapIndex !== prevCanvasPoints.length - 1) {\n        return false;\n    }\n    const p1 = canvasPos;\n    const p2 = lastCanvasPos;\n    const p3 = prevCanvasPoints[snapIndex];\n    const a = vec2.create();\n    const b = vec2.create();\n    vec2.set(a, p1[0] - p2[0], p1[1] - p2[1]);\n    vec2.set(b, p1[0] - p3[0], p1[1] - p3[1]);\n    const aDotb = vec2.dot(a, b);\n    const magA = Math.sqrt(a[0] * a[0] + a[1] * a[1]);\n    const magB = Math.sqrt(b[0] * b[0] + b[1] * b[1]);\n    const theta = Math.acos(aDotb / (magA * magB));\n    if (theta < Math.PI / 2) {\n        return true;\n    }\n    return false;\n}\nfunction fuseEditPointsForOpenContourEndEdit() {\n    const { snapIndex, prevCanvasPoints, editCanvasPoints, startCrossingIndex } = this.editData;\n    const newCanvasPoints = [];\n    if (snapIndex === 0) {\n        for (let i = prevCanvasPoints.length - 1; i >= startCrossingIndex; i--) {\n            const canvasPoint = prevCanvasPoints[i];\n            newCanvasPoints.push([canvasPoint[0], canvasPoint[1]]);\n        }\n    }\n    else {\n        for (let i = 0; i < startCrossingIndex; i++) {\n            const canvasPoint = prevCanvasPoints[i];\n            newCanvasPoints.push([canvasPoint[0], canvasPoint[1]]);\n        }\n    }\n    const distanceBetweenCrossingIndexAndFirstPoint = vec2.distance(prevCanvasPoints[startCrossingIndex], editCanvasPoints[0]);\n    const distanceBetweenCrossingIndexAndLastPoint = vec2.distance(prevCanvasPoints[startCrossingIndex], editCanvasPoints[editCanvasPoints.length - 1]);\n    if (distanceBetweenCrossingIndexAndFirstPoint <\n        distanceBetweenCrossingIndexAndLastPoint) {\n        for (let i = 0; i < editCanvasPoints.length; i++) {\n            const canvasPoint = editCanvasPoints[i];\n            newCanvasPoints.push([canvasPoint[0], canvasPoint[1]]);\n        }\n    }\n    else {\n        for (let i = editCanvasPoints.length - 1; i >= 0; i--) {\n            const canvasPoint = editCanvasPoints[i];\n            newCanvasPoints.push([canvasPoint[0], canvasPoint[1]]);\n        }\n    }\n    return newCanvasPoints;\n}\nfunction fuseEditPointsWithOpenContour(evt) {\n    const { prevCanvasPoints, editCanvasPoints, startCrossingIndex, snapIndex } = this.editData;\n    if (startCrossingIndex === undefined || snapIndex === undefined) {\n        return undefined;\n    }\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const augmentedEditCanvasPoints = [...editCanvasPoints];\n    addCanvasPointsToArray(element, augmentedEditCanvasPoints, prevCanvasPoints[snapIndex], this.commonData);\n    if (augmentedEditCanvasPoints.length > editCanvasPoints.length) {\n        augmentedEditCanvasPoints.pop();\n    }\n    let lowIndex;\n    let highIndex;\n    if (startCrossingIndex > snapIndex) {\n        lowIndex = snapIndex;\n        highIndex = startCrossingIndex;\n    }\n    else {\n        lowIndex = startCrossingIndex;\n        highIndex = snapIndex;\n    }\n    const distanceBetweenLowAndFirstPoint = vec2.distance(prevCanvasPoints[lowIndex], augmentedEditCanvasPoints[0]);\n    const distanceBetweenLowAndLastPoint = vec2.distance(prevCanvasPoints[lowIndex], augmentedEditCanvasPoints[augmentedEditCanvasPoints.length - 1]);\n    const distanceBetweenHighAndFirstPoint = vec2.distance(prevCanvasPoints[highIndex], augmentedEditCanvasPoints[0]);\n    const distanceBetweenHighAndLastPoint = vec2.distance(prevCanvasPoints[highIndex], augmentedEditCanvasPoints[augmentedEditCanvasPoints.length - 1]);\n    const pointsToRender = [];\n    for (let i = 0; i < lowIndex; i++) {\n        const canvasPoint = prevCanvasPoints[i];\n        pointsToRender.push([canvasPoint[0], canvasPoint[1]]);\n    }\n    const inPlaceDistance = distanceBetweenLowAndFirstPoint + distanceBetweenHighAndLastPoint;\n    const reverseDistance = distanceBetweenLowAndLastPoint + distanceBetweenHighAndFirstPoint;\n    if (inPlaceDistance < reverseDistance) {\n        for (let i = 0; i < augmentedEditCanvasPoints.length; i++) {\n            const canvasPoint = augmentedEditCanvasPoints[i];\n            pointsToRender.push([canvasPoint[0], canvasPoint[1]]);\n        }\n    }\n    else {\n        for (let i = augmentedEditCanvasPoints.length - 1; i >= 0; i--) {\n            const canvasPoint = augmentedEditCanvasPoints[i];\n            pointsToRender.push([canvasPoint[0], canvasPoint[1]]);\n        }\n    }\n    for (let i = highIndex; i < prevCanvasPoints.length; i++) {\n        const canvasPoint = prevCanvasPoints[i];\n        pointsToRender.push([canvasPoint[0], canvasPoint[1]]);\n    }\n    return pointsToRender;\n}\nfunction finishEditOpenOnSecondCrossing(evt) {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n    const { annotation, viewportIdsToRender } = this.commonData;\n    const { fusedCanvasPoints, editCanvasPoints } = this.editData;\n    updateContourPolyline(annotation, {\n        points: fusedCanvasPoints,\n        closed: false,\n    }, viewport);\n    const worldPoints = annotation.data.contour.polyline;\n    annotation.data.handles.points = [\n        worldPoints[0],\n        worldPoints[worldPoints.length - 1],\n    ];\n    triggerAnnotationModified(annotation, element);\n    const lastEditCanvasPoint = editCanvasPoints.pop();\n    this.editData = {\n        prevCanvasPoints: fusedCanvasPoints,\n        editCanvasPoints: [lastEditCanvasPoint],\n        startCrossingIndex: undefined,\n        editIndex: 0,\n    };\n    triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n}\nfunction mouseUpOpenContourEditCallback(evt) {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    this.completeOpenContourEdit(element);\n}\nfunction completeOpenContourEdit(element) {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const { annotation, viewportIdsToRender } = this.commonData;\n    this.doneEditMemo();\n    const { fusedCanvasPoints, prevCanvasPoints } = this.editData;\n    if (fusedCanvasPoints) {\n        const updatedPoints = shouldSmooth(this.configuration)\n            ? getInterpolatedPoints(this.configuration, fusedCanvasPoints, prevCanvasPoints)\n            : fusedCanvasPoints;\n        const decimateConfig = this.configuration?.decimate || {};\n        updateContourPolyline(annotation, {\n            points: updatedPoints,\n            closed: false,\n        }, viewport, {\n            decimate: {\n                enabled: !!decimateConfig.enabled,\n                epsilon: decimateConfig.epsilon,\n            },\n        });\n        const worldPoints = annotation.data.contour.polyline;\n        annotation.data.handles.points = [\n            worldPoints[0],\n            worldPoints[worldPoints.length - 1],\n        ];\n        if (annotation.data.isOpenUShapeContour) {\n            annotation.data.openUShapeContourVectorToPeak =\n                findOpenUShapedContourVectorToPeak(fusedCanvasPoints, viewport);\n        }\n        triggerAnnotationModified(annotation, element);\n    }\n    this.isEditingOpen = false;\n    this.editData = undefined;\n    this.commonData = undefined;\n    triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n    this.deactivateOpenContourEdit(element);\n}\nfunction cancelOpenContourEdit(element) {\n    this.completeOpenContourEdit(element);\n}\nfunction registerOpenContourEditLoop(toolInstance) {\n    toolInstance.activateOpenContourEdit =\n        activateOpenContourEdit.bind(toolInstance);\n    toolInstance.deactivateOpenContourEdit =\n        deactivateOpenContourEdit.bind(toolInstance);\n    toolInstance.mouseDragOpenContourEditCallback =\n        mouseDragOpenContourEditCallback.bind(toolInstance);\n    toolInstance.mouseUpOpenContourEditCallback =\n        mouseUpOpenContourEditCallback.bind(toolInstance);\n    toolInstance.fuseEditPointsWithOpenContour =\n        fuseEditPointsWithOpenContour.bind(toolInstance);\n    toolInstance.finishEditOpenOnSecondCrossing =\n        finishEditOpenOnSecondCrossing.bind(toolInstance);\n    toolInstance.checkIfShouldOverwriteAnEnd =\n        checkIfShouldOverwriteAnEnd.bind(toolInstance);\n    toolInstance.fuseEditPointsForOpenContourEndEdit =\n        fuseEditPointsForOpenContourEndEdit.bind(toolInstance);\n    toolInstance.openContourEditOverwriteEnd =\n        openContourEditOverwriteEnd.bind(toolInstance);\n    toolInstance.cancelOpenContourEdit = cancelOpenContourEdit.bind(toolInstance);\n    toolInstance.completeOpenContourEdit =\n        completeOpenContourEdit.bind(toolInstance);\n}\nexport default registerOpenContourEditLoop;\n","import { getEnabledElement } from '@cornerstonejs/core';\nimport { state } from '../../../store/state';\nimport { Events } from '../../../enums';\nimport { hideElementCursor } from '../../../cursors/elementCursor';\nimport { polyline } from '../../../utilities/math';\nconst { getSubPixelSpacingAndXYDirections } = polyline;\nfunction activateOpenContourEndEdit(evt, annotation, viewportIdsToRender, handle) {\n    this.isDrawing = true;\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const { spacing, xDir, yDir } = getSubPixelSpacingAndXYDirections(viewport, this.configuration.subPixelResolution);\n    const canvasPoints = annotation.data.contour.polyline.map(viewport.worldToCanvas);\n    const handleIndexGrabbed = annotation.data.handles.activeHandleIndex;\n    if (handleIndexGrabbed === 0) {\n        canvasPoints.reverse();\n    }\n    let movingTextBox = false;\n    if (handle?.worldPosition) {\n        movingTextBox = true;\n    }\n    this.drawData = {\n        canvasPoints: canvasPoints,\n        polylineIndex: canvasPoints.length - 1,\n    };\n    this.commonData = {\n        annotation,\n        viewportIdsToRender,\n        spacing,\n        xDir,\n        yDir,\n        movingTextBox,\n    };\n    state.isInteractingWithTool = true;\n    element.addEventListener(Events.MOUSE_UP, this.mouseUpDrawCallback);\n    element.addEventListener(Events.MOUSE_DRAG, this.mouseDragDrawCallback);\n    element.addEventListener(Events.MOUSE_CLICK, this.mouseUpDrawCallback);\n    element.addEventListener(Events.TOUCH_END, this.mouseUpDrawCallback);\n    element.addEventListener(Events.TOUCH_DRAG, this.mouseDragDrawCallback);\n    element.addEventListener(Events.TOUCH_TAP, this.mouseUpDrawCallback);\n    hideElementCursor(element);\n}\nfunction registerOpenContourEndEditLoop(toolInstance) {\n    toolInstance.activateOpenContourEndEdit =\n        activateOpenContourEndEdit.bind(toolInstance);\n}\nexport default registerOpenContourEndEditLoop;\n","import { drawHandles as drawHandlesSvg, drawPolyline as drawPolylineSvg, drawPath as drawPathSvg, } from '../../../drawingSvg';\nimport { polyline } from '../../../utilities/math';\nimport { findOpenUShapedContourVectorToPeakOnRender } from './findOpenUShapedContourVectorToPeak';\nimport getContourHolesDataCanvas from '../../../utilities/contours/getContourHolesDataCanvas';\nconst { pointsAreWithinCloseContourProximity } = polyline;\nfunction _getRenderingOptions(enabledElement, annotation) {\n    const styleSpecifier = {\n        toolGroupId: this.toolGroupId,\n        toolName: this.getToolName(),\n        viewportId: enabledElement.viewport.id,\n        annotationUID: annotation.annotationUID,\n    };\n    const { lineWidth, lineDash, color, fillColor, fillOpacity } = this.getAnnotationStyle({\n        annotation,\n        styleSpecifier,\n    });\n    const { closed: isClosedContour } = annotation.data.contour;\n    const options = {\n        color,\n        width: lineWidth,\n        lineDash,\n        fillColor,\n        fillOpacity,\n        closePath: isClosedContour,\n    };\n    return options;\n}\nfunction renderContour(enabledElement, svgDrawingHelper, annotation) {\n    if (!enabledElement?.viewport?.getImageData()) {\n        return;\n    }\n    if (annotation.data.contour.closed) {\n        this.renderClosedContour(enabledElement, svgDrawingHelper, annotation);\n    }\n    else {\n        if (annotation.data.isOpenUShapeContour) {\n            calculateUShapeContourVectorToPeakIfNotPresent(enabledElement, annotation);\n            this.renderOpenUShapedContour(enabledElement, svgDrawingHelper, annotation);\n        }\n        else {\n            this.renderOpenContour(enabledElement, svgDrawingHelper, annotation);\n        }\n    }\n}\nfunction calculateUShapeContourVectorToPeakIfNotPresent(enabledElement, annotation) {\n    if (!annotation.data.openUShapeContourVectorToPeak) {\n        annotation.data.openUShapeContourVectorToPeak =\n            findOpenUShapedContourVectorToPeakOnRender(enabledElement, annotation);\n    }\n}\nfunction renderClosedContour(enabledElement, svgDrawingHelper, annotation) {\n    if (annotation.parentAnnotationUID) {\n        return;\n    }\n    const { viewport } = enabledElement;\n    const options = this._getRenderingOptions(enabledElement, annotation);\n    const canvasPolyline = annotation.data.contour.polyline.map((worldPos) => viewport.worldToCanvas(worldPos));\n    const childContours = getContourHolesDataCanvas(annotation, viewport);\n    const allContours = [canvasPolyline, ...childContours];\n    const polylineUID = '1';\n    drawPathSvg(svgDrawingHelper, annotation.annotationUID, polylineUID, allContours, options);\n}\nfunction renderOpenContour(enabledElement, svgDrawingHelper, annotation) {\n    const { viewport } = enabledElement;\n    const options = this._getRenderingOptions(enabledElement, annotation);\n    const canvasPoints = annotation.data.contour.polyline.map((worldPos) => viewport.worldToCanvas(worldPos));\n    const polylineUID = '1';\n    drawPolylineSvg(svgDrawingHelper, annotation.annotationUID, polylineUID, canvasPoints, options);\n    const activeHandleIndex = annotation.data.handles.activeHandleIndex;\n    if (this.configuration.alwaysRenderOpenContourHandles?.enabled === true) {\n        const radius = this.configuration.alwaysRenderOpenContourHandles.radius;\n        const handleGroupUID = '0';\n        const handlePoints = [\n            canvasPoints[0],\n            canvasPoints[canvasPoints.length - 1],\n        ];\n        if (activeHandleIndex === 0) {\n            handlePoints.shift();\n        }\n        else if (activeHandleIndex === 1) {\n            handlePoints.pop();\n        }\n        drawHandlesSvg(svgDrawingHelper, annotation.annotationUID, handleGroupUID, handlePoints, {\n            color: options.color,\n            handleRadius: radius,\n        });\n    }\n    if (activeHandleIndex !== null) {\n        const handleGroupUID = '1';\n        const indexOfCanvasPoints = activeHandleIndex === 0 ? 0 : canvasPoints.length - 1;\n        const handlePoint = canvasPoints[indexOfCanvasPoints];\n        drawHandlesSvg(svgDrawingHelper, annotation.annotationUID, handleGroupUID, [handlePoint], { color: options.color });\n    }\n}\nfunction renderOpenUShapedContour(enabledElement, svgDrawingHelper, annotation) {\n    const { viewport } = enabledElement;\n    const { openUShapeContourVectorToPeak } = annotation.data;\n    const { polyline } = annotation.data.contour;\n    this.renderOpenContour(enabledElement, svgDrawingHelper, annotation);\n    if (!openUShapeContourVectorToPeak) {\n        return;\n    }\n    const firstCanvasPoint = viewport.worldToCanvas(polyline[0]);\n    const lastCanvasPoint = viewport.worldToCanvas(polyline[polyline.length - 1]);\n    const openUShapeContourVectorToPeakCanvas = [\n        viewport.worldToCanvas(openUShapeContourVectorToPeak[0]),\n        viewport.worldToCanvas(openUShapeContourVectorToPeak[1]),\n    ];\n    const options = this._getRenderingOptions(enabledElement, annotation);\n    drawPolylineSvg(svgDrawingHelper, annotation.annotationUID, 'first-to-last', [firstCanvasPoint, lastCanvasPoint], {\n        color: options.color,\n        width: options.width,\n        closePath: false,\n        lineDash: '2,2',\n    });\n    drawPolylineSvg(svgDrawingHelper, annotation.annotationUID, 'midpoint-to-open-contour', [\n        openUShapeContourVectorToPeakCanvas[0],\n        openUShapeContourVectorToPeakCanvas[1],\n    ], {\n        color: options.color,\n        width: options.width,\n        closePath: false,\n        lineDash: '2,2',\n    });\n}\nfunction renderContourBeingDrawn(enabledElement, svgDrawingHelper, annotation) {\n    const options = this._getRenderingOptions(enabledElement, annotation);\n    const { allowOpenContours } = this.configuration;\n    const { canvasPoints } = this.drawData;\n    options.closePath = false;\n    drawPolylineSvg(svgDrawingHelper, annotation.annotationUID, '1', canvasPoints, options);\n    if (allowOpenContours) {\n        const firstPoint = canvasPoints[0];\n        const lastPoint = canvasPoints[canvasPoints.length - 1];\n        if (pointsAreWithinCloseContourProximity(firstPoint, lastPoint, this.configuration.closeContourProximity)) {\n            drawPolylineSvg(svgDrawingHelper, annotation.annotationUID, '2', [lastPoint, firstPoint], options);\n        }\n        else {\n            const handleGroupUID = '0';\n            drawHandlesSvg(svgDrawingHelper, annotation.annotationUID, handleGroupUID, [firstPoint], { color: options.color, handleRadius: 2 });\n        }\n    }\n}\nfunction renderClosedContourBeingEdited(enabledElement, svgDrawingHelper, annotation) {\n    const { viewport } = enabledElement;\n    const { fusedCanvasPoints } = this.editData;\n    if (fusedCanvasPoints === undefined) {\n        this.renderClosedContour(enabledElement, svgDrawingHelper, annotation);\n        return;\n    }\n    const childContours = getContourHolesDataCanvas(annotation, viewport);\n    const allContours = [fusedCanvasPoints, ...childContours];\n    const options = this._getRenderingOptions(enabledElement, annotation);\n    const polylineUIDToRender = 'preview-1';\n    if (annotation.parentAnnotationUID && options.fillOpacity) {\n        options.fillOpacity = 0;\n    }\n    drawPathSvg(svgDrawingHelper, annotation.annotationUID, polylineUIDToRender, allContours, options);\n}\nfunction renderOpenContourBeingEdited(enabledElement, svgDrawingHelper, annotation) {\n    const { fusedCanvasPoints } = this.editData;\n    if (fusedCanvasPoints === undefined) {\n        this.renderOpenContour(enabledElement, svgDrawingHelper, annotation);\n        return;\n    }\n    const options = this._getRenderingOptions(enabledElement, annotation);\n    const polylineUIDToRender = 'preview-1';\n    drawPolylineSvg(svgDrawingHelper, annotation.annotationUID, polylineUIDToRender, fusedCanvasPoints, options);\n}\nfunction renderPointContourWithMarker(enabledElement, svgDrawingHelper, annotation) {\n    if (annotation.parentAnnotationUID) {\n        return;\n    }\n    const { viewport } = enabledElement;\n    const options = this._getRenderingOptions(enabledElement, annotation);\n    const canvasPolyline = annotation.data.contour.polyline.map((worldPos) => viewport.worldToCanvas(worldPos));\n    const childContours = getContourHolesDataCanvas(annotation, viewport);\n    const polylineUID = '1';\n    const center = canvasPolyline[0];\n    const radius = 6;\n    const numberOfPoints = 100;\n    const circlePoints = [];\n    for (let i = 0; i < numberOfPoints; i++) {\n        const angle = (i / numberOfPoints) * 2 * Math.PI;\n        const x = center[0] + radius * Math.cos(angle);\n        const y = center[1] + radius * Math.sin(angle);\n        circlePoints.push([x, y]);\n    }\n    const crosshair = [\n        [center[0] - radius * 2, center[1]],\n        [center[0] + radius * 2, center[1]],\n        [center[0], center[1] - radius * 2],\n        [center[0], center[1] + radius * 2],\n    ];\n    drawPathSvg(svgDrawingHelper, annotation.annotationUID, polylineUID + '-crosshair_v', [crosshair[0], crosshair[1]], options);\n    drawPathSvg(svgDrawingHelper, annotation.annotationUID, polylineUID + '-crosshair_h', [crosshair[2], crosshair[3]], options);\n    const allContours = [circlePoints, ...childContours];\n    drawPathSvg(svgDrawingHelper, annotation.annotationUID, polylineUID, allContours, options);\n}\nfunction registerRenderMethods(toolInstance) {\n    toolInstance.renderContour = renderContour.bind(toolInstance);\n    toolInstance.renderClosedContour = renderClosedContour.bind(toolInstance);\n    toolInstance.renderOpenContour = renderOpenContour.bind(toolInstance);\n    toolInstance.renderPointContourWithMarker =\n        renderPointContourWithMarker.bind(toolInstance);\n    toolInstance.renderOpenUShapedContour =\n        renderOpenUShapedContour.bind(toolInstance);\n    toolInstance.renderContourBeingDrawn =\n        renderContourBeingDrawn.bind(toolInstance);\n    toolInstance.renderClosedContourBeingEdited =\n        renderClosedContourBeingEdited.bind(toolInstance);\n    toolInstance.renderOpenContourBeingEdited =\n        renderOpenContourBeingEdited.bind(toolInstance);\n    toolInstance._getRenderingOptions = _getRenderingOptions.bind(toolInstance);\n}\nexport default registerRenderMethods;\n","import { BaseVolumeViewport, cache, getEnabledElement, metaData, utilities as csUtils, StackViewport, } from '@cornerstonejs/core';\nimport { vec2 } from 'gl-matrix';\nimport AnnotationDisplayTool from './AnnotationDisplayTool';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport { addAnnotation, removeAnnotation, getAnnotation, } from '../../stateManagement/annotation/annotationState';\nimport { triggerAnnotationModified } from '../../stateManagement/annotation/helpers/state';\nimport ChangeTypes from '../../enums/ChangeTypes';\nimport { setAnnotationSelected } from '../../stateManagement/annotation/annotationSelection';\nimport { addContourSegmentationAnnotation } from '../../utilities/contourSegmentation';\nconst { DefaultHistoryMemo } = csUtils.HistoryMemo;\nconst { PointsManager } = csUtils;\nclass AnnotationTool extends AnnotationDisplayTool {\n    static createAnnotation(...annotationBaseData) {\n        let annotation = {\n            annotationUID: null,\n            highlighted: true,\n            invalidated: true,\n            metadata: {\n                toolName: this.toolName,\n            },\n            data: {\n                text: '',\n                handles: {\n                    points: new Array(),\n                    textBox: {\n                        hasMoved: false,\n                        worldPosition: [0, 0, 0],\n                        worldBoundingBox: {\n                            topLeft: [0, 0, 0],\n                            topRight: [0, 0, 0],\n                            bottomLeft: [0, 0, 0],\n                            bottomRight: [0, 0, 0],\n                        },\n                    },\n                },\n                label: '',\n            },\n        };\n        for (const baseData of annotationBaseData) {\n            annotation = csUtils.deepMerge(annotation, baseData);\n        }\n        return annotation;\n    }\n    static createAnnotationForViewport(viewport, ...annotationBaseData) {\n        return this.createAnnotation({ metadata: viewport.getViewReference() }, ...annotationBaseData);\n    }\n    static createAndAddAnnotation(viewport, ...annotationBaseData) {\n        const annotation = this.createAnnotationForViewport(viewport, ...annotationBaseData);\n        addAnnotation(annotation, viewport.element);\n        triggerAnnotationModified(annotation, viewport.element);\n    }\n    constructor(toolProps, defaultToolProps) {\n        super(toolProps, defaultToolProps);\n        this.mouseMoveCallback = (evt, filteredAnnotations) => {\n            if (!filteredAnnotations) {\n                return false;\n            }\n            const { element, currentPoints } = evt.detail;\n            const canvasCoords = currentPoints.canvas;\n            let annotationsNeedToBeRedrawn = false;\n            for (const annotation of filteredAnnotations) {\n                if (isAnnotationLocked(annotation.annotationUID) ||\n                    !isAnnotationVisible(annotation.annotationUID)) {\n                    continue;\n                }\n                const { data } = annotation;\n                const activateHandleIndex = data.handles\n                    ? data.handles.activeHandleIndex\n                    : undefined;\n                const near = this._imagePointNearToolOrHandle(element, annotation, canvasCoords, 6);\n                const nearToolAndNotMarkedActive = near && !annotation.highlighted;\n                const notNearToolAndMarkedActive = !near && annotation.highlighted;\n                if (nearToolAndNotMarkedActive || notNearToolAndMarkedActive) {\n                    annotation.highlighted = !annotation.highlighted;\n                    annotationsNeedToBeRedrawn = true;\n                }\n                else if (data.handles &&\n                    data.handles.activeHandleIndex !== activateHandleIndex) {\n                    annotationsNeedToBeRedrawn = true;\n                }\n            }\n            return annotationsNeedToBeRedrawn;\n        };\n        this.isSuvScaled = AnnotationTool.isSuvScaled;\n        if (toolProps.configuration?.getTextLines) {\n            this.configuration.getTextLines = toolProps.configuration.getTextLines;\n        }\n        if (toolProps.configuration?.statsCalculator) {\n            this.configuration.statsCalculator =\n                toolProps.configuration.statsCalculator;\n        }\n    }\n    getHandleNearImagePoint(element, annotation, canvasCoords, proximity) {\n        const enabledElement = getEnabledElement(element);\n        const { viewport } = enabledElement;\n        const { data } = annotation;\n        const { isCanvasAnnotation } = data;\n        const { points, textBox } = data.handles;\n        if (textBox) {\n            const { worldBoundingBox } = textBox;\n            if (worldBoundingBox) {\n                const canvasBoundingBox = {\n                    topLeft: viewport.worldToCanvas(worldBoundingBox.topLeft),\n                    topRight: viewport.worldToCanvas(worldBoundingBox.topRight),\n                    bottomLeft: viewport.worldToCanvas(worldBoundingBox.bottomLeft),\n                    bottomRight: viewport.worldToCanvas(worldBoundingBox.bottomRight),\n                };\n                if (canvasCoords[0] >= canvasBoundingBox.topLeft[0] &&\n                    canvasCoords[0] <= canvasBoundingBox.bottomRight[0] &&\n                    canvasCoords[1] >= canvasBoundingBox.topLeft[1] &&\n                    canvasCoords[1] <= canvasBoundingBox.bottomRight[1]) {\n                    data.handles.activeHandleIndex = null;\n                    return textBox;\n                }\n            }\n        }\n        for (let i = 0; i < points?.length; i++) {\n            const point = points[i];\n            const annotationCanvasCoordinate = isCanvasAnnotation\n                ? point.slice(0, 2)\n                : viewport.worldToCanvas(point);\n            const near = vec2.distance(canvasCoords, annotationCanvasCoordinate) < proximity;\n            if (near === true) {\n                data.handles.activeHandleIndex = i;\n                return point;\n            }\n        }\n        data.handles.activeHandleIndex = null;\n    }\n    getLinkedTextBoxStyle(specifications, annotation) {\n        return {\n            visibility: this.getStyle('textBoxVisibility', specifications, annotation),\n            fontFamily: this.getStyle('textBoxFontFamily', specifications, annotation),\n            fontSize: this.getStyle('textBoxFontSize', specifications, annotation),\n            color: this.getStyle('textBoxColor', specifications, annotation),\n            shadow: this.getStyle('textBoxShadow', specifications, annotation),\n            background: this.getStyle('textBoxBackground', specifications, annotation),\n            lineWidth: this.getStyle('textBoxLinkLineWidth', specifications, annotation),\n            lineDash: this.getStyle('textBoxLinkLineDash', specifications, annotation),\n        };\n    }\n    static isSuvScaled(viewport, targetId, imageId) {\n        if (viewport instanceof BaseVolumeViewport) {\n            const volumeId = csUtils.getVolumeId(targetId);\n            const volume = cache.getVolume(volumeId);\n            return volume?.scaling?.PT !== undefined;\n        }\n        const scalingModule = imageId && metaData.get('scalingModule', imageId);\n        return typeof scalingModule?.suvbw === 'number';\n    }\n    getAnnotationStyle(context) {\n        const { annotation, styleSpecifier } = context;\n        const getStyle = (property) => this.getStyle(property, styleSpecifier, annotation);\n        const { annotationUID } = annotation;\n        const visibility = isAnnotationVisible(annotationUID);\n        const locked = isAnnotationLocked(annotationUID);\n        const lineWidth = getStyle('lineWidth');\n        const lineDash = getStyle('lineDash');\n        const color = getStyle('color');\n        const markerSize = getStyle('markerSize');\n        const shadow = getStyle('shadow');\n        const textboxStyle = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n        return {\n            visibility,\n            locked,\n            color,\n            lineWidth,\n            lineDash,\n            lineOpacity: 1,\n            fillColor: color,\n            fillOpacity: 0,\n            shadow,\n            textbox: textboxStyle,\n            markerSize,\n        };\n    }\n    _imagePointNearToolOrHandle(element, annotation, canvasCoords, proximity) {\n        const handleNearImagePoint = this.getHandleNearImagePoint(element, annotation, canvasCoords, proximity);\n        if (handleNearImagePoint) {\n            return true;\n        }\n        const toolNewImagePoint = this.isPointNearTool(element, annotation, canvasCoords, proximity, 'mouse');\n        if (toolNewImagePoint) {\n            return true;\n        }\n    }\n    static createAnnotationState(annotation, deleting) {\n        const { data, annotationUID } = annotation;\n        const cloneData = {\n            ...data,\n            cachedStats: {},\n        };\n        delete cloneData.contour;\n        delete cloneData.spline;\n        const state = {\n            annotationUID,\n            data: structuredClone(cloneData),\n            deleting,\n        };\n        const contour = data.contour;\n        if (contour) {\n            state.data.contour = {\n                ...contour,\n                polyline: null,\n                pointsManager: PointsManager.create3(contour.polyline.length, contour.polyline),\n            };\n        }\n        return state;\n    }\n    static createAnnotationMemo(element, annotation, options) {\n        if (!annotation) {\n            return;\n        }\n        const { newAnnotation, deleting = newAnnotation ? false : undefined } = options || {};\n        const { annotationUID } = annotation;\n        const state = AnnotationTool.createAnnotationState(annotation, deleting);\n        const annotationMemo = {\n            restoreMemo: () => {\n                const newState = AnnotationTool.createAnnotationState(annotation, deleting);\n                const { viewport } = getEnabledElement(element) || {};\n                viewport?.setViewReference(annotation.metadata);\n                if (state.deleting === true) {\n                    state.deleting = false;\n                    Object.assign(annotation.data, state.data);\n                    if (annotation.data.contour) {\n                        const annotationData = annotation.data;\n                        annotationData.contour.polyline = state.data.contour.pointsManager.points;\n                        delete state.data.contour.pointsManager;\n                        if (annotationData.segmentation) {\n                            addContourSegmentationAnnotation(annotation);\n                        }\n                    }\n                    state.data = newState.data;\n                    addAnnotation(annotation, element);\n                    setAnnotationSelected(annotation.annotationUID, true);\n                    viewport?.render();\n                    return;\n                }\n                if (state.deleting === false) {\n                    state.deleting = true;\n                    state.data = newState.data;\n                    setAnnotationSelected(annotation.annotationUID);\n                    removeAnnotation(annotation.annotationUID);\n                    viewport?.render();\n                    return;\n                }\n                const currentAnnotation = getAnnotation(annotationUID);\n                if (!currentAnnotation) {\n                    console.warn('No current annotation');\n                    return;\n                }\n                Object.assign(currentAnnotation.data, state.data);\n                if (currentAnnotation.data.contour) {\n                    currentAnnotation.data\n                        .contour.polyline = state.data.contour.pointsManager.points;\n                }\n                state.data = newState.data;\n                currentAnnotation.invalidated = true;\n                triggerAnnotationModified(currentAnnotation, element, ChangeTypes.History);\n            },\n            id: annotationUID,\n            operationType: 'annotation',\n        };\n        DefaultHistoryMemo.push(annotationMemo);\n        return annotationMemo;\n    }\n    createMemo(element, annotation, options) {\n        this.memo ||= AnnotationTool.createAnnotationMemo(element, annotation, options);\n    }\n    static hydrateBase(ToolClass, enabledElement, points, options = {}) {\n        if (!enabledElement) {\n            return null;\n        }\n        const { viewport } = enabledElement;\n        const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n        const camera = viewport.getCamera();\n        const viewPlaneNormal = options.viewplaneNormal ?? camera.viewPlaneNormal;\n        const viewUp = options.viewUp ?? camera.viewUp;\n        const instance = options.toolInstance || new ToolClass();\n        let referencedImageId;\n        let finalViewPlaneNormal = viewPlaneNormal;\n        let finalViewUp = viewUp;\n        if (options.referencedImageId) {\n            referencedImageId = options.referencedImageId;\n            finalViewPlaneNormal = undefined;\n            finalViewUp = undefined;\n        }\n        else {\n            if (viewport instanceof StackViewport) {\n                const closestImageIndex = csUtils.getClosestStackImageIndexForPoint(points[0], viewport);\n                if (closestImageIndex !== undefined) {\n                    referencedImageId = viewport.getImageIds()[closestImageIndex];\n                }\n            }\n            else if (viewport instanceof BaseVolumeViewport) {\n                referencedImageId = instance.getReferencedImageId(viewport, points[0], viewPlaneNormal, viewUp);\n            }\n            else {\n                throw new Error('Unsupported viewport type');\n            }\n        }\n        return {\n            FrameOfReferenceUID,\n            referencedImageId,\n            viewPlaneNormal: finalViewPlaneNormal,\n            viewUp: finalViewUp,\n            instance,\n            viewport,\n        };\n    }\n}\nAnnotationTool.toolName = 'AnnotationTool';\nexport default AnnotationTool;\n","import { getEnabledElement } from '@cornerstonejs/core';\nimport { addAnnotation, getAnnotations, getChildAnnotations, } from '../../stateManagement/annotation/annotationState';\nimport { drawPath as drawPathSvg } from '../../drawingSvg';\nimport AnnotationTool from './AnnotationTool';\nimport updateContourPolyline from '../../utilities/contours/updateContourPolyline';\nimport getContourHolesDataCanvas from '../../utilities/contours/getContourHolesDataCanvas';\nclass ContourBaseTool extends AnnotationTool {\n    constructor(toolProps, defaultToolProps) {\n        super(toolProps, defaultToolProps);\n    }\n    renderAnnotation(enabledElement, svgDrawingHelper) {\n        let renderStatus = false;\n        const { viewport } = enabledElement;\n        const { element } = viewport;\n        if (!viewport.getRenderingEngine()) {\n            console.warn('Rendering Engine has been destroyed');\n            return renderStatus;\n        }\n        let annotations = getAnnotations(this.getToolName(), element);\n        if (!annotations?.length) {\n            return renderStatus;\n        }\n        annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n        if (!annotations?.length) {\n            return renderStatus;\n        }\n        const targetId = this.getTargetId(viewport);\n        const styleSpecifier = {\n            toolGroupId: this.toolGroupId,\n            toolName: this.getToolName(),\n            viewportId: enabledElement.viewport.id,\n        };\n        for (let i = 0; i < annotations.length; i++) {\n            const annotation = annotations[i];\n            styleSpecifier.annotationUID = annotation.annotationUID;\n            const annotationStyle = this.getAnnotationStyle({\n                annotation,\n                styleSpecifier,\n            });\n            if (!annotationStyle.visibility) {\n                continue;\n            }\n            const annotationRendered = this.renderAnnotationInstance({\n                enabledElement,\n                targetId,\n                annotation,\n                annotationStyle,\n                svgDrawingHelper,\n            });\n            renderStatus ||= annotationRendered;\n            annotation.invalidated = false;\n        }\n        return renderStatus;\n    }\n    createAnnotation(evt) {\n        const annotation = super.createAnnotation(evt);\n        Object.assign(annotation.data, {\n            contour: {\n                polyline: [],\n                closed: false,\n            },\n        });\n        Object.assign(annotation, {\n            interpolationUID: '',\n            autoGenerated: false,\n        });\n        return annotation;\n    }\n    addAnnotation(annotation, element) {\n        return addAnnotation(annotation, element);\n    }\n    cancelAnnotation(annotation) {\n    }\n    moveAnnotation(annotation, worldPosDelta) {\n        const { points } = annotation.data.handles;\n        for (let i = 0, numPoints = points.length; i < numPoints; i++) {\n            const point = points[i];\n            point[0] += worldPosDelta[0];\n            point[1] += worldPosDelta[1];\n            point[2] += worldPosDelta[2];\n        }\n        annotation.invalidated = true;\n        getChildAnnotations(annotation).forEach((childAnnotation) => this.moveAnnotation(childAnnotation, worldPosDelta));\n    }\n    updateContourPolyline(annotation, polylineData, transforms, options) {\n        const decimateConfig = this.configuration?.decimate || {};\n        updateContourPolyline(annotation, polylineData, transforms, {\n            decimate: {\n                enabled: !!decimateConfig.enabled,\n                epsilon: decimateConfig.epsilon,\n            },\n            updateWindingDirection: options?.updateWindingDirection,\n        });\n    }\n    getPolylinePoints(annotation) {\n        return annotation.data.contour?.polyline ?? annotation.data.polyline;\n    }\n    renderAnnotationInstance(renderContext) {\n        const { enabledElement, annotationStyle, svgDrawingHelper } = renderContext;\n        const annotation = renderContext.annotation;\n        if (annotation.parentAnnotationUID) {\n            return;\n        }\n        const { annotationUID } = annotation;\n        const { viewport } = enabledElement;\n        const { worldToCanvas } = viewport;\n        const polylineCanvasPoints = this.getPolylinePoints(annotation).map((point) => worldToCanvas(point));\n        const { lineWidth, lineDash, color, fillColor, fillOpacity } = annotationStyle;\n        const childContours = getContourHolesDataCanvas(annotation, viewport);\n        const allContours = [polylineCanvasPoints, ...childContours];\n        drawPathSvg(svgDrawingHelper, annotationUID, 'contourPolyline', allContours, {\n            color: color,\n            lineDash: lineDash,\n            lineWidth: Math.max(0.1, lineWidth),\n            fillColor: fillColor,\n            fillOpacity: fillOpacity,\n        });\n        return true;\n    }\n}\nexport { ContourBaseTool as default, ContourBaseTool };\n","import { getEnabledElement, utilities } from '@cornerstonejs/core';\nimport { SegmentationRepresentations } from '../../enums';\nimport ContourBaseTool from './ContourBaseTool';\nimport { triggerSegmentationDataModified } from '../../stateManagement/segmentation/triggerSegmentationEvents';\nimport InterpolationManager from '../../utilities/segmentation/InterpolationManager/InterpolationManager';\nimport { addContourSegmentationAnnotation, removeContourSegmentationAnnotation, } from '../../utilities/contourSegmentation';\nimport { triggerAnnotationRenderForToolGroupIds } from '../../utilities/triggerAnnotationRenderForToolGroupIds';\nimport { getToolGroupForViewport } from '../../store/ToolGroupManager';\nimport { getSegmentationRepresentations } from '../../stateManagement/segmentation/getSegmentationRepresentation';\nimport { getActiveSegmentation } from '../../stateManagement/segmentation/getActiveSegmentation';\nimport { getViewportIdsWithSegmentation } from '../../stateManagement/segmentation/getViewportIdsWithSegmentation';\nimport { getActiveSegmentIndex } from '../../stateManagement/segmentation/getActiveSegmentIndex';\nimport { getLockedSegmentIndices } from '../../stateManagement/segmentation/segmentLocking';\nimport { getSVGStyleForSegment } from '../../utilities/segmentation/getSVGStyleForSegment';\nclass ContourSegmentationBaseTool extends ContourBaseTool {\n    static { this.PreviewSegmentIndex = 255; }\n    constructor(toolProps, defaultToolProps) {\n        super(toolProps, defaultToolProps);\n        if (this.configuration.interpolation?.enabled) {\n            InterpolationManager.addTool(this.getToolName());\n        }\n    }\n    isContourSegmentationTool() {\n        return true;\n    }\n    createAnnotation(evt) {\n        const eventDetail = evt.detail;\n        const { element } = eventDetail;\n        const enabledElement = getEnabledElement(element);\n        if (!enabledElement) {\n            return;\n        }\n        const { viewport } = enabledElement;\n        const contourAnnotation = super.createAnnotation(evt);\n        if (!this.isContourSegmentationTool()) {\n            return contourAnnotation;\n        }\n        const activeSeg = getActiveSegmentation(viewport.id);\n        if (!activeSeg) {\n            throw new Error('No active segmentation detected, create one before using scissors tool');\n        }\n        if (!activeSeg.representationData.Contour) {\n            throw new Error(`A contour segmentation must be active`);\n        }\n        const { segmentationId } = activeSeg;\n        const segmentIndex = getActiveSegmentIndex(segmentationId);\n        return utilities.deepMerge(contourAnnotation, {\n            data: {\n                segmentation: {\n                    segmentationId,\n                    segmentIndex,\n                },\n            },\n        });\n    }\n    addAnnotation(annotation, element) {\n        const annotationUID = super.addAnnotation(annotation, element);\n        if (this.isContourSegmentationTool()) {\n            const contourSegAnnotation = annotation;\n            addContourSegmentationAnnotation(contourSegAnnotation);\n        }\n        return annotationUID;\n    }\n    cancelAnnotation(annotation) {\n        if (this.isContourSegmentationTool()) {\n            removeContourSegmentationAnnotation(annotation);\n        }\n        super.cancelAnnotation(annotation);\n    }\n    getAnnotationStyle(context) {\n        const annotationStyle = super.getAnnotationStyle(context);\n        if (!this.isContourSegmentationTool()) {\n            return annotationStyle;\n        }\n        const contourSegmentationStyle = this._getContourSegmentationStyle(context);\n        return utilities.deepMerge(annotationStyle, contourSegmentationStyle);\n    }\n    renderAnnotationInstance(renderContext) {\n        const { annotation } = renderContext;\n        const { invalidated } = annotation;\n        const renderResult = super.renderAnnotationInstance(renderContext);\n        if (invalidated && this.isContourSegmentationTool()) {\n            const { segmentationId } = (annotation).data.segmentation;\n            triggerSegmentationDataModified(segmentationId);\n            const viewportIds = getViewportIdsWithSegmentation(segmentationId);\n            const toolGroupIds = viewportIds.map((viewportId) => {\n                const toolGroup = getToolGroupForViewport(viewportId);\n                return toolGroup.id;\n            });\n            triggerAnnotationRenderForToolGroupIds(toolGroupIds);\n        }\n        return renderResult;\n    }\n    _getContourSegmentationStyle(context) {\n        const annotation = context.annotation;\n        const { segmentationId, segmentIndex } = annotation.data.segmentation;\n        const { viewportId } = context.styleSpecifier;\n        const segmentationRepresentations = getSegmentationRepresentations(viewportId, { segmentationId });\n        if (!segmentationRepresentations?.length) {\n            return {};\n        }\n        let segmentationRepresentation;\n        if (segmentationRepresentations.length > 1) {\n            segmentationRepresentation = segmentationRepresentations.find((rep) => rep.segmentationId === segmentationId &&\n                rep.type === SegmentationRepresentations.Contour);\n        }\n        else {\n            segmentationRepresentation = segmentationRepresentations[0];\n        }\n        const { autoGenerated } = annotation;\n        const segmentsLocked = getLockedSegmentIndices(segmentationId);\n        const annotationLocked = segmentsLocked.includes(segmentIndex);\n        const { color, fillColor, lineWidth, fillOpacity, lineDash, visibility } = getSVGStyleForSegment({\n            segmentationId,\n            segmentIndex,\n            viewportId,\n            autoGenerated,\n        });\n        return {\n            color,\n            fillColor,\n            lineWidth,\n            fillOpacity,\n            lineDash,\n            textbox: {\n                color,\n            },\n            visibility,\n            locked: annotationLocked,\n        };\n    }\n}\nexport { ContourSegmentationBaseTool as default, ContourSegmentationBaseTool };\n","const defaultContourConfig = {\n    renderOutline: true,\n    outlineWidthAutoGenerated: 3,\n    outlineWidth: 1,\n    outlineWidthInactive: 1,\n    outlineOpacity: 1,\n    outlineOpacityInactive: 0.85,\n    outlineDash: undefined,\n    outlineDashInactive: undefined,\n    outlineDashAutoGenerated: '5,3',\n    activeSegmentOutlineWidthDelta: 0,\n    renderFill: true,\n    fillAlpha: 0.5,\n    fillAlphaInactive: 0.3,\n    fillAlphaAutoGenerated: 0.3,\n};\nfunction getDefaultContourStyle() {\n    return defaultContourConfig;\n}\nexport default getDefaultContourStyle;\n","import { addAnnotation } from '../../../../stateManagement/annotation/annotationState';\nimport { cache, utilities } from '@cornerstonejs/core';\nimport { getClosestImageIdForStackViewport } from '../../../../utilities/annotationHydration';\nimport { addContourSegmentationAnnotation } from '../../../../utilities/contourSegmentation';\nimport { validateGeometry } from './utils';\nimport { SegmentationRepresentations } from '../../../../enums';\nimport { segmentationStyle } from '../../../../stateManagement/segmentation/SegmentationStyle';\nfunction handleContourSegmentation(viewport, geometryIds, annotationUIDsMap, contourRepresentation) {\n    if (annotationUIDsMap.size) {\n        viewport.render();\n    }\n    else {\n        addContourSetsToElement(viewport, geometryIds, contourRepresentation);\n    }\n}\nfunction addContourSetsToElement(viewport, geometryIds, contourRepresentation) {\n    const { segmentationId } = contourRepresentation;\n    const segmentSpecificMap = new Map();\n    geometryIds.forEach((geometryId) => {\n        const geometry = cache.getGeometry(geometryId);\n        if (!geometry) {\n            console.warn(`No geometry found for geometryId ${geometryId}. Skipping render.`);\n            return;\n        }\n        const segmentIndex = geometry.data.segmentIndex;\n        validateGeometry(geometry);\n        const segmentSpecificConfig = segmentationStyle.getStyle({\n            viewportId: viewport.id,\n            segmentationId,\n            type: SegmentationRepresentations.Contour,\n            segmentIndex,\n        });\n        const contourSet = geometry.data;\n        const viewPlaneNormal = viewport.getCamera().viewPlaneNormal;\n        contourSet.contours.forEach((contour) => {\n            const { points, color, id } = contour;\n            const referencedImageId = getClosestImageIdForStackViewport(viewport, points[0], viewPlaneNormal);\n            const contourSegmentationAnnotation = {\n                annotationUID: utilities.uuidv4(),\n                data: {\n                    contour: {\n                        closed: true,\n                        polyline: points,\n                    },\n                    segmentation: {\n                        segmentationId,\n                        segmentIndex,\n                        color,\n                        id,\n                    },\n                    handles: {},\n                },\n                handles: {},\n                highlighted: false,\n                autoGenerated: false,\n                invalidated: false,\n                isLocked: true,\n                isVisible: true,\n                metadata: {\n                    referencedImageId,\n                    toolName: 'PlanarFreehandContourSegmentationTool',\n                    FrameOfReferenceUID: viewport.getFrameOfReferenceUID(),\n                    viewPlaneNormal: viewport.getCamera().viewPlaneNormal,\n                },\n            };\n            const annotationGroupSelector = viewport.element;\n            addAnnotation(contourSegmentationAnnotation, annotationGroupSelector);\n            addContourSegmentationAnnotation(contourSegmentationAnnotation);\n        });\n        if (segmentSpecificConfig) {\n            segmentSpecificMap.set(segmentIndex, segmentSpecificConfig);\n        }\n    });\n    viewport.resetCamera();\n    viewport.render();\n}\nexport { handleContourSegmentation, addContourSetsToElement };\n","import { Enums } from '@cornerstonejs/core';\nimport vtkCellArray from '@kitware/vtk.js/Common/Core/CellArray';\nimport vtkPoints from '@kitware/vtk.js/Common/Core/Points';\nimport vtkPolyData from '@kitware/vtk.js/Common/DataModel/PolyData';\nexport function validateGeometry(geometry) {\n    if (!geometry) {\n        throw new Error(`No contours found for geometryId ${geometry.id}`);\n    }\n    const geometryId = geometry.id;\n    if (geometry.type !== Enums.GeometryType.CONTOUR) {\n        throw new Error(`Geometry type ${geometry.type} not supported for rendering.`);\n    }\n    if (!geometry.data) {\n        console.warn(`No contours found for geometryId ${geometryId}. Skipping render.`);\n        return;\n    }\n}\nexport function getPolyData(contourSet) {\n    const pointArray = [];\n    const points = vtkPoints.newInstance();\n    const lines = vtkCellArray.newInstance();\n    let pointIndex = 0;\n    contourSet.contours.forEach((contour) => {\n        const pointList = contour.points;\n        const flatPoints = contour.flatPointsArray;\n        const type = contour.type;\n        const pointIndexes = pointList.map((_, pointListIndex) => pointListIndex + pointIndex);\n        if (type === Enums.ContourType.CLOSED_PLANAR) {\n            pointIndexes.push(pointIndexes[0]);\n        }\n        const linePoints = Float32Array.from(flatPoints);\n        pointArray.push(...linePoints);\n        lines.insertNextCell([...pointIndexes]);\n        pointIndex = pointIndex + pointList.length;\n    });\n    points.setData(pointArray, 3);\n    const polygon = vtkPolyData.newInstance();\n    polygon.setPoints(points);\n    polygon.setLines(lines);\n    return polygon;\n}\n","import { getSegmentation } from '../../../stateManagement/segmentation/getSegmentation';\nimport { removeAnnotation } from '../../../stateManagement';\nfunction removeContourFromElement(viewportId, segmentationId, removeFromCache = false) {\n    const segmentation = getSegmentation(segmentationId);\n    const { annotationUIDsMap } = segmentation.representationData.Contour;\n    annotationUIDsMap.forEach((annotationSet) => {\n        annotationSet.forEach((annotationUID) => {\n            removeAnnotation(annotationUID);\n        });\n    });\n}\nexport default removeContourFromElement;\n","import { cache, Enums, convertMapperToNotSharedMapper, volumeLoader, eventTarget, createVolumeActor, } from '@cornerstonejs/core';\nimport { Events, SegmentationRepresentations } from '../../../enums';\nimport { getSegmentation } from '../../../stateManagement/segmentation/getSegmentation';\nconst internalCache = new Map();\nconst load = ({ cfun, ofun, actor }) => {\n    actor.getProperty().setRGBTransferFunction(1, cfun);\n    actor.getProperty().setScalarOpacity(1, ofun);\n};\nexport async function addVolumesAsIndependentComponents({ viewport, volumeInputs, segmentationId, }) {\n    const defaultActor = viewport.getDefaultActor();\n    const { actor } = defaultActor;\n    const { uid, callback } = defaultActor;\n    const referenceVolumeId = viewport.getVolumeId();\n    if (internalCache.get(uid)?.added) {\n        return {\n            uid,\n            actor,\n        };\n    }\n    const volumeInputArray = volumeInputs;\n    const firstImageVolume = cache.getVolume(volumeInputArray[0].volumeId);\n    if (!firstImageVolume) {\n        throw new Error(`imageVolume with id: ${firstImageVolume.volumeId} does not exist`);\n    }\n    const { volumeId } = volumeInputArray[0];\n    const segImageVolume = await volumeLoader.loadVolume(volumeId);\n    if (!segImageVolume) {\n        throw new Error(`segImageVolume with id: ${segImageVolume.volumeId} does not exist`);\n    }\n    const segVoxelManager = segImageVolume.voxelManager;\n    const segData = segVoxelManager.getCompleteScalarDataArray();\n    const { imageData: segImageData } = segImageVolume;\n    const baseVolume = cache.getVolume(referenceVolumeId);\n    const baseVoxelManager = baseVolume.voxelManager;\n    const baseData = baseVoxelManager.getCompleteScalarDataArray();\n    const newComp = 2;\n    const cubeData = new Float32Array(newComp * baseVolume.voxelManager.getScalarDataLength());\n    const dims = segImageData.getDimensions();\n    for (let z = 0; z < dims[2]; ++z) {\n        for (let y = 0; y < dims[1]; ++y) {\n            for (let x = 0; x < dims[0]; ++x) {\n                const iTuple = x + dims[0] * (y + dims[1] * z);\n                cubeData[iTuple * newComp + 0] = baseData[iTuple];\n                cubeData[iTuple * newComp + 1] = segData[iTuple];\n            }\n        }\n    }\n    viewport.removeActors([uid]);\n    const oldMapper = actor.getMapper();\n    const mapper = convertMapperToNotSharedMapper(oldMapper);\n    actor.setMapper(mapper);\n    mapper.setBlendMode(Enums.BlendModes.LABELMAP_EDGE_PROJECTION_BLEND);\n    const arrayAgain = mapper.getInputData().getPointData().getArray(0);\n    arrayAgain.setData(cubeData);\n    arrayAgain.setNumberOfComponents(2);\n    actor.getProperty().setColorMixPreset(1);\n    actor.getProperty().setForceNearestInterpolation(1, true);\n    actor.getProperty().setIndependentComponents(true);\n    viewport.addActor({\n        actor,\n        uid,\n        callback,\n        referencedId: referenceVolumeId,\n        representationUID: `${segmentationId}-${SegmentationRepresentations.Labelmap}`,\n    });\n    internalCache.set(uid, {\n        added: true,\n        segmentationRepresentationUID: `${segmentationId}`,\n        originalBlendMode: viewport.getBlendMode(),\n    });\n    actor.set({\n        preLoad: load,\n    });\n    function onSegmentationDataModified(evt) {\n        const { segmentationId } = evt.detail;\n        const { representationData } = getSegmentation(segmentationId);\n        const { volumeId: segVolumeId } = representationData.Labelmap;\n        if (segVolumeId !== segImageVolume.volumeId) {\n            return;\n        }\n        const segmentationVolume = cache.getVolume(segVolumeId);\n        const segVoxelManager = segmentationVolume.voxelManager;\n        const imageData = mapper.getInputData();\n        const array = imageData.getPointData().getArray(0);\n        const baseData = array.getData();\n        const newComp = 2;\n        const dims = segImageData.getDimensions();\n        const slices = Array.from({ length: dims[2] }, (_, i) => i);\n        for (const z of slices) {\n            for (let y = 0; y < dims[1]; ++y) {\n                for (let x = 0; x < dims[0]; ++x) {\n                    const iTuple = x + dims[0] * (y + dims[1] * z);\n                    baseData[iTuple * newComp + 1] = segVoxelManager.getAtIndex(iTuple);\n                }\n            }\n        }\n        array.setData(baseData);\n        imageData.modified();\n        viewport.render();\n    }\n    eventTarget.addEventListenerDebounced(Events.SEGMENTATION_DATA_MODIFIED, onSegmentationDataModified, 200);\n    eventTarget.addEventListener(Events.SEGMENTATION_REPRESENTATION_REMOVED, async (evt) => {\n        eventTarget.removeEventListener(Events.SEGMENTATION_DATA_MODIFIED, onSegmentationDataModified);\n        const actorEntry = viewport.getActor(uid);\n        const { element, id } = viewport;\n        viewport.removeActors([uid]);\n        const actor = await createVolumeActor({\n            volumeId: uid,\n            blendMode: Enums.BlendModes.MAXIMUM_INTENSITY_BLEND,\n            callback: ({ volumeActor }) => {\n                if (actorEntry.callback) {\n                    actorEntry.callback({\n                        volumeActor,\n                        volumeId,\n                    });\n                }\n            },\n        }, element, id);\n        viewport.addActor({ actor, uid });\n        viewport.render();\n    });\n    return {\n        uid,\n        actor,\n    };\n}\n","import { getEnabledElement, addVolumesToViewports, addImageSlicesToViewports, Enums, cache, BaseVolumeViewport, volumeLoader, utilities, } from '@cornerstonejs/core';\nimport { getCurrentLabelmapImageIdsForViewport } from '../../../stateManagement/segmentation/getCurrentLabelmapImageIdForViewport';\nimport { getSegmentation } from '../../../stateManagement/segmentation/getSegmentation';\nimport { triggerSegmentationDataModified, triggerSegmentationModified, } from '../../../stateManagement/segmentation/triggerSegmentationEvents';\nimport { SegmentationRepresentations } from '../../../enums';\nimport { addVolumesAsIndependentComponents } from './addVolumesAsIndependentComponents';\nconst { uuidv4 } = utilities;\nasync function addLabelmapToElement(element, labelMapData, segmentationId, config) {\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine, viewport } = enabledElement;\n    const { id: viewportId } = viewport;\n    const visibility = true;\n    const immediateRender = false;\n    const suppressEvents = true;\n    if (viewport instanceof BaseVolumeViewport) {\n        const volumeLabelMapData = labelMapData;\n        const volumeId = _ensureVolumeHasVolumeId(volumeLabelMapData, segmentationId);\n        if (!cache.getVolume(volumeId)) {\n            await _handleMissingVolume(labelMapData);\n        }\n        let blendMode = config?.blendMode ?? Enums.BlendModes.MAXIMUM_INTENSITY_BLEND;\n        let useIndependentComponents = blendMode === Enums.BlendModes.LABELMAP_EDGE_PROJECTION_BLEND;\n        if (useIndependentComponents) {\n            const referenceVolumeId = viewport.getVolumeId();\n            const baseVolume = cache.getVolume(referenceVolumeId);\n            const segVolume = cache.getVolume(volumeId);\n            const segDims = segVolume.dimensions;\n            const refDims = baseVolume.dimensions;\n            if (segDims[0] !== refDims[0] ||\n                segDims[1] !== refDims[1] ||\n                segDims[2] !== refDims[2]) {\n                useIndependentComponents = false;\n                blendMode = Enums.BlendModes.MAXIMUM_INTENSITY_BLEND;\n                console.debug('Dimensions mismatch - falling back to regular volume addition');\n            }\n        }\n        const volumeInputs = [\n            {\n                volumeId,\n                visibility,\n                representationUID: `${segmentationId}-${SegmentationRepresentations.Labelmap}`,\n                useIndependentComponents,\n                blendMode,\n            },\n        ];\n        if (!volumeInputs[0].useIndependentComponents) {\n            await addVolumesToViewports(renderingEngine, volumeInputs, [viewportId], immediateRender, suppressEvents);\n        }\n        else {\n            const result = await addVolumesAsIndependentComponents({\n                viewport,\n                volumeInputs,\n                segmentationId,\n            });\n            return result;\n        }\n    }\n    else {\n        const segmentationImageIds = getCurrentLabelmapImageIdsForViewport(viewport.id, segmentationId);\n        const stackInputs = segmentationImageIds.map((imageId) => ({\n            imageId,\n            representationUID: `${segmentationId}-${SegmentationRepresentations.Labelmap}-${imageId}`,\n        }));\n        addImageSlicesToViewports(renderingEngine, stackInputs, [viewportId]);\n    }\n    triggerSegmentationDataModified(segmentationId);\n}\nfunction _ensureVolumeHasVolumeId(labelMapData, segmentationId) {\n    let { volumeId } = labelMapData;\n    if (!volumeId) {\n        volumeId = uuidv4();\n        const segmentation = getSegmentation(segmentationId);\n        segmentation.representationData.Labelmap = {\n            ...segmentation.representationData.Labelmap,\n            volumeId,\n        };\n        labelMapData.volumeId = volumeId;\n        triggerSegmentationModified(segmentationId);\n    }\n    return volumeId;\n}\nasync function _handleMissingVolume(labelMapData) {\n    const stackData = labelMapData;\n    const hasImageIds = stackData.imageIds.length > 0;\n    if (!hasImageIds) {\n        throw new Error('cannot create labelmap, no imageIds found for the volume labelmap');\n    }\n    const volume = await volumeLoader.createAndCacheVolumeFromImages(labelMapData.volumeId || uuidv4(), stackData.imageIds);\n    return volume;\n}\nexport default addLabelmapToElement;\n","const defaultLabelmapConfig = {\n    renderOutline: true,\n    renderOutlineInactive: true,\n    outlineWidth: 3,\n    outlineWidthInactive: 2,\n    activeSegmentOutlineWidthDelta: 0,\n    renderFill: true,\n    renderFillInactive: true,\n    fillAlpha: 0.5,\n    fillAlphaInactive: 0.4,\n    outlineOpacity: 1,\n    outlineOpacityInactive: 0.85,\n};\nfunction getDefaultLabelmapStyle() {\n    return defaultLabelmapConfig;\n}\nexport default getDefaultLabelmapStyle;\n","import { getEnabledElement } from '@cornerstonejs/core';\nimport { getLabelmapActorUID } from '../../../stateManagement/segmentation/helpers/getSegmentationActor';\nfunction removeLabelmapFromElement(element, segmentationId) {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    viewport.removeActors([getLabelmapActorUID(viewport.id, segmentationId)]);\n}\nexport default removeLabelmapFromElement;\n","import { getEnabledElement } from '@cornerstonejs/core';\nimport { utilities } from '@cornerstonejs/core';\nimport vtkMapper from '@kitware/vtk.js/Rendering/Core/Mapper';\nimport vtkActor from '@kitware/vtk.js/Rendering/Core/Actor';\nimport vtkPolyData from '@kitware/vtk.js/Common/DataModel/PolyData';\nimport vtkCellArray from '@kitware/vtk.js/Common/Core/CellArray';\nimport { getSurfaceActorEntry, getSurfaceRepresentationUID, } from '../../../stateManagement/segmentation/helpers/getSegmentationActor';\nfunction addOrUpdateSurfaceToElement(element, surface, segmentationId) {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const surfaceActorEntry = getSurfaceActorEntry(viewport.id, segmentationId, surface.segmentIndex);\n    const surfaceActor = surfaceActorEntry?.actor;\n    const isVisible = surface.visible;\n    if (surfaceActor) {\n        surfaceActor.setVisibility(isVisible);\n        if (!isVisible) {\n            return;\n        }\n        const surfaceMapper = surfaceActor.getMapper();\n        const currentPolyData = surfaceMapper.getInputData();\n        const newPoints = surface.points;\n        const newPolys = surface.polys;\n        const currentPoints = currentPolyData.getPoints().getData();\n        const currentPolys = currentPolyData.getPolys().getData();\n        if (newPoints.length === currentPoints.length &&\n            newPolys.length === currentPolys.length) {\n            return;\n        }\n        const polyData = vtkPolyData.newInstance();\n        polyData.getPoints().setData(newPoints, 3);\n        const triangles = vtkCellArray.newInstance({\n            values: Float32Array.from(newPolys),\n        });\n        polyData.setPolys(triangles);\n        surfaceMapper.setInputData(polyData);\n        surfaceMapper.modified();\n        viewport.getRenderer().resetCameraClippingRange();\n        return;\n    }\n    const points = surface.points;\n    const polys = surface.polys;\n    const color = surface.color;\n    const surfacePolyData = vtkPolyData.newInstance();\n    surfacePolyData.getPoints().setData(points, 3);\n    const triangles = vtkCellArray.newInstance({\n        values: Float32Array.from(polys),\n    });\n    surfacePolyData.setPolys(triangles);\n    const mapper = vtkMapper.newInstance({});\n    let clippingFilter;\n    mapper.setInputData(surfacePolyData);\n    const actor = vtkActor.newInstance();\n    actor.setMapper(mapper);\n    actor.getProperty().setColor(color[0] / 255, color[1] / 255, color[2] / 255);\n    actor.getProperty().setLineWidth(2);\n    const representationUID = getSurfaceRepresentationUID(segmentationId, surface.segmentIndex);\n    viewport.addActor({\n        uid: utilities.uuidv4(),\n        actor: actor,\n        clippingFilter,\n        representationUID,\n    });\n    viewport.resetCamera();\n    viewport.getRenderer().resetCameraClippingRange();\n    viewport.render();\n}\nexport default addOrUpdateSurfaceToElement;\n","import { getEnabledElement } from '@cornerstonejs/core';\nfunction removeSurfaceFromElement(element, segmentationId) {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const actorEntries = viewport.getActors();\n    const filteredSurfaceActors = actorEntries.filter((actor) => actor.representationUID &&\n        typeof actor.representationUID === 'string' &&\n        actor.representationUID.startsWith(segmentationId));\n    viewport.removeActors(filteredSurfaceActors.map((actor) => actor.uid));\n}\nexport default removeSurfaceFromElement;\n","import { utilities as csUtils } from '@cornerstonejs/core';\nimport { triggerSegmentationDataModified } from '../../../stateManagement/segmentation/triggerSegmentationEvents';\nimport compositions from './compositions';\nimport { getStrategyData } from './utils/getStrategyData';\nimport { StrategyCallbacks } from '../../../enums';\nexport default class BrushStrategy {\n    static { this.COMPOSITIONS = compositions; }\n    static { this.childFunctions = {\n        [StrategyCallbacks.OnInteractionStart]: addListMethod(StrategyCallbacks.OnInteractionStart, StrategyCallbacks.Initialize),\n        [StrategyCallbacks.OnInteractionEnd]: addListMethod(StrategyCallbacks.OnInteractionEnd, StrategyCallbacks.Initialize),\n        [StrategyCallbacks.Fill]: addListMethod(StrategyCallbacks.Fill),\n        [StrategyCallbacks.Initialize]: addListMethod(StrategyCallbacks.Initialize),\n        [StrategyCallbacks.CreateIsInThreshold]: addSingletonMethod(StrategyCallbacks.CreateIsInThreshold),\n        [StrategyCallbacks.Interpolate]: addListMethod(StrategyCallbacks.Interpolate, StrategyCallbacks.Initialize),\n        [StrategyCallbacks.AcceptPreview]: addListMethod(StrategyCallbacks.AcceptPreview, StrategyCallbacks.Initialize),\n        [StrategyCallbacks.RejectPreview]: addListMethod(StrategyCallbacks.RejectPreview, StrategyCallbacks.Initialize),\n        [StrategyCallbacks.INTERNAL_setValue]: addSingletonMethod(StrategyCallbacks.INTERNAL_setValue),\n        [StrategyCallbacks.Preview]: addSingletonMethod(StrategyCallbacks.Preview, false),\n        [StrategyCallbacks.ComputeInnerCircleRadius]: addListMethod(StrategyCallbacks.ComputeInnerCircleRadius),\n        [StrategyCallbacks.EnsureSegmentationVolumeFor3DManipulation]: addListMethod(StrategyCallbacks.EnsureSegmentationVolumeFor3DManipulation),\n        [StrategyCallbacks.EnsureImageVolumeFor3DManipulation]: addListMethod(StrategyCallbacks.EnsureImageVolumeFor3DManipulation),\n        [StrategyCallbacks.AddPreview]: addListMethod(StrategyCallbacks.AddPreview),\n        [StrategyCallbacks.GetStatistics]: addSingletonMethod(StrategyCallbacks.GetStatistics),\n        compositions: null,\n    }; }\n    constructor(name, ...initializers) {\n        this._initialize = [];\n        this._fill = [];\n        this._onInteractionStart = [];\n        this.fill = (enabledElement, operationData) => {\n            const initializedData = this.initialize(enabledElement, operationData, StrategyCallbacks.Fill);\n            if (!initializedData) {\n                return;\n            }\n            this._fill.forEach((func) => func(initializedData));\n            const { segmentationVoxelManager, segmentIndex } = initializedData;\n            triggerSegmentationDataModified(initializedData.segmentationId, segmentationVoxelManager.getArrayOfModifiedSlices(), segmentIndex);\n            return initializedData;\n        };\n        this.onInteractionStart = (enabledElement, operationData) => {\n            const initializedData = this.initialize(enabledElement, operationData);\n            if (!initializedData) {\n                return;\n            }\n            this._onInteractionStart.forEach((func) => func.call(this, initializedData));\n        };\n        this.addPreview = (enabledElement, operationData) => {\n            const initializedData = this.initialize(enabledElement, operationData, StrategyCallbacks.AddPreview);\n            if (!initializedData) {\n                return;\n            }\n            return initializedData;\n        };\n        this.configurationName = name;\n        this.compositions = initializers;\n        initializers.forEach((initializer) => {\n            const result = typeof initializer === 'function' ? initializer() : initializer;\n            if (!result) {\n                return;\n            }\n            for (const key in result) {\n                if (!BrushStrategy.childFunctions[key]) {\n                    throw new Error(`Didn't find ${key} as a brush strategy`);\n                }\n                BrushStrategy.childFunctions[key](this, result[key]);\n            }\n        });\n        this.strategyFunction = (enabledElement, operationData) => {\n            return this.fill(enabledElement, operationData);\n        };\n        for (const key of Object.keys(BrushStrategy.childFunctions)) {\n            this.strategyFunction[key] = this[key];\n        }\n    }\n    initialize(enabledElement, operationData, operationName) {\n        const { viewport } = enabledElement;\n        const data = getStrategyData({ operationData, viewport, strategy: this });\n        if (!data) {\n            return null;\n        }\n        const { imageVoxelManager, segmentationVoxelManager, segmentationImageData, } = data;\n        const memo = operationData.createMemo(operationData.segmentationId, segmentationVoxelManager);\n        const initializedData = {\n            operationName,\n            ...operationData,\n            segmentIndex: operationData.segmentIndex,\n            enabledElement,\n            imageVoxelManager,\n            segmentationVoxelManager,\n            segmentationImageData,\n            viewport,\n            centerWorld: null,\n            isInObject: null,\n            isInObjectBoundsIJK: null,\n            brushStrategy: this,\n            memo,\n        };\n        this._initialize.forEach((func) => func(initializedData));\n        return initializedData;\n    }\n}\nfunction addListMethod(name, createInitialized) {\n    const listName = `_${name}`;\n    return (brushStrategy, func) => {\n        brushStrategy[listName] ||= [];\n        brushStrategy[listName].push(func);\n        brushStrategy[name] ||= createInitialized\n            ? (enabledElement, operationData, ...args) => {\n                const initializedData = brushStrategy[createInitialized](enabledElement, operationData, name);\n                let returnValue;\n                brushStrategy[listName].forEach((func) => {\n                    const value = func.call(brushStrategy, initializedData, ...args);\n                    returnValue ||= value;\n                });\n                return returnValue;\n            }\n            : (operationData, ...args) => {\n                brushStrategy[listName].forEach((func) => func.call(brushStrategy, operationData, ...args));\n            };\n    };\n}\nfunction addSingletonMethod(name, isInitialized = true) {\n    return (brushStrategy, func) => {\n        if (brushStrategy[name]) {\n            throw new Error(`The singleton method ${name} already exists`);\n        }\n        brushStrategy[name] = isInitialized\n            ? func\n            : (enabledElement, operationData, ...args) => {\n                operationData.enabledElement = enabledElement;\n                return func.call(brushStrategy, operationData, ...args);\n            };\n    };\n}\n","import StrategyCallbacks from '../../../../enums/StrategyCallbacks';\nexport default {\n    [StrategyCallbacks.OnInteractionStart]: (operationData) => {\n        const { segmentIndex, previewSegmentIndex, segmentationVoxelManager, centerIJK, viewPlaneNormal, segmentationImageData, configuration, } = operationData;\n        if (!configuration?.useCenterSegmentIndex) {\n            return;\n        }\n        let hasSegmentIndex = false;\n        let hasPreviewIndex = false;\n        const nestedBounds = [\n            ...segmentationVoxelManager.getBoundsIJK(),\n        ];\n        if (Math.abs(viewPlaneNormal[0]) > 0.8) {\n            nestedBounds[0] = [centerIJK[0], centerIJK[0]];\n        }\n        else if (Math.abs(viewPlaneNormal[1]) > 0.8) {\n            nestedBounds[1] = [centerIJK[1], centerIJK[1]];\n        }\n        else if (Math.abs(viewPlaneNormal[2]) > 0.8) {\n            nestedBounds[2] = [centerIJK[2], centerIJK[2]];\n        }\n        const callback = ({ value }) => {\n            hasSegmentIndex ||= value === segmentIndex;\n            hasPreviewIndex ||= value === previewSegmentIndex;\n        };\n        segmentationVoxelManager.forEach(callback, {\n            imageData: segmentationImageData,\n            isInObject: operationData.isInObject,\n            boundsIJK: nestedBounds,\n        });\n        if (!hasSegmentIndex && !hasPreviewIndex) {\n            operationData.centerSegmentIndexInfo.segmentIndex = null;\n            return;\n        }\n        const existingValue = segmentationVoxelManager.getAtIJKPoint(centerIJK);\n        operationData.centerSegmentIndexInfo.segmentIndex = existingValue;\n        operationData.centerSegmentIndexInfo.hasSegmentIndex = hasSegmentIndex;\n        operationData.centerSegmentIndexInfo.hasPreviewIndex = hasPreviewIndex;\n    },\n};\n","import { vec3 } from 'gl-matrix';\nimport StrategyCallbacks from '../../../../enums/StrategyCallbacks';\nexport default {\n    [StrategyCallbacks.Initialize]: (operationData) => {\n        const { operationName, centerIJK, segmentationVoxelManager, imageVoxelManager, configuration, segmentIndex, viewport, } = operationData;\n        if (!configuration?.threshold?.isDynamic || !centerIJK || !segmentIndex) {\n            return;\n        }\n        if (operationName === StrategyCallbacks.RejectPreview ||\n            operationName === StrategyCallbacks.OnInteractionEnd) {\n            return;\n        }\n        const boundsIJK = segmentationVoxelManager.getBoundsIJK();\n        const { range: oldThreshold, dynamicRadius = 0 } = configuration.threshold;\n        const useDelta = oldThreshold ? 0 : dynamicRadius;\n        const { viewPlaneNormal } = viewport.getCamera();\n        const nestedBounds = boundsIJK.map((ijk, idx) => {\n            const [min, max] = ijk;\n            return [\n                Math.max(min, centerIJK[idx] - useDelta),\n                Math.min(max, centerIJK[idx] + useDelta),\n            ];\n        });\n        if (Math.abs(viewPlaneNormal[0]) > 0.8) {\n            nestedBounds[0] = [centerIJK[0], centerIJK[0]];\n        }\n        else if (Math.abs(viewPlaneNormal[1]) > 0.8) {\n            nestedBounds[1] = [centerIJK[1], centerIJK[1]];\n        }\n        else if (Math.abs(viewPlaneNormal[2]) > 0.8) {\n            nestedBounds[2] = [centerIJK[2], centerIJK[2]];\n        }\n        const threshold = oldThreshold || [Infinity, -Infinity];\n        const useDeltaSqr = useDelta * useDelta;\n        const callback = ({ value, pointIJK }) => {\n            const distance = vec3.sqrDist(centerIJK, pointIJK);\n            if (distance > useDeltaSqr) {\n                return;\n            }\n            const gray = Array.isArray(value) ? vec3.len(value) : value;\n            threshold[0] = Math.min(gray, threshold[0]);\n            threshold[1] = Math.max(gray, threshold[1]);\n        };\n        imageVoxelManager.forEach(callback, { boundsIJK: nestedBounds });\n        configuration.threshold.range = threshold;\n    },\n    [StrategyCallbacks.OnInteractionStart]: (operationData) => {\n        const { configuration } = operationData;\n        if (!configuration?.threshold?.isDynamic) {\n            return;\n        }\n        configuration.threshold.range = null;\n    },\n    [StrategyCallbacks.ComputeInnerCircleRadius]: (operationData) => {\n        const { configuration, viewport } = operationData;\n        const { dynamicRadius = 0, isDynamic } = configuration.threshold;\n        if (!isDynamic) {\n            configuration.threshold.dynamicRadiusInCanvas = 0;\n            return;\n        }\n        if (dynamicRadius === 0) {\n            return;\n        }\n        const imageData = viewport.getImageData();\n        if (!imageData) {\n            return;\n        }\n        const { spacing } = imageData;\n        const centerCanvas = [\n            viewport.element.clientWidth / 2,\n            viewport.element.clientHeight / 2,\n        ];\n        const radiusInWorld = dynamicRadius * spacing[0];\n        const centerCursorInWorld = viewport.canvasToWorld(centerCanvas);\n        const offSetCenterInWorld = centerCursorInWorld.map((coord) => coord + radiusInWorld);\n        const offSetCenterCanvas = viewport.worldToCanvas(offSetCenterInWorld);\n        const dynamicRadiusInCanvas = Math.abs(centerCanvas[0] - offSetCenterCanvas[0]);\n        if (!configuration.threshold.dynamicRadiusInCanvas) {\n            configuration.threshold.dynamicRadiusInCanvas = 0;\n        }\n        configuration.threshold.dynamicRadiusInCanvas = 3 + dynamicRadiusInCanvas;\n    },\n};\n","import StrategyCallbacks from '../../../../enums/StrategyCallbacks';\nexport default {\n    [StrategyCallbacks.Initialize]: (operationData) => {\n        operationData.segmentIndex = 0;\n    },\n};\n","import { triggerSegmentationDataModified } from '../../../../stateManagement/segmentation/triggerSegmentationEvents';\nimport StrategyCallbacks from '../../../../enums/StrategyCallbacks';\nimport IslandRemoval from '../../../../utilities/segmentation/islandRemoval';\nexport default {\n    [StrategyCallbacks.OnInteractionEnd]: (operationData) => {\n        const { previewSegmentIndex, segmentIndex, viewport, segmentationVoxelManager, activeStrategy, memo, } = operationData;\n        if (activeStrategy !== 'THRESHOLD_INSIDE_SPHERE_WITH_ISLAND_REMOVAL' ||\n            segmentIndex === null) {\n            return;\n        }\n        const islandRemoval = new IslandRemoval();\n        const voxelManager = memo?.voxelManager || segmentationVoxelManager;\n        if (!islandRemoval.initialize(viewport, voxelManager, {\n            previewSegmentIndex,\n            segmentIndex,\n        })) {\n            return;\n        }\n        islandRemoval.floodFillSegmentIsland();\n        islandRemoval.removeExternalIslands();\n        islandRemoval.removeInternalIslands();\n        const arrayOfSlices = voxelManager.getArrayOfModifiedSlices();\n        if (!arrayOfSlices) {\n            return;\n        }\n        triggerSegmentationDataModified(operationData.segmentationId, arrayOfSlices, previewSegmentIndex);\n    },\n};\n","import { utilities } from '@cornerstonejs/core';\nimport { triggerSegmentationDataModified } from '../../../../stateManagement/segmentation/events/triggerSegmentationDataModified';\nimport StrategyCallbacks from '../../../../enums/StrategyCallbacks';\nimport { setSegmentIndexColor } from '../../../../stateManagement/segmentation/config/segmentationColor';\nimport { getViewportIdsWithSegmentation } from '../../../../stateManagement/segmentation/getViewportIdsWithSegmentation';\nexport default {\n    [StrategyCallbacks.Preview]: function (operationData) {\n        const { previewSegmentIndex, configuration, enabledElement } = operationData;\n        if (!previewSegmentIndex || !configuration) {\n            return;\n        }\n        this.onInteractionStart?.(enabledElement, operationData);\n        const preview = this.fill(enabledElement, operationData);\n        if (preview) {\n            this.onInteractionEnd?.(enabledElement, operationData);\n        }\n        return preview;\n    },\n    [StrategyCallbacks.Initialize]: (operationData) => {\n        const { segmentIndex, previewColor, previewSegmentIndex } = operationData;\n        if (previewSegmentIndex == null || segmentIndex == null) {\n            return;\n        }\n        const viewportIds = getViewportIdsWithSegmentation(operationData.segmentationId);\n        viewportIds?.forEach((viewportId) => {\n            setSegmentIndexColor(viewportId, operationData.segmentationId, previewSegmentIndex, previewColor);\n        });\n    },\n    [StrategyCallbacks.AcceptPreview]: (operationData) => {\n        const { previewSegmentIndex, segmentationVoxelManager, memo, segmentIndex, centerSegmentIndexInfo, } = operationData || {};\n        const { changedIndices } = centerSegmentIndexInfo || {};\n        const labelmapMemo = memo;\n        const callback = ({ index }) => {\n            const oldValue = segmentationVoxelManager.getAtIndex(index);\n            if (changedIndices?.length > 0) {\n                if (changedIndices.includes(index)) {\n                    labelmapMemo.voxelManager.setAtIndex(index, 0);\n                }\n            }\n            else {\n                if (oldValue === previewSegmentIndex) {\n                    labelmapMemo.voxelManager.setAtIndex(index, segmentIndex);\n                }\n            }\n        };\n        segmentationVoxelManager.forEach(callback);\n        triggerSegmentationDataModified(operationData.segmentationId, segmentationVoxelManager.getArrayOfModifiedSlices(), segmentIndex);\n        operationData.centerSegmentIndexInfo.changedIndices = [];\n    },\n    [StrategyCallbacks.RejectPreview]: (operationData) => {\n        if (!operationData) {\n            return;\n        }\n        utilities.HistoryMemo.DefaultHistoryMemo.undoIf((memo) => {\n            const labelmapMemo = memo;\n            if (!labelmapMemo?.voxelManager) {\n                return false;\n            }\n            const { segmentationVoxelManager } = labelmapMemo;\n            let hasPreviewSegmentIndex = false;\n            const callback = ({ value }) => {\n                if (value === operationData.previewSegmentIndex) {\n                    hasPreviewSegmentIndex = true;\n                }\n            };\n            segmentationVoxelManager.forEach(callback);\n            return hasPreviewSegmentIndex;\n        });\n    },\n};\n","import StrategyCallbacks from '../../../../enums/StrategyCallbacks';\nexport default {\n    [StrategyCallbacks.Fill]: (operationData) => {\n        const { segmentsLocked, segmentationImageData, segmentationVoxelManager, brushStrategy, centerIJK, } = operationData;\n        const isWithinThreshold = brushStrategy.createIsInThreshold?.(operationData);\n        const { setValue } = brushStrategy;\n        const callback = isWithinThreshold\n            ? (data) => {\n                const { value, index } = data;\n                if (segmentsLocked.includes(value) || !isWithinThreshold(index)) {\n                    return;\n                }\n                setValue(operationData, data);\n            }\n            : (data) => setValue(operationData, data);\n        segmentationVoxelManager.forEach(callback, {\n            imageData: segmentationImageData,\n            isInObject: operationData.isInObject,\n            boundsIJK: operationData.isInObjectBoundsIJK,\n        });\n        segmentationVoxelManager.addPoint(centerIJK);\n    },\n};\n","import StrategyCallbacks from '../../../../enums/StrategyCallbacks';\nimport { handleUseSegmentCenterIndex } from '../utils/handleUseSegmentCenterIndex';\nexport default {\n    [StrategyCallbacks.INTERNAL_setValue]: (operationData, { value, index }) => {\n        const { segmentsLocked, previewSegmentIndex, memo, segmentationVoxelManager, centerSegmentIndexInfo, segmentIndex, } = operationData;\n        const existingValue = segmentationVoxelManager.getAtIndex(index);\n        if (segmentsLocked.includes(value)) {\n            return;\n        }\n        if (!centerSegmentIndexInfo && existingValue === segmentIndex) {\n            return;\n        }\n        if (centerSegmentIndexInfo?.segmentIndex !== 0 &&\n            existingValue === segmentIndex) {\n            return;\n        }\n        if (centerSegmentIndexInfo?.segmentIndex === null) {\n            memo.voxelManager.setAtIndex(index, previewSegmentIndex ?? segmentIndex);\n            return;\n        }\n        if (!previewSegmentIndex) {\n            let useSegmentIndex = segmentIndex;\n            if (centerSegmentIndexInfo) {\n                useSegmentIndex = centerSegmentIndexInfo.segmentIndex;\n            }\n            memo.voxelManager.setAtIndex(index, useSegmentIndex);\n            return;\n        }\n        handleUseSegmentCenterIndex({\n            operationData,\n            existingValue,\n            index,\n        });\n    },\n};\n","export function handleUseSegmentCenterIndex({ operationData, existingValue, index, }) {\n    const { previewSegmentIndex, memo, centerSegmentIndexInfo, previewOnHover, segmentIndex, } = operationData;\n    const { hasPreviewIndex, hasSegmentIndex, segmentIndex: centerSegmentIndex, } = centerSegmentIndexInfo;\n    if (centerSegmentIndex === 0 && hasSegmentIndex && hasPreviewIndex) {\n        if (existingValue === segmentIndex) {\n            return;\n        }\n        if (previewOnHover) {\n            return;\n        }\n        if (existingValue === previewSegmentIndex) {\n            memo.voxelManager.setAtIndex(index, 0);\n            return;\n        }\n        return;\n    }\n    if (centerSegmentIndex === 0 && hasSegmentIndex && !hasPreviewIndex) {\n        if (existingValue === 0 || existingValue !== segmentIndex) {\n            return;\n        }\n        memo.voxelManager.setAtIndex(index, previewSegmentIndex);\n        centerSegmentIndexInfo.changedIndices.push(index);\n        return;\n    }\n    if (centerSegmentIndex === 0 && !hasSegmentIndex && hasPreviewIndex) {\n        if (existingValue === segmentIndex) {\n            return;\n        }\n        if (previewOnHover) {\n            return;\n        }\n        if (existingValue === previewSegmentIndex) {\n            memo.voxelManager.setAtIndex(index, 0);\n            return;\n        }\n        return;\n    }\n    if (centerSegmentIndex === 0 && !hasSegmentIndex && !hasPreviewIndex) {\n        if (existingValue === segmentIndex) {\n            return;\n        }\n        if (existingValue === previewSegmentIndex) {\n            memo.voxelManager.setAtIndex(index, previewSegmentIndex);\n            return;\n        }\n        return;\n    }\n    if (centerSegmentIndex === previewSegmentIndex &&\n        hasSegmentIndex &&\n        hasPreviewIndex) {\n        if (existingValue === segmentIndex) {\n            return;\n        }\n        memo.voxelManager.setAtIndex(index, previewSegmentIndex);\n        return;\n    }\n    if (centerSegmentIndex === previewSegmentIndex &&\n        !hasSegmentIndex &&\n        hasPreviewIndex) {\n        if (existingValue === segmentIndex) {\n            return;\n        }\n        memo.voxelManager.setAtIndex(index, previewSegmentIndex);\n        return;\n    }\n    if (centerSegmentIndex === segmentIndex &&\n        hasSegmentIndex &&\n        hasPreviewIndex) {\n        if (existingValue === segmentIndex) {\n            return;\n        }\n        memo.voxelManager.setAtIndex(index, previewSegmentIndex);\n        return;\n    }\n    if (centerSegmentIndex === segmentIndex &&\n        hasSegmentIndex &&\n        !hasPreviewIndex) {\n        if (existingValue === segmentIndex) {\n            return;\n        }\n        memo.voxelManager.setAtIndex(index, previewSegmentIndex);\n        return;\n    }\n}\n","import { vec3 } from 'gl-matrix';\nimport StrategyCallbacks from '../../../../enums/StrategyCallbacks';\nexport default {\n    [StrategyCallbacks.CreateIsInThreshold]: (operationData) => {\n        const { imageVoxelManager, segmentIndex, configuration } = operationData;\n        if (!configuration || !segmentIndex) {\n            return;\n        }\n        return (index) => {\n            const voxelValue = imageVoxelManager.getAtIndex(index);\n            const gray = Array.isArray(voxelValue)\n                ? vec3.length(voxelValue)\n                : voxelValue;\n            const { threshold } = configuration || {};\n            if (!threshold?.range?.length) {\n                return true;\n            }\n            return threshold.range[0] <= gray && gray <= threshold.range[1];\n        };\n    },\n};\n","import StrategyCallbacks from '../../../../enums/StrategyCallbacks';\nimport getStatistics from '../../../../utilities/segmentation/getStatistics';\nexport default {\n    [StrategyCallbacks.GetStatistics]: function (enabledElement, operationData, options) {\n        const { indices } = options;\n        const { segmentationId, viewport } = operationData;\n        getStatistics({\n            segmentationId,\n            segmentIndices: indices,\n        });\n    },\n};\n","import determineSegmentIndex from './determineSegmentIndex';\nimport dynamicThreshold from './dynamicThreshold';\nimport erase from './erase';\nimport islandRemoval from './islandRemovalComposition';\nimport preview from './preview';\nimport regionFill from './regionFill';\nimport setValue from './setValue';\nimport threshold from './threshold';\nimport labelmapStatistics from './labelmapStatistics';\nimport ensureSegmentationVolumeFor3DManipulation from './ensureSegmentationVolume';\nimport ensureImageVolumeFor3DManipulation from './ensureImageVolume';\nexport default {\n    determineSegmentIndex,\n    dynamicThreshold,\n    erase,\n    islandRemoval,\n    preview,\n    regionFill,\n    setValue,\n    threshold,\n    labelmapStatistics,\n    ensureSegmentationVolumeFor3DManipulation,\n    ensureImageVolumeFor3DManipulation,\n};\n","import BrushStrategy from './BrushStrategy';\nimport { CIRCLE_STRATEGY } from './fillCircle';\nimport compositions from './compositions';\nconst ERASE_CIRCLE_STRATEGY = new BrushStrategy('EraseCircle', compositions.erase, ...CIRCLE_STRATEGY.compositions);\nconst eraseInsideCircle = ERASE_CIRCLE_STRATEGY.strategyFunction;\nexport { eraseInsideCircle };\n","import BrushStrategy from './BrushStrategy';\nimport { SPHERE_STRATEGY } from './fillSphere';\nimport compositions from './compositions';\nconst ERASE_SPHERE_STRATEGY = new BrushStrategy('EraseSphere', compositions.erase, ...SPHERE_STRATEGY.compositions);\nconst eraseInsideSphere = ERASE_SPHERE_STRATEGY.strategyFunction;\nexport { eraseInsideSphere };\n","import { utilities as csUtils } from '@cornerstonejs/core';\nimport { vec3 } from 'gl-matrix';\nimport BrushStrategy from './BrushStrategy';\nimport compositions from './compositions';\nimport StrategyCallbacks from '../../../enums/StrategyCallbacks';\nimport { createEllipseInPoint } from './fillCircle';\nconst { transformWorldToIndex } = csUtils;\nimport { getSphereBoundsInfoFromViewport } from '../../../utilities/getSphereBoundsInfo';\nconst sphereComposition = {\n    [StrategyCallbacks.Initialize]: (operationData) => {\n        const { points, viewport, segmentationImageData } = operationData;\n        if (!points) {\n            return;\n        }\n        const center = vec3.fromValues(0, 0, 0);\n        points.forEach((point) => {\n            vec3.add(center, center, point);\n        });\n        vec3.scale(center, center, 1 / points.length);\n        operationData.centerWorld = center;\n        operationData.centerIJK = transformWorldToIndex(segmentationImageData, center);\n        const { boundsIJK: newBoundsIJK, topLeftWorld, bottomRightWorld, } = getSphereBoundsInfoFromViewport(points.slice(0, 2), segmentationImageData, viewport);\n        operationData.isInObjectBoundsIJK = newBoundsIJK;\n        operationData.isInObject = createEllipseInPoint({\n            topLeftWorld,\n            bottomRightWorld,\n            center,\n        });\n    },\n};\nconst SPHERE_STRATEGY = new BrushStrategy('Sphere', compositions.regionFill, compositions.setValue, sphereComposition, compositions.determineSegmentIndex, compositions.preview, compositions.labelmapStatistics, compositions.ensureSegmentationVolumeFor3DManipulation);\nconst fillInsideSphere = SPHERE_STRATEGY.strategyFunction;\nconst SPHERE_THRESHOLD_STRATEGY = new BrushStrategy('SphereThreshold', ...SPHERE_STRATEGY.compositions, compositions.dynamicThreshold, compositions.threshold, compositions.ensureSegmentationVolumeFor3DManipulation, compositions.ensureImageVolumeFor3DManipulation);\nconst SPHERE_THRESHOLD_STRATEGY_ISLAND = new BrushStrategy('SphereThreshold', ...SPHERE_STRATEGY.compositions, compositions.dynamicThreshold, compositions.threshold, compositions.islandRemoval, compositions.ensureSegmentationVolumeFor3DManipulation, compositions.ensureImageVolumeFor3DManipulation);\nconst thresholdInsideSphere = SPHERE_THRESHOLD_STRATEGY.strategyFunction;\nconst thresholdInsideSphereIsland = SPHERE_THRESHOLD_STRATEGY_ISLAND.strategyFunction;\nexport function fillOutsideSphere() {\n    throw new Error('fill outside sphere not implemented');\n}\nexport { fillInsideSphere, thresholdInsideSphere, SPHERE_STRATEGY, thresholdInsideSphereIsland, };\n","import { cache, Enums, eventTarget } from '@cornerstonejs/core';\nimport { getCurrentLabelmapImageIdForViewport } from '../../../../stateManagement/segmentation/segmentationState';\nimport { getLabelmapActorEntry } from '../../../../stateManagement/segmentation/helpers';\nimport { getReferenceVolumeForSegmentationVolume } from '../../../../utilities/segmentation/getReferenceVolumeForSegmentationVolume';\nfunction getStrategyDataForVolumeViewport({ operationData }) {\n    const { volumeId } = operationData;\n    if (!volumeId) {\n        const event = new CustomEvent(Enums.Events.ERROR_EVENT, {\n            detail: {\n                type: 'Segmentation',\n                message: 'No volume id found for the segmentation',\n            },\n            cancelable: true,\n        });\n        eventTarget.dispatchEvent(event);\n        return null;\n    }\n    const segmentationVolume = cache.getVolume(volumeId);\n    const imageVolume = getReferenceVolumeForSegmentationVolume(volumeId);\n    if (!segmentationVolume || !imageVolume) {\n        return null;\n    }\n    const { imageData: segmentationImageData } = segmentationVolume;\n    const { voxelManager: segmentationVoxelManager } = segmentationVolume;\n    const { voxelManager: imageVoxelManager, imageData } = imageVolume;\n    return {\n        segmentationImageData,\n        segmentationVoxelManager,\n        segmentationScalarData: null,\n        imageScalarData: null,\n        imageVoxelManager,\n        imageData,\n    };\n}\nfunction getStrategyDataForStackViewport({ operationData, viewport, strategy, }) {\n    const { segmentationId } = operationData;\n    let segmentationImageData;\n    let segmentationVoxelManager;\n    let segmentationScalarData;\n    let imageScalarData;\n    let imageVoxelManager;\n    let imageData;\n    if (strategy.ensureSegmentationVolumeFor3DManipulation) {\n        strategy.ensureSegmentationVolumeFor3DManipulation({\n            operationData,\n            viewport,\n        });\n        segmentationVoxelManager = operationData.segmentationVoxelManager;\n        segmentationImageData = operationData.segmentationImageData;\n        segmentationScalarData = null;\n    }\n    else {\n        const labelmapImageId = getCurrentLabelmapImageIdForViewport(viewport.id, segmentationId);\n        if (!labelmapImageId) {\n            return null;\n        }\n        const actorEntry = getLabelmapActorEntry(viewport.id, segmentationId);\n        if (!actorEntry) {\n            return null;\n        }\n        const currentSegImage = cache.getImage(labelmapImageId);\n        segmentationImageData = actorEntry.actor.getMapper().getInputData();\n        segmentationVoxelManager = currentSegImage.voxelManager;\n        const currentSegmentationImageId = operationData.imageId;\n        const segmentationImage = cache.getImage(currentSegmentationImageId);\n        if (!segmentationImage) {\n            return null;\n        }\n        segmentationScalarData = segmentationImage.getPixelData?.();\n    }\n    if (strategy.ensureImageVolumeFor3DManipulation) {\n        strategy.ensureImageVolumeFor3DManipulation({\n            operationData,\n            viewport,\n        });\n        imageVoxelManager = operationData.imageVoxelManager;\n        imageScalarData = operationData.imageScalarData;\n        imageData = operationData.imageData;\n    }\n    else {\n        const currentImageId = viewport.getCurrentImageId();\n        if (!currentImageId) {\n            return null;\n        }\n        const image = cache.getImage(currentImageId);\n        imageData = image ? null : viewport.getImageData();\n        imageScalarData = image?.getPixelData() || imageData.getScalarData();\n        imageVoxelManager = image?.voxelManager;\n    }\n    return {\n        segmentationImageData,\n        segmentationScalarData,\n        imageScalarData,\n        segmentationVoxelManager,\n        imageVoxelManager,\n        imageData,\n    };\n}\nfunction getStrategyData({ operationData, viewport, strategy, }) {\n    if (!operationData) {\n        return null;\n    }\n    if (('volumeId' in operationData && operationData.volumeId != null) ||\n        ('referencedVolumeId' in operationData &&\n            operationData.referencedVolumeId != null)) {\n        return getStrategyDataForVolumeViewport({ operationData });\n    }\n    return getStrategyDataForStackViewport({ operationData, viewport, strategy });\n}\nexport { getStrategyData };\n","class RectangleROIStartEndThreshold {\n    constructor() {\n    }\n    static getContourSequence(toolData, metadataProvider) {\n        const { data } = toolData;\n        const { projectionPoints, projectionPointsImageIds } = data.cachedStats;\n        return projectionPoints.map((point, index) => {\n            const ContourData = getPointData(point);\n            const ContourImageSequence = getContourImageSequence(projectionPointsImageIds[index], metadataProvider);\n            return {\n                NumberOfContourPoints: ContourData.length / 3,\n                ContourImageSequence,\n                ContourGeometricType: 'CLOSED_PLANAR',\n                ContourData,\n            };\n        });\n    }\n}\nRectangleROIStartEndThreshold.toolName = 'RectangleROIStartEndThreshold';\nfunction getPointData(points) {\n    const orderedPoints = [\n        ...points[0],\n        ...points[1],\n        ...points[3],\n        ...points[2],\n    ];\n    const pointsArray = orderedPoints.flat();\n    const pointsArrayWithPrecision = pointsArray.map((point) => {\n        return point.toFixed(2);\n    });\n    return pointsArrayWithPrecision;\n}\nfunction getContourImageSequence(imageId, metadataProvider) {\n    const sopCommon = metadataProvider.get('sopCommonModule', imageId);\n    return {\n        ReferencedSOPClassUID: sopCommon.sopClassUID,\n        ReferencedSOPInstanceUID: sopCommon.sopInstanceUID,\n    };\n}\nexport default RectangleROIStartEndThreshold;\n","import { getAnnotations } from '../../../stateManagement/annotation/annotationState';\nconst DEFAULT_CONTOUR_SEG_TOOLNAME = 'PlanarFreehandContourSegmentationTool';\nexport default function getInterpolationData(viewportData, filterParams = []) {\n    const { viewport, sliceData, annotation } = viewportData;\n    const interpolationDatas = new Map();\n    const { toolName, originalToolName } = annotation.metadata;\n    const testToolName = originalToolName || toolName;\n    const annotations = (getAnnotations(testToolName, viewport.element) || []).filter((annotation) => !annotation.metadata.originalToolName ||\n        annotation.metadata.originalToolName === testToolName);\n    if (testToolName !== DEFAULT_CONTOUR_SEG_TOOLNAME) {\n        const modifiedAnnotations = getAnnotations(DEFAULT_CONTOUR_SEG_TOOLNAME, viewport.element);\n        if (modifiedAnnotations?.length) {\n            modifiedAnnotations.forEach((annotation) => {\n                const { metadata } = annotation;\n                if (metadata.originalToolName === testToolName &&\n                    metadata.originalToolName !== metadata.toolName) {\n                    annotations.push(annotation);\n                }\n            });\n        }\n    }\n    if (!annotations?.length) {\n        return interpolationDatas;\n    }\n    for (let i = 0; i < sliceData.numberOfSlices; i++) {\n        const imageAnnotations = annotations.filter((x) => x.metadata.sliceIndex === i);\n        if (!imageAnnotations?.length) {\n            continue;\n        }\n        const filteredInterpolatedAnnotations = imageAnnotations.filter((imageAnnotation) => {\n            return filterParams.every((x) => {\n                const parent = x.parentKey\n                    ? x.parentKey(imageAnnotation)\n                    : imageAnnotation;\n                const value = parent?.[x.key];\n                if (Array.isArray(value)) {\n                    return value.every((item, index) => item === x.value[index]);\n                }\n                return value === x.value;\n            });\n        });\n        if (filteredInterpolatedAnnotations.length) {\n            interpolationDatas.set(i, filteredInterpolatedAnnotations);\n        }\n    }\n    return interpolationDatas;\n}\n","import getInterpolationData from './getInterpolationData';\nexport default function getInterpolationDataCollection(viewportData, filterParams) {\n    const imageAnnotations = getInterpolationData(viewportData, filterParams);\n    const interpolatedDataCollection = [];\n    if (!imageAnnotations?.size) {\n        return interpolatedDataCollection;\n    }\n    for (const annotations of imageAnnotations.values()) {\n        annotations.forEach((annotation) => {\n            interpolatedDataCollection.push(annotation);\n        });\n    }\n    return interpolatedDataCollection;\n}\n","import { utilities as csUtils } from '@cornerstonejs/core';\nexport default function createPolylineToolData(polyline, handlePoints, referencedToolData) {\n    const annotation = csUtils.deepMerge({\n        data: {},\n        metadata: {},\n    }, referencedToolData);\n    Object.assign(annotation, {\n        highlighted: false,\n        invalidated: true,\n        autoGenerated: true,\n        annotationUID: undefined,\n        cachedStats: {},\n        childAnnotationUIDs: [],\n        parentAnnotationUID: undefined,\n    });\n    Object.assign(annotation.data, {\n        handles: {\n            points: handlePoints.points || handlePoints || [],\n            interpolationSources: handlePoints.sources,\n            activeHandleIndex: null,\n            textBox: {\n                hasMoved: false,\n                worldPosition: [0, 0, 0],\n                worldBoundingBox: {\n                    topLeft: [0, 0, 0],\n                    topRight: [0, 0, 0],\n                    bottomLeft: [0, 0, 0],\n                    bottomRight: [0, 0, 0],\n                },\n            },\n        },\n        contour: {\n            ...referencedToolData.data.contour,\n            polyline,\n        },\n    });\n    return annotation;\n}\n","import getInterpolationData from './getInterpolationData';\nfunction findAnnotationsForInterpolation(toolData, viewportData) {\n    const interpolationData = getInterpolationData(viewportData, [\n        {\n            key: 'interpolationUID',\n            value: viewportData.interpolationUID,\n        },\n    ]);\n    const rangeToInterpolate = getRangeToInterpolate(interpolationData);\n    if (!rangeToInterpolate) {\n        console.warn('No annotations found to interpolate', interpolationData);\n        return;\n    }\n    const sliceEdited = _getSlicePositionOfToolData(interpolationData, toolData.annotationUID);\n    const interpolationList = [];\n    for (let i = rangeToInterpolate[0] + 1; i < rangeToInterpolate[1]; i++) {\n        if (_sliceNeedsInterpolating(interpolationData, i)) {\n            const contourPair = _getBoundingPair(i, rangeToInterpolate, interpolationData);\n            if (contourPair?.[0] === sliceEdited ||\n                contourPair?.[1] === sliceEdited) {\n                _appendInterpolationList(contourPair, interpolationList, i);\n            }\n        }\n    }\n    return {\n        interpolationData,\n        interpolationList,\n    };\n}\nfunction getRangeToInterpolate(interpolationData) {\n    let first = Infinity;\n    let last = -Infinity;\n    let found = false;\n    for (const [sliceIndex, annotations] of interpolationData.entries()) {\n        if (annotations.length) {\n            first = Math.min(sliceIndex, first);\n            last = Math.max(sliceIndex, last);\n            found = true;\n        }\n    }\n    if (!found) {\n        return;\n    }\n    return [first, last];\n}\nfunction _getSlicePositionOfToolData(interpolationData, annotationUID) {\n    for (const [sliceIndex, annotations] of interpolationData) {\n        for (let j = 0; j < annotations.length; j++) {\n            if (annotations[j].annotationUID === annotationUID) {\n                return sliceIndex;\n            }\n        }\n    }\n    return;\n}\nfunction _sliceNeedsInterpolating(interpolationData, sliceIndex) {\n    const annotations = interpolationData.get(sliceIndex);\n    return (!annotations?.length ||\n        (annotations.length === 1 && annotations[0].autoGenerated));\n}\nfunction _appendInterpolationList(contourPair, interpolationList, itemIndex) {\n    const [startIndex] = contourPair;\n    interpolationList[startIndex] ||= {\n        pair: contourPair,\n        list: [],\n    };\n    interpolationList[startIndex].list.push(itemIndex);\n}\nfunction _getBoundingPair(sliceIndex, sliceRange, interpolationData) {\n    const annotationPair = [];\n    let canInterpolate = true;\n    for (let i = sliceIndex - 1; i >= sliceRange[0]; i--) {\n        const annotations = interpolationData.get(i);\n        if (annotations?.length) {\n            if (annotations[0].autoGenerated) {\n                continue;\n            }\n            if (annotations.length > 1) {\n                canInterpolate = false;\n            }\n            annotationPair.push(i);\n            break;\n        }\n    }\n    if (!canInterpolate || !annotationPair.length) {\n        return;\n    }\n    for (let i = sliceIndex + 1; i <= sliceRange[1]; i++) {\n        const annotations = interpolationData.get(i);\n        if (annotations?.length) {\n            if (annotations[0].autoGenerated) {\n                continue;\n            }\n            if (annotations.length > 1) {\n                canInterpolate = false;\n            }\n            annotationPair.push(i);\n            break;\n        }\n    }\n    if (!canInterpolate || annotationPair.length < 2) {\n        return;\n    }\n    return annotationPair;\n}\nexport default findAnnotationsForInterpolation;\n","import { vec3 } from 'gl-matrix';\nimport { utilities } from '@cornerstonejs/core';\nconst { PointsManager } = utilities;\nexport default function selectHandles(polyline, handleCount = 12) {\n    const handles = PointsManager.create3(handleCount);\n    handles.sources = [];\n    const { sources: destPoints } = handles;\n    const { length, sources: sourcePoints = [] } = polyline;\n    const distance = 5;\n    if (length < distance * 3) {\n        return polyline.subselect(handleCount);\n    }\n    const interval = Math.floor(Math.max((2 * length) / handleCount, distance * 2));\n    sourcePoints.forEach(() => destPoints.push(PointsManager.create3(handleCount)));\n    const dotValues = createDotValues(polyline, distance);\n    const minimumRegions = findMinimumRegions(dotValues, handleCount);\n    const indices = [];\n    if (minimumRegions?.length > 2) {\n        let lastHandle = -1;\n        const thirdInterval = interval / 3;\n        minimumRegions.forEach((region) => {\n            const [start, , end] = region;\n            const midIndex = Math.ceil((start + end) / 2);\n            if (end - lastHandle < thirdInterval) {\n                return;\n            }\n            if (midIndex - start > 2 * thirdInterval) {\n                addInterval(indices, lastHandle, start, interval, length);\n                lastHandle = addInterval(indices, start, midIndex, interval, length);\n            }\n            else {\n                lastHandle = addInterval(indices, lastHandle, midIndex, interval, length);\n            }\n            if (end - lastHandle > thirdInterval) {\n                lastHandle = addInterval(indices, lastHandle, end, interval, length);\n            }\n        });\n        const firstHandle = indices[0];\n        const lastDistance = indexValue(firstHandle + length - lastHandle, length);\n        if (lastDistance > 2 * thirdInterval) {\n            addInterval(indices, lastHandle, firstHandle - thirdInterval, interval, length);\n        }\n    }\n    else {\n        const interval = Math.floor(length / handleCount);\n        addInterval(indices, -1, length - interval, interval, length);\n    }\n    indices.forEach((index) => {\n        const point = polyline.getPointArray(index);\n        handles.push(point);\n        sourcePoints.forEach((source, destSourceIndex) => destPoints[destSourceIndex].push(source.getPoint(index)));\n    });\n    return handles;\n}\nexport function createDotValues(polyline, distance = 6) {\n    const { length } = polyline;\n    const prevVec3 = vec3.create();\n    const nextVec3 = vec3.create();\n    const dotValues = new Float32Array(length);\n    for (let i = 0; i < length; i++) {\n        const point = polyline.getPoint(i);\n        const prevPoint = polyline.getPoint(i - distance);\n        const nextPoint = polyline.getPoint((i + distance) % length);\n        vec3.sub(prevVec3, point, prevPoint);\n        vec3.sub(nextVec3, nextPoint, point);\n        const dot = vec3.dot(prevVec3, nextVec3) / (vec3.len(prevVec3) * vec3.len(nextVec3));\n        dotValues[i] = dot;\n    }\n    return dotValues;\n}\nfunction findMinimumRegions(dotValues, handleCount) {\n    const { max, deviation } = getStats(dotValues);\n    const { length } = dotValues;\n    if (deviation < 0.01 || length < handleCount * 3) {\n        return [];\n    }\n    const inflection = [];\n    let pair = null;\n    let minValue;\n    let minIndex = 0;\n    for (let i = 0; i < length; i++) {\n        const dot = dotValues[i];\n        if (dot < max - deviation) {\n            if (pair) {\n                pair[2] = i;\n                if (dot < minValue) {\n                    minValue = dot;\n                    minIndex = i;\n                }\n                pair[1] = minIndex;\n            }\n            else {\n                minValue = dot;\n                minIndex = i;\n                pair = [i, i, i];\n            }\n        }\n        else {\n            if (pair) {\n                inflection.push(pair);\n                pair = null;\n            }\n        }\n    }\n    if (pair) {\n        if (inflection[0][0] === 0) {\n            inflection[0][0] = pair[0];\n        }\n        else {\n            pair[1] = minIndex;\n            pair[2] = length - 1;\n            inflection.push(pair);\n        }\n    }\n    return inflection;\n}\nexport function addInterval(indices, start, finish, interval, length) {\n    if (finish < start) {\n        finish += length;\n    }\n    const distance = finish - start;\n    const count = Math.ceil(distance / interval);\n    if (count <= 0) {\n        if (indices[indices.length - 1] !== finish) {\n            indices.push(indexValue(finish, length));\n        }\n        return finish;\n    }\n    for (let i = 1; i <= count; i++) {\n        const index = indexValue(start + (i * distance) / count, length);\n        indices.push(index);\n    }\n    return indices[indices.length - 1];\n}\nfunction indexValue(v, length) {\n    return (Math.round(v) + length) % length;\n}\nfunction getStats(dotValues) {\n    const { length } = dotValues;\n    let sum = 0;\n    let min = Infinity;\n    let max = -Infinity;\n    let sumSq = 0;\n    for (let i = 0; i < length; i++) {\n        const dot = dotValues[i];\n        sum += dot;\n        min = Math.min(min, dot);\n        max = Math.max(max, dot);\n    }\n    const mean = sum / length;\n    for (let i = 0; i < length; i++) {\n        const valueDiff = dotValues[i] - mean;\n        sumSq += valueDiff * valueDiff;\n    }\n    return {\n        mean,\n        max,\n        min,\n        sumSq,\n        deviation: Math.sqrt(sumSq / length),\n    };\n}\n","import { triggerEvent, utilities } from '@cornerstonejs/core';\nimport { vec3 } from 'gl-matrix';\nimport createPolylineToolData from './createPolylineToolData';\nimport findAnnotationsForInterpolation from './findAnnotationForInterpolation';\nimport EventTypes from '../../../enums/Events';\nimport * as annotationState from '../../../stateManagement/annotation';\nimport selectHandles from './selectHandles';\nimport updateChildInterpolationUID from './updateChildInterpolationUID';\nimport { createPolylineHole } from '../../../eventListeners/annotations/contourSegmentation/contourSegmentationCompleted';\nconst { PointsManager } = utilities;\nconst dP = 0.2;\nfunction interpolate(viewportData) {\n    if (!viewportData.annotation) {\n        return;\n    }\n    const { isInterpolationUpdate, annotation } = viewportData;\n    queueMicrotask(() => {\n        try {\n            if (isInterpolationUpdate) {\n                annotation.isInterpolationUpdate = true;\n                annotation.autoGenerated = false;\n            }\n            startInterpolation(viewportData);\n        }\n        finally {\n            if (isInterpolationUpdate) {\n                annotation.autoGenerated = true;\n            }\n        }\n    });\n}\nfunction startInterpolation(viewportData) {\n    const { annotation: toolData } = viewportData;\n    updateChildInterpolationUID(toolData);\n    const { interpolationData, interpolationList } = findAnnotationsForInterpolation(toolData, viewportData) || {};\n    if (!interpolationData || !interpolationList) {\n        return;\n    }\n    const eventData = {\n        toolName: toolData.metadata.toolName,\n        toolType: toolData.metadata.toolName,\n        viewport: viewportData.viewport,\n    };\n    for (let i = 0; i < interpolationList.length; i++) {\n        if (interpolationList[i]) {\n            _linearlyInterpolateBetween(interpolationList[i].list, interpolationList[i].pair, interpolationData, eventData);\n        }\n    }\n    const { id, renderingEngineId, element } = viewportData.viewport;\n    const eventDetails = {\n        annotation: toolData,\n        element,\n        viewportId: id,\n        renderingEngineId,\n    };\n    if (interpolationList.length) {\n        triggerEvent(viewportData.viewport.element, EventTypes.ANNOTATION_INTERPOLATION_PROCESS_COMPLETED, eventDetails);\n    }\n}\nfunction _linearlyInterpolateBetween(indices, annotationPair, interpolationData, eventData) {\n    const annotation0 = interpolationData.get(annotationPair[0])[0];\n    const annotation1 = interpolationData.get(annotationPair[1])[0];\n    const c1 = _generateClosedContour(annotation0.data.contour.polyline);\n    const c2 = _generateClosedContour(annotation1.data.contour.polyline);\n    const { c1Interp, c2Interp } = _generateInterpolationContourPair(c1, c2);\n    c1Interp.kIndex = annotationPair[0];\n    c2Interp.kIndex = annotationPair[1];\n    indices.forEach(function (index) {\n        _linearlyInterpolateContour(c1Interp, c2Interp, index, annotationPair, interpolationData, c1.x.length > c2.x.length, eventData);\n    });\n}\nfunction getPointCount(pointArray) {\n    let sum = 0;\n    for (let i = 0; i < pointArray.I.length; i++) {\n        if (pointArray.I[i]) {\n            sum++;\n        }\n    }\n    return sum;\n}\nfunction _linearlyInterpolateContour(c1Interp, c2Interp, sliceIndex, annotationPair, interpolationData, c1HasMoreNodes, eventData) {\n    const [startIndex, endIndex] = annotationPair;\n    const zInterp = (sliceIndex - startIndex) / (endIndex - startIndex);\n    const annotation0 = interpolationData.get(startIndex)[0];\n    const annotation1 = interpolationData.get(endIndex)[0];\n    const interpolated3DPoints = _generateInterpolatedOpenContour(c1Interp, c2Interp, zInterp, c1HasMoreNodes);\n    const nearestAnnotation = zInterp > 0.5 ? annotation1 : annotation0;\n    const handlePoints = selectHandles(interpolated3DPoints);\n    if (interpolationData.has(sliceIndex)) {\n        _editInterpolatedContour(interpolated3DPoints, handlePoints, sliceIndex, nearestAnnotation, eventData);\n    }\n    else {\n        _addInterpolatedContour(interpolated3DPoints, handlePoints, sliceIndex, nearestAnnotation, eventData);\n    }\n}\nfunction _addInterpolatedContour(interpolated3DPoints, handlePoints, sliceIndex, referencedToolData, eventData) {\n    const points = interpolated3DPoints.points;\n    const { viewport } = eventData;\n    const interpolatedAnnotation = createPolylineToolData(points, handlePoints, referencedToolData);\n    const viewRef = viewport.getViewReference({ sliceIndex });\n    if (!viewRef) {\n        throw new Error(`Can't find slice ${sliceIndex}`);\n    }\n    Object.assign(interpolatedAnnotation.metadata, viewRef);\n    annotationState.state.addAnnotation(interpolatedAnnotation, viewport.element);\n    referencedToolData.onInterpolationComplete?.(interpolatedAnnotation, referencedToolData);\n    const { parentAnnotationUID } = referencedToolData;\n    if (parentAnnotationUID) {\n        const parentReferenced = annotationState.state.getAnnotation(parentAnnotationUID);\n        const parentAnnotation = _findExistingAnnotation(parentReferenced, sliceIndex, eventData);\n        createPolylineHole(viewport, parentAnnotation, interpolatedAnnotation);\n    }\n}\nfunction _findExistingAnnotation(referencedToolData, sliceIndex, eventData) {\n    const { viewport } = eventData;\n    const annotations = annotationState.state.getAnnotations(referencedToolData.metadata.toolName, viewport.element);\n    for (let i = 0; i < annotations.length; i++) {\n        const annotation = annotations[i];\n        if (annotation.interpolationUID === referencedToolData.interpolationUID &&\n            annotation.metadata.sliceIndex === sliceIndex) {\n            return annotation;\n        }\n    }\n}\nfunction _editInterpolatedContour(interpolated3DPoints, handlePoints, sliceIndex, referencedToolData, eventData) {\n    const oldAnnotationData = _findExistingAnnotation(referencedToolData, sliceIndex, eventData);\n    const points = interpolated3DPoints.points;\n    const interpolatedAnnotation = createPolylineToolData(points, handlePoints, oldAnnotationData);\n    Object.assign(oldAnnotationData, {\n        metadata: interpolatedAnnotation.metadata,\n        data: interpolatedAnnotation.data,\n    });\n}\nfunction _generateInterpolatedOpenContour(c1ir, c2ir, zInterp, c1HasMoreNodes) {\n    const indices = c1HasMoreNodes ? c1ir.I : c2ir.I;\n    const c1 = PointsManager.fromXYZ(c1ir);\n    const c2 = PointsManager.fromXYZ(c2ir);\n    const { length } = c1;\n    const cInterp = PointsManager.create3(length);\n    const vecSubtract = vec3.create();\n    const vecResult = vec3.create();\n    const c1Source = PointsManager.create3(length);\n    c1Source.kIndex = c1ir.kIndex;\n    const c2Source = PointsManager.create3(length);\n    c2Source.kIndex = c2ir.kIndex;\n    for (let i = 0; i < c1ir.x.length; i++) {\n        if (indices[i]) {\n            const c1point = c1.getPoint(i);\n            const c2point = c2.getPoint(i);\n            c1Source.push(c1point);\n            c2Source.push(c2point);\n            vec3.sub(vecSubtract, c2point, c1point);\n            cInterp.push(vec3.scaleAndAdd(vecResult, c1point, vecSubtract, zInterp));\n        }\n    }\n    cInterp.sources = [c1Source, c2Source];\n    return cInterp;\n}\nfunction _generateInterpolationContourPair(c1, c2) {\n    const cumPerim1 = _getCumulativePerimeter(c1);\n    const cumPerim2 = _getCumulativePerimeter(c2);\n    const interpNodes = Math.max(Math.ceil(cumPerim1[cumPerim1.length - 1] / dP), Math.ceil(cumPerim2[cumPerim2.length - 1] / dP));\n    const cumPerim1Norm = _normalisedCumulativePerimeter(cumPerim1);\n    const cumPerim2Norm = _normalisedCumulativePerimeter(cumPerim2);\n    const numNodes1 = interpNodes + c2.x.length;\n    const numNodes2 = interpNodes + c1.x.length;\n    const perim1Interp = _getInterpolatedPerim(numNodes1, cumPerim1Norm);\n    const perim2Interp = _getInterpolatedPerim(numNodes2, cumPerim2Norm);\n    const perim1Ind = _getIndicatorArray(numNodes1 - 2, c1.x.length);\n    const perim2Ind = _getIndicatorArray(numNodes2 - 2, c2.x.length);\n    const nodesPerSegment1 = _getNodesPerSegment(perim1Interp, perim1Ind);\n    const nodesPerSegment2 = _getNodesPerSegment(perim2Interp, perim2Ind);\n    const c1i = _getSuperSampledContour(c1, nodesPerSegment1);\n    const c2i = _getSuperSampledContour(c2, nodesPerSegment2);\n    _shiftSuperSampledContourInPlace(c1i, c2i);\n    return _reduceContoursToOriginNodes(c1i, c2i);\n}\nfunction _reduceContoursToOriginNodes(c1i, c2i) {\n    const c1Interp = {\n        x: [],\n        y: [],\n        z: [],\n        I: [],\n    };\n    const c2Interp = {\n        x: [],\n        y: [],\n        z: [],\n        I: [],\n    };\n    for (let i = 0; i < c1i.x.length; i++) {\n        if (c1i.I[i] || c2i.I[i]) {\n            c1Interp.x.push(c1i.x[i]);\n            c1Interp.y.push(c1i.y[i]);\n            c1Interp.z.push(c1i.z[i]);\n            c1Interp.I.push(c1i.I[i]);\n            c2Interp.x.push(c2i.x[i]);\n            c2Interp.y.push(c2i.y[i]);\n            c2Interp.z.push(c2i.z[i]);\n            c2Interp.I.push(c2i.I[i]);\n        }\n    }\n    return {\n        c1Interp,\n        c2Interp,\n    };\n}\nfunction _shiftSuperSampledContourInPlace(c1i, c2i) {\n    const c1iLength = c1i.x.length;\n    const optimal = {\n        startingNode: 0,\n        totalSquaredXYLengths: Infinity,\n    };\n    for (let startingNode = 0; startingNode < c1iLength; startingNode++) {\n        let node = startingNode;\n        let totalSquaredXYLengths = 0;\n        for (let iteration = 0; iteration < c1iLength; iteration++) {\n            totalSquaredXYLengths +=\n                (c1i.x[node] - c2i.x[iteration]) ** 2 +\n                    (c1i.y[node] - c2i.y[iteration]) ** 2 +\n                    (c1i.z[node] - c2i.z[iteration]) ** 2;\n            node++;\n            if (node === c1iLength) {\n                node = 0;\n            }\n        }\n        if (totalSquaredXYLengths < optimal.totalSquaredXYLengths) {\n            optimal.totalSquaredXYLengths = totalSquaredXYLengths;\n            optimal.startingNode = startingNode;\n        }\n    }\n    const node = optimal.startingNode;\n    _shiftCircularArray(c1i.x, node);\n    _shiftCircularArray(c1i.y, node);\n    _shiftCircularArray(c1i.z, node);\n    _shiftCircularArray(c1i.I, node);\n}\nfunction _shiftCircularArray(arr, count) {\n    count -= arr.length * Math.floor(count / arr.length);\n    const slicedArray = arr.splice(0, count);\n    arr.push(...slicedArray);\n    return arr;\n}\nfunction _getSuperSampledContour(c, nodesPerSegment) {\n    const ci = {\n        x: [],\n        y: [],\n        z: [],\n        I: [],\n    };\n    for (let n = 0; n < c.x.length - 1; n++) {\n        ci.x.push(c.x[n]);\n        ci.y.push(c.y[n]);\n        ci.z.push(c.z[n]);\n        ci.I.push(true);\n        const xSpacing = (c.x[n + 1] - c.x[n]) / (nodesPerSegment[n] + 1);\n        const ySpacing = (c.y[n + 1] - c.y[n]) / (nodesPerSegment[n] + 1);\n        const zSpacing = (c.z[n + 1] - c.z[n]) / (nodesPerSegment[n] + 1);\n        for (let i = 0; i < nodesPerSegment[n] - 1; i++) {\n            ci.x.push(ci.x[ci.x.length - 1] + xSpacing);\n            ci.y.push(ci.y[ci.y.length - 1] + ySpacing);\n            ci.z.push(ci.z[ci.z.length - 1] + zSpacing);\n            ci.I.push(false);\n        }\n    }\n    return ci;\n}\nfunction _getNodesPerSegment(perimInterp, perimInd) {\n    const idx = [];\n    for (let i = 0; i < perimInterp.length; ++i) {\n        idx[i] = i;\n    }\n    idx.sort(function (a, b) {\n        return perimInterp[a] < perimInterp[b] ? -1 : 1;\n    });\n    const perimIndSorted = [];\n    for (let i = 0; i < perimInd.length; i++) {\n        perimIndSorted.push(perimInd[idx[i]]);\n    }\n    const indicesOfOriginNodes = perimIndSorted.reduce(function (arr, elementValue, i) {\n        if (elementValue) {\n            arr.push(i);\n        }\n        return arr;\n    }, []);\n    const nodesPerSegment = [];\n    for (let i = 0; i < indicesOfOriginNodes.length - 1; i++) {\n        nodesPerSegment.push(indicesOfOriginNodes[i + 1] - indicesOfOriginNodes[i]);\n    }\n    return nodesPerSegment;\n}\nfunction _getIndicatorArray(numFalse, numTrue) {\n    const perimInd = new Array(numFalse + numTrue);\n    perimInd.fill(false, 0, numFalse);\n    perimInd.fill(true, numFalse, numFalse + numTrue);\n    return perimInd;\n}\nfunction _getInterpolatedPerim(numNodes, cumPerimNorm) {\n    const diff = 1 / (numNodes - 1);\n    const linspace = [diff];\n    for (let i = 1; i < numNodes - 2; i++) {\n        linspace.push(linspace[linspace.length - 1] + diff);\n    }\n    return linspace.concat(cumPerimNorm);\n}\nfunction _normalisedCumulativePerimeter(cumPerim) {\n    const cumPerimNorm = [];\n    for (let i = 0; i < cumPerim.length; i++) {\n        cumPerimNorm.push(cumPerim[i] / cumPerim[cumPerim.length - 1]);\n    }\n    return cumPerimNorm;\n}\nfunction _getCumulativePerimeter(contour) {\n    const cumulativePerimeter = [0];\n    for (let i = 1; i < contour.x.length; i++) {\n        const lengthOfSegment = Math.sqrt((contour.x[i] - contour.x[i - 1]) ** 2 +\n            (contour.y[i] - contour.y[i - 1]) ** 2 +\n            (contour.z[i] - contour.z[i - 1]) ** 2);\n        cumulativePerimeter.push(cumulativePerimeter[i - 1] + lengthOfSegment);\n    }\n    return cumulativePerimeter;\n}\nfunction _generateClosedContour(points) {\n    const c = {\n        x: [],\n        y: [],\n        z: [],\n    };\n    for (let i = 0; i < points.length; i++) {\n        c.x[i] = points[i][0];\n        c.y[i] = points[i][1];\n        c.z[i] = points[i][2];\n    }\n    c.x.push(c.x[0]);\n    c.y.push(c.y[0]);\n    c.z.push(c.z[0]);\n    return c;\n}\nexport default interpolate;\n","import * as annotationState from '../../../stateManagement/annotation';\nexport default function updateChildInterpolationUID(annotation) {\n    const { parentAnnotationUID, annotationUID } = annotation;\n    if (!parentAnnotationUID) {\n        return annotation.interpolationUID;\n    }\n    const parentAnnotation = annotationState.state.getAnnotation(parentAnnotationUID);\n    const { interpolationUID } = parentAnnotation;\n    const index = parentAnnotation.childAnnotationUIDs.indexOf(annotationUID);\n    annotation.interpolationUID = `${interpolationUID}-${index}`;\n    return annotation.interpolationUID;\n}\n","import { utilities } from '@cornerstonejs/core';\nimport { Calculator, InstanceCalculator } from './Calculator';\nconst { PointsManager } = utilities;\nfunction createBasicStatsState(storePointData) {\n    return {\n        max: [-Infinity],\n        min: [Infinity],\n        sum: [0],\n        count: 0,\n        maxIJK: null,\n        maxLPS: null,\n        minIJK: null,\n        minLPS: null,\n        runMean: [0],\n        m2: [0],\n        m3: [0],\n        m4: [0],\n        allValues: [[]],\n        pointsInShape: storePointData ? PointsManager.create3(1024) : null,\n        sumLPS: [0, 0, 0],\n    };\n}\nfunction basicStatsCallback(state, newValue, pointLPS = null, pointIJK = null) {\n    if (Array.isArray(newValue) &&\n        newValue.length > 1 &&\n        state.max.length === 1) {\n        state.max.push(state.max[0], state.max[0]);\n        state.min.push(state.min[0], state.min[0]);\n        state.sum.push(state.sum[0], state.sum[0]);\n        state.runMean.push(0, 0);\n        state.m2.push(state.m2[0], state.m2[0]);\n        state.m3.push(state.m3[0], state.m3[0]);\n        state.m4.push(state.m4[0], state.m4[0]);\n        state.allValues.push([], []);\n    }\n    if (state?.pointsInShape && pointLPS) {\n        state.pointsInShape.push(pointLPS);\n    }\n    const newArray = Array.isArray(newValue) ? newValue : [newValue];\n    state.count += 1;\n    if (pointLPS) {\n        state.sumLPS[0] += pointLPS[0];\n        state.sumLPS[1] += pointLPS[1];\n        state.sumLPS[2] += pointLPS[2];\n    }\n    state.max.forEach((it, idx) => {\n        const value = newArray[idx];\n        state.allValues[idx].push(value);\n        const n = state.count;\n        const delta = value - state.runMean[idx];\n        const delta_n = delta / n;\n        const term1 = delta * delta_n * (n - 1);\n        state.sum[idx] += value;\n        state.runMean[idx] += delta_n;\n        state.m4[idx] +=\n            term1 * delta_n * delta_n * (n * n - 3 * n + 3) +\n                6 * delta_n * delta_n * state.m2[idx] -\n                4 * delta_n * state.m3[idx];\n        state.m3[idx] += term1 * delta_n * (n - 2) - 3 * delta_n * state.m2[idx];\n        state.m2[idx] += term1;\n        if (value < state.min[idx]) {\n            state.min[idx] = value;\n            if (idx === 0) {\n                state.minIJK = pointIJK ? [...pointIJK] : null;\n                state.minLPS = pointLPS ? [...pointLPS] : null;\n            }\n        }\n        if (value > state.max[idx]) {\n            state.max[idx] = value;\n            if (idx === 0) {\n                state.maxIJK = pointIJK ? [...pointIJK] : null;\n                state.maxLPS = pointLPS ? [...pointLPS] : null;\n            }\n        }\n    });\n}\nfunction calculateMedian(values) {\n    if (values.length === 0) {\n        return 0;\n    }\n    const sorted = [...values].sort((a, b) => a - b);\n    const mid = Math.floor(sorted.length / 2);\n    if (sorted.length % 2 === 0) {\n        return (sorted[mid - 1] + sorted[mid]) / 2;\n    }\n    else {\n        return sorted[mid];\n    }\n}\nfunction basicGetStatistics(state, unit) {\n    const mean = state.sum.map((sum) => sum / state.count);\n    const stdDev = state.m2.map((squaredDiffSum) => Math.sqrt(squaredDiffSum / state.count));\n    const center = state.sumLPS.map((sum) => sum / state.count);\n    const skewness = state.m3.map((m3, idx) => {\n        const variance = state.m2[idx] / state.count;\n        if (variance === 0) {\n            return 0;\n        }\n        return m3 / (state.count * Math.pow(variance, 1.5));\n    });\n    const kurtosis = state.m4.map((m4, idx) => {\n        const variance = state.m2[idx] / state.count;\n        if (variance === 0) {\n            return 0;\n        }\n        return m4 / (state.count * variance * variance) - 3;\n    });\n    const median = state.allValues.map((values) => calculateMedian(values));\n    const named = {\n        max: {\n            name: 'max',\n            label: 'Max Pixel',\n            value: state.max.length === 1 ? state.max[0] : state.max,\n            unit,\n            pointIJK: state.maxIJK ? [...state.maxIJK] : null,\n            pointLPS: state.maxLPS ? [...state.maxLPS] : null,\n        },\n        min: {\n            name: 'min',\n            label: 'Min Pixel',\n            value: state.min.length === 1 ? state.min[0] : state.min,\n            unit,\n            pointIJK: state.minIJK ? [...state.minIJK] : null,\n            pointLPS: state.minLPS ? [...state.minLPS] : null,\n        },\n        mean: {\n            name: 'mean',\n            label: 'Mean Pixel',\n            value: mean.length === 1 ? mean[0] : mean,\n            unit,\n        },\n        stdDev: {\n            name: 'stdDev',\n            label: 'Standard Deviation',\n            value: stdDev.length === 1 ? stdDev[0] : stdDev,\n            unit,\n        },\n        count: {\n            name: 'count',\n            label: 'Voxel Count',\n            value: state.count,\n            unit: null,\n        },\n        median: {\n            name: 'median',\n            label: 'Median',\n            value: median.length === 1 ? median[0] : median,\n            unit,\n        },\n        skewness: {\n            name: 'skewness',\n            label: 'Skewness',\n            value: skewness.length === 1 ? skewness[0] : skewness,\n            unit: null,\n        },\n        kurtosis: {\n            name: 'kurtosis',\n            label: 'Kurtosis',\n            value: kurtosis.length === 1 ? kurtosis[0] : kurtosis,\n            unit: null,\n        },\n        maxLPS: {\n            name: 'maxLPS',\n            label: 'Max LPS',\n            value: state.maxLPS ? Array.from(state.maxLPS) : null,\n            unit: null,\n        },\n        minLPS: {\n            name: 'minLPS',\n            label: 'Min LPS',\n            value: state.minLPS ? Array.from(state.minLPS) : null,\n            unit: null,\n        },\n        pointsInShape: state.pointsInShape,\n        center: {\n            name: 'center',\n            label: 'Center',\n            value: center ? [...center] : null,\n            unit: null,\n        },\n        array: [],\n    };\n    named.array.push(named.min, named.max, named.mean, named.stdDev, named.median, named.skewness, named.kurtosis, named.count, named.maxLPS, named.minLPS);\n    if (named.center.value) {\n        named.array.push(named.center);\n    }\n    const store = state.pointsInShape !== null;\n    const freshState = createBasicStatsState(store);\n    state.max = freshState.max;\n    state.min = freshState.min;\n    state.sum = freshState.sum;\n    state.count = freshState.count;\n    state.maxIJK = freshState.maxIJK;\n    state.maxLPS = freshState.maxLPS;\n    state.minIJK = freshState.minIJK;\n    state.minLPS = freshState.minLPS;\n    state.runMean = freshState.runMean;\n    state.m2 = freshState.m2;\n    state.m3 = freshState.m3;\n    state.m4 = freshState.m4;\n    state.allValues = freshState.allValues;\n    state.pointsInShape = freshState.pointsInShape;\n    state.sumLPS = freshState.sumLPS;\n    return named;\n}\nexport class BasicStatsCalculator extends Calculator {\n    static { this.state = createBasicStatsState(true); }\n    static statsInit(options) {\n        if (!options.storePointData) {\n            this.state.pointsInShape = null;\n        }\n        this.state = createBasicStatsState(options.storePointData);\n    }\n    static { this.statsCallback = ({ value: newValue, pointLPS = null, pointIJK = null, }) => {\n        basicStatsCallback(this.state, newValue, pointLPS, pointIJK);\n    }; }\n    static { this.getStatistics = (options) => {\n        return basicGetStatistics(this.state, options?.unit);\n    }; }\n}\nexport class InstanceBasicStatsCalculator extends InstanceCalculator {\n    constructor(options) {\n        super(options);\n        this.state = createBasicStatsState(options.storePointData);\n    }\n    statsInit(options) {\n        this.state = createBasicStatsState(options.storePointData);\n    }\n    statsCallback(data) {\n        basicStatsCallback(this.state, data.value, data.pointLPS, data.pointIJK);\n    }\n    getStatistics(options) {\n        return basicGetStatistics(this.state, options?.unit);\n    }\n}\n","export default function getCanvasEllipseCorners(ellipseCanvasPoints) {\n    const [bottom, top, left, right] = ellipseCanvasPoints;\n    const topLeft = [left[0], top[1]];\n    const bottomRight = [right[0], bottom[1]];\n    return [topLeft, bottomRight];\n}\n","import distanceToPointSquared from './distanceToPointSquared';\nexport default function distanceToPoint(lineStart, lineEnd, point) {\n    if (lineStart.length !== 2 || lineEnd.length !== 2 || point.length !== 2) {\n        throw Error('lineStart, lineEnd, and point should have 2 elements of [x, y]');\n    }\n    return Math.sqrt(distanceToPointSquared(lineStart, lineEnd, point));\n}\n","function sign(x) {\n    return typeof x === 'number'\n        ? x\n            ? x < 0\n                ? -1\n                : 1\n            : x === x\n                ? 0\n                : NaN\n        : NaN;\n}\nexport default function intersectLine(line1Start, line1End, line2Start, line2End) {\n    const [x1, y1] = line1Start;\n    const [x2, y2] = line1End;\n    const [x3, y3] = line2Start;\n    const [x4, y4] = line2End;\n    const a1 = y2 - y1;\n    const b1 = x1 - x2;\n    const c1 = x2 * y1 - x1 * y2;\n    const r3 = a1 * x3 + b1 * y3 + c1;\n    const r4 = a1 * x4 + b1 * y4 + c1;\n    if (r3 !== 0 && r4 !== 0 && sign(r3) === sign(r4)) {\n        return;\n    }\n    const a2 = y4 - y3;\n    const b2 = x3 - x4;\n    const c2 = x4 * y3 - x3 * y4;\n    const r1 = a2 * x1 + b2 * y1 + c2;\n    const r2 = a2 * x2 + b2 * y2 + c2;\n    if (r1 !== 0 && r2 !== 0 && sign(r1) === sign(r2)) {\n        return;\n    }\n    const denom = a1 * b2 - a2 * b1;\n    let num;\n    num = b1 * c2 - b2 * c1;\n    const x = num / denom;\n    num = a2 * c1 - a1 * c2;\n    const y = num / denom;\n    const intersectionPoint = [x, y];\n    return intersectionPoint;\n}\n","import * as lineSegment from '../line';\nfunction rectToLineSegments(left, top, width, height) {\n    const topLineStart = [left, top];\n    const topLineEnd = [left + width, top];\n    const rightLineStart = [left + width, top];\n    const rightLineEnd = [left + width, top + height];\n    const bottomLineStart = [left + width, top + height];\n    const bottomLineEnd = [left, top + height];\n    const leftLineStart = [left, top + height];\n    const leftLineEnd = [left, top];\n    const lineSegments = {\n        top: [topLineStart, topLineEnd],\n        right: [rightLineStart, rightLineEnd],\n        bottom: [bottomLineStart, bottomLineEnd],\n        left: [leftLineStart, leftLineEnd],\n    };\n    return lineSegments;\n}\nexport default function distanceToPoint(rect, point) {\n    if (rect.length !== 4 || point.length !== 2) {\n        throw Error('rectangle:[left, top, width, height] or point: [x,y] not defined correctly');\n    }\n    const [left, top, width, height] = rect;\n    let minDistance = 655535;\n    const lineSegments = rectToLineSegments(left, top, width, height);\n    Object.keys(lineSegments).forEach((segment) => {\n        const [lineStart, lineEnd] = lineSegments[segment];\n        const distance = lineSegment.distanceToPoint(lineStart, lineEnd, point);\n        if (distance < minDistance) {\n            minDistance = distance;\n        }\n    });\n    return minDistance;\n}\n","import { interpolatePoints } from './algorithms/bspline';\nfunction getContinuousUniformDistributionValues(minDistributionDistance, closedInterval) {\n    const result = [];\n    const [intervalIni, intervalEnd] = closedInterval;\n    const intervalSize = intervalEnd - intervalIni + 1;\n    const intensity = Math.floor(intervalSize / minDistributionDistance);\n    let x = 0;\n    let continuosDistributionValue = Math.round(((intervalSize - 1) / (intensity - 1)) * x) + intervalIni;\n    while (continuosDistributionValue <= intervalEnd) {\n        result.push(continuosDistributionValue);\n        x++;\n        continuosDistributionValue =\n            Math.round(((intervalSize - 1) / (intensity - 1)) * x) + intervalIni;\n    }\n    return result;\n}\nexport default function interpolateSegmentPoints(points, iniIndex, endIndex, knotsRatioPercentage) {\n    const segmentSize = endIndex - iniIndex + 1;\n    const amountOfKnots = Math.floor((knotsRatioPercentage / 100) * segmentSize) ?? 1;\n    const minKnotDistance = Math.floor(segmentSize / amountOfKnots) ?? 1;\n    if (isNaN(segmentSize) || !segmentSize || !minKnotDistance) {\n        return points;\n    }\n    if (segmentSize / minKnotDistance < 2) {\n        return points;\n    }\n    const interpolationIniIndex = Math.max(0, iniIndex);\n    const interpolationEndIndex = Math.min(points.length - 1, endIndex);\n    const segmentPointsUnchangedBeg = points.slice(0, interpolationIniIndex);\n    const segmentPointsUnchangedEnd = points.slice(interpolationEndIndex + 1, points.length);\n    const knotsIndexes = getContinuousUniformDistributionValues(minKnotDistance, [\n        interpolationIniIndex,\n        interpolationEndIndex,\n    ]);\n    const interpolatedPoints = interpolatePoints(points, knotsIndexes);\n    return [\n        ...segmentPointsUnchangedBeg,\n        ...interpolatedPoints,\n        ...segmentPointsUnchangedEnd,\n    ];\n}\n","import { interpolateBasis as d3InterpolateBasis, quantize as d3Quantize, } from 'd3-interpolate';\nimport { zip as d3Zip } from 'd3-array';\nfunction isPoints3D(points) {\n    return points[0]?.length === 3;\n}\nexport function interpolatePoints(originalPoints, knotsIndexes) {\n    if (!knotsIndexes ||\n        knotsIndexes.length === 0 ||\n        knotsIndexes.length === originalPoints.length) {\n        return originalPoints;\n    }\n    const n = knotsIndexes[knotsIndexes.length - 1] - knotsIndexes[0] + 1;\n    const xInterpolator = d3InterpolateBasis(knotsIndexes.map((k) => originalPoints[k][0]));\n    const yInterpolator = d3InterpolateBasis(knotsIndexes.map((k) => originalPoints[k][1]));\n    if (isPoints3D(originalPoints)) {\n        const zInterpolator = d3InterpolateBasis(knotsIndexes.map((k) => originalPoints[k][2]));\n        return (d3Zip(d3Quantize(xInterpolator, n), d3Quantize(yInterpolator, n), d3Quantize(zInterpolator, n)));\n    }\n    else {\n        return (d3Zip(d3Quantize(xInterpolator, n), d3Quantize(yInterpolator, n)));\n    }\n}\n","import { point } from '../math';\nimport interpolateSegmentPoints from './interpolation/interpolateSegmentPoints';\nexport function shouldSmooth(configuration, annotation) {\n    if (annotation?.autoGenerated) {\n        return false;\n    }\n    const shouldSmooth = configuration?.smoothing?.smoothOnAdd === true ||\n        configuration?.smoothing?.smoothOnEdit === true;\n    return shouldSmooth;\n}\nfunction isEqualByProximity(pointA, pointB) {\n    return point.distanceToPoint(pointA, pointB) < 0.001;\n}\nfunction isEqual(pointA, pointB) {\n    return point.distanceToPoint(pointA, pointB) === 0;\n}\nfunction findMatchIndexes(points, otherPoints) {\n    for (let i = 0; i < points.length; i++) {\n        for (let j = 0; j < otherPoints.length; j++) {\n            if (isEqual(points[i], otherPoints[j])) {\n                return [i, j];\n            }\n        }\n    }\n}\nfunction followingIndex(index, size, direction) {\n    return (index + size + direction) % size;\n}\nfunction circularFindNextIndexBy(listParams, otherListParams, criteria, direction) {\n    const [, indexDelimiter, points] = listParams;\n    const [, otherIndexDelimiter, otherPoints] = otherListParams;\n    const pointsLength = points.length;\n    const otherPointsLength = otherPoints.length;\n    let startIndex = listParams[0];\n    let otherStartIndex = otherListParams[0];\n    if (!points[startIndex] ||\n        !otherPoints[otherStartIndex] ||\n        !points[indexDelimiter] ||\n        !otherPoints[otherIndexDelimiter]) {\n        return [undefined, undefined];\n    }\n    while (startIndex !== indexDelimiter &&\n        otherStartIndex !== otherIndexDelimiter) {\n        if (criteria(otherPoints[otherStartIndex], points[startIndex])) {\n            return [startIndex, otherStartIndex];\n        }\n        startIndex = followingIndex(startIndex, pointsLength, direction);\n        otherStartIndex = followingIndex(otherStartIndex, otherPointsLength, direction);\n    }\n    return [undefined, undefined];\n}\nfunction findChangedSegment(points, previousPoints) {\n    const [firstMatchIndex, previousFirstMatchIndex] = findMatchIndexes(points, previousPoints) || [];\n    const toBeNotEqualCriteria = (pointA, pointB) => isEqualByProximity(pointA, pointB) === false;\n    const [lowDiffIndex, lowOtherDiffIndex] = circularFindNextIndexBy([\n        followingIndex(firstMatchIndex, points.length, 1),\n        firstMatchIndex,\n        points,\n    ], [\n        followingIndex(previousFirstMatchIndex, previousPoints.length, 1),\n        previousFirstMatchIndex,\n        previousPoints,\n    ], toBeNotEqualCriteria, 1);\n    const [highIndex] = circularFindNextIndexBy([followingIndex(lowDiffIndex, points.length, -1), lowDiffIndex, points], [\n        followingIndex(lowOtherDiffIndex, previousPoints.length, -1),\n        lowOtherDiffIndex,\n        previousPoints,\n    ], toBeNotEqualCriteria, -1);\n    return [lowDiffIndex, highIndex];\n}\nexport function getInterpolatedPoints(configuration, points, pointsOfReference) {\n    const { interpolation, smoothing } = configuration;\n    const result = points;\n    if (interpolation) {\n        const { knotsRatioPercentageOnAdd, knotsRatioPercentageOnEdit, smoothOnAdd = false, smoothOnEdit = false, } = smoothing;\n        const knotsRatioPercentage = pointsOfReference\n            ? knotsRatioPercentageOnEdit\n            : knotsRatioPercentageOnAdd;\n        const isEnabled = pointsOfReference ? smoothOnEdit : smoothOnAdd;\n        if (isEnabled) {\n            const [changedIniIndex, changedEndIndex] = pointsOfReference\n                ? findChangedSegment(points, pointsOfReference)\n                : [0, points.length - 1];\n            if (!points[changedIniIndex] || !points[changedEndIndex]) {\n                return points;\n            }\n            return (interpolateSegmentPoints(points, changedIniIndex, changedEndIndex, knotsRatioPercentage));\n        }\n    }\n    return result;\n}\n","import { StackViewport, VolumeViewport, utilities as csUtils, } from '@cornerstonejs/core';\nimport filterAnnotationsWithinSlice from './filterAnnotationsWithinSlice';\nexport default function filterAnnotationsForDisplay(viewport, annotations, filterOptions = {}) {\n    if (viewport instanceof VolumeViewport) {\n        const camera = viewport.getCamera();\n        const { spacingInNormalDirection } = csUtils.getTargetVolumeAndSpacingInNormalDir(viewport, camera);\n        return filterAnnotationsWithinSlice(annotations, camera, spacingInNormalDirection);\n    }\n    if (viewport instanceof StackViewport) {\n        const imageId = viewport.getCurrentImageId();\n        if (!imageId) {\n            return [];\n        }\n        const colonIndex = imageId.indexOf(':');\n        filterOptions.imageURI = imageId.substring(colonIndex + 1);\n    }\n    return annotations.filter((annotation) => {\n        if (!annotation.isVisible) {\n            return false;\n        }\n        if (annotation.data.isCanvasAnnotation) {\n            return true;\n        }\n        return viewport.isReferenceViewable(annotation.metadata, filterOptions);\n    });\n}\n","import { vec3 } from 'gl-matrix';\nimport { CONSTANTS, metaData } from '@cornerstonejs/core';\nconst { EPSILON } = CONSTANTS;\nconst PARALLEL_THRESHOLD = 1 - EPSILON;\nexport function filterAnnotationsWithinSamePlane(annotations, camera) {\n    const { viewPlaneNormal } = camera;\n    const annotationsWithParallelNormals = annotations.filter((td) => {\n        let annotationViewPlaneNormal = td.metadata.viewPlaneNormal;\n        if (!annotationViewPlaneNormal) {\n            const { referencedImageId } = td.metadata;\n            const { imageOrientationPatient } = metaData.get('imagePlaneModule', referencedImageId);\n            const rowCosineVec = vec3.fromValues(imageOrientationPatient[0], imageOrientationPatient[1], imageOrientationPatient[2]);\n            const colCosineVec = vec3.fromValues(imageOrientationPatient[3], imageOrientationPatient[4], imageOrientationPatient[5]);\n            annotationViewPlaneNormal = vec3.create();\n            vec3.cross(annotationViewPlaneNormal, rowCosineVec, colCosineVec);\n            td.metadata.viewPlaneNormal = annotationViewPlaneNormal;\n        }\n        const isParallel = Math.abs(vec3.dot(viewPlaneNormal, annotationViewPlaneNormal)) >\n            PARALLEL_THRESHOLD;\n        return annotationViewPlaneNormal && isParallel;\n    });\n    if (!annotationsWithParallelNormals.length) {\n        return [];\n    }\n    return annotationsWithParallelNormals;\n}\n","import { vec3 } from 'gl-matrix';\nimport { CONSTANTS, metaData } from '@cornerstonejs/core';\nconst { EPSILON } = CONSTANTS;\nconst PARALLEL_THRESHOLD = 1 - EPSILON;\nexport default function filterAnnotationsWithinSlice(annotations, camera, spacingInNormalDirection) {\n    const { viewPlaneNormal } = camera;\n    const annotationsWithParallelNormals = annotations.filter((td) => {\n        let annotationViewPlaneNormal = td.metadata.viewPlaneNormal;\n        if (!annotationViewPlaneNormal) {\n            const { referencedImageId } = td.metadata;\n            const { imageOrientationPatient } = metaData.get('imagePlaneModule', referencedImageId);\n            const rowCosineVec = vec3.fromValues(imageOrientationPatient[0], imageOrientationPatient[1], imageOrientationPatient[2]);\n            const colCosineVec = vec3.fromValues(imageOrientationPatient[3], imageOrientationPatient[4], imageOrientationPatient[5]);\n            annotationViewPlaneNormal = vec3.create();\n            vec3.cross(annotationViewPlaneNormal, rowCosineVec, colCosineVec);\n            td.metadata.viewPlaneNormal = annotationViewPlaneNormal;\n        }\n        const isParallel = Math.abs(vec3.dot(viewPlaneNormal, annotationViewPlaneNormal)) >\n            PARALLEL_THRESHOLD;\n        return annotationViewPlaneNormal && isParallel;\n    });\n    if (!annotationsWithParallelNormals.length) {\n        return [];\n    }\n    const halfSpacingInNormalDirection = spacingInNormalDirection / 2;\n    const { focalPoint } = camera;\n    const annotationsWithinSlice = [];\n    for (const annotation of annotationsWithParallelNormals) {\n        const data = annotation.data;\n        const point = data.handles.points[0] || data.contour?.polyline[0];\n        if (!annotation.isVisible) {\n            continue;\n        }\n        const dir = vec3.create();\n        if (!point) {\n            annotationsWithinSlice.push(annotation);\n            continue;\n        }\n        vec3.sub(dir, focalPoint, point);\n        const dot = vec3.dot(dir, viewPlaneNormal);\n        if (Math.abs(dot) < halfSpacingInNormalDirection) {\n            annotationsWithinSlice.push(annotation);\n        }\n    }\n    return annotationsWithinSlice;\n}\n","import { utilities as csUtils } from '@cornerstonejs/core';\nexport function getPointInLineOfSightWithCriteria(viewport, worldPos, targetVolumeId, criteriaFunction, stepSize = 0.25) {\n    const points = getPointsInLineOfSight(viewport, worldPos, {\n        targetVolumeId,\n        stepSize,\n    });\n    let pickedPoint;\n    for (const point of points) {\n        const intensity = viewport.getIntensityFromWorld(point);\n        const pointToPick = criteriaFunction(intensity, point);\n        if (pointToPick) {\n            pickedPoint = pointToPick;\n        }\n    }\n    return pickedPoint;\n}\nexport function getPointsInLineOfSight(viewport, worldPos, { targetVolumeId, stepSize }) {\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal: normalDirection } = camera;\n    const { spacingInNormalDirection } = csUtils.getTargetVolumeAndSpacingInNormalDir(viewport, camera, targetVolumeId);\n    const step = spacingInNormalDirection * stepSize || 1;\n    const bounds = viewport.getBounds();\n    const points = [];\n    let currentPos = [...worldPos];\n    while (_inBounds(currentPos, bounds)) {\n        points.push([...currentPos]);\n        currentPos[0] += normalDirection[0] * step;\n        currentPos[1] += normalDirection[1] * step;\n        currentPos[2] += normalDirection[2] * step;\n    }\n    currentPos = [...worldPos];\n    while (_inBounds(currentPos, bounds)) {\n        points.push([...currentPos]);\n        currentPos[0] -= normalDirection[0] * step;\n        currentPos[1] -= normalDirection[1] * step;\n        currentPos[2] -= normalDirection[2] * step;\n    }\n    return points;\n}\nconst _inBounds = function (point, bounds) {\n    const [xMin, xMax, yMin, yMax, zMin, zMax] = bounds;\n    const padding = 10;\n    return (point[0] > xMin + padding &&\n        point[0] < xMax - padding &&\n        point[1] > yMin + padding &&\n        point[1] < yMax - padding &&\n        point[2] > zMin + padding &&\n        point[2] < zMax - padding);\n};\n","import { vec3 } from 'gl-matrix';\nexport default function getWorldWidthAndHeightFromCorners(viewPlaneNormal, viewUp, topLeftWorld, bottomRightWorld) {\n    const viewRight = vec3.create();\n    vec3.cross(viewRight, viewUp, viewPlaneNormal);\n    const pos1 = vec3.fromValues(...topLeftWorld);\n    const pos2 = vec3.fromValues(...bottomRightWorld);\n    const diagonal = vec3.create();\n    vec3.subtract(diagonal, pos1, pos2);\n    const diagonalLength = vec3.length(diagonal);\n    if (diagonalLength < 0.0001) {\n        return { worldWidth: 0, worldHeight: 0 };\n    }\n    const cosTheta = vec3.dot(diagonal, viewRight) / (diagonalLength * vec3.length(viewRight));\n    const sinTheta = Math.sqrt(1 - cosTheta * cosTheta);\n    const worldWidth = sinTheta * diagonalLength;\n    const worldHeight = cosTheta * diagonalLength;\n    return { worldWidth, worldHeight };\n}\n","import { vec3 } from 'gl-matrix';\nexport default function getWorldWidthAndHeightFromTwoPoints(viewPlaneNormal, viewUp, worldPos1, worldPos2) {\n    const viewRight = vec3.create();\n    vec3.cross(viewRight, viewUp, viewPlaneNormal);\n    const pos1 = vec3.fromValues(...worldPos1);\n    const pos2 = vec3.fromValues(...worldPos2);\n    const diagonal = vec3.create();\n    vec3.subtract(diagonal, pos1, pos2);\n    const diagonalLength = vec3.length(diagonal);\n    if (diagonalLength < 0.0001) {\n        return { worldWidth: 0, worldHeight: 0 };\n    }\n    const cosTheta = vec3.dot(diagonal, viewRight) / (diagonalLength * vec3.length(viewRight));\n    const sinTheta = Math.sqrt(1 - cosTheta * cosTheta);\n    const worldWidth = sinTheta * diagonalLength;\n    const worldHeight = cosTheta * diagonalLength;\n    return { worldWidth, worldHeight };\n}\n","import { vec3 } from 'gl-matrix';\nexport const isPlaneIntersectingAABB = (origin, normal, minX, minY, minZ, maxX, maxY, maxZ) => {\n    const vertices = [\n        vec3.fromValues(minX, minY, minZ),\n        vec3.fromValues(maxX, minY, minZ),\n        vec3.fromValues(minX, maxY, minZ),\n        vec3.fromValues(maxX, maxY, minZ),\n        vec3.fromValues(minX, minY, maxZ),\n        vec3.fromValues(maxX, minY, maxZ),\n        vec3.fromValues(minX, maxY, maxZ),\n        vec3.fromValues(maxX, maxY, maxZ),\n    ];\n    const normalVec = vec3.fromValues(normal[0], normal[1], normal[2]);\n    const originVec = vec3.fromValues(origin[0], origin[1], origin[2]);\n    const planeDistance = -vec3.dot(normalVec, originVec);\n    let initialSign = null;\n    for (const vertex of vertices) {\n        const distance = vec3.dot(normalVec, vertex) + planeDistance;\n        if (initialSign === null) {\n            initialSign = Math.sign(distance);\n        }\n        else if (Math.sign(distance) !== initialSign) {\n            return true;\n        }\n    }\n    return false;\n};\n","import { triggerEvent } from '@cornerstonejs/core';\nimport * as annotationStateManagement from '../../../stateManagement/annotation';\nimport interpolate from '../../contours/interpolation/interpolate';\nimport getInterpolationData from '../../contours/interpolation/getInterpolationData';\nimport EventTypes from '../../../enums/Events';\nexport default function deleteRelatedAnnotations(viewportData) {\n    const { annotation } = viewportData;\n    const interpolationAnnotations = getInterpolationData(viewportData, [\n        { key: 'interpolationUID', value: viewportData.interpolationUID },\n    ]);\n    const referencedSliceIndex = annotation.metadata.sliceIndex;\n    let minInterpolation = -1;\n    let maxInterpolation = viewportData.sliceData.numberOfSlices;\n    for (const [sliceIndex, annotations] of interpolationAnnotations.entries()) {\n        if (sliceIndex === referencedSliceIndex) {\n            continue;\n        }\n        const nonInterpolated = annotations.find((annotation) => !annotation.autoGenerated);\n        if (!nonInterpolated) {\n            continue;\n        }\n        if (sliceIndex < referencedSliceIndex) {\n            minInterpolation = Math.max(sliceIndex, minInterpolation);\n        }\n        else {\n            maxInterpolation = Math.min(sliceIndex, maxInterpolation);\n        }\n    }\n    const removedAnnotations = [];\n    for (const [sliceIndex, annotations] of interpolationAnnotations.entries()) {\n        if (sliceIndex <= minInterpolation ||\n            sliceIndex >= maxInterpolation ||\n            sliceIndex === referencedSliceIndex) {\n            continue;\n        }\n        annotations.forEach((annotationToDelete) => {\n            if (annotationToDelete.autoGenerated) {\n                annotationStateManagement.state.removeAnnotation(annotationToDelete.annotationUID);\n                removedAnnotations.push(annotationToDelete);\n            }\n        });\n    }\n    if (removedAnnotations.length) {\n        const eventDetails = {\n            annotations: removedAnnotations,\n            element: viewportData.viewport.element,\n            viewportId: viewportData.viewport.id,\n            renderingEngineId: viewportData.viewport.getRenderingEngine().id,\n        };\n        triggerEvent(viewportData.viewport.element, EventTypes.INTERPOLATED_ANNOTATIONS_REMOVED, eventDetails);\n    }\n    if (minInterpolation >= 0 &&\n        maxInterpolation < viewportData.sliceData.numberOfSlices) {\n        const nextAnnotation = interpolationAnnotations.get(maxInterpolation)[0];\n        const viewportNewData = {\n            viewport: viewportData.viewport,\n            sliceData: {\n                numberOfSlices: viewportData.sliceData.numberOfSlices,\n                imageIndex: nextAnnotation.metadata.sliceIndex,\n            },\n            annotation: nextAnnotation,\n            interpolationUID: nextAnnotation.interpolationUID,\n        };\n        interpolate(viewportNewData);\n    }\n}\n","import { eventTarget } from '@cornerstonejs/core';\nimport { Events } from '../../enums';\nimport addRepresentationData from '../../stateManagement/segmentation/internalAddRepresentationData';\nimport { triggerSegmentationModified } from '../../stateManagement/segmentation/triggerSegmentationEvents';\nimport debounce from '../debounce';\nconst computedRepresentations = new Map();\nasync function computeAndAddRepresentation(segmentationId, type, computeFunction, updateFunction, onComputationComplete) {\n    const data = await computeFunction();\n    addRepresentationData({\n        segmentationId,\n        type,\n        data,\n    });\n    onComputationComplete?.();\n    if (!computedRepresentations.has(segmentationId)) {\n        computedRepresentations.set(segmentationId, []);\n    }\n    const representations = computedRepresentations.get(segmentationId);\n    if (!representations.includes(type)) {\n        representations.push(type);\n    }\n    subscribeToSegmentationChanges(updateFunction);\n    triggerSegmentationModified(segmentationId);\n    return data;\n}\nfunction subscribeToSegmentationChanges(updateFunction) {\n    const debouncedUpdateFunction = (event) => {\n        _debouncedSegmentationModified(event, updateFunction);\n    };\n    updateFunction._debouncedUpdateFunction = debouncedUpdateFunction;\n    eventTarget.removeEventListener(Events.SEGMENTATION_DATA_MODIFIED, updateFunction._debouncedUpdateFunction);\n    eventTarget.addEventListener(Events.SEGMENTATION_DATA_MODIFIED, updateFunction._debouncedUpdateFunction);\n}\nconst _debouncedSegmentationModified = debounce((event, updateFunction) => {\n    const segmentationId = event.detail.segmentationId;\n    const representations = computedRepresentations.get(segmentationId);\n    if (!representations || !representations.length) {\n        return;\n    }\n    updateFunction(segmentationId);\n    if (representations.length) {\n        triggerSegmentationModified(segmentationId);\n    }\n}, 300);\nexport { computeAndAddRepresentation };\n","import { SegmentationRepresentations } from '../../enums';\nimport { getSegmentIndexColor } from '../../stateManagement/segmentation/config/segmentationColor';\nimport { getActiveSegmentation } from '../../stateManagement/segmentation/getActiveSegmentation';\nimport { getActiveSegmentIndex } from '../../stateManagement/segmentation/getActiveSegmentIndex';\nimport { getSegmentationRepresentationVisibility } from '../../stateManagement/segmentation/getSegmentationRepresentationVisibility';\nimport { internalGetHiddenSegmentIndices } from '../../stateManagement/segmentation/helpers/internalGetHiddenSegmentIndices';\nimport { segmentationStyle } from '../../stateManagement/segmentation/SegmentationStyle';\nexport function getSVGStyleForSegment({ segmentationId, segmentIndex, viewportId, autoGenerated = false, }) {\n    const segmentColor = getSegmentIndexColor(viewportId, segmentationId, segmentIndex);\n    const segmentationVisible = getSegmentationRepresentationVisibility(viewportId, {\n        segmentationId,\n        type: SegmentationRepresentations.Contour,\n    });\n    const activeSegmentation = getActiveSegmentation(viewportId);\n    const isActive = activeSegmentation?.segmentationId === segmentationId;\n    const style = segmentationStyle.getStyle({\n        viewportId,\n        segmentationId,\n        type: SegmentationRepresentations.Contour,\n        segmentIndex,\n    });\n    const mergedConfig = style;\n    let lineWidth = 1;\n    let lineDash = undefined;\n    let lineOpacity = 1;\n    let fillOpacity = 0;\n    if (autoGenerated) {\n        lineWidth = mergedConfig.outlineWidthAutoGenerated ?? lineWidth;\n        lineDash = mergedConfig.outlineDashAutoGenerated ?? lineDash;\n        lineOpacity = mergedConfig.outlineOpacity ?? lineOpacity;\n        fillOpacity = mergedConfig.fillAlphaAutoGenerated ?? fillOpacity;\n    }\n    else if (isActive) {\n        lineWidth = mergedConfig.outlineWidth ?? lineWidth;\n        lineDash = mergedConfig.outlineDash ?? lineDash;\n        lineOpacity = mergedConfig.outlineOpacity ?? lineOpacity;\n        fillOpacity = mergedConfig.fillAlpha ?? fillOpacity;\n    }\n    else {\n        lineWidth = mergedConfig.outlineWidthInactive ?? lineWidth;\n        lineDash = mergedConfig.outlineDashInactive ?? lineDash;\n        lineOpacity = mergedConfig.outlineOpacityInactive ?? lineOpacity;\n        fillOpacity = mergedConfig.fillAlphaInactive ?? fillOpacity;\n    }\n    if (getActiveSegmentIndex(segmentationId) === segmentIndex) {\n        lineWidth += mergedConfig.activeSegmentOutlineWidthDelta;\n    }\n    lineWidth = mergedConfig.renderOutline ? lineWidth : 0;\n    fillOpacity = mergedConfig.renderFill ? fillOpacity : 0;\n    const color = `rgba(${segmentColor[0]}, ${segmentColor[1]}, ${segmentColor[2]}, ${lineOpacity})`;\n    const fillColor = `rgb(${segmentColor[0]}, ${segmentColor[1]}, ${segmentColor[2]})`;\n    const hiddenSegments = internalGetHiddenSegmentIndices(viewportId, {\n        segmentationId,\n        type: SegmentationRepresentations.Contour,\n    });\n    const isVisible = !hiddenSegments.has(segmentIndex);\n    return {\n        color,\n        fillColor,\n        lineWidth,\n        fillOpacity,\n        lineDash,\n        textbox: {\n            color,\n        },\n        visibility: segmentationVisible && isVisible,\n    };\n}\n","import { getEnabledElement } from '@cornerstonejs/core';\nimport filterViewportsWithFrameOfReferenceUID from './filterViewportsWithFrameOfReferenceUID';\nimport filterViewportsWithToolEnabled from './filterViewportsWithToolEnabled';\nimport filterViewportsWithParallelNormals from './filterViewportsWithParallelNormals';\nexport default function getViewportIdsWithToolToRender(element, toolName, requireParallelNormals = true) {\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine, FrameOfReferenceUID } = enabledElement;\n    let viewports = renderingEngine.getViewports();\n    viewports = filterViewportsWithFrameOfReferenceUID(viewports, FrameOfReferenceUID);\n    viewports = filterViewportsWithToolEnabled(viewports, toolName);\n    const viewport = renderingEngine.getViewport(enabledElement.viewportId);\n    if (requireParallelNormals) {\n        viewports = filterViewportsWithParallelNormals(viewports, viewport.getCamera());\n    }\n    const viewportIds = viewports.map((vp) => vp.id);\n    return viewportIds;\n}\n"],"names":["annotationUID","drawingElementType","nodeUID","evt","shiftKey","ctrlKey","ShiftCtrl","altKey","ShiftAlt","metaKey","ShiftMeta","Shift","CtrlAlt","CtrlMeta","Ctrl","AltMeta","Alt","Meta","defaultManager","resetAnnotationManager","setAnnotationManager","setPreprocessingFn","annotation","uid","data","cachedStats","checkAndDefineCachedStatsProperty","handles","textBox","checkAndDefineTextBoxProperty","isLocked","checkAndSetAnnotationLocked","isVisible","checkAndSetAnnotationVisibility","triggerSegmentationAdded","segmentationId","eventDetail","triggerEvent","eventTarget","Events","SEGMENTATION_ADDED","triggerSegmentationModified","SEGMENTATION_MODIFIED","triggerSegmentationRemoved","SEGMENTATION_REMOVED","triggerSegmentationRepresentationModified","viewportId","type","SEGMENTATION_REPRESENTATION_MODIFIED","triggerSegmentationRepresentationRemoved","SEGMENTATION_REPRESENTATION_REMOVED","internalGetHiddenSegmentIndices","specifier","representation","Set","Object","entries","segments","reduce","acc","segmentIndex","segment","visible","add","Number","MODES","ToolModes","Active","Passive","Enabled","toolName","toolGroups","filter","toolOptions","toolGroupToolNames","keys","i","length","includes","mode","getSubPixelSpacingAndXYDirections","addCanvasPointsToArray","getArea","polyline","activateClosedContourEdit","viewportIdsToRender","this","isEditingClosed","detail","currentPoints","element","canvasPos","canvas","enabledElement","getEnabledElement","viewport","prevCanvasPoints","contour","map","worldToCanvas","spacing","xDir","yDir","configuration","subPixelResolution","editData","editCanvasPoints","startCrossingIndex","undefined","editIndex","commonData","movingTextBox","isInteractingWithTool","addEventListener","MOUSE_UP","mouseUpClosedContourEditCallback","MOUSE_DRAG","mouseDragClosedContourEditCallback","MOUSE_CLICK","TOUCH_END","TOUCH_DRAG","TOUCH_TAP","hideElementCursor","deactivateClosedContourEdit","removeEventListener","resetElementCursor","worldPos","world","createMemo","lastCanvasPoint","lastWorldPoint","canvasToWorld","worldPosDiff","xDist","Math","abs","yDist","checkAndRemoveCrossesOnEditLine","currentEditIndex","checkForFirstCrossing","snapIndex","findSnapIndex","fusedCanvasPoints","fuseEditPointsWithClosedContour","checkForSecondCrossing","removePointsAfterSecondCrossing","finishEditAndStartNewEdit","renderingEngine","points","closed","targetWindingDirection","Clockwise","autoGenerated","triggerAnnotationModified","lastEditCanvasPoint","pop","augmentedEditCanvasPoints","lowIndex","highIndex","distanceBetweenLowAndFirstPoint","distanceBetweenLowAndLastPoint","distanceBetweenHighAndFirstPoint","distanceBetweenHighAndLastPoint","pointSet1","canvasPoint","push","inPlaceDistance","reverseDistance","pointSet2","completeClosedContourEdit","doneEditMemo","updatedPoints","decimateConfig","decimate","enabled","epsilon","cancelClosedContourEdit","toolInstance","bind","pointsAreWithinCloseContourProximity","getFirstLineSegmentIntersectionIndexes","activateDraw","isDrawing","contourHoleProcessingEnabled","event","contourHoleAdditionModifierKey","drawData","canvasPoints","polylineIndex","newAnnotation","mouseUpDrawCallback","mouseDragDrawCallback","deactivateDraw","deltaPoints","worldPosDelta","worldPosition","hasMoved","crossingIndex","findCrossingIndexDuringCreate","applyCreateOnCross","numPointsAdded","invalidated","ChangeTypes","HandlesUpdated","allowOpenContours","firstPoint","lastPoint","closeContourProximity","completeDrawOpenContour","completeDrawClosedContour","options","removeCrossedLinesOnCompleteDraw","minPointsToSave","haltDrawing","updateContourPolyline","triggerContourAnnotationCompleted","numPoints","endToStart","canvasPointsMinusEnds","slice","lineSegment","indexToRemoveUpTo","splice","worldPoints","isOpenUShapeContour","openUShapeContourVectorToPeak","lastPoints","pointsLessLastOne","remainingPoints","newArea","utilities","cancelDrawing","minPoints","max","shouldHaltDrawing","removeAnnotation","isClosedContour","crossedLineSegment","removePointsUpUntilFirstCrossing","checkCanvasEditFallbackProximity","firstEditCanvasPoint","distanceIndexPairs","prevCanvasPoint","distance","index","sort","a","b","twoClosestDistanceIndexPairs","lowestIndex","min","dir","proximity","extendedPoint","crossedLineSegmentFromExtendedPoint","pointsToPrepend","unshift","numPointsToRemove","firstLine","lastLine","didCrossLine","editCanvasPointsLessLastOne","snapCanvasPosition","editIndexCrossed","findOpenUShapedContourVectorToPeak","first","last","firstToLastUnitVector","normalVector1","normalVector2","centerOfFirstToLast","furthest","dist","findOpenUShapedContourVectorToPeakOnRender","activateOpenContourEdit","isEditingOpen","mouseUpOpenContourEditCallback","mouseDragOpenContourEditCallback","deactivateOpenContourEdit","fuseEditPointsWithOpenContour","finishEditOpenOnSecondCrossing","checkIfShouldOverwriteAnEnd","openContourEditOverwriteEnd","fuseEditPointsForOpenContourEndEdit","activeHandleIndex","activateOpenContourEndEdit","lastCanvasPos","p1","p2","p3","aDotb","magA","sqrt","magB","acos","PI","newCanvasPoints","pointsToRender","completeOpenContourEdit","cancelOpenContourEdit","handle","reverse","_getRenderingOptions","styleSpecifier","toolGroupId","getToolName","id","lineWidth","lineDash","color","fillColor","fillOpacity","getAnnotationStyle","width","closePath","renderContour","svgDrawingHelper","getImageData","renderClosedContour","calculateUShapeContourVectorToPeakIfNotPresent","renderOpenUShapedContour","renderOpenContour","parentAnnotationUID","allContours","drawPath","drawPolyline","alwaysRenderOpenContourHandles","radius","handleGroupUID","handlePoints","shift","drawHandles","handleRadius","handlePoint","firstCanvasPoint","openUShapeContourVectorToPeakCanvas","renderContourBeingDrawn","renderClosedContourBeingEdited","renderOpenContourBeingEdited","renderPointContourWithMarker","canvasPolyline","childContours","center","circlePoints","angle","x","cos","y","sin","crosshair","polylineUID","DefaultHistoryMemo","PointsManager","AnnotationTool","A","createAnnotation","annotationBaseData","highlighted","metadata","text","Array","worldBoundingBox","topLeft","topRight","bottomLeft","bottomRight","label","baseData","createAnnotationForViewport","getViewReference","createAndAddAnnotation","addAnnotation","constructor","toolProps","defaultToolProps","super","mouseMoveCallback","filteredAnnotations","canvasCoords","annotationsNeedToBeRedrawn","isAnnotationLocked","isAnnotationVisible","activateHandleIndex","near","_imagePointNearToolOrHandle","nearToolAndNotMarkedActive","notNearToolAndMarkedActive","isSuvScaled","getTextLines","statsCalculator","getHandleNearImagePoint","isCanvasAnnotation","canvasBoundingBox","point","annotationCanvasCoordinate","getLinkedTextBoxStyle","specifications","visibility","getStyle","fontFamily","fontSize","shadow","background","targetId","imageId","BaseVolumeViewport","volumeId","volume","cache","getVolume","scaling","PT","scalingModule","metaData","suvbw","context","property","locked","markerSize","lineOpacity","textbox","isPointNearTool","createAnnotationState","deleting","cloneData","spline","state","structuredClone","pointsManager","create3","createAnnotationMemo","annotationMemo","restoreMemo","newState","setViewReference","assign","annotationData","segmentation","addContourSegmentationAnnotation","setAnnotationSelected","render","currentAnnotation","getAnnotation","History","console","warn","operationType","memo","hydrateBase","ToolClass","FrameOfReferenceUID","getFrameOfReferenceUID","camera","getCamera","viewPlaneNormal","viewplaneNormal","viewUp","instance","referencedImageId","finalViewPlaneNormal","finalViewUp","StackViewport","closestImageIndex","getImageIds","Error","getReferencedImageId","ContourBaseTool","renderAnnotation","renderStatus","getRenderingEngine","annotations","getAnnotations","filterInteractableAnnotationsForElement","getTargetId","annotationStyle","annotationRendered","renderAnnotationInstance","interpolationUID","cancelAnnotation","moveAnnotation","getChildAnnotations","forEach","childAnnotation","polylineData","transforms","updateWindingDirection","getPolylinePoints","renderContext","polylineCanvasPoints","getContourHolesDataCanvas","ContourSegmentationBaseTool","PreviewSegmentIndex","interpolation","InterpolationManager","addTool","isContourSegmentationTool","contourAnnotation","activeSeg","getActiveSegmentation","representationData","Contour","getActiveSegmentIndex","contourSegAnnotation","removeContourSegmentationAnnotation","contourSegmentationStyle","_getContourSegmentationStyle","renderResult","triggerSegmentationDataModified","toolGroupIds","getViewportIdsWithSegmentation","getToolGroupForViewport","triggerAnnotationRenderForToolGroupIds","segmentationRepresentations","getSegmentationRepresentation","segmentationRepresentation","find","rep","SegmentationRepresentations","annotationLocked","getLockedSegmentIndices","getSVGStyleForSegment","defaultContourConfig","renderOutline","outlineWidthAutoGenerated","outlineWidth","outlineWidthInactive","outlineOpacity","outlineOpacityInactive","outlineDash","outlineDashInactive","outlineDashAutoGenerated","activeSegmentOutlineWidthDelta","renderFill","fillAlpha","fillAlphaInactive","fillAlphaAutoGenerated","handleContourSegmentation","geometryIds","annotationUIDsMap","contourRepresentation","size","segmentSpecificMap","Map","geometryId","geometry","getGeometry","Enums","CONTOUR","validateGeometry","segmentSpecificConfig","contourSet","contours","contourSegmentationAnnotation","annotationGroupSelector","set","resetCamera","addContourSetsToElement","removeFromCache","annotationSet","internalCache","load","cfun","ofun","actor","getProperty","setRGBTransferFunction","setScalarOpacity","uuidv4","async","labelMapData","config","getSegmentation","Labelmap","_ensureVolumeHasVolumeId","stackData","imageIds","volumeLoader","_handleMissingVolume","blendMode","MAXIMUM_INTENSITY_BLEND","useIndependentComponents","LABELMAP_EDGE_PROJECTION_BLEND","referenceVolumeId","getVolumeId","baseVolume","segDims","dimensions","refDims","debug","volumeInputs","representationUID","result","defaultActor","getDefaultActor","callback","get","added","volumeInputArray","firstImageVolume","segImageVolume","segData","voxelManager","getCompleteScalarDataArray","imageData","segImageData","cubeData","Float32Array","getScalarDataLength","dims","getDimensions","z","iTuple","removeActors","oldMapper","getMapper","mapper","convertMapperToNotSharedMapper","setMapper","setBlendMode","arrayAgain","getInputData","getPointData","getArray","onSegmentationDataModified","segVolumeId","segVoxelManager","array","getData","slices","from","_","getAtIndex","setData","modified","setNumberOfComponents","setColorMixPreset","setForceNearestInterpolation","setIndependentComponents","addActor","referencedId","segmentationRepresentationUID","originalBlendMode","getBlendMode","preLoad","addEventListenerDebounced","SEGMENTATION_DATA_MODIFIED","actorEntry","getActor","createVolumeActor","volumeActor","addVolumesAsIndependentComponents","addVolumesToViewports","stackInputs","addImageSlicesToViewports","defaultLabelmapConfig","renderOutlineInactive","renderFillInactive","surface","surfaceActorEntry","surfaceActor","setVisibility","surfaceMapper","currentPolyData","newPoints","newPolys","polys","getPoints","currentPolys","getPolys","polyData","triangles","values","setPolys","setInputData","getRenderer","resetCameraClippingRange","surfacePolyData","setColor","setLineWidth","clippingFilter","filteredSurfaceActors","getActors","startsWith","BrushStrategy","COMPOSITIONS","childFunctions","StrategyCallbacks","OnInteractionStart","addListMethod","Initialize","OnInteractionEnd","Fill","CreateIsInThreshold","addSingletonMethod","Interpolate","AcceptPreview","RejectPreview","INTERNAL_setValue","Preview","ComputeInnerCircleRadius","EnsureSegmentationVolumeFor3DManipulation","EnsureImageVolumeFor3DManipulation","AddPreview","GetStatistics","compositions","name","initializers","_initialize","_fill","_onInteractionStart","fill","operationData","initializedData","initialize","func","segmentationVoxelManager","getArrayOfModifiedSlices","onInteractionStart","call","addPreview","configurationName","initializer","key","strategyFunction","operationName","strategy","imageVoxelManager","segmentationImageData","centerWorld","isInObject","isInObjectBoundsIJK","brushStrategy","createInitialized","listName","args","returnValue","value","isInitialized","previewSegmentIndex","centerIJK","useCenterSegmentIndex","hasSegmentIndex","hasPreviewIndex","nestedBounds","getBoundsIJK","boundsIJK","centerSegmentIndexInfo","existingValue","getAtIJKPoint","threshold","isDynamic","range","oldThreshold","dynamicRadius","useDelta","ijk","idx","Infinity","useDeltaSqr","pointIJK","gray","isArray","dynamicRadiusInCanvas","centerCanvas","clientWidth","clientHeight","radiusInWorld","offSetCenterInWorld","coord","offSetCenterCanvas","activeStrategy","islandRemoval","floodFillSegmentIsland","removeExternalIslands","removeInternalIslands","arrayOfSlices","preview","onInteractionEnd","previewColor","viewportIds","setSegmentIndexColor","changedIndices","labelmapMemo","oldValue","setAtIndex","undoIf","hasPreviewSegmentIndex","segmentsLocked","isWithinThreshold","createIsInThreshold","setValue","addPoint","useSegmentIndex","previewOnHover","centerSegmentIndex","handleUseSegmentCenterIndex","voxelValue","indices","getStatistics","segmentIndices","determineSegmentIndex","dynamicThreshold","erase","regionFill","labelmapStatistics","ensureSegmentationVolumeFor3DManipulation","ensureImageVolumeFor3DManipulation","eraseInsideCircle","eraseInsideSphere","transformWorldToIndex","sphereComposition","newBoundsIJK","topLeftWorld","bottomRightWorld","SPHERE_STRATEGY","fillInsideSphere","SPHERE_THRESHOLD_STRATEGY","SPHERE_THRESHOLD_STRATEGY_ISLAND","thresholdInsideSphere","thresholdInsideSphereIsland","getStrategyData","referencedVolumeId","CustomEvent","ERROR_EVENT","message","cancelable","dispatchEvent","segmentationVolume","imageVolume","segmentationScalarData","imageScalarData","getStrategyDataForVolumeViewport","labelmapImageId","getCurrentLabelmapImageIdForViewport","currentSegImage","getImage","currentSegmentationImageId","segmentationImage","getPixelData","currentImageId","getCurrentImageId","image","getScalarData","getStrategyDataForStackViewport","RectangleROIStartEndThreshold","getContourSequence","toolData","metadataProvider","projectionPoints","projectionPointsImageIds","ContourData","orderedPoints","pointsArrayWithPrecision","flat","toFixed","ContourImageSequence","sopCommon","ReferencedSOPClassUID","sopClassUID","ReferencedSOPInstanceUID","sopInstanceUID","getContourImageSequence","NumberOfContourPoints","ContourGeometricType","DEFAULT_CONTOUR_SEG_TOOLNAME","getInterpolationData","viewportData","filterParams","sliceData","interpolationDatas","originalToolName","testToolName","modifiedAnnotations","numberOfSlices","imageAnnotations","sliceIndex","filteredInterpolatedAnnotations","imageAnnotation","every","parent","parentKey","item","getInterpolationDataCollection","interpolatedDataCollection","createPolylineToolData","referencedToolData","childAnnotationUIDs","interpolationSources","sources","_sliceNeedsInterpolating","interpolationData","_appendInterpolationList","contourPair","interpolationList","itemIndex","startIndex","pair","list","_getBoundingPair","sliceRange","annotationPair","canInterpolate","rangeToInterpolate","found","getRangeToInterpolate","sliceEdited","j","_getSlicePositionOfToolData","selectHandles","handleCount","destPoints","sourcePoints","subselect","interval","floor","dotValues","prevVec3","nextVec3","getPoint","prevPoint","nextPoint","dot","createDotValues","minimumRegions","deviation","sum","sumSq","mean","valueDiff","getStats","inflection","minValue","minIndex","findMinimumRegions","lastHandle","thirdInterval","region","start","end","midIndex","ceil","addInterval","firstHandle","indexValue","getPointArray","source","destSourceIndex","finish","count","v","round","dP","_linearlyInterpolateBetween","eventData","annotation0","annotation1","c1","_generateClosedContour","c2","c1Interp","c2Interp","cumPerim1","_getCumulativePerimeter","cumPerim2","interpNodes","cumPerim1Norm","_normalisedCumulativePerimeter","cumPerim2Norm","numNodes1","numNodes2","perim1Interp","_getInterpolatedPerim","perim2Interp","perim1Ind","_getIndicatorArray","perim2Ind","nodesPerSegment1","_getNodesPerSegment","nodesPerSegment2","c1i","_getSuperSampledContour","c2i","c1iLength","optimal","startingNode","totalSquaredXYLengths","node","iteration","_shiftCircularArray","I","_shiftSuperSampledContourInPlace","_reduceContoursToOriginNodes","_generateInterpolationContourPair","kIndex","c1HasMoreNodes","endIndex","zInterp","interpolated3DPoints","c1ir","c2ir","fromXYZ","cInterp","vecSubtract","vecResult","c1Source","c2Source","c1point","c2point","_generateInterpolatedOpenContour","nearestAnnotation","has","oldAnnotationData","_findExistingAnnotation","interpolatedAnnotation","_editInterpolatedContour","viewRef","onInterpolationComplete","parentAnnotation","_addInterpolatedContour","_linearlyInterpolateContour","arr","slicedArray","c","nodesPerSegment","ci","n","xSpacing","ySpacing","zSpacing","perimInterp","perimInd","perimIndSorted","indicesOfOriginNodes","elementValue","numFalse","numTrue","numNodes","cumPerimNorm","diff","linspace","concat","cumPerim","cumulativePerimeter","lengthOfSegment","isInterpolationUpdate","queueMicrotask","indexOf","updateChildInterpolationUID","toolType","renderingEngineId","eventDetails","ANNOTATION_INTERPOLATION_PROCESS_COMPLETED","startInterpolation","createBasicStatsState","storePointData","maxIJK","maxLPS","minIJK","minLPS","runMean","m2","m3","m4","allValues","pointsInShape","sumLPS","basicStatsCallback","newValue","pointLPS","newArray","it","delta","delta_n","term1","basicGetStatistics","unit","stdDev","squaredDiffSum","skewness","variance","pow","kurtosis","median","sorted","mid","calculateMedian","named","freshState","BasicStatsCalculator","statsInit","statsCallback","InstanceBasicStatsCalculator","getCanvasEllipseCorners","ellipseCanvasPoints","bottom","top","left","right","distanceToPoint","lineStart","lineEnd","sign","NaN","intersectLine","line1Start","line1End","line2Start","line2End","x1","y1","x2","y2","x3","y3","x4","y4","a1","b1","r3","r4","a2","b2","r1","r2","denom","num","rect","height","minDistance","lineSegments","rectToLineSegments","interpolateSegmentPoints","iniIndex","knotsRatioPercentage","segmentSize","amountOfKnots","minKnotDistance","isNaN","interpolationIniIndex","interpolationEndIndex","segmentPointsUnchangedBeg","segmentPointsUnchangedEnd","interpolatedPoints","originalPoints","knotsIndexes","xInterpolator","k","yInterpolator","zInterpolator","interpolatePoints","minDistributionDistance","closedInterval","intervalIni","intervalEnd","intervalSize","intensity","continuosDistributionValue","getContinuousUniformDistributionValues","shouldSmooth","smoothing","smoothOnAdd","smoothOnEdit","followingIndex","direction","circularFindNextIndexBy","listParams","otherListParams","criteria","indexDelimiter","otherIndexDelimiter","otherPoints","pointsLength","otherPointsLength","otherStartIndex","findChangedSegment","previousPoints","firstMatchIndex","previousFirstMatchIndex","pointA","pointB","findMatchIndexes","toBeNotEqualCriteria","isEqualByProximity","lowDiffIndex","lowOtherDiffIndex","getInterpolatedPoints","pointsOfReference","knotsRatioPercentageOnAdd","knotsRatioPercentageOnEdit","changedIniIndex","changedEndIndex","filterAnnotationsForDisplay","filterOptions","VolumeViewport","spacingInNormalDirection","colonIndex","imageURI","substring","isReferenceViewable","EPSILON","CONSTANTS","PARALLEL_THRESHOLD","filterAnnotationsWithinSamePlane","annotationsWithParallelNormals","td","annotationViewPlaneNormal","imageOrientationPatient","rowCosineVec","colCosineVec","isParallel","filterAnnotationsWithinSlice","halfSpacingInNormalDirection","focalPoint","annotationsWithinSlice","getPointInLineOfSightWithCriteria","targetVolumeId","criteriaFunction","stepSize","getPointsInLineOfSight","pickedPoint","pointToPick","getIntensityFromWorld","normalDirection","step","bounds","getBounds","currentPos","_inBounds","xMin","xMax","yMin","yMax","zMin","zMax","padding","getWorldWidthAndHeightFromCorners","viewRight","pos1","pos2","diagonal","diagonalLength","worldWidth","worldHeight","cosTheta","getWorldWidthAndHeightFromTwoPoints","worldPos1","worldPos2","isPlaneIntersectingAABB","origin","normal","minX","minY","minZ","maxX","maxY","maxZ","vertices","normalVec","originVec","planeDistance","initialSign","vertex","deleteRelatedAnnotations","interpolationAnnotations","referencedSliceIndex","minInterpolation","maxInterpolation","nonInterpolated","removedAnnotations","annotationToDelete","INTERPOLATED_ANNOTATIONS_REMOVED","nextAnnotation","viewportNewData","imageIndex","computedRepresentations","computeAndAddRepresentation","computeFunction","updateFunction","onComputationComplete","representations","debouncedUpdateFunction","_debouncedSegmentationModified","_debouncedUpdateFunction","subscribeToSegmentationChanges","segmentColor","getSegmentIndexColor","segmentationVisible","activeSegmentation","isActive","mergedConfig","getViewportIdsWithToolToRender","requireParallelNormals","viewports","getViewports","getViewport","vp"],"sourceRoot":""}