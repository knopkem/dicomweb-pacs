{"version":3,"file":"487.bundle.2fcb24e65a7e4254e63a.js","mappings":"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","sources":["webpack:///../../../extensions/cornerstone-dynamic-volume/src/id.js","webpack:///../../../extensions/cornerstone-dynamic-volume/src/actions/updateSegmentationsChartDisplaySet.ts","webpack:///../../../extensions/cornerstone-dynamic-volume/src/commandsModule.ts","webpack:///../../../extensions/cornerstone-dynamic-volume/src/panels/DynamicVolumeControls.tsx","webpack:///../../../extensions/cornerstone-dynamic-volume/src/panels/PanelGenerateImage.tsx","webpack:///../../../extensions/cornerstone-dynamic-volume/src/panels/DynamicDataPanel.tsx","webpack:///../../../extensions/cornerstone-dynamic-volume/src/panels/DynamicExport.tsx","webpack:///../../../extensions/cornerstone-dynamic-volume/src/getPanelModule.tsx","webpack:///../../../extensions/cornerstone-dynamic-volume/src/getHangingProtocolModule.ts","webpack:///../../../extensions/cornerstone-dynamic-volume/src/index.ts"],"sourcesContent":["import packageJson from '../package.json';\n\nconst id = packageJson.name;\nconst SOPClassHandlerName = 'dynamic-volume';\n\nexport { id, SOPClassHandlerName };\n","import { DicomMetadataStore, utils } from '@ohif/core';\n\nimport * as cs from '@cornerstonejs/core';\nimport * as csTools from '@cornerstonejs/tools';\n\nconst CHART_MODALITY = 'CHT';\nconst SEG_CHART_INSTANCE_UID = utils.guid();\n\n// Private SOPClassUid for chart data\nconst ChartDataSOPClassUid = '1.9.451.13215.7.3.2.7.6.1';\n\nconst { utilities: csToolsUtils } = csTools;\n\nfunction _getDateTimeStr() {\n  const now = new Date();\n  const date =\n    now.getFullYear() + ('0' + now.getUTCMonth()).slice(-2) + ('0' + now.getUTCDate()).slice(-2);\n  const time =\n    ('0' + now.getUTCHours()).slice(-2) +\n    ('0' + now.getUTCMinutes()).slice(-2) +\n    ('0' + now.getUTCSeconds()).slice(-2);\n\n  return { date, time };\n}\n\nfunction _getTimePointsDataByTagName(volume, timePointsTag) {\n  const uniqueTimePoints = volume.imageIds.reduce((timePoints, imageId) => {\n    const instance = DicomMetadataStore.getInstanceByImageId(imageId);\n    const timePointValue = instance[timePointsTag];\n\n    if (timePointValue !== undefined) {\n      timePoints.add(timePointValue);\n    }\n\n    return timePoints;\n  }, new Set());\n\n  return Array.from(uniqueTimePoints).sort((a: number, b: number) => a - b);\n}\n\nfunction _convertTimePointsUnit(timePoints, timePointsUnit) {\n  const validUnits = ['ms', 's', 'm', 'h'];\n  const divisors = [1000, 60, 60];\n  const currentUnitIndex = validUnits.indexOf(timePointsUnit);\n  let divisor = 1;\n\n  if (currentUnitIndex !== -1) {\n    for (let i = currentUnitIndex; i < validUnits.length - 1; i++) {\n      const newDivisor = divisor * divisors[i];\n      const greaterThanDivisorCount = timePoints.filter(timePoint => timePoint > newDivisor).length;\n\n      // Change the scale only if more than 50% of the time points are\n      // greater than the new divisor.\n      if (greaterThanDivisorCount <= timePoints.length / 2) {\n        break;\n      }\n\n      divisor = newDivisor;\n      timePointsUnit = validUnits[i + 1];\n    }\n\n    if (divisor > 1) {\n      timePoints = timePoints.map(timePoint => timePoint / divisor);\n    }\n  }\n\n  return { timePoints, timePointsUnit };\n}\n\n// It currently supports only one tag but a few other will be added soon\n// Supported 4D Tags\n//   (0018,1060) Trigger Time                   [NOK]\n//   (0018,0081) Echo Time                      [NOK]\n//   (0018,0086) Echo Number                    [NOK]\n//   (0020,0100) Temporal Position Identifier   [NOK]\n//   (0054,1300) FrameReferenceTime             [OK]\nfunction _getTimePointsData(volume) {\n  const timePointsTags = {\n    FrameReferenceTime: {\n      unit: 'ms',\n    },\n  };\n\n  const timePointsTagNames = Object.keys(timePointsTags);\n  let timePoints;\n  let timePointsUnit;\n\n  for (let i = 0; i < timePointsTagNames.length; i++) {\n    const tagName = timePointsTagNames[i];\n    const curTimePoints = _getTimePointsDataByTagName(volume, tagName);\n\n    if (curTimePoints.length) {\n      timePoints = curTimePoints;\n      timePointsUnit = timePointsTags[tagName].unit;\n      break;\n    }\n  }\n\n  if (!timePoints.length) {\n    const concatTagNames = timePointsTagNames.join(', ');\n\n    throw new Error(`Could not extract time points data for the following tags: ${concatTagNames}`);\n  }\n\n  const convertedTimePoints = _convertTimePointsUnit(timePoints, timePointsUnit);\n\n  timePoints = convertedTimePoints.timePoints;\n  timePointsUnit = convertedTimePoints.timePointsUnit;\n\n  return { timePoints, timePointsUnit };\n}\n\nfunction _getSegmentationData(segmentation, volumesTimePointsCache, displaySetService) {\n  const displaySets = displaySetService.getActiveDisplaySets();\n\n  const dynamic4DDisplaySet = displaySets.find(displaySet => {\n    const anInstance = displaySet.instances?.[0];\n\n    if (anInstance) {\n      return (\n        anInstance.FrameReferenceTime !== undefined || anInstance.NumberOfTimeSlices !== undefined\n      );\n    }\n\n    return false;\n  });\n\n  // const referencedDynamicVolume = cs.cache.getVolume(dynamic4DDisplaySet.displaySetInstanceUID);\n  let volumeCacheKey: string | undefined;\n  const volumeId = dynamic4DDisplaySet.displaySetInstanceUID;\n\n  for (const [key] of cs.cache._volumeCache) {\n    if (key.includes(volumeId)) {\n      volumeCacheKey = key;\n      break;\n    }\n  }\n\n  let referencedDynamicVolume;\n  if (volumeCacheKey) {\n    referencedDynamicVolume = cs.cache.getVolume(volumeCacheKey);\n  }\n\n  const { StudyInstanceUID, StudyDescription } = DicomMetadataStore.getInstanceByImageId(\n    referencedDynamicVolume.imageIds[0]\n  );\n\n  const [timeData, _] = csToolsUtils.dynamicVolume.getDataInTime(referencedDynamicVolume, {\n    maskVolumeId: segmentation.id,\n  }) as number[][];\n\n  const pixelCount = timeData.length;\n\n  if (pixelCount === 0) {\n    return [];\n  }\n\n  // since we only use one segmentation representation per segmentationId\n  // it is fine to pick the first one\n  const segmentationRepresentations = csTools.segmentation.state.getSegmentationIdRepresentations(\n    segmentation.id\n  );\n\n  const segmentationRepresentationUID =\n    segmentationRepresentations[0].segmentationRepresentationUID;\n\n  const toolGroupId = csTools.segmentation.state.getToolGroupIdFromSegmentationRepresentationUID(\n    segmentationRepresentationUID\n  );\n\n  // Todo: this is useless we should be able to grab color with just segRepUID and segmentIndex\n  const color = csTools.segmentation.config.color.getColorForSegmentIndex(\n    toolGroupId,\n    segmentationRepresentationUID,\n    1 // segmentIndex\n  );\n\n  const hexColor = cs.utilities.color.rgbToHex(...color);\n  let timePointsData = volumesTimePointsCache.get(referencedDynamicVolume);\n\n  if (!timePointsData) {\n    timePointsData = _getTimePointsData(referencedDynamicVolume);\n    volumesTimePointsCache.set(referencedDynamicVolume, timePointsData);\n  }\n\n  const { timePoints, timePointsUnit } = timePointsData;\n\n  if (timePoints.length !== timeData[0].length) {\n    throw new Error('Invalid number of time points returned');\n  }\n\n  const timepointsCount = timePoints.length;\n  const chartSeriesData = new Array(timepointsCount);\n\n  for (let i = 0; i < timepointsCount; i++) {\n    const average = timeData.reduce((acc, cur) => acc + cur[i] / pixelCount, 0);\n\n    chartSeriesData[i] = [timePoints[i], average];\n  }\n\n  return {\n    StudyInstanceUID,\n    StudyDescription,\n    chartData: {\n      series: {\n        label: segmentation.label,\n        points: chartSeriesData,\n        color: hexColor,\n      },\n      axis: {\n        x: {\n          label: `Time (${timePointsUnit})`,\n        },\n        y: {\n          label: `Vl (Bq/ml)`,\n        },\n      },\n    },\n  };\n}\n\nfunction _getInstanceFromSegmentations(segmentations, displaySetService) {\n  if (!segmentations.length) {\n    return;\n  }\n\n  const volumesTimePointsCache = new WeakMap();\n  const segmentationsData = segmentations.map(segmentation =>\n    _getSegmentationData(segmentation, volumesTimePointsCache, displaySetService)\n  );\n\n  const { date: seriesDate, time: seriesTime } = _getDateTimeStr();\n  const series = segmentationsData.reduce((allSeries, curSegData) => {\n    return [...allSeries, curSegData.chartData.series];\n  }, []);\n\n  const instance = {\n    SOPClassUID: ChartDataSOPClassUid,\n    Modality: CHART_MODALITY,\n    SOPInstanceUID: utils.guid(),\n    SeriesDate: seriesDate,\n    SeriesTime: seriesTime,\n    SeriesInstanceUID: SEG_CHART_INSTANCE_UID,\n    StudyInstanceUID: segmentationsData[0].StudyInstanceUID,\n    StudyDescription: segmentationsData[0].StudyDescription,\n    SeriesNumber: 100,\n    SeriesDescription: 'Segmentation chart series data',\n    chartData: {\n      series,\n      axis: { ...segmentationsData[0].chartData.axis },\n    },\n  };\n\n  const seriesMetadata = {\n    StudyInstanceUID: instance.StudyInstanceUID,\n    StudyDescription: instance.StudyDescription,\n    SeriesInstanceUID: instance.SeriesInstanceUID,\n    SeriesDescription: instance.SeriesDescription,\n    SeriesNumber: instance.SeriesNumber,\n    SeriesTime: instance.SeriesTime,\n    SOPClassUID: instance.SOPClassUID,\n    Modality: instance.Modality,\n  };\n\n  return { seriesMetadata, instance };\n}\n\nfunction updateSegmentationsChartDisplaySet({ servicesManager }): void {\n  const { segmentationService, displaySetService } = servicesManager.services;\n  const segmentations = segmentationService.getSegmentations();\n  const { seriesMetadata, instance } =\n    _getInstanceFromSegmentations(segmentations, displaySetService) ?? {};\n\n  if (seriesMetadata && instance) {\n    // An event is triggered after adding the instance and the displaySet is created\n    DicomMetadataStore.addSeriesMetadata([seriesMetadata], true);\n    DicomMetadataStore.addInstances([instance], true);\n  }\n}\n\nexport { updateSegmentationsChartDisplaySet as default };\n","import * as importedActions from './actions';\nimport { utilities, Enums } from '@cornerstonejs/tools';\nimport { cache } from '@cornerstonejs/core';\n\nconst LABELMAP = Enums.SegmentationRepresentations.Labelmap;\n\nconst commandsModule = ({ commandsManager, servicesManager }) => {\n  const services = servicesManager.services;\n  const { displaySetService, viewportGridService, segmentationService } = services;\n\n  const actions = {\n    ...importedActions,\n    getDynamic4DDisplaySet: () => {\n      const displaySets = displaySetService.getActiveDisplaySets();\n\n      const dynamic4DDisplaySet = displaySets.find(displaySet => {\n        const anInstance = displaySet.instances?.[0];\n\n        if (anInstance) {\n          return (\n            anInstance.FrameReferenceTime !== undefined ||\n            anInstance.NumberOfTimeSlices !== undefined ||\n            anInstance.TemporalPositionIdentifier !== undefined\n          );\n        }\n\n        return false;\n      });\n\n      return dynamic4DDisplaySet;\n    },\n    getComputedDisplaySets: () => {\n      const displaySetCache = displaySetService.getDisplaySetCache();\n      const cachedDisplaySets = [...displaySetCache.values()];\n      const computedDisplaySets = cachedDisplaySets.filter(displaySet => {\n        return displaySet.isDerived;\n      });\n      return computedDisplaySets;\n    },\n    exportTimeReportCSV: ({ segmentations, config, options, summaryStats }) => {\n      const dynamic4DDisplaySet = actions.getDynamic4DDisplaySet();\n\n      const volumeId = dynamic4DDisplaySet?.displaySetInstanceUID;\n\n      // cache._volumeCache is a map that has a key that includes the volumeId\n      // it is not exactly the volumeId, but it is the key that includes the volumeId\n      // so we can't do cache._volumeCache.get(volumeId) we should iterate\n      // over the keys and find the one that includes the volumeId\n      let volumeCacheKey: string | undefined;\n\n      for (const [key] of cache._volumeCache) {\n        if (key.includes(volumeId)) {\n          volumeCacheKey = key;\n          break;\n        }\n      }\n\n      let dynamicVolume;\n      if (volumeCacheKey) {\n        dynamicVolume = cache.getVolume(volumeCacheKey);\n      }\n\n      const instance = dynamic4DDisplaySet.instances[0];\n\n      const csv = [];\n\n      // CSV header information with placeholder empty values for the metadata lines\n      csv.push(`Patient ID,${instance.PatientID},`);\n      csv.push(`Study Date,${instance.StudyDate},`);\n      csv.push(`StudyInstanceUID,${instance.StudyInstanceUID},`);\n      csv.push(`StudyDescription,${instance.StudyDescription},`);\n      csv.push(`SeriesInstanceUID,${instance.SeriesInstanceUID},`);\n\n      // empty line\n      csv.push('');\n      csv.push('');\n\n      // Helper function to calculate standard deviation\n      function calculateStandardDeviation(data) {\n        const n = data.length;\n        const mean = data.reduce((acc, value) => acc + value, 0) / n;\n        const squaredDifferences = data.map(value => (value - mean) ** 2);\n        const variance = squaredDifferences.reduce((acc, value) => acc + value, 0) / n;\n        const stdDeviation = Math.sqrt(variance);\n        return stdDeviation;\n      }\n\n      // Iterate through each segmentation to get the timeData and ijkCoords\n      segmentations.forEach((segmentation, segmentationIndex) => {\n        const [timeData, ijkCoords] = utilities.dynamicVolume.getDataInTime(dynamicVolume, {\n          maskVolumeId: segmentation.id,\n        }) as number[][];\n\n        if (summaryStats) {\n          // Adding column headers for pixel identifier and segmentation label ids\n          let headers = 'Operation,Segmentation Label ID';\n          const maxLength = dynamicVolume.numTimePoints;\n          for (let t = 0; t < maxLength; t++) {\n            headers += `,Time Point ${t}`;\n          }\n          csv.push(headers);\n          // // perform summary statistics on the timeData including for each time point, mean, median, min, max, and standard deviation for\n          // // all the voxels in the ROI\n          const mean = [];\n          const min = [];\n          const minIJK = [];\n          const max = [];\n          const maxIJK = [];\n          const std = [];\n\n          const numVoxels = timeData.length;\n          // Helper function to calculate standard deviation\n          for (let timeIndex = 0; timeIndex < maxLength; timeIndex++) {\n            // for each voxel in the ROI, get the value at the current time point\n            const voxelValues = [];\n            for (let voxelIndex = 0; voxelIndex < numVoxels; voxelIndex++) {\n              voxelValues.push(timeData[voxelIndex][timeIndex]);\n            }\n\n            mean.push(voxelValues.reduce((acc, value) => acc + value, 0) / numVoxels);\n            const minimum = Math.min(...voxelValues);\n            min.push(minimum);\n            minIJK.push(ijkCoords[voxelValues.indexOf(minimum)]);\n            const maximum = Math.max(...voxelValues);\n            max.push(maximum);\n            maxIJK.push(ijkCoords[voxelValues.indexOf(maximum)]);\n            std.push(calculateStandardDeviation(voxelValues));\n          }\n\n          let row = `Mean,${segmentation.label}`;\n          // Generate separate rows for each statistic\n          for (let t = 0; t < maxLength; t++) {\n            row += `,${mean[t]}`;\n          }\n\n          csv.push(row);\n\n          row = `Standard Deviation,${segmentation.label}`;\n          for (let t = 0; t < maxLength; t++) {\n            row += `,${std[t]}`;\n          }\n\n          csv.push(row);\n\n          row = `Min,${segmentation.label}`;\n          for (let t = 0; t < maxLength; t++) {\n            row += `,${min[t]}`;\n          }\n\n          csv.push(row);\n\n          row = `Max,${segmentation.label}`;\n          for (let t = 0; t < maxLength; t++) {\n            row += `,${max[t]}`;\n          }\n\n          csv.push(row);\n        } else {\n          // Adding column headers for pixel identifier and segmentation label ids\n          let headers = 'Pixel Identifier (IJK),Segmentation Label ID';\n          const maxLength = dynamicVolume.numTimePoints;\n          for (let t = 0; t < maxLength; t++) {\n            headers += `,Time Point ${t}`;\n          }\n          csv.push(headers);\n          // Assuming timeData and ijkCoords are of the same length\n          for (let i = 0; i < timeData.length; i++) {\n            // Generate the pixel identifier\n            const pixelIdentifier = `${ijkCoords[i][0]}_${ijkCoords[i][1]}_${ijkCoords[i][2]}`;\n\n            // Start a new row for the current pixel\n            let row = `${pixelIdentifier},${segmentation.label}`;\n\n            // Add time data points for this pixel\n            for (let t = 0; t < timeData[i].length; t++) {\n              row += `,${timeData[i][t]}`;\n            }\n\n            // Append the row to the CSV array\n            csv.push(row);\n          }\n        }\n      });\n\n      // Convert to CSV string\n      const csvContent = csv.join('\\n');\n\n      // Generate filename and trigger download\n      const filename = `${instance.PatientID}.csv`;\n      const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });\n      const link = document.createElement('a');\n      const url = URL.createObjectURL(blob);\n      link.setAttribute('href', url);\n      link.setAttribute('download', filename);\n      link.style.visibility = 'hidden';\n      document.body.appendChild(link);\n      link.click();\n      document.body.removeChild(link);\n    },\n    swapDynamicWithComputedDisplaySet: ({ displaySet }) => {\n      const computedDisplaySet = displaySet;\n\n      const displaySetCache = displaySetService.getDisplaySetCache();\n      const cachedDisplaySetKeys = [displaySetCache.keys()];\n      const { displaySetInstanceUID } = computedDisplaySet;\n      // Check to see if computed display set is already in cache\n      if (!cachedDisplaySetKeys.includes(displaySetInstanceUID)) {\n        displaySetCache.set(displaySetInstanceUID, computedDisplaySet);\n      }\n\n      // Get all viewports and their corresponding indices\n      const { viewports } = viewportGridService.getState();\n\n      // get the viewports in the grid\n      // iterate over them and find the ones that are showing a dynamic\n      // volume (displaySet), and replace that exact displaySet with the\n      // computed displaySet\n\n      const dynamic4DDisplaySet = actions.getDynamic4DDisplaySet();\n\n      const viewportsToUpdate = [];\n\n      for (const [key, value] of viewports) {\n        const viewport = value;\n        const viewportOptions = viewport.viewportOptions;\n        const { displaySetInstanceUIDs } = viewport;\n        const displaySetInstanceUIDIndex = displaySetInstanceUIDs.indexOf(\n          dynamic4DDisplaySet.displaySetInstanceUID\n        );\n        if (displaySetInstanceUIDIndex !== -1) {\n          const newViewport = {\n            viewportId: viewport.viewportId,\n            // merge the other displaySetInstanceUIDs with the new one\n            displaySetInstanceUIDs: [\n              ...displaySetInstanceUIDs.slice(0, displaySetInstanceUIDIndex),\n              displaySetInstanceUID,\n              ...displaySetInstanceUIDs.slice(displaySetInstanceUIDIndex + 1),\n            ],\n            viewportOptions: {\n              initialImageOptions: viewportOptions.initialImageOptions,\n              viewportType: 'volume',\n              orientation: viewportOptions.orientation,\n              background: viewportOptions.background,\n            },\n          };\n          viewportsToUpdate.push(newViewport);\n        }\n      }\n\n      viewportGridService.setDisplaySetsForViewports(viewportsToUpdate);\n    },\n    swapComputedWithDynamicDisplaySet: () => {\n      // Todo: this assumes there is only one dynamic display set in the viewer\n      const dynamicDisplaySet = actions.getDynamic4DDisplaySet();\n\n      const displaySetCache = displaySetService.getDisplaySetCache();\n      const cachedDisplaySetKeys = [...displaySetCache.keys()]; // Fix: Spread to get the array\n      const { displaySetInstanceUID } = dynamicDisplaySet;\n\n      // Check to see if dynamic display set is already in cache\n      if (!cachedDisplaySetKeys.includes(displaySetInstanceUID)) {\n        displaySetCache.set(displaySetInstanceUID, dynamicDisplaySet);\n      }\n\n      // Get all viewports and their corresponding indices\n      const { viewports } = viewportGridService.getState();\n\n      // Get the computed 4D display set\n      const computed4DDisplaySet = actions.getComputedDisplaySets()[0];\n\n      const viewportsToUpdate = [];\n\n      for (const [key, value] of viewports) {\n        const viewport = value;\n        const viewportOptions = viewport.viewportOptions;\n        const { displaySetInstanceUIDs } = viewport;\n        const displaySetInstanceUIDIndex = displaySetInstanceUIDs.indexOf(\n          computed4DDisplaySet.displaySetInstanceUID\n        );\n        if (displaySetInstanceUIDIndex !== -1) {\n          const newViewport = {\n            viewportId: viewport.viewportId,\n            // merge the other displaySetInstanceUIDs with the new one\n            displaySetInstanceUIDs: [\n              ...displaySetInstanceUIDs.slice(0, displaySetInstanceUIDIndex),\n              displaySetInstanceUID,\n              ...displaySetInstanceUIDs.slice(displaySetInstanceUIDIndex + 1),\n            ],\n            viewportOptions: {\n              initialImageOptions: viewportOptions.initialImageOptions,\n              viewportType: 'volume',\n              orientation: viewportOptions.orientation,\n              background: viewportOptions.background,\n            },\n          };\n          viewportsToUpdate.push(newViewport);\n        }\n      }\n\n      viewportGridService.setDisplaySetsForViewports(viewportsToUpdate);\n    },\n    createNewLabelMapForDynamicVolume: async ({ label }) => {\n      const { viewports, activeViewportId } = viewportGridService.getState();\n\n      // get the dynamic 4D display set\n      const dynamic4DDisplaySet = actions.getDynamic4DDisplaySet();\n      const dynamic4DDisplaySetInstanceUID = dynamic4DDisplaySet.displaySetInstanceUID;\n\n      // check if the dynamic 4D display set is in the display, if not we might have\n      // the computed volumes and we should choose them for the segmentation\n      // creation\n\n      let referenceDisplaySet;\n\n      const activeViewport = viewports.get(activeViewportId);\n      const activeDisplaySetInstanceUIDs = activeViewport.displaySetInstanceUIDs;\n      const dynamicIsInActiveViewport = activeDisplaySetInstanceUIDs.includes(\n        dynamic4DDisplaySetInstanceUID\n      );\n\n      if (dynamicIsInActiveViewport) {\n        referenceDisplaySet = dynamic4DDisplaySet;\n      }\n\n      if (!referenceDisplaySet) {\n        // try to see if there is any derived displaySet in the active viewport\n        // which is referencing the dynamic 4D display set\n\n        // Todo: this is wrong but I don't have time to fix it now\n        const cachedDisplaySets = displaySetService.getDisplaySetCache();\n        for (const [key, displaySet] of cachedDisplaySets) {\n          if (displaySet.referenceDisplaySetUID === dynamic4DDisplaySetInstanceUID) {\n            referenceDisplaySet = displaySet;\n            break;\n          }\n        }\n      }\n\n      if (!referenceDisplaySet) {\n        throw new Error('No reference display set found based on the dynamic data');\n      }\n\n      const segmentationId = await segmentationService.createSegmentationForDisplaySet(\n        referenceDisplaySet.displaySetInstanceUID,\n        { label }\n      );\n\n      // Add Segmentation to all toolGroupIds in the viewer\n      const toolGroupIds = Array.from(\n        viewports.values(),\n        viewport => viewport.viewportOptions.toolGroupId\n      );\n\n      const representationType = LABELMAP;\n\n      for (const toolGroupId of toolGroupIds) {\n        const hydrateSegmentation = true;\n        await segmentationService.addSegmentationRepresentationToToolGroup(\n          toolGroupId,\n          segmentationId,\n          hydrateSegmentation,\n          representationType\n        );\n\n        segmentationService.setActiveSegmentationForToolGroup(segmentationId, toolGroupId);\n      }\n\n      return segmentationId;\n    },\n  };\n\n  const definitions = {\n    updateSegmentationsChartDisplaySet: {\n      commandFn: actions.updateSegmentationsChartDisplaySet,\n      storeContexts: [],\n      options: {},\n    },\n    exportTimeReportCSV: {\n      commandFn: actions.exportTimeReportCSV,\n      storeContexts: [],\n      options: {},\n    },\n    swapDynamicWithComputedDisplaySet: {\n      commandFn: actions.swapDynamicWithComputedDisplaySet,\n      storeContexts: [],\n      options: {},\n    },\n    createNewLabelMapForDynamicVolume: {\n      commandFn: actions.createNewLabelMapForDynamicVolume,\n      storeContexts: [],\n      options: {},\n    },\n    swapComputedWithDynamicDisplaySet: {\n      commandFn: actions.swapComputedWithDynamicDisplaySet,\n      storeContexts: [],\n      options: {},\n    },\n  };\n\n  return {\n    actions,\n    definitions,\n    defaultContext: 'DYNAMIC-VOLUME:CORNERSTONE',\n  };\n};\n\nexport default commandsModule;\n","import React, { useEffect, useState } from 'react';\nimport {\n  InputDoubleRange,\n  Button,\n  PanelSection,\n  ButtonGroup,\n  IconButton,\n  InputNumber,\n  Icon,\n  Tooltip,\n} from '@ohif/ui';\n\nimport { Enums } from '@cornerstonejs/core';\n\nconst controlClassNames = {\n  sizeClassName: 'w-[58px] h-[28px]',\n  arrowsDirection: 'horizontal',\n  labelPosition: 'bottom',\n};\n\nconst Header = ({ title, tooltip }) => (\n  <div className=\"flex items-center space-x-1\">\n    <Tooltip\n      content={<div className=\"text-white\">{tooltip}</div>}\n      position=\"bottom-left\"\n      tight={true}\n      tooltipBoxClassName=\"max-w-xs p-2\"\n    >\n      <Icon\n        name=\"info-link\"\n        className=\"text-primary-active h-[14px] w-[14px]\"\n      />\n    </Tooltip>\n    <span className=\"text-aqua-pale text-[11px] uppercase\">{title}</span>\n  </div>\n);\n\nconst DynamicVolumeControls = ({\n  isPlaying,\n  onPlayPauseChange,\n  // fps\n  fps,\n  onFpsChange,\n  minFps,\n  maxFps,\n  // Frames\n  currentFrameIndex,\n  onFrameChange,\n  framesLength,\n  onGenerate,\n  onDoubleRangeChange,\n  onDynamicClick,\n}) => {\n  const [computedView, setComputedView] = useState(false);\n\n  const [computeViewMode, setComputeViewMode] = useState(Enums.DynamicOperatorType.SUM);\n\n  const [sliderRangeValues, setSliderRangeValues] = useState([framesLength / 4, framesLength / 2]);\n\n  useEffect(() => {\n    setSliderRangeValues([framesLength / 4, framesLength / 2]);\n  }, [framesLength]);\n\n  const handleSliderChange = newValues => {\n    onDoubleRangeChange(newValues);\n\n    if (newValues[0] === sliderRangeValues[0] && newValues[1] === sliderRangeValues[1]) {\n      return;\n    }\n    setSliderRangeValues(newValues);\n  };\n\n  return (\n    <div className=\"flex select-none flex-col\">\n      <PanelSection\n        title=\"Controls\"\n        childrenClassName=\"space-y-4 pb-5 px-5\"\n      >\n        <div className=\"mt-2\">\n          <Header\n            title=\"View\"\n            tooltip={\n              'Select the view mode, 4D to view the dynamic volume or Computed to view the computed volume'\n            }\n          />\n          <ButtonGroup className=\"mt-2 w-full\">\n            <button\n              className=\"w-1/2\"\n              onClick={() => {\n                setComputedView(false);\n                onDynamicClick?.();\n              }}\n            >\n              4D\n            </button>\n            <button\n              className=\"w-1/2\"\n              onClick={() => {\n                setComputedView(true);\n              }}\n            >\n              Computed\n            </button>\n          </ButtonGroup>\n        </div>\n        <div>\n          <FrameControls\n            onPlayPauseChange={onPlayPauseChange}\n            isPlaying={isPlaying}\n            computedView={computedView}\n            // fps\n            fps={fps}\n            onFpsChange={onFpsChange}\n            minFps={minFps}\n            maxFps={maxFps}\n            //\n            framesLength={framesLength}\n            onFrameChange={onFrameChange}\n            currentFrameIndex={currentFrameIndex}\n          />\n        </div>\n        <div className={`mt-6 flex flex-col ${computedView ? '' : 'ohif-disabled'}`}>\n          <Header\n            title=\"Computed Operation\"\n            tooltip={\n              <div>\n                Operation Buttons (SUM, AVERAGE, SUBTRACT): Select the mathematical operation to be\n                applied to the data set.\n                <br></br> Range Slider: Choose the numeric range within which the operation will be\n                performed.\n                <br></br>Generate Button: Execute the chosen operation on the specified range of\n                data.{' '}\n              </div>\n            }\n          />\n          <ButtonGroup\n            className={`mt-2 w-full `}\n            separated={true}\n          >\n            <button\n              className=\"w-1/2\"\n              onClick={() => setComputeViewMode(Enums.DynamicOperatorType.SUM)}\n            >\n              {Enums.DynamicOperatorType.SUM.toString().toUpperCase()}\n            </button>\n            <button\n              className=\"w-1/2\"\n              onClick={() => setComputeViewMode(Enums.DynamicOperatorType.AVERAGE)}\n            >\n              {Enums.DynamicOperatorType.AVERAGE.toString().toUpperCase()}\n            </button>\n            <button\n              className=\"w-1/2\"\n              onClick={() => setComputeViewMode(Enums.DynamicOperatorType.SUBTRACT)}\n            >\n              {Enums.DynamicOperatorType.SUBTRACT.toString().toUpperCase()}\n            </button>\n          </ButtonGroup>\n          <div className=\"w-ful mt-2\">\n            <InputDoubleRange\n              values={sliderRangeValues}\n              onChange={handleSliderChange}\n              minValue={0}\n              showLabel={true}\n              allowNumberEdit={true}\n              maxValue={framesLength}\n              step={1}\n            />\n          </div>\n          <Button\n            className=\"mt-2 !h-[26px] !w-[115px] self-start !p-0\"\n            onClick={() => {\n              onGenerate(computeViewMode);\n            }}\n          >\n            Generate\n          </Button>\n        </div>\n      </PanelSection>\n    </div>\n  );\n};\n\nexport default DynamicVolumeControls;\n\nfunction FrameControls({\n  isPlaying,\n  onPlayPauseChange,\n  fps,\n  minFps,\n  maxFps,\n  onFpsChange,\n  framesLength,\n  onFrameChange,\n  currentFrameIndex,\n  computedView,\n}) {\n  const getPlayPauseIconName = () => (isPlaying ? 'icon-pause' : 'icon-play');\n\n  return (\n    <div className={computedView && 'ohif-disabled'}>\n      <Header\n        title=\"4D Controls\"\n        tooltip={\n          <div>\n            Play/Pause Button: Begin or pause the animation of the 4D visualization. <br></br> Frame\n            Selector: Navigate through individual frames of the 4D data. <br></br> FPS (Frames Per\n            Second) Selector: Adjust the playback speed of the animation.\n          </div>\n        }\n      />\n      <div className=\"mt-3 flex justify-between\">\n        <IconButton\n          className=\"bg-customblue-30 h-[26px] w-[58px] rounded-[4px]\"\n          onClick={() => onPlayPauseChange(!isPlaying)}\n        >\n          <Icon\n            name={getPlayPauseIconName()}\n            className=\" active:text-primary-light hover:bg-customblue-300 h-[24px] w-[24px] cursor-pointer text-white\"\n          />\n        </IconButton>\n        <InputNumber\n          value={currentFrameIndex}\n          onChange={onFrameChange}\n          minValue={0}\n          maxValue={framesLength}\n          label=\"Frame\"\n          {...controlClassNames}\n        />\n        <InputNumber\n          value={fps}\n          onChange={onFpsChange}\n          minValue={minFps}\n          maxValue={maxFps}\n          {...controlClassNames}\n          label=\"FPS\"\n        />\n      </div>\n    </div>\n  );\n}\n","import React, { useEffect, useState, useRef } from 'react';\nimport PropTypes from 'prop-types';\nimport { useCine, useViewportGrid } from '@ohif/ui';\nimport { cache, utilities as csUtils, volumeLoader, eventTarget } from '@cornerstonejs/core';\nimport { Enums } from '@cornerstonejs/streaming-image-volume-loader';\nimport { utilities as cstUtils } from '@cornerstonejs/tools';\nimport DynamicVolumeControls from './DynamicVolumeControls';\n\nconst SOPClassHandlerId = '@ohif/extension-default.sopClassHandlerModule.stack';\n\nexport default function PanelGenerateImage({ servicesManager, commandsManager }) {\n  const { cornerstoneViewportService, viewportGridService, displaySetService } =\n    servicesManager.services;\n\n  const [{ isCineEnabled }, cineService] = useCine();\n  const [{ activeViewportId }] = useViewportGrid();\n\n  //\n  const [timePointsRange, setTimePointsRange] = useState([]);\n  const [timePointsRangeToUseForGenerate, setTimePointsRangeToUseForGenerate] = useState([]);\n  const [computedDisplaySet, setComputedDisplaySet] = useState(null);\n  const [dynamicVolume, setDynamicVolume] = useState(null);\n  const [frameRate, setFrameRate] = useState(20);\n  const [isPlaying, setIsPlaying] = useState(isCineEnabled);\n  const [timePointRendered, setTimePointRendered] = useState(null);\n  const [displayingComputed, setDisplayingComputed] = useState(false);\n\n  //\n  const uuidComputedVolume = useRef(csUtils.uuidv4());\n  const uuidDynamicVolume = useRef(null);\n  const computedVolumeId = `cornerstoneStreamingImageVolume:${uuidComputedVolume.current}`;\n\n  useEffect(() => {\n    const evt = cornerstoneViewportService.EVENTS.VIEWPORT_DATA_CHANGED;\n\n    const { unsubscribe } = cornerstoneViewportService.subscribe(evt, evtDetails => {\n      evtDetails.viewportData.data.forEach(volumeData => {\n        if (volumeData.volume.isDynamicVolume()) {\n          setDynamicVolume(volumeData.volume);\n          uuidDynamicVolume.current = volumeData.displaySetInstanceUID;\n          setTimePointsRange([1, volumeData.volume.numTimePoints]);\n        }\n      });\n    });\n\n    return () => {\n      unsubscribe();\n    };\n  }, [cornerstoneViewportService]);\n\n  useEffect(() => {\n    const { unsubscribe } = servicesManager.services.cineService.subscribe(\n      servicesManager.services.cineService.EVENTS.CINE_STATE_CHANGED,\n      evt => {\n        setIsPlaying(evt.isPlaying);\n      }\n    );\n\n    return () => {\n      unsubscribe();\n    };\n  }, [cineService]);\n\n  useEffect(() => {\n    const displaySetUIDs = viewportGridService.getDisplaySetsUIDsForViewport(activeViewportId);\n\n    if (!displaySetUIDs || displaySetUIDs.length === 0) {\n      return;\n    }\n\n    const displaySets = displaySetUIDs.map(displaySetUID =>\n      displaySetService.getDisplaySetByUID(displaySetUID)\n    );\n\n    const dynamicVolumeDisplaySet = displaySets.find(displaySet => displaySet.isDynamicVolume);\n\n    if (!dynamicVolumeDisplaySet) {\n      return;\n    }\n\n    const dynamicVolume = cache\n      .getVolumes()\n      .find(volume => volume.volumeId.includes(dynamicVolumeDisplaySet.displaySetInstanceUID));\n\n    if (!dynamicVolume) {\n      return;\n    }\n\n    setDynamicVolume(dynamicVolume);\n    uuidDynamicVolume.current = dynamicVolumeDisplaySet.displaySetInstanceUID;\n    setTimePointsRange([1, dynamicVolume.numTimePoints]);\n  }, [activeViewportId, cornerstoneViewportService]);\n\n  useEffect(() => {\n    // ~~ Subscription\n    const evt = Enums.Events.DYNAMIC_VOLUME_TIME_POINT_INDEX_CHANGED;\n\n    const callback = evt => {\n      setTimePointRendered(evt.detail.timePointIndex);\n    };\n\n    eventTarget.addEventListener(evt, callback);\n\n    return () => {\n      eventTarget.removeEventListener(evt, callback);\n    };\n  }, [cornerstoneViewportService]);\n\n  function renderGeneratedImage(displaySet) {\n    commandsManager.runCommand('swapDynamicWithComputedDisplaySet', {\n      displaySet,\n    });\n\n    setDisplayingComputed(true);\n  }\n\n  function renderDynamicImage(displaySet) {\n    commandsManager.runCommand('swapComputedWithDynamicDisplaySet');\n  }\n\n  // Get computed volume from cache, calculate the data across the time frames,\n  // set the scalar data to the computedVolume, and create displaySet\n  async function onGenerateImage(operationName) {\n    const dynamicVolumeId = dynamicVolume.volumeId;\n\n    if (!dynamicVolumeId) {\n      return;\n    }\n\n    let computedVolume = cache.getVolume(computedVolumeId);\n\n    if (!computedVolume) {\n      await createComputedVolume(dynamicVolumeId, computedVolumeId);\n      computedVolume = cache.getVolume(computedVolumeId);\n    }\n\n    const vals = timePointsRangeToUseForGenerate;\n\n    const targets = Array.from({ length: vals[1] - vals[0] + 1 }, (_, i) => i + vals[0]);\n\n    const dataInTime = cstUtils.dynamicVolume.generateImageFromTimeData(\n      dynamicVolume,\n      operationName,\n      operationName === 'SUBTRACT' ? vals : targets\n    );\n\n    // Add loadStatus.loaded to computed volume and set to true\n    computedVolume.loadStatus = {};\n    computedVolume.loadStatus.loaded = true;\n    // Set computed scalar data to volume\n    const scalarData = computedVolume.getScalarData();\n    scalarData.set(dataInTime);\n\n    // If computed display set does not exist, create an object to be used as\n    // the displaySet. If it does exist, update the image data and vtkTexture\n    if (!computedDisplaySet) {\n      const displaySet = {\n        volumeLoaderSchema: computedVolume.volumeId.split(':')[0],\n        displaySetInstanceUID: uuidComputedVolume.current,\n        SOPClassHandlerId: SOPClassHandlerId,\n        Modality: dynamicVolume.metadata.Modality,\n        isMultiFrame: false,\n        numImageFrames: 1,\n        uid: uuidComputedVolume.current,\n        referenceDisplaySetUID: dynamicVolume.volumeId.split(':')[1],\n        madeInClient: true,\n        FrameOfReferenceUID: dynamicVolume.metadata.FrameOfReferenceUID,\n        isDerived: true,\n      };\n      setComputedDisplaySet(displaySet);\n      renderGeneratedImage(displaySet);\n    } else {\n      commandsManager.runCommand('updateVolumeData', {\n        volume: computedVolume,\n      });\n      // Check if viewport is currently displaying the computed volume, if so,\n      // call render on the viewports to update the image, if not, call\n      // renderGeneratedImage\n      // if (!cache.getVolume(dynamicVolumeId)) {\n      //   for (const viewportId of viewports.keys()) {\n      //     const viewportForRendering =\n      //       cornerstoneViewportService.getCornerstoneViewport(viewportId);\n      //     viewportForRendering.render();\n      //   }\n      // } else {\n      cornerstoneViewportService.getRenderingEngine().render();\n      renderGeneratedImage(computedDisplaySet);\n      // }\n    }\n  }\n\n  const onPlayPauseChange = isPlaying => {\n    isPlaying ? handlePlay() : handleStop();\n  };\n\n  const handlePlay = () => {\n    setIsPlaying(true);\n    const viewportInfo = cornerstoneViewportService.getViewportInfo(activeViewportId);\n\n    if (!viewportInfo) {\n      return;\n    }\n\n    const { element } = viewportInfo;\n    cineService.playClip(element, { framesPerSecond: frameRate, viewportId: activeViewportId });\n  };\n\n  const handleStop = () => {\n    setIsPlaying(false);\n    const { element } = cornerstoneViewportService.getViewportInfo(activeViewportId);\n    cineService.stopClip(element);\n  };\n\n  const handleSetFrameRate = newFrameRate => {\n    setFrameRate(newFrameRate);\n    handleStop();\n    handlePlay();\n  };\n\n  function handleSliderChange(newValues) {\n    if (\n      newValues[0] === timePointsRangeToUseForGenerate[0] &&\n      newValues[1] === timePointsRangeToUseForGenerate[1]\n    ) {\n      return;\n    }\n\n    setTimePointsRangeToUseForGenerate(newValues);\n  }\n\n  if (!dynamicVolume || timePointsRange.length === 0) {\n    return null;\n  }\n\n  return (\n    <DynamicVolumeControls\n      fps={frameRate}\n      isPlaying={isPlaying}\n      onPlayPauseChange={onPlayPauseChange}\n      minFps={1}\n      maxFps={50}\n      currentFrameIndex={timePointRendered}\n      onFpsChange={handleSetFrameRate}\n      framesLength={timePointsRange[1]}\n      onFrameChange={timePointIndex => {\n        dynamicVolume.timePointIndex = timePointIndex;\n      }}\n      onGenerate={onGenerateImage}\n      onDynamicClick={displayingComputed ? () => renderDynamicImage(computedDisplaySet) : null}\n      onDoubleRangeChange={handleSliderChange}\n    />\n  );\n}\n\nasync function createComputedVolume(dynamicVolumeId, computedVolumeId) {\n  if (!cache.getVolume(computedVolumeId)) {\n    const computedVolume = await volumeLoader.createAndCacheDerivedVolume(dynamicVolumeId, {\n      volumeId: computedVolumeId,\n    });\n    return computedVolume;\n  }\n}\n\nPanelGenerateImage.propTypes = {\n  servicesManager: PropTypes.shape({\n    services: PropTypes.shape({\n      measurementService: PropTypes.shape({\n        getMeasurements: PropTypes.func.isRequired,\n        subscribe: PropTypes.func.isRequired,\n        EVENTS: PropTypes.object.isRequired,\n        VALUE_TYPES: PropTypes.object.isRequired,\n      }).isRequired,\n    }).isRequired,\n  }).isRequired,\n};\n","import React from 'react';\nimport PanelGenerateImage from './PanelGenerateImage';\n\nfunction DynamicDataPanel({ servicesManager, commandsManager }) {\n  return (\n    <div\n      className=\"flex flex-col text-white\"\n      data-cy={'dynamic-volume-panel'}\n    >\n      <PanelGenerateImage\n        commandsManager={commandsManager}\n        servicesManager={servicesManager}\n      ></PanelGenerateImage>\n    </div>\n  );\n}\n\nexport default DynamicDataPanel;\n","import React, { useState, useEffect } from 'react';\nimport { ActionButtons } from '@ohif/ui';\nimport { useTranslation } from 'react-i18next';\n\nfunction DynamicExport({ commandsManager, servicesManager, extensionManager }) {\n  const { segmentationService } = servicesManager.services;\n  const { t } = useTranslation('dynamicExport');\n\n  const [segmentations, setSegmentations] = useState(() => segmentationService.getSegmentations());\n\n  const actions = [\n    {\n      label: 'Export Time Data',\n      onClick: () => {\n        commandsManager.runCommand('exportTimeReportCSV', {\n          segmentations,\n          options: {\n            filename: 'TimeData.csv',\n          },\n        });\n      },\n      disabled: !segmentations?.length,\n    },\n    {\n      label: 'Export ROI Stats',\n      onClick: () => {\n        commandsManager.runCommand('exportTimeReportCSV', {\n          segmentations,\n          summaryStats: true,\n          options: {\n            filename: 'ROIStats.csv',\n          },\n        });\n      },\n      disabled: !segmentations?.length,\n    },\n  ];\n\n  /**\n   * Update UI based on segmentation changes (added, removed, updated)\n   */\n  useEffect(() => {\n    // ~~ Subscription\n    const added = segmentationService.EVENTS.SEGMENTATION_ADDED;\n    const updated = segmentationService.EVENTS.SEGMENTATION_UPDATED;\n    const removed = segmentationService.EVENTS.SEGMENTATION_REMOVED;\n    const subscriptions = [];\n\n    [added, updated, removed].forEach(evt => {\n      const { unsubscribe } = segmentationService.subscribe(evt, () => {\n        const segmentations = segmentationService.getSegmentations();\n        setSegmentations(segmentations);\n      });\n      subscriptions.push(unsubscribe);\n    });\n\n    return () => {\n      subscriptions.forEach(unsub => {\n        unsub();\n      });\n    };\n  }, []);\n\n  return (\n    <div>\n      <div className=\"mt-3 flex justify-center px-2\">\n        <ActionButtons\n          actions={actions}\n          t={t}\n        />\n      </div>\n    </div>\n  );\n}\n\nexport default DynamicExport;\n","import React from 'react';\nimport { DynamicDataPanel } from './panels';\nimport { Toolbox } from '@ohif/ui';\nimport DynamicExport from './panels/DynamicExport';\n\nfunction getPanelModule({ commandsManager, extensionManager, servicesManager }) {\n  const wrappedDynamicDataPanel = () => {\n    return (\n      <DynamicDataPanel\n        commandsManager={commandsManager}\n        servicesManager={servicesManager}\n        extensionManager={extensionManager}\n      />\n    );\n  };\n\n  const wrappedDynamicToolbox = () => {\n    return (\n      <>\n        <Toolbox\n          commandsManager={commandsManager}\n          servicesManager={servicesManager}\n          extensionManager={extensionManager}\n          buttonSectionId=\"dynamic-toolbox\"\n          title=\"Threshold Tools\"\n        />\n      </>\n    );\n  };\n\n  const wrappedDynamicExport = () => {\n    return (\n      <>\n        <DynamicExport\n          commandsManager={commandsManager}\n          servicesManager={servicesManager}\n          extensionManager={extensionManager}\n        />\n      </>\n    );\n  };\n\n  return [\n    {\n      name: 'dynamic-volume',\n      iconName: 'tab-4d',\n      iconLabel: '4D Workflow',\n      label: '4D Workflow',\n      component: wrappedDynamicDataPanel,\n    },\n    {\n      name: 'dynamic-toolbox',\n      iconName: 'tab-4d',\n      iconLabel: '4D Workflow',\n      label: 'Dynamic Toolbox',\n      component: wrappedDynamicToolbox,\n    },\n    {\n      name: 'dynamic-export',\n      iconName: 'tab-4d',\n      iconLabel: '4D Workflow',\n      label: '4D Workflow',\n      component: wrappedDynamicExport,\n    },\n  ];\n}\n\nexport default getPanelModule;\n","const DEFAULT_COLORMAP = '2hot';\nconst toolGroupIds = {\n  pt: 'dynamic4D-pt',\n  fusion: 'dynamic4D-fusion',\n  ct: 'dynamic4D-ct',\n};\n\nfunction getPTOptions({\n  colormap,\n  voiInverted,\n}: {\n  colormap?: {\n    name: string;\n    opacity:\n      | number\n      | {\n          value: number;\n          opacity: number;\n        }[];\n  };\n  voiInverted?: boolean;\n} = {}) {\n  return {\n    blendMode: 'MIP',\n    colormap,\n    voi: {\n      windowWidth: 5,\n      windowCenter: 2.5,\n    },\n    voiInverted,\n  };\n}\n\nfunction getPTViewports() {\n  const ptOptionsParams = {\n    colormap: {\n      name: DEFAULT_COLORMAP,\n      opacity: [\n        { value: 0, opacity: 0 },\n        { value: 0.1, opacity: 1 },\n        { value: 1, opacity: 1 },\n      ],\n    },\n    voiInverted: false,\n  };\n\n  return [\n    {\n      viewportOptions: {\n        viewportId: 'ptAxial',\n        viewportType: 'volume',\n        orientation: 'axial',\n        toolGroupId: toolGroupIds.pt,\n        initialImageOptions: {\n          preset: 'middle', // 'first', 'last', 'middle'\n        },\n        syncGroups: [\n          {\n            type: 'cameraPosition',\n            id: 'axialSync',\n            source: true,\n            target: true,\n          },\n          {\n            type: 'voi',\n            id: 'ptWLSync',\n            source: true,\n            target: true,\n          },\n        ],\n      },\n      displaySets: [\n        {\n          id: 'ptDisplaySet',\n          options: { ...getPTOptions(ptOptionsParams) },\n        },\n      ],\n    },\n    {\n      viewportOptions: {\n        viewportId: 'ptSagittal',\n        viewportType: 'volume',\n        orientation: 'sagittal',\n        toolGroupId: toolGroupIds.pt,\n        initialImageOptions: {\n          preset: 'middle', // 'first', 'last', 'middle'\n        },\n        syncGroups: [\n          {\n            type: 'cameraPosition',\n            id: 'sagittalSync',\n            source: true,\n            target: true,\n          },\n          {\n            type: 'voi',\n            id: 'ptWLSync',\n            source: true,\n            target: true,\n          },\n        ],\n      },\n      displaySets: [\n        {\n          id: 'ptDisplaySet',\n          options: { ...getPTOptions(ptOptionsParams) },\n        },\n      ],\n    },\n    {\n      viewportOptions: {\n        viewportId: 'ptCoronal',\n        viewportType: 'volume',\n        orientation: 'coronal',\n        toolGroupId: toolGroupIds.pt,\n        initialImageOptions: {\n          preset: 'middle', // 'first', 'last', 'middle'\n        },\n        syncGroups: [\n          {\n            type: 'cameraPosition',\n            id: 'coronalSync',\n            source: true,\n            target: true,\n          },\n          {\n            type: 'voi',\n            id: 'ptWLSync',\n            source: true,\n            target: true,\n          },\n        ],\n      },\n      displaySets: [\n        {\n          id: 'ptDisplaySet',\n          options: { ...getPTOptions(ptOptionsParams) },\n        },\n      ],\n    },\n  ];\n}\n\nfunction getFusionViewports() {\n  const ptOptionsParams = {\n    colormap: {\n      name: DEFAULT_COLORMAP,\n      opacity: [\n        { value: 0, opacity: 0 },\n        { value: 0.1, opacity: 0.3 },\n        { value: 1, opacity: 0.3 },\n      ],\n    },\n  };\n\n  return [\n    {\n      viewportOptions: {\n        viewportId: 'fusionAxial',\n        viewportType: 'volume',\n        orientation: 'axial',\n        toolGroupId: toolGroupIds.fusion,\n        initialImageOptions: {\n          preset: 'middle', // 'first', 'last', 'middle'\n        },\n        syncGroups: [\n          {\n            type: 'cameraPosition',\n            id: 'axialSync',\n            source: true,\n            target: true,\n          },\n          {\n            type: 'voi',\n            id: 'ctWLSync',\n            source: false,\n            target: true,\n          },\n          {\n            type: 'voi',\n            id: 'fusionWLSync',\n            source: true,\n            target: true,\n          },\n          {\n            type: 'voi',\n            id: 'ptFusionWLSync',\n            source: false,\n            target: true,\n            options: {\n              syncInvertState: false,\n            },\n          },\n        ],\n      },\n      displaySets: [\n        {\n          id: 'ctDisplaySet',\n        },\n        {\n          options: { ...getPTOptions(ptOptionsParams) },\n          id: 'ptDisplaySet',\n        },\n      ],\n    },\n    {\n      viewportOptions: {\n        viewportId: 'fusionSagittal',\n        viewportType: 'volume',\n        orientation: 'sagittal',\n        toolGroupId: toolGroupIds.fusion,\n        initialImageOptions: {\n          preset: 'middle', // 'first', 'last', 'middle'\n        },\n        syncGroups: [\n          {\n            type: 'cameraPosition',\n            id: 'sagittalSync',\n            source: true,\n            target: true,\n          },\n          {\n            type: 'voi',\n            id: 'ctWLSync',\n            source: false,\n            target: true,\n          },\n          {\n            type: 'voi',\n            id: 'fusionWLSync',\n            source: true,\n            target: true,\n          },\n          {\n            type: 'voi',\n            id: 'ptFusionWLSync',\n            source: false,\n            target: true,\n            options: {\n              syncInvertState: false,\n            },\n          },\n        ],\n      },\n      displaySets: [\n        {\n          id: 'ctDisplaySet',\n        },\n        {\n          options: { ...getPTOptions(ptOptionsParams) },\n          id: 'ptDisplaySet',\n        },\n      ],\n    },\n    {\n      viewportOptions: {\n        viewportId: 'fusionCoronal',\n        viewportType: 'volume',\n        orientation: 'coronal',\n        toolGroupId: toolGroupIds.fusion,\n        initialImageOptions: {\n          preset: 'middle', // 'first', 'last', 'middle'\n        },\n        syncGroups: [\n          {\n            type: 'cameraPosition',\n            id: 'coronalSync',\n            source: true,\n            target: true,\n          },\n          {\n            type: 'voi',\n            id: 'ctWLSync',\n            source: false,\n            target: true,\n          },\n          {\n            type: 'voi',\n            id: 'fusionWLSync',\n            source: true,\n            target: true,\n          },\n          {\n            type: 'voi',\n            id: 'ptFusionWLSync',\n            source: false,\n            target: true,\n            options: {\n              syncInvertState: false,\n            },\n          },\n        ],\n      },\n      displaySets: [\n        {\n          id: 'ctDisplaySet',\n        },\n        {\n          options: { ...getPTOptions(ptOptionsParams) },\n          id: 'ptDisplaySet',\n        },\n      ],\n    },\n  ];\n}\n\nfunction getSeriesChartViewport() {\n  return {\n    viewportOptions: {\n      viewportId: 'seriesChart',\n    },\n    displaySets: [\n      {\n        id: 'chartDisplaySet',\n        options: {\n          // This dataset does not require the download of any instance since it is pre-computed locally,\n          // but interleaveTopToBottom.ts was not loading any series because it consider that all viewports\n          // are a Cornerstone viewport which is not true in this case and it waits for all viewports to\n          // have called interleaveTopToBottom(...).\n          skipLoading: true,\n        },\n      },\n    ],\n  };\n}\n\nfunction getCTViewports() {\n  return [\n    {\n      viewportOptions: {\n        viewportId: 'ctAxial',\n        viewportType: 'volume',\n        orientation: 'axial',\n        toolGroupId: toolGroupIds.ct,\n        initialImageOptions: {\n          preset: 'middle', // 'first', 'last', 'middle'\n        },\n        syncGroups: [\n          {\n            type: 'cameraPosition',\n            id: 'axialSync',\n            source: true,\n            target: true,\n          },\n          {\n            type: 'voi',\n            id: 'ctWLSync',\n            source: true,\n            target: true,\n          },\n        ],\n      },\n      displaySets: [\n        {\n          id: 'ctDisplaySet',\n        },\n      ],\n    },\n    {\n      viewportOptions: {\n        viewportId: 'ctSagittal',\n        viewportType: 'volume',\n        orientation: 'sagittal',\n        toolGroupId: toolGroupIds.ct,\n        initialImageOptions: {\n          preset: 'middle',\n        },\n        syncGroups: [\n          {\n            type: 'cameraPosition',\n            id: 'sagittalSync',\n            source: true,\n            target: true,\n          },\n          {\n            type: 'voi',\n            id: 'ctWLSync',\n            source: true,\n            target: true,\n          },\n        ],\n      },\n      displaySets: [\n        {\n          id: 'ctDisplaySet',\n        },\n      ],\n    },\n    {\n      viewportOptions: {\n        viewportId: 'ctCoronal',\n        viewportType: 'volume',\n        orientation: 'coronal',\n        toolGroupId: toolGroupIds.ct,\n        initialImageOptions: {\n          preset: 'middle',\n        },\n        syncGroups: [\n          {\n            type: 'cameraPosition',\n            id: 'coronalSync',\n            source: true,\n            target: true,\n          },\n          {\n            type: 'voi',\n            id: 'ctWLSync',\n            source: true,\n            target: true,\n          },\n        ],\n      },\n      displaySets: [\n        {\n          id: 'ctDisplaySet',\n        },\n      ],\n    },\n  ];\n}\n\nconst defaultProtocol = {\n  id: 'default4D',\n  locked: true,\n  // Don't store this hanging protocol as it applies to the currently active\n  // display set by default\n  // cacheId: null,\n  hasUpdatedPriorsInformation: false,\n  name: 'Default',\n  createdDate: '2023-01-01T00:00:00.000Z',\n  modifiedDate: '2023-01-01T00:00:00.000Z',\n  availableTo: {},\n  editableBy: {},\n  imageLoadStrategy: 'default', // \"default\" , \"interleaveTopToBottom\",  \"interleaveCenter\"\n  protocolMatchingRules: [\n    {\n      attribute: 'ModalitiesInStudy',\n      constraint: {\n        contains: ['CT', 'PT'],\n      },\n    },\n  ],\n  // -1 would be used to indicate active only, whereas other values are\n  // the number of required priors referenced - so 0 means active with\n  // 0 or more priors.\n  numberOfPriorsReferenced: -1,\n  displaySetSelectors: {\n    defaultDisplaySetId: {\n      // Unused currently\n      imageMatchingRules: [],\n      // Matches displaysets, NOT series\n      seriesMatchingRules: [\n        // Try to match series with images by default, to prevent weird display\n        // on SEG/SR containing studies\n        {\n          attribute: 'numImageFrames',\n          constraint: {\n            greaterThan: { value: 0 },\n          },\n        },\n      ],\n      // Can be used to select matching studies\n      // studyMatchingRules: [],\n    },\n    ctDisplaySet: {\n      // Unused currently\n      imageMatchingRules: [],\n      // Matches displaysets, NOT series\n      seriesMatchingRules: [\n        {\n          attribute: 'Modality',\n          constraint: {\n            equals: {\n              value: 'CT',\n            },\n          },\n          required: true,\n        },\n        {\n          attribute: 'isReconstructable',\n          constraint: {\n            equals: {\n              value: true,\n            },\n          },\n          required: true,\n        },\n      ],\n      // Can be used to select matching studies\n      // studyMatchingRules: [],\n    },\n    ptDisplaySet: {\n      // Unused currently\n      imageMatchingRules: [],\n      // Matches displaysets, NOT series\n      seriesMatchingRules: [\n        {\n          attribute: 'Modality',\n          constraint: {\n            equals: 'PT',\n          },\n          required: true,\n        },\n        {\n          attribute: 'isReconstructable',\n          constraint: {\n            equals: {\n              value: true,\n            },\n          },\n          required: true,\n        },\n        {\n          attribute: 'SeriesDescription',\n          constraint: {\n            contains: 'Corrected',\n          },\n        },\n        {\n          weight: 2,\n          attribute: 'SeriesDescription',\n          constraint: {\n            doesNotContain: {\n              value: 'Uncorrected',\n            },\n          },\n        },\n\n        // Should we check if CorrectedImage contains ATTN?\n        // (0028,0051) (CorrectedImage): NORM\\DTIM\\ATTN\\SCAT\\RADL\\DECY\n      ],\n      // Can be used to select matching studies\n      // studyMatchingRules: [],\n    },\n    chartDisplaySet: {\n      // Unused currently\n      imageMatchingRules: [],\n      // Matches displaysets, NOT series\n      seriesMatchingRules: [\n        {\n          attribute: 'Modality',\n          constraint: {\n            equals: {\n              value: 'CHT',\n            },\n          },\n          required: true,\n        },\n      ],\n    },\n  },\n  stages: [\n    {\n      id: 'dataPreparation',\n      name: 'Data Preparation',\n      viewportStructure: {\n        layoutType: 'grid',\n        properties: {\n          rows: 1,\n          columns: 3,\n        },\n      },\n      viewports: [...getPTViewports()],\n      createdDate: '2023-01-01T00:00:00.000Z',\n    },\n\n    {\n      id: 'registration',\n      name: 'Registration',\n      viewportStructure: {\n        layoutType: 'grid',\n        properties: {\n          rows: 3,\n          columns: 3,\n        },\n      },\n      viewports: [...getFusionViewports(), ...getCTViewports(), ...getPTViewports()],\n      createdDate: '2023-01-01T00:00:00.000Z',\n    },\n\n    {\n      id: 'roiQuantification',\n      name: 'ROI Quantification',\n      viewportStructure: {\n        layoutType: 'grid',\n        properties: {\n          rows: 1,\n          columns: 3,\n        },\n      },\n      viewports: [...getFusionViewports()],\n      createdDate: '2023-01-01T00:00:00.000Z',\n    },\n\n    {\n      id: 'kineticAnalysis',\n      name: 'Kinetic Analysis',\n      viewportStructure: {\n        layoutType: 'grid',\n        properties: {\n          rows: 2,\n          columns: 3,\n          layoutOptions: [\n            {\n              x: 0,\n              y: 0,\n              width: 1 / 3,\n              height: 1 / 2,\n            },\n            {\n              x: 1 / 3,\n              y: 0,\n              width: 1 / 3,\n              height: 1 / 2,\n            },\n            {\n              x: 2 / 3,\n              y: 0,\n              width: 1 / 3,\n              height: 1 / 2,\n            },\n            {\n              x: 0,\n              y: 1 / 2,\n              width: 1,\n              height: 1 / 2,\n            },\n          ],\n        },\n      },\n      viewports: [...getFusionViewports(), getSeriesChartViewport()],\n      createdDate: '2023-01-01T00:00:00.000Z',\n    },\n  ],\n};\n\n/**\n * HangingProtocolModule should provide a list of hanging protocols that will be\n * available in OHIF for Modes to use to decide on the structure of the viewports\n * and also the series that hung in the viewports. Each hanging protocol is defined by\n * { name, protocols}. Examples include the default hanging protocol provided by\n * the default extension that shows 2x2 viewports.\n */\n\nfunction getHangingProtocolModule() {\n  return [\n    {\n      name: defaultProtocol.id,\n      protocol: defaultProtocol,\n    },\n  ];\n}\n\nexport default getHangingProtocolModule;\n","import { id } from './id';\nimport commandsModule from './commandsModule';\nimport getPanelModule from './getPanelModule';\nimport getHangingProtocolModule from './getHangingProtocolModule';\nimport { cache } from '@cornerstonejs/core';\n\n/**\n * You can remove any of the following modules if you don't need them.\n */\nconst dynamicVolumeExtension = {\n  /**\n   * Only required property. Should be a unique value across all extensions.\n   * You ID can be anything you want, but it should be unique.\n   */\n  id,\n\n  /**\n   * Perform any pre-registration tasks here. This is called before the extension\n   * is registered. Usually we run tasks such as: configuring the libraries\n   * (e.g. cornerstone, cornerstoneTools, ...) or registering any services that\n   * this extension is providing.\n   */\n  preRegistration: ({ servicesManager, commandsManager, configuration = {} }) => {\n    // TODO: look for the right fix\n    cache.setMaxCacheSize(5 * 1024 * 1024 * 1024);\n  },\n  /**\n   * PanelModule should provide a list of panels that will be available in OHIF\n   * for Modes to consume and render. Each panel is defined by a {name,\n   * iconName, iconLabel, label, component} object. Example of a panel module\n   * is the StudyBrowserPanel that is provided by the default extension in OHIF.\n   */\n  getPanelModule,\n  /**\n   * ViewportModule should provide a list of viewports that will be available in OHIF\n   * for Modes to consume and use in the viewports. Each viewport is defined by\n   * {name, component} object. Example of a viewport module is the CornerstoneViewport\n   * that is provided by the Cornerstone extension in OHIF.\n   */\n  getHangingProtocolModule,\n  /**\n   * CommandsModule should provide a list of commands that will be available in OHIF\n   * for Modes to consume and use in the viewports. Each command is defined by\n   * an object of { actions, definitions, defaultContext } where actions is an\n   * object of functions, definitions is an object of available commands, their\n   * options, and defaultContext is the default context for the command to run against.\n   */\n  getCommandsModule: ({ servicesManager, commandsManager, extensionManager }) => {\n    return commandsModule({\n      servicesManager,\n      commandsManager,\n      extensionManager,\n    });\n  },\n};\n\nexport { dynamicVolumeExtension as default };\n"],"names":["id","packageJson","CHART_MODALITY","SEG_CHART_INSTANCE_UID","utils","guid","ChartDataSOPClassUid","utilities","csToolsUtils","csTools","_getTimePointsDataByTagName","volume","timePointsTag","uniqueTimePoints","imageIds","reduce","timePoints","imageId","timePointValue","DicomMetadataStore","getInstanceByImageId","undefined","add","Set","Array","from","sort","a","b","_getSegmentationData","segmentation","volumesTimePointsCache","displaySetService","volumeCacheKey","volumeId","getActiveDisplaySets","find","displaySet","anInstance","instances","FrameReferenceTime","NumberOfTimeSlices","displaySetInstanceUID","key","cs","_volumeCache","includes","referencedDynamicVolume","getVolume","StudyInstanceUID","StudyDescription","timeData","_","dynamicVolume","getDataInTime","maskVolumeId","pixelCount","length","segmentationRepresentationUID","toolGroupId","color","hexColor","timePointsData","get","timePointsTags","unit","timePointsTagNames","Object","keys","timePointsUnit","i","tagName","curTimePoints","concatTagNames","join","Error","convertedTimePoints","validUnits","divisors","currentUnitIndex","indexOf","divisor","newDivisor","filter","timePoint","map","_convertTimePointsUnit","_getTimePointsData","set","timepointsCount","chartSeriesData","average","acc","cur","chartData","series","label","points","axis","x","y","_getInstanceFromSegmentations","segmentations","WeakMap","segmentationsData","date","seriesDate","time","seriesTime","now","Date","getFullYear","getUTCMonth","slice","getUTCDate","getUTCHours","getUTCMinutes","getUTCSeconds","_getDateTimeStr","allSeries","curSegData","instance","SOPClassUID","Modality","SOPInstanceUID","SeriesDate","SeriesTime","SeriesInstanceUID","SeriesNumber","SeriesDescription","seriesMetadata","updateSegmentationsChartDisplaySet","servicesManager","segmentationService","services","getSegmentations","addSeriesMetadata","addInstances","LABELMAP","Enums","Labelmap","commandsModule","commandsManager","viewportGridService","actions","importedActions","getDynamic4DDisplaySet","TemporalPositionIdentifier","getComputedDisplaySets","getDisplaySetCache","values","isDerived","exportTimeReportCSV","config","options","summaryStats","dynamic4DDisplaySet","cache","csv","calculateStandardDeviation","data","n","mean","value","variance","Math","sqrt","push","PatientID","StudyDate","forEach","segmentationIndex","ijkCoords","headers","maxLength","numTimePoints","t","min","minIJK","max","maxIJK","std","numVoxels","timeIndex","voxelValues","voxelIndex","minimum","maximum","row","csvContent","filename","blob","Blob","type","link","document","createElement","url","URL","createObjectURL","setAttribute","style","visibility","body","appendChild","click","removeChild","swapDynamicWithComputedDisplaySet","computedDisplaySet","displaySetCache","cachedDisplaySetKeys","viewports","getState","viewportsToUpdate","viewport","viewportOptions","displaySetInstanceUIDs","displaySetInstanceUIDIndex","newViewport","viewportId","initialImageOptions","viewportType","orientation","background","setDisplaySetsForViewports","swapComputedWithDynamicDisplaySet","dynamicDisplaySet","computed4DDisplaySet","createNewLabelMapForDynamicVolume","async","activeViewportId","dynamic4DDisplaySetInstanceUID","referenceDisplaySet","cachedDisplaySets","referenceDisplaySetUID","segmentationId","createSegmentationForDisplaySet","toolGroupIds","representationType","hydrateSegmentation","addSegmentationRepresentationToToolGroup","setActiveSegmentationForToolGroup","definitions","commandFn","storeContexts","defaultContext","controlClassNames","sizeClassName","arrowsDirection","labelPosition","Header","title","tooltip","React","className","Tooltip","content","position","tight","tooltipBoxClassName","Icon","name","DynamicVolumeControls","isPlaying","onPlayPauseChange","fps","onFpsChange","minFps","maxFps","currentFrameIndex","onFrameChange","framesLength","onGenerate","onDoubleRangeChange","onDynamicClick","computedView","setComputedView","useState","computeViewMode","setComputeViewMode","SUM","sliderRangeValues","setSliderRangeValues","useEffect","PanelSection","childrenClassName","ButtonGroup","onClick","FrameControls","separated","toString","toUpperCase","AVERAGE","SUBTRACT","InputDoubleRange","onChange","newValues","minValue","showLabel","allowNumberEdit","maxValue","step","Button","IconButton","InputNumber","_extends","SOPClassHandlerId","PanelGenerateImage","cornerstoneViewportService","isCineEnabled","cineService","useCine","useViewportGrid","timePointsRange","setTimePointsRange","timePointsRangeToUseForGenerate","setTimePointsRangeToUseForGenerate","setComputedDisplaySet","setDynamicVolume","frameRate","setFrameRate","setIsPlaying","timePointRendered","setTimePointRendered","displayingComputed","setDisplayingComputed","uuidComputedVolume","useRef","csUtils","uuidDynamicVolume","computedVolumeId","current","renderGeneratedImage","runCommand","evt","EVENTS","VIEWPORT_DATA_CHANGED","unsubscribe","subscribe","evtDetails","viewportData","volumeData","isDynamicVolume","CINE_STATE_CHANGED","displaySetUIDs","getDisplaySetsUIDsForViewport","dynamicVolumeDisplaySet","displaySetUID","getDisplaySetByUID","getVolumes","DYNAMIC_VOLUME_TIME_POINT_INDEX_CHANGED","callback","detail","timePointIndex","eventTarget","addEventListener","removeEventListener","handlePlay","viewportInfo","getViewportInfo","element","playClip","framesPerSecond","handleStop","stopClip","newFrameRate","operationName","dynamicVolumeId","computedVolume","volumeLoader","createComputedVolume","vals","targets","dataInTime","cstUtils","loadStatus","loaded","getScalarData","getRenderingEngine","render","volumeLoaderSchema","split","metadata","isMultiFrame","numImageFrames","uid","madeInClient","FrameOfReferenceUID","propTypes","PropTypes","measurementService","getMeasurements","isRequired","VALUE_TYPES","extensionManager","useTranslation","setSegmentations","disabled","added","SEGMENTATION_ADDED","updated","SEGMENTATION_UPDATED","removed","SEGMENTATION_REMOVED","subscriptions","unsub","ActionButtons","iconName","iconLabel","component","wrappedDynamicDataPanel","DynamicDataPanel","wrappedDynamicToolbox","Toolbox","buttonSectionId","wrappedDynamicExport","DynamicExport","DEFAULT_COLORMAP","getPTOptions","colormap","voiInverted","blendMode","voi","windowWidth","windowCenter","getPTViewports","ptOptionsParams","opacity","preset","syncGroups","source","target","displaySets","getFusionViewports","syncInvertState","defaultProtocol","locked","hasUpdatedPriorsInformation","createdDate","modifiedDate","availableTo","editableBy","imageLoadStrategy","protocolMatchingRules","attribute","constraint","contains","numberOfPriorsReferenced","displaySetSelectors","defaultDisplaySetId","imageMatchingRules","seriesMatchingRules","greaterThan","ctDisplaySet","equals","required","ptDisplaySet","weight","doesNotContain","chartDisplaySet","stages","viewportStructure","layoutType","properties","rows","columns","layoutOptions","width","height","skipLoading","dynamicVolumeExtension","preRegistration","configuration","setMaxCacheSize","getPanelModule","getHangingProtocolModule","protocol","getCommandsModule"],"sourceRoot":""}